bility of the
\&\fIMakefile.SH\fR to get the value of this into the proper command.
You must be prepared to do the \fI~name\fR expansion yourself.
The standard distribution will put nothing in this directory.
After perl has been installed, users may install their own local
man3 pages in this directory with
MakeMaker \fIMakefile.PL\fR
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """siteman3direxp""" 4
.el .IP "\f(CWsiteman3direxp\fR" 4
.IX Item "siteman3direxp"
From \fIsiteman3dir.U\fR:
.Sp
This variable is the same as the siteman3dir variable, but is filename
expanded at configuration time, for convenient use in makefiles.
.ie n .IP """siteprefix""" 4
.el .IP "\f(CWsiteprefix\fR" 4
.IX Item "siteprefix"
From \fIsiteprefix.U\fR:
.Sp
This variable holds the full absolute path of the directory below
which the user will install add-on packages.
See \f(CW\*(C`INSTALL\*(C'\fR for usage and examples.
.ie n .IP """siteprefixexp""" 4
.el .IP "\f(CWsiteprefixexp\fR" 4
.IX Item "siteprefixexp"
From \fIsiteprefix.U\fR:
.Sp
This variable holds the full absolute path of the directory below
which the user will install add-on packages.  Derived from siteprefix.
.ie n .IP """sitescript""" 4
.el .IP "\f(CWsitescript\fR" 4
.IX Item "sitescript"
From \fIsitescript.U\fR:
.Sp
This variable holds the name of the directory in which the user wants
to put add-on publicly executable files for the package in question.  It
is most often a local directory such as \fI/usr/local/bin\fR. Programs using
this variable must be prepared to deal with \fI~name\fR substitution.
The standard distribution will put nothing in this directory.
After perl has been installed, users may install their own local
scripts in this directory with
MakeMaker \fIMakefile.PL\fR
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """sitescriptexp""" 4
.el .IP "\f(CWsitescriptexp\fR" 4
.IX Item "sitescriptexp"
From \fIsitescript.U\fR:
.Sp
This is the same as the sitescript variable, but is filename expanded at
configuration time, for use in your makefiles.
.ie n .IP """sizesize""" 4
.el .IP "\f(CWsizesize\fR" 4
.IX Item "sizesize"
From \fIsizesize.U\fR:
.Sp
This variable contains the size of a sizetype in bytes.
.ie n .IP """sizetype""" 4
.el .IP "\f(CWsizetype\fR" 4
.IX Item "sizetype"
From \fIsizetype.U\fR:
.Sp
This variable defines sizetype to be something like size_t,
unsigned long, or whatever type is used to declare length
parameters for string functions.
.ie n .IP """sleep""" 4
.el .IP "\f(CWsleep\fR" 4
.IX Item "sleep"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """sLOCALTIME_max""" 4
.el .IP "\f(CWsLOCALTIME_max\fR" 4
.IX Item "sLOCALTIME_max"
From \fItime_size.U\fR:
.Sp
This variable defines the maximum value of the time_t offset that
the system function localtime () accepts
.ie n .IP """sLOCALTIME_min""" 4
.el .IP "\f(CWsLOCALTIME_min\fR" 4
.IX Item "sLOCALTIME_min"
From \fItime_size.U\fR:
.Sp
This variable defines the minimum value of the time_t offset that
the system function localtime () accepts
.ie n .IP """smail""" 4
.el .IP "\f(CWsmail\fR" 4
.IX Item "smail"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """so""" 4
.el .IP "\f(CWso\fR" 4
.IX Item "so"
From \fIso.U\fR:
.Sp
This variable holds the extension used to identify shared libraries
(also known as shared objects) on the system. Usually set to \f(CW\*(C`so\*(C'\fR.
.ie n .IP """sockethdr""" 4
.el .IP "\f(CWsockethdr\fR" 4
.IX Item "sockethdr"
From \fId_socket.U\fR:
.Sp
This variable has any cpp \f(CW\*(C`\-I\*(C'\fR flags needed for socket support.
.ie n .IP """socketlib""" 4
.el .IP "\f(CWsocketlib\fR" 4
.IX Item "socketlib"
From \fId_socket.U\fR:
.Sp
This variable has the names of any libraries needed for socket support.
.ie n .IP """socksizetype""" 4
.el .IP "\f(CWsocksizetype\fR" 4
.IX Item "socksizetype"
From \fIsocksizetype.U\fR:
.Sp
This variable holds the type used for the size argument
for various socket calls like accept.  Usual values include
socklen_t, size_t, and int.
.ie n .IP """sort""" 4
.el .IP "\f(CWsort\fR" 4
.IX Item "sort"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the sort program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`sort\*(C'\fR and is not useful.
.ie n .IP """spackage""" 4
.el .IP "\f(CWspackage\fR" 4
.IX Item "spackage"
From \fIpackage.U\fR:
.Sp
This variable contains the name of the package being constructed,
with the first letter uppercased, \fIi.e\fR. suitable for starting
sentences.
.ie n .IP """spitshell""" 4
.el .IP "\f(CWspitshell\fR" 4
.IX Item "spitshell"
From \fIspitshell.U\fR:
.Sp
This variable contains the command necessary to spit out a runnable
shell on this system.  It is either cat or a grep \f(CW\*(C`\-v\*(C'\fR for # comments.
.ie n .IP """sPRId64""" 4
.el .IP "\f(CWsPRId64\fR" 4
.IX Item "sPRId64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit decimal numbers (format \f(CW\*(C`d\*(C'\fR) for output.
.ie n .IP """sPRIeldbl""" 4
.el .IP "\f(CWsPRIeldbl\fR" 4
.IX Item "sPRIeldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`e\*(C'\fR) for output.
.ie n .IP """sPRIEUldbl""" 4
.el .IP "\f(CWsPRIEUldbl\fR" 4
.IX Item "sPRIEUldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`E\*(C'\fR) for output.
The \f(CW\*(C`U\*(C'\fR in the name is to separate this from sPRIeldbl so that even
case-blind systems can see the difference.
.ie n .IP """sPRIfldbl""" 4
.el .IP "\f(CWsPRIfldbl\fR" 4
.IX Item "sPRIfldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`f\*(C'\fR) for output.
.ie n .IP """sPRIFUldbl""" 4
.el .IP "\f(CWsPRIFUldbl\fR" 4
.IX Item "sPRIFUldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`F\*(C'\fR) for output.
The \f(CW\*(C`U\*(C'\fR in the name is to separate this from sPRIfldbl so that even
case-blind systems can see the difference.
.ie n .IP """sPRIgldbl""" 4
.el .IP "\f(CWsPRIgldbl\fR" 4
.IX Item "sPRIgldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`g\*(C'\fR) for output.
.ie n .IP """sPRIGUldbl""" 4
.el .IP "\f(CWsPRIGUldbl\fR" 4
.IX Item "sPRIGUldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`G\*(C'\fR) for output.
The \f(CW\*(C`U\*(C'\fR in the name is to separate this from sPRIgldbl so that even
case-blind systems can see the difference.
.ie n .IP """sPRIi64""" 4
.el .IP "\f(CWsPRIi64\fR" 4
.IX Item "sPRIi64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit decimal numbers (format \f(CW\*(C`i\*(C'\fR) for output.
.ie n .IP """sPRIo64""" 4
.el .IP "\f(CWsPRIo64\fR" 4
.IX Item "sPRIo64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit octal numbers (format \f(CW\*(C`o\*(C'\fR) for output.
.ie n .IP """sPRIu64""" 4
.el .IP "\f(CWsPRIu64\fR" 4
.IX Item "sPRIu64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit unsigned decimal numbers (format \f(CW\*(C`u\*(C'\fR) for output.
.ie n .IP """sPRIx64""" 4
.el .IP "\f(CWsPRIx64\fR" 4
.IX Item "sPRIx64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit hexadecimal numbers (format \f(CW\*(C`x\*(C'\fR) for output.
.ie n .IP """sPRIXU64""" 4
.el .IP "\f(CWsPRIXU64\fR" 4
.IX Item "sPRIXU64"
From \fIquadfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format 64\-bit hExADECimAl numbers (format \f(CW\*(C`X\*(C'\fR) for output.
The \f(CW\*(C`U\*(C'\fR in the name is to separate this from sPRIx64 so that even
case-blind systems can see the difference.
.ie n .IP """srand48_r_proto""" 4
.el .IP "\f(CWsrand48_r_proto\fR" 4
.IX Item "srand48_r_proto"
From \fId_srand48_r.U\fR:
.Sp
This variable encodes the prototype of srand48_r.
It is zero if d_srand48_r is undef, and one of the
\&\f(CW\*(C`REENTRANT_PROTO_T_ABC\*(C'\fR macros of \fIreentr.h\fR if d_srand48_r
is defined.
.ie n .IP """srandom_r_proto""" 4
.el .IP "\f(CWsrandom_r_proto\fR" 4
.IX Item "srandom_r_proto"
From \fId_srandom_r.U\fR:
.Sp
This variable encodes the prototype of srandom_r.
It is zero if d_srandom_r is undef, and one of the
\&\f(CW\*(C`REENTRANT_PROTO_T_ABC\*(C'\fR macros of \fIreentr.h\fR if d_srandom_r
is defined.
.ie n .IP """src""" 4
.el .IP "\f(CWsrc\fR" 4
.IX Item "src"
From \fIsrc.U\fR:
.Sp
This variable holds the (possibly relative) path of the package source.
It is up to the Makefile to use this variable and set \f(CW\*(C`VPATH\*(C'\fR accordingly
to find the sources remotely.  Use \f(CW$pkgsrc\fR to have an absolute path.
.ie n .IP """sSCNfldbl""" 4
.el .IP "\f(CWsSCNfldbl\fR" 4
.IX Item "sSCNfldbl"
From \fIlongdblfio.U\fR:
.Sp
This variable, if defined, contains the string used by stdio to
format long doubles (format \f(CW\*(C`f\*(C'\fR) for input.
.ie n .IP """ssizetype""" 4
.el .IP "\f(CWssizetype\fR" 4
.IX Item "ssizetype"
From \fIssizetype.U\fR:
.Sp
This variable defines ssizetype to be something like ssize_t,
long or int.  It is used by functions that return a count
of bytes or an error condition.  It must be a signed type.
We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
.ie n .IP """st_ino_sign""" 4
.el .IP "\f(CWst_ino_sign\fR" 4
.IX Item "st_ino_sign"
From \fIst_ino_def.U\fR:
.Sp
This variable contains the signedness of struct stat's st_ino.
1 for unsigned, \-1 for signed.
.ie n .IP """st_ino_size""" 4
.el .IP "\f(CWst_ino_size\fR" 4
.IX Item "st_ino_size"
From \fIst_ino_def.U\fR:
.Sp
This variable contains the size of struct stat's st_ino in bytes.
.ie n .IP """startperl""" 4
.el .IP "\f(CWstartperl\fR" 4
.IX Item "startperl"
From \fIstartperl.U\fR:
.Sp
This variable contains the string to put on the front of a perl
script to make sure (hopefully) that it runs with perl and not some
shell. Of course, that leading line must be followed by the classical
perl idiom:
eval 'exec perl \-S \f(CW$0\fR ${1+\f(CW$@\fR}'
if \f(CW$running_under_some_shell\fR;
to guarantee perl startup should the shell execute the script. Note
that this magic incantation is not understood by csh.
.ie n .IP """startsh""" 4
.el .IP "\f(CWstartsh\fR" 4
.IX Item "startsh"
From \fIstartsh.U\fR:
.Sp
This variable contains the string to put on the front of a shell
script to make sure (hopefully) that it runs with sh and not some
other shell.
.ie n .IP """static_ext""" 4
.el .IP "\f(CWstatic_ext\fR" 4
.IX Item "static_ext"
From \fIExtensions.U\fR:
.Sp
This variable holds a list of \f(CW\*(C`XS\*(C'\fR extension files we want to
link statically into the package.  It is used by Makefile.
.ie n .IP """stdchar""" 4
.el .IP "\f(CWstdchar\fR" 4
.IX Item "stdchar"
From \fIstdchar.U\fR:
.Sp
This variable conditionally defines \f(CW\*(C`STDCHAR\*(C'\fR to be the type of char
used in \fIstdio.h\fR.  It has the values \*(L"unsigned char\*(R" or \f(CW\*(C`char\*(C'\fR.
.ie n .IP """stdio_base""" 4
.el .IP "\f(CWstdio_base\fR" 4
.IX Item "stdio_base"
From \fId_stdstdio.U\fR:
.Sp
This variable defines how, given a \f(CW\*(C`FILE\*(C'\fR pointer, fp, to access the
_base field (or equivalent) of \fIstdio.h\fR's \f(CW\*(C`FILE\*(C'\fR structure.  This will
be used to define the macro FILE_base(fp).
.ie n .IP """stdio_bufsiz""" 4
.el .IP "\f(CWstdio_bufsiz\fR" 4
.IX Item "stdio_bufsiz"
From \fId_stdstdio.U\fR:
.Sp
This variable defines how, given a \f(CW\*(C`FILE\*(C'\fR pointer, fp, to determine
the number of bytes store in the I/O buffer pointer to by the
_base field (or equivalent) of \fIstdio.h\fR's \f(CW\*(C`FILE\*(C'\fR structure.  This will
be used to define the macro FILE_bufsiz(fp).
.ie n .IP """stdio_cnt""" 4
.el .IP "\f(CWstdio_cnt\fR" 4
.IX Item "stdio_cnt"
From \fId_stdstdio.U\fR:
.Sp
This variable defines how, given a \f(CW\*(C`FILE\*(C'\fR pointer, fp, to access the
_cnt field (or equivalent) of \fIstdio.h\fR's \f(CW\*(C`FILE\*(C'\fR structure.  This will
be used to define the macro FILE_cnt(fp).
.ie n .IP """stdio_filbuf""" 4
.el .IP "\f(CWstdio_filbuf\fR" 4
.IX Item "stdio_filbuf"
From \fId_stdstdio.U\fR:
.Sp
This variable defines how, given a \f(CW\*(C`FILE\*(C'\fR pointer, fp, to tell
stdio to refill its internal buffers (?).  This will
be used to define the macro FILE_filbuf(fp).
.ie n .IP """stdio_ptr""" 4
.el .IP "\f(CWstdio_ptr\fR" 4
.IX Item "stdio_ptr"
From \fId_stdstdio.U\fR:
.Sp
This variable defines how, given a \f(CW\*(C`FILE\*(C'\fR pointer, fp, to access the
_ptr field (or equivalent) of \fIstdio.h\fR's \f(CW\*(C`FILE\*(C'\fR structure.  This will
be used to define the macro FILE_ptr(fp).
.ie n .IP """stdio_stream_array""" 4
.el .IP "\f(CWstdio_stream_array\fR" 4
.IX Item "stdio_stream_array"
From \fIstdio_streams.U\fR:
.Sp
This variable tells the name of the array holding the stdio streams.
Usual values include _iob, _\|_iob, and _\|_sF.
.ie n .IP """strerror_r_proto""" 4
.el .IP "\f(CWstrerror_r_proto\fR" 4
.IX Item "strerror_r_proto"
From \fId_strerror_r.U\fR:
.Sp
This variable encodes the prototype of strerror_r.
It is zero if d_strerror_r is undef, and one of the
\&\f(CW\*(C`REENTRANT_PROTO_T_ABC\*(C'\fR macros of \fIreentr.h\fR if d_strerror_r
is defined.
.ie n .IP """strings""" 4
.el .IP "\f(CWstrings\fR" 4
.IX Item "strings"
From \fIi_string.U\fR:
.Sp
This variable holds the full path of the string header that will be
used. Typically \fI/usr/include/string.h\fR or \fI/usr/include/strings.h\fR.
.ie n .IP """submit""" 4
.el .IP "\f(CWsubmit\fR" 4
.IX Item "submit"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """subversion""" 4
.el .IP "\f(CWsubversion\fR" 4
.IX Item "subversion"
From \fIpatchlevel.U\fR:
.Sp
The subversion level of this package.
The value of subversion comes from the \fIpatchlevel.h\fR file.
In a version number such as 5.6.1, this is the \f(CW1\fR.
In \fIpatchlevel.h\fR, this is referred to as \f(CW\*(C`PERL_SUBVERSION\*(C'\fR.
This is unique to perl.
.ie n .IP """sysman""" 4
.el .IP "\f(CWsysman\fR" 4
.IX Item "sysman"
From \fIsysman.U\fR:
.Sp
This variable holds the place where the manual is located on this
system. It is not the place where the user wants to put his manual
pages. Rather it is the place where Configure may look to find manual
for unix commands (section 1 of the manual usually). See mansrc.
.SS "t"
.IX Subsection "t"
.ie n .IP """tail""" 4
.el .IP "\f(CWtail\fR" 4
.IX Item "tail"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """tar""" 4
.el .IP "\f(CWtar\fR" 4
.IX Item "tar"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """targetarch""" 4
.el .IP "\f(CWtargetarch\fR" 4
.IX Item "targetarch"
From \fICross.U\fR:
.Sp
If cross-compiling, this variable contains the target architecture.
If not, this will be empty.
.ie n .IP """tbl""" 4
.el .IP "\f(CWtbl\fR" 4
.IX Item "tbl"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """tee""" 4
.el .IP "\f(CWtee\fR" 4
.IX Item "tee"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """test""" 4
.el .IP "\f(CWtest\fR" 4
.IX Item "test"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the test program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`test\*(C'\fR and is not useful.
.ie n .IP """timeincl""" 4
.el .IP "\f(CWtimeincl\fR" 4
.IX Item "timeincl"
From \fIi_time.U\fR:
.Sp
This variable holds the full path of the included time header(s).
.ie n .IP """timetype""" 4
.el .IP "\f(CWtimetype\fR" 4
.IX Item "timetype"
From \fId_time.U\fR:
.Sp
This variable holds the type returned by \fItime()\fR. It can be long,
or time_t on \f(CW\*(C`BSD\*(C'\fR sites (in which case <sys/types.h> should be
included). Anyway, the type Time_t should be used.
.ie n .IP """tmpnam_r_proto""" 4
.el .IP "\f(CWtmpnam_r_proto\fR" 4
.IX Item "tmpnam_r_proto"
From \fId_tmpnam_r.U\fR:
.Sp
This variable encodes the prototype of tmpnam_r.
It is zero if d_tmpnam_r is undef, and one of the
\&\f(CW\*(C`REENTRANT_PROTO_T_ABC\*(C'\fR macros of \fIreentr.h\fR if d_tmpnam_r
is defined.
.ie n .IP """to""" 4
.el .IP "\f(CWto\fR" 4
.IX Item "to"
From \fICross.U\fR:
.Sp
This variable contains the command used by Configure
to copy to from the target host.  Useful and available
only during Perl build.
The string \f(CW\*(C`:\*(C'\fR if not cross-compiling.
.ie n .IP """touch""" 4
.el .IP "\f(CWtouch\fR" 4
.IX Item "touch"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the touch program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`touch\*(C'\fR and is not useful.
.ie n .IP """tr""" 4
.el .IP "\f(CWtr\fR" 4
.IX Item "tr"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the tr program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`tr\*(C'\fR and is not useful.
.ie n .IP """trnl""" 4
.el .IP "\f(CWtrnl\fR" 4
.IX Item "trnl"
From \fItrnl.U\fR:
.Sp
This variable contains the value to be passed to the \fItr\fR\|(1)
command to transliterate a newline.  Typical values are
\&\f(CW\*(C`\e012\*(C'\fR and \f(CW\*(C`\en\*(C'\fR.  This is needed for \f(CW\*(C`EBCDIC\*(C'\fR systems where
newline is not necessarily \f(CW\*(C`\e012\*(C'\fR.
.ie n .IP """troff""" 4
.el .IP "\f(CWtroff\fR" 4
.IX Item "troff"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """ttyname_r_proto""" 4
.el .IP "\f(CWttyname_r_proto\fR" 4
.IX Item "ttyname_r_proto"
From \fId_ttyname_r.U\fR:
.Sp
This variable encodes the prototype of ttyname_r.
It is zero if d_ttyname_r is undef, and one of the
\&\f(CW\*(C`REENTRANT_PROTO_T_ABC\*(C'\fR macros of \fIreentr.h\fR if d_ttyname_r
is defined.
.SS "u"
.IX Subsection "u"
.ie n .IP """u16size""" 4
.el .IP "\f(CWu16size\fR" 4
.IX Item "u16size"
From \fIperlxv.U\fR:
.Sp
This variable is the size of an U16 in bytes.
.ie n .IP """u16type""" 4
.el .IP "\f(CWu16type\fR" 4
.IX Item "u16type"
From \fIperlxv.U\fR:
.Sp
This variable contains the C type used for Perl's U16.
.ie n .IP """u32size""" 4
.el .IP "\f(CWu32size\fR" 4
.IX Item "u32size"
From \fIperlxv.U\fR:
.Sp
This variable is the size of an U32 in bytes.
.ie n .IP """u32type""" 4
.el .IP "\f(CWu32type\fR" 4
.IX Item "u32type"
From \fIperlxv.U\fR:
.Sp
This variable contains the C type used for Perl's U32.
.ie n .IP """u64size""" 4
.el .IP "\f(CWu64size\fR" 4
.IX Item "u64size"
From \fIperlxv.U\fR:
.Sp
This variable is the size of an U64 in bytes.
.ie n .IP """u64type""" 4
.el .IP "\f(CWu64type\fR" 4
.IX Item "u64type"
From \fIperlxv.U\fR:
.Sp
This variable contains the C type used for Perl's U64.
.ie n .IP """u8size""" 4
.el .IP "\f(CWu8size\fR" 4
.IX Item "u8size"
From \fIperlxv.U\fR:
.Sp
This variable is the size of an U8 in bytes.
.ie n .IP """u8type""" 4
.el .IP "\f(CWu8type\fR" 4
.IX Item "u8type"
From \fIperlxv.U\fR:
.Sp
This variable contains the C type used for Perl's U8.
.ie n .IP """uidformat""" 4
.el .IP "\f(CWuidformat\fR" 4
.IX Item "uidformat"
From \fIuidf.U\fR:
.Sp
This variable contains the format string used for printing a Uid_t.
.ie n .IP """uidsign""" 4
.el .IP "\f(CWuidsign\fR" 4
.IX Item "uidsign"
From \fIuidsign.U\fR:
.Sp
This variable contains the signedness of a uidtype.
1 for unsigned, \-1 for signed.
.ie n .IP """uidsize""" 4
.el .IP "\f(CWuidsize\fR" 4
.IX Item "uidsize"
From \fIuidsize.U\fR:
.Sp
This variable contains the size of a uidtype in bytes.
.ie n .IP """uidtype""" 4
.el .IP "\f(CWuidtype\fR" 4
.IX Item "uidtype"
From \fIuidtype.U\fR:
.Sp
This variable defines Uid_t to be something like uid_t, int,
ushort, or whatever type is used to declare user ids in the kernel.
.ie n .IP """uname""" 4
.el .IP "\f(CWuname\fR" 4
.IX Item "uname"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the uname program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`uname\*(C'\fR and is not useful.
.ie n .IP """uniq""" 4
.el .IP "\f(CWuniq\fR" 4
.IX Item "uniq"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the uniq program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`uniq\*(C'\fR and is not useful.
.ie n .IP """uquadtype""" 4
.el .IP "\f(CWuquadtype\fR" 4
.IX Item "uquadtype"
From \fIquadtype.U\fR:
.Sp
This variable defines Uquad_t to be something like unsigned long,
unsigned int, unsigned long long, uint64_t, or whatever type is
used for 64\-bit integers.
.ie n .IP """use5005threads""" 4
.el .IP "\f(CWuse5005threads\fR" 4
.IX Item "use5005threads"
From \fIusethreads.U\fR:
.Sp
This variable conditionally defines the \s-1USE_5005THREADS\s0 symbol,
and indicates that Perl should be built to use the 5.005\-based
threading implementation. Only valid up to 5.8.x.
.ie n .IP """use64bitall""" 4
.el .IP "\f(CWuse64bitall\fR" 4
.IX Item "use64bitall"
From \fIuse64bits.U\fR:
.Sp
This variable conditionally defines the \s-1USE_64_BIT_ALL\s0 symbol,
and indicates that 64\-bit integer types should be used
when available.  The maximal possible
64\-bitness is employed: \s-1LP64\s0 or \s-1ILP64,\s0 meaning that you will
be able to use more than 2 gigabytes of memory.  This mode is
even more binary incompatible than \s-1USE_64_BIT_INT.\s0 You may not
be able to run the resulting executable in a 32\-bit \f(CW\*(C`CPU\*(C'\fR at all or
you may need at least to reboot your \f(CW\*(C`OS\*(C'\fR to 64\-bit mode.
.ie n .IP """use64bitint""" 4
.el .IP "\f(CWuse64bitint\fR" 4
.IX Item "use64bitint"
From \fIuse64bits.U\fR:
.Sp
This variable conditionally defines the \s-1USE_64_BIT_INT\s0 symbol,
and indicates that 64\-bit integer types should be used
when available.  The minimal possible 64\-bitness
is employed, just enough to get 64\-bit integers into Perl.
This may mean using for example \*(L"long longs\*(R", while your memory
may still be limited to 2 gigabytes.
.ie n .IP """usecrosscompile""" 4
.el .IP "\f(CWusecrosscompile\fR" 4
.IX Item "usecrosscompile"
From \fICross.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_CROSS_COMPILE\*(C'\fR symbol,
and indicates that Perl has been cross-compiled.
.ie n .IP """usedevel""" 4
.el .IP "\f(CWusedevel\fR" 4
.IX Item "usedevel"
From \fIDevel.U\fR:
.Sp
This variable indicates that Perl was configured with development
features enabled.  This should not be done for production builds.
.ie n .IP """usedl""" 4
.el .IP "\f(CWusedl\fR" 4
.IX Item "usedl"
From \fIdlsrc.U\fR:
.Sp
This variable indicates if the system supports dynamic
loading of some sort.  See also dlsrc and dlobj.
.ie n .IP """usedtrace""" 4
.el .IP "\f(CWusedtrace\fR" 4
.IX Item "usedtrace"
From \fIusedtrace.U\fR:
.Sp
This variable indicates whether we are compiling with dtrace
support. See also dtrace.
.ie n .IP """usefaststdio""" 4
.el .IP "\f(CWusefaststdio\fR" 4
.IX Item "usefaststdio"
From \fIusefaststdio.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_FAST_STDIO\*(C'\fR symbol,
and indicates that Perl should be built to use \f(CW\*(C`fast stdio\*(C'\fR.
Defaults to define in Perls 5.8 and earlier, to undef later.
.ie n .IP """useithreads""" 4
.el .IP "\f(CWuseithreads\fR" 4
.IX Item "useithreads"
From \fIusethreads.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_ITHREADS\*(C'\fR symbol,
and indicates that Perl should be built to use the interpreter-based
threading implementation.
.ie n .IP """usekernprocpathname""" 4
.el .IP "\f(CWusekernprocpathname\fR" 4
.IX Item "usekernprocpathname"
From \fIusekernprocpathname.U\fR:
.Sp
This variable, indicates that we can use sysctl with
\&\f(CW\*(C`KERN_PROC_PATHNAME\*(C'\fR to get a full path for the executable, and hence
convert $^X to an absolute path.
.ie n .IP """uselargefiles""" 4
.el .IP "\f(CWuselargefiles\fR" 4
.IX Item "uselargefiles"
From \fIuselfs.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_LARGE_FILES\*(C'\fR symbol,
and indicates that large file interfaces should be used when
available.
.ie n .IP """uselongdouble""" 4
.el .IP "\f(CWuselongdouble\fR" 4
.IX Item "uselongdouble"
From \fIuselongdbl.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_LONG_DOUBLE\*(C'\fR symbol,
and indicates that long doubles should be used when available.
.ie n .IP """usemallocwrap""" 4
.el .IP "\f(CWusemallocwrap\fR" 4
.IX Item "usemallocwrap"
From \fImallocsrc.U\fR:
.Sp
This variable contains y if we are wrapping malloc to prevent
integer overflow during size calculations.
.ie n .IP """usemorebits""" 4
.el .IP "\f(CWusemorebits\fR" 4
.IX Item "usemorebits"
From \fIusemorebits.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_MORE_BITS\*(C'\fR symbol,
and indicates that explicit 64\-bit interfaces and long doubles
should be used when available.
.ie n .IP """usemultiplicity""" 4
.el .IP "\f(CWusemultiplicity\fR" 4
.IX Item "usemultiplicity"
From \fIusemultiplicity.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`MULTIPLICITY\*(C'\fR symbol,
and indicates that Perl should be built to use multiplicity.
.ie n .IP """usemymalloc""" 4
.el .IP "\f(CWusemymalloc\fR" 4
.IX Item "usemymalloc"
From \fImallocsrc.U\fR:
.Sp
This variable contains y if the malloc that comes with this package
is desired over the system's version of malloc.  People often include
special versions of malloc for efficiency, but such versions are often
less portable.  See also mallocsrc and mallocobj.
If this is \f(CW\*(C`y\*(C'\fR, then \-lmalloc is removed from \f(CW$libs\fR.
.ie n .IP """usenm""" 4
.el .IP "\f(CWusenm\fR" 4
.IX Item "usenm"
From \fIusenm.U\fR:
.Sp
This variable contains \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR depending whether the
nm extraction is wanted or not.
.ie n .IP """usensgetexecutablepath""" 4
.el .IP "\f(CWusensgetexecutablepath\fR" 4
.IX Item "usensgetexecutablepath"
From \fIusensgetexecutablepath.U\fR:
.Sp
This symbol, if defined, indicates that we can use _NSGetExecutablePath
and realpath to get a full path for the executable, and hence convert
$^X to an absolute path.
.ie n .IP """useopcode""" 4
.el .IP "\f(CWuseopcode\fR" 4
.IX Item "useopcode"
From \fIExtensions.U\fR:
.Sp
This variable holds either \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR to indicate
whether the Opcode extension should be used.  The sole
use for this currently is to allow an easy mechanism
for users to skip the Opcode extension from the Configure
command line.
.ie n .IP """useperlio""" 4
.el .IP "\f(CWuseperlio\fR" 4
.IX Item "useperlio"
From \fIuseperlio.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_PERLIO\*(C'\fR symbol,
and indicates that the PerlIO abstraction should be
used throughout.
.ie n .IP """useposix""" 4
.el .IP "\f(CWuseposix\fR" 4
.IX Item "useposix"
From \fIExtensions.U\fR:
.Sp
This variable holds either \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR to indicate
whether the \f(CW\*(C`POSIX\*(C'\fR extension should be used.  The sole
use for this currently is to allow an easy mechanism
for hints files to indicate that \f(CW\*(C`POSIX\*(C'\fR will not compile
on a particular system.
.ie n .IP """usereentrant""" 4
.el .IP "\f(CWusereentrant\fR" 4
.IX Item "usereentrant"
From \fIusethreads.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_REENTRANT_API\*(C'\fR symbol,
which indicates that the thread code may try to use the various
_r versions of library functions.  This is only potentially
meaningful if usethreads is set and is very experimental, it is
not even prompted for.
.ie n .IP """userelocatableinc""" 4
.el .IP "\f(CWuserelocatableinc\fR" 4
.IX Item "userelocatableinc"
From \fIbin.U\fR:
.Sp
This variable is set to true to indicate that perl should relocate
@\f(CW\*(C`INC\*(C'\fR entries at runtime based on the path to the perl binary.
Any @\f(CW\*(C`INC\*(C'\fR paths starting \fI.../\fR are relocated relative to the directory
containing the perl binary, and a logical cleanup of the path is then
made around the join point (removing \fIdir/../\fR pairs)
.ie n .IP """usesfio""" 4
.el .IP "\f(CWusesfio\fR" 4
.IX Item "usesfio"
From \fId_sfio.U\fR:
.Sp
This variable is set to true when the user agrees to use sfio.
It is set to false when sfio is not available or when the user
explicitly requests not to use sfio.  It is here primarily so
that command-line settings can override the auto-detection of
d_sfio without running into a \*(L"\s-1WHOA THERE\*(R".\s0
.ie n .IP """useshrplib""" 4
.el .IP "\f(CWuseshrplib\fR" 4
.IX Item "useshrplib"
From \fIlibperl.U\fR:
.Sp
This variable is set to \f(CW\*(C`true\*(C'\fR if the user wishes
to build a shared libperl, and \f(CW\*(C`false\*(C'\fR otherwise.
.ie n .IP """usesitecustomize""" 4
.el .IP "\f(CWusesitecustomize\fR" 4
.IX Item "usesitecustomize"
From \fId_sitecustomize.U\fR:
.Sp
This variable is set to true when the user requires a mechanism that
allows the sysadmin to add entries to @\f(CW\*(C`INC\*(C'\fR at runtime.  This variable
being set, makes perl run \fI$\fIsitelib/sitecustomize.pl\fI\fR at startup.
.ie n .IP """usesocks""" 4
.el .IP "\f(CWusesocks\fR" 4
.IX Item "usesocks"
From \fIusesocks.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_SOCKS\*(C'\fR symbol,
and indicates that Perl should be built to use \f(CW\*(C`SOCKS\*(C'\fR.
.ie n .IP """usethreads""" 4
.el .IP "\f(CWusethreads\fR" 4
.IX Item "usethreads"
From \fIusethreads.U\fR:
.Sp
This variable conditionally defines the \f(CW\*(C`USE_THREADS\*(C'\fR symbol,
and indicates that Perl should be built to use threads.
.ie n .IP """usevendorprefix""" 4
.el .IP "\f(CWusevendorprefix\fR" 4
.IX Item "usevendorprefix"
From \fIvendorprefix.U\fR:
.Sp
This variable tells whether the vendorprefix
and consequently other vendor* paths are in use.
.ie n .IP """useversionedarchname""" 4
.el .IP "\f(CWuseversionedarchname\fR" 4
.IX Item "useversionedarchname"
From \fIarchname.U\fR:
.Sp
This variable indicates whether to include the \f(CW$api_versionstring\fR
as a component of the \f(CW$archname\fR.
.ie n .IP """usevfork""" 4
.el .IP "\f(CWusevfork\fR" 4
.IX Item "usevfork"
From \fId_vfork.U\fR:
.Sp
This variable is set to true when the user accepts to use vfork.
It is set to false when no vfork is available or when the user
explicitly requests not to use vfork.
.ie n .IP """usrinc""" 4
.el .IP "\f(CWusrinc\fR" 4
.IX Item "usrinc"
From \fIusrinc.U\fR:
.Sp
This variable holds the path of the include files, which is
usually \fI/usr/include\fR. It is mainly used by other Configure units.
.ie n .IP """uuname""" 4
.el .IP "\f(CWuuname\fR" 4
.IX Item "uuname"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """uvoformat""" 4
.el .IP "\f(CWuvoformat\fR" 4
.IX Item "uvoformat"
From \fIperlxvf.U\fR:
.Sp
This variable contains the format string used for printing
a Perl \f(CW\*(C`UV\*(C'\fR as an unsigned octal integer.
.ie n .IP """uvsize""" 4
.el .IP "\f(CWuvsize\fR" 4
.IX Item "uvsize"
From \fIperlxv.U\fR:
.Sp
This variable is the size of a \f(CW\*(C`UV\*(C'\fR in bytes.
.ie n .IP """uvtype""" 4
.el .IP "\f(CWuvtype\fR" 4
.IX Item "uvtype"
From \fIperlxv.U\fR:
.Sp
This variable contains the C type used for Perl's \f(CW\*(C`UV\*(C'\fR.
.ie n .IP """uvuformat""" 4
.el .IP "\f(CWuvuformat\fR" 4
.IX Item "uvuformat"
From \fIperlxvf.U\fR:
.Sp
This variable contains the format string used for printing
a Perl \f(CW\*(C`UV\*(C'\fR as an unsigned decimal integer.
.ie n .IP """uvxformat""" 4
.el .IP "\f(CWuvxformat\fR" 4
.IX Item "uvxformat"
From \fIperlxvf.U\fR:
.Sp
This variable contains the format string used for printing
a Perl \f(CW\*(C`UV\*(C'\fR as an unsigned hexadecimal integer in lowercase abcdef.
.ie n .IP """uvXUformat""" 4
.el .IP "\f(CWuvXUformat\fR" 4
.IX Item "uvXUformat"
From \fIperlxvf.U\fR:
.Sp
This variable contains the format string used for printing
a Perl \f(CW\*(C`UV\*(C'\fR as an unsigned hexadecimal integer in uppercase \f(CW\*(C`ABCDEF\*(C'\fR.
.SS "v"
.IX Subsection "v"
.ie n .IP """vaproto""" 4
.el .IP "\f(CWvaproto\fR" 4
.IX Item "vaproto"
From \fIvaproto.U\fR:
.Sp
This variable conditionally defines \f(CW\*(C`CAN_VAPROTO\*(C'\fR on systems supporting
prototype declaration of functions with a variable number of
arguments. See also prototype.
.ie n .IP """vendorarch""" 4
.el .IP "\f(CWvendorarch\fR" 4
.IX Item "vendorarch"
From \fIvendorarch.U\fR:
.Sp
This variable contains the value of the \f(CW\*(C`PERL_VENDORARCH\*(C'\fR symbol.
It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
architecture-dependent modules and extensions in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorarchexp""" 4
.el .IP "\f(CWvendorarchexp\fR" 4
.IX Item "vendorarchexp"
From \fIvendorarch.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorarch, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorbin""" 4
.el .IP "\f(CWvendorbin\fR" 4
.IX Item "vendorbin"
From \fIvendorbin.U\fR:
.Sp
This variable contains the eventual value of the \f(CW\*(C`VENDORBIN\*(C'\fR symbol.
It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place additional
binaries in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorbinexp""" 4
.el .IP "\f(CWvendorbinexp\fR" 4
.IX Item "vendorbinexp"
From \fIvendorbin.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorbin, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorhtml1dir""" 4
.el .IP "\f(CWvendorhtml1dir\fR" 4
.IX Item "vendorhtml1dir"
From \fIvendorhtml1dir.U\fR:
.Sp
This variable contains the name of the directory for html
pages.  It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
html pages in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorhtml1direxp""" 4
.el .IP "\f(CWvendorhtml1direxp\fR" 4
.IX Item "vendorhtml1direxp"
From \fIvendorhtml1dir.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorhtml1dir, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorhtml3dir""" 4
.el .IP "\f(CWvendorhtml3dir\fR" 4
.IX Item "vendorhtml3dir"
From \fIvendorhtml3dir.U\fR:
.Sp
This variable contains the name of the directory for html
library pages.  It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
html pages for modules and extensions in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorhtml3direxp""" 4
.el .IP "\f(CWvendorhtml3direxp\fR" 4
.IX Item "vendorhtml3direxp"
From \fIvendorhtml3dir.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorhtml3dir, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorlib""" 4
.el .IP "\f(CWvendorlib\fR" 4
.IX Item "vendorlib"
From \fIvendorlib.U\fR:
.Sp
This variable contains the eventual value of the \f(CW\*(C`VENDORLIB\*(C'\fR symbol,
which is the name of the private library for this package.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
modules in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorlib_stem""" 4
.el .IP "\f(CWvendorlib_stem\fR" 4
.IX Item "vendorlib_stem"
From \fIvendorlib.U\fR:
.Sp
This variable is \f(CW$vendorlibexp\fR with any trailing version-specific component
removed.  The elements in inc_version_list (\fIinc_version_list.U\fR) can
be tacked onto this variable to generate a list of directories to search.
.ie n .IP """vendorlibexp""" 4
.el .IP "\f(CWvendorlibexp\fR" 4
.IX Item "vendorlibexp"
From \fIvendorlib.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorlib, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorman1dir""" 4
.el .IP "\f(CWvendorman1dir\fR" 4
.IX Item "vendorman1dir"
From \fIvendorman1dir.U\fR:
.Sp
This variable contains the name of the directory for man1
pages.  It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
man1 pages in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorman1direxp""" 4
.el .IP "\f(CWvendorman1direxp\fR" 4
.IX Item "vendorman1direxp"
From \fIvendorman1dir.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorman1dir, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorman3dir""" 4
.el .IP "\f(CWvendorman3dir\fR" 4
.IX Item "vendorman3dir"
From \fIvendorman3dir.U\fR:
.Sp
This variable contains the name of the directory for man3
pages.  It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place their own
man3 pages in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorman3direxp""" 4
.el .IP "\f(CWvendorman3direxp\fR" 4
.IX Item "vendorman3direxp"
From \fIvendorman3dir.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorman3dir, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """vendorprefix""" 4
.el .IP "\f(CWvendorprefix\fR" 4
.IX Item "vendorprefix"
From \fIvendorprefix.U\fR:
.Sp
This variable holds the full absolute path of the directory below
which the vendor will install add-on packages.
See \f(CW\*(C`INSTALL\*(C'\fR for usage and examples.
.ie n .IP """vendorprefixexp""" 4
.el .IP "\f(CWvendorprefixexp\fR" 4
.IX Item "vendorprefixexp"
From \fIvendorprefix.U\fR:
.Sp
This variable holds the full absolute path of the directory below
which the vendor will install add-on packages.  Derived from vendorprefix.
.ie n .IP """vendorscript""" 4
.el .IP "\f(CWvendorscript\fR" 4
.IX Item "vendorscript"
From \fIvendorscript.U\fR:
.Sp
This variable contains the eventual value of the \f(CW\*(C`VENDORSCRIPT\*(C'\fR symbol.
It may have a \fI~\fR on the front.
The standard distribution will put nothing in this directory.
Vendors who distribute perl may wish to place additional
executable scripts in this directory with
MakeMaker \fIMakefile.PL\fR \f(CW\*(C`INSTALLDIRS\*(C'\fR=vendor
or equivalent.  See \f(CW\*(C`INSTALL\*(C'\fR for details.
.ie n .IP """vendorscriptexp""" 4
.el .IP "\f(CWvendorscriptexp\fR" 4
.IX Item "vendorscriptexp"
From \fIvendorscript.U\fR:
.Sp
This variable is the \fI~name\fR expanded version of vendorscript, so that you
may use it directly in Makefiles or shell scripts.
.ie n .IP """version""" 4
.el .IP "\f(CWversion\fR" 4
.IX Item "version"
From \fIpatchlevel.U\fR:
.Sp
The full version number of this package, such as 5.6.1 (or 5_6_1).
This combines revision, patchlevel, and subversion to get the
full version number, including any possible subversions.
This is suitable for use as a directory name, and hence is
filesystem dependent.
.ie n .IP """version_patchlevel_string""" 4
.el .IP "\f(CWversion_patchlevel_string\fR" 4
.IX Item "version_patchlevel_string"
From \fIpatchlevel.U\fR:
.Sp
This is a string combining version, subversion and
perl_patchlevel (if perl_patchlevel is non-zero).
It is typically something like
\&'version 7 subversion 1'  or
\&'version 7 subversion 1 patchlevel 11224'
It is computed here to avoid duplication of code in \fImyconfig.SH\fR
and \fIlib/Config.pm\fR.
.ie n .IP """versiononly""" 4
.el .IP "\f(CWversiononly\fR" 4
.IX Item "versiononly"
From \fIversiononly.U\fR:
.Sp
If set, this symbol indicates that only the version-specific
components of a perl installation should be installed.
This may be useful for making a test installation of a new
version without disturbing the existing installation.
Setting versiononly is equivalent to setting installperl's \-v option.
In particular, the non-versioned scripts and programs such as
a2p, c2ph, h2xs, pod2*, and perldoc are not installed
(see \f(CW\*(C`INSTALL\*(C'\fR for a more complete list).  Nor are the man
pages installed.
Usually, this is undef.
.ie n .IP """vi""" 4
.el .IP "\f(CWvi\fR" 4
.IX Item "vi"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """voidflags""" 4
.el .IP "\f(CWvoidflags\fR" 4
.IX Item "voidflags"
From \fIvoidflags.U\fR:
.Sp
This variable contains the eventual value of the \f(CW\*(C`VOIDFLAGS\*(C'\fR symbol,
which indicates how much support of the void type is given by this
compiler.  See \f(CW\*(C`VOIDFLAGS\*(C'\fR for more info.
.SS "x"
.IX Subsection "x"
.ie n .IP """xlibpth""" 4
.el .IP "\f(CWxlibpth\fR" 4
.IX Item "xlibpth"
From \fIlibpth.U\fR:
.Sp
This variable holds extra path (space-separated) used to find
libraries on this platform, for example \f(CW\*(C`CPU\*(C'\fR\-specific libraries
(on multi\-\f(CW\*(C`CPU\*(C'\fR platforms) may be listed here.
.SS "y"
.IX Subsection "y"
.ie n .IP """yacc""" 4
.el .IP "\f(CWyacc\fR" 4
.IX Item "yacc"
From \fIyacc.U\fR:
.Sp
This variable holds the name of the compiler compiler we
want to use in the Makefile. It can be yacc, byacc, or bison \-y.
.ie n .IP """yaccflags""" 4
.el .IP "\f(CWyaccflags\fR" 4
.IX Item "yaccflags"
From \fIyacc.U\fR:
.Sp
This variable contains any additional yacc flags desired by the
user.  It is up to the Makefile to use this.
.SS "z"
.IX Subsection "z"
.ie n .IP """zcat""" 4
.el .IP "\f(CWzcat\fR" 4
.IX Item "zcat"
From \fILoc.U\fR:
.Sp
This variable is defined but not used by Configure.
The value is the empty string and is not useful.
.ie n .IP """zip""" 4
.el .IP "\f(CWzip\fR" 4
.IX Item "zip"
From \fILoc.U\fR:
.Sp
This variable is used internally by Configure to determine the
full pathname (if any) of the zip program.  After Configure runs,
the value is reset to a plain \f(CW\*(C`zip\*(C'\fR and is not useful.
.SH "GIT DATA"
.IX Header "GIT DATA"
Information on the git commit from which the current perl binary was compiled
can be found in the variable \f(CW$Config::Git_Data\fR.  The variable is a
structured string that looks something like this:
.PP
.Vb 6
\&  git_commit_id=\*(Aqea0c2dbd5f5ac6845ecc7ec6696415bf8e27bd52\*(Aq
\&  git_describe=\*(AqGitLive\-blead\-1076\-gea0c2db\*(Aq
\&  git_branch=\*(Aqsmartmatch\*(Aq
\&  git_uncommitted_changes=\*(Aq\*(Aq
\&  git_commit_id_title=\*(AqCommit id:\*(Aq
\&  git_commit_date=\*(Aq2009\-05\-09 17:47:31 +0200\*(Aq
.Ve
.PP
Its format is not guaranteed not to change over time.
.SH "NOTE"
.IX Header "NOTE"
This module contains a good example of how to use tie to implement a
cache and an example of how to make a tied variable readonly to those
outside of it.
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any.3pm                              0100644 0001750 0001750 00000031022 12566242270 023336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any 3"
.TH Config::Any 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any \- Load configuration from different file formats, transparently
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Any;
\&
\&    my $cfg = Config::Any\->load_stems({stems => \e@filepath_stems, ... });
\&    # or
\&    my $cfg = Config::Any\->load_files({files => \e@filepaths, ... });
\&
\&    for (@$cfg) {
\&        my ($filename, $config) = %$_;
\&        $class\->config($config);
\&        warn "loaded config from file: $filename";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::Any provides a facility for Perl applications and libraries
to load configuration data from multiple different file formats. It supports \s-1XML, YAML,
JSON,\s0 Apache-style configuration, Windows \s-1INI\s0 files, and even Perl code.
.PP
The rationale for this module is as follows: Perl programs are deployed on many different
platforms and integrated with many different systems. Systems administrators and end 
users may prefer different configuration formats than the developers. The flexibility
inherent in a multiple format configuration loader allows different users to make 
different choices, without generating extra work for the developers. As a developer
you only need to learn a single interface to be able to use the power of different
configuration formats.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "load_files( \e%args )"
.IX Subsection "load_files( %args )"
.Vb 4
\&    Config::Any\->load_files( { files => \e@files } );
\&    Config::Any\->load_files( { files => \e@files, filter  => \e&filter } );
\&    Config::Any\->load_files( { files => \e@files, use_ext => 1 } );
\&    Config::Any\->load_files( { files => \e@files, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_files()\*(C'\fR attempts to load configuration from the list of files passed in
the \f(CW\*(C`files\*(C'\fR parameter, if the file exists.
.PP
If the \f(CW\*(C`filter\*(C'\fR parameter is set, it is used as a callback to modify the configuration 
data before it is returned. It will be passed a single hash-reference parameter which 
it should modify in-place.
.PP
If the \f(CW\*(C`use_ext\*(C'\fR parameter is defined, the loader will attempt to parse the file
extension from each filename and will skip the file unless it matches a standard
extension for the loading plugins. Only plugins whose standard extensions match the
file extension will be used. For efficiency reasons, its use is encouraged, but
be aware that you will lose flexibility \*(-- for example, a file called \f(CW\*(C`myapp.cfg\*(C'\fR 
containing \s-1YAML\s0 data will not be offered to the \s-1YAML\s0 plugin, whereas \f(CW\*(C`myapp.yml\*(C'\fR
or \f(CW\*(C`myapp.yaml\*(C'\fR would be.
.PP
When the \f(CW\*(C`flatten_to_hash\*(C'\fR parameter is defined, the loader will return a hash
keyed on the file names, as opposed to the usual list of single-key hashes.
.PP
\&\f(CW\*(C`load_files()\*(C'\fR also supports a 'force_plugins' parameter, whose value should be an
arrayref of plugin names like \f(CW\*(C`Config::Any::INI\*(C'\fR. Its intended use is to allow the use 
of a non-standard file extension while forcing it to be offered to a particular parser.
It is not compatible with 'use_ext'.
.PP
You can supply a \f(CW\*(C`driver_args\*(C'\fR hashref to pass special options to a particular
parser object. Example:
.PP
.Vb 3
\&    Config::Any\->load_files( { files => \e@files, driver_args => {
\&        General => { \-LowerCaseNames => 1 }
\&    } )
.Ve
.SS "load_stems( \e%args )"
.IX Subsection "load_stems( %args )"
.Vb 4
\&    Config::Any\->load_stems( { stems => \e@stems } );
\&    Config::Any\->load_stems( { stems => \e@stems, filter  => \e&filter } );
\&    Config::Any\->load_stems( { stems => \e@stems, use_ext => 1 } );
\&    Config::Any\->load_stems( { stems => \e@stems, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_stems()\*(C'\fR attempts to load configuration from a list of files which it generates
by combining the filename stems list passed in the \f(CW\*(C`stems\*(C'\fR parameter with the 
potential filename extensions from each loader, which you can check with the
\&\f(CW\*(C`extensions()\*(C'\fR classmethod described below. Once this list of possible filenames is
built it is treated exactly as in \f(CW\*(C`load_files()\*(C'\fR above, as which it takes the same
parameters. Please read the \f(CW\*(C`load_files()\*(C'\fR documentation before using this method.
.SS "finder( )"
.IX Subsection "finder( )"
The \f(CW\*(C`finder()\*(C'\fR classmethod returns the 
Module::Pluggable::Object
object which is used to load the plugins. See the documentation for that module for
more information.
.SS "plugins( )"
.IX Subsection "plugins( )"
The \f(CW\*(C`plugins()\*(C'\fR classmethod returns the names of configuration loading plugins as 
found by Module::Pluggable::Object.
.SS "extensions( )"
.IX Subsection "extensions( )"
The \f(CW\*(C`extensions()\*(C'\fR classmethod returns the possible file extensions which can be loaded
by \f(CW\*(C`load_stems()\*(C'\fR and \f(CW\*(C`load_files()\*(C'\fR. This may be useful if you set the \f(CW\*(C`use_ext\*(C'\fR
parameter to those methods.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """No files specified!"" or ""No stems specified!""" 4
.el .IP "\f(CWNo files specified!\fR or \f(CWNo stems specified!\fR" 4
.IX Item "No files specified! or No stems specified!"
The \f(CW\*(C`load_files()\*(C'\fR and \f(CW\*(C`load_stems()\*(C'\fR methods will issue this warning if
called with an empty list of files/stems to load.
.ie n .IP """_load requires a arrayref of file paths""" 4
.el .IP "\f(CW_load requires a arrayref of file paths\fR" 4
.IX Item "_load requires a arrayref of file paths"
This fatal error will be thrown by the internal \f(CW\*(C`_load\*(C'\fR method. It should not occur
but is specified here for completeness. If your code dies with this error, please
email a failing test case to the authors below.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Config::Any requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Module::Pluggable
.PP
And at least one of the following:
Config::General
Config::Tiny
\&\s-1JSON\s0
\&\s-1YAML\s0
JSON::Syck
YAML::Syck
XML::Simple
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-config\-any@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joel Bernstein <rataxis@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
This module was based on the original 
Catalyst::Plugin::ConfigLoader
module by Brian Cassidy \f(CW\*(C`<bricas@cpan.org>\*(C'\fR.
.PP
With ideas and support from Matt S Trout \f(CW\*(C`<mst@shadowcatsystems.co.uk>\*(C'\fR.
.PP
Further enhancements suggested by Evan Kaufman \f(CW\*(C`<evank@cpan.org>\*(C'\fR.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006, Portugal Telecom \f(CW\*(C`http://www.sapo.pt/\*(C'\fR. All rights reserved.
Portions copyright 2007, Joel Bernstein \f(CW\*(C`<rataxis@cpan.org>\*(C'\fR.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Plugin::ConfigLoader 
\&\*(-- now a wrapper around this module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any5.16.3pm                          0100644 0001750 0001750 00000033326 12566242272 023663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any 3"
.TH Config::Any 3 "2011-07-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any \- Load configuration from different file formats, transparently
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Any;
\&
\&    my $cfg = Config::Any\->load_stems({stems => \e@filepath_stems, ... });
\&    # or
\&    my $cfg = Config::Any\->load_files({files => \e@filepaths, ... });
\&
\&    for (@$cfg) {
\&        my ($filename, $config) = %$_;
\&        $class\->config($config);
\&        warn "loaded config from file: $filename";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::Any provides a facility for Perl applications and libraries
to load configuration data from multiple different file formats. It supports \s-1XML\s0, \s-1YAML\s0,
\&\s-1JSON\s0, Apache-style configuration, Windows \s-1INI\s0 files, and even Perl code.
.PP
The rationale for this module is as follows: Perl programs are deployed on many different
platforms and integrated with many different systems. Systems administrators and end 
users may prefer different configuration formats than the developers. The flexibility
inherent in a multiple format configuration loader allows different users to make 
different choices, without generating extra work for the developers. As a developer
you only need to learn a single interface to be able to use the power of different
configuration formats.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "load_files( \e%args )"
.IX Subsection "load_files( %args )"
.Vb 4
\&    Config::Any\->load_files( { files => \e@files } );
\&    Config::Any\->load_files( { files => \e@files, filter  => \e&filter } );
\&    Config::Any\->load_files( { files => \e@files, use_ext => 1 } );
\&    Config::Any\->load_files( { files => \e@files, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_files()\*(C'\fR attempts to load configuration from the list of files passed in
the \f(CW\*(C`files\*(C'\fR parameter, if the file exists.
.PP
If the \f(CW\*(C`filter\*(C'\fR parameter is set, it is used as a callback to modify the configuration 
data before it is returned. It will be passed a single hash-reference parameter which 
it should modify in-place.
.PP
If the \f(CW\*(C`use_ext\*(C'\fR parameter is defined, the loader will attempt to parse the file
extension from each filename and will skip the file unless it matches a standard
extension for the loading plugins. Only plugins whose standard extensions match the
file extension will be used. For efficiency reasons, its use is encouraged, but
be aware that you will lose flexibility \*(-- for example, a file called \f(CW\*(C`myapp.cfg\*(C'\fR 
containing \s-1YAML\s0 data will not be offered to the \s-1YAML\s0 plugin, whereas \f(CW\*(C`myapp.yml\*(C'\fR
or \f(CW\*(C`myapp.yaml\*(C'\fR would be.
.PP
When the \f(CW\*(C`flatten_to_hash\*(C'\fR parameter is defined, the loader will return a hash
keyed on the file names, as opposed to the usual list of single-key hashes.
.PP
\&\f(CW\*(C`load_files()\*(C'\fR also supports a 'force_plugins' parameter, whose value should be an
arrayref of plugin names like \f(CW\*(C`Config::Any::INI\*(C'\fR. Its intended use is to allow the use 
of a non-standard file extension while forcing it to be offered to a particular parser.
It is not compatible with 'use_ext'.
.PP
You can supply a \f(CW\*(C`driver_args\*(C'\fR hashref to pass special options to a particular
parser object. Example:
.PP
.Vb 3
\&    Config::Any\->load_files( { files => \e@files, driver_args => {
\&        General => { \-LowerCaseNames => 1 }
\&    } )
.Ve
.SS "load_stems( \e%args )"
.IX Subsection "load_stems( %args )"
.Vb 4
\&    Config::Any\->load_stems( { stems => \e@stems } );
\&    Config::Any\->load_stems( { stems => \e@stems, filter  => \e&filter } );
\&    Config::Any\->load_stems( { stems => \e@stems, use_ext => 1 } );
\&    Config::Any\->load_stems( { stems => \e@stems, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_stems()\*(C'\fR attempts to load configuration from a list of files which it generates
by combining the filename stems list passed in the \f(CW\*(C`stems\*(C'\fR parameter with the 
potential filename extensions from each loader, which you can check with the
\&\f(CW\*(C`extensions()\*(C'\fR classmethod described below. Once this list of possible filenames is
built it is treated exactly as in \f(CW\*(C`load_files()\*(C'\fR above, as which it takes the same
parameters. Please read the \f(CW\*(C`load_files()\*(C'\fR documentation before using this method.
.SS "finder( )"
.IX Subsection "finder( )"
The \f(CW\*(C`finder()\*(C'\fR classmethod returns the 
Module::Pluggable::Object
object which is used to load the plugins. See the documentation for that module for
more information.
.SS "plugins( )"
.IX Subsection "plugins( )"
The \f(CW\*(C`plugins()\*(C'\fR classmethod returns the names of configuration loading plugins as 
found by Module::Pluggable::Object.
.SS "extensions( )"
.IX Subsection "extensions( )"
The \f(CW\*(C`extensions()\*(C'\fR classmethod returns the possible file extensions which can be loaded
by \f(CW\*(C`load_stems()\*(C'\fR and \f(CW\*(C`load_files()\*(C'\fR. This may be useful if you set the \f(CW\*(C`use_ext\*(C'\fR
parameter to those methods.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """No files specified!"" or ""No stems specified!""" 4
.el .IP "\f(CWNo files specified!\fR or \f(CWNo stems specified!\fR" 4
.IX Item "No files specified! or No stems specified!"
The \f(CW\*(C`load_files()\*(C'\fR and \f(CW\*(C`load_stems()\*(C'\fR methods will issue this warning if
called with an empty list of files/stems to load.
.ie n .IP """_load requires a arrayref of file paths""" 4
.el .IP "\f(CW_load requires a arrayref of file paths\fR" 4
.IX Item "_load requires a arrayref of file paths"
This fatal error will be thrown by the internal \f(CW\*(C`_load\*(C'\fR method. It should not occur
but is specified here for completeness. If your code dies with this error, please
email a failing test case to the authors below.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Config::Any requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Module::Pluggable
.PP
And at least one of the following:
Config::General
Config::Tiny
\&\s-1JSON\s0
\&\s-1YAML\s0
JSON::Syck
YAML::Syck
XML::Simple
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-config\-any@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joel Bernstein <rataxis@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
This module was based on the original 
Catalyst::Plugin::ConfigLoader
module by Brian Cassidy \f(CW\*(C`<bricas@cpan.org>\*(C'\fR.
.PP
With ideas and support from Matt S Trout \f(CW\*(C`<mst@shadowcatsystems.co.uk>\*(C'\fR.
.PP
Further enhancements suggested by Evan Kaufman \f(CW\*(C`<evank@cpan.org>\*(C'\fR.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006, Portugal Telecom \f(CW\*(C`http://www.sapo.pt/\*(C'\fR. All rights reserved.
Portions copyright 2007, Joel Bernstein \f(CW\*(C`<rataxis@cpan.org>\*(C'\fR.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0
\&\s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0
\&\s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0
\&\s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0
\&\s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0
\&\s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0
\&\s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0
\&\s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0
\&\s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0
\&\s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0
\&\s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0
\&\s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0
\&\s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A
\&\s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0
\&\s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGES\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Plugin::ConfigLoader 
\&\*(-- now a wrapper around this module.
                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any5.18.3pm                          0100644 0001750 0001750 00000031022 12566242270 023652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any 3"
.TH Config::Any 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any \- Load configuration from different file formats, transparently
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Config::Any;
\&
\&    my $cfg = Config::Any\->load_stems({stems => \e@filepath_stems, ... });
\&    # or
\&    my $cfg = Config::Any\->load_files({files => \e@filepaths, ... });
\&
\&    for (@$cfg) {
\&        my ($filename, $config) = %$_;
\&        $class\->config($config);
\&        warn "loaded config from file: $filename";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::Any provides a facility for Perl applications and libraries
to load configuration data from multiple different file formats. It supports \s-1XML, YAML,
JSON,\s0 Apache-style configuration, Windows \s-1INI\s0 files, and even Perl code.
.PP
The rationale for this module is as follows: Perl programs are deployed on many different
platforms and integrated with many different systems. Systems administrators and end 
users may prefer different configuration formats than the developers. The flexibility
inherent in a multiple format configuration loader allows different users to make 
different choices, without generating extra work for the developers. As a developer
you only need to learn a single interface to be able to use the power of different
configuration formats.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "load_files( \e%args )"
.IX Subsection "load_files( %args )"
.Vb 4
\&    Config::Any\->load_files( { files => \e@files } );
\&    Config::Any\->load_files( { files => \e@files, filter  => \e&filter } );
\&    Config::Any\->load_files( { files => \e@files, use_ext => 1 } );
\&    Config::Any\->load_files( { files => \e@files, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_files()\*(C'\fR attempts to load configuration from the list of files passed in
the \f(CW\*(C`files\*(C'\fR parameter, if the file exists.
.PP
If the \f(CW\*(C`filter\*(C'\fR parameter is set, it is used as a callback to modify the configuration 
data before it is returned. It will be passed a single hash-reference parameter which 
it should modify in-place.
.PP
If the \f(CW\*(C`use_ext\*(C'\fR parameter is defined, the loader will attempt to parse the file
extension from each filename and will skip the file unless it matches a standard
extension for the loading plugins. Only plugins whose standard extensions match the
file extension will be used. For efficiency reasons, its use is encouraged, but
be aware that you will lose flexibility \*(-- for example, a file called \f(CW\*(C`myapp.cfg\*(C'\fR 
containing \s-1YAML\s0 data will not be offered to the \s-1YAML\s0 plugin, whereas \f(CW\*(C`myapp.yml\*(C'\fR
or \f(CW\*(C`myapp.yaml\*(C'\fR would be.
.PP
When the \f(CW\*(C`flatten_to_hash\*(C'\fR parameter is defined, the loader will return a hash
keyed on the file names, as opposed to the usual list of single-key hashes.
.PP
\&\f(CW\*(C`load_files()\*(C'\fR also supports a 'force_plugins' parameter, whose value should be an
arrayref of plugin names like \f(CW\*(C`Config::Any::INI\*(C'\fR. Its intended use is to allow the use 
of a non-standard file extension while forcing it to be offered to a particular parser.
It is not compatible with 'use_ext'.
.PP
You can supply a \f(CW\*(C`driver_args\*(C'\fR hashref to pass special options to a particular
parser object. Example:
.PP
.Vb 3
\&    Config::Any\->load_files( { files => \e@files, driver_args => {
\&        General => { \-LowerCaseNames => 1 }
\&    } )
.Ve
.SS "load_stems( \e%args )"
.IX Subsection "load_stems( %args )"
.Vb 4
\&    Config::Any\->load_stems( { stems => \e@stems } );
\&    Config::Any\->load_stems( { stems => \e@stems, filter  => \e&filter } );
\&    Config::Any\->load_stems( { stems => \e@stems, use_ext => 1 } );
\&    Config::Any\->load_stems( { stems => \e@stems, flatten_to_hash => 1 } );
.Ve
.PP
\&\f(CW\*(C`load_stems()\*(C'\fR attempts to load configuration from a list of files which it generates
by combining the filename stems list passed in the \f(CW\*(C`stems\*(C'\fR parameter with the 
potential filename extensions from each loader, which you can check with the
\&\f(CW\*(C`extensions()\*(C'\fR classmethod described below. Once this list of possible filenames is
built it is treated exactly as in \f(CW\*(C`load_files()\*(C'\fR above, as which it takes the same
parameters. Please read the \f(CW\*(C`load_files()\*(C'\fR documentation before using this method.
.SS "finder( )"
.IX Subsection "finder( )"
The \f(CW\*(C`finder()\*(C'\fR classmethod returns the 
Module::Pluggable::Object
object which is used to load the plugins. See the documentation for that module for
more information.
.SS "plugins( )"
.IX Subsection "plugins( )"
The \f(CW\*(C`plugins()\*(C'\fR classmethod returns the names of configuration loading plugins as 
found by Module::Pluggable::Object.
.SS "extensions( )"
.IX Subsection "extensions( )"
The \f(CW\*(C`extensions()\*(C'\fR classmethod returns the possible file extensions which can be loaded
by \f(CW\*(C`load_stems()\*(C'\fR and \f(CW\*(C`load_files()\*(C'\fR. This may be useful if you set the \f(CW\*(C`use_ext\*(C'\fR
parameter to those methods.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """No files specified!"" or ""No stems specified!""" 4
.el .IP "\f(CWNo files specified!\fR or \f(CWNo stems specified!\fR" 4
.IX Item "No files specified! or No stems specified!"
The \f(CW\*(C`load_files()\*(C'\fR and \f(CW\*(C`load_stems()\*(C'\fR methods will issue this warning if
called with an empty list of files/stems to load.
.ie n .IP """_load requires a arrayref of file paths""" 4
.el .IP "\f(CW_load requires a arrayref of file paths\fR" 4
.IX Item "_load requires a arrayref of file paths"
This fatal error will be thrown by the internal \f(CW\*(C`_load\*(C'\fR method. It should not occur
but is specified here for completeness. If your code dies with this error, please
email a failing test case to the authors below.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Config::Any requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Module::Pluggable
.PP
And at least one of the following:
Config::General
Config::Tiny
\&\s-1JSON\s0
\&\s-1YAML\s0
JSON::Syck
YAML::Syck
XML::Simple
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-config\-any@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joel Bernstein <rataxis@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
This module was based on the original 
Catalyst::Plugin::ConfigLoader
module by Brian Cassidy \f(CW\*(C`<bricas@cpan.org>\*(C'\fR.
.PP
With ideas and support from Matt S Trout \f(CW\*(C`<mst@shadowcatsystems.co.uk>\*(C'\fR.
.PP
Further enhancements suggested by Evan Kaufman \f(CW\*(C`<evank@cpan.org>\*(C'\fR.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006, Portugal Telecom \f(CW\*(C`http://www.sapo.pt/\*(C'\fR. All rights reserved.
Portions copyright 2007, Joel Bernstein \f(CW\*(C`<rataxis@cpan.org>\*(C'\fR.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Plugin::ConfigLoader 
\&\*(-- now a wrapper around this module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Base.3pm                        0100644 0001750 0001750 00000012327 12566242270 024324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Base 3"
.TH Config::Any::Base 3 "2013-08-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Base \- Base class for loaders
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a base class for all loaders. It currently handles the specification
of dependencies in order to ensure the subclass can load the config file
format.
.SH "METHODS"
.IX Header "METHODS"
.SS "is_supported( )"
.IX Subsection "is_supported( )"
Allows us to determine if the file format can be loaded. The can be done via
one of two subclass methods:
.IP "\(bu" 4
\&\f(CW\*(C`requires_all_of()\*(C'\fR \- returns an array of items that must all be present in order to work
.IP "\(bu" 4
\&\f(CW\*(C`requires_any_of()\*(C'\fR \- returns an array of items in which at least one must be present
.PP
You can specify a module version by passing an array reference in the return.
.PP
.Vb 1
\&    sub requires_all_of { [ \*(AqMy::Module\*(Aq, \*(Aq1.1\*(Aq ], \*(AqMy::OtherModule\*(Aq }
.Ve
.PP
Lack of specifying these subs will assume you require no extra modules to function.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008\-2009 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Config::Any
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Base5.16.3pm                    0100644 0001750 0001750 00000012005 12566242272 024631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Base 3"
.TH Config::Any::Base 3 "2011-05-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Base \- Base class for loaders
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a base class for all loaders. It currently handles the specification
of dependencies in order to ensure the subclass can load the config file
format.
.SH "METHODS"
.IX Header "METHODS"
.SS "is_supported( )"
.IX Subsection "is_supported( )"
Allows us to determine if the file format can be loaded. The can be done via
one of two subclass methds:
.IP "\(bu" 4
\&\f(CW\*(C`requires_all_of()\*(C'\fR \- returns an array of items that must all be present in order to work
.IP "\(bu" 4
\&\f(CW\*(C`requires_any_of()\*(C'\fR \- returns an array of items in which at least one must be present
.PP
You can specify a module version by passing an array reference in the return.
.PP
.Vb 1
\&    sub requires_all_of { [ \*(AqMy::Module\*(Aq, \*(Aq1.1\*(Aq ], \*(AqMy::OtherModule\*(Aq }
.Ve
.PP
Lack of specifying these subs will assume you require no extra modules to function.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008\-2009 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Config::Any
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Base5.18.3pm                    0100644 0001750 0001750 00000012327 12566242270 024640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Base 3"
.TH Config::Any::Base 3 "2013-08-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Base \- Base class for loaders
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a base class for all loaders. It currently handles the specification
of dependencies in order to ensure the subclass can load the config file
format.
.SH "METHODS"
.IX Header "METHODS"
.SS "is_supported( )"
.IX Subsection "is_supported( )"
Allows us to determine if the file format can be loaded. The can be done via
one of two subclass methods:
.IP "\(bu" 4
\&\f(CW\*(C`requires_all_of()\*(C'\fR \- returns an array of items that must all be present in order to work
.IP "\(bu" 4
\&\f(CW\*(C`requires_any_of()\*(C'\fR \- returns an array of items in which at least one must be present
.PP
You can specify a module version by passing an array reference in the return.
.PP
.Vb 1
\&    sub requires_all_of { [ \*(AqMy::Module\*(Aq, \*(Aq1.1\*(Aq ], \*(AqMy::OtherModule\*(Aq }
.Ve
.PP
Lack of specifying these subs will assume you require no extra modules to function.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008\-2009 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Config::Any
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::General.3pm                     0100644 0001750 0001750 00000012312 12566242270 025021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::General 3"
.TH Config::Any::General 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::General \- Load Config::General files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Config::General files. Example:
.PP
.Vb 8
\&    name = TestApp
\&    <Component Controller::Foo>
\&        foo bar
\&        bar [ arrayref\-value ]
\&    </Component>
\&    <Model Baz>
\&        qux xyzzy
\&    </Model>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`cnf\*(C'\fR, \f(CW\*(C`conf\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR via Config::General.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::General in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
Portions Copyright 2006 Portugal Telecom
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::General
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::General5.16.3pm                 0100644 0001750 0001750 00000011771 12566242272 025345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::General 3"
.TH Config::Any::General 3 "2011-05-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::General \- Load Config::General files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Config::General files. Example:
.PP
.Vb 8
\&    name = TestApp
\&    <Component Controller::Foo>
\&        foo bar
\&        bar [ arrayref\-value ]
\&    </Component>
\&    <Model Baz>
\&        qux xyzzy
\&    </Model>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`cnf\*(C'\fR, \f(CW\*(C`conf\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR via Config::General.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::General in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy
.PP
Portions Copyright 2006 Portugal Telecom
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::General
       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::General5.18.3pm                 0100644 0001750 0001750 00000012312 12566242270 025335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::General 3"
.TH Config::Any::General 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::General \- Load Config::General files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Config::General files. Example:
.PP
.Vb 8
\&    name = TestApp
\&    <Component Controller::Foo>
\&        foo bar
\&        bar [ arrayref\-value ]
\&    </Component>
\&    <Model Baz>
\&        qux xyzzy
\&    </Model>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`cnf\*(C'\fR, \f(CW\*(C`conf\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR via Config::General.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::General in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
Portions Copyright 2006 Portugal Telecom
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::General
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::INI.3pm                         0100644 0001750 0001750 00000013341 12566242270 024066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::INI 3"
.TH Config::Any::INI 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::INI \- Load INI config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1INI\s0 files. Example:
.PP
.Vb 1
\&    name=TestApp
\&    
\&    [Controller::Foo]
\&    foo=bar
\&    
\&    [Model::Baz]
\&    qux=xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`ini\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1INI\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::Tiny in order to work.
.SH "PACKAGE VARIABLES"
.IX Header "PACKAGE VARIABLES"
.ie n .IP "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)" 4
.el .IP "\f(CW$MAP_SECTION_SPACE_TO_NESTED_KEY\fR (boolean)" 4
.IX Item "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)"
This variable controls whether spaces in \s-1INI\s0 section headings will be expanded into nested hash keys.
e.g. it controls whether [Full Power] maps to \f(CW$config\fR\->{'Full Power'} or \f(CW$config\fR\->{'Full'}\->{'Power'}
.Sp
By default it is set to 1 (i.e. true).
.Sp
Set it to 0 to preserve literal spaces in section headings:
.Sp
.Vb 3
\&    use Config::Any;
\&    use Config::Any::INI;
\&    $Config::Any::INI::MAP_SECTION_SPACE_TO_NESTED_KEY = 0;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy, portions copyright 2006, 2007 by Joel Bernstein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::Tiny
                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::INI5.16.3pm                     0100644 0001750 0001750 00000013020 12566242272 024374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::INI 3"
.TH Config::Any::INI 3 "2011-05-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::INI \- Load INI config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1INI\s0 files. Example:
.PP
.Vb 1
\&    name=TestApp
\&    
\&    [Controller::Foo]
\&    foo=bar
\&    
\&    [Model::Baz]
\&    qux=xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`ini\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1INI\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::Tiny in order to work.
.SH "PACKAGE VARIABLES"
.IX Header "PACKAGE VARIABLES"
.ie n .IP "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)" 4
.el .IP "\f(CW$MAP_SECTION_SPACE_TO_NESTED_KEY\fR (boolean)" 4
.IX Item "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)"
This variable controls whether spaces in \s-1INI\s0 section headings will be expanded into nested hash keys.
e.g. it controls whether [Full Power] maps to \f(CW$config\fR\->{'Full Power'} or \f(CW$config\fR\->{'Full'}\->{'Power'}
.Sp
By default it is set to 1 (i.e. true).
.Sp
Set it to 0 to preserve literal spaces in section headings:
.Sp
.Vb 3
\&    use Config::Any;
\&    use Config::Any::INI;
\&    $Config::Any::INI::MAP_SECTION_SPACE_TO_NESTED_KEY = 0;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy, portions copyright 2006, 2007 by Joel Bernstein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::Tiny
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::INI5.18.3pm                     0100644 0001750 0001750 00000013341 12566242270 024402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::INI 3"
.TH Config::Any::INI 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::INI \- Load INI config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1INI\s0 files. Example:
.PP
.Vb 1
\&    name=TestApp
\&    
\&    [Controller::Foo]
\&    foo=bar
\&    
\&    [Model::Baz]
\&    qux=xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`ini\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1INI\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires Config::Tiny in order to work.
.SH "PACKAGE VARIABLES"
.IX Header "PACKAGE VARIABLES"
.ie n .IP "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)" 4
.el .IP "\f(CW$MAP_SECTION_SPACE_TO_NESTED_KEY\fR (boolean)" 4
.IX Item "$MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)"
This variable controls whether spaces in \s-1INI\s0 section headings will be expanded into nested hash keys.
e.g. it controls whether [Full Power] maps to \f(CW$config\fR\->{'Full Power'} or \f(CW$config\fR\->{'Full'}\->{'Power'}
.Sp
By default it is set to 1 (i.e. true).
.Sp
Set it to 0 to preserve literal spaces in section headings:
.Sp
.Vb 3
\&    use Config::Any;
\&    use Config::Any::INI;
\&    $Config::Any::INI::MAP_SECTION_SPACE_TO_NESTED_KEY = 0;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy, portions copyright 2006, 2007 by Joel Bernstein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
Config::Tiny
                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::JSON.3pm                        0100644 0001750 0001750 00000012321 12566242270 024215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::JSON 3"
.TH Config::Any::JSON 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::JSON \- Load JSON config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1JSON\s0 files. Example:
.PP
.Vb 9
\&    {
\&        "name": "TestApp",
\&        "Controller::Foo": {
\&            "foo": "bar"
\&        },
\&        "Model::Baz": {
\&            "qux": "xyzzy"
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`json\*(C'\fR, \f(CW\*(C`jsn\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1JSON\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of,  \s-1JSON::DWIW\s0, \s-1JSON::XS\s0,
JSON::Syck or \s-1JSON\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1JSON::DWIW\s0
.IP "\(bu" 4
\&\s-1JSON::XS\s0
.IP "\(bu" 4
JSON::Syck
.IP "\(bu" 4
\&\s-1JSON\s0
                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::JSON5.16.3pm                    0100644 0001750 0001750 00000012000 12566242272 024523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::JSON 3"
.TH Config::Any::JSON 3 "2011-05-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::JSON \- Load JSON config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1JSON\s0 files. Example:
.PP
.Vb 9
\&    {
\&        "name": "TestApp",
\&        "Controller::Foo": {
\&            "foo": "bar"
\&        },
\&        "Model::Baz": {
\&            "qux": "xyzzy"
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`json\*(C'\fR, \f(CW\*(C`jsn\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1JSON\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of,  \s-1JSON::DWIW\s0, \s-1JSON::XS\s0,
JSON::Syck or \s-1JSON\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1JSON::DWIW\s0
.IP "\(bu" 4
\&\s-1JSON::XS\s0
.IP "\(bu" 4
JSON::Syck
.IP "\(bu" 4
\&\s-1JSON\s0
osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::JSON5.18.3pm                    0100644 0001750 0001750 00000012321 12566242270 024531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::JSON 3"
.TH Config::Any::JSON 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::JSON \- Load JSON config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1JSON\s0 files. Example:
.PP
.Vb 9
\&    {
\&        "name": "TestApp",
\&        "Controller::Foo": {
\&            "foo": "bar"
\&        },
\&        "Model::Baz": {
\&            "qux": "xyzzy"
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`json\*(C'\fR, \f(CW\*(C`jsn\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1JSON\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of,  \s-1JSON::DWIW\s0, \s-1JSON::XS\s0,
JSON::Syck or \s-1JSON\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1JSON::DWIW\s0
.IP "\(bu" 4
\&\s-1JSON::XS\s0
.IP "\(bu" 4
JSON::Syck
.IP "\(bu" 4
\&\s-1JSON\s0
                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Perl.3pm                        0100644 0001750 0001750 00000011700 12566242270 024346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Perl 3"
.TH Config::Any::Perl 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Perl \- Load Perl config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Perl files. Example:
.PP
.Vb 9
\&    {
\&        name => \*(AqTestApp\*(Aq,
\&        \*(AqController::Foo\*(Aq => {
\&            foo => \*(Aqbar\*(Aq
\&        },
\&        \*(AqModel::Baz\*(Aq => {
\&            qux => \*(Aqxyzzy\*(Aq
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`pl\*(C'\fR, \f(CW\*(C`perl\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a Perl file.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Perl5.16.3pm                    0100644 0001750 0001750 00000011357 12566242272 024672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Perl 3"
.TH Config::Any::Perl 3 "2011-05-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Perl \- Load Perl config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Perl files. Example:
.PP
.Vb 9
\&    {
\&        name => \*(AqTestApp\*(Aq,
\&        \*(AqController::Foo\*(Aq => {
\&            foo => \*(Aqbar\*(Aq
\&        },
\&        \*(AqModel::Baz\*(Aq => {
\&            qux => \*(Aqxyzzy\*(Aq
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`pl\*(C'\fR, \f(CW\*(C`perl\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a Perl file.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::Perl5.18.3pm                    0100644 0001750 0001750 00000011700 12566242270 024662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::Perl 3"
.TH Config::Any::Perl 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::Perl \- Load Perl config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads Perl files. Example:
.PP
.Vb 9
\&    {
\&        name => \*(AqTestApp\*(Aq,
\&        \*(AqController::Foo\*(Aq => {
\&            foo => \*(Aqbar\*(Aq
\&        },
\&        \*(AqModel::Baz\*(Aq => {
\&            qux => \*(Aqxyzzy\*(Aq
\&        }
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`pl\*(C'\fR, \f(CW\*(C`perl\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a Perl file.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::XML.3pm                         0100644 0001750 0001750 00000013023 12566242270 024104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::XML 3"
.TH Config::Any::XML 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::XML \- Load XML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1XML\s0 files. Example:
.PP
.Vb 9
\&    <config>
\&        <name>TestApp</name>
\&        <component name="Controller::Foo">
\&            <foo>bar</foo>
\&        </component>
\&        <model name="Baz">
\&            <qux>xyzzy</qux>
\&        </model>
\&    </config>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`xml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1XML\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires XML::Simple and XML::NamespaceSupport
in order to work.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Strict Mode"
.IX Subsection "Strict Mode"
If, by some chance, XML::Simple has already been loaded with the strict
flag turned on, then you will likely get errors as warnings will become
fatal exceptions and certain arguments to \fIXMLin()\fR will no longer be optional.
.PP
See XML::Simple's strict mode documentation for
more information.
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
XML::Simple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::XML5.16.3pm                     0100644 0001750 0001750 00000012502 12566242272 024421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::XML 3"
.TH Config::Any::XML 3 "2011-07-04" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::XML \- Load XML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1XML\s0 files. Example:
.PP
.Vb 9
\&    <config>
\&        <name>TestApp</name>
\&        <component name="Controller::Foo">
\&            <foo>bar</foo>
\&        </component>
\&        <model name="Baz">
\&            <qux>xyzzy</qux>
\&        </model>
\&    </config>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`xml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1XML\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires XML::Simple and XML::NamespaceSupport
in order to work.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Strict Mode"
.IX Subsection "Strict Mode"
If, by some chance, XML::Simple has already been loaded with the strict
flag turned on, then you will likely get errors as warnings will become
fatal exceptions and certain arguments to \fIXMLin()\fR will no longer be optional.
.PP
See XML::Simple's strict mode documentation for
more information.
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
XML::Simple
                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::XML5.18.3pm                     0100644 0001750 0001750 00000013023 12566242270 024420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::XML 3"
.TH Config::Any::XML 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::XML \- Load XML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1XML\s0 files. Example:
.PP
.Vb 9
\&    <config>
\&        <name>TestApp</name>
\&        <component name="Controller::Foo">
\&            <foo>bar</foo>
\&        </component>
\&        <model name="Baz">
\&            <qux>xyzzy</qux>
\&        </model>
\&    </config>
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`xml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as an \s-1XML\s0 file.
.SS "requires_all_of( )"
.IX Subsection "requires_all_of( )"
Specifies that this module requires XML::Simple and XML::NamespaceSupport
in order to work.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Strict Mode"
.IX Subsection "Strict Mode"
If, by some chance, XML::Simple has already been loaded with the strict
flag turned on, then you will likely get errors as warnings will become
fatal exceptions and certain arguments to \fIXMLin()\fR will no longer be optional.
.PP
See XML::Simple's strict mode documentation for
more information.
.SH "AUTHORS"
.IX Header "AUTHORS"
Brian Cassidy <bricas@cpan.org>
.PP
Joel Bernstein <rataxis@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
XML::Simple
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::YAML.3pm                        0100644 0001750 0001750 00000012137 12566242270 024213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::YAML 3"
.TH Config::Any::YAML 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::YAML \- Load YAML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1YAML\s0 files. Example:
.PP
.Vb 6
\&    \-\-\-
\&    name: TestApp
\&    Controller::Foo:
\&        foo: bar
\&    Model::Baz:
\&        qux: xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`yml\*(C'\fR, \f(CW\*(C`yaml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1YAML\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of \s-1YAML::XS\s0, YAML::Syck (0.70) or
\&\s-1YAML\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1YAML::XS\s0
.IP "\(bu" 4
\&\s-1YAML\s0
.IP "\(bu" 4
YAML::Syck
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::YAML5.16.3pm                    0100644 0001750 0001750 00000011616 12566242272 024530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::YAML 3"
.TH Config::Any::YAML 3 "2011-07-04" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::YAML \- Load YAML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1YAML\s0 files. Example:
.PP
.Vb 6
\&    \-\-\-
\&    name: TestApp
\&    Controller::Foo:
\&        foo: bar
\&    Model::Baz:
\&        qux: xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`yml\*(C'\fR, \f(CW\*(C`yaml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1YAML\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of \s-1YAML::XS\s0, YAML::Syck (0.70) or
\&\s-1YAML\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2011 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1YAML::XS\s0
.IP "\(bu" 4
\&\s-1YAML\s0
.IP "\(bu" 4
YAML::Syck
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Any::YAML5.18.3pm                    0100644 0001750 0001750 00000012137 12566242270 024527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Any::YAML 3"
.TH Config::Any::YAML 3 "2013-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Any::YAML \- Load YAML config files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Loads \s-1YAML\s0 files. Example:
.PP
.Vb 6
\&    \-\-\-
\&    name: TestApp
\&    Controller::Foo:
\&        foo: bar
\&    Model::Baz:
\&        qux: xyzzy
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "extensions( )"
.IX Subsection "extensions( )"
return an array of valid extensions (\f(CW\*(C`yml\*(C'\fR, \f(CW\*(C`yaml\*(C'\fR).
.ie n .SS "load( $file )"
.el .SS "load( \f(CW$file\fP )"
.IX Subsection "load( $file )"
Attempts to load \f(CW$file\fR as a \s-1YAML\s0 file.
.SS "requires_any_of( )"
.IX Subsection "requires_any_of( )"
Specifies that this modules requires one of \s-1YAML::XS\s0, YAML::Syck (0.70) or
\&\s-1YAML\s0 in order to work.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Cassidy <bricas@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2013 by Brian Cassidy
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Catalyst
.IP "\(bu" 4
Config::Any
.IP "\(bu" 4
\&\s-1YAML::XS\s0
.IP "\(bu" 4
\&\s-1YAML\s0
.IP "\(bu" 4
YAML::Syck
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Extensions.3pm                       0100644 0001750 0001750 00000012116 12566207453 024755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Extensions 3pm"
.TH Config::Extensions 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Extensions \- hash lookup of which core extensions were built.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Config::Extensions \*(Aq%Extensions\*(Aq;
\&    if ($Extensions{PerlIO::via}) {
\&        # This perl has PerlIO::via built
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Config::Extensions module provides a hash \f(CW%Extensions\fR containing all
the core extensions that were enabled for this perl. The hash is keyed by
extension name, with each entry having one of 3 possible values:
.IP "dynamic" 4
.IX Item "dynamic"
The extension is dynamically linked
.IP "nonxs" 4
.IX Item "nonxs"
The extension is pure perl, so doesn't need linking to the perl executable
.IP "static" 4
.IX Item "static"
The extension is statically linked to the perl binary
.PP
As all values evaluate to true, a simple \f(CW\*(C`if\*(C'\fR test is good enough to determine
whether an extension is present.
.PP
All the data uses to generate the \f(CW%Extensions\fR hash is already present in
the \f(CW\*(C`Config\*(C'\fR module, but not in such a convenient format to quickly reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nicholas Clark <nick@ccl4.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Extensions5.16.3pm                   0100644 0001750 0001750 00000011575 12566207432 025274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Extensions 3pm"
.TH Config::Extensions 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Extensions \- hash lookup of which core extensions were built.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Config::Extensions \*(Aq%Extensions\*(Aq;
\&    if ($Extensions{PerlIO::via}) {
\&        # This perl has PerlIO::via built
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Config::Extensions module provides a hash \f(CW%Extensions\fR containing all
the core extensions that were enabled for this perl. The hash is keyed by
extension name, with each entry having one of 3 possible values:
.IP "dynamic" 4
.IX Item "dynamic"
The extension is dynamically linked
.IP "nonxs" 4
.IX Item "nonxs"
The extension is pure perl, so doesn't need linking to the perl executable
.IP "static" 4
.IX Item "static"
The extension is statically linked to the perl binary
.PP
As all values evaluate to true, a simple \f(CW\*(C`if\*(C'\fR test is good enough to determine
whether an extension is present.
.PP
All the data uses to generate the \f(CW%Extensions\fR hash is already present in
the \f(CW\*(C`Config\*(C'\fR module, but not in such a convenient format to quickly reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nicholas Clark <nick@ccl4.org>
                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Extensions5.18.3pm                   0100644 0001750 0001750 00000012116 12566207453 025271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Extensions 3pm"
.TH Config::Extensions 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Extensions \- hash lookup of which core extensions were built.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Config::Extensions \*(Aq%Extensions\*(Aq;
\&    if ($Extensions{PerlIO::via}) {
\&        # This perl has PerlIO::via built
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Config::Extensions module provides a hash \f(CW%Extensions\fR containing all
the core extensions that were enabled for this perl. The hash is keyed by
extension name, with each entry having one of 3 possible values:
.IP "dynamic" 4
.IX Item "dynamic"
The extension is dynamically linked
.IP "nonxs" 4
.IX Item "nonxs"
The extension is pure perl, so doesn't need linking to the perl executable
.IP "static" 4
.IX Item "static"
The extension is statically linked to the perl binary
.PP
As all values evaluate to true, a simple \f(CW\*(C`if\*(C'\fR test is good enough to determine
whether an extension is present.
.PP
All the data uses to generate the \f(CW%Extensions\fR hash is already present in
the \f(CW\*(C`Config\*(C'\fR module, but not in such a convenient format to quickly reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nicholas Clark <nick@ccl4.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Perl::V.3pm                          0100644 0001750 0001750 00000023314 12566207453 024034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Perl::V 3pm"
.TH Config::Perl::V 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Perl::V \- Structured data retrieval of perl \-V output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Config::Perl::V;
\&
\& my $local_config = Config::Perl::V::myconfig ();
\& print $local_config\->{config}{osname};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$conf = myconfig ()"
.el .SS "\f(CW$conf\fP = myconfig ()"
.IX Subsection "$conf = myconfig ()"
This function will collect the data described in \*(L"the hash structure\*(R" below,
and return that as a hash reference. It optionally accepts an option to
include more entries from \f(CW%ENV\fR. See environment below.
.PP
Note that this will not work on uninstalled perls when called with
\&\f(CW\*(C`\-I/path/to/uninstalled/perl/lib\*(C'\fR, but it works when that path is in
\&\f(CW$PERL5LIB\fR or in \f(CW$PERL5OPT\fR, as paths passed using \f(CW\*(C`\-I\*(C'\fR are not
known when the \f(CW\*(C`\-V\*(C'\fR information is collected.
.ie n .SS "$conf = plv2hash ($text [, ...])"
.el .SS "\f(CW$conf\fP = plv2hash ($text [, ...])"
.IX Subsection "$conf = plv2hash ($text [, ...])"
Convert a sole 'perl \-V' text block, or list of lines, to a complete
myconfig hash.  All unknown entries are defaulted.
.ie n .SS "$info = summary ([$conf])"
.el .SS "\f(CW$info\fP = summary ([$conf])"
.IX Subsection "$info = summary ([$conf])"
Return an arbitrary selection of the information. If no \f(CW$conf\fR is
given, \f(CW\*(C`myconfig ()\*(C'\fR is used instead.
.ie n .SS "$md5 = signature ([$conf])"
.el .SS "\f(CW$md5\fP = signature ([$conf])"
.IX Subsection "$md5 = signature ([$conf])"
Return the \s-1MD5\s0 of the info returned by \f(CW\*(C`summary ()\*(C'\fR without the
\&\f(CW\*(C`config_args\*(C'\fR entry.
.PP
If \f(CW\*(C`Digest::MD5\*(C'\fR is not available, it return a string with only \f(CW0\fR's.
.SS "The hash structure"
.IX Subsection "The hash structure"
The returned hash consists of 4 parts:
.IP "build" 4
.IX Item "build"
This information is extracted from the second block that is emitted by
\&\f(CW\*(C`perl \-V\*(C'\fR, and usually looks something like
.Sp
.Vb 10
\& Characteristics of this binary (from libperl):
\&   Compile\-time options: DEBUGGING USE_64_BIT_INT USE_LARGE_FILES
\&   Locally applied patches:
\&         defined\-or
\&         MAINT24637
\&   Built under linux
\&   Compiled at Jun 13 2005 10:44:20
\&   @INC:
\&     /usr/lib/perl5/5.8.7/i686\-linux\-64int
\&     /usr/lib/perl5/5.8.7
\&     /usr/lib/perl5/site_perl/5.8.7/i686\-linux\-64int
\&     /usr/lib/perl5/site_perl/5.8.7
\&     /usr/lib/perl5/site_perl
\&     .
.Ve
.Sp
or
.Sp
.Vb 9
\& Characteristics of this binary (from libperl):
\&   Compile\-time options: DEBUGGING MULTIPLICITY
\&                         PERL_DONT_CREATE_GVSV PERL_IMPLICIT_CONTEXT
\&                         PERL_MALLOC_WRAP PERL_TRACK_MEMPOOL
\&                         PERL_USE_SAFE_PUTENV USE_ITHREADS
\&                         USE_LARGE_FILES USE_PERLIO
\&                         USE_REENTRANT_API
\&   Built under linux
\&   Compiled at Jan 28 2009 15:26:59
.Ve
.Sp
This information is not available anywhere else, including \f(CW%Config\fR,
but it is the information that is only known to the perl binary.
.Sp
The extracted information is stored in 5 entries in the \f(CW\*(C`build\*(C'\fR hash:
.RS 4
.IP "osname" 4
.IX Item "osname"
This is most likely the same as \f(CW$Config{osname}\fR, and was the name
known when perl was built. It might be different if perl was cross-compiled.
.Sp
The default for this field, if it cannot be extracted, is to copy
\&\f(CW$Config{osname}\fR. The two may be differing in casing (OpenBSD vs openbsd).
.IP "stamp" 4
.IX Item "stamp"
This is the time string for which the perl binary was compiled. The default
value is 0.
.IP "options" 4
.IX Item "options"
This is a hash with all the known defines as keys. The value is either 0,
which means unknown or unset, or 1, which means defined.
.IP "derived" 4
.IX Item "derived"
As some variables are reported by a different name in the output of \f(CW\*(C`perl \-V\*(C'\fR
than their actual name in \f(CW%Config\fR, I decided to leave the \f(CW\*(C`config\*(C'\fR entry
as close to reality as possible, and put in the entries that might have been
guessed by the printed output in a separate block.
.IP "patches" 4
.IX Item "patches"
This is a list of optionally locally applied patches. Default is an empty list.
.RE
.RS 4
.RE
.IP "environment" 4
.IX Item "environment"
By default this hash is only filled with the environment variables
out of \f(CW%ENV\fR that start with \f(CW\*(C`PERL\*(C'\fR, but you can pass the \f(CW\*(C`env\*(C'\fR option
to myconfig to get more
.Sp
.Vb 2
\& my $conf = Config::Perl::V::myconfig ({ env => qr/^ORACLE/ });
\& my $conf = Config::Perl::V::myconfig ([ env => qr/^ORACLE/ ]);
.Ve
.IP "config" 4
.IX Item "config"
This hash is filled with the variables that \f(CW\*(C`perl \-V\*(C'\fR fills its report
with, and it has the same variables that \f(CW\*(C`Config::myconfig\*(C'\fR returns
from \f(CW%Config\fR.
.IP "inc" 4
.IX Item "inc"
This is the list of default \f(CW@INC\fR.
.SH "REASONING"
.IX Header "REASONING"
This module was written to be able to return the configuration for the
currently used perl as deeply as needed for the \s-1CPANTESTERS\s0 framework.
Up until now they used the output of myconfig as a single text blob,
and so it was missing the vital binary characteristics of the running
perl and the optional applied patches.
.SH "BUGS"
.IX Header "BUGS"
Please feedback what is wrong
.SH "TODO"
.IX Header "TODO"
.Vb 4
\& * Implement retrieval functions/methods
\& * Documentation
\& * Error checking
\& * Tests
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
H.Merijn Brand <h.m.brand@xs4all.nl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009\-2013 H.Merijn Brand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Config::Perl::V5.18.3pm                      0100644 0001750 0001750 00000023314 12566207453 024350  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Perl::V 3pm"
.TH Config::Perl::V 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Perl::V \- Structured data retrieval of perl \-V output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Config::Perl::V;
\&
\& my $local_config = Config::Perl::V::myconfig ();
\& print $local_config\->{config}{osname};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "$conf = myconfig ()"
.el .SS "\f(CW$conf\fP = myconfig ()"
.IX Subsection "$conf = myconfig ()"
This function will collect the data described in \*(L"the hash structure\*(R" below,
and return that as a hash reference. It optionally accepts an option to
include more entries from \f(CW%ENV\fR. See environment below.
.PP
Note that this will not work on uninstalled perls when called with
\&\f(CW\*(C`\-I/path/to/uninstalled/perl/lib\*(C'\fR, but it works when that path is in
\&\f(CW$PERL5LIB\fR or in \f(CW$PERL5OPT\fR, as paths passed using \f(CW\*(C`\-I\*(C'\fR are not
known when the \f(CW\*(C`\-V\*(C'\fR information is collected.
.ie n .SS "$conf = plv2hash ($text [, ...])"
.el .SS "\f(CW$conf\fP = plv2hash ($text [, ...])"
.IX Subsection "$conf = plv2hash ($text [, ...])"
Convert a sole 'perl \-V' text block, or list of lines, to a complete
myconfig hash.  All unknown entries are defaulted.
.ie n .SS "$info = summary ([$conf])"
.el .SS "\f(CW$info\fP = summary ([$conf])"
.IX Subsection "$info = summary ([$conf])"
Return an arbitrary selection of the information. If no \f(CW$conf\fR is
given, \f(CW\*(C`myconfig ()\*(C'\fR is used instead.
.ie n .SS "$md5 = signature ([$conf])"
.el .SS "\f(CW$md5\fP = signature ([$conf])"
.IX Subsection "$md5 = signature ([$conf])"
Return the \s-1MD5\s0 of the info returned by \f(CW\*(C`summary ()\*(C'\fR without the
\&\f(CW\*(C`config_args\*(C'\fR entry.
.PP
If \f(CW\*(C`Digest::MD5\*(C'\fR is not available, it return a string with only \f(CW0\fR's.
.SS "The hash structure"
.IX Subsection "The hash structure"
The returned hash consists of 4 parts:
.IP "build" 4
.IX Item "build"
This information is extracted from the second block that is emitted by
\&\f(CW\*(C`perl \-V\*(C'\fR, and usually looks something like
.Sp
.Vb 10
\& Characteristics of this binary (from libperl):
\&   Compile\-time options: DEBUGGING USE_64_BIT_INT USE_LARGE_FILES
\&   Locally applied patches:
\&         defined\-or
\&         MAINT24637
\&   Built under linux
\&   Compiled at Jun 13 2005 10:44:20
\&   @INC:
\&     /usr/lib/perl5/5.8.7/i686\-linux\-64int
\&     /usr/lib/perl5/5.8.7
\&     /usr/lib/perl5/site_perl/5.8.7/i686\-linux\-64int
\&     /usr/lib/perl5/site_perl/5.8.7
\&     /usr/lib/perl5/site_perl
\&     .
.Ve
.Sp
or
.Sp
.Vb 9
\& Characteristics of this binary (from libperl):
\&   Compile\-time options: DEBUGGING MULTIPLICITY
\&                         PERL_DONT_CREATE_GVSV PERL_IMPLICIT_CONTEXT
\&                         PERL_MALLOC_WRAP PERL_TRACK_MEMPOOL
\&                         PERL_USE_SAFE_PUTENV USE_ITHREADS
\&                         USE_LARGE_FILES USE_PERLIO
\&                         USE_REENTRANT_API
\&   Built under linux
\&   Compiled at Jan 28 2009 15:26:59
.Ve
.Sp
This information is not available anywhere else, including \f(CW%Config\fR,
but it is the information that is only known to the perl binary.
.Sp
The extracted information is stored in 5 entries in the \f(CW\*(C`build\*(C'\fR hash:
.RS 4
.IP "osname" 4
.IX Item "osname"
This is most likely the same as \f(CW$Config{osname}\fR, and was the name
known when perl was built. It might be different if perl was cross-compiled.
.Sp
The default for this field, if it cannot be extracted, is to copy
\&\f(CW$Config{osname}\fR. The two may be differing in casing (OpenBSD vs openbsd).
.IP "stamp" 4
.IX Item "stamp"
This is the time string for which the perl binary was compiled. The default
value is 0.
.IP "options" 4
.IX Item "options"
This is a hash with all the known defines as keys. The value is either 0,
which means unknown or unset, or 1, which means defined.
.IP "derived" 4
.IX Item "derived"
As some variables are reported by a different name in the output of \f(CW\*(C`perl \-V\*(C'\fR
than their actual name in \f(CW%Config\fR, I decided to leave the \f(CW\*(C`config\*(C'\fR entry
as close to reality as possible, and put in the entries that might have been
guessed by the printed output in a separate block.
.IP "patches" 4
.IX Item "patches"
This is a list of optionally locally applied patches. Default is an empty list.
.RE
.RS 4
.RE
.IP "environment" 4
.IX Item "environment"
By default this hash is only filled with the environment variables
out of \f(CW%ENV\fR that start with \f(CW\*(C`PERL\*(C'\fR, but you can pass the \f(CW\*(C`env\*(C'\fR option
to myconfig to get more
.Sp
.Vb 2
\& my $conf = Config::Perl::V::myconfig ({ env => qr/^ORACLE/ });
\& my $conf = Config::Perl::V::myconfig ([ env => qr/^ORACLE/ ]);
.Ve
.IP "config" 4
.IX Item "config"
This hash is filled with the variables that \f(CW\*(C`perl \-V\*(C'\fR fills its report
with, and it has the same variables that \f(CW\*(C`Config::myconfig\*(C'\fR returns
from \f(CW%Config\fR.
.IP "inc" 4
.IX Item "inc"
This is the list of default \f(CW@INC\fR.
.SH "REASONING"
.IX Header "REASONING"
This module was written to be able to return the configuration for the
currently used perl as deeply as needed for the \s-1CPANTESTERS\s0 framework.
Up until now they used the output of myconfig as a single text blob,
and so it was missing the vital binary characteristics of the running
perl and the optional applied patches.
.SH "BUGS"
.IX Header "BUGS"
Please feedback what is wrong
.SH "TODO"
.IX Header "TODO"
.Vb 4
\& * Implement retrieval functions/methods
\& * Documentation
\& * Error checking
\& * Tests
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
H.Merijn Brand <h.m.brand@xs4all.nl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009\-2013 H.Merijn Brand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Context::Preserve.3pm                        0100644 0001750 0001750 00000017412 12566242306 024630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Context::Preserve 3"
.TH Context::Preserve 3 "2008-01-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Context::Preserve \- run code after a subroutine call, preserving the context the subroutine would have seen if it were the last statement in the caller
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Have you ever written this?
.PP
.Vb 1
\&    my ($result, @result);
\&
\&    # run a sub in the correct context
\&    if(!defined wantarray){
\&        some::code();
\&    }
\&    elsif(wantarray){
\&        @result = some::code();
\&    }
\&    else {
\&        $result = some::code();
\&    }
\&  
\&    # do something after some::code
\&    $_ += 42 for (@result, $result);
\&  
\&    # finally return the correct value
\&    if(!defined wantarray){
\&        return;
\&    }
\&    elsif(wantarray){
\&        return @result;
\&    }
\&    else {
\&        return $result;
\&    }
.Ve
.PP
Now you can just write this instead:
.PP
.Vb 1
\&  use Context::Preserve;
\&
\&  return preserve_context { some::code() }
\&             after => sub { $_ += 42 for @_ };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes you need to call a function, get the results, act on the
results, then return the result of the function.  This is painful
because of contexts; the original function can behave different if
it's called in void, scalar, or list context.  You can ignore the
various cases and just pick one, but that's fragile.  To do things
right, you need to see which case you're being called in, and then
call the function in that context.  This results in 3 code paths,
which is a pain to type in (and maintain).
.PP
This module automates the process.  You provide a coderef that is the
\&\*(L"original function\*(R", and another coderef to run after the original
runs.  You can modify the return value (aliased to \f(CW@_\fR) here, and do
whatever else you need to do.  \f(CW\*(C`wantarray\*(C'\fR is correct inside both
coderefs; in \*(L"after\*(R", though, the return value is ignored and the
value \f(CW\*(C`wantarray\*(C'\fR returns is related to the context that the original
function was called in.
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`preserve_context\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "preserve_context { original } [after|replace] => sub { after }"
.IX Subsection "preserve_context { original } [after|replace] => sub { after }"
Invokes \f(CW\*(C`original\*(C'\fR in the same context as \f(CW\*(C`preserve_context\*(C'\fR was
called in, save the results, runs \f(CW\*(C`after\*(C'\fR in the same context, then
returns the result of \f(CW\*(C`original\*(C'\fR (or \f(CW\*(C`after\*(C'\fR if \f(CW\*(C`replace\*(C'\fR is used).
.PP
If the second argument is \f(CW\*(C`after\*(C'\fR, then you can modify \f(CW@_\fR to
affect the return value.  \f(CW\*(C`after\*(C'\fR's return value is ignored.
.PP
If the second argument is \f(CW\*(C`replace\*(C'\fR, then modifying \f(CW@_\fR doesn't do
anything.  The return value of \f(CW\*(C`after\*(C'\fR is returned from
\&\f(CW\*(C`preserve_context\*(C'\fR instead.
.PP
Run \f(CW\*(C`preserve_context\*(C'\fR like this:
.PP
.Vb 5
\&  sub whatever {
\&      ...
\&      return preserve_context { orginal_function() }
\&                 after => sub { modify @_          };
\&  }
\&
\&  or
\&
\&  sub whatever {
\&      ...
\&      return preserve_context   { orginal_function() }
\&                 replace => sub { return @new_return };
\&  }
.Ve
.PP
Note that there's no comma between the first block and the \f(CW\*(C`after
=>\*(C'\fR part.  This is how perl parses functions with the \f(CW\*(C`(&@)\*(C'\fR
prototype.  The alternative is to say:
.PP
.Vb 1
\&      preserve_context(sub { original }, after => sub { after });
.Ve
.PP
You can pick the one you like, but I think the first version is much
prettier.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Jonathan Rockway \f(CW\*(C`<jrockway@cpan.org>\*(C'\fR
.PP
Copyright (c) 2008 Infinity Interactive.  You may redistribute this
module under the same terms as Perl itself.
                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Context::Preserve5.16.3pm                    0100644 0001750 0001750 00000017071 12566242310 025136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Context::Preserve 3"
.TH Context::Preserve 3 "2008-01-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Context::Preserve \- run code after a subroutine call, preserving the context the subroutine would have seen if it were the last statement in the caller
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Have you ever written this?
.PP
.Vb 1
\&    my ($result, @result);
\&
\&    # run a sub in the correct context
\&    if(!defined wantarray){
\&        some::code();
\&    }
\&    elsif(wantarray){
\&        @result = some::code();
\&    }
\&    else {
\&        $result = some::code();
\&    }
\&  
\&    # do something after some::code
\&    $_ += 42 for (@result, $result);
\&  
\&    # finally return the correct value
\&    if(!defined wantarray){
\&        return;
\&    }
\&    elsif(wantarray){
\&        return @result;
\&    }
\&    else {
\&        return $result;
\&    }
.Ve
.PP
Now you can just write this instead:
.PP
.Vb 1
\&  use Context::Preserve;
\&
\&  return preserve_context { some::code() }
\&             after => sub { $_ += 42 for @_ };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes you need to call a function, get the results, act on the
results, then return the result of the function.  This is painful
because of contexts; the original function can behave different if
it's called in void, scalar, or list context.  You can ignore the
various cases and just pick one, but that's fragile.  To do things
right, you need to see which case you're being called in, and then
call the function in that context.  This results in 3 code paths,
which is a pain to type in (and maintain).
.PP
This module automates the process.  You provide a coderef that is the
\&\*(L"original function\*(R", and another coderef to run after the original
runs.  You can modify the return value (aliased to \f(CW@_\fR) here, and do
whatever else you need to do.  \f(CW\*(C`wantarray\*(C'\fR is correct inside both
coderefs; in \*(L"after\*(R", though, the return value is ignored and the
value \f(CW\*(C`wantarray\*(C'\fR returns is related to the context that the original
function was called in.
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`preserve_context\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "preserve_context { original } [after|replace] => sub { after }"
.IX Subsection "preserve_context { original } [after|replace] => sub { after }"
Invokes \f(CW\*(C`original\*(C'\fR in the same context as \f(CW\*(C`preserve_context\*(C'\fR was
called in, save the results, runs \f(CW\*(C`after\*(C'\fR in the same context, then
returns the result of \f(CW\*(C`original\*(C'\fR (or \f(CW\*(C`after\*(C'\fR if \f(CW\*(C`replace\*(C'\fR is used).
.PP
If the second argument is \f(CW\*(C`after\*(C'\fR, then you can modify \f(CW@_\fR to
affect the return value.  \f(CW\*(C`after\*(C'\fR's return value is ignored.
.PP
If the second argument is \f(CW\*(C`replace\*(C'\fR, then modifying \f(CW@_\fR doesn't do
anything.  The return value of \f(CW\*(C`after\*(C'\fR is returned from
\&\f(CW\*(C`preserve_context\*(C'\fR instead.
.PP
Run \f(CW\*(C`preserve_context\*(C'\fR like this:
.PP
.Vb 5
\&  sub whatever {
\&      ...
\&      return preserve_context { orginal_function() }
\&                 after => sub { modify @_          };
\&  }
\&
\&  or
\&
\&  sub whatever {
\&      ...
\&      return preserve_context   { orginal_function() }
\&                 replace => sub { return @new_return };
\&  }
.Ve
.PP
Note that there's no comma between the first block and the \f(CW\*(C`after
=>\*(C'\fR part.  This is how perl parses functions with the \f(CW\*(C`(&@)\*(C'\fR
prototype.  The alternative is to say:
.PP
.Vb 1
\&      preserve_context(sub { original }, after => sub { after });
.Ve
.PP
You can pick the one you like, but I think the first version is much
prettier.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Jonathan Rockway \f(CW\*(C`<jrockway@cpan.org>\*(C'\fR
.PP
Copyright (c) 2008 Infinity Interactive.  You may redistribute this
module under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Context::Preserve5.18.3pm                    0100644 0001750 0001750 00000017412 12566242306 025144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Context::Preserve 3"
.TH Context::Preserve 3 "2008-01-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Context::Preserve \- run code after a subroutine call, preserving the context the subroutine would have seen if it were the last statement in the caller
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Have you ever written this?
.PP
.Vb 1
\&    my ($result, @result);
\&
\&    # run a sub in the correct context
\&    if(!defined wantarray){
\&        some::code();
\&    }
\&    elsif(wantarray){
\&        @result = some::code();
\&    }
\&    else {
\&        $result = some::code();
\&    }
\&  
\&    # do something after some::code
\&    $_ += 42 for (@result, $result);
\&  
\&    # finally return the correct value
\&    if(!defined wantarray){
\&        return;
\&    }
\&    elsif(wantarray){
\&        return @result;
\&    }
\&    else {
\&        return $result;
\&    }
.Ve
.PP
Now you can just write this instead:
.PP
.Vb 1
\&  use Context::Preserve;
\&
\&  return preserve_context { some::code() }
\&             after => sub { $_ += 42 for @_ };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes you need to call a function, get the results, act on the
results, then return the result of the function.  This is painful
because of contexts; the original function can behave different if
it's called in void, scalar, or list context.  You can ignore the
various cases and just pick one, but that's fragile.  To do things
right, you need to see which case you're being called in, and then
call the function in that context.  This results in 3 code paths,
which is a pain to type in (and maintain).
.PP
This module automates the process.  You provide a coderef that is the
\&\*(L"original function\*(R", and another coderef to run after the original
runs.  You can modify the return value (aliased to \f(CW@_\fR) here, and do
whatever else you need to do.  \f(CW\*(C`wantarray\*(C'\fR is correct inside both
coderefs; in \*(L"after\*(R", though, the return value is ignored and the
value \f(CW\*(C`wantarray\*(C'\fR returns is related to the context that the original
function was called in.
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`preserve_context\*(C'\fR
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "preserve_context { original } [after|replace] => sub { after }"
.IX Subsection "preserve_context { original } [after|replace] => sub { after }"
Invokes \f(CW\*(C`original\*(C'\fR in the same context as \f(CW\*(C`preserve_context\*(C'\fR was
called in, save the results, runs \f(CW\*(C`after\*(C'\fR in the same context, then
returns the result of \f(CW\*(C`original\*(C'\fR (or \f(CW\*(C`after\*(C'\fR if \f(CW\*(C`replace\*(C'\fR is used).
.PP
If the second argument is \f(CW\*(C`after\*(C'\fR, then you can modify \f(CW@_\fR to
affect the return value.  \f(CW\*(C`after\*(C'\fR's return value is ignored.
.PP
If the second argument is \f(CW\*(C`replace\*(C'\fR, then modifying \f(CW@_\fR doesn't do
anything.  The return value of \f(CW\*(C`after\*(C'\fR is returned from
\&\f(CW\*(C`preserve_context\*(C'\fR instead.
.PP
Run \f(CW\*(C`preserve_context\*(C'\fR like this:
.PP
.Vb 5
\&  sub whatever {
\&      ...
\&      return preserve_context { orginal_function() }
\&                 after => sub { modify @_          };
\&  }
\&
\&  or
\&
\&  sub whatever {
\&      ...
\&      return preserve_context   { orginal_function() }
\&                 replace => sub { return @new_return };
\&  }
.Ve
.PP
Note that there's no comma between the first block and the \f(CW\*(C`after
=>\*(C'\fR part.  This is how perl parses functions with the \f(CW\*(C`(&@)\*(C'\fR
prototype.  The alternative is to say:
.PP
.Vb 1
\&      preserve_context(sub { original }, after => sub { after });
.Ve
.PP
You can pick the one you like, but I think the first version is much
prettier.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Jonathan Rockway \f(CW\*(C`<jrockway@cpan.org>\*(C'\fR
.PP
Copyright (c) 2008 Infinity Interactive.  You may redistribute this
module under the same terms as Perl itself.
                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::ASN1.3pm                            0100644 0001750 0001750 00000046216 12566241532 023537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::ASN1 3"
.TH Convert::ASN1 3 "2012-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::ASN1 \- ASN.1 Encode/Decode library
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use Convert::ASN1;
\&
\&  $asn = Convert::ASN1\->new;
\&  $asn\->prepare(q<
\&
\&    [APPLICATION 7] SEQUENCE {
\&      int INTEGER,
\&      str OCTET STRING
\&    }
\&
\&  >);
\&
\&  $pdu = $asn\->encode( int => 7, str => "string");
\&
\&  $out = $asn\->decode($pdu);
\&  print $out\->{int}," ",$out\->{str},"\en";
\&
\&  use Convert::ASN1 qw(:io);
\&
\&  $peer   = asn_recv($sock,$buffer,0);
\&  $nbytes = asn_read($fh, $buffer);
\&  $nbytes = asn_send($sock, $buffer, $peer);
\&  $nbytes = asn_send($sock, $buffer);
\&  $nbytes = asn_write($fh, $buffer);
\&  $buffer = asn_get($fh);
\&  $yes    = asn_ready($fh)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Convert::ASN1 encodes and decodes \s-1ASN.1\s0 data structures using \s-1BER/DER\s0
rules.
.SH "METHODS"
.IX Header "METHODS"
.SS "new ( [\s-1OPTIONS\s0] )"
.IX Subsection "new ( [OPTIONS] )"
Contructor, creates a new object.
.PP
If given, \fB\s-1OPTIONS\s0\fR are the same ones as for \*(L"configure ( \s-1OPTIONS \s0)\*(R" below.
.SS "error ()"
.IX Subsection "error ()"
Returns the last error.
.SS "configure ( \s-1OPTIONS \s0)"
.IX Subsection "configure ( OPTIONS )"
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.
.IP "encode" 4
.IX Item "encode"
Reference to a hash which contains various encode options.
.IP "decode" 4
.IX Item "decode"
Reference to a hash which contains various decode options.
.IP "encoding" 4
.IX Item "encoding"
One of '\s-1BER\s0' or '\s-1DER\s0'. The default is '\s-1BER\s0'
.IP "tagdefault" 4
.IX Item "tagdefault"
One of '\s-1EXPLICIT\s0' or '\s-1IMPLICIT\s0'.
Default tagging conventions are normally given in the \s-1ASN.1\s0 module definition (not supported by the parser). The \s-1ASN.1\s0 spec states \s-1EXPLICIT\s0 tagging is the default, but this option has \s-1IMPLICIT\s0 tagging default for backward compatibility reasons.
.PP
Encode options
.IP "real" 4
.IX Item "real"
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'
.IP "time" 4
.IX Item "time"
This controls how UTCTime and GeneralizedTime elements are encoded. The default
is \f(CW\*(C`withzone\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value passed will be encoded without a zone, ie a \s-1UTC\s0 value.
.IP "withzone" 4
.IX Item "withzone"
The value will be encoded with a zone. By default it will be encoded
using the local time offset. The offset may be set using the \f(CW\*(C`timezone\*(C'\fR
configure option.
.IP "raw" 4
.IX Item "raw"
The value passed should already be in the correct format and will be copied
into the \s-1PDU\s0 as-is.
.RE
.RS 4
.RE
.IP "timezone" 4
.IX Item "timezone"
By default UTCTime and GeneralizedTime will be encoded using the local
time offset from \s-1UTC.\s0 This will over-ride that. It is an offset from \s-1UTC\s0
in seconds.  This option can be overridden by passing a reference to a
list of two values as the time value. The list should contain the time
value and the offset from \s-1UTC\s0 in seconds.
.IP "bigint" 4
.IX Item "bigint"
If during encoding an value greater than 32 bits is discovered and
is not already a big integer object, then the value will first be
converted into a big integer object. This option controls the big
integer class into which the objects will be blessed. The default
is to use Math::BigInt
.PP
Decode options
.IP "time" 4
.IX Item "time"
This controls how a UTCTime or a GeneralizedTime element will be decoded. The default
is \f(CW\*(C`utctime\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value returned will be a time value as returned by the \f(CW\*(C`time\*(C'\fR function.
.IP "withzone" 4
.IX Item "withzone"
The value returned will be a reference to an array of two values. The first is the
same as with \f(CW\*(C`utctime\*(C'\fR, the second is the timezone offset, in seconds, that was
used in the encoding.
.IP "raw" 4
.IX Item "raw"
The value returned will be the raw encoding as extracted from the \s-1PDU.\s0
.RE
.RS 4
.RE
.IP "bigint" 4
.IX Item "bigint"
If during decoding any big integers are discovered (integers greater
than 32 bits), they will be decoded into big integer objects. This option
controls the big integer class into which the objects will be blessed.
The default is to use Math::BigInt.
.IP "null" 4
.IX Item "null"
The value to decode \s-1ASN.1 NULL\s0 types into.
If not set, it defaults to \f(CW1\fR.
.SS "prepare ( \s-1ASN \s0)"
.IX Subsection "prepare ( ASN )"
Compile the given \s-1ASN.1\s0 descripton which can be passed as a string
or as a filehandle. The syntax used is very close to \s-1ASN.1,\s0 but has
a few differences. If the \s-1ASN\s0 decribes only one macro then encode/decode can be
called on this object. If \s-1ASN\s0 describes more than one \s-1ASN.1\s0 macro then \f(CW\*(C`find\*(C'\fR
must be called. The method returns undef on error.
.SS "prepare_file ( \s-1ASNPATH \s0)"
.IX Subsection "prepare_file ( ASNPATH )"
Compile the \s-1ASN.1\s0 description to be read from the specified pathname.
.SS "find ( \s-1MACRO \s0)"
.IX Subsection "find ( MACRO )"
Find a macro from a prepared \s-1ASN.1\s0 description. Returns an object which can
be used for encode/decode.
.SS "encode ( \s-1VARIABLES \s0)"
.IX Subsection "encode ( VARIABLES )"
Encode a \s-1PDU.\s0 Top-level variable are passed as name-value pairs, or as a reference
to a hash containing them. Returns the encoded \s-1PDU,\s0 or undef on error.
.SS "decode ( \s-1PDU \s0)"
.IX Subsection "decode ( PDU )"
Decode the \s-1PDU,\s0 returns a reference to a hash containg the values for the \s-1PDU.\s0 Returns
undef if there was an error.
.SS "registeroid ( \s-1OID, HANDLER \s0)"
.IX Subsection "registeroid ( OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SS "registertype ( \s-1NAME, OID, HANDLER \s0)"
.IX Subsection "registertype ( NAME, OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements named \f(CW\*(C`NAME\*(C'\fR,
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SH "EXPORTS"
.IX Header "EXPORTS"
As well as providing an object interface for encoding/decoding PDUs Convert::ASN1
also provides the following functions.
.SS "\s-1IO\s0 Functions"
.IX Subsection "IO Functions"
.IP "asn_recv ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_recv ( SOCK, BUFFER, FLAGS )"
Will read a single element from the socket \s-1SOCK\s0 into \s-1BUFFER.  FLAGS\s0 may
be \s-1MSG_PEEK\s0 as exported by \f(CW\*(C`Socket\*(C'\fR. Returns the address of the sender,
or undef if there was an error. Some systems do not support the return
of the peer address when the socket is a connected socket, in these
cases the empty string will be returned. This is the same behaviour
as the \f(CW\*(C`recv\*(C'\fR function in perl itself.
.Sp
It is recommended that if the socket is of type \s-1SOCK_DGRAM\s0 then \f(CW\*(C`recv\*(C'\fR
be called directly instead of calling \f(CW\*(C`asn_recv\*(C'\fR.
.IP "asn_read ( \s-1FH, BUFFER, OFFSET \s0)" 4
.IX Item "asn_read ( FH, BUFFER, OFFSET )"
.PD 0
.IP "asn_read ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_read ( FH, BUFFER )"
.PD
Will read a single element from the filehandle \s-1FH\s0 into \s-1BUFFER.\s0 Returns the
number of bytes read if a complete element was read, \-1 if an incomplete
element was read or undef if there was an error. If \s-1OFFSET\s0 is specified
then it is assumed that \s-1BUFFER\s0 already contains an incomplete element
and new data will be appended starting at \s-1OFFSET.\s0
.Sp
If \s-1FH\s0 is a socket the asn_recv is used to read the element, so the same
restiction applies if \s-1FH\s0 is a socket of type \s-1SOCK_DGRAM.\s0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS, TO \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS, TO )"
.PD 0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS )"
.PD
Identical to calling \f(CW\*(C`send\*(C'\fR, see perlfunc
.IP "asn_write ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_write ( FH, BUFFER )"
Identical to calling \f(CW\*(C`syswrite\*(C'\fR with 2 arguments, see perlfunc
.IP "asn_get ( \s-1FH \s0)" 4
.IX Item "asn_get ( FH )"
\&\f(CW\*(C`asn_get\*(C'\fR provides buffered \s-1IO.\s0 Because it needs a buffer \s-1FH\s0 must be a \s-1GLOB\s0
or a reference to a \s-1GLOB. \s0\f(CW\*(C`asn_get\*(C'\fR will use two entries in the hash element
of the \s-1GLOB\s0 to use as its buffer:
.Sp
.Vb 2
\&  asn_buffer \- input buffer
\&  asn_need   \- number of bytes needed for the next element, if known
.Ve
.Sp
Returns an element or undef if there was an error.
.IP "asn_ready ( \s-1FH \s0)" 4
.IX Item "asn_ready ( FH )"
\&\f(CW\*(C`asn_ready\*(C'\fR works with \f(CW\*(C`asn_get\*(C'\fR. It will return true if \f(CW\*(C`asn_get\*(C'\fR has already
read enough data into the buffer to return a complete element.
.SS "Encode/Decode Functions"
.IX Subsection "Encode/Decode Functions"
.IP "asn_tag ( \s-1CLASS, VALUE \s0)" 4
.IX Item "asn_tag ( CLASS, VALUE )"
Given \fB\s-1CLASS\s0\fR and a \fB\s-1VALUE\s0\fR, calculate an integer which when encoded
will become the tag.
.IP "asn_decode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_decode_tag ( TAG )"
Decode the given \s-1ASN.1\s0 encoded \f(CW\*(C`TAG\*(C'\fR.
.IP "asn_encode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_encode_tag ( TAG )"
Encode \fB\s-1TAG\s0\fR value for encoding.
We assume that the tag has been correctly generated with \*(L"asn_tag ( \s-1CLASS, VALUE \s0)\*(R".
.IP "asn_decode_length ( \s-1LEN \s0)" 4
.IX Item "asn_decode_length ( LEN )"
Decode the given \s-1ASN.1\s0 decoded \f(CW\*(C`LEN\*(C'\fR.
.IP "asn_encode_length ( \s-1LEN \s0)" 4
.IX Item "asn_encode_length ( LEN )"
Encode the given \f(CW\*(C`LEN\*(C'\fR to its \s-1ASN.1\s0 encoding.
.SS "Constants"
.IX Subsection "Constants"
.IP "\s-1ASN_BIT_STR\s0" 4
.IX Item "ASN_BIT_STR"
.PD 0
.IP "\s-1ASN_BOOLEAN\s0" 4
.IX Item "ASN_BOOLEAN"
.IP "\s-1ASN_ENUMERATED\s0" 4
.IX Item "ASN_ENUMERATED"
.IP "\s-1ASN_GENERAL_TIME\s0" 4
.IX Item "ASN_GENERAL_TIME"
.IP "\s-1ASN_IA5_STR\s0" 4
.IX Item "ASN_IA5_STR"
.IP "\s-1ASN_INTEGER\s0" 4
.IX Item "ASN_INTEGER"
.IP "\s-1ASN_NULL\s0" 4
.IX Item "ASN_NULL"
.IP "\s-1ASN_OBJECT_ID\s0" 4
.IX Item "ASN_OBJECT_ID"
.IP "\s-1ASN_OCTET_STR\s0" 4
.IX Item "ASN_OCTET_STR"
.IP "\s-1ASN_PRINT_STR\s0" 4
.IX Item "ASN_PRINT_STR"
.IP "\s-1ASN_REAL\s0" 4
.IX Item "ASN_REAL"
.IP "\s-1ASN_SEQUENCE\s0" 4
.IX Item "ASN_SEQUENCE"
.IP "\s-1ASN_SET\s0" 4
.IX Item "ASN_SET"
.IP "\s-1ASN_UTC_TIME\s0" 4
.IX Item "ASN_UTC_TIME"
.IP "\s-1ASN_APPLICATION\s0" 4
.IX Item "ASN_APPLICATION"
.IP "\s-1ASN_CONTEXT\s0" 4
.IX Item "ASN_CONTEXT"
.IP "\s-1ASN_PRIVATE\s0" 4
.IX Item "ASN_PRIVATE"
.IP "\s-1ASN_UNIVERSAL\s0" 4
.IX Item "ASN_UNIVERSAL"
.IP "\s-1ASN_PRIMITIVE\s0" 4
.IX Item "ASN_PRIMITIVE"
.IP "\s-1ASN_CONSTRUCTOR\s0" 4
.IX Item "ASN_CONSTRUCTOR"
.IP "\s-1ASN_LONG_LEN\s0" 4
.IX Item "ASN_LONG_LEN"
.IP "\s-1ASN_EXTENSION_ID\s0" 4
.IX Item "ASN_EXTENSION_ID"
.IP "\s-1ASN_BIT\s0" 4
.IX Item "ASN_BIT"
.PD
.SS "Debug Functions"
.IX Subsection "Debug Functions"
.IP "asn_dump ( [\s-1FH,\s0] \s-1BUFFER \s0)" 4
.IX Item "asn_dump ( [FH,] BUFFER )"
Try to decode the given buffer as \s-1ASN.1\s0 structure and dump it to the
given file handle, or \f(CW\*(C`STDERR\*(C'\fR if the handle is not given.
.IP "asn_hexdump ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_hexdump ( FH, BUFFER )"
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.PD 0
.IP ":all" 4
.IX Item ":all"
.PD
All exported functions
.IP ":const" 4
.IX Item ":const"
\&\s-1ASN_BOOLEAN,     ASN_INTEGER,      ASN_BIT_STR,      ASN_OCTET_STR,
ASN_NULL,        ASN_OBJECT_ID,    ASN_REAL,         ASN_ENUMERATED,
ASN_SEQUENCE,    ASN_SET,          ASN_PRINT_STR,    ASN_IA5_STR,
ASN_UTC_TIME,    ASN_GENERAL_TIME,
ASN_UNIVERSAL,   ASN_APPLICATION,  ASN_CONTEXT,      ASN_PRIVATE,
ASN_PRIMITIVE,   ASN_CONSTRUCTOR,  ASN_LONG_LEN,     ASN_EXTENSION_ID, ASN_BIT\s0
.IP ":debug" 4
.IX Item ":debug"
asn_dump, asn_hexdump
.IP ":io" 4
.IX Item ":io"
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready
.IP ":tag" 4
.IX Item ":tag"
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length, asn_encode_length
.SH "MAPPING ASN.1 TO PERL"
.IX Header "MAPPING ASN.1 TO PERL"
Every element in the \s-1ASN.1\s0 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => "text" }
.Ve
.PP
In the case of a \s-1SEQUENCE, SET\s0 or \s-1CHOICE\s0 then the value in the namespace will
be a hash reference which will be the namespce for the elements with
that element.
.PP
.Vb 6
\&  # ASN.1
\&  int INTEGER,
\&  seq SEQUENCE {
\&    str OCTET STRING,
\&    bool BOOLEAN
\&  }
\&
\&  # Perl
\&  { int => 5, seq => { str => "text", bool => 1}}
.Ve
.PP
If the element is a \s-1SEQUENCE OF,\s0 or \s-1SET OF,\s0 then the value in the namespace
will be an array reference. The elements in the array will be of
the type expected by the type following the \s-1OF.\s0 For example
with \*(L"\s-1SEQUENCE OF STRING\*(R"\s0 the array would contain strings. With
\&\*(L"\s-1SEQUENCE OF SEQUENCE\s0 { ... }\*(R" the array will contain hash references
which will be used as namespaces
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => [ "text1", "text2"]}
\&
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF SEQUENCE {
\&    type OCTET STRING,
\&    value INTEGER
\&  }
\&
\&  # Perl
\&  { int => 5, str => [
\&    { type => "abc", value => 4 },
\&    { type => "def", value => \-1 },
\&  ]}
.Ve
.PP
Finally, if you wish to pre-parse \s-1ASN.1\s0 and hold it to include
inline in your \s-1PDU,\s0 you can coerce it into the \s-1ASN.1\s0 spec by
defining the value as \s-1ANY\s0 in the schema, and then pass the pre
encoded value inline.
.PP
.Vb 4
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING,
\&  pre ANY
\&
\&  # Perl
\&  { int => 5, str => "text", pre=>"\ex03\ex03\ex00\ex0a\ex05" }
.Ve
.PP
passes a pre-encoded \s-1BIT STRING\s0 instance as hex text. \-But
it could be a previous run of \f(CW$obj\fR\->\fIencode()\fR from another run
held in some variable.
.SS "Exceptions"
.IX Subsection "Exceptions"
There are some exceptions where Convert::ASN1 does not require an element to be named.
These are \s-1SEQUENCE\s0 {...}, \s-1SET\s0 {...} and \s-1CHOICE.\s0 In each case if the element is not
given a name then the elements inside the {...} will share the same namespace as
the elements outside of the {...}.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
\&\s-1XS\s0 implementation.
.IP "\(bu" 4
More documentation.
.IP "\(bu" 4
More tests.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@cpan.org>
.SH "SUPPORT"
.IX Header "SUPPORT"
Report issues via github at https://github.com/gbarr/perl\-Convert\-ASN1/issues
.PP
To contribute I encourage you to create a git fork of the repository at
https://github.com/gbarr/perl\-Convert\-ASN1 do you work on a fresh branch
created from master and submit a pull request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2012 Graham Barr <gbarr@cpan.org>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::ASN15.16.3pm                        0100644 0001750 0001750 00000046436 12566241532 024055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::ASN1 3"
.TH Convert::ASN1 3 "2012-06-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::ASN1 \- ASN.1 Encode/Decode library
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use Convert::ASN1;
\&
\&  $asn = Convert::ASN1\->new;
\&  $asn\->prepare(q<
\&
\&    [APPLICATION 7] SEQUENCE {
\&      int INTEGER,
\&      str OCTET STRING
\&    }
\&
\&  >);
\&
\&  $pdu = $asn\->encode( int => 7, str => "string");
\&
\&  $out = $asn\->decode($pdu);
\&  print $out\->{int}," ",$out\->{str},"\en";
\&
\&  use Convert::ASN1 qw(:io);
\&
\&  $peer   = asn_recv($sock,$buffer,0);
\&  $nbytes = asn_read($fh, $buffer);
\&  $nbytes = asn_send($sock, $buffer, $peer);
\&  $nbytes = asn_send($sock, $buffer);
\&  $nbytes = asn_write($fh, $buffer);
\&  $buffer = asn_get($fh);
\&  $yes    = asn_ready($fh)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Convert::ASN1 encodes and decodes \s-1ASN\s0.1 data structures using \s-1BER/DER\s0
rules.
.SH "METHODS"
.IX Header "METHODS"
.SS "new ( [\s-1OPTIONS\s0] )"
.IX Subsection "new ( [OPTIONS] )"
Contructor, creates a new object.
.PP
If given, \fB\s-1OPTIONS\s0\fR are the same ones as for \*(L"configure ( \s-1OPTIONS\s0 )\*(R" below.
.SS "error ()"
.IX Subsection "error ()"
Returns the last error.
.SS "configure ( \s-1OPTIONS\s0 )"
.IX Subsection "configure ( OPTIONS )"
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.
.IP "encode" 4
.IX Item "encode"
Reference to a hash which contains various encode options.
.IP "decode" 4
.IX Item "decode"
Reference to a hash which contains various decode options.
.IP "encoding" 4
.IX Item "encoding"
One of '\s-1BER\s0' or '\s-1DER\s0'. The default is '\s-1BER\s0'
.IP "tagdefault" 4
.IX Item "tagdefault"
One of '\s-1EXPLICIT\s0' or '\s-1IMPLICIT\s0'.
Default tagging conventions are normally given in the \s-1ASN\s0.1 module definition (not supported by the parser). The \s-1ASN\s0.1 spec states \s-1EXPLICIT\s0 tagging is the default, but this option has \s-1IMPLICIT\s0 tagging default for backward compatibility reasons.
.PP
Encode options
.IP "real" 4
.IX Item "real"
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'
.IP "time" 4
.IX Item "time"
This controls how UTCTime and GeneralizedTime elements are encoded. The default
is \f(CW\*(C`withzone\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value passed will be encoded without a zone, ie a \s-1UTC\s0 value.
.IP "withzone" 4
.IX Item "withzone"
The value will be encoded with a zone. By default it will be encoded
using the local time offset. The offset may be set using the \f(CW\*(C`timezone\*(C'\fR
configure option.
.IP "raw" 4
.IX Item "raw"
The value passed should already be in the correct format and will be copied
into the \s-1PDU\s0 as-is.
.RE
.RS 4
.RE
.IP "timezone" 4
.IX Item "timezone"
By default UTCTime and GeneralizedTime will be encoded using the local
time offset from \s-1UTC\s0. This will over-ride that. It is an offset from \s-1UTC\s0
in seconds.  This option can be overridden by passing a reference to a
list of two values as the time value. The list should contain the time
value and the offset from \s-1UTC\s0 in seconds.
.IP "bigint" 4
.IX Item "bigint"
If during encoding an value greater than 32 bits is discovered and
is not already a big integer object, then the value will first be
converted into a big integer object. This option controls the big
integer class into which the objects will be blessed. The default
is to use Math::BigInt
.PP
Decode options
.IP "time" 4
.IX Item "time"
This controls how a UTCTime or a GeneralizedTime element will be decoded. The default
is \f(CW\*(C`utctime\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value returned will be a time value as returned by the \f(CW\*(C`time\*(C'\fR function.
.IP "withzone" 4
.IX Item "withzone"
The value returned will be a reference to an array of two values. The first is the
same as with \f(CW\*(C`utctime\*(C'\fR, the second is the timezone offset, in seconds, that was
used in the encoding.
.IP "raw" 4
.IX Item "raw"
The value returned will be the raw encoding as extracted from the \s-1PDU\s0.
.RE
.RS 4
.RE
.IP "bigint" 4
.IX Item "bigint"
If during decoding any big integers are discovered (integers greater
than 32 bits), they will be decoded into big integer objects. This option
controls the big integer class into which the objects will be blessed.
The default is to use Math::BigInt.
.IP "null" 4
.IX Item "null"
The value to decode \s-1ASN\s0.1 \s-1NULL\s0 types into.
If not set, it defaults to \f(CW1\fR.
.SS "prepare ( \s-1ASN\s0 )"
.IX Subsection "prepare ( ASN )"
Compile the given \s-1ASN\s0.1 descripton which can be passed as a string
or as a filehandle. The syntax used is very close to \s-1ASN\s0.1, but has
a few differences. If the \s-1ASN\s0 decribes only one macro then encode/decode can be
called on this object. If \s-1ASN\s0 describes more than one \s-1ASN\s0.1 macro then \f(CW\*(C`find\*(C'\fR
must be called. The method returns undef on error.
.SS "prepare_file ( \s-1ASNPATH\s0 )"
.IX Subsection "prepare_file ( ASNPATH )"
Compile the \s-1ASN\s0.1 description to be read from the specified pathname.
.SS "find ( \s-1MACRO\s0 )"
.IX Subsection "find ( MACRO )"
Find a macro from a prepared \s-1ASN\s0.1 description. Returns an object which can
be used for encode/decode.
.SS "encode ( \s-1VARIABLES\s0 )"
.IX Subsection "encode ( VARIABLES )"
Encode a \s-1PDU\s0. Top-level variable are passed as name-value pairs, or as a reference
to a hash containing them. Returns the encoded \s-1PDU\s0, or undef on error.
.SS "decode ( \s-1PDU\s0 )"
.IX Subsection "decode ( PDU )"
Decode the \s-1PDU\s0, returns a reference to a hash containg the values for the \s-1PDU\s0. Returns
undef if there was an error.
.SS "registeroid ( \s-1OID\s0, \s-1HANDLER\s0 )"
.IX Subsection "registeroid ( OID, HANDLER )"
Register a handler for all \s-1ASN\s0.1 elements
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID\s0.
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO\s0 )\*(R".
.SS "registertype ( \s-1NAME\s0, \s-1OID\s0, \s-1HANDLER\s0 )"
.IX Subsection "registertype ( NAME, OID, HANDLER )"
Register a handler for all \s-1ASN\s0.1 elements named \f(CW\*(C`NAME\*(C'\fR,
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID\s0.
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO\s0 )\*(R".
.SH "EXPORTS"
.IX Header "EXPORTS"
As well as providing an object interface for encoding/decoding PDUs Convert::ASN1
also provides the following functions.
.SS "\s-1IO\s0 Functions"
.IX Subsection "IO Functions"
.IP "asn_recv ( \s-1SOCK\s0, \s-1BUFFER\s0, \s-1FLAGS\s0 )" 4
.IX Item "asn_recv ( SOCK, BUFFER, FLAGS )"
Will read a single element from the socket \s-1SOCK\s0 into \s-1BUFFER\s0.  \s-1FLAGS\s0 may
be \s-1MSG_PEEK\s0 as exported by \f(CW\*(C`Socket\*(C'\fR. Returns the address of the sender,
or undef if there was an error. Some systems do not support the return
of the peer address when the socket is a connected socket, in these
cases the empty string will be returned. This is the same behaviour
as the \f(CW\*(C`recv\*(C'\fR function in perl itself.
.Sp
It is recommended that if the socket is of type \s-1SOCK_DGRAM\s0 then \f(CW\*(C`recv\*(C'\fR
be called directly instead of calling \f(CW\*(C`asn_recv\*(C'\fR.
.IP "asn_read ( \s-1FH\s0, \s-1BUFFER\s0, \s-1OFFSET\s0 )" 4
.IX Item "asn_read ( FH, BUFFER, OFFSET )"
.PD 0
.IP "asn_read ( \s-1FH\s0, \s-1BUFFER\s0 )" 4
.IX Item "asn_read ( FH, BUFFER )"
.PD
Will read a single element from the filehandle \s-1FH\s0 into \s-1BUFFER\s0. Returns the
number of bytes read if a complete element was read, \-1 if an incomplete
element was read or undef if there was an error. If \s-1OFFSET\s0 is specified
then it is assumed that \s-1BUFFER\s0 already contains an incomplete element
and new data will be appended starting at \s-1OFFSET\s0.
.Sp
If \s-1FH\s0 is a socket the asn_recv is used to read the element, so the same
restiction applies if \s-1FH\s0 is a socket of type \s-1SOCK_DGRAM\s0.
.IP "asn_send ( \s-1SOCK\s0, \s-1BUFFER\s0, \s-1FLAGS\s0, \s-1TO\s0 )" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS, TO )"
.PD 0
.IP "asn_send ( \s-1SOCK\s0, \s-1BUFFER\s0, \s-1FLAGS\s0 )" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS )"
.PD
Identical to calling \f(CW\*(C`send\*(C'\fR, see perlfunc
.IP "asn_write ( \s-1FH\s0, \s-1BUFFER\s0 )" 4
.IX Item "asn_write ( FH, BUFFER )"
Identical to calling \f(CW\*(C`syswrite\*(C'\fR with 2 arguments, see perlfunc
.IP "asn_get ( \s-1FH\s0 )" 4
.IX Item "asn_get ( FH )"
\&\f(CW\*(C`asn_get\*(C'\fR provides buffered \s-1IO\s0. Because it needs a buffer \s-1FH\s0 must be a \s-1GLOB\s0
or a reference to a \s-1GLOB\s0. \f(CW\*(C`asn_get\*(C'\fR will use two entries in the hash element
of the \s-1GLOB\s0 to use as its buffer:
.Sp
.Vb 2
\&  asn_buffer \- input buffer
\&  asn_need   \- number of bytes needed for the next element, if known
.Ve
.Sp
Returns an element or undef if there was an error.
.IP "asn_ready ( \s-1FH\s0 )" 4
.IX Item "asn_ready ( FH )"
\&\f(CW\*(C`asn_ready\*(C'\fR works with \f(CW\*(C`asn_get\*(C'\fR. It will return true if \f(CW\*(C`asn_get\*(C'\fR has already
read enough data into the buffer to return a complete element.
.SS "Encode/Decode Functions"
.IX Subsection "Encode/Decode Functions"
.IP "asn_tag ( \s-1CLASS\s0, \s-1VALUE\s0 )" 4
.IX Item "asn_tag ( CLASS, VALUE )"
Given \fB\s-1CLASS\s0\fR and a \fB\s-1VALUE\s0\fR, calculate an integer which when encoded
will become the tag.
.IP "asn_decode_tag ( \s-1TAG\s0 )" 4
.IX Item "asn_decode_tag ( TAG )"
Decode the given \s-1ASN\s0.1 encoded \f(CW\*(C`TAG\*(C'\fR.
.IP "asn_encode_tag ( \s-1TAG\s0 )" 4
.IX Item "asn_encode_tag ( TAG )"
Encode \fB\s-1TAG\s0\fR value for encoding.
We assume that the tag has been correctly generated with \*(L"asn_tag ( \s-1CLASS\s0, \s-1VALUE\s0 )\*(R".
.IP "asn_decode_length ( \s-1LEN\s0 )" 4
.IX Item "asn_decode_length ( LEN )"
Decode the given \s-1ASN\s0.1 decoded \f(CW\*(C`LEN\*(C'\fR.
.IP "asn_encode_length ( \s-1LEN\s0 )" 4
.IX Item "asn_encode_length ( LEN )"
Encode the given \f(CW\*(C`LEN\*(C'\fR to its \s-1ASN\s0.1 encoding.
.SS "Constants"
.IX Subsection "Constants"
.IP "\s-1ASN_BIT_STR\s0" 4
.IX Item "ASN_BIT_STR"
.PD 0
.IP "\s-1ASN_BOOLEAN\s0" 4
.IX Item "ASN_BOOLEAN"
.IP "\s-1ASN_ENUMERATED\s0" 4
.IX Item "ASN_ENUMERATED"
.IP "\s-1ASN_GENERAL_TIME\s0" 4
.IX Item "ASN_GENERAL_TIME"
.IP "\s-1ASN_IA5_STR\s0" 4
.IX Item "ASN_IA5_STR"
.IP "\s-1ASN_INTEGER\s0" 4
.IX Item "ASN_INTEGER"
.IP "\s-1ASN_NULL\s0" 4
.IX Item "ASN_NULL"
.IP "\s-1ASN_OBJECT_ID\s0" 4
.IX Item "ASN_OBJECT_ID"
.IP "\s-1ASN_OCTET_STR\s0" 4
.IX Item "ASN_OCTET_STR"
.IP "\s-1ASN_PRINT_STR\s0" 4
.IX Item "ASN_PRINT_STR"
.IP "\s-1ASN_REAL\s0" 4
.IX Item "ASN_REAL"
.IP "\s-1ASN_SEQUENCE\s0" 4
.IX Item "ASN_SEQUENCE"
.IP "\s-1ASN_SET\s0" 4
.IX Item "ASN_SET"
.IP "\s-1ASN_UTC_TIME\s0" 4
.IX Item "ASN_UTC_TIME"
.IP "\s-1ASN_APPLICATION\s0" 4
.IX Item "ASN_APPLICATION"
.IP "\s-1ASN_CONTEXT\s0" 4
.IX Item "ASN_CONTEXT"
.IP "\s-1ASN_PRIVATE\s0" 4
.IX Item "ASN_PRIVATE"
.IP "\s-1ASN_UNIVERSAL\s0" 4
.IX Item "ASN_UNIVERSAL"
.IP "\s-1ASN_PRIMITIVE\s0" 4
.IX Item "ASN_PRIMITIVE"
.IP "\s-1ASN_CONSTRUCTOR\s0" 4
.IX Item "ASN_CONSTRUCTOR"
.IP "\s-1ASN_LONG_LEN\s0" 4
.IX Item "ASN_LONG_LEN"
.IP "\s-1ASN_EXTENSION_ID\s0" 4
.IX Item "ASN_EXTENSION_ID"
.IP "\s-1ASN_BIT\s0" 4
.IX Item "ASN_BIT"
.PD
.SS "Debug Functions"
.IX Subsection "Debug Functions"
.IP "asn_dump ( [\s-1FH\s0,] \s-1BUFFER\s0 )" 4
.IX Item "asn_dump ( [FH,] BUFFER )"
Try to decode the given buffer as \s-1ASN\s0.1 structure and dump it to the
given file handle, or \f(CW\*(C`STDERR\*(C'\fR if the handle is not given.
.IP "asn_hexdump ( \s-1FH\s0, \s-1BUFFER\s0 )" 4
.IX Item "asn_hexdump ( FH, BUFFER )"
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.PD 0
.IP ":all" 4
.IX Item ":all"
.PD
All exported functions
.IP ":const" 4
.IX Item ":const"
\&\s-1ASN_BOOLEAN\s0,     \s-1ASN_INTEGER\s0,      \s-1ASN_BIT_STR\s0,      \s-1ASN_OCTET_STR\s0,
\&\s-1ASN_NULL\s0,        \s-1ASN_OBJECT_ID\s0,    \s-1ASN_REAL\s0,         \s-1ASN_ENUMERATED\s0,
\&\s-1ASN_SEQUENCE\s0,    \s-1ASN_SET\s0,          \s-1ASN_PRINT_STR\s0,    \s-1ASN_IA5_STR\s0,
\&\s-1ASN_UTC_TIME\s0,    \s-1ASN_GENERAL_TIME\s0,
\&\s-1ASN_UNIVERSAL\s0,   \s-1ASN_APPLICATION\s0,  \s-1ASN_CONTEXT\s0,      \s-1ASN_PRIVATE\s0,
\&\s-1ASN_PRIMITIVE\s0,   \s-1ASN_CONSTRUCTOR\s0,  \s-1ASN_LONG_LEN\s0,     \s-1ASN_EXTENSION_ID\s0, \s-1ASN_BIT\s0
.IP ":debug" 4
.IX Item ":debug"
asn_dump, asn_hexdump
.IP ":io" 4
.IX Item ":io"
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready
.IP ":tag" 4
.IX Item ":tag"
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length, asn_encode_length
.SH "MAPPING ASN.1 TO PERL"
.IX Header "MAPPING ASN.1 TO PERL"
Every element in the \s-1ASN\s0.1 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => "text" }
.Ve
.PP
In the case of a \s-1SEQUENCE\s0, \s-1SET\s0 or \s-1CHOICE\s0 then the value in the namespace will
be a hash reference which will be the namespce for the elements with
that element.
.PP
.Vb 6
\&  # ASN.1
\&  int INTEGER,
\&  seq SEQUENCE {
\&    str OCTET STRING,
\&    bool BOOLEAN
\&  }
\&
\&  # Perl
\&  { int => 5, seq => { str => "text", bool => 1}}
.Ve
.PP
If the element is a \s-1SEQUENCE\s0 \s-1OF\s0, or \s-1SET\s0 \s-1OF\s0, then the value in the namespace
will be an array reference. The elements in the array will be of
the type expected by the type following the \s-1OF\s0. For example
with \*(L"\s-1SEQUENCE\s0 \s-1OF\s0 \s-1STRING\s0\*(R" the array would contain strings. With
\&\*(L"\s-1SEQUENCE\s0 \s-1OF\s0 \s-1SEQUENCE\s0 { ... }\*(R" the array will contain hash references
which will be used as namespaces
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => [ "text1", "text2"]}
\&
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF SEQUENCE {
\&    type OCTET STRING,
\&    value INTEGER
\&  }
\&
\&  # Perl
\&  { int => 5, str => [
\&    { type => "abc", value => 4 },
\&    { type => "def", value => \-1 },
\&  ]}
.Ve
.PP
Finally, if you wish to pre-parse \s-1ASN\s0.1 and hold it to include
inline in your \s-1PDU\s0, you can coerce it into the \s-1ASN\s0.1 spec by
defining the value as \s-1ANY\s0 in the schema, and then pass the pre
encoded value inline.
.PP
.Vb 4
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING,
\&  pre ANY
\&
\&  # Perl
\&  { int => 5, str => "text", pre=>"\ex03\ex03\ex00\ex0a\ex05" }
.Ve
.PP
passes a pre-encoded \s-1BIT\s0 \s-1STRING\s0 instance as hex text. \-But
it could be a previous run of \f(CW$obj\fR\->\fIencode()\fR from another run
held in some variable.
.SS "Exceptions"
.IX Subsection "Exceptions"
There are some exceptions where Convert::ASN1 does not require an element to be named.
These are \s-1SEQUENCE\s0 {...}, \s-1SET\s0 {...} and \s-1CHOICE\s0. In each case if the element is not
given a name then the elements inside the {...} will share the same namespace as
the elements outside of the {...}.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
\&\s-1XS\s0 implementation.
.IP "\(bu" 4
More documentation.
.IP "\(bu" 4
More tests.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@cpan.org>
.SH "SUPPORT"
.IX Header "SUPPORT"
Report issues via github at https://github.com/gbarr/perl\-Convert\-ASN1/issues
.PP
To contribute I encourage you to create a git fork of the repository at
https://github.com/gbarr/perl\-Convert\-ASN1 do you work on a fresh branch
created from master and submit a pull request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2012 Graham Barr <gbarr@cpan.org>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::ASN15.18.3pm                        0100644 0001750 0001750 00000046216 12566241532 024053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::ASN1 3"
.TH Convert::ASN1 3 "2012-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::ASN1 \- ASN.1 Encode/Decode library
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use Convert::ASN1;
\&
\&  $asn = Convert::ASN1\->new;
\&  $asn\->prepare(q<
\&
\&    [APPLICATION 7] SEQUENCE {
\&      int INTEGER,
\&      str OCTET STRING
\&    }
\&
\&  >);
\&
\&  $pdu = $asn\->encode( int => 7, str => "string");
\&
\&  $out = $asn\->decode($pdu);
\&  print $out\->{int}," ",$out\->{str},"\en";
\&
\&  use Convert::ASN1 qw(:io);
\&
\&  $peer   = asn_recv($sock,$buffer,0);
\&  $nbytes = asn_read($fh, $buffer);
\&  $nbytes = asn_send($sock, $buffer, $peer);
\&  $nbytes = asn_send($sock, $buffer);
\&  $nbytes = asn_write($fh, $buffer);
\&  $buffer = asn_get($fh);
\&  $yes    = asn_ready($fh)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Convert::ASN1 encodes and decodes \s-1ASN.1\s0 data structures using \s-1BER/DER\s0
rules.
.SH "METHODS"
.IX Header "METHODS"
.SS "new ( [\s-1OPTIONS\s0] )"
.IX Subsection "new ( [OPTIONS] )"
Contructor, creates a new object.
.PP
If given, \fB\s-1OPTIONS\s0\fR are the same ones as for \*(L"configure ( \s-1OPTIONS \s0)\*(R" below.
.SS "error ()"
.IX Subsection "error ()"
Returns the last error.
.SS "configure ( \s-1OPTIONS \s0)"
.IX Subsection "configure ( OPTIONS )"
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.
.IP "encode" 4
.IX Item "encode"
Reference to a hash which contains various encode options.
.IP "decode" 4
.IX Item "decode"
Reference to a hash which contains various decode options.
.IP "encoding" 4
.IX Item "encoding"
One of '\s-1BER\s0' or '\s-1DER\s0'. The default is '\s-1BER\s0'
.IP "tagdefault" 4
.IX Item "tagdefault"
One of '\s-1EXPLICIT\s0' or '\s-1IMPLICIT\s0'.
Default tagging conventions are normally given in the \s-1ASN.1\s0 module definition (not supported by the parser). The \s-1ASN.1\s0 spec states \s-1EXPLICIT\s0 tagging is the default, but this option has \s-1IMPLICIT\s0 tagging default for backward compatibility reasons.
.PP
Encode options
.IP "real" 4
.IX Item "real"
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'
.IP "time" 4
.IX Item "time"
This controls how UTCTime and GeneralizedTime elements are encoded. The default
is \f(CW\*(C`withzone\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value passed will be encoded without a zone, ie a \s-1UTC\s0 value.
.IP "withzone" 4
.IX Item "withzone"
The value will be encoded with a zone. By default it will be encoded
using the local time offset. The offset may be set using the \f(CW\*(C`timezone\*(C'\fR
configure option.
.IP "raw" 4
.IX Item "raw"
The value passed should already be in the correct format and will be copied
into the \s-1PDU\s0 as-is.
.RE
.RS 4
.RE
.IP "timezone" 4
.IX Item "timezone"
By default UTCTime and GeneralizedTime will be encoded using the local
time offset from \s-1UTC.\s0 This will over-ride that. It is an offset from \s-1UTC\s0
in seconds.  This option can be overridden by passing a reference to a
list of two values as the time value. The list should contain the time
value and the offset from \s-1UTC\s0 in seconds.
.IP "bigint" 4
.IX Item "bigint"
If during encoding an value greater than 32 bits is discovered and
is not already a big integer object, then the value will first be
converted into a big integer object. This option controls the big
integer class into which the objects will be blessed. The default
is to use Math::BigInt
.PP
Decode options
.IP "time" 4
.IX Item "time"
This controls how a UTCTime or a GeneralizedTime element will be decoded. The default
is \f(CW\*(C`utctime\*(C'\fR.
.RS 4
.IP "utctime" 4
.IX Item "utctime"
The value returned will be a time value as returned by the \f(CW\*(C`time\*(C'\fR function.
.IP "withzone" 4
.IX Item "withzone"
The value returned will be a reference to an array of two values. The first is the
same as with \f(CW\*(C`utctime\*(C'\fR, the second is the timezone offset, in seconds, that was
used in the encoding.
.IP "raw" 4
.IX Item "raw"
The value returned will be the raw encoding as extracted from the \s-1PDU.\s0
.RE
.RS 4
.RE
.IP "bigint" 4
.IX Item "bigint"
If during decoding any big integers are discovered (integers greater
than 32 bits), they will be decoded into big integer objects. This option
controls the big integer class into which the objects will be blessed.
The default is to use Math::BigInt.
.IP "null" 4
.IX Item "null"
The value to decode \s-1ASN.1 NULL\s0 types into.
If not set, it defaults to \f(CW1\fR.
.SS "prepare ( \s-1ASN \s0)"
.IX Subsection "prepare ( ASN )"
Compile the given \s-1ASN.1\s0 descripton which can be passed as a string
or as a filehandle. The syntax used is very close to \s-1ASN.1,\s0 but has
a few differences. If the \s-1ASN\s0 decribes only one macro then encode/decode can be
called on this object. If \s-1ASN\s0 describes more than one \s-1ASN.1\s0 macro then \f(CW\*(C`find\*(C'\fR
must be called. The method returns undef on error.
.SS "prepare_file ( \s-1ASNPATH \s0)"
.IX Subsection "prepare_file ( ASNPATH )"
Compile the \s-1ASN.1\s0 description to be read from the specified pathname.
.SS "find ( \s-1MACRO \s0)"
.IX Subsection "find ( MACRO )"
Find a macro from a prepared \s-1ASN.1\s0 description. Returns an object which can
be used for encode/decode.
.SS "encode ( \s-1VARIABLES \s0)"
.IX Subsection "encode ( VARIABLES )"
Encode a \s-1PDU.\s0 Top-level variable are passed as name-value pairs, or as a reference
to a hash containing them. Returns the encoded \s-1PDU,\s0 or undef on error.
.SS "decode ( \s-1PDU \s0)"
.IX Subsection "decode ( PDU )"
Decode the \s-1PDU,\s0 returns a reference to a hash containg the values for the \s-1PDU.\s0 Returns
undef if there was an error.
.SS "registeroid ( \s-1OID, HANDLER \s0)"
.IX Subsection "registeroid ( OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SS "registertype ( \s-1NAME, OID, HANDLER \s0)"
.IX Subsection "registertype ( NAME, OID, HANDLER )"
Register a handler for all \s-1ASN.1\s0 elements named \f(CW\*(C`NAME\*(C'\fR,
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given \s-1OID.\s0
.PP
\&\fB\s-1HANDLER\s0\fR must be a Convert::ASN1 object, e.g. as returned by \*(L"find ( \s-1MACRO \s0)\*(R".
.SH "EXPORTS"
.IX Header "EXPORTS"
As well as providing an object interface for encoding/decoding PDUs Convert::ASN1
also provides the following functions.
.SS "\s-1IO\s0 Functions"
.IX Subsection "IO Functions"
.IP "asn_recv ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_recv ( SOCK, BUFFER, FLAGS )"
Will read a single element from the socket \s-1SOCK\s0 into \s-1BUFFER.  FLAGS\s0 may
be \s-1MSG_PEEK\s0 as exported by \f(CW\*(C`Socket\*(C'\fR. Returns the address of the sender,
or undef if there was an error. Some systems do not support the return
of the peer address when the socket is a connected socket, in these
cases the empty string will be returned. This is the same behaviour
as the \f(CW\*(C`recv\*(C'\fR function in perl itself.
.Sp
It is recommended that if the socket is of type \s-1SOCK_DGRAM\s0 then \f(CW\*(C`recv\*(C'\fR
be called directly instead of calling \f(CW\*(C`asn_recv\*(C'\fR.
.IP "asn_read ( \s-1FH, BUFFER, OFFSET \s0)" 4
.IX Item "asn_read ( FH, BUFFER, OFFSET )"
.PD 0
.IP "asn_read ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_read ( FH, BUFFER )"
.PD
Will read a single element from the filehandle \s-1FH\s0 into \s-1BUFFER.\s0 Returns the
number of bytes read if a complete element was read, \-1 if an incomplete
element was read or undef if there was an error. If \s-1OFFSET\s0 is specified
then it is assumed that \s-1BUFFER\s0 already contains an incomplete element
and new data will be appended starting at \s-1OFFSET.\s0
.Sp
If \s-1FH\s0 is a socket the asn_recv is used to read the element, so the same
restiction applies if \s-1FH\s0 is a socket of type \s-1SOCK_DGRAM.\s0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS, TO \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS, TO )"
.PD 0
.IP "asn_send ( \s-1SOCK, BUFFER, FLAGS \s0)" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS )"
.PD
Identical to calling \f(CW\*(C`send\*(C'\fR, see perlfunc
.IP "asn_write ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_write ( FH, BUFFER )"
Identical to calling \f(CW\*(C`syswrite\*(C'\fR with 2 arguments, see perlfunc
.IP "asn_get ( \s-1FH \s0)" 4
.IX Item "asn_get ( FH )"
\&\f(CW\*(C`asn_get\*(C'\fR provides buffered \s-1IO.\s0 Because it needs a buffer \s-1FH\s0 must be a \s-1GLOB\s0
or a reference to a \s-1GLOB. \s0\f(CW\*(C`asn_get\*(C'\fR will use two entries in the hash element
of the \s-1GLOB\s0 to use as its buffer:
.Sp
.Vb 2
\&  asn_buffer \- input buffer
\&  asn_need   \- number of bytes needed for the next element, if known
.Ve
.Sp
Returns an element or undef if there was an error.
.IP "asn_ready ( \s-1FH \s0)" 4
.IX Item "asn_ready ( FH )"
\&\f(CW\*(C`asn_ready\*(C'\fR works with \f(CW\*(C`asn_get\*(C'\fR. It will return true if \f(CW\*(C`asn_get\*(C'\fR has already
read enough data into the buffer to return a complete element.
.SS "Encode/Decode Functions"
.IX Subsection "Encode/Decode Functions"
.IP "asn_tag ( \s-1CLASS, VALUE \s0)" 4
.IX Item "asn_tag ( CLASS, VALUE )"
Given \fB\s-1CLASS\s0\fR and a \fB\s-1VALUE\s0\fR, calculate an integer which when encoded
will become the tag.
.IP "asn_decode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_decode_tag ( TAG )"
Decode the given \s-1ASN.1\s0 encoded \f(CW\*(C`TAG\*(C'\fR.
.IP "asn_encode_tag ( \s-1TAG \s0)" 4
.IX Item "asn_encode_tag ( TAG )"
Encode \fB\s-1TAG\s0\fR value for encoding.
We assume that the tag has been correctly generated with \*(L"asn_tag ( \s-1CLASS, VALUE \s0)\*(R".
.IP "asn_decode_length ( \s-1LEN \s0)" 4
.IX Item "asn_decode_length ( LEN )"
Decode the given \s-1ASN.1\s0 decoded \f(CW\*(C`LEN\*(C'\fR.
.IP "asn_encode_length ( \s-1LEN \s0)" 4
.IX Item "asn_encode_length ( LEN )"
Encode the given \f(CW\*(C`LEN\*(C'\fR to its \s-1ASN.1\s0 encoding.
.SS "Constants"
.IX Subsection "Constants"
.IP "\s-1ASN_BIT_STR\s0" 4
.IX Item "ASN_BIT_STR"
.PD 0
.IP "\s-1ASN_BOOLEAN\s0" 4
.IX Item "ASN_BOOLEAN"
.IP "\s-1ASN_ENUMERATED\s0" 4
.IX Item "ASN_ENUMERATED"
.IP "\s-1ASN_GENERAL_TIME\s0" 4
.IX Item "ASN_GENERAL_TIME"
.IP "\s-1ASN_IA5_STR\s0" 4
.IX Item "ASN_IA5_STR"
.IP "\s-1ASN_INTEGER\s0" 4
.IX Item "ASN_INTEGER"
.IP "\s-1ASN_NULL\s0" 4
.IX Item "ASN_NULL"
.IP "\s-1ASN_OBJECT_ID\s0" 4
.IX Item "ASN_OBJECT_ID"
.IP "\s-1ASN_OCTET_STR\s0" 4
.IX Item "ASN_OCTET_STR"
.IP "\s-1ASN_PRINT_STR\s0" 4
.IX Item "ASN_PRINT_STR"
.IP "\s-1ASN_REAL\s0" 4
.IX Item "ASN_REAL"
.IP "\s-1ASN_SEQUENCE\s0" 4
.IX Item "ASN_SEQUENCE"
.IP "\s-1ASN_SET\s0" 4
.IX Item "ASN_SET"
.IP "\s-1ASN_UTC_TIME\s0" 4
.IX Item "ASN_UTC_TIME"
.IP "\s-1ASN_APPLICATION\s0" 4
.IX Item "ASN_APPLICATION"
.IP "\s-1ASN_CONTEXT\s0" 4
.IX Item "ASN_CONTEXT"
.IP "\s-1ASN_PRIVATE\s0" 4
.IX Item "ASN_PRIVATE"
.IP "\s-1ASN_UNIVERSAL\s0" 4
.IX Item "ASN_UNIVERSAL"
.IP "\s-1ASN_PRIMITIVE\s0" 4
.IX Item "ASN_PRIMITIVE"
.IP "\s-1ASN_CONSTRUCTOR\s0" 4
.IX Item "ASN_CONSTRUCTOR"
.IP "\s-1ASN_LONG_LEN\s0" 4
.IX Item "ASN_LONG_LEN"
.IP "\s-1ASN_EXTENSION_ID\s0" 4
.IX Item "ASN_EXTENSION_ID"
.IP "\s-1ASN_BIT\s0" 4
.IX Item "ASN_BIT"
.PD
.SS "Debug Functions"
.IX Subsection "Debug Functions"
.IP "asn_dump ( [\s-1FH,\s0] \s-1BUFFER \s0)" 4
.IX Item "asn_dump ( [FH,] BUFFER )"
Try to decode the given buffer as \s-1ASN.1\s0 structure and dump it to the
given file handle, or \f(CW\*(C`STDERR\*(C'\fR if the handle is not given.
.IP "asn_hexdump ( \s-1FH, BUFFER \s0)" 4
.IX Item "asn_hexdump ( FH, BUFFER )"
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.PD 0
.IP ":all" 4
.IX Item ":all"
.PD
All exported functions
.IP ":const" 4
.IX Item ":const"
\&\s-1ASN_BOOLEAN,     ASN_INTEGER,      ASN_BIT_STR,      ASN_OCTET_STR,
ASN_NULL,        ASN_OBJECT_ID,    ASN_REAL,         ASN_ENUMERATED,
ASN_SEQUENCE,    ASN_SET,          ASN_PRINT_STR,    ASN_IA5_STR,
ASN_UTC_TIME,    ASN_GENERAL_TIME,
ASN_UNIVERSAL,   ASN_APPLICATION,  ASN_CONTEXT,      ASN_PRIVATE,
ASN_PRIMITIVE,   ASN_CONSTRUCTOR,  ASN_LONG_LEN,     ASN_EXTENSION_ID, ASN_BIT\s0
.IP ":debug" 4
.IX Item ":debug"
asn_dump, asn_hexdump
.IP ":io" 4
.IX Item ":io"
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready
.IP ":tag" 4
.IX Item ":tag"
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length, asn_encode_length
.SH "MAPPING ASN.1 TO PERL"
.IX Header "MAPPING ASN.1 TO PERL"
Every element in the \s-1ASN.1\s0 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => "text" }
.Ve
.PP
In the case of a \s-1SEQUENCE, SET\s0 or \s-1CHOICE\s0 then the value in the namespace will
be a hash reference which will be the namespce for the elements with
that element.
.PP
.Vb 6
\&  # ASN.1
\&  int INTEGER,
\&  seq SEQUENCE {
\&    str OCTET STRING,
\&    bool BOOLEAN
\&  }
\&
\&  # Perl
\&  { int => 5, seq => { str => "text", bool => 1}}
.Ve
.PP
If the element is a \s-1SEQUENCE OF,\s0 or \s-1SET OF,\s0 then the value in the namespace
will be an array reference. The elements in the array will be of
the type expected by the type following the \s-1OF.\s0 For example
with \*(L"\s-1SEQUENCE OF STRING\*(R"\s0 the array would contain strings. With
\&\*(L"\s-1SEQUENCE OF SEQUENCE\s0 { ... }\*(R" the array will contain hash references
which will be used as namespaces
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => [ "text1", "text2"]}
\&
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF SEQUENCE {
\&    type OCTET STRING,
\&    value INTEGER
\&  }
\&
\&  # Perl
\&  { int => 5, str => [
\&    { type => "abc", value => 4 },
\&    { type => "def", value => \-1 },
\&  ]}
.Ve
.PP
Finally, if you wish to pre-parse \s-1ASN.1\s0 and hold it to include
inline in your \s-1PDU,\s0 you can coerce it into the \s-1ASN.1\s0 spec by
defining the value as \s-1ANY\s0 in the schema, and then pass the pre
encoded value inline.
.PP
.Vb 4
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING,
\&  pre ANY
\&
\&  # Perl
\&  { int => 5, str => "text", pre=>"\ex03\ex03\ex00\ex0a\ex05" }
.Ve
.PP
passes a pre-encoded \s-1BIT STRING\s0 instance as hex text. \-But
it could be a previous run of \f(CW$obj\fR\->\fIencode()\fR from another run
held in some variable.
.SS "Exceptions"
.IX Subsection "Exceptions"
There are some exceptions where Convert::ASN1 does not require an element to be named.
These are \s-1SEQUENCE\s0 {...}, \s-1SET\s0 {...} and \s-1CHOICE.\s0 In each case if the element is not
given a name then the elements inside the {...} will share the same namespace as
the elements outside of the {...}.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
\&\s-1XS\s0 implementation.
.IP "\(bu" 4
More documentation.
.IP "\(bu" 4
More tests.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@cpan.org>
.SH "SUPPORT"
.IX Header "SUPPORT"
Report issues via github at https://github.com/gbarr/perl\-Convert\-ASN1/issues
.PP
To contribute I encourage you to create a git fork of the repository at
https://github.com/gbarr/perl\-Convert\-ASN1 do you work on a fresh branch
created from master and submit a pull request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2012 Graham Barr <gbarr@cpan.org>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::BinHex.3pm                          0100644 0001750 0001750 00000062555 12566241407 024217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::BinHex 3"
.TH Convert::BinHex 3 "2013-09-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::BinHex \- extract data from Macintosh BinHex files
.PP
ALPHA WARNING: this code is currently in its Alpha release.
Things may change drastically until the interface is hammered out:
if you have suggestions or objections, please speak up now!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBSimple functions:\fR
.PP
.Vb 1
\&    use Convert::BinHex qw(binhex_crc macbinary_crc);
\&
\&    # Compute HQX7\-style CRC for data, pumping in old CRC if desired:
\&    $crc = binhex_crc($data, $crc);
\&
\&    # Compute the MacBinary\-II\-style CRC for the data:
\&    $crc = macbinary_crc($data, $crc);
.Ve
.PP
\&\fBHex to bin, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Hex2Bin\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $H2B\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $H2B\->done;              # no more input: finish up
.Ve
.PP
\&\fBHex to bin, \s-1OO\s0 interface.\fR
The following operations \fImust\fR be done in the order shown!
.PP
.Vb 5
\&    # Read data in piecemeal:
\&    $HQX = Convert::BinHex\->open(FH=>\e*STDIN) || die "open: $!";
\&    $HQX\->read_header;                  # read header info
\&    @data = $HQX\->read_data;            # read in all the data
\&    @rsrc = $HQX\->read_resource;        # read in all the resource
.Ve
.PP
\&\fBBin to hex, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Bin2Hex\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $B2H\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $B2H\->done;              # no more input: finish up
.Ve
.PP
\&\fBBin to hex, file interface.\fR  Yes, you can convert \fIto\fR BinHex
as well as from it!
.PP
.Vb 2
\&    # Create new, empty object:
\&    my $HQX = Convert::BinHex\->new;
\&
\&    # Set header attributes:
\&    $HQX\->filename("logo.gif");
\&    $HQX\->type("GIFA");
\&    $HQX\->creator("CNVS");
\&
\&    # Give it the data and resource forks (either can be absent):
\&    $HQX\->data(Path => "/path/to/data");       # here, data is on disk
\&    $HQX\->resource(Data => $resourcefork);     # here, resource is in core
\&
\&    # Output as a BinHex stream, complete with leading comment:
\&    $HQX\->encode(\e*STDOUT);
.Ve
.PP
\&\fB\s-1PLANNED\s0!!!! Bin to hex, \*(L"\s-1CAP\*(R"\s0 interface.\fR
\&\fIThanks to Ken Lunde for suggesting this\fR.
.PP
.Vb 3
\&    # Create new, empty object from CAP tree:
\&    my $HQX = Convert::BinHex\->from_cap("/path/to/root/file");
\&    $HQX\->encode(\e*STDOUT);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBinHex\fR is a format used by Macintosh for transporting Mac files
safely through electronic mail, as short-lined, 7\-bit, semi-compressed
data streams.  Ths module provides a means of converting those
data streams back into into binary data.
.SH "FORMAT"
.IX Header "FORMAT"
\&\fI(Some text taken from \s-1RFC\-1741.\s0)\fR
Files on the Macintosh consist of two parts, called \fIforks\fR:
.IP "Data fork" 4
.IX Item "Data fork"
The actual data included in the file.  The Data fork is typically the
only meaningful part of a Macintosh file on a non-Macintosh computer system.
For example, if a Macintosh user wants to send a file of data to a
user on an IBM-PC, she would only send the Data fork.
.IP "Resource fork" 4
.IX Item "Resource fork"
Contains a collection of arbitrary attribute/value pairs, including
program segments, icon bitmaps, and parametric values.
.PP
Additional information regarding Macintosh files is stored by the
Finder in a hidden file, called the \*(L"Desktop Database\*(R".
.PP
Because of the complications in storing different parts of a
Macintosh file in a non-Macintosh filesystem that only handles
consecutive data in one part, it is common to convert the Macintosh
file into some other format before transferring it over the network.
The BinHex format squashes that data into transmittable \s-1ASCII\s0 as follows:
.IP "1." 4
The file is output as a \fBbyte stream\fR consisting of some basic header
information (filename, type, creator), then the data fork, then the
resource fork.
.IP "2." 4
The byte stream is \fBcompressed\fR by looking for series of duplicated
bytes and representing them using a special binary escape sequence
(of course, any occurences of the escape character must also be escaped).
.IP "3." 4
The compressed stream is \fBencoded\fR via the \*(L"6/8 hemiola\*(R" common
to \fIbase64\fR and \fIuuencode\fR: each group of three 8\-bit bytes (24 bits)
is chopped into four 6\-bit numbers, which are used as indexes into
an \s-1ASCII \s0\*(L"alphabet\*(R".
(I assume that leftover bytes are zero-padded; documentation is thin).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1CRC\s0 computation"
.IX Subsection "CRC computation"
.IP "macbinary_crc \s-1DATA, SEED\s0" 4
.IX Item "macbinary_crc DATA, SEED"
Compute the MacBinary-II-style \s-1CRC\s0 for the given \s-1DATA,\s0 with the \s-1CRC\s0
seeded to \s-1SEED. \s0 Normally, you start with a \s-1SEED\s0 of 0, and you pump in
the previous \s-1CRC\s0 as the \s-1SEED\s0 if you're handling a lot of data one chunk
at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = macbinary_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.  \fBUntested.\fR
.IP "binhex_crc \s-1DATA, SEED\s0" 4
.IX Item "binhex_crc DATA, SEED"
Compute the HQX-style \s-1CRC\s0 for the given \s-1DATA,\s0 with the \s-1CRC\s0 seeded to \s-1SEED.\s0
Normally, you start with a \s-1SEED\s0 of 0, and you pump in the previous \s-1CRC\s0 as
the \s-1SEED\s0 if you're handling a lot of data one chunk at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = binhex_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
.SS "Conversion"
.IX Subsection "Conversion"
.IP "bin2hex" 4
.IX Item "bin2hex"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Bin2Hex\*(R"; see that class for details.
.IP "hex2bin" 4
.IX Item "hex2bin"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Hex2Bin\*(R"; see that class for details.
.SS "Construction"
.IX Subsection "Construction"
.IP "new \s-1PARAMHASH\s0" 4
.IX Item "new PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a BinHex'able entity.  In general, the data and resource
forks for such an entity are stored in native format (binary) format.
.Sp
Parameters in the \s-1PARAMHASH\s0 are the same as header-oriented method names,
and may be used to set attributes:
.Sp
.Vb 3
\&    $HQX = new Convert::BinHex filename => "icon.gif",
\&                               type    => "GIFB",
\&                               creator => "CNVS";
.Ve
.IP "open \s-1PARAMHASH\s0" 4
.IX Item "open PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a new BinHex'ed stream, for parsing.
Params are:
.RS 4
.IP "Data" 4
.IX Item "Data"
Input a \s-1HEX\s0 stream from the given data.  This can be a scalar, or a
reference to an array of scalars.
.IP "Expr" 4
.IX Item "Expr"
Input a \s-1HEX\s0 stream from any \fIopen()\fRable expression.  It will be opened and
binmode'd, and the filehandle will be closed either on a \f(CW\*(C`close()\*(C'\fR
or when the object is destructed.
.IP "\s-1FH\s0" 4
.IX Item "FH"
Input a \s-1HEX\s0 stream from the given filehandle.
.IP "NoComment" 4
.IX Item "NoComment"
If true, the parser should not attempt to skip a leading \*(L"(This file...)\*(R"
comment.  That means that the first nonwhite characters encountered
must be the binhex'ed data.
.RE
.RS 4
.RE
.SS "Get/set header information"
.IX Subsection "Get/set header information"
.IP "creator [\s-1VALUE\s0]" 4
.IX Item "creator [VALUE]"
\&\fIInstance method.\fR
Get/set the creator of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a document created by \*(L"Canvas\*(R" might have
creator \f(CW"CNVS"\fR.
.IP "data [\s-1PARAMHASH\s0]" 4
.IX Item "data [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the data fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "filename [\s-1VALUE\s0]" 4
.IX Item "filename [VALUE]"
\&\fIInstance method.\fR
Get/set the name of the file.
.IP "flags [\s-1VALUE\s0]" 4
.IX Item "flags [VALUE]"
\&\fIInstance method.\fR
Return the flags, as an integer.  Use bitmasking to get as the values
you need.
.IP "header_as_string" 4
.IX Item "header_as_string"
Return a stringified version of the header that you might
use for logging/debugging purposes.  It looks like this:
.Sp
.Vb 7
\&    X\-HQX\-Software: BinHex 4.0 (Convert::BinHex 1.102)
\&    X\-HQX\-Filename: Something_new.eps
\&    X\-HQX\-Version: 0
\&    X\-HQX\-Type: EPSF
\&    X\-HQX\-Creator: ART5
\&    X\-HQX\-Data\-Length: 49731
\&    X\-HQX\-Rsrc\-Length: 23096
.Ve
.Sp
As some of you might have guessed, this is RFC\-822\-style, and
may be easily plunked down into the middle of a mail header, or
split into lines, etc.
.IP "requires [\s-1VALUE\s0]" 4
.IX Item "requires [VALUE]"
\&\fIInstance method.\fR
Get/set the software version required to convert this file, as
extracted from the comment that preceded the actual binhex'ed
data; e.g.:
.Sp
.Vb 1
\&    (This file must be converted with BinHex 4.0)
.Ve
.Sp
In this case, after parsing in the comment, the code:
.Sp
.Vb 1
\&    $HQX\->requires;
.Ve
.Sp
would get back \*(L"4.0\*(R".
.IP "resource [\s-1PARAMHASH\s0]" 4
.IX Item "resource [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the resource fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "type [\s-1VALUE\s0]" 4
.IX Item "type [VALUE]"
\&\fIInstance method.\fR
Get/set the type of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a GIF89a file might have type \f(CW"GF89"\fR.
.IP "version [\s-1VALUE\s0]" 4
.IX Item "version [VALUE]"
\&\fIInstance method.\fR
Get/set the version, as an integer.
.SS "Decode, high-level"
.IX Subsection "Decode, high-level"
.IP "read_comment" 4
.IX Item "read_comment"
\&\fIInstance method.\fR
Skip past the opening comment in the file, which is of the form:
.Sp
.Vb 1
\&   (This file must be converted with BinHex 4.0)
.Ve
.Sp
As per \s-1RFC\-1741, \s0\fIthis comment must immediately precede the BinHex data,\fR
and any text before it will be ignored.
.Sp
\&\fIYou don't need to invoke this method yourself;\fR \f(CW\*(C`read_header()\*(C'\fR will
do it for you.  After the call, the version number in the comment is
accessible via the \f(CW\*(C`requires()\*(C'\fR method.
.IP "read_header" 4
.IX Item "read_header"
\&\fIInstance method.\fR
Read in the BinHex file header.  You must do this first!
.IP "read_data [\s-1NBYTES\s0]" 4
.IX Item "read_data [NBYTES]"
\&\fIInstance method.\fR
Read information from the data fork.  Use it in an array context to
slurp all the data into an array of scalars:
.Sp
.Vb 1
\&    @data = $HQX\->read_data;
.Ve
.Sp
Or use it in a scalar context to get the data piecemeal:
.Sp
.Vb 3
\&    while (defined($data = $HQX\->read_data)) {
\&       # do stuff with $data
\&    }
.Ve
.Sp
The \s-1NBYTES\s0 to read defaults to 2048.
.IP "read_resource [\s-1NBYTES\s0]" 4
.IX Item "read_resource [NBYTES]"
\&\fIInstance method.\fR
Read in all/some of the resource fork.
See \f(CW\*(C`read_data()\*(C'\fR for usage.
.SS "Encode, high-level"
.IX Subsection "Encode, high-level"
.IP "encode \s-1OUT\s0" 4
.IX Item "encode OUT"
Encode the object as a BinHex stream to the given output handle \s-1OUT.
OUT\s0 can be a filehandle, or any blessed object that responds to a
\&\f(CW\*(C`print()\*(C'\fR message.
.Sp
The leading comment is output, using the \f(CW\*(C`requires()\*(C'\fR attribute.
.SH "SUBMODULES"
.IX Header "SUBMODULES"
.SS "Convert::BinHex::Bin2Hex"
.IX Subsection "Convert::BinHex::Bin2Hex"
A BINary-to-HEX converter.  This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $B2H\->next($_);          # convert some more input
\&    }
\&    print STDOUT $B2H\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $B2H\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
This may have been a good approach.  It may not.  Someday, the converter
may also allow you give it an object that responds to \fIread()\fR, or
a FileHandle, and it will do all the nasty buffer-filling on its own,
serving you stuff line by line:
.PP
.Vb 5
\&    # Someday, maybe...
\&    my $B2H = Convert::BinHex\->bin2hex(\e*STDIN);
\&    while (defined($_ = $B2H\->getline)) {
\&        print STDOUT $_;
\&    }
.Ve
.PP
Someday, maybe.  Feel free to voice your opinions.
.SS "Convert::BinHex::Hex2Bin"
.IX Subsection "Convert::BinHex::Hex2Bin"
A HEX-to-BINary converter. This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $H2B\->next($_);          # convert some more input
\&    }
\&    print STDOUT $H2B\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $H2B\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
Note that this converter does \fInot\fR find the initial
\&\*(L"BinHex version\*(R" comment.  You have to skip that yourself.  It
only handles data between the opening and closing \f(CW":"\fR.
.SS "Convert::BinHex::Fork"
.IX Subsection "Convert::BinHex::Fork"
A fork in a Macintosh file.
.PP
.Vb 3
\&    # How to get them...
\&    $data_fork = $HQX\->data;      # get the data fork
\&    $rsrc_fork = $HQX\->resource;  # get the resource fork
\&
\&    # Make a new fork:
\&    $FORK = Convert::BinHex::Fork\->new(Path => "/tmp/file.data");
\&    $FORK = Convert::BinHex::Fork\->new(Data => $scalar);
\&    $FORK = Convert::BinHex::Fork\->new(Data => \e@array_of_scalars);
\&
\&    # Get/set the length of the data fork:
\&    $len = $FORK\->length;
\&    $FORK\->length(170);        # this overrides the REAL value: be careful!
\&
\&    # Get/set the path to the underlying data (if in a disk file):
\&    $path = $FORK\->path;
\&    $FORK\->path("/tmp/file.data");
\&
\&    # Get/set the in\-core data itself, which may be a scalar or an arrayref:
\&    $data = $FORK\->data;
\&    $FORK\->data($scalar);
\&    $FORK\->data(\e@array_of_scalars);
\&
\&    # Get/set the CRC:
\&    $crc = $FORK\->crc;
\&    $FORK\->crc($crc);
.Ve
.SH "UNDER THE HOOD"
.IX Header "UNDER THE HOOD"
.SS "Design issues"
.IX Subsection "Design issues"
.IP "BinHex needs a stateful parser" 4
.IX Item "BinHex needs a stateful parser"
Unlike its cousins \fIbase64\fR and \fIuuencode\fR, BinHex format is not
amenable to being parsed line-by-line.  There appears to be no
guarantee that lines contain 4n encoded characters... and even if there
is one, the BinHex compression algorithm interferes: even when you
can \fIdecode\fR one line at a time, you can't necessarily
\&\fIdecompress\fR a line at a time.
.Sp
For example: a decoded line ending with the byte \f(CW\*(C`\ex90\*(C'\fR (the escape
or \*(L"mark\*(R" character) is ambiguous: depending on the next decoded byte,
it could mean a literal \f(CW\*(C`\ex90\*(C'\fR (if the next byte is a \f(CW\*(C`\ex00\*(C'\fR), or
it could mean n\-1 more repetitions of the previous character (if
the next byte is some nonzero \f(CW\*(C`n\*(C'\fR).
.Sp
For this reason, a BinHex parser has to be somewhat stateful: you
cannot have code like this:
.Sp
.Vb 4
\&    #### NO! #### NO! #### NO! #### NO! #### NO! ####
\&    while (<STDIN>) {            # read HEX
\&        print hexbin($_);          # convert and write BIN
\&    }
.Ve
.Sp
unless something is happening \*(L"behind the scenes\*(R" to keep track of
what was last done.  \fIThe dangerous thing, however, is that this
approach will \f(BIseem\fI to work, if you only test it on BinHex files
which do not use compression and which have 4n \s-1HEX\s0 characters
on each line.\fR
.Sp
Since we have to be stateful anyway, we use the parser object to
keep our state.
.IP "We need to be handle large input files" 4
.IX Item "We need to be handle large input files"
Solutions that demand reading everything into core don't cut
it in my book.  The first \s-1MPEG\s0 file that comes along can louse
up your whole day.  So, there are no size limitations in this
module: the data is read on-demand, and filehandles are always
an option.
.IP "Boy, is this slow!" 4
.IX Item "Boy, is this slow!"
A lot of the byte-level manipulation that has to go on, particularly
the \s-1CRC\s0 computing (which involves intensive bit-shifting and masking)
slows this module down significantly.  What is needed perhaps is an
\&\fIoptional\fR extension library where the slow pieces can be done more
quickly... a Convert::BinHex::CRC, if you will.  Volunteers, anyone?
.Sp
Even considering that, however, it's slower than I'd like.  I'm
sure many improvements can be made in the HEX-to-BIN end of things.
No doubt I'll attempt some as time goes on...
.SS "How it works"
.IX Subsection "How it works"
Since BinHex is a layered format, consisting of...
.PP
.Vb 4
\&      A Macintosh file [the "BIN"]...
\&         Encoded as a structured 8\-bit bytestream, then...
\&            Compressed to reduce duplicate bytes, then...
\&               Encoded as 7\-bit ASCII [the "HEX"]
.Ve
.PP
\&...there is a layered parsing algorithm to reverse the process.
Basically, it works in a similar fashion to stdio's \fIfread()\fR:
.PP
.Vb 11
\&       0. There is an internal buffer of decompressed (BIN) data,
\&          initially empty.
\&       1. Application asks to read() n bytes of data from object
\&       2. If the buffer is not full enough to accomodate the request:
\&            2a. The read() method grabs the next available chunk of input
\&                data (the HEX).
\&            2b. HEX data is converted and decompressed into as many BIN
\&                bytes as possible.
\&            2c. BIN bytes are added to the read() buffer.
\&            2d. Go back to step 2a. until the buffer is full enough
\&                or we hit end\-of\-input.
.Ve
.PP
The conversion-and-decompression algorithms need their own internal
buffers and state (since the next input chunk may not contain all the
data needed for a complete conversion/decompression operation).
These are maintained in the object, so parsing two different
input streams simultaneously is possible.
.SH "WARNINGS"
.IX Header "WARNINGS"
Only handles \f(CW\*(C`Hqx7\*(C'\fR files, as per \s-1RFC\-1741.\s0
.PP
Remember that Macintosh text files use \f(CW"\er"\fR as end-of-line:
this means that if you want a textual file to look normal on
a non-Mac system, you probably want to do this to the data:
.PP
.Vb 2
\&    # Get the data, and output it according to normal conventions:
\&    foreach ($HQX\->read_data) { s/\er/\en/g; print }
.Ve
.SH "AUTHOR AND CREDITS"
.IX Header "AUTHOR AND CREDITS"
Maintained by Stephen Nelson <stephenenelson@mac.com>
.PP
Written by Eryq, \fIhttp://www.enteract.com/~eryq\fR / \fIeryq@enteract.com\fR
.PP
Support for native-Mac conversion, \fIplus\fR invaluable contributions in 
Alpha Testing, \fIplus\fR a few patches, \fIplus\fR the baseline binhex/debinhex
programs, were provided by Paul J. Schinder (\s-1NASA/GSFC\s0).
.PP
Ken Lunde (Adobe) suggested incorporating the \s-1CAP\s0 file representation.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1997 by Eryq.  All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
.PP
This software comes with \fB\s-1NO WARRANTY\s0\fR of any kind.
See the \s-1COPYING\s0 file in the distribution for details.
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::BinHex5.16.3pm                      0100644 0001750 0001750 00000063772 12566241407 024533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::BinHex 3"
.TH Convert::BinHex 3 "1997-06-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::BinHex \- extract data from Macintosh BinHex files
.PP
ALPHA WARNING: this code is currently in its Alpha release.
Things may change drastically until the interface is hammered out:
if you have suggestions or objections, please speak up now!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBSimple functions:\fR
.PP
.Vb 1
\&    use Convert::BinHex qw(binhex_crc macbinary_crc);
\&
\&    # Compute HQX7\-style CRC for data, pumping in old CRC if desired:
\&    $crc = binhex_crc($data, $crc);
\&
\&    # Compute the MacBinary\-II\-style CRC for the data:
\&    $crc = macbinary_crc($data, $crc);
.Ve
.PP
\&\fBHex to bin, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Hex2Bin\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $H2B\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $H2B\->done;              # no more input: finish up
.Ve
.PP
\&\fBHex to bin, \s-1OO\s0 interface.\fR
The following operations \fImust\fR be done in the order shown!
.PP
.Vb 5
\&    # Read data in piecemeal:
\&    $HQX = Convert::BinHex\->open(FH=>\e*STDIN) || die "open: $!";
\&    $HQX\->read_header;                  # read header info
\&    @data = $HQX\->read_data;            # read in all the data
\&    @rsrc = $HQX\->read_resource;        # read in all the resource
.Ve
.PP
\&\fBBin to hex, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Bin2Hex\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $B2H\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $B2H\->done;              # no more input: finish up
.Ve
.PP
\&\fBBin to hex, file interface.\fR  Yes, you can convert \fIto\fR BinHex
as well as from it!
.PP
.Vb 2
\&    # Create new, empty object:
\&    my $HQX = Convert::BinHex\->new;
\&
\&    # Set header attributes:
\&    $HQX\->filename("logo.gif");
\&    $HQX\->type("GIFA");
\&    $HQX\->creator("CNVS");
\&
\&    # Give it the data and resource forks (either can be absent):
\&    $HQX\->data(Path => "/path/to/data");       # here, data is on disk
\&    $HQX\->resource(Data => $resourcefork);     # here, resource is in core
\&
\&    # Output as a BinHex stream, complete with leading comment:
\&    $HQX\->encode(\e*STDOUT);
.Ve
.PP
\&\fB\s-1PLANNED\s0!!!! Bin to hex, \*(L"\s-1CAP\s0\*(R" interface.\fR
\&\fIThanks to Ken Lunde for suggesting this\fR.
.PP
.Vb 3
\&    # Create new, empty object from CAP tree:
\&    my $HQX = Convert::BinHex\->from_cap("/path/to/root/file");
\&    $HQX\->encode(\e*STDOUT);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBinHex\fR is a format used by Macintosh for transporting Mac files
safely through electronic mail, as short-lined, 7\-bit, semi-compressed
data streams.  Ths module provides a means of converting those
data streams back into into binary data.
.SH "FORMAT"
.IX Header "FORMAT"
\&\fI(Some text taken from \s-1RFC\-1741\s0.)\fR
Files on the Macintosh consist of two parts, called \fIforks\fR:
.IP "Data fork" 4
.IX Item "Data fork"
The actual data included in the file.  The Data fork is typically the
only meaningful part of a Macintosh file on a non-Macintosh computer system.
For example, if a Macintosh user wants to send a file of data to a
user on an IBM-PC, she would only send the Data fork.
.IP "Resource fork" 4
.IX Item "Resource fork"
Contains a collection of arbitrary attribute/value pairs, including
program segments, icon bitmaps, and parametric values.
.PP
Additional information regarding Macintosh files is stored by the
Finder in a hidden file, called the \*(L"Desktop Database\*(R".
.PP
Because of the complications in storing different parts of a
Macintosh file in a non-Macintosh filesystem that only handles
consecutive data in one part, it is common to convert the Macintosh
file into some other format before transferring it over the network.
The BinHex format squashes that data into transmittable \s-1ASCII\s0 as follows:
.IP "1." 4
The file is output as a \fBbyte stream\fR consisting of some basic header
information (filename, type, creator), then the data fork, then the
resource fork.
.IP "2." 4
The byte stream is \fBcompressed\fR by looking for series of duplicated
bytes and representing them using a special binary escape sequence
(of course, any occurences of the escape character must also be escaped).
.IP "3." 4
The compressed stream is \fBencoded\fR via the \*(L"6/8 hemiola\*(R" common
to \fIbase64\fR and \fIuuencode\fR: each group of three 8\-bit bytes (24 bits)
is chopped into four 6\-bit numbers, which are used as indexes into
an \s-1ASCII\s0 \*(L"alphabet\*(R".
(I assume that leftover bytes are zero-padded; documentation is thin).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1CRC\s0 computation"
.IX Subsection "CRC computation"
.IP "macbinary_crc \s-1DATA\s0, \s-1SEED\s0" 4
.IX Item "macbinary_crc DATA, SEED"
Compute the MacBinary-II-style \s-1CRC\s0 for the given \s-1DATA\s0, with the \s-1CRC\s0
seeded to \s-1SEED\s0.  Normally, you start with a \s-1SEED\s0 of 0, and you pump in
the previous \s-1CRC\s0 as the \s-1SEED\s0 if you're handling a lot of data one chunk
at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = macbinary_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.  \fBUntested.\fR
.IP "binhex_crc \s-1DATA\s0, \s-1SEED\s0" 4
.IX Item "binhex_crc DATA, SEED"
Compute the HQX-style \s-1CRC\s0 for the given \s-1DATA\s0, with the \s-1CRC\s0 seeded to \s-1SEED\s0.
Normally, you start with a \s-1SEED\s0 of 0, and you pump in the previous \s-1CRC\s0 as
the \s-1SEED\s0 if you're handling a lot of data one chunk at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = binhex_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
.SS "Conversion"
.IX Subsection "Conversion"
.IP "bin2hex" 4
.IX Item "bin2hex"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Bin2Hex\*(R"; see that class for details.
.IP "hex2bin" 4
.IX Item "hex2bin"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Hex2Bin\*(R"; see that class for details.
.SS "Construction"
.IX Subsection "Construction"
.IP "new \s-1PARAMHASH\s0" 4
.IX Item "new PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a BinHex'able entity.  In general, the data and resource
forks for such an entity are stored in native format (binary) format.
.Sp
Parameters in the \s-1PARAMHASH\s0 are the same as header-oriented method names,
and may be used to set attributes:
.Sp
.Vb 3
\&    $HQX = new Convert::BinHex filename => "icon.gif",
\&                               type    => "GIFB",
\&                               creator => "CNVS";
.Ve
.IP "open \s-1PARAMHASH\s0" 4
.IX Item "open PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a new BinHex'ed stream, for parsing.
Params are:
.RS 4
.IP "Data" 4
.IX Item "Data"
Input a \s-1HEX\s0 stream from the given data.  This can be a scalar, or a
reference to an array of scalars.
.IP "Expr" 4
.IX Item "Expr"
Input a \s-1HEX\s0 stream from any \fIopen()\fRable expression.  It will be opened and
binmode'd, and the filehandle will be closed either on a \f(CW\*(C`close()\*(C'\fR
or when the object is destructed.
.IP "\s-1FH\s0" 4
.IX Item "FH"
Input a \s-1HEX\s0 stream from the given filehandle.
.IP "NoComment" 4
.IX Item "NoComment"
If true, the parser should not attempt to skip a leading \*(L"(This file...)\*(R"
comment.  That means that the first nonwhite characters encountered
must be the binhex'ed data.
.RE
.RS 4
.RE
.SS "Get/set header information"
.IX Subsection "Get/set header information"
.IP "creator [\s-1VALUE\s0]" 4
.IX Item "creator [VALUE]"
\&\fIInstance method.\fR
Get/set the creator of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME\s0 \*(L"content-type\*(R".
.Sp
For example, a document created by \*(L"Canvas\*(R" might have
creator \f(CW"CNVS"\fR.
.IP "data [\s-1PARAMHASH\s0]" 4
.IX Item "data [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the data fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "filename [\s-1VALUE\s0]" 4
.IX Item "filename [VALUE]"
\&\fIInstance method.\fR
Get/set the name of the file.
.IP "flags [\s-1VALUE\s0]" 4
.IX Item "flags [VALUE]"
\&\fIInstance method.\fR
Return the flags, as an integer.  Use bitmasking to get as the values
you need.
.IP "header_as_string" 4
.IX Item "header_as_string"
Return a stringified version of the header that you might
use for logging/debugging purposes.  It looks like this:
.Sp
.Vb 7
\&    X\-HQX\-Software: BinHex 4.0 (Convert::BinHex 1.102)
\&    X\-HQX\-Filename: Something_new.eps
\&    X\-HQX\-Version: 0
\&    X\-HQX\-Type: EPSF
\&    X\-HQX\-Creator: ART5
\&    X\-HQX\-Data\-Length: 49731
\&    X\-HQX\-Rsrc\-Length: 23096
.Ve
.Sp
As some of you might have guessed, this is RFC\-822\-style, and
may be easily plunked down into the middle of a mail header, or
split into lines, etc.
.IP "requires [\s-1VALUE\s0]" 4
.IX Item "requires [VALUE]"
\&\fIInstance method.\fR
Get/set the software version required to convert this file, as
extracted from the comment that preceded the actual binhex'ed
data; e.g.:
.Sp
.Vb 1
\&    (This file must be converted with BinHex 4.0)
.Ve
.Sp
In this case, after parsing in the comment, the code:
.Sp
.Vb 1
\&    $HQX\->requires;
.Ve
.Sp
would get back \*(L"4.0\*(R".
.IP "resource [\s-1PARAMHASH\s0]" 4
.IX Item "resource [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the resource fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "type [\s-1VALUE\s0]" 4
.IX Item "type [VALUE]"
\&\fIInstance method.\fR
Get/set the type of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME\s0 \*(L"content-type\*(R".
.Sp
For example, a GIF89a file might have type \f(CW"GF89"\fR.
.IP "version [\s-1VALUE\s0]" 4
.IX Item "version [VALUE]"
\&\fIInstance method.\fR
Get/set the version, as an integer.
.SS "Decode, high-level"
.IX Subsection "Decode, high-level"
.IP "read_comment" 4
.IX Item "read_comment"
\&\fIInstance method.\fR
Skip past the opening comment in the file, which is of the form:
.Sp
.Vb 1
\&   (This file must be converted with BinHex 4.0)
.Ve
.Sp
As per \s-1RFC\-1741\s0, \fIthis comment must immediately precede the BinHex data,\fR
and any text before it will be ignored.
.Sp
\&\fIYou don't need to invoke this method yourself;\fR \f(CW\*(C`read_header()\*(C'\fR will
do it for you.  After the call, the version number in the comment is
accessible via the \f(CW\*(C`requires()\*(C'\fR method.
.IP "read_header" 4
.IX Item "read_header"
\&\fIInstance method.\fR
Read in the BinHex file header.  You must do this first!
.IP "read_data [\s-1NBYTES\s0]" 4
.IX Item "read_data [NBYTES]"
\&\fIInstance method.\fR
Read information from the data fork.  Use it in an array context to
slurp all the data into an array of scalars:
.Sp
.Vb 1
\&    @data = $HQX\->read_data;
.Ve
.Sp
Or use it in a scalar context to get the data piecemeal:
.Sp
.Vb 3
\&    while (defined($data = $HQX\->read_data)) {
\&       # do stuff with $data
\&    }
.Ve
.Sp
The \s-1NBYTES\s0 to read defaults to 2048.
.IP "read_resource [\s-1NBYTES\s0]" 4
.IX Item "read_resource [NBYTES]"
\&\fIInstance method.\fR
Read in all/some of the resource fork.
See \f(CW\*(C`read_data()\*(C'\fR for usage.
.SS "Encode, high-level"
.IX Subsection "Encode, high-level"
.IP "encode \s-1OUT\s0" 4
.IX Item "encode OUT"
Encode the object as a BinHex stream to the given output handle \s-1OUT\s0.
\&\s-1OUT\s0 can be a filehandle, or any blessed object that responds to a
\&\f(CW\*(C`print()\*(C'\fR message.
.Sp
The leading comment is output, using the \f(CW\*(C`requires()\*(C'\fR attribute.
.SH "SUBMODULES"
.IX Header "SUBMODULES"
.SS "Convert::BinHex::Bin2Hex"
.IX Subsection "Convert::BinHex::Bin2Hex"
A BINary-to-HEX converter.  This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $B2H\->next($_);          # convert some more input
\&    }
\&    print STDOUT $B2H\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $B2H\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
This may have been a good approach.  It may not.  Someday, the converter
may also allow you give it an object that responds to \fIread()\fR, or
a FileHandle, and it will do all the nasty buffer-filling on its own,
serving you stuff line by line:
.PP
.Vb 5
\&    # Someday, maybe...
\&    my $B2H = Convert::BinHex\->bin2hex(\e*STDIN);
\&    while (defined($_ = $B2H\->getline)) {
\&        print STDOUT $_;
\&    }
.Ve
.PP
Someday, maybe.  Feel free to voice your opinions.
.SS "Convert::BinHex::Hex2Bin"
.IX Subsection "Convert::BinHex::Hex2Bin"
A HEX-to-BINary converter. This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $H2B\->next($_);          # convert some more input
\&    }
\&    print STDOUT $H2B\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $H2B\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
Note that this converter does \fInot\fR find the initial
\&\*(L"BinHex version\*(R" comment.  You have to skip that yourself.  It
only handles data between the opening and closing \f(CW":"\fR.
.SS "Convert::BinHex::Fork"
.IX Subsection "Convert::BinHex::Fork"
A fork in a Macintosh file.
.PP
.Vb 3
\&    # How to get them...
\&    $data_fork = $HQX\->data;      # get the data fork
\&    $rsrc_fork = $HQX\->resource;  # get the resource fork
\&
\&    # Make a new fork:
\&    $FORK = Convert::BinHex::Fork\->new(Path => "/tmp/file.data");
\&    $FORK = Convert::BinHex::Fork\->new(Data => $scalar);
\&    $FORK = Convert::BinHex::Fork\->new(Data => \e@array_of_scalars);
\&
\&    # Get/set the length of the data fork:
\&    $len = $FORK\->length;
\&    $FORK\->length(170);        # this overrides the REAL value: be careful!
\&
\&    # Get/set the path to the underlying data (if in a disk file):
\&    $path = $FORK\->path;
\&    $FORK\->path("/tmp/file.data");
\&
\&    # Get/set the in\-core data itself, which may be a scalar or an arrayref:
\&    $data = $FORK\->data;
\&    $FORK\->data($scalar);
\&    $FORK\->data(\e@array_of_scalars);
\&
\&    # Get/set the CRC:
\&    $crc = $FORK\->crc;
\&    $FORK\->crc($crc);
.Ve
.SH "UNDER THE HOOD"
.IX Header "UNDER THE HOOD"
.SS "Design issues"
.IX Subsection "Design issues"
.IP "BinHex needs a stateful parser" 4
.IX Item "BinHex needs a stateful parser"
Unlike its cousins \fIbase64\fR and \fIuuencode\fR, BinHex format is not
amenable to being parsed line-by-line.  There appears to be no
guarantee that lines contain 4n encoded characters... and even if there
is one, the BinHex compression algorithm interferes: even when you
can \fIdecode\fR one line at a time, you can't necessarily
\&\fIdecompress\fR a line at a time.
.Sp
For example: a decoded line ending with the byte \f(CW\*(C`\ex90\*(C'\fR (the escape
or \*(L"mark\*(R" character) is ambiguous: depending on the next decoded byte,
it could mean a literal \f(CW\*(C`\ex90\*(C'\fR (if the next byte is a \f(CW\*(C`\ex00\*(C'\fR), or
it could mean n\-1 more repetitions of the previous character (if
the next byte is some nonzero \f(CW\*(C`n\*(C'\fR).
.Sp
For this reason, a BinHex parser has to be somewhat stateful: you
cannot have code like this:
.Sp
.Vb 4
\&    #### NO! #### NO! #### NO! #### NO! #### NO! ####
\&    while (<STDIN>) {            # read HEX
\&        print hexbin($_);          # convert and write BIN
\&    }
.Ve
.Sp
unless something is happening \*(L"behind the scenes\*(R" to keep track of
what was last done.  \fIThe dangerous thing, however, is that this
approach will \f(BIseem\fI to work, if you only test it on BinHex files
which do not use compression and which have 4n \s-1HEX\s0 characters
on each line.\fR
.Sp
Since we have to be stateful anyway, we use the parser object to
keep our state.
.IP "We need to be handle large input files" 4
.IX Item "We need to be handle large input files"
Solutions that demand reading everything into core don't cut
it in my book.  The first \s-1MPEG\s0 file that comes along can louse
up your whole day.  So, there are no size limitations in this
module: the data is read on-demand, and filehandles are always
an option.
.IP "Boy, is this slow!" 4
.IX Item "Boy, is this slow!"
A lot of the byte-level manipulation that has to go on, particularly
the \s-1CRC\s0 computing (which involves intensive bit-shifting and masking)
slows this module down significantly.  What is needed perhaps is an
\&\fIoptional\fR extension library where the slow pieces can be done more
quickly... a Convert::BinHex::CRC, if you will.  Volunteers, anyone?
.Sp
Even considering that, however, it's slower than I'd like.  I'm
sure many improvements can be made in the HEX-to-BIN end of things.
No doubt I'll attempt some as time goes on...
.SS "How it works"
.IX Subsection "How it works"
Since BinHex is a layered format, consisting of...
.PP
.Vb 4
\&      A Macintosh file [the "BIN"]...
\&         Encoded as a structured 8\-bit bytestream, then...
\&            Compressed to reduce duplicate bytes, then...
\&               Encoded as 7\-bit ASCII [the "HEX"]
.Ve
.PP
\&...there is a layered parsing algorithm to reverse the process.
Basically, it works in a similar fashion to stdio's \fIfread()\fR:
.PP
.Vb 11
\&       0. There is an internal buffer of decompressed (BIN) data,
\&          initially empty.
\&       1. Application asks to read() n bytes of data from object
\&       2. If the buffer is not full enough to accomodate the request:
\&            2a. The read() method grabs the next available chunk of input
\&                data (the HEX).
\&            2b. HEX data is converted and decompressed into as many BIN
\&                bytes as possible.
\&            2c. BIN bytes are added to the read() buffer.
\&            2d. Go back to step 2a. until the buffer is full enough
\&                or we hit end\-of\-input.
.Ve
.PP
The conversion-and-decompression algorithms need their own internal
buffers and state (since the next input chunk may not contain all the
data needed for a complete conversion/decompression operation).
These are maintained in the object, so parsing two different
input streams simultaneously is possible.
.SH "WARNINGS"
.IX Header "WARNINGS"
Only handles \f(CW\*(C`Hqx7\*(C'\fR files, as per \s-1RFC\-1741\s0.
.PP
Remember that Macintosh text files use \f(CW"\er"\fR as end-of-line:
this means that if you want a textual file to look normal on
a non-Mac system, you probably want to do this to the data:
.PP
.Vb 2
\&    # Get the data, and output it according to normal conventions:
\&    foreach ($HQX\->read_data) { s/\er/\en/g; print }
.Ve
.SH "CHANGE LOG"
.IX Header "CHANGE LOG"
Current version: \f(CW$Id:\fR BinHex.pm,v 1.119 1997/06/28 05:12:42 eryq Exp $
.IP "Version 1.118" 4
.IX Item "Version 1.118"
Ready to go public (with Paul's version, patched for native Mac support)!
Warnings have been suppressed in a few places where undefined values
appear.
.IP "Version 1.115" 4
.IX Item "Version 1.115"
Fixed another bug in comp2bin, related to the \s-1MARK\s0 falling on a
boundary between inputs.  Added testing code.
.IP "Version 1.114" 4
.IX Item "Version 1.114"
Added BIN-to-HEX conversion.  Eh.  It's a start.
Also, a lot of documentation additions and cleanups.
Some methods were also renamed.
.IP "Version 1.103" 4
.IX Item "Version 1.103"
Fixed bug in decompression (wasn't saving last character).
Fixed \*(L"NoComment\*(R" bug.
.IP "Version 1.102" 4
.IX Item "Version 1.102"
Initial release.
.SH "AUTHOR AND CREDITS"
.IX Header "AUTHOR AND CREDITS"
Written by Eryq, \fIhttp://www.enteract.com/~eryq\fR / \fIeryq@enteract.com\fR
.PP
Support for native-Mac conversion, \fIplus\fR invaluable contributions in 
Alpha Testing, \fIplus\fR a few patches, \fIplus\fR the baseline binhex/debinhex
programs, were provided by Paul J. Schinder (\s-1NASA/GSFC\s0).
.PP
Ken Lunde (Adobe) suggested incorporating the \s-1CAP\s0 file representation.
.SH "TERMS AND CONDITIONS"
.IX Header "TERMS AND CONDITIONS"
Copyright (c) 1997 by Eryq.  All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
.PP
This software comes with \fB\s-1NO\s0 \s-1WARRANTY\s0\fR of any kind.
See the \s-1COPYING\s0 file in the distribution for details.
      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::BinHex5.18.3pm                      0100644 0001750 0001750 00000062555 12566241407 024533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::BinHex 3"
.TH Convert::BinHex 3 "2013-09-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::BinHex \- extract data from Macintosh BinHex files
.PP
ALPHA WARNING: this code is currently in its Alpha release.
Things may change drastically until the interface is hammered out:
if you have suggestions or objections, please speak up now!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBSimple functions:\fR
.PP
.Vb 1
\&    use Convert::BinHex qw(binhex_crc macbinary_crc);
\&
\&    # Compute HQX7\-style CRC for data, pumping in old CRC if desired:
\&    $crc = binhex_crc($data, $crc);
\&
\&    # Compute the MacBinary\-II\-style CRC for the data:
\&    $crc = macbinary_crc($data, $crc);
.Ve
.PP
\&\fBHex to bin, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Hex2Bin\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $H2B\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $H2B\->done;              # no more input: finish up
.Ve
.PP
\&\fBHex to bin, \s-1OO\s0 interface.\fR
The following operations \fImust\fR be done in the order shown!
.PP
.Vb 5
\&    # Read data in piecemeal:
\&    $HQX = Convert::BinHex\->open(FH=>\e*STDIN) || die "open: $!";
\&    $HQX\->read_header;                  # read header info
\&    @data = $HQX\->read_data;            # read in all the data
\&    @rsrc = $HQX\->read_resource;        # read in all the resource
.Ve
.PP
\&\fBBin to hex, low-level interface.\fR
Conversion is actually done via an object (\*(L"Convert::BinHex::Bin2Hex\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print $STDOUT $B2H\->next($_);        # convert some more input
\&    }
\&    print $STDOUT $B2H\->done;              # no more input: finish up
.Ve
.PP
\&\fBBin to hex, file interface.\fR  Yes, you can convert \fIto\fR BinHex
as well as from it!
.PP
.Vb 2
\&    # Create new, empty object:
\&    my $HQX = Convert::BinHex\->new;
\&
\&    # Set header attributes:
\&    $HQX\->filename("logo.gif");
\&    $HQX\->type("GIFA");
\&    $HQX\->creator("CNVS");
\&
\&    # Give it the data and resource forks (either can be absent):
\&    $HQX\->data(Path => "/path/to/data");       # here, data is on disk
\&    $HQX\->resource(Data => $resourcefork);     # here, resource is in core
\&
\&    # Output as a BinHex stream, complete with leading comment:
\&    $HQX\->encode(\e*STDOUT);
.Ve
.PP
\&\fB\s-1PLANNED\s0!!!! Bin to hex, \*(L"\s-1CAP\*(R"\s0 interface.\fR
\&\fIThanks to Ken Lunde for suggesting this\fR.
.PP
.Vb 3
\&    # Create new, empty object from CAP tree:
\&    my $HQX = Convert::BinHex\->from_cap("/path/to/root/file");
\&    $HQX\->encode(\e*STDOUT);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBinHex\fR is a format used by Macintosh for transporting Mac files
safely through electronic mail, as short-lined, 7\-bit, semi-compressed
data streams.  Ths module provides a means of converting those
data streams back into into binary data.
.SH "FORMAT"
.IX Header "FORMAT"
\&\fI(Some text taken from \s-1RFC\-1741.\s0)\fR
Files on the Macintosh consist of two parts, called \fIforks\fR:
.IP "Data fork" 4
.IX Item "Data fork"
The actual data included in the file.  The Data fork is typically the
only meaningful part of a Macintosh file on a non-Macintosh computer system.
For example, if a Macintosh user wants to send a file of data to a
user on an IBM-PC, she would only send the Data fork.
.IP "Resource fork" 4
.IX Item "Resource fork"
Contains a collection of arbitrary attribute/value pairs, including
program segments, icon bitmaps, and parametric values.
.PP
Additional information regarding Macintosh files is stored by the
Finder in a hidden file, called the \*(L"Desktop Database\*(R".
.PP
Because of the complications in storing different parts of a
Macintosh file in a non-Macintosh filesystem that only handles
consecutive data in one part, it is common to convert the Macintosh
file into some other format before transferring it over the network.
The BinHex format squashes that data into transmittable \s-1ASCII\s0 as follows:
.IP "1." 4
The file is output as a \fBbyte stream\fR consisting of some basic header
information (filename, type, creator), then the data fork, then the
resource fork.
.IP "2." 4
The byte stream is \fBcompressed\fR by looking for series of duplicated
bytes and representing them using a special binary escape sequence
(of course, any occurences of the escape character must also be escaped).
.IP "3." 4
The compressed stream is \fBencoded\fR via the \*(L"6/8 hemiola\*(R" common
to \fIbase64\fR and \fIuuencode\fR: each group of three 8\-bit bytes (24 bits)
is chopped into four 6\-bit numbers, which are used as indexes into
an \s-1ASCII \s0\*(L"alphabet\*(R".
(I assume that leftover bytes are zero-padded; documentation is thin).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1CRC\s0 computation"
.IX Subsection "CRC computation"
.IP "macbinary_crc \s-1DATA, SEED\s0" 4
.IX Item "macbinary_crc DATA, SEED"
Compute the MacBinary-II-style \s-1CRC\s0 for the given \s-1DATA,\s0 with the \s-1CRC\s0
seeded to \s-1SEED. \s0 Normally, you start with a \s-1SEED\s0 of 0, and you pump in
the previous \s-1CRC\s0 as the \s-1SEED\s0 if you're handling a lot of data one chunk
at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = macbinary_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.  \fBUntested.\fR
.IP "binhex_crc \s-1DATA, SEED\s0" 4
.IX Item "binhex_crc DATA, SEED"
Compute the HQX-style \s-1CRC\s0 for the given \s-1DATA,\s0 with the \s-1CRC\s0 seeded to \s-1SEED.\s0
Normally, you start with a \s-1SEED\s0 of 0, and you pump in the previous \s-1CRC\s0 as
the \s-1SEED\s0 if you're handling a lot of data one chunk at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = binhex_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from the \fImcvert\fR utility (Doug Moore, April '87),
using a \*(L"magic array\*(R" algorithm by Jim Van Verth for efficiency.
Converted to Perl5 by Eryq.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
.SS "Conversion"
.IX Subsection "Conversion"
.IP "bin2hex" 4
.IX Item "bin2hex"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Bin2Hex\*(R"; see that class for details.
.IP "hex2bin" 4
.IX Item "hex2bin"
\&\fIClass method, constructor.\fR
Return a converter object.  Just creates a new instance of
\&\*(L"Convert::BinHex::Hex2Bin\*(R"; see that class for details.
.SS "Construction"
.IX Subsection "Construction"
.IP "new \s-1PARAMHASH\s0" 4
.IX Item "new PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a BinHex'able entity.  In general, the data and resource
forks for such an entity are stored in native format (binary) format.
.Sp
Parameters in the \s-1PARAMHASH\s0 are the same as header-oriented method names,
and may be used to set attributes:
.Sp
.Vb 3
\&    $HQX = new Convert::BinHex filename => "icon.gif",
\&                               type    => "GIFB",
\&                               creator => "CNVS";
.Ve
.IP "open \s-1PARAMHASH\s0" 4
.IX Item "open PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a new BinHex'ed stream, for parsing.
Params are:
.RS 4
.IP "Data" 4
.IX Item "Data"
Input a \s-1HEX\s0 stream from the given data.  This can be a scalar, or a
reference to an array of scalars.
.IP "Expr" 4
.IX Item "Expr"
Input a \s-1HEX\s0 stream from any \fIopen()\fRable expression.  It will be opened and
binmode'd, and the filehandle will be closed either on a \f(CW\*(C`close()\*(C'\fR
or when the object is destructed.
.IP "\s-1FH\s0" 4
.IX Item "FH"
Input a \s-1HEX\s0 stream from the given filehandle.
.IP "NoComment" 4
.IX Item "NoComment"
If true, the parser should not attempt to skip a leading \*(L"(This file...)\*(R"
comment.  That means that the first nonwhite characters encountered
must be the binhex'ed data.
.RE
.RS 4
.RE
.SS "Get/set header information"
.IX Subsection "Get/set header information"
.IP "creator [\s-1VALUE\s0]" 4
.IX Item "creator [VALUE]"
\&\fIInstance method.\fR
Get/set the creator of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a document created by \*(L"Canvas\*(R" might have
creator \f(CW"CNVS"\fR.
.IP "data [\s-1PARAMHASH\s0]" 4
.IX Item "data [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the data fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "filename [\s-1VALUE\s0]" 4
.IX Item "filename [VALUE]"
\&\fIInstance method.\fR
Get/set the name of the file.
.IP "flags [\s-1VALUE\s0]" 4
.IX Item "flags [VALUE]"
\&\fIInstance method.\fR
Return the flags, as an integer.  Use bitmasking to get as the values
you need.
.IP "header_as_string" 4
.IX Item "header_as_string"
Return a stringified version of the header that you might
use for logging/debugging purposes.  It looks like this:
.Sp
.Vb 7
\&    X\-HQX\-Software: BinHex 4.0 (Convert::BinHex 1.102)
\&    X\-HQX\-Filename: Something_new.eps
\&    X\-HQX\-Version: 0
\&    X\-HQX\-Type: EPSF
\&    X\-HQX\-Creator: ART5
\&    X\-HQX\-Data\-Length: 49731
\&    X\-HQX\-Rsrc\-Length: 23096
.Ve
.Sp
As some of you might have guessed, this is RFC\-822\-style, and
may be easily plunked down into the middle of a mail header, or
split into lines, etc.
.IP "requires [\s-1VALUE\s0]" 4
.IX Item "requires [VALUE]"
\&\fIInstance method.\fR
Get/set the software version required to convert this file, as
extracted from the comment that preceded the actual binhex'ed
data; e.g.:
.Sp
.Vb 1
\&    (This file must be converted with BinHex 4.0)
.Ve
.Sp
In this case, after parsing in the comment, the code:
.Sp
.Vb 1
\&    $HQX\->requires;
.Ve
.Sp
would get back \*(L"4.0\*(R".
.IP "resource [\s-1PARAMHASH\s0]" 4
.IX Item "resource [PARAMHASH]"
\&\fIInstance method.\fR
Get/set the resource fork.  Any arguments are passed into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "type [\s-1VALUE\s0]" 4
.IX Item "type [VALUE]"
\&\fIInstance method.\fR
Get/set the type of the file.  This is a four-character
string (though I don't know if it's guaranteed to be printable \s-1ASCII\s0!)
that serves as part of the Macintosh's version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a GIF89a file might have type \f(CW"GF89"\fR.
.IP "version [\s-1VALUE\s0]" 4
.IX Item "version [VALUE]"
\&\fIInstance method.\fR
Get/set the version, as an integer.
.SS "Decode, high-level"
.IX Subsection "Decode, high-level"
.IP "read_comment" 4
.IX Item "read_comment"
\&\fIInstance method.\fR
Skip past the opening comment in the file, which is of the form:
.Sp
.Vb 1
\&   (This file must be converted with BinHex 4.0)
.Ve
.Sp
As per \s-1RFC\-1741, \s0\fIthis comment must immediately precede the BinHex data,\fR
and any text before it will be ignored.
.Sp
\&\fIYou don't need to invoke this method yourself;\fR \f(CW\*(C`read_header()\*(C'\fR will
do it for you.  After the call, the version number in the comment is
accessible via the \f(CW\*(C`requires()\*(C'\fR method.
.IP "read_header" 4
.IX Item "read_header"
\&\fIInstance method.\fR
Read in the BinHex file header.  You must do this first!
.IP "read_data [\s-1NBYTES\s0]" 4
.IX Item "read_data [NBYTES]"
\&\fIInstance method.\fR
Read information from the data fork.  Use it in an array context to
slurp all the data into an array of scalars:
.Sp
.Vb 1
\&    @data = $HQX\->read_data;
.Ve
.Sp
Or use it in a scalar context to get the data piecemeal:
.Sp
.Vb 3
\&    while (defined($data = $HQX\->read_data)) {
\&       # do stuff with $data
\&    }
.Ve
.Sp
The \s-1NBYTES\s0 to read defaults to 2048.
.IP "read_resource [\s-1NBYTES\s0]" 4
.IX Item "read_resource [NBYTES]"
\&\fIInstance method.\fR
Read in all/some of the resource fork.
See \f(CW\*(C`read_data()\*(C'\fR for usage.
.SS "Encode, high-level"
.IX Subsection "Encode, high-level"
.IP "encode \s-1OUT\s0" 4
.IX Item "encode OUT"
Encode the object as a BinHex stream to the given output handle \s-1OUT.
OUT\s0 can be a filehandle, or any blessed object that responds to a
\&\f(CW\*(C`print()\*(C'\fR message.
.Sp
The leading comment is output, using the \f(CW\*(C`requires()\*(C'\fR attribute.
.SH "SUBMODULES"
.IX Header "SUBMODULES"
.SS "Convert::BinHex::Bin2Hex"
.IX Subsection "Convert::BinHex::Bin2Hex"
A BINary-to-HEX converter.  This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $B2H = Convert::BinHex\->bin2hex;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $B2H\->next($_);          # convert some more input
\&    }
\&    print STDOUT $B2H\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $B2H\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
This may have been a good approach.  It may not.  Someday, the converter
may also allow you give it an object that responds to \fIread()\fR, or
a FileHandle, and it will do all the nasty buffer-filling on its own,
serving you stuff line by line:
.PP
.Vb 5
\&    # Someday, maybe...
\&    my $B2H = Convert::BinHex\->bin2hex(\e*STDIN);
\&    while (defined($_ = $B2H\->getline)) {
\&        print STDOUT $_;
\&    }
.Ve
.PP
Someday, maybe.  Feel free to voice your opinions.
.SS "Convert::BinHex::Hex2Bin"
.IX Subsection "Convert::BinHex::Hex2Bin"
A HEX-to-BINary converter. This kind of conversion requires
a certain amount of state information; it cannot be done by
just calling a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Create and use a "translator" object:
\&    my $H2B = Convert::BinHex\->hex2bin;    # get a converter object
\&    while (<STDIN>) {
\&        print STDOUT $H2B\->next($_);          # convert some more input
\&    }
\&    print STDOUT $H2B\->done;               # no more input: finish up
\&
\&    # Re\-use the object:
\&    $H2B\->rewind;                 # ready for more action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty string (indicating that more converted data
is ready for you) or an empty string (indicating that the converter
is waiting to amass more input in its private buffers before handing
you more stuff to output.
.PP
Note that \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts and hands you whatever is left.
.PP
Note that this converter does \fInot\fR find the initial
\&\*(L"BinHex version\*(R" comment.  You have to skip that yourself.  It
only handles data between the opening and closing \f(CW":"\fR.
.SS "Convert::BinHex::Fork"
.IX Subsection "Convert::BinHex::Fork"
A fork in a Macintosh file.
.PP
.Vb 3
\&    # How to get them...
\&    $data_fork = $HQX\->data;      # get the data fork
\&    $rsrc_fork = $HQX\->resource;  # get the resource fork
\&
\&    # Make a new fork:
\&    $FORK = Convert::BinHex::Fork\->new(Path => "/tmp/file.data");
\&    $FORK = Convert::BinHex::Fork\->new(Data => $scalar);
\&    $FORK = Convert::BinHex::Fork\->new(Data => \e@array_of_scalars);
\&
\&    # Get/set the length of the data fork:
\&    $len = $FORK\->length;
\&    $FORK\->length(170);        # this overrides the REAL value: be careful!
\&
\&    # Get/set the path to the underlying data (if in a disk file):
\&    $path = $FORK\->path;
\&    $FORK\->path("/tmp/file.data");
\&
\&    # Get/set the in\-core data itself, which may be a scalar or an arrayref:
\&    $data = $FORK\->data;
\&    $FORK\->data($scalar);
\&    $FORK\->data(\e@array_of_scalars);
\&
\&    # Get/set the CRC:
\&    $crc = $FORK\->crc;
\&    $FORK\->crc($crc);
.Ve
.SH "UNDER THE HOOD"
.IX Header "UNDER THE HOOD"
.SS "Design issues"
.IX Subsection "Design issues"
.IP "BinHex needs a stateful parser" 4
.IX Item "BinHex needs a stateful parser"
Unlike its cousins \fIbase64\fR and \fIuuencode\fR, BinHex format is not
amenable to being parsed line-by-line.  There appears to be no
guarantee that lines contain 4n encoded characters... and even if there
is one, the BinHex compression algorithm interferes: even when you
can \fIdecode\fR one line at a time, you can't necessarily
\&\fIdecompress\fR a line at a time.
.Sp
For example: a decoded line ending with the byte \f(CW\*(C`\ex90\*(C'\fR (the escape
or \*(L"mark\*(R" character) is ambiguous: depending on the next decoded byte,
it could mean a literal \f(CW\*(C`\ex90\*(C'\fR (if the next byte is a \f(CW\*(C`\ex00\*(C'\fR), or
it could mean n\-1 more repetitions of the previous character (if
the next byte is some nonzero \f(CW\*(C`n\*(C'\fR).
.Sp
For this reason, a BinHex parser has to be somewhat stateful: you
cannot have code like this:
.Sp
.Vb 4
\&    #### NO! #### NO! #### NO! #### NO! #### NO! ####
\&    while (<STDIN>) {            # read HEX
\&        print hexbin($_);          # convert and write BIN
\&    }
.Ve
.Sp
unless something is happening \*(L"behind the scenes\*(R" to keep track of
what was last done.  \fIThe dangerous thing, however, is that this
approach will \f(BIseem\fI to work, if you only test it on BinHex files
which do not use compression and which have 4n \s-1HEX\s0 characters
on each line.\fR
.Sp
Since we have to be stateful anyway, we use the parser object to
keep our state.
.IP "We need to be handle large input files" 4
.IX Item "We need to be handle large input files"
Solutions that demand reading everything into core don't cut
it in my book.  The first \s-1MPEG\s0 file that comes along can louse
up your whole day.  So, there are no size limitations in this
module: the data is read on-demand, and filehandles are always
an option.
.IP "Boy, is this slow!" 4
.IX Item "Boy, is this slow!"
A lot of the byte-level manipulation that has to go on, particularly
the \s-1CRC\s0 computing (which involves intensive bit-shifting and masking)
slows this module down significantly.  What is needed perhaps is an
\&\fIoptional\fR extension library where the slow pieces can be done more
quickly... a Convert::BinHex::CRC, if you will.  Volunteers, anyone?
.Sp
Even considering that, however, it's slower than I'd like.  I'm
sure many improvements can be made in the HEX-to-BIN end of things.
No doubt I'll attempt some as time goes on...
.SS "How it works"
.IX Subsection "How it works"
Since BinHex is a layered format, consisting of...
.PP
.Vb 4
\&      A Macintosh file [the "BIN"]...
\&         Encoded as a structured 8\-bit bytestream, then...
\&            Compressed to reduce duplicate bytes, then...
\&               Encoded as 7\-bit ASCII [the "HEX"]
.Ve
.PP
\&...there is a layered parsing algorithm to reverse the process.
Basically, it works in a similar fashion to stdio's \fIfread()\fR:
.PP
.Vb 11
\&       0. There is an internal buffer of decompressed (BIN) data,
\&          initially empty.
\&       1. Application asks to read() n bytes of data from object
\&       2. If the buffer is not full enough to accomodate the request:
\&            2a. The read() method grabs the next available chunk of input
\&                data (the HEX).
\&            2b. HEX data is converted and decompressed into as many BIN
\&                bytes as possible.
\&            2c. BIN bytes are added to the read() buffer.
\&            2d. Go back to step 2a. until the buffer is full enough
\&                or we hit end\-of\-input.
.Ve
.PP
The conversion-and-decompression algorithms need their own internal
buffers and state (since the next input chunk may not contain all the
data needed for a complete conversion/decompression operation).
These are maintained in the object, so parsing two different
input streams simultaneously is possible.
.SH "WARNINGS"
.IX Header "WARNINGS"
Only handles \f(CW\*(C`Hqx7\*(C'\fR files, as per \s-1RFC\-1741.\s0
.PP
Remember that Macintosh text files use \f(CW"\er"\fR as end-of-line:
this means that if you want a textual file to look normal on
a non-Mac system, you probably want to do this to the data:
.PP
.Vb 2
\&    # Get the data, and output it according to normal conventions:
\&    foreach ($HQX\->read_data) { s/\er/\en/g; print }
.Ve
.SH "AUTHOR AND CREDITS"
.IX Header "AUTHOR AND CREDITS"
Maintained by Stephen Nelson <stephenenelson@mac.com>
.PP
Written by Eryq, \fIhttp://www.enteract.com/~eryq\fR / \fIeryq@enteract.com\fR
.PP
Support for native-Mac conversion, \fIplus\fR invaluable contributions in 
Alpha Testing, \fIplus\fR a few patches, \fIplus\fR the baseline binhex/debinhex
programs, were provided by Paul J. Schinder (\s-1NASA/GSFC\s0).
.PP
Ken Lunde (Adobe) suggested incorporating the \s-1CAP\s0 file representation.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1997 by Eryq.  All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.
.PP
This software comes with \fB\s-1NO WARRANTY\s0\fR of any kind.
See the \s-1COPYING\s0 file in the distribution for details.
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::TNEF.3pm                            0100644 0001750 0001750 00000027170 12566241460 023567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TNEF 3"
.TH TNEF 3 "2012-07-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\& Convert::TNEF \- Perl module to read TNEF files
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::TNEF;
\&
\& $tnef = Convert::TNEF\->read($iohandle, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_in($filename, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_ent($mime_entity, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef\->purge;
\&
\& $message = $tnef\->message;
\&
\& @attachments = $tnef\->attachments;
\&
\& $attribute_value      = $attachments[$i]\->data($att_attribute_name);
\& $attribute_value_size = $attachments[$i]\->size($att_attribute_name);
\& $attachment_name = $attachments[$i]\->name;
\& $long_attachment_name = $attachments[$i]\->longname;
\&
\& $datahandle = $attachments[$i]\->datahandle($att_attribute_name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 3
\& TNEF stands for Transport Neutral Encapsulation Format, and if you\*(Aqve
\& ever been unfortunate enough to receive one of these files as an email
\& attachment, you may want to use this module.
\&
\& read() takes as its first argument any file handle open
\& for reading. The optional second argument is a hash reference
\& which contains one or more of the following keys:
.Ve
.SS ""
.IX Subsection ""
.Vb 2
\& output_dir \- Path for storing TNEF attribute data kept in files
\& (default: current directory).
\&
\& output_prefix \- File prefix for TNEF attribute data kept in files
\& (default: \*(Aqtnef\*(Aq).
\&
\& output_to_core \- TNEF attribute data will be saved in core memory unless
\& it is greater than this many bytes (default: 4096). May also be set to
\& \*(AqNONE\*(Aq to keep all data in files, or \*(AqALL\*(Aq to keep all data in core.
\&
\& buffer_size \- Buffer size for reading in the TNEF file (default: 1024).
\&
\& debug \- If true, outputs all sorts of info about what the read() function
\& is reading, including the raw ascii data along with the data converted
\& to hex (default: false).
\&
\& display_after_err \- If debug is true and an error is encountered,
\& reads and displays this many bytes of data following the error
\& (default: 32).
\&
\& debug_max_display \- If debug is true then read and display at most
\& this many bytes of data for each TNEF attribute (default: 1024).
\&
\& debug_max_line_size \- If debug is true then at most this many bytes of
\& data will be displayed on each line for each TNEF attribute
\& (default: 64).
\&
\& ignore_checksum \- If true, will ignore checksum errors while parsing
\& data (default: false).
\&
\& read() returns an object containing the TNEF \*(Aqattributes\*(Aq read from the
\& file and the data for those attributes. If all you want are the
\& attachments, then this is mostly garbage, but if you\*(Aqre interested then
\& you can see all the garbage by turning on debugging. If the garbage
\& proves useful to you, then let me know how I can maybe make it more
\& useful.
\&
\& If an error is encountered, an undefined value is returned and the
\& package variable $errstr is set to some helpful message.
\&
\& read_in() is a convienient front end for read() which takes a filename
\& instead of a handle.
\&
\& read_ent() is another convient front end for read() which can take a
\& MIME::Entity object (or any object with like methods, specifically
\& open("r"), read($buff,$num_bytes), and close ).
\&
\& purge() deletes any on\-disk data that may be in the attachments of
\& the TNEF object.
\&
\& message() returns the message portion of the tnef object, if any.
\& The thing it returns is like an attachment, but its not an attachment.
\& For instance, it more than likely does not have a name or any
\& attachment data.
\&
\& attachments() returns a list of the attachments that the given TNEF
\& object contains. Returns a list ref if not called in array context.
\&
\& data() takes a TNEF attribute name, and returns a string value for that 
\& attribute for that attachment. Its your own problem if the string is too
\& big for memory. If no argument is given, then the \*(AqAttachData\*(Aq attribute
\& is assumed, which is probably the attachment data you\*(Aqre looking for.
\&
\& name() is the same as data(), except the attribute \*(AqAttachTitle\*(Aq is
\& the default, which returns the 8 character + 3 character extension name
\& of the attachment.
\&
\& longname() returns the long filename and extension of an attachment. This
\& is embedded within a MAPI property of the \*(AqAttachment\*(Aq attribute data, so
\& we attempt to extract the name out of that.
\&
\& size() takes an TNEF attribute name, and returns the size in bytes for
\& the data for that attachment attribute.
\&
\& datahandle() is a method for attachments which takes a TNEF attribute
\& name, and returns the data for that attribute as a handle which is
\& the same as a MIME::Body handle.  See MIME::Body for all the applicable
\& methods. If no argument is given, then \*(AqAttachData\*(Aq is assumed.
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\& # Here\*(Aqs a rather long example where mail is retrieved
\& # from a POP3 server based on header information, then
\& # it is MIME parsed, and then the TNEF contents
\& # are extracted and converted.
\&
\& use strict;
\& use Net::POP3;
\& use MIME::Parser;
\& use Convert::TNEF;
\&
\& my $mail_dir = "mailout";
\& my $mail_prefix = "mail";
\&
\& my $pop = new Net::POP3 ( "pop3server_name" );
\& my $num_msgs = $pop\->login("user_name","password");
\& die "Can\*(Aqt login: $!" unless defined $num_msgs;
\&
\& # Get mail by sender and subject
\& my $mail_out_idx = 0;
\& MESSAGE: for ( my $i=1; $i<= $num_msgs;  $i++ ) {
\&  my $header = join "", @{$pop\->top($i)};
\&
\&  for ($header) {
\&   next MESSAGE unless
\&    /^from:.*someone\e@somewhere.net/im &&
\&    /^subject:\es*important stuff/im
\&  }
\&
\&  my $fname = $mail_prefix."\-".$$.++$mail_out_idx.".doc";
\&  open (MAILOUT, ">$mail_dir/$fname")
\&   or die "Can\*(Aqt open $mail_dir/$fname: $!";
\&  # If the get() complains, you need the new libnet bundle
\&  $pop\->get($i, \e*MAILOUT) or die "Can\*(Aqt read mail";
\&  close MAILOUT or die "Error closing $mail_dir/$fname";
\&  # If you want to delete the mail on the server
\&  # $pop\->delete($i);
\& }
\&
\& close MAILOUT;
\& $pop\->quit();
\&
\& # Parse the mail message into separate mime entities
\& my $parser=new MIME::Parser;
\& $parser\->output_dir("mimemail");
\&
\& opendir(DIR, $mail_dir) or die "Can\*(Aqt open directory $mail_dir: $!";
\& my @files = map { $mail_dir."/".$_ } sort
\&  grep { \-f "$mail_dir/$_" and /$mail_prefix\-$$\-/o } readdir DIR;
\& closedir DIR;
\&
\& for my $file ( @files ) {
\&  my $entity=$parser\->parse_in($file) or die "Couldn\*(Aqt parse mail";
\&  print_tnef_parts($entity);
\&  # If you want to delete the working files
\&  # $entity\->purge;
\& }
\&
\& sub print_tnef_parts {
\&  my $ent = shift;
\&
\&  if ( $ent\->parts ) {
\&   for my $sub_ent ( $ent\->parts ) {
\&    print_tnef_parts($sub_ent);
\&   }
\&  } elsif ( $ent\->mime_type =~ /ms\-tnef/i ) {
\&
\&   # Create a tnef object
\&   my $tnef = Convert::TNEF\->read_ent($ent,{output_dir=>"tnefmail"})
\&    or die $Convert::TNEF::errstr;
\&   for ($tnef\->attachments) {
\&    print "Title:",$_\->name,"\en";
\&    print "Data:\en",$_\->data,"\en";
\&   }
\&
\&   # If you want to delete the working files
\&   # $tnef\->purge;
\&  }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIIO::Wrap\fR\|(3), \fIMIME::Parser\fR\|(3), \fIMIME::Entity\fR\|(3), \fIMIME::Body\fR\|(3)
.SH "CAVEATS"
.IX Header "CAVEATS"
.Vb 4
\& The parsing may depend on the endianness (see perlport) and width of
\& integers on the system where the TNEF file was created. If this proves
\& to be the case (check the debug output), I\*(Aqll see what I can do
\& about it.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Douglas Wilson, dougw@cpan.org
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::TNEF5.16.3pm                        0100644 0001750 0001750 00000026647 12566241460 024111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TNEF 3"
.TH TNEF 3 "2012-07-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\& Convert::TNEF \- Perl module to read TNEF files
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::TNEF;
\&
\& $tnef = Convert::TNEF\->read($iohandle, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_in($filename, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_ent($mime_entity, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef\->purge;
\&
\& $message = $tnef\->message;
\&
\& @attachments = $tnef\->attachments;
\&
\& $attribute_value      = $attachments[$i]\->data($att_attribute_name);
\& $attribute_value_size = $attachments[$i]\->size($att_attribute_name);
\& $attachment_name = $attachments[$i]\->name;
\& $long_attachment_name = $attachments[$i]\->longname;
\&
\& $datahandle = $attachments[$i]\->datahandle($att_attribute_name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 3
\& TNEF stands for Transport Neutral Encapsulation Format, and if you\*(Aqve
\& ever been unfortunate enough to receive one of these files as an email
\& attachment, you may want to use this module.
\&
\& read() takes as its first argument any file handle open
\& for reading. The optional second argument is a hash reference
\& which contains one or more of the following keys:
.Ve
.SS ""
.IX Subsection ""
.Vb 2
\& output_dir \- Path for storing TNEF attribute data kept in files
\& (default: current directory).
\&
\& output_prefix \- File prefix for TNEF attribute data kept in files
\& (default: \*(Aqtnef\*(Aq).
\&
\& output_to_core \- TNEF attribute data will be saved in core memory unless
\& it is greater than this many bytes (default: 4096). May also be set to
\& \*(AqNONE\*(Aq to keep all data in files, or \*(AqALL\*(Aq to keep all data in core.
\&
\& buffer_size \- Buffer size for reading in the TNEF file (default: 1024).
\&
\& debug \- If true, outputs all sorts of info about what the read() function
\& is reading, including the raw ascii data along with the data converted
\& to hex (default: false).
\&
\& display_after_err \- If debug is true and an error is encountered,
\& reads and displays this many bytes of data following the error
\& (default: 32).
\&
\& debug_max_display \- If debug is true then read and display at most
\& this many bytes of data for each TNEF attribute (default: 1024).
\&
\& debug_max_line_size \- If debug is true then at most this many bytes of
\& data will be displayed on each line for each TNEF attribute
\& (default: 64).
\&
\& ignore_checksum \- If true, will ignore checksum errors while parsing
\& data (default: false).
\&
\& read() returns an object containing the TNEF \*(Aqattributes\*(Aq read from the
\& file and the data for those attributes. If all you want are the
\& attachments, then this is mostly garbage, but if you\*(Aqre interested then
\& you can see all the garbage by turning on debugging. If the garbage
\& proves useful to you, then let me know how I can maybe make it more
\& useful.
\&
\& If an error is encountered, an undefined value is returned and the
\& package variable $errstr is set to some helpful message.
\&
\& read_in() is a convienient front end for read() which takes a filename
\& instead of a handle.
\&
\& read_ent() is another convient front end for read() which can take a
\& MIME::Entity object (or any object with like methods, specifically
\& open("r"), read($buff,$num_bytes), and close ).
\&
\& purge() deletes any on\-disk data that may be in the attachments of
\& the TNEF object.
\&
\& message() returns the message portion of the tnef object, if any.
\& The thing it returns is like an attachment, but its not an attachment.
\& For instance, it more than likely does not have a name or any
\& attachment data.
\&
\& attachments() returns a list of the attachments that the given TNEF
\& object contains. Returns a list ref if not called in array context.
\&
\& data() takes a TNEF attribute name, and returns a string value for that 
\& attribute for that attachment. Its your own problem if the string is too
\& big for memory. If no argument is given, then the \*(AqAttachData\*(Aq attribute
\& is assumed, which is probably the attachment data you\*(Aqre looking for.
\&
\& name() is the same as data(), except the attribute \*(AqAttachTitle\*(Aq is
\& the default, which returns the 8 character + 3 character extension name
\& of the attachment.
\&
\& longname() returns the long filename and extension of an attachment. This
\& is embedded within a MAPI property of the \*(AqAttachment\*(Aq attribute data, so
\& we attempt to extract the name out of that.
\&
\& size() takes an TNEF attribute name, and returns the size in bytes for
\& the data for that attachment attribute.
\&
\& datahandle() is a method for attachments which takes a TNEF attribute
\& name, and returns the data for that attribute as a handle which is
\& the same as a MIME::Body handle.  See MIME::Body for all the applicable
\& methods. If no argument is given, then \*(AqAttachData\*(Aq is assumed.
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\& # Here\*(Aqs a rather long example where mail is retrieved
\& # from a POP3 server based on header information, then
\& # it is MIME parsed, and then the TNEF contents
\& # are extracted and converted.
\&
\& use strict;
\& use Net::POP3;
\& use MIME::Parser;
\& use Convert::TNEF;
\&
\& my $mail_dir = "mailout";
\& my $mail_prefix = "mail";
\&
\& my $pop = new Net::POP3 ( "pop3server_name" );
\& my $num_msgs = $pop\->login("user_name","password");
\& die "Can\*(Aqt login: $!" unless defined $num_msgs;
\&
\& # Get mail by sender and subject
\& my $mail_out_idx = 0;
\& MESSAGE: for ( my $i=1; $i<= $num_msgs;  $i++ ) {
\&  my $header = join "", @{$pop\->top($i)};
\&
\&  for ($header) {
\&   next MESSAGE unless
\&    /^from:.*someone\e@somewhere.net/im &&
\&    /^subject:\es*important stuff/im
\&  }
\&
\&  my $fname = $mail_prefix."\-".$$.++$mail_out_idx.".doc";
\&  open (MAILOUT, ">$mail_dir/$fname")
\&   or die "Can\*(Aqt open $mail_dir/$fname: $!";
\&  # If the get() complains, you need the new libnet bundle
\&  $pop\->get($i, \e*MAILOUT) or die "Can\*(Aqt read mail";
\&  close MAILOUT or die "Error closing $mail_dir/$fname";
\&  # If you want to delete the mail on the server
\&  # $pop\->delete($i);
\& }
\&
\& close MAILOUT;
\& $pop\->quit();
\&
\& # Parse the mail message into separate mime entities
\& my $parser=new MIME::Parser;
\& $parser\->output_dir("mimemail");
\&
\& opendir(DIR, $mail_dir) or die "Can\*(Aqt open directory $mail_dir: $!";
\& my @files = map { $mail_dir."/".$_ } sort
\&  grep { \-f "$mail_dir/$_" and /$mail_prefix\-$$\-/o } readdir DIR;
\& closedir DIR;
\&
\& for my $file ( @files ) {
\&  my $entity=$parser\->parse_in($file) or die "Couldn\*(Aqt parse mail";
\&  print_tnef_parts($entity);
\&  # If you want to delete the working files
\&  # $entity\->purge;
\& }
\&
\& sub print_tnef_parts {
\&  my $ent = shift;
\&
\&  if ( $ent\->parts ) {
\&   for my $sub_ent ( $ent\->parts ) {
\&    print_tnef_parts($sub_ent);
\&   }
\&  } elsif ( $ent\->mime_type =~ /ms\-tnef/i ) {
\&
\&   # Create a tnef object
\&   my $tnef = Convert::TNEF\->read_ent($ent,{output_dir=>"tnefmail"})
\&    or die $Convert::TNEF::errstr;
\&   for ($tnef\->attachments) {
\&    print "Title:",$_\->name,"\en";
\&    print "Data:\en",$_\->data,"\en";
\&   }
\&
\&   # If you want to delete the working files
\&   # $tnef\->purge;
\&  }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIIO::Wrap\fR\|(3), \fIMIME::Parser\fR\|(3), \fIMIME::Entity\fR\|(3), \fIMIME::Body\fR\|(3)
.SH "CAVEATS"
.IX Header "CAVEATS"
.Vb 4
\& The parsing may depend on the endianness (see perlport) and width of
\& integers on the system where the TNEF file was created. If this proves
\& to be the case (check the debug output), I\*(Aqll see what I can do
\& about it.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Douglas Wilson, dougw@cpan.org
.Ve
                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::TNEF5.18.3pm                        0100644 0001750 0001750 00000027170 12566241460 024103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TNEF 3"
.TH TNEF 3 "2012-07-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\& Convert::TNEF \- Perl module to read TNEF files
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::TNEF;
\&
\& $tnef = Convert::TNEF\->read($iohandle, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_in($filename, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef = Convert::TNEF\->read_ent($mime_entity, \e%parms)
\&  or die Convert::TNEF::errstr;
\&
\& $tnef\->purge;
\&
\& $message = $tnef\->message;
\&
\& @attachments = $tnef\->attachments;
\&
\& $attribute_value      = $attachments[$i]\->data($att_attribute_name);
\& $attribute_value_size = $attachments[$i]\->size($att_attribute_name);
\& $attachment_name = $attachments[$i]\->name;
\& $long_attachment_name = $attachments[$i]\->longname;
\&
\& $datahandle = $attachments[$i]\->datahandle($att_attribute_name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 3
\& TNEF stands for Transport Neutral Encapsulation Format, and if you\*(Aqve
\& ever been unfortunate enough to receive one of these files as an email
\& attachment, you may want to use this module.
\&
\& read() takes as its first argument any file handle open
\& for reading. The optional second argument is a hash reference
\& which contains one or more of the following keys:
.Ve
.SS ""
.IX Subsection ""
.Vb 2
\& output_dir \- Path for storing TNEF attribute data kept in files
\& (default: current directory).
\&
\& output_prefix \- File prefix for TNEF attribute data kept in files
\& (default: \*(Aqtnef\*(Aq).
\&
\& output_to_core \- TNEF attribute data will be saved in core memory unless
\& it is greater than this many bytes (default: 4096). May also be set to
\& \*(AqNONE\*(Aq to keep all data in files, or \*(AqALL\*(Aq to keep all data in core.
\&
\& buffer_size \- Buffer size for reading in the TNEF file (default: 1024).
\&
\& debug \- If true, outputs all sorts of info about what the read() function
\& is reading, including the raw ascii data along with the data converted
\& to hex (default: false).
\&
\& display_after_err \- If debug is true and an error is encountered,
\& reads and displays this many bytes of data following the error
\& (default: 32).
\&
\& debug_max_display \- If debug is true then read and display at most
\& this many bytes of data for each TNEF attribute (default: 1024).
\&
\& debug_max_line_size \- If debug is true then at most this many bytes of
\& data will be displayed on each line for each TNEF attribute
\& (default: 64).
\&
\& ignore_checksum \- If true, will ignore checksum errors while parsing
\& data (default: false).
\&
\& read() returns an object containing the TNEF \*(Aqattributes\*(Aq read from the
\& file and the data for those attributes. If all you want are the
\& attachments, then this is mostly garbage, but if you\*(Aqre interested then
\& you can see all the garbage by turning on debugging. If the garbage
\& proves useful to you, then let me know how I can maybe make it more
\& useful.
\&
\& If an error is encountered, an undefined value is returned and the
\& package variable $errstr is set to some helpful message.
\&
\& read_in() is a convienient front end for read() which takes a filename
\& instead of a handle.
\&
\& read_ent() is another convient front end for read() which can take a
\& MIME::Entity object (or any object with like methods, specifically
\& open("r"), read($buff,$num_bytes), and close ).
\&
\& purge() deletes any on\-disk data that may be in the attachments of
\& the TNEF object.
\&
\& message() returns the message portion of the tnef object, if any.
\& The thing it returns is like an attachment, but its not an attachment.
\& For instance, it more than likely does not have a name or any
\& attachment data.
\&
\& attachments() returns a list of the attachments that the given TNEF
\& object contains. Returns a list ref if not called in array context.
\&
\& data() takes a TNEF attribute name, and returns a string value for that 
\& attribute for that attachment. Its your own problem if the string is too
\& big for memory. If no argument is given, then the \*(AqAttachData\*(Aq attribute
\& is assumed, which is probably the attachment data you\*(Aqre looking for.
\&
\& name() is the same as data(), except the attribute \*(AqAttachTitle\*(Aq is
\& the default, which returns the 8 character + 3 character extension name
\& of the attachment.
\&
\& longname() returns the long filename and extension of an attachment. This
\& is embedded within a MAPI property of the \*(AqAttachment\*(Aq attribute data, so
\& we attempt to extract the name out of that.
\&
\& size() takes an TNEF attribute name, and returns the size in bytes for
\& the data for that attachment attribute.
\&
\& datahandle() is a method for attachments which takes a TNEF attribute
\& name, and returns the data for that attribute as a handle which is
\& the same as a MIME::Body handle.  See MIME::Body for all the applicable
\& methods. If no argument is given, then \*(AqAttachData\*(Aq is assumed.
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\& # Here\*(Aqs a rather long example where mail is retrieved
\& # from a POP3 server based on header information, then
\& # it is MIME parsed, and then the TNEF contents
\& # are extracted and converted.
\&
\& use strict;
\& use Net::POP3;
\& use MIME::Parser;
\& use Convert::TNEF;
\&
\& my $mail_dir = "mailout";
\& my $mail_prefix = "mail";
\&
\& my $pop = new Net::POP3 ( "pop3server_name" );
\& my $num_msgs = $pop\->login("user_name","password");
\& die "Can\*(Aqt login: $!" unless defined $num_msgs;
\&
\& # Get mail by sender and subject
\& my $mail_out_idx = 0;
\& MESSAGE: for ( my $i=1; $i<= $num_msgs;  $i++ ) {
\&  my $header = join "", @{$pop\->top($i)};
\&
\&  for ($header) {
\&   next MESSAGE unless
\&    /^from:.*someone\e@somewhere.net/im &&
\&    /^subject:\es*important stuff/im
\&  }
\&
\&  my $fname = $mail_prefix."\-".$$.++$mail_out_idx.".doc";
\&  open (MAILOUT, ">$mail_dir/$fname")
\&   or die "Can\*(Aqt open $mail_dir/$fname: $!";
\&  # If the get() complains, you need the new libnet bundle
\&  $pop\->get($i, \e*MAILOUT) or die "Can\*(Aqt read mail";
\&  close MAILOUT or die "Error closing $mail_dir/$fname";
\&  # If you want to delete the mail on the server
\&  # $pop\->delete($i);
\& }
\&
\& close MAILOUT;
\& $pop\->quit();
\&
\& # Parse the mail message into separate mime entities
\& my $parser=new MIME::Parser;
\& $parser\->output_dir("mimemail");
\&
\& opendir(DIR, $mail_dir) or die "Can\*(Aqt open directory $mail_dir: $!";
\& my @files = map { $mail_dir."/".$_ } sort
\&  grep { \-f "$mail_dir/$_" and /$mail_prefix\-$$\-/o } readdir DIR;
\& closedir DIR;
\&
\& for my $file ( @files ) {
\&  my $entity=$parser\->parse_in($file) or die "Couldn\*(Aqt parse mail";
\&  print_tnef_parts($entity);
\&  # If you want to delete the working files
\&  # $entity\->purge;
\& }
\&
\& sub print_tnef_parts {
\&  my $ent = shift;
\&
\&  if ( $ent\->parts ) {
\&   for my $sub_ent ( $ent\->parts ) {
\&    print_tnef_parts($sub_ent);
\&   }
\&  } elsif ( $ent\->mime_type =~ /ms\-tnef/i ) {
\&
\&   # Create a tnef object
\&   my $tnef = Convert::TNEF\->read_ent($ent,{output_dir=>"tnefmail"})
\&    or die $Convert::TNEF::errstr;
\&   for ($tnef\->attachments) {
\&    print "Title:",$_\->name,"\en";
\&    print "Data:\en",$_\->data,"\en";
\&   }
\&
\&   # If you want to delete the working files
\&   # $tnef\->purge;
\&  }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIIO::Wrap\fR\|(3), \fIMIME::Parser\fR\|(3), \fIMIME::Entity\fR\|(3), \fIMIME::Body\fR\|(3)
.SH "CAVEATS"
.IX Header "CAVEATS"
.Vb 4
\& The parsing may depend on the endianness (see perlport) and width of
\& integers on the system where the TNEF file was created. If this proves
\& to be the case (check the debug output), I\*(Aqll see what I can do
\& about it.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Douglas Wilson, dougw@cpan.org
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::UUlib.3pm                           0100644 0001750 0001750 00000052322 12566241425 024051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UUlib 3"
.TH UUlib 3 "2011-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::UUlib \- Perl interface to the uulib library (a.k.a. uudeview/uuenview).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::UUlib \*(Aq:all\*(Aq;
\& 
\& # read all the files named on the commandline and decode them
\& # into the CURRENT directory. See below for a longer example.
\& LoadFile $_ for @ARGV;
\& for (my $i = 0; my $uu = GetFileListItem $i; $i++) {
\&    if ($uu\->state & FILE_OK) {
\&      $uu\->decode;
\&      print $uu\->filename, "\en";
\&    }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read the file doc/library.pdf from the distribution for in-depth
information about the C\-library used in this interface, and the rest of
this document and especially the non-trivial decoder program at the end.
.SH "EXPORTED CONSTANTS"
.IX Header "EXPORTED CONSTANTS"
.SS "Action code constants"
.IX Subsection "Action code constants"
.Vb 5
\&  ACT_IDLE      we don\*(Aqt do anything
\&  ACT_SCANNING  scanning an input file
\&  ACT_DECODING  decoding into a temp file
\&  ACT_COPYING   copying temp to target
\&  ACT_ENCODING  encoding a file
.Ve
.SS "Message severity levels"
.IX Subsection "Message severity levels"
.Vb 6
\&  MSG_MESSAGE   just a message, nothing important
\&  MSG_NOTE      something that should be noticed
\&  MSG_WARNING   important msg, processing continues
\&  MSG_ERROR     processing has been terminated
\&  MSG_FATAL     decoder cannot process further requests
\&  MSG_PANIC     recovery impossible, app must terminate
.Ve
.SS "Options"
.IX Subsection "Options"
.Vb 10
\&  OPT_VERSION   version number MAJOR.MINORplPATCH (ro)
\&  OPT_FAST      assumes only one part per file
\&  OPT_DUMBNESS  switch off the program\*(Aqs intelligence
\&  OPT_BRACKPOL  give numbers in [] higher precendence
\&  OPT_VERBOSE   generate informative messages
\&  OPT_DESPERATE try to decode incomplete files
\&  OPT_IGNREPLY  ignore RE:plies (off by default)
\&  OPT_OVERWRITE whether it\*(Aqs OK to overwrite ex. files
\&  OPT_SAVEPATH  prefix to save\-files on disk
\&  OPT_IGNMODE   ignore the original file mode
\&  OPT_DEBUG     print messages with FILE/LINE info
\&  OPT_ERRNO     get last error code for RET_IOERR (ro)
\&  OPT_PROGRESS  retrieve progress information
\&  OPT_USETEXT   handle text messages
\&  OPT_PREAMB    handle Mime preambles/epilogues
\&  OPT_TINYB64   detect short B64 outside of Mime
\&  OPT_ENCEXT    extension for single\-part encoded files
\&  OPT_REMOVE    remove input files after decoding (dangerous)
\&  OPT_MOREMIME  strict MIME adherence
\&  OPT_DOTDOT    ".."\-unescaping has not yet been done on input files
\&  OPT_RBUF      set default read I/O buffer size in bytes
\&  OPT_WBUF      set default write I/O buffer size in bytes
\&  OPT_AUTOCHECK automatically check file list after every loadfile
.Ve
.SS "Result/Error codes"
.IX Subsection "Result/Error codes"
.Vb 10
\&  RET_OK        everything went fine
\&  RET_IOERR     I/O Error \- examine errno
\&  RET_NOMEM     not enough memory
\&  RET_ILLVAL    illegal value for operation
\&  RET_NODATA    decoder didn\*(Aqt find any data
\&  RET_NOEND     encoded data wasn\*(Aqt ended properly
\&  RET_UNSUP     unsupported function (encoding)
\&  RET_EXISTS    file exists (decoding)
\&  RET_CONT      continue \-\- special from ScanPart
\&  RET_CANCEL    operation canceled
.Ve
.SS "File States"
.IX Subsection "File States"
.Vb 1
\& This code is zero, i.e. "false":
\&
\&  UUFILE_READ   Read in, but not further processed
\&
\& The following state codes are or\*(Aqed together:
\&
\&  FILE_MISPART  Missing Part(s) detected
\&  FILE_NOBEGIN  No \*(Aqbegin\*(Aq found
\&  FILE_NOEND    No \*(Aqend\*(Aq found
\&  FILE_NODATA   File does not contain valid uudata
\&  FILE_OK       All Parts found, ready to decode
\&  FILE_ERROR    Error while decoding
\&  FILE_DECODED  Successfully decoded
\&  FILE_TMPFILE  Temporary decoded file exists
.Ve
.SS "Encoding types"
.IX Subsection "Encoding types"
.Vb 7
\&  UU_ENCODED    UUencoded data
\&  B64_ENCODED   Mime\-Base64 data
\&  XX_ENCODED    XXencoded data
\&  BH_ENCODED    Binhex encoded
\&  PT_ENCODED    Plain\-Text encoded (MIME)
\&  QP_ENCODED    Quoted\-Printable (MIME)
\&  YENC_ENCODED  yEnc encoded (non\-MIME)
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "Initializing and cleanup"
.IX Subsection "Initializing and cleanup"
Initialize is automatically called when the module is loaded and allocates
quite a small amount of memory for todays machines ;) CleanUp releases that
again.
.PP
On my machine, a fairly complete decode with \s-1DBI\s0 backend needs about 10MB
\&\s-1RSS\s0 to decode 20000 files.
.IP "Initialize" 4
.IX Item "Initialize"
Not normally necessary, (re\-)initializes the library.
.IP "CleanUp" 4
.IX Item "CleanUp"
Not normally necessary, could be called at the end to release memory
before starting a new decoding round.
.SS "Setting and querying options"
.IX Subsection "Setting and querying options"
.ie n .IP "$option = GetOption OPT_xxx" 4
.el .IP "\f(CW$option\fR = GetOption OPT_xxx" 4
.IX Item "$option = GetOption OPT_xxx"
.PD 0
.IP "SetOption OPT_xxx, opt-value" 4
.IX Item "SetOption OPT_xxx, opt-value"
.PD
.PP
See the \f(CW\*(C`OPT_xxx\*(C'\fR constants above to see which options exist.
.SS "Setting various callbacks"
.IX Subsection "Setting various callbacks"
.IP "SetMsgCallback [callback\-function]" 4
.IX Item "SetMsgCallback [callback-function]"
.PD 0
.IP "SetBusyCallback [callback\-function]" 4
.IX Item "SetBusyCallback [callback-function]"
.IP "SetFileCallback [callback\-function]" 4
.IX Item "SetFileCallback [callback-function]"
.IP "SetFNameFilter [callback\-function]" 4
.IX Item "SetFNameFilter [callback-function]"
.PD
.SS "Call the currently selected FNameFilter"
.IX Subsection "Call the currently selected FNameFilter"
.ie n .IP "$file = FNameFilter $file" 4
.el .IP "\f(CW$file\fR = FNameFilter \f(CW$file\fR" 4
.IX Item "$file = FNameFilter $file"
.SS "Loading sourcefiles, optionally fuzzy merge and start decoding"
.IX Subsection "Loading sourcefiles, optionally fuzzy merge and start decoding"
.PD 0
.ie n .IP "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]" 4
.el .IP "($retval, \f(CW$count\fR) = LoadFile \f(CW$fname\fR, [$id, [$delflag, [$partno]]]" 4
.IX Item "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]"
.PD
Load the given file and scan it for encoded contents. Optionally tag it
with the given id, and if \f(CW$delflag\fR is true, delete the file after it
is no longer necessary. If you are certain of the part number, you can
specify it as the last argument.
.Sp
A better (usually faster) way of doing this is using the \f(CW\*(C`SetFNameFilter\*(C'\fR
functionality.
.ie n .IP "$retval = Smerge $pass" 4
.el .IP "\f(CW$retval\fR = Smerge \f(CW$pass\fR" 4
.IX Item "$retval = Smerge $pass"
If you are desperate, try to call \f(CW\*(C`Smerge\*(C'\fR with increasing \f(CW$pass\fR
values, beginning at \f(CW0\fR, to try to merge parts that usually would not
have been merged.
.Sp
Most probably this will result in garbled files, so never do this by
default, except:
.Sp
If the \f(CW\*(C`OPT_AUTOCHECK\*(C'\fR option has been disabled (by default it is
enabled) to speed up file loading, then you \fIhave\fR to call \f(CW\*(C`Smerge \-1\*(C'\fR
after loading all files as an additional pre-pass (which is normally done
by \f(CW\*(C`LoadFile\*(C'\fR).
.ie n .IP "$item = GetFileListItem $item_number" 4
.el .IP "\f(CW$item\fR = GetFileListItem \f(CW$item_number\fR" 4
.IX Item "$item = GetFileListItem $item_number"
Return the \f(CW$item\fR structure for the \f(CW$item_number\fR'th found file, or
\&\f(CW\*(C`undef\*(C'\fR of no file with that number exists.
.Sp
The first file has number \f(CW0\fR, and the series has no holes, so you can
iterate over all files by starting with zero and incrementing until you
hit \f(CW\*(C`undef\*(C'\fR.
.SS "Decoding files"
.IX Subsection "Decoding files"
.ie n .IP "$retval = $item\->rename($newname)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->rename($newname)" 4
.IX Item "$retval = $item->rename($newname)"
Change the ondisk filename where the decoded file will be saved.
.ie n .IP "$retval = $item\->decode_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode_temp" 4
.IX Item "$retval = $item->decode_temp"
Decode the file into a temporary location, use \f(CW\*(C`$item\->infile\*(C'\fR to
retrieve the temporary filename.
.ie n .IP "$retval = $item\->remove_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->remove_temp" 4
.IX Item "$retval = $item->remove_temp"
Remove the temporarily decoded file again.
.ie n .IP "$retval = $item\->decode([$target_path])" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode([$target_path])" 4
.IX Item "$retval = $item->decode([$target_path])"
Decode the file to it's destination, or the given target path.
.ie n .IP "$retval = $item\->info(callback\-function)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->info(callback\-function)" 4
.IX Item "$retval = $item->info(callback-function)"
.SS "Querying (and setting) item attributes"
.IX Subsection "Querying (and setting) item attributes"
.PD 0
.ie n .IP "$state    = $item\->state" 4
.el .IP "\f(CW$state\fR    = \f(CW$item\fR\->state" 4
.IX Item "$state = $item->state"
.ie n .IP "$mode     = $item\->mode([newmode])" 4
.el .IP "\f(CW$mode\fR     = \f(CW$item\fR\->mode([newmode])" 4
.IX Item "$mode = $item->mode([newmode])"
.ie n .IP "$uudet    = $item\->uudet" 4
.el .IP "\f(CW$uudet\fR    = \f(CW$item\fR\->uudet" 4
.IX Item "$uudet = $item->uudet"
.ie n .IP "$size     = $item\->size" 4
.el .IP "\f(CW$size\fR     = \f(CW$item\fR\->size" 4
.IX Item "$size = $item->size"
.ie n .IP "$filename = $item\->filename([newfilename})" 4
.el .IP "\f(CW$filename\fR = \f(CW$item\fR\->filename([newfilename})" 4
.IX Item "$filename = $item->filename([newfilename})"
.ie n .IP "$subfname = $item\->subfname" 4
.el .IP "\f(CW$subfname\fR = \f(CW$item\fR\->subfname" 4
.IX Item "$subfname = $item->subfname"
.ie n .IP "$mimeid   = $item\->mimeid" 4
.el .IP "\f(CW$mimeid\fR   = \f(CW$item\fR\->mimeid" 4
.IX Item "$mimeid = $item->mimeid"
.ie n .IP "$mimetype = $item\->mimetype" 4
.el .IP "\f(CW$mimetype\fR = \f(CW$item\fR\->mimetype" 4
.IX Item "$mimetype = $item->mimetype"
.ie n .IP "$binfile  = $item\->binfile" 4
.el .IP "\f(CW$binfile\fR  = \f(CW$item\fR\->binfile" 4
.IX Item "$binfile = $item->binfile"
.PD
.SS "Information about source parts"
.IX Subsection "Information about source parts"
.ie n .IP "$parts = $item\->parts" 4
.el .IP "\f(CW$parts\fR = \f(CW$item\fR\->parts" 4
.IX Item "$parts = $item->parts"
Return information about all parts (source files) used to decode the file
as a list of hashrefs with the following structure:
.Sp
.Vb 11
\& {
\&   partno   => <integer describing the part number, starting with 1>,
\&   # the following member sonly exist when they contain useful information
\&   sfname   => <local pathname of the file where this part is from>,
\&   filename => <the ondisk filename of the decoded file>,
\&   subfname => <used to cluster postings, possibly the posting filename>,
\&   subject  => <the subject of the posting/mail>,
\&   origin   => <the possible source (From) address>,
\&   mimetype => <the possible mimetype of the decoded file>,
\&   mimeid   => <the id part of the Content\-Type>,
\& }
.Ve
.Sp
Usually you are interested mostly the \f(CW\*(C`sfname\*(C'\fR and possibly the \f(CW\*(C`partno\*(C'\fR
and \f(CW\*(C`filename\*(C'\fR members.
.SS "Functions below not documented and not very well tested"
.IX Subsection "Functions below not documented and not very well tested"
.Vb 7
\&  QuickDecode
\&  EncodeMulti
\&  EncodePartial
\&  EncodeToStream
\&  EncodeToFile
\&  E_PrepSingle
\&  E_PrepPartial
.Ve
.SS "\s-1EXTENSION FUNCTIONS\s0"
.IX Subsection "EXTENSION FUNCTIONS"
Functions found in this module but not documented in the uulib documentation:
.ie n .IP "$msg = straction ACT_xxx" 4
.el .IP "\f(CW$msg\fR = straction ACT_xxx" 4
.IX Item "$msg = straction ACT_xxx"
Return a human readable string representing the given action code.
.ie n .IP "$msg = strerror RET_xxx" 4
.el .IP "\f(CW$msg\fR = strerror RET_xxx" 4
.IX Item "$msg = strerror RET_xxx"
Return a human readable string representing the given error code.
.ie n .IP "$str = strencoding xxx_ENCODED" 4
.el .IP "\f(CW$str\fR = strencoding xxx_ENCODED" 4
.IX Item "$str = strencoding xxx_ENCODED"
Return the name of the encoding type as a string.
.ie n .IP "$str = strmsglevel MSG_xxx" 4
.el .IP "\f(CW$str\fR = strmsglevel MSG_xxx" 4
.IX Item "$str = strmsglevel MSG_xxx"
Returns the message level as a string.
.ie n .IP "SetFileNameCallback $cb" 4
.el .IP "SetFileNameCallback \f(CW$cb\fR" 4
.IX Item "SetFileNameCallback $cb"
Sets (or queries) the FileNameCallback, which is called whenever the
decoding library can't find a filename and wants to extract a filename
from the subject line of a posting. The callback will be called with
two arguments, the subject line and the current candidate for the
filename. The latter argument can be \f(CW\*(C`undef\*(C'\fR, which means that no
filename could be found (and likely no one exists, so it is safe to also
return \f(CW\*(C`undef\*(C'\fR in this case). If it doesn't return anything (not even
\&\f(CW\*(C`undef\*(C'\fR!), then nothing happens, so this is a no-op callback:
.Sp
.Vb 3
\&   sub cb {
\&      return ();
\&   }
.Ve
.Sp
If it returns \f(CW\*(C`undef\*(C'\fR, then this indicates that no filename could be
found. In all other cases, the return value is taken to be the filename.
.Sp
This is a slightly more useful callback:
.Sp
.Vb 8
\&  sub cb {
\&     return unless $_[1]; # skip "Re:"\-plies et al.
\&     my ($subject, $filename) = @_;
\&     # if we find some *.rar, take it
\&     return $1 if $subject =~ /(\ew+\e.rar)/;
\&     # otherwise just pass what we have
\&     return ();
\&  }
.Ve
.SH "LARGE EXAMPLE DECODER"
.IX Header "LARGE EXAMPLE DECODER"
This is the file \f(CW\*(C`example\-decoder\*(C'\fR from the distribution, put here
instead of more thorough documentation.
.PP
.Vb 1
\&   #!/usr/bin/perl
\&
\&   # decode all the files in the directory uusrc/ and copy
\&   # the resulting files to uudst/
\&
\&   use Convert::UUlib \*(Aq:all\*(Aq;
\&
\&   sub namefilter {
\&      my ($path) = @_;
\&
\&      $path=~s/^.*[\e/\e\e]//;
\&
\&      $path
\&   }
\&
\&   sub busycb {
\&      my ($action, $curfile, $partno, $numparts, $percent, $fsize) = @_;
\&      $_[0]=straction($action);
\&      print "busy_callback(", (join ",",@_), ")\en";
\&      0
\&   }
\&
\&   SetOption OPT_RBUF, 128*1024;
\&   SetOption OPT_WBUF, 1024*1024;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_VERBOSE, 1;
\&
\&   # show the three ways you can set callback functions. I normally
\&   # prefer the one with the sub inplace.
\&   SetFNameFilter \e&namefilter;
\&
\&   SetBusyCallback "busycb", 333;
\&
\&   SetMsgCallback sub {
\&      my ($msg, $level) = @_;
\&      print uc strmsglevel $_[1], ": $msg\en";
\&   };
\&
\&   # the following non\-trivial FileNameCallback takes care
\&   # of some subject lines not detected properly by uulib:
\&   SetFileNameCallback sub {
\&      return unless $_[1]; # skip "Re:"\-plies et al.
\&      local $_ = $_[0];
\&
\&      # the following rules are rather effective on some newsgroups,
\&      # like alt.binaries.games.anime, where non\-mime, uuencoded data
\&      # is very common
\&
\&      # if we find some *.rar, take it as the filename
\&      return $1 if /(\eS{3,}\e.(?:[rstuvwxyz]\ed\ed|rar))\es/i;
\&
\&      # one common subject format
\&      return $1 if /\- "(.{2,}?\e..+?)" (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- filename.par (04/55)
\&      return $1 if /\- "?(\eS{3,}\e.\eS+?)"? (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- (xxx) No. 1 sayuri81.jpg 756565 bytes
\&      # \- (20 files) No.17 Roseanne.jpg [2/2]
\&      return $1 if /No\e.[ 0\-9]+ (\eS+\e....) (?:\ed+ bytes )?\e[/;
\&
\&      # try to detect some common forms of filenames
\&      return $1 if /([a\-z0\-9_\e\-+.]{3,}\e.[a\-z]{3,4}(?:.\ed+))/i;
\&
\&      # otherwise just pass what we have
\&      ()
\&   };
\&
\&   # now read all files in the directory uusrc/*
\&   for(<uusrc/*>) {
\&      my ($retval, $count) = LoadFile ($_, $_, 1);
\&      print "file($_), status(", strerror $retval, ") parts($count)\en";
\&   }
\&
\&   SetOption OPT_SAVEPATH, "uudst/";
\&
\&   # now wade through all files and their source parts
\&   $i = 0;
\&   while ($uu = GetFileListItem $i) {
\&      $i++;
\&      print "file nr. $i";
\&      print " state ", $uu\->state;
\&      print " mode ", $uu\->mode;
\&      print " uudet ", strencoding $uu\->uudet;
\&      print " size ", $uu\->size;
\&      print " filename ", $uu\->filename;
\&      print " subfname ", $uu\->subfname;
\&      print " mimeid ", $uu\->mimeid;
\&      print " mimetype ", $uu\->mimetype;
\&      print "\en";
\&
\&      # print additional info about all parts
\&      for ($uu\->parts) {
\&         while (my ($k, $v) = each %$_) {
\&            print "$k > $v, ";
\&         }
\&         print "\en";
\&      }
\&
\&      print $uu\->filename;
\&
\&      $uu\->remove_temp;
\&
\&      if (my $err = $uu\->decode ()) {
\&         print ", ", strerror $err, "\en";
\&      } else {
\&         print ", saved as uudst/", $uu\->filename, "\en";
\&      }
\&   }
\&
\&   print "cleanup...\en";
\&
\&   CleanUp;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Marc Lehmann <schmorp@schmorp.de>, the original uulib library was written
by Frank Pilhofer <fp@informatik.uni\-frankfurt.de>, and later heavily
bugfixed by Marc Lehmann.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), uudeview homepage at http://www.uni\-frankfurt.de/~fp/uudeview/.
                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::UUlib5.16.3pm                       0100644 0001750 0001750 00000052031 12566241424 024357  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UUlib 3"
.TH UUlib 3 "2011-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::UUlib \- Perl interface to the uulib library (a.k.a. uudeview/uuenview).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::UUlib \*(Aq:all\*(Aq;
\& 
\& # read all the files named on the commandline and decode them
\& # into the CURRENT directory. See below for a longer example.
\& LoadFile $_ for @ARGV;
\& for (my $i = 0; my $uu = GetFileListItem $i; $i++) {
\&    if ($uu\->state & FILE_OK) {
\&      $uu\->decode;
\&      print $uu\->filename, "\en";
\&    }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read the file doc/library.pdf from the distribution for in-depth
information about the C\-library used in this interface, and the rest of
this document and especially the non-trivial decoder program at the end.
.SH "EXPORTED CONSTANTS"
.IX Header "EXPORTED CONSTANTS"
.SS "Action code constants"
.IX Subsection "Action code constants"
.Vb 5
\&  ACT_IDLE      we don\*(Aqt do anything
\&  ACT_SCANNING  scanning an input file
\&  ACT_DECODING  decoding into a temp file
\&  ACT_COPYING   copying temp to target
\&  ACT_ENCODING  encoding a file
.Ve
.SS "Message severity levels"
.IX Subsection "Message severity levels"
.Vb 6
\&  MSG_MESSAGE   just a message, nothing important
\&  MSG_NOTE      something that should be noticed
\&  MSG_WARNING   important msg, processing continues
\&  MSG_ERROR     processing has been terminated
\&  MSG_FATAL     decoder cannot process further requests
\&  MSG_PANIC     recovery impossible, app must terminate
.Ve
.SS "Options"
.IX Subsection "Options"
.Vb 10
\&  OPT_VERSION   version number MAJOR.MINORplPATCH (ro)
\&  OPT_FAST      assumes only one part per file
\&  OPT_DUMBNESS  switch off the program\*(Aqs intelligence
\&  OPT_BRACKPOL  give numbers in [] higher precendence
\&  OPT_VERBOSE   generate informative messages
\&  OPT_DESPERATE try to decode incomplete files
\&  OPT_IGNREPLY  ignore RE:plies (off by default)
\&  OPT_OVERWRITE whether it\*(Aqs OK to overwrite ex. files
\&  OPT_SAVEPATH  prefix to save\-files on disk
\&  OPT_IGNMODE   ignore the original file mode
\&  OPT_DEBUG     print messages with FILE/LINE info
\&  OPT_ERRNO     get last error code for RET_IOERR (ro)
\&  OPT_PROGRESS  retrieve progress information
\&  OPT_USETEXT   handle text messages
\&  OPT_PREAMB    handle Mime preambles/epilogues
\&  OPT_TINYB64   detect short B64 outside of Mime
\&  OPT_ENCEXT    extension for single\-part encoded files
\&  OPT_REMOVE    remove input files after decoding (dangerous)
\&  OPT_MOREMIME  strict MIME adherence
\&  OPT_DOTDOT    ".."\-unescaping has not yet been done on input files
\&  OPT_RBUF      set default read I/O buffer size in bytes
\&  OPT_WBUF      set default write I/O buffer size in bytes
\&  OPT_AUTOCHECK automatically check file list after every loadfile
.Ve
.SS "Result/Error codes"
.IX Subsection "Result/Error codes"
.Vb 10
\&  RET_OK        everything went fine
\&  RET_IOERR     I/O Error \- examine errno
\&  RET_NOMEM     not enough memory
\&  RET_ILLVAL    illegal value for operation
\&  RET_NODATA    decoder didn\*(Aqt find any data
\&  RET_NOEND     encoded data wasn\*(Aqt ended properly
\&  RET_UNSUP     unsupported function (encoding)
\&  RET_EXISTS    file exists (decoding)
\&  RET_CONT      continue \-\- special from ScanPart
\&  RET_CANCEL    operation canceled
.Ve
.SS "File States"
.IX Subsection "File States"
.Vb 1
\& This code is zero, i.e. "false":
\&
\&  UUFILE_READ   Read in, but not further processed
\&
\& The following state codes are or\*(Aqed together:
\&
\&  FILE_MISPART  Missing Part(s) detected
\&  FILE_NOBEGIN  No \*(Aqbegin\*(Aq found
\&  FILE_NOEND    No \*(Aqend\*(Aq found
\&  FILE_NODATA   File does not contain valid uudata
\&  FILE_OK       All Parts found, ready to decode
\&  FILE_ERROR    Error while decoding
\&  FILE_DECODED  Successfully decoded
\&  FILE_TMPFILE  Temporary decoded file exists
.Ve
.SS "Encoding types"
.IX Subsection "Encoding types"
.Vb 7
\&  UU_ENCODED    UUencoded data
\&  B64_ENCODED   Mime\-Base64 data
\&  XX_ENCODED    XXencoded data
\&  BH_ENCODED    Binhex encoded
\&  PT_ENCODED    Plain\-Text encoded (MIME)
\&  QP_ENCODED    Quoted\-Printable (MIME)
\&  YENC_ENCODED  yEnc encoded (non\-MIME)
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "Initializing and cleanup"
.IX Subsection "Initializing and cleanup"
Initialize is automatically called when the module is loaded and allocates
quite a small amount of memory for todays machines ;) CleanUp releases that
again.
.PP
On my machine, a fairly complete decode with \s-1DBI\s0 backend needs about 10MB
\&\s-1RSS\s0 to decode 20000 files.
.IP "Initialize" 4
.IX Item "Initialize"
Not normally necessary, (re\-)initializes the library.
.IP "CleanUp" 4
.IX Item "CleanUp"
Not normally necessary, could be called at the end to release memory
before starting a new decoding round.
.SS "Setting and querying options"
.IX Subsection "Setting and querying options"
.ie n .IP "$option = GetOption OPT_xxx" 4
.el .IP "\f(CW$option\fR = GetOption OPT_xxx" 4
.IX Item "$option = GetOption OPT_xxx"
.PD 0
.IP "SetOption OPT_xxx, opt-value" 4
.IX Item "SetOption OPT_xxx, opt-value"
.PD
.PP
See the \f(CW\*(C`OPT_xxx\*(C'\fR constants above to see which options exist.
.SS "Setting various callbacks"
.IX Subsection "Setting various callbacks"
.IP "SetMsgCallback [callback\-function]" 4
.IX Item "SetMsgCallback [callback-function]"
.PD 0
.IP "SetBusyCallback [callback\-function]" 4
.IX Item "SetBusyCallback [callback-function]"
.IP "SetFileCallback [callback\-function]" 4
.IX Item "SetFileCallback [callback-function]"
.IP "SetFNameFilter [callback\-function]" 4
.IX Item "SetFNameFilter [callback-function]"
.PD
.SS "Call the currently selected FNameFilter"
.IX Subsection "Call the currently selected FNameFilter"
.ie n .IP "$file = FNameFilter $file" 4
.el .IP "\f(CW$file\fR = FNameFilter \f(CW$file\fR" 4
.IX Item "$file = FNameFilter $file"
.SS "Loading sourcefiles, optionally fuzzy merge and start decoding"
.IX Subsection "Loading sourcefiles, optionally fuzzy merge and start decoding"
.PD 0
.ie n .IP "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]" 4
.el .IP "($retval, \f(CW$count\fR) = LoadFile \f(CW$fname\fR, [$id, [$delflag, [$partno]]]" 4
.IX Item "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]"
.PD
Load the given file and scan it for encoded contents. Optionally tag it
with the given id, and if \f(CW$delflag\fR is true, delete the file after it
is no longer necessary. If you are certain of the part number, you can
specify it as the last argument.
.Sp
A better (usually faster) way of doing this is using the \f(CW\*(C`SetFNameFilter\*(C'\fR
functionality.
.ie n .IP "$retval = Smerge $pass" 4
.el .IP "\f(CW$retval\fR = Smerge \f(CW$pass\fR" 4
.IX Item "$retval = Smerge $pass"
If you are desperate, try to call \f(CW\*(C`Smerge\*(C'\fR with increasing \f(CW$pass\fR
values, beginning at \f(CW0\fR, to try to merge parts that usually would not
have been merged.
.Sp
Most probably this will result in garbled files, so never do this by
default, except:
.Sp
If the \f(CW\*(C`OPT_AUTOCHECK\*(C'\fR option has been disabled (by default it is
enabled) to speed up file loading, then you \fIhave\fR to call \f(CW\*(C`Smerge \-1\*(C'\fR
after loading all files as an additional pre-pass (which is normally done
by \f(CW\*(C`LoadFile\*(C'\fR).
.ie n .IP "$item = GetFileListItem $item_number" 4
.el .IP "\f(CW$item\fR = GetFileListItem \f(CW$item_number\fR" 4
.IX Item "$item = GetFileListItem $item_number"
Return the \f(CW$item\fR structure for the \f(CW$item_number\fR'th found file, or
\&\f(CW\*(C`undef\*(C'\fR of no file with that number exists.
.Sp
The first file has number \f(CW0\fR, and the series has no holes, so you can
iterate over all files by starting with zero and incrementing until you
hit \f(CW\*(C`undef\*(C'\fR.
.SS "Decoding files"
.IX Subsection "Decoding files"
.ie n .IP "$retval = $item\->rename($newname)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->rename($newname)" 4
.IX Item "$retval = $item->rename($newname)"
Change the ondisk filename where the decoded file will be saved.
.ie n .IP "$retval = $item\->decode_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode_temp" 4
.IX Item "$retval = $item->decode_temp"
Decode the file into a temporary location, use \f(CW\*(C`$item\->infile\*(C'\fR to
retrieve the temporary filename.
.ie n .IP "$retval = $item\->remove_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->remove_temp" 4
.IX Item "$retval = $item->remove_temp"
Remove the temporarily decoded file again.
.ie n .IP "$retval = $item\->decode([$target_path])" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode([$target_path])" 4
.IX Item "$retval = $item->decode([$target_path])"
Decode the file to it's destination, or the given target path.
.ie n .IP "$retval = $item\->info(callback\-function)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->info(callback\-function)" 4
.IX Item "$retval = $item->info(callback-function)"
.SS "Querying (and setting) item attributes"
.IX Subsection "Querying (and setting) item attributes"
.PD 0
.ie n .IP "$state    = $item\->state" 4
.el .IP "\f(CW$state\fR    = \f(CW$item\fR\->state" 4
.IX Item "$state    = $item->state"
.ie n .IP "$mode     = $item\->mode([newmode])" 4
.el .IP "\f(CW$mode\fR     = \f(CW$item\fR\->mode([newmode])" 4
.IX Item "$mode     = $item->mode([newmode])"
.ie n .IP "$uudet    = $item\->uudet" 4
.el .IP "\f(CW$uudet\fR    = \f(CW$item\fR\->uudet" 4
.IX Item "$uudet    = $item->uudet"
.ie n .IP "$size     = $item\->size" 4
.el .IP "\f(CW$size\fR     = \f(CW$item\fR\->size" 4
.IX Item "$size     = $item->size"
.ie n .IP "$filename = $item\->filename([newfilename})" 4
.el .IP "\f(CW$filename\fR = \f(CW$item\fR\->filename([newfilename})" 4
.IX Item "$filename = $item->filename([newfilename})"
.ie n .IP "$subfname = $item\->subfname" 4
.el .IP "\f(CW$subfname\fR = \f(CW$item\fR\->subfname" 4
.IX Item "$subfname = $item->subfname"
.ie n .IP "$mimeid   = $item\->mimeid" 4
.el .IP "\f(CW$mimeid\fR   = \f(CW$item\fR\->mimeid" 4
.IX Item "$mimeid   = $item->mimeid"
.ie n .IP "$mimetype = $item\->mimetype" 4
.el .IP "\f(CW$mimetype\fR = \f(CW$item\fR\->mimetype" 4
.IX Item "$mimetype = $item->mimetype"
.ie n .IP "$binfile  = $item\->binfile" 4
.el .IP "\f(CW$binfile\fR  = \f(CW$item\fR\->binfile" 4
.IX Item "$binfile  = $item->binfile"
.PD
.SS "Information about source parts"
.IX Subsection "Information about source parts"
.ie n .IP "$parts = $item\->parts" 4
.el .IP "\f(CW$parts\fR = \f(CW$item\fR\->parts" 4
.IX Item "$parts = $item->parts"
Return information about all parts (source files) used to decode the file
as a list of hashrefs with the following structure:
.Sp
.Vb 11
\& {
\&   partno   => <integer describing the part number, starting with 1>,
\&   # the following member sonly exist when they contain useful information
\&   sfname   => <local pathname of the file where this part is from>,
\&   filename => <the ondisk filename of the decoded file>,
\&   subfname => <used to cluster postings, possibly the posting filename>,
\&   subject  => <the subject of the posting/mail>,
\&   origin   => <the possible source (From) address>,
\&   mimetype => <the possible mimetype of the decoded file>,
\&   mimeid   => <the id part of the Content\-Type>,
\& }
.Ve
.Sp
Usually you are interested mostly the \f(CW\*(C`sfname\*(C'\fR and possibly the \f(CW\*(C`partno\*(C'\fR
and \f(CW\*(C`filename\*(C'\fR members.
.SS "Functions below not documented and not very well tested"
.IX Subsection "Functions below not documented and not very well tested"
.Vb 7
\&  QuickDecode
\&  EncodeMulti
\&  EncodePartial
\&  EncodeToStream
\&  EncodeToFile
\&  E_PrepSingle
\&  E_PrepPartial
.Ve
.SS "\s-1EXTENSION\s0 \s-1FUNCTIONS\s0"
.IX Subsection "EXTENSION FUNCTIONS"
Functions found in this module but not documented in the uulib documentation:
.ie n .IP "$msg = straction ACT_xxx" 4
.el .IP "\f(CW$msg\fR = straction ACT_xxx" 4
.IX Item "$msg = straction ACT_xxx"
Return a human readable string representing the given action code.
.ie n .IP "$msg = strerror RET_xxx" 4
.el .IP "\f(CW$msg\fR = strerror RET_xxx" 4
.IX Item "$msg = strerror RET_xxx"
Return a human readable string representing the given error code.
.ie n .IP "$str = strencoding xxx_ENCODED" 4
.el .IP "\f(CW$str\fR = strencoding xxx_ENCODED" 4
.IX Item "$str = strencoding xxx_ENCODED"
Return the name of the encoding type as a string.
.ie n .IP "$str = strmsglevel MSG_xxx" 4
.el .IP "\f(CW$str\fR = strmsglevel MSG_xxx" 4
.IX Item "$str = strmsglevel MSG_xxx"
Returns the message level as a string.
.ie n .IP "SetFileNameCallback $cb" 4
.el .IP "SetFileNameCallback \f(CW$cb\fR" 4
.IX Item "SetFileNameCallback $cb"
Sets (or queries) the FileNameCallback, which is called whenever the
decoding library can't find a filename and wants to extract a filename
from the subject line of a posting. The callback will be called with
two arguments, the subject line and the current candidate for the
filename. The latter argument can be \f(CW\*(C`undef\*(C'\fR, which means that no
filename could be found (and likely no one exists, so it is safe to also
return \f(CW\*(C`undef\*(C'\fR in this case). If it doesn't return anything (not even
\&\f(CW\*(C`undef\*(C'\fR!), then nothing happens, so this is a no-op callback:
.Sp
.Vb 3
\&   sub cb {
\&      return ();
\&   }
.Ve
.Sp
If it returns \f(CW\*(C`undef\*(C'\fR, then this indicates that no filename could be
found. In all other cases, the return value is taken to be the filename.
.Sp
This is a slightly more useful callback:
.Sp
.Vb 8
\&  sub cb {
\&     return unless $_[1]; # skip "Re:"\-plies et al.
\&     my ($subject, $filename) = @_;
\&     # if we find some *.rar, take it
\&     return $1 if $subject =~ /(\ew+\e.rar)/;
\&     # otherwise just pass what we have
\&     return ();
\&  }
.Ve
.SH "LARGE EXAMPLE DECODER"
.IX Header "LARGE EXAMPLE DECODER"
This is the file \f(CW\*(C`example\-decoder\*(C'\fR from the distribution, put here
instead of more thorough documentation.
.PP
.Vb 1
\&   #!/usr/bin/perl
\&
\&   # decode all the files in the directory uusrc/ and copy
\&   # the resulting files to uudst/
\&
\&   use Convert::UUlib \*(Aq:all\*(Aq;
\&
\&   sub namefilter {
\&      my ($path) = @_;
\&
\&      $path=~s/^.*[\e/\e\e]//;
\&
\&      $path
\&   }
\&
\&   sub busycb {
\&      my ($action, $curfile, $partno, $numparts, $percent, $fsize) = @_;
\&      $_[0]=straction($action);
\&      print "busy_callback(", (join ",",@_), ")\en";
\&      0
\&   }
\&
\&   SetOption OPT_RBUF, 128*1024;
\&   SetOption OPT_WBUF, 1024*1024;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_VERBOSE, 1;
\&
\&   # show the three ways you can set callback functions. I normally
\&   # prefer the one with the sub inplace.
\&   SetFNameFilter \e&namefilter;
\&
\&   SetBusyCallback "busycb", 333;
\&
\&   SetMsgCallback sub {
\&      my ($msg, $level) = @_;
\&      print uc strmsglevel $_[1], ": $msg\en";
\&   };
\&
\&   # the following non\-trivial FileNameCallback takes care
\&   # of some subject lines not detected properly by uulib:
\&   SetFileNameCallback sub {
\&      return unless $_[1]; # skip "Re:"\-plies et al.
\&      local $_ = $_[0];
\&
\&      # the following rules are rather effective on some newsgroups,
\&      # like alt.binaries.games.anime, where non\-mime, uuencoded data
\&      # is very common
\&
\&      # if we find some *.rar, take it as the filename
\&      return $1 if /(\eS{3,}\e.(?:[rstuvwxyz]\ed\ed|rar))\es/i;
\&
\&      # one common subject format
\&      return $1 if /\- "(.{2,}?\e..+?)" (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- filename.par (04/55)
\&      return $1 if /\- "?(\eS{3,}\e.\eS+?)"? (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- (xxx) No. 1 sayuri81.jpg 756565 bytes
\&      # \- (20 files) No.17 Roseanne.jpg [2/2]
\&      return $1 if /No\e.[ 0\-9]+ (\eS+\e....) (?:\ed+ bytes )?\e[/;
\&
\&      # try to detect some common forms of filenames
\&      return $1 if /([a\-z0\-9_\e\-+.]{3,}\e.[a\-z]{3,4}(?:.\ed+))/i;
\&
\&      # otherwise just pass what we have
\&      ()
\&   };
\&
\&   # now read all files in the directory uusrc/*
\&   for(<uusrc/*>) {
\&      my ($retval, $count) = LoadFile ($_, $_, 1);
\&      print "file($_), status(", strerror $retval, ") parts($count)\en";
\&   }
\&
\&   SetOption OPT_SAVEPATH, "uudst/";
\&
\&   # now wade through all files and their source parts
\&   $i = 0;
\&   while ($uu = GetFileListItem $i) {
\&      $i++;
\&      print "file nr. $i";
\&      print " state ", $uu\->state;
\&      print " mode ", $uu\->mode;
\&      print " uudet ", strencoding $uu\->uudet;
\&      print " size ", $uu\->size;
\&      print " filename ", $uu\->filename;
\&      print " subfname ", $uu\->subfname;
\&      print " mimeid ", $uu\->mimeid;
\&      print " mimetype ", $uu\->mimetype;
\&      print "\en";
\&
\&      # print additional info about all parts
\&      for ($uu\->parts) {
\&         while (my ($k, $v) = each %$_) {
\&            print "$k > $v, ";
\&         }
\&         print "\en";
\&      }
\&
\&      print $uu\->filename;
\&
\&      $uu\->remove_temp;
\&
\&      if (my $err = $uu\->decode ()) {
\&         print ", ", strerror $err, "\en";
\&      } else {
\&         print ", saved as uudst/", $uu\->filename, "\en";
\&      }
\&   }
\&
\&   print "cleanup...\en";
\&
\&   CleanUp;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Marc Lehmann <schmorp@schmorp.de>, the original uulib library was written
by Frank Pilhofer <fp@informatik.uni\-frankfurt.de>, and later heavily
bugfixed by Marc Lehmann.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), uudeview homepage at http://www.uni\-frankfurt.de/~fp/uudeview/.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Convert::UUlib5.18.3pm                       0100644 0001750 0001750 00000052322 12566241425 024365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UUlib 3"
.TH UUlib 3 "2011-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::UUlib \- Perl interface to the uulib library (a.k.a. uudeview/uuenview).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Convert::UUlib \*(Aq:all\*(Aq;
\& 
\& # read all the files named on the commandline and decode them
\& # into the CURRENT directory. See below for a longer example.
\& LoadFile $_ for @ARGV;
\& for (my $i = 0; my $uu = GetFileListItem $i; $i++) {
\&    if ($uu\->state & FILE_OK) {
\&      $uu\->decode;
\&      print $uu\->filename, "\en";
\&    }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read the file doc/library.pdf from the distribution for in-depth
information about the C\-library used in this interface, and the rest of
this document and especially the non-trivial decoder program at the end.
.SH "EXPORTED CONSTANTS"
.IX Header "EXPORTED CONSTANTS"
.SS "Action code constants"
.IX Subsection "Action code constants"
.Vb 5
\&  ACT_IDLE      we don\*(Aqt do anything
\&  ACT_SCANNING  scanning an input file
\&  ACT_DECODING  decoding into a temp file
\&  ACT_COPYING   copying temp to target
\&  ACT_ENCODING  encoding a file
.Ve
.SS "Message severity levels"
.IX Subsection "Message severity levels"
.Vb 6
\&  MSG_MESSAGE   just a message, nothing important
\&  MSG_NOTE      something that should be noticed
\&  MSG_WARNING   important msg, processing continues
\&  MSG_ERROR     processing has been terminated
\&  MSG_FATAL     decoder cannot process further requests
\&  MSG_PANIC     recovery impossible, app must terminate
.Ve
.SS "Options"
.IX Subsection "Options"
.Vb 10
\&  OPT_VERSION   version number MAJOR.MINORplPATCH (ro)
\&  OPT_FAST      assumes only one part per file
\&  OPT_DUMBNESS  switch off the program\*(Aqs intelligence
\&  OPT_BRACKPOL  give numbers in [] higher precendence
\&  OPT_VERBOSE   generate informative messages
\&  OPT_DESPERATE try to decode incomplete files
\&  OPT_IGNREPLY  ignore RE:plies (off by default)
\&  OPT_OVERWRITE whether it\*(Aqs OK to overwrite ex. files
\&  OPT_SAVEPATH  prefix to save\-files on disk
\&  OPT_IGNMODE   ignore the original file mode
\&  OPT_DEBUG     print messages with FILE/LINE info
\&  OPT_ERRNO     get last error code for RET_IOERR (ro)
\&  OPT_PROGRESS  retrieve progress information
\&  OPT_USETEXT   handle text messages
\&  OPT_PREAMB    handle Mime preambles/epilogues
\&  OPT_TINYB64   detect short B64 outside of Mime
\&  OPT_ENCEXT    extension for single\-part encoded files
\&  OPT_REMOVE    remove input files after decoding (dangerous)
\&  OPT_MOREMIME  strict MIME adherence
\&  OPT_DOTDOT    ".."\-unescaping has not yet been done on input files
\&  OPT_RBUF      set default read I/O buffer size in bytes
\&  OPT_WBUF      set default write I/O buffer size in bytes
\&  OPT_AUTOCHECK automatically check file list after every loadfile
.Ve
.SS "Result/Error codes"
.IX Subsection "Result/Error codes"
.Vb 10
\&  RET_OK        everything went fine
\&  RET_IOERR     I/O Error \- examine errno
\&  RET_NOMEM     not enough memory
\&  RET_ILLVAL    illegal value for operation
\&  RET_NODATA    decoder didn\*(Aqt find any data
\&  RET_NOEND     encoded data wasn\*(Aqt ended properly
\&  RET_UNSUP     unsupported function (encoding)
\&  RET_EXISTS    file exists (decoding)
\&  RET_CONT      continue \-\- special from ScanPart
\&  RET_CANCEL    operation canceled
.Ve
.SS "File States"
.IX Subsection "File States"
.Vb 1
\& This code is zero, i.e. "false":
\&
\&  UUFILE_READ   Read in, but not further processed
\&
\& The following state codes are or\*(Aqed together:
\&
\&  FILE_MISPART  Missing Part(s) detected
\&  FILE_NOBEGIN  No \*(Aqbegin\*(Aq found
\&  FILE_NOEND    No \*(Aqend\*(Aq found
\&  FILE_NODATA   File does not contain valid uudata
\&  FILE_OK       All Parts found, ready to decode
\&  FILE_ERROR    Error while decoding
\&  FILE_DECODED  Successfully decoded
\&  FILE_TMPFILE  Temporary decoded file exists
.Ve
.SS "Encoding types"
.IX Subsection "Encoding types"
.Vb 7
\&  UU_ENCODED    UUencoded data
\&  B64_ENCODED   Mime\-Base64 data
\&  XX_ENCODED    XXencoded data
\&  BH_ENCODED    Binhex encoded
\&  PT_ENCODED    Plain\-Text encoded (MIME)
\&  QP_ENCODED    Quoted\-Printable (MIME)
\&  YENC_ENCODED  yEnc encoded (non\-MIME)
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "Initializing and cleanup"
.IX Subsection "Initializing and cleanup"
Initialize is automatically called when the module is loaded and allocates
quite a small amount of memory for todays machines ;) CleanUp releases that
again.
.PP
On my machine, a fairly complete decode with \s-1DBI\s0 backend needs about 10MB
\&\s-1RSS\s0 to decode 20000 files.
.IP "Initialize" 4
.IX Item "Initialize"
Not normally necessary, (re\-)initializes the library.
.IP "CleanUp" 4
.IX Item "CleanUp"
Not normally necessary, could be called at the end to release memory
before starting a new decoding round.
.SS "Setting and querying options"
.IX Subsection "Setting and querying options"
.ie n .IP "$option = GetOption OPT_xxx" 4
.el .IP "\f(CW$option\fR = GetOption OPT_xxx" 4
.IX Item "$option = GetOption OPT_xxx"
.PD 0
.IP "SetOption OPT_xxx, opt-value" 4
.IX Item "SetOption OPT_xxx, opt-value"
.PD
.PP
See the \f(CW\*(C`OPT_xxx\*(C'\fR constants above to see which options exist.
.SS "Setting various callbacks"
.IX Subsection "Setting various callbacks"
.IP "SetMsgCallback [callback\-function]" 4
.IX Item "SetMsgCallback [callback-function]"
.PD 0
.IP "SetBusyCallback [callback\-function]" 4
.IX Item "SetBusyCallback [callback-function]"
.IP "SetFileCallback [callback\-function]" 4
.IX Item "SetFileCallback [callback-function]"
.IP "SetFNameFilter [callback\-function]" 4
.IX Item "SetFNameFilter [callback-function]"
.PD
.SS "Call the currently selected FNameFilter"
.IX Subsection "Call the currently selected FNameFilter"
.ie n .IP "$file = FNameFilter $file" 4
.el .IP "\f(CW$file\fR = FNameFilter \f(CW$file\fR" 4
.IX Item "$file = FNameFilter $file"
.SS "Loading sourcefiles, optionally fuzzy merge and start decoding"
.IX Subsection "Loading sourcefiles, optionally fuzzy merge and start decoding"
.PD 0
.ie n .IP "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]" 4
.el .IP "($retval, \f(CW$count\fR) = LoadFile \f(CW$fname\fR, [$id, [$delflag, [$partno]]]" 4
.IX Item "($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]"
.PD
Load the given file and scan it for encoded contents. Optionally tag it
with the given id, and if \f(CW$delflag\fR is true, delete the file after it
is no longer necessary. If you are certain of the part number, you can
specify it as the last argument.
.Sp
A better (usually faster) way of doing this is using the \f(CW\*(C`SetFNameFilter\*(C'\fR
functionality.
.ie n .IP "$retval = Smerge $pass" 4
.el .IP "\f(CW$retval\fR = Smerge \f(CW$pass\fR" 4
.IX Item "$retval = Smerge $pass"
If you are desperate, try to call \f(CW\*(C`Smerge\*(C'\fR with increasing \f(CW$pass\fR
values, beginning at \f(CW0\fR, to try to merge parts that usually would not
have been merged.
.Sp
Most probably this will result in garbled files, so never do this by
default, except:
.Sp
If the \f(CW\*(C`OPT_AUTOCHECK\*(C'\fR option has been disabled (by default it is
enabled) to speed up file loading, then you \fIhave\fR to call \f(CW\*(C`Smerge \-1\*(C'\fR
after loading all files as an additional pre-pass (which is normally done
by \f(CW\*(C`LoadFile\*(C'\fR).
.ie n .IP "$item = GetFileListItem $item_number" 4
.el .IP "\f(CW$item\fR = GetFileListItem \f(CW$item_number\fR" 4
.IX Item "$item = GetFileListItem $item_number"
Return the \f(CW$item\fR structure for the \f(CW$item_number\fR'th found file, or
\&\f(CW\*(C`undef\*(C'\fR of no file with that number exists.
.Sp
The first file has number \f(CW0\fR, and the series has no holes, so you can
iterate over all files by starting with zero and incrementing until you
hit \f(CW\*(C`undef\*(C'\fR.
.SS "Decoding files"
.IX Subsection "Decoding files"
.ie n .IP "$retval = $item\->rename($newname)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->rename($newname)" 4
.IX Item "$retval = $item->rename($newname)"
Change the ondisk filename where the decoded file will be saved.
.ie n .IP "$retval = $item\->decode_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode_temp" 4
.IX Item "$retval = $item->decode_temp"
Decode the file into a temporary location, use \f(CW\*(C`$item\->infile\*(C'\fR to
retrieve the temporary filename.
.ie n .IP "$retval = $item\->remove_temp" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->remove_temp" 4
.IX Item "$retval = $item->remove_temp"
Remove the temporarily decoded file again.
.ie n .IP "$retval = $item\->decode([$target_path])" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->decode([$target_path])" 4
.IX Item "$retval = $item->decode([$target_path])"
Decode the file to it's destination, or the given target path.
.ie n .IP "$retval = $item\->info(callback\-function)" 4
.el .IP "\f(CW$retval\fR = \f(CW$item\fR\->info(callback\-function)" 4
.IX Item "$retval = $item->info(callback-function)"
.SS "Querying (and setting) item attributes"
.IX Subsection "Querying (and setting) item attributes"
.PD 0
.ie n .IP "$state    = $item\->state" 4
.el .IP "\f(CW$state\fR    = \f(CW$item\fR\->state" 4
.IX Item "$state = $item->state"
.ie n .IP "$mode     = $item\->mode([newmode])" 4
.el .IP "\f(CW$mode\fR     = \f(CW$item\fR\->mode([newmode])" 4
.IX Item "$mode = $item->mode([newmode])"
.ie n .IP "$uudet    = $item\->uudet" 4
.el .IP "\f(CW$uudet\fR    = \f(CW$item\fR\->uudet" 4
.IX Item "$uudet = $item->uudet"
.ie n .IP "$size     = $item\->size" 4
.el .IP "\f(CW$size\fR     = \f(CW$item\fR\->size" 4
.IX Item "$size = $item->size"
.ie n .IP "$filename = $item\->filename([newfilename})" 4
.el .IP "\f(CW$filename\fR = \f(CW$item\fR\->filename([newfilename})" 4
.IX Item "$filename = $item->filename([newfilename})"
.ie n .IP "$subfname = $item\->subfname" 4
.el .IP "\f(CW$subfname\fR = \f(CW$item\fR\->subfname" 4
.IX Item "$subfname = $item->subfname"
.ie n .IP "$mimeid   = $item\->mimeid" 4
.el .IP "\f(CW$mimeid\fR   = \f(CW$item\fR\->mimeid" 4
.IX Item "$mimeid = $item->mimeid"
.ie n .IP "$mimetype = $item\->mimetype" 4
.el .IP "\f(CW$mimetype\fR = \f(CW$item\fR\->mimetype" 4
.IX Item "$mimetype = $item->mimetype"
.ie n .IP "$binfile  = $item\->binfile" 4
.el .IP "\f(CW$binfile\fR  = \f(CW$item\fR\->binfile" 4
.IX Item "$binfile = $item->binfile"
.PD
.SS "Information about source parts"
.IX Subsection "Information about source parts"
.ie n .IP "$parts = $item\->parts" 4
.el .IP "\f(CW$parts\fR = \f(CW$item\fR\->parts" 4
.IX Item "$parts = $item->parts"
Return information about all parts (source files) used to decode the file
as a list of hashrefs with the following structure:
.Sp
.Vb 11
\& {
\&   partno   => <integer describing the part number, starting with 1>,
\&   # the following member sonly exist when they contain useful information
\&   sfname   => <local pathname of the file where this part is from>,
\&   filename => <the ondisk filename of the decoded file>,
\&   subfname => <used to cluster postings, possibly the posting filename>,
\&   subject  => <the subject of the posting/mail>,
\&   origin   => <the possible source (From) address>,
\&   mimetype => <the possible mimetype of the decoded file>,
\&   mimeid   => <the id part of the Content\-Type>,
\& }
.Ve
.Sp
Usually you are interested mostly the \f(CW\*(C`sfname\*(C'\fR and possibly the \f(CW\*(C`partno\*(C'\fR
and \f(CW\*(C`filename\*(C'\fR members.
.SS "Functions below not documented and not very well tested"
.IX Subsection "Functions below not documented and not very well tested"
.Vb 7
\&  QuickDecode
\&  EncodeMulti
\&  EncodePartial
\&  EncodeToStream
\&  EncodeToFile
\&  E_PrepSingle
\&  E_PrepPartial
.Ve
.SS "\s-1EXTENSION FUNCTIONS\s0"
.IX Subsection "EXTENSION FUNCTIONS"
Functions found in this module but not documented in the uulib documentation:
.ie n .IP "$msg = straction ACT_xxx" 4
.el .IP "\f(CW$msg\fR = straction ACT_xxx" 4
.IX Item "$msg = straction ACT_xxx"
Return a human readable string representing the given action code.
.ie n .IP "$msg = strerror RET_xxx" 4
.el .IP "\f(CW$msg\fR = strerror RET_xxx" 4
.IX Item "$msg = strerror RET_xxx"
Return a human readable string representing the given error code.
.ie n .IP "$str = strencoding xxx_ENCODED" 4
.el .IP "\f(CW$str\fR = strencoding xxx_ENCODED" 4
.IX Item "$str = strencoding xxx_ENCODED"
Return the name of the encoding type as a string.
.ie n .IP "$str = strmsglevel MSG_xxx" 4
.el .IP "\f(CW$str\fR = strmsglevel MSG_xxx" 4
.IX Item "$str = strmsglevel MSG_xxx"
Returns the message level as a string.
.ie n .IP "SetFileNameCallback $cb" 4
.el .IP "SetFileNameCallback \f(CW$cb\fR" 4
.IX Item "SetFileNameCallback $cb"
Sets (or queries) the FileNameCallback, which is called whenever the
decoding library can't find a filename and wants to extract a filename
from the subject line of a posting. The callback will be called with
two arguments, the subject line and the current candidate for the
filename. The latter argument can be \f(CW\*(C`undef\*(C'\fR, which means that no
filename could be found (and likely no one exists, so it is safe to also
return \f(CW\*(C`undef\*(C'\fR in this case). If it doesn't return anything (not even
\&\f(CW\*(C`undef\*(C'\fR!), then nothing happens, so this is a no-op callback:
.Sp
.Vb 3
\&   sub cb {
\&      return ();
\&   }
.Ve
.Sp
If it returns \f(CW\*(C`undef\*(C'\fR, then this indicates that no filename could be
found. In all other cases, the return value is taken to be the filename.
.Sp
This is a slightly more useful callback:
.Sp
.Vb 8
\&  sub cb {
\&     return unless $_[1]; # skip "Re:"\-plies et al.
\&     my ($subject, $filename) = @_;
\&     # if we find some *.rar, take it
\&     return $1 if $subject =~ /(\ew+\e.rar)/;
\&     # otherwise just pass what we have
\&     return ();
\&  }
.Ve
.SH "LARGE EXAMPLE DECODER"
.IX Header "LARGE EXAMPLE DECODER"
This is the file \f(CW\*(C`example\-decoder\*(C'\fR from the distribution, put here
instead of more thorough documentation.
.PP
.Vb 1
\&   #!/usr/bin/perl
\&
\&   # decode all the files in the directory uusrc/ and copy
\&   # the resulting files to uudst/
\&
\&   use Convert::UUlib \*(Aq:all\*(Aq;
\&
\&   sub namefilter {
\&      my ($path) = @_;
\&
\&      $path=~s/^.*[\e/\e\e]//;
\&
\&      $path
\&   }
\&
\&   sub busycb {
\&      my ($action, $curfile, $partno, $numparts, $percent, $fsize) = @_;
\&      $_[0]=straction($action);
\&      print "busy_callback(", (join ",",@_), ")\en";
\&      0
\&   }
\&
\&   SetOption OPT_RBUF, 128*1024;
\&   SetOption OPT_WBUF, 1024*1024;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_IGNMODE, 1;
\&   SetOption OPT_VERBOSE, 1;
\&
\&   # show the three ways you can set callback functions. I normally
\&   # prefer the one with the sub inplace.
\&   SetFNameFilter \e&namefilter;
\&
\&   SetBusyCallback "busycb", 333;
\&
\&   SetMsgCallback sub {
\&      my ($msg, $level) = @_;
\&      print uc strmsglevel $_[1], ": $msg\en";
\&   };
\&
\&   # the following non\-trivial FileNameCallback takes care
\&   # of some subject lines not detected properly by uulib:
\&   SetFileNameCallback sub {
\&      return unless $_[1]; # skip "Re:"\-plies et al.
\&      local $_ = $_[0];
\&
\&      # the following rules are rather effective on some newsgroups,
\&      # like alt.binaries.games.anime, where non\-mime, uuencoded data
\&      # is very common
\&
\&      # if we find some *.rar, take it as the filename
\&      return $1 if /(\eS{3,}\e.(?:[rstuvwxyz]\ed\ed|rar))\es/i;
\&
\&      # one common subject format
\&      return $1 if /\- "(.{2,}?\e..+?)" (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- filename.par (04/55)
\&      return $1 if /\- "?(\eS{3,}\e.\eS+?)"? (?:yenc )?\e(\ed+\e/\ed+\e)/i;
\&
\&      # \- (xxx) No. 1 sayuri81.jpg 756565 bytes
\&      # \- (20 files) No.17 Roseanne.jpg [2/2]
\&      return $1 if /No\e.[ 0\-9]+ (\eS+\e....) (?:\ed+ bytes )?\e[/;
\&
\&      # try to detect some common forms of filenames
\&      return $1 if /([a\-z0\-9_\e\-+.]{3,}\e.[a\-z]{3,4}(?:.\ed+))/i;
\&
\&      # otherwise just pass what we have
\&      ()
\&   };
\&
\&   # now read all files in the directory uusrc/*
\&   for(<uusrc/*>) {
\&      my ($retval, $count) = LoadFile ($_, $_, 1);
\&      print "file($_), status(", strerror $retval, ") parts($count)\en";
\&   }
\&
\&   SetOption OPT_SAVEPATH, "uudst/";
\&
\&   # now wade through all files and their source parts
\&   $i = 0;
\&   while ($uu = GetFileListItem $i) {
\&      $i++;
\&      print "file nr. $i";
\&      print " state ", $uu\->state;
\&      print " mode ", $uu\->mode;
\&      print " uudet ", strencoding $uu\->uudet;
\&      print " size ", $uu\->size;
\&      print " filename ", $uu\->filename;
\&      print " subfname ", $uu\->subfname;
\&      print " mimeid ", $uu\->mimeid;
\&      print " mimetype ", $uu\->mimetype;
\&      print "\en";
\&
\&      # print additional info about all parts
\&      for ($uu\->parts) {
\&         while (my ($k, $v) = each %$_) {
\&            print "$k > $v, ";
\&         }
\&         print "\en";
\&      }
\&
\&      print $uu\->filename;
\&
\&      $uu\->remove_temp;
\&
\&      if (my $err = $uu\->decode ()) {
\&         print ", ", strerror $err, "\en";
\&      } else {
\&         print ", saved as uudst/", $uu\->filename, "\en";
\&      }
\&   }
\&
\&   print "cleanup...\en";
\&
\&   CleanUp;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Marc Lehmann <schmorp@schmorp.de>, the original uulib library was written
by Frank Pilhofer <fp@informatik.uni\-frankfurt.de>, and later heavily
bugfixed by Marc Lehmann.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), uudeview homepage at http://www.uni\-frankfurt.de/~fp/uudeview/.
                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::RSA.3pm                      0100644 0001750 0001750 00000030656 12566242056 024536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA 3"
.TH RSA 3 "2011-08-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Crypt::OpenSSL::Random;
\&  use Crypt::OpenSSL::RSA;
\&
\&  # not necessary if we have /dev/random:
\&  Crypt::OpenSSL::Random::random_seed($good_entropy);
\&  Crypt::OpenSSL::RSA\->import_random_seed();
\&  $rsa_pub = Crypt::OpenSSL::RSA\->new_public_key($key_string);
\&  $rsa_pub\->use_sslv23_padding(); # use_pkcs1_oaep_padding is the default
\&  $ciphertext = $rsa\->encrypt($plaintext);
\&
\&  $rsa_priv = Crypt::OpenSSL::RSA\->new_private_key($key_string);
\&  $plaintext = $rsa\->encrypt($ciphertext);
\&
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024); # or
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024, $prime);
\&
\&  print "private key is:\en", $rsa\->get_private_key_string();
\&  print "public key (in PKCS1 format) is:\en",
\&        $rsa\->get_public_key_string();
\&  print "public key (in X509 format) is:\en",
\&        $rsa\->get_public_key_x509_string();
\&
\&  $rsa_priv\->use_md5_hash(); # use_sha1_hash is the default
\&  $signature = $rsa_priv\->sign($plaintext);
\&  print "Signed correctly\en" if ($rsa\->verify($plaintext, $signature));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::RSA provides the ability to \s-1RSA\s0 encrypt strings which are
somewhat shorter than the block size of a key.  It also allows for decryption,
signatures and signature verification.
.PP
\&\fI\s-1NOTE\s0\fR: Many of the methods in this package can croak, so use eval, or
Error.pm's try/catch mechanism to capture errors.  Also, while some
methods from earlier versions of this package return true on success,
this (never documented) behavior is no longer the case.
.SH "Class Methods"
.IX Header "Class Methods"
.IP "new_public_key" 4
.IX Item "new_public_key"
Create a new Crypt::OpenSSL::RSA object by loading a public key in
from a string containing Base64/DER\-encoding of either the \s-1PKCS1\s0 or
X.509 representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.
.Sp
The padding is set to \s-1PKCS1_OAEP,\s0 but can be changed with the
use_xxx_padding methods
.IP "new_private_key" 4
.IX Item "new_private_key"
Create a new Crypt::OpenSSL::RSA object by loading a private key in
from an string containing the Base64/DER encoding of the \s-1PKCS1\s0
representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding.
.IP "generate_key" 4
.IX Item "generate_key"
Create a new Crypt::OpenSSL::RSA object by constructing a
private/public key pair.  The first (mandetory) argument is the key
size, while the second optional argument specifies the public exponent
(the default public exponent is 65537).  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding methods.
.IP "new_key_from_parameters" 4
.IX Item "new_key_from_parameters"
Given Crypt::OpenSSL::Bignum objects for n, e, and optionally d, p,
and q, where p and q are the prime factors of n, e is the public
exponent and d is the private exponent, create a new
Crypt::OpenSSL::RSA object using these values.  If p and q are
provided and d is undef, d is computed.  Note that while p and q are
not necessary for a private key, their presence will speed up
computation.
.IP "import_random_seed" 4
.IX Item "import_random_seed"
Import a random seed from Crypt::OpenSSL::Random, since the OpenSSL
libraries won't allow sharing of random structures across perl \s-1XS\s0
modules.
.SH "Instance Methods"
.IX Header "Instance Methods"
.IP "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
Clean up after ourselves.  In particular, erase and free the memory
occupied by the \s-1RSA\s0 key structure.
.IP "get_public_key_string" 4
.IX Item "get_public_key_string"
Return the Base64/DER\-encoded \s-1PKCS1\s0 representation of the public
key.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN RSA PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END RSA PUBLIC KEY\-\-\-\-\-\-
.Ve
.IP "get_public_key_x509_string" 4
.IX Item "get_public_key_x509_string"
Return the Base64/DER\-encoded representation of the \*(L"subject
public key\*(R", suitable for use in X509 certificates.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\-
.Ve
.Sp
and is the format that is produced by running \f(CW\*(C`openssl rsa \-pubout\*(C'\fR.
.IP "get_private_key_string" 4
.IX Item "get_private_key_string"
Return the DER-encoded \s-1PKCS1\s0 representation of the private key.
.IP "encrypt" 4
.IX Item "encrypt"
Encrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "decrypt" 4
.IX Item "decrypt"
Decrypt a binary \*(L"string\*(R".  Croaks if the key is public only.
.IP "private_encrypt" 4
.IX Item "private_encrypt"
Encrypt a binary \*(L"string\*(R" using the private key.  Croaks if the key is
public only.
.IP "public_decrypt" 4
.IX Item "public_decrypt"
Decrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "sign" 4
.IX Item "sign"
Sign a string using the secret (portion of the) key.
.IP "verify" 4
.IX Item "verify"
Check the signature on a text.
.IP "use_no_padding" 4
.IX Item "use_no_padding"
Use raw \s-1RSA\s0 encryption. This mode should only be used to implement
cryptographically sound padding modes in the application code.
Encrypting user data directly with \s-1RSA\s0 is insecure.
.IP "use_pkcs1_padding" 4
.IX Item "use_pkcs1_padding"
Use \s-1PKCS\s0 #1 v1.5 padding. This currently is the most widely used mode
of padding.
.IP "use_pkcs1_oaep_padding" 4
.IX Item "use_pkcs1_oaep_padding"
Use EME-OAEP padding as defined in \s-1PKCS\s0 #1 v2.0 with \s-1SHA\-1, MGF1\s0 and
an empty encoding parameter. This mode of padding is recommended for
all new applications.  It is the default mode used by
Crypt::OpenSSL::RSA.
.IP "use_sslv23_padding" 4
.IX Item "use_sslv23_padding"
Use \s-1PKCS\s0 #1 v1.5 padding with an SSL-specific modification that
denotes that the server is \s-1SSL3\s0 capable.
.IP "use_md5_hash" 4
.IX Item "use_md5_hash"
Use the \s-1RFC 1321 MD5\s0 hashing algorithm by Ron Rivest when signing and
verifying messages.
.IP "use_sha1_hash" 4
.IX Item "use_sha1_hash"
Use the \s-1RFC 3174\s0 Secure Hashing Algorithm (\s-1FIPS 180\-1\s0) when signing
and verifying messages. This is the default.
.IP "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash" 4
.IX Item "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash"
These \s-1FIPS 180\-2\s0 hash algorithms, for use when signing and verifying
messages, are only available with newer openssl versions (>= 0.9.8).
.IP "use_ripemd160_hash" 4
.IX Item "use_ripemd160_hash"
Dobbertin, Bosselaers and Preneel's \s-1RIPEMD\s0 hashing algorithm when
signing and verifying messages.
.IP "size" 4
.IX Item "size"
Returns the size, in bytes, of the key.  All encrypted text will be of
this size, and depending on the padding mode used, the length of
the text to be encrypted should be:
.RS 4
.IP "pkcs1_oaep_padding" 4
.IX Item "pkcs1_oaep_padding"
at most 42 bytes less than this size.
.IP "pkcs1_padding or sslv23_padding" 4
.IX Item "pkcs1_padding or sslv23_padding"
at most 11 bytes less than this size.
.IP "no_padding" 4
.IX Item "no_padding"
exactly this size.
.RE
.RS 4
.RE
.IP "check_key" 4
.IX Item "check_key"
This function validates the \s-1RSA\s0 key, returning a true value if the key
is valid, and a false value otherwise.  Croaks if the key is public only.
.IP "get_key_parameters" 4
.IX Item "get_key_parameters"
Return Crypt::OpenSSL::Bignum objects representing the values of n, e,
d, p, q, d mod (p\-1), d mod (q\-1), and 1/q mod p, where p and q are
the prime factors of n, e is the public exponent and d is the private
exponent.  Some of these values may return as undef; only n and e will
be defined for a public key.  The Crypt::OpenSSL::Bignum module must
be installed for this to work.
.IP "is_private" 4
.IX Item "is_private"
Return true if this is a private key, and false if it is private only.
.SH "BUGS"
.IX Header "BUGS"
There is a small memory leak when generating new keys of more than 512 bits.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.org.  For support, please email
perl\-openssl\-users@lists.sourceforge.net.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fICrypt::OpenSSL::Random\fR\|(3), \fICrypt::OpenSSL::Bignum\fR\|(3),
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3), \fIRSA_public_encrypt\fR\|(3), \fIRSA_size\fR\|(3),
\&\fIRSA_generate_key\fR\|(3), \fIRSA_check_key\fR\|(3)
                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::RSA5.16.3pm                  0100644 0001750 0001750 00000030353 12566242070 025036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA 3"
.TH RSA 3 "2011-08-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Crypt::OpenSSL::Random;
\&  use Crypt::OpenSSL::RSA;
\&
\&  # not necessary if we have /dev/random:
\&  Crypt::OpenSSL::Random::random_seed($good_entropy);
\&  Crypt::OpenSSL::RSA\->import_random_seed();
\&  $rsa_pub = Crypt::OpenSSL::RSA\->new_public_key($key_string);
\&  $rsa_pub\->use_sslv23_padding(); # use_pkcs1_oaep_padding is the default
\&  $ciphertext = $rsa\->encrypt($plaintext);
\&
\&  $rsa_priv = Crypt::OpenSSL::RSA\->new_private_key($key_string);
\&  $plaintext = $rsa\->encrypt($ciphertext);
\&
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024); # or
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024, $prime);
\&
\&  print "private key is:\en", $rsa\->get_private_key_string();
\&  print "public key (in PKCS1 format) is:\en",
\&        $rsa\->get_public_key_string();
\&  print "public key (in X509 format) is:\en",
\&        $rsa\->get_public_key_x509_string();
\&
\&  $rsa_priv\->use_md5_hash(); # use_sha1_hash is the default
\&  $signature = $rsa_priv\->sign($plaintext);
\&  print "Signed correctly\en" if ($rsa\->verify($plaintext, $signature));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::RSA provides the ability to \s-1RSA\s0 encrypt strings which are
somewhat shorter than the block size of a key.  It also allows for decryption,
signatures and signature verification.
.PP
\&\fI\s-1NOTE\s0\fR: Many of the methods in this package can croak, so use eval, or
Error.pm's try/catch mechanism to capture errors.  Also, while some
methods from earlier versions of this package return true on success,
this (never documented) behavior is no longer the case.
.SH "Class Methods"
.IX Header "Class Methods"
.IP "new_public_key" 4
.IX Item "new_public_key"
Create a new Crypt::OpenSSL::RSA object by loading a public key in
from a string containing Base64/DER\-encoding of either the \s-1PKCS1\s0 or
X.509 representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.
.Sp
The padding is set to \s-1PKCS1_OAEP\s0, but can be changed with the
use_xxx_padding methods
.IP "new_private_key" 4
.IX Item "new_private_key"
Create a new Crypt::OpenSSL::RSA object by loading a private key in
from an string containing the Base64/DER encoding of the \s-1PKCS1\s0
representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.  The padding is set to
\&\s-1PKCS1_OAEP\s0, but can be changed with use_xxx_padding.
.IP "generate_key" 4
.IX Item "generate_key"
Create a new Crypt::OpenSSL::RSA object by constructing a
private/public key pair.  The first (mandetory) argument is the key
size, while the second optional argument specifies the public exponent
(the default public exponent is 65537).  The padding is set to
\&\s-1PKCS1_OAEP\s0, but can be changed with use_xxx_padding methods.
.IP "new_key_from_parameters" 4
.IX Item "new_key_from_parameters"
Given Crypt::OpenSSL::Bignum objects for n, e, and optionally d, p,
and q, where p and q are the prime factors of n, e is the public
exponent and d is the private exponent, create a new
Crypt::OpenSSL::RSA object using these values.  If p and q are
provided and d is undef, d is computed.  Note that while p and q are
not necessary for a private key, their presence will speed up
computation.
.IP "import_random_seed" 4
.IX Item "import_random_seed"
Import a random seed from Crypt::OpenSSL::Random, since the OpenSSL
libraries won't allow sharing of random structures across perl \s-1XS\s0
modules.
.SH "Instance Methods"
.IX Header "Instance Methods"
.IP "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
Clean up after ourselves.  In particular, erase and free the memory
occupied by the \s-1RSA\s0 key structure.
.IP "get_public_key_string" 4
.IX Item "get_public_key_string"
Return the Base64/DER\-encoded \s-1PKCS1\s0 representation of the public
key.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN RSA PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END RSA PUBLIC KEY\-\-\-\-\-\-
.Ve
.IP "get_public_key_x509_string" 4
.IX Item "get_public_key_x509_string"
Return the Base64/DER\-encoded representation of the \*(L"subject
public key\*(R", suitable for use in X509 certificates.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\-
.Ve
.Sp
and is the format that is produced by running \f(CW\*(C`openssl rsa \-pubout\*(C'\fR.
.IP "get_private_key_string" 4
.IX Item "get_private_key_string"
Return the DER-encoded \s-1PKCS1\s0 representation of the private key.
.IP "encrypt" 4
.IX Item "encrypt"
Encrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "decrypt" 4
.IX Item "decrypt"
Decrypt a binary \*(L"string\*(R".  Croaks if the key is public only.
.IP "private_encrypt" 4
.IX Item "private_encrypt"
Encrypt a binary \*(L"string\*(R" using the private key.  Croaks if the key is
public only.
.IP "public_decrypt" 4
.IX Item "public_decrypt"
Decrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "sign" 4
.IX Item "sign"
Sign a string using the secret (portion of the) key.
.IP "verify" 4
.IX Item "verify"
Check the signature on a text.
.IP "use_no_padding" 4
.IX Item "use_no_padding"
Use raw \s-1RSA\s0 encryption. This mode should only be used to implement
cryptographically sound padding modes in the application code.
Encrypting user data directly with \s-1RSA\s0 is insecure.
.IP "use_pkcs1_padding" 4
.IX Item "use_pkcs1_padding"
Use \s-1PKCS\s0 #1 v1.5 padding. This currently is the most widely used mode
of padding.
.IP "use_pkcs1_oaep_padding" 4
.IX Item "use_pkcs1_oaep_padding"
Use EME-OAEP padding as defined in \s-1PKCS\s0 #1 v2.0 with \s-1SHA\-1\s0, \s-1MGF1\s0 and
an empty encoding parameter. This mode of padding is recommended for
all new applications.  It is the default mode used by
Crypt::OpenSSL::RSA.
.IP "use_sslv23_padding" 4
.IX Item "use_sslv23_padding"
Use \s-1PKCS\s0 #1 v1.5 padding with an SSL-specific modification that
denotes that the server is \s-1SSL3\s0 capable.
.IP "use_md5_hash" 4
.IX Item "use_md5_hash"
Use the \s-1RFC\s0 1321 \s-1MD5\s0 hashing algorithm by Ron Rivest when signing and
verifying messages.
.IP "use_sha1_hash" 4
.IX Item "use_sha1_hash"
Use the \s-1RFC\s0 3174 Secure Hashing Algorithm (\s-1FIPS\s0 180\-1) when signing
and verifying messages. This is the default.
.IP "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash" 4
.IX Item "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash"
These \s-1FIPS\s0 180\-2 hash algorithms, for use when signing and verifying
messages, are only available with newer openssl versions (>= 0.9.8).
.IP "use_ripemd160_hash" 4
.IX Item "use_ripemd160_hash"
Dobbertin, Bosselaers and Preneel's \s-1RIPEMD\s0 hashing algorithm when
signing and verifying messages.
.IP "size" 4
.IX Item "size"
Returns the size, in bytes, of the key.  All encrypted text will be of
this size, and depending on the padding mode used, the length of
the text to be encrypted should be:
.RS 4
.IP "pkcs1_oaep_padding" 4
.IX Item "pkcs1_oaep_padding"
at most 42 bytes less than this size.
.IP "pkcs1_padding or sslv23_padding" 4
.IX Item "pkcs1_padding or sslv23_padding"
at most 11 bytes less than this size.
.IP "no_padding" 4
.IX Item "no_padding"
exactly this size.
.RE
.RS 4
.RE
.IP "check_key" 4
.IX Item "check_key"
This function validates the \s-1RSA\s0 key, returning a true value if the key
is valid, and a false value otherwise.  Croaks if the key is public only.
.IP "get_key_parameters" 4
.IX Item "get_key_parameters"
Return Crypt::OpenSSL::Bignum objects representing the values of n, e,
d, p, q, d mod (p\-1), d mod (q\-1), and 1/q mod p, where p and q are
the prime factors of n, e is the public exponent and d is the private
exponent.  Some of these values may return as undef; only n and e will
be defined for a public key.  The Crypt::OpenSSL::Bignum module must
be installed for this to work.
.IP "is_private" 4
.IX Item "is_private"
Return true if this is a private key, and false if it is private only.
.SH "BUGS"
.IX Header "BUGS"
There is a small memory leak when generating new keys of more than 512 bits.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.org.  For support, please email
perl\-openssl\-users@lists.sourceforge.net.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fICrypt::OpenSSL::Random\fR\|(3), \fICrypt::OpenSSL::Bignum\fR\|(3),
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3), \fIRSA_public_encrypt\fR\|(3), \fIRSA_size\fR\|(3),
\&\fIRSA_generate_key\fR\|(3), \fIRSA_check_key\fR\|(3)
                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::RSA5.18.3pm                  0100644 0001750 0001750 00000030656 12566242056 025052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA 3"
.TH RSA 3 "2011-08-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Crypt::OpenSSL::Random;
\&  use Crypt::OpenSSL::RSA;
\&
\&  # not necessary if we have /dev/random:
\&  Crypt::OpenSSL::Random::random_seed($good_entropy);
\&  Crypt::OpenSSL::RSA\->import_random_seed();
\&  $rsa_pub = Crypt::OpenSSL::RSA\->new_public_key($key_string);
\&  $rsa_pub\->use_sslv23_padding(); # use_pkcs1_oaep_padding is the default
\&  $ciphertext = $rsa\->encrypt($plaintext);
\&
\&  $rsa_priv = Crypt::OpenSSL::RSA\->new_private_key($key_string);
\&  $plaintext = $rsa\->encrypt($ciphertext);
\&
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024); # or
\&  $rsa = Crypt::OpenSSL::RSA\->generate_key(1024, $prime);
\&
\&  print "private key is:\en", $rsa\->get_private_key_string();
\&  print "public key (in PKCS1 format) is:\en",
\&        $rsa\->get_public_key_string();
\&  print "public key (in X509 format) is:\en",
\&        $rsa\->get_public_key_x509_string();
\&
\&  $rsa_priv\->use_md5_hash(); # use_sha1_hash is the default
\&  $signature = $rsa_priv\->sign($plaintext);
\&  print "Signed correctly\en" if ($rsa\->verify($plaintext, $signature));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::RSA provides the ability to \s-1RSA\s0 encrypt strings which are
somewhat shorter than the block size of a key.  It also allows for decryption,
signatures and signature verification.
.PP
\&\fI\s-1NOTE\s0\fR: Many of the methods in this package can croak, so use eval, or
Error.pm's try/catch mechanism to capture errors.  Also, while some
methods from earlier versions of this package return true on success,
this (never documented) behavior is no longer the case.
.SH "Class Methods"
.IX Header "Class Methods"
.IP "new_public_key" 4
.IX Item "new_public_key"
Create a new Crypt::OpenSSL::RSA object by loading a public key in
from a string containing Base64/DER\-encoding of either the \s-1PKCS1\s0 or
X.509 representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.
.Sp
The padding is set to \s-1PKCS1_OAEP,\s0 but can be changed with the
use_xxx_padding methods
.IP "new_private_key" 4
.IX Item "new_private_key"
Create a new Crypt::OpenSSL::RSA object by loading a private key in
from an string containing the Base64/DER encoding of the \s-1PKCS1\s0
representation of the key.  The string should include the
\&\-\-\-\-\-BEGIN...\-\-\-\-\- and \-\-\-\-\-END...\-\-\-\-\- lines.  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding.
.IP "generate_key" 4
.IX Item "generate_key"
Create a new Crypt::OpenSSL::RSA object by constructing a
private/public key pair.  The first (mandetory) argument is the key
size, while the second optional argument specifies the public exponent
(the default public exponent is 65537).  The padding is set to
\&\s-1PKCS1_OAEP,\s0 but can be changed with use_xxx_padding methods.
.IP "new_key_from_parameters" 4
.IX Item "new_key_from_parameters"
Given Crypt::OpenSSL::Bignum objects for n, e, and optionally d, p,
and q, where p and q are the prime factors of n, e is the public
exponent and d is the private exponent, create a new
Crypt::OpenSSL::RSA object using these values.  If p and q are
provided and d is undef, d is computed.  Note that while p and q are
not necessary for a private key, their presence will speed up
computation.
.IP "import_random_seed" 4
.IX Item "import_random_seed"
Import a random seed from Crypt::OpenSSL::Random, since the OpenSSL
libraries won't allow sharing of random structures across perl \s-1XS\s0
modules.
.SH "Instance Methods"
.IX Header "Instance Methods"
.IP "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
Clean up after ourselves.  In particular, erase and free the memory
occupied by the \s-1RSA\s0 key structure.
.IP "get_public_key_string" 4
.IX Item "get_public_key_string"
Return the Base64/DER\-encoded \s-1PKCS1\s0 representation of the public
key.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN RSA PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END RSA PUBLIC KEY\-\-\-\-\-\-
.Ve
.IP "get_public_key_x509_string" 4
.IX Item "get_public_key_x509_string"
Return the Base64/DER\-encoded representation of the \*(L"subject
public key\*(R", suitable for use in X509 certificates.  This string has
header and footer lines:
.Sp
.Vb 2
\&  \-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-\-
\&  \-\-\-\-\-END PUBLIC KEY\-\-\-\-\-\-
.Ve
.Sp
and is the format that is produced by running \f(CW\*(C`openssl rsa \-pubout\*(C'\fR.
.IP "get_private_key_string" 4
.IX Item "get_private_key_string"
Return the DER-encoded \s-1PKCS1\s0 representation of the private key.
.IP "encrypt" 4
.IX Item "encrypt"
Encrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "decrypt" 4
.IX Item "decrypt"
Decrypt a binary \*(L"string\*(R".  Croaks if the key is public only.
.IP "private_encrypt" 4
.IX Item "private_encrypt"
Encrypt a binary \*(L"string\*(R" using the private key.  Croaks if the key is
public only.
.IP "public_decrypt" 4
.IX Item "public_decrypt"
Decrypt a binary \*(L"string\*(R" using the public (portion of the) key.
.IP "sign" 4
.IX Item "sign"
Sign a string using the secret (portion of the) key.
.IP "verify" 4
.IX Item "verify"
Check the signature on a text.
.IP "use_no_padding" 4
.IX Item "use_no_padding"
Use raw \s-1RSA\s0 encryption. This mode should only be used to implement
cryptographically sound padding modes in the application code.
Encrypting user data directly with \s-1RSA\s0 is insecure.
.IP "use_pkcs1_padding" 4
.IX Item "use_pkcs1_padding"
Use \s-1PKCS\s0 #1 v1.5 padding. This currently is the most widely used mode
of padding.
.IP "use_pkcs1_oaep_padding" 4
.IX Item "use_pkcs1_oaep_padding"
Use EME-OAEP padding as defined in \s-1PKCS\s0 #1 v2.0 with \s-1SHA\-1, MGF1\s0 and
an empty encoding parameter. This mode of padding is recommended for
all new applications.  It is the default mode used by
Crypt::OpenSSL::RSA.
.IP "use_sslv23_padding" 4
.IX Item "use_sslv23_padding"
Use \s-1PKCS\s0 #1 v1.5 padding with an SSL-specific modification that
denotes that the server is \s-1SSL3\s0 capable.
.IP "use_md5_hash" 4
.IX Item "use_md5_hash"
Use the \s-1RFC 1321 MD5\s0 hashing algorithm by Ron Rivest when signing and
verifying messages.
.IP "use_sha1_hash" 4
.IX Item "use_sha1_hash"
Use the \s-1RFC 3174\s0 Secure Hashing Algorithm (\s-1FIPS 180\-1\s0) when signing
and verifying messages. This is the default.
.IP "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash" 4
.IX Item "use_sha224_hash, use_sha256_hash, use_sha384_hash, use_sha512_hash"
These \s-1FIPS 180\-2\s0 hash algorithms, for use when signing and verifying
messages, are only available with newer openssl versions (>= 0.9.8).
.IP "use_ripemd160_hash" 4
.IX Item "use_ripemd160_hash"
Dobbertin, Bosselaers and Preneel's \s-1RIPEMD\s0 hashing algorithm when
signing and verifying messages.
.IP "size" 4
.IX Item "size"
Returns the size, in bytes, of the key.  All encrypted text will be of
this size, and depending on the padding mode used, the length of
the text to be encrypted should be:
.RS 4
.IP "pkcs1_oaep_padding" 4
.IX Item "pkcs1_oaep_padding"
at most 42 bytes less than this size.
.IP "pkcs1_padding or sslv23_padding" 4
.IX Item "pkcs1_padding or sslv23_padding"
at most 11 bytes less than this size.
.IP "no_padding" 4
.IX Item "no_padding"
exactly this size.
.RE
.RS 4
.RE
.IP "check_key" 4
.IX Item "check_key"
This function validates the \s-1RSA\s0 key, returning a true value if the key
is valid, and a false value otherwise.  Croaks if the key is public only.
.IP "get_key_parameters" 4
.IX Item "get_key_parameters"
Return Crypt::OpenSSL::Bignum objects representing the values of n, e,
d, p, q, d mod (p\-1), d mod (q\-1), and 1/q mod p, where p and q are
the prime factors of n, e is the public exponent and d is the private
exponent.  Some of these values may return as undef; only n and e will
be defined for a public key.  The Crypt::OpenSSL::Bignum module must
be installed for this to work.
.IP "is_private" 4
.IX Item "is_private"
Return true if this is a private key, and false if it is private only.
.SH "BUGS"
.IX Header "BUGS"
There is a small memory leak when generating new keys of more than 512 bits.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.org.  For support, please email
perl\-openssl\-users@lists.sourceforge.net.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fICrypt::OpenSSL::Random\fR\|(3), \fICrypt::OpenSSL::Bignum\fR\|(3),
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3), \fIRSA_public_encrypt\fR\|(3), \fIRSA_size\fR\|(3),
\&\fIRSA_generate_key\fR\|(3), \fIRSA_check_key\fR\|(3)
                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::Random.3pm                   0100644 0001750 0001750 00000015761 12566242053 025326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Random 3"
.TH Random 3 "2007-05-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.PP
Crypt::OpenSSL::Random \- Routines for accessing the OpenSSL
pseudo\-random number generator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Crypt::OpenSSL::Random;
\&
\&  Crypt::OpenSSL::Random::random_seed($good_random_data);
\&  Crypt::OpenSSL::Random::random_egd("/tmp/entropy");
\&  Crypt::OpenSSL::Random::random_status() or
\&    die "Unable to sufficiently seed the random number generator".
\&
\&  my $ten_good_random_bytes = Crypt::OpenSSL::Random::random_bytes(10);
\&  my $ten_ok_random_bytes = Crypt::OpenSSL::Random::random_pseudo_bytes(10);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::Random provides the ability to seed and query the
OpenSSL library's pseudo-random number generator
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "Static Methods"
.IX Header "Static Methods"
.IP "random_bytes" 4
.IX Item "random_bytes"
This function, returns a specified number of cryptographically strong
pseudo-random bytes from the \s-1PRNG. \s0 If the \s-1PRNG\s0 has not been seeded
with enough randomness to ensure an unpredictable byte sequence, then
a false value is returned.
.IP "random_pseudo_bytes" 4
.IX Item "random_pseudo_bytes"
This function, is similar to c<random_bytes>, but the resulting
sequence of bytes are not necessarily unpredictable.  They can be used
for non-cryptographic purposes and for certain purposes in
cryptographic protocols, but usually not for key generation etc.
.IP "random_seed" 4
.IX Item "random_seed"
This function seeds the \s-1PRNG\s0 with a supplied string of bytes.  It
returns true if the \s-1PRNG\s0 has sufficient seeding.  Note: calling this
function with non-random bytes is of limited value at best!
.IP "random_egd" 4
.IX Item "random_egd"
This function seeds the \s-1PRNG\s0 with data from the specified entropy
gathering daemon.  Returns the number of bytes read from the daemon on
succes, or \-1 if not enough bytes were read, or if the connection to
the daemon failed.
.IP "random_status" 4
.IX Item "random_status"
This function returns true if the \s-1PRNG\s0 has sufficient seeding.
.SH "BUGS"
.IX Header "BUGS"
Because of the internal workings of OpenSSL's random library, the
pseudo-random number generator (\s-1PRNG\s0) accessed by
Crypt::OpenSSL::Random will be different than the one accessed by any
other perl module.  Hence, to use a module such as
Crypt::OpenSSL::Random, you will need to seed the \s-1PRNG\s0 used there from
one used here.  This class is still advantageous, however, as it
centralizes other methods, such as random_egd, in one place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIrand\fR\|(3), \fIRAND_add\fR\|(3), \fIRAND_egd\fR\|(3), \fIRAND_bytes\fR\|(3).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 62:" 4
.IX Item "Around line 62:"
\&'=item' outside of any '=over'
.IP "Around line 93:" 4
.IX Item "Around line 93:"
You forgot a '=back' before '=head1'
               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::Random5.16.3pm               0100644 0001750 0001750 00000015440 12566242065 025635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Random 3"
.TH Random 3 "2007-05-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.PP
Crypt::OpenSSL::Random \- Routines for accessing the OpenSSL
pseudo\-random number generator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Crypt::OpenSSL::Random;
\&
\&  Crypt::OpenSSL::Random::random_seed($good_random_data);
\&  Crypt::OpenSSL::Random::random_egd("/tmp/entropy");
\&  Crypt::OpenSSL::Random::random_status() or
\&    die "Unable to sufficiently seed the random number generator".
\&
\&  my $ten_good_random_bytes = Crypt::OpenSSL::Random::random_bytes(10);
\&  my $ten_ok_random_bytes = Crypt::OpenSSL::Random::random_pseudo_bytes(10);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::Random provides the ability to seed and query the
OpenSSL library's pseudo-random number generator
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "Static Methods"
.IX Header "Static Methods"
.IP "random_bytes" 4
.IX Item "random_bytes"
This function, returns a specified number of cryptographically strong
pseudo-random bytes from the \s-1PRNG\s0.  If the \s-1PRNG\s0 has not been seeded
with enough randomness to ensure an unpredictable byte sequence, then
a false value is returned.
.IP "random_pseudo_bytes" 4
.IX Item "random_pseudo_bytes"
This function, is similar to c<random_bytes>, but the resulting
sequence of bytes are not necessarily unpredictable.  They can be used
for non-cryptographic purposes and for certain purposes in
cryptographic protocols, but usually not for key generation etc.
.IP "random_seed" 4
.IX Item "random_seed"
This function seeds the \s-1PRNG\s0 with a supplied string of bytes.  It
returns true if the \s-1PRNG\s0 has sufficient seeding.  Note: calling this
function with non-random bytes is of limited value at best!
.IP "random_egd" 4
.IX Item "random_egd"
This function seeds the \s-1PRNG\s0 with data from the specified entropy
gathering daemon.  Returns the number of bytes read from the daemon on
succes, or \-1 if not enough bytes were read, or if the connection to
the daemon failed.
.IP "random_status" 4
.IX Item "random_status"
This function returns true if the \s-1PRNG\s0 has sufficient seeding.
.SH "BUGS"
.IX Header "BUGS"
Because of the internal workings of OpenSSL's random library, the
pseudo-random number generator (\s-1PRNG\s0) accessed by
Crypt::OpenSSL::Random will be different than the one accessed by any
other perl module.  Hence, to use a module such as
Crypt::OpenSSL::Random, you will need to seed the \s-1PRNG\s0 used there from
one used here.  This class is still advantageous, however, as it
centralizes other methods, such as random_egd, in one place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIrand\fR\|(3), \fIRAND_add\fR\|(3), \fIRAND_egd\fR\|(3), \fIRAND_bytes\fR\|(3).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 62:" 4
.IX Item "Around line 62:"
\&'=item' outside of any '=over'
.IP "Around line 93:" 4
.IX Item "Around line 93:"
You forgot a '=back' before '=head1'
                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Crypt::OpenSSL::Random5.18.3pm               0100644 0001750 0001750 00000015761 12566242053 025642  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Random 3"
.TH Random 3 "2007-05-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::OpenSSL::RSA \- RSA encoding and decoding, using the openSSL libraries
.PP
Crypt::OpenSSL::Random \- Routines for accessing the OpenSSL
pseudo\-random number generator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Crypt::OpenSSL::Random;
\&
\&  Crypt::OpenSSL::Random::random_seed($good_random_data);
\&  Crypt::OpenSSL::Random::random_egd("/tmp/entropy");
\&  Crypt::OpenSSL::Random::random_status() or
\&    die "Unable to sufficiently seed the random number generator".
\&
\&  my $ten_good_random_bytes = Crypt::OpenSSL::Random::random_bytes(10);
\&  my $ten_ok_random_bytes = Crypt::OpenSSL::Random::random_pseudo_bytes(10);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::OpenSSL::Random provides the ability to seed and query the
OpenSSL library's pseudo-random number generator
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "Static Methods"
.IX Header "Static Methods"
.IP "random_bytes" 4
.IX Item "random_bytes"
This function, returns a specified number of cryptographically strong
pseudo-random bytes from the \s-1PRNG. \s0 If the \s-1PRNG\s0 has not been seeded
with enough randomness to ensure an unpredictable byte sequence, then
a false value is returned.
.IP "random_pseudo_bytes" 4
.IX Item "random_pseudo_bytes"
This function, is similar to c<random_bytes>, but the resulting
sequence of bytes are not necessarily unpredictable.  They can be used
for non-cryptographic purposes and for certain purposes in
cryptographic protocols, but usually not for key generation etc.
.IP "random_seed" 4
.IX Item "random_seed"
This function seeds the \s-1PRNG\s0 with a supplied string of bytes.  It
returns true if the \s-1PRNG\s0 has sufficient seeding.  Note: calling this
function with non-random bytes is of limited value at best!
.IP "random_egd" 4
.IX Item "random_egd"
This function seeds the \s-1PRNG\s0 with data from the specified entropy
gathering daemon.  Returns the number of bytes read from the daemon on
succes, or \-1 if not enough bytes were read, or if the connection to
the daemon failed.
.IP "random_status" 4
.IX Item "random_status"
This function returns true if the \s-1PRNG\s0 has sufficient seeding.
.SH "BUGS"
.IX Header "BUGS"
Because of the internal workings of OpenSSL's random library, the
pseudo-random number generator (\s-1PRNG\s0) accessed by
Crypt::OpenSSL::Random will be different than the one accessed by any
other perl module.  Hence, to use a module such as
Crypt::OpenSSL::Random, you will need to seed the \s-1PRNG\s0 used there from
one used here.  This class is still advantageous, however, as it
centralizes other methods, such as random_egd, in one place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ian Robertson, iroberts@cpan.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIrand\fR\|(3), \fIRAND_add\fR\|(3), \fIRAND_egd\fR\|(3), \fIRAND_bytes\fR\|(3).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 62:" 4
.IX Item "Around line 62:"
\&'=item' outside of any '=over'
.IP "Around line 93:" 4
.IX Item "Around line 93:"
You forgot a '=back' before '=head1'
               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Cwd.3pm                                      0100644 0001750 0001750 00000021434 12566207453 022024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cwd 3pm"
.TH Cwd 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cwd \- get pathname of current working directory
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Cwd;
\&    my $dir = getcwd;
\&
\&    use Cwd \*(Aqabs_path\*(Aq;
\&    my $abs_path = abs_path($file);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions for determining the pathname of the
current working directory.  It is recommended that getcwd (or another
*\fIcwd()\fR function) be used in \fIall\fR code to ensure portability.
.PP
By default, it exports the functions \fIcwd()\fR, \fIgetcwd()\fR, \fIfastcwd()\fR, and
\&\fIfastgetcwd()\fR (and, on Win32, \fIgetdcwd()\fR) into the caller's namespace.
.SS "getcwd and friends"
.IX Subsection "getcwd and friends"
Each of these functions are called without arguments and return the
absolute path of the current working directory.
.IP "getcwd" 4
.IX Item "getcwd"
.Vb 1
\&    my $cwd = getcwd();
.Ve
.Sp
Returns the current working directory.
.Sp
Exposes the \s-1POSIX\s0 function \fIgetcwd\fR\|(3) or re-implements it if it's not
available.
.IP "cwd" 4
.IX Item "cwd"
.Vb 1
\&    my $cwd = cwd();
.Ve
.Sp
The \fIcwd()\fR is the most natural form for the current architecture.  For
most systems it is identical to `pwd` (but without the trailing line
terminator).
.IP "fastcwd" 4
.IX Item "fastcwd"
.Vb 1
\&    my $cwd = fastcwd();
.Ve
.Sp
A more dangerous version of \fIgetcwd()\fR, but potentially faster.
.Sp
It might conceivably \fIchdir()\fR you out of a directory that it can't
\&\fIchdir()\fR you back into.  If fastcwd encounters a problem it will return
undef but will probably leave you in a different directory.  For a
measure of extra security, if everything appears to have worked, the
\&\fIfastcwd()\fR function will check that it leaves you in the same directory
that it started in.  If it has changed it will \f(CW\*(C`die\*(C'\fR with the message
\&\*(L"Unstable directory path, current directory changed
unexpectedly\*(R".  That should never happen.
.IP "fastgetcwd" 4
.IX Item "fastgetcwd"
.Vb 1
\&  my $cwd = fastgetcwd();
.Ve
.Sp
The \fIfastgetcwd()\fR function is provided as a synonym for \fIcwd()\fR.
.IP "getdcwd" 4
.IX Item "getdcwd"
.Vb 2
\&    my $cwd = getdcwd();
\&    my $cwd = getdcwd(\*(AqC:\*(Aq);
.Ve
.Sp
The \fIgetdcwd()\fR function is also provided on Win32 to get the current working
directory on the specified drive, since Windows maintains a separate current
working directory for each drive.  If no drive is specified then the current
drive is assumed.
.Sp
This function simply calls the Microsoft C library \fI_getdcwd()\fR function.
.SS "abs_path and friends"
.IX Subsection "abs_path and friends"
These functions are exported only on request.  They each take a single
argument and return the absolute pathname for it.  If no argument is
given they'll use the current working directory.
.IP "abs_path" 4
.IX Item "abs_path"
.Vb 1
\&  my $abs_path = abs_path($file);
.Ve
.Sp
Uses the same algorithm as \fIgetcwd()\fR.  Symbolic links and relative-path
components (\*(L".\*(R" and \*(L"..\*(R") are resolved to return the canonical
pathname, just like \fIrealpath\fR\|(3).
.IP "realpath" 4
.IX Item "realpath"
.Vb 1
\&  my $abs_path = realpath($file);
.Ve
.Sp
A synonym for \fIabs_path()\fR.
.IP "fast_abs_path" 4
.IX Item "fast_abs_path"
.Vb 1
\&  my $abs_path = fast_abs_path($file);
.Ve
.Sp
A more dangerous, but potentially faster version of abs_path.
.ie n .SS "$ENV{\s-1PWD\s0}"
.el .SS "\f(CW$ENV\fP{\s-1PWD\s0}"
.IX Subsection "$ENV{PWD}"
If you ask to override your \fIchdir()\fR built-in function,
.PP
.Vb 1
\&  use Cwd qw(chdir);
.Ve
.PP
then your \s-1PWD\s0 environment variable will be kept up to date.  Note that
it will only be kept up to date if all packages which use chdir import
it from Cwd.
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
Since the path separators are different on some operating systems ('/'
on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
modules wherever portability is a concern.
.IP "\(bu" 4
Actually, on Mac \s-1OS,\s0 the \f(CW\*(C`getcwd()\*(C'\fR, \f(CW\*(C`fastgetcwd()\*(C'\fR and \f(CW\*(C`fastcwd()\*(C'\fR
functions are all aliases for the \f(CW\*(C`cwd()\*(C'\fR function, which, on Mac \s-1OS,\s0
calls `pwd`.  Likewise, the \f(CW\*(C`abs_path()\*(C'\fR function is an alias for
\&\f(CW\*(C`fast_abs_path()\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally by the perl5\-porters.
.PP
Maintained by Ken Williams <KWILLIAMS@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Portions of the C code in this library are copyright (c) 1994 by the
Regents of the University of California.  All rights reserved.  The
license on this code is compatible with the licensing of the rest of
the distribution \- please see the source code in \fICwd.xs\fR for the
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::chdir
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Cwd5.16.3pm                                  0100644 0001750 0001750 00000021113 12566207432 022325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cwd 3pm"
.TH Cwd 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cwd \- get pathname of current working directory
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Cwd;
\&    my $dir = getcwd;
\&
\&    use Cwd \*(Aqabs_path\*(Aq;
\&    my $abs_path = abs_path($file);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions for determining the pathname of the
current working directory.  It is recommended that getcwd (or another
*\fIcwd()\fR function) be used in \fIall\fR code to ensure portability.
.PP
By default, it exports the functions \fIcwd()\fR, \fIgetcwd()\fR, \fIfastcwd()\fR, and
\&\fIfastgetcwd()\fR (and, on Win32, \fIgetdcwd()\fR) into the caller's namespace.
.SS "getcwd and friends"
.IX Subsection "getcwd and friends"
Each of these functions are called without arguments and return the
absolute path of the current working directory.
.IP "getcwd" 4
.IX Item "getcwd"
.Vb 1
\&    my $cwd = getcwd();
.Ve
.Sp
Returns the current working directory.
.Sp
Exposes the \s-1POSIX\s0 function \fIgetcwd\fR\|(3) or re-implements it if it's not
available.
.IP "cwd" 4
.IX Item "cwd"
.Vb 1
\&    my $cwd = cwd();
.Ve
.Sp
The \fIcwd()\fR is the most natural form for the current architecture.  For
most systems it is identical to `pwd` (but without the trailing line
terminator).
.IP "fastcwd" 4
.IX Item "fastcwd"
.Vb 1
\&    my $cwd = fastcwd();
.Ve
.Sp
A more dangerous version of \fIgetcwd()\fR, but potentially faster.
.Sp
It might conceivably \fIchdir()\fR you out of a directory that it can't
\&\fIchdir()\fR you back into.  If fastcwd encounters a problem it will return
undef but will probably leave you in a different directory.  For a
measure of extra security, if everything appears to have worked, the
\&\fIfastcwd()\fR function will check that it leaves you in the same directory
that it started in.  If it has changed it will \f(CW\*(C`die\*(C'\fR with the message
\&\*(L"Unstable directory path, current directory changed
unexpectedly\*(R".  That should never happen.
.IP "fastgetcwd" 4
.IX Item "fastgetcwd"
.Vb 1
\&  my $cwd = fastgetcwd();
.Ve
.Sp
The \fIfastgetcwd()\fR function is provided as a synonym for \fIcwd()\fR.
.IP "getdcwd" 4
.IX Item "getdcwd"
.Vb 2
\&    my $cwd = getdcwd();
\&    my $cwd = getdcwd(\*(AqC:\*(Aq);
.Ve
.Sp
The \fIgetdcwd()\fR function is also provided on Win32 to get the current working
directory on the specified drive, since Windows maintains a separate current
working directory for each drive.  If no drive is specified then the current
drive is assumed.
.Sp
This function simply calls the Microsoft C library \fI_getdcwd()\fR function.
.SS "abs_path and friends"
.IX Subsection "abs_path and friends"
These functions are exported only on request.  They each take a single
argument and return the absolute pathname for it.  If no argument is
given they'll use the current working directory.
.IP "abs_path" 4
.IX Item "abs_path"
.Vb 1
\&  my $abs_path = abs_path($file);
.Ve
.Sp
Uses the same algorithm as \fIgetcwd()\fR.  Symbolic links and relative-path
components (\*(L".\*(R" and \*(L"..\*(R") are resolved to return the canonical
pathname, just like \fIrealpath\fR\|(3).
.IP "realpath" 4
.IX Item "realpath"
.Vb 1
\&  my $abs_path = realpath($file);
.Ve
.Sp
A synonym for \fIabs_path()\fR.
.IP "fast_abs_path" 4
.IX Item "fast_abs_path"
.Vb 1
\&  my $abs_path = fast_abs_path($file);
.Ve
.Sp
A more dangerous, but potentially faster version of abs_path.
.ie n .SS "$ENV{\s-1PWD\s0}"
.el .SS "\f(CW$ENV\fP{\s-1PWD\s0}"
.IX Subsection "$ENV{PWD}"
If you ask to override your \fIchdir()\fR built-in function,
.PP
.Vb 1
\&  use Cwd qw(chdir);
.Ve
.PP
then your \s-1PWD\s0 environment variable will be kept up to date.  Note that
it will only be kept up to date if all packages which use chdir import
it from Cwd.
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
Since the path separators are different on some operating systems ('/'
on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
modules wherever portability is a concern.
.IP "\(bu" 4
Actually, on Mac \s-1OS\s0, the \f(CW\*(C`getcwd()\*(C'\fR, \f(CW\*(C`fastgetcwd()\*(C'\fR and \f(CW\*(C`fastcwd()\*(C'\fR
functions are all aliases for the \f(CW\*(C`cwd()\*(C'\fR function, which, on Mac \s-1OS\s0,
calls `pwd`.  Likewise, the \f(CW\*(C`abs_path()\*(C'\fR function is an alias for
\&\f(CW\*(C`fast_abs_path()\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally by the perl5\-porters.
.PP
Maintained by Ken Williams <KWILLIAMS@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Portions of the C code in this library are copyright (c) 1994 by the
Regents of the University of California.  All rights reserved.  The
license on this code is compatible with the licensing of the rest of
the distribution \- please see the source code in \fICwd.xs\fR for the
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::chdir
                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Cwd5.18.3pm                                  0100644 0001750 0001750 00000021434 12566207453 022340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cwd 3pm"
.TH Cwd 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cwd \- get pathname of current working directory
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Cwd;
\&    my $dir = getcwd;
\&
\&    use Cwd \*(Aqabs_path\*(Aq;
\&    my $abs_path = abs_path($file);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions for determining the pathname of the
current working directory.  It is recommended that getcwd (or another
*\fIcwd()\fR function) be used in \fIall\fR code to ensure portability.
.PP
By default, it exports the functions \fIcwd()\fR, \fIgetcwd()\fR, \fIfastcwd()\fR, and
\&\fIfastgetcwd()\fR (and, on Win32, \fIgetdcwd()\fR) into the caller's namespace.
.SS "getcwd and friends"
.IX Subsection "getcwd and friends"
Each of these functions are called without arguments and return the
absolute path of the current working directory.
.IP "getcwd" 4
.IX Item "getcwd"
.Vb 1
\&    my $cwd = getcwd();
.Ve
.Sp
Returns the current working directory.
.Sp
Exposes the \s-1POSIX\s0 function \fIgetcwd\fR\|(3) or re-implements it if it's not
available.
.IP "cwd" 4
.IX Item "cwd"
.Vb 1
\&    my $cwd = cwd();
.Ve
.Sp
The \fIcwd()\fR is the most natural form for the current architecture.  For
most systems it is identical to `pwd` (but without the trailing line
terminator).
.IP "fastcwd" 4
.IX Item "fastcwd"
.Vb 1
\&    my $cwd = fastcwd();
.Ve
.Sp
A more dangerous version of \fIgetcwd()\fR, but potentially faster.
.Sp
It might conceivably \fIchdir()\fR you out of a directory that it can't
\&\fIchdir()\fR you back into.  If fastcwd encounters a problem it will return
undef but will probably leave you in a different directory.  For a
measure of extra security, if everything appears to have worked, the
\&\fIfastcwd()\fR function will check that it leaves you in the same directory
that it started in.  If it has changed it will \f(CW\*(C`die\*(C'\fR with the message
\&\*(L"Unstable directory path, current directory changed
unexpectedly\*(R".  That should never happen.
.IP "fastgetcwd" 4
.IX Item "fastgetcwd"
.Vb 1
\&  my $cwd = fastgetcwd();
.Ve
.Sp
The \fIfastgetcwd()\fR function is provided as a synonym for \fIcwd()\fR.
.IP "getdcwd" 4
.IX Item "getdcwd"
.Vb 2
\&    my $cwd = getdcwd();
\&    my $cwd = getdcwd(\*(AqC:\*(Aq);
.Ve
.Sp
The \fIgetdcwd()\fR function is also provided on Win32 to get the current working
directory on the specified drive, since Windows maintains a separate current
working directory for each drive.  If no drive is specified then the current
drive is assumed.
.Sp
This function simply calls the Microsoft C library \fI_getdcwd()\fR function.
.SS "abs_path and friends"
.IX Subsection "abs_path and friends"
These functions are exported only on request.  They each take a single
argument and return the absolute pathname for it.  If no argument is
given they'll use the current working directory.
.IP "abs_path" 4
.IX Item "abs_path"
.Vb 1
\&  my $abs_path = abs_path($file);
.Ve
.Sp
Uses the same algorithm as \fIgetcwd()\fR.  Symbolic links and relative-path
components (\*(L".\*(R" and \*(L"..\*(R") are resolved to return the canonical
pathname, just like \fIrealpath\fR\|(3).
.IP "realpath" 4
.IX Item "realpath"
.Vb 1
\&  my $abs_path = realpath($file);
.Ve
.Sp
A synonym for \fIabs_path()\fR.
.IP "fast_abs_path" 4
.IX Item "fast_abs_path"
.Vb 1
\&  my $abs_path = fast_abs_path($file);
.Ve
.Sp
A more dangerous, but potentially faster version of abs_path.
.ie n .SS "$ENV{\s-1PWD\s0}"
.el .SS "\f(CW$ENV\fP{\s-1PWD\s0}"
.IX Subsection "$ENV{PWD}"
If you ask to override your \fIchdir()\fR built-in function,
.PP
.Vb 1
\&  use Cwd qw(chdir);
.Ve
.PP
then your \s-1PWD\s0 environment variable will be kept up to date.  Note that
it will only be kept up to date if all packages which use chdir import
it from Cwd.
.SH "NOTES"
.IX Header "NOTES"
.IP "\(bu" 4
Since the path separators are different on some operating systems ('/'
on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
modules wherever portability is a concern.
.IP "\(bu" 4
Actually, on Mac \s-1OS,\s0 the \f(CW\*(C`getcwd()\*(C'\fR, \f(CW\*(C`fastgetcwd()\*(C'\fR and \f(CW\*(C`fastcwd()\*(C'\fR
functions are all aliases for the \f(CW\*(C`cwd()\*(C'\fR function, which, on Mac \s-1OS,\s0
calls `pwd`.  Likewise, the \f(CW\*(C`abs_path()\*(C'\fR function is an alias for
\&\f(CW\*(C`fast_abs_path()\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally by the perl5\-porters.
.PP
Maintained by Ken Williams <KWILLIAMS@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Portions of the C code in this library are copyright (c) 1994 by the
Regents of the University of California.  All rights reserved.  The
license on this code is compatible with the licensing of the rest of
the distribution \- please see the source code in \fICwd.xs\fR for the
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::chdir
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DB.3pm                                       0100644 0001750 0001750 00000030365 12566207453 021577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DB 3pm"
.TH DB 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DB \- programmatic interface to the Perl debugging API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package CLIENT;
\&    use DB;
\&    @ISA = qw(DB);
\&
\&    # these (inherited) methods can be called by the client
\&
\&    CLIENT\->register()      # register a client package name
\&    CLIENT\->done()          # de\-register from the debugging API
\&    CLIENT\->skippkg(\*(Aqhide::hide\*(Aq)  # ask DB not to stop in this package
\&    CLIENT\->cont([WHERE])       # run some more (until BREAK or another breakpt)
\&    CLIENT\->step()              # single step
\&    CLIENT\->next()              # step over
\&    CLIENT\->ret()               # return from current subroutine
\&    CLIENT\->backtrace()         # return the call stack description
\&    CLIENT\->ready()             # call when client setup is done
\&    CLIENT\->trace_toggle()      # toggle subroutine call trace mode
\&    CLIENT\->subs([SUBS])        # return subroutine information
\&    CLIENT\->files()             # return list of all files known to DB
\&    CLIENT\->lines()             # return lines in currently loaded file
\&    CLIENT\->loadfile(FILE,LINE) # load a file and let other clients know
\&    CLIENT\->lineevents()        # return info on lines with actions
\&    CLIENT\->set_break([WHERE],[COND])
\&    CLIENT\->set_tbreak([WHERE])
\&    CLIENT\->clr_breaks([LIST])
\&    CLIENT\->set_action(WHERE,ACTION)
\&    CLIENT\->clr_actions([LIST])
\&    CLIENT\->evalcode(STRING)  # eval STRING in executing code\*(Aqs context
\&    CLIENT\->prestop([STRING]) # execute in code context before stopping
\&    CLIENT\->poststop([STRING])# execute in code context before resuming
\&
\&    # These methods will be called at the appropriate times.
\&    # Stub versions provided do nothing.
\&    # None of these can block.
\&
\&    CLIENT\->init()          # called when debug API inits itself
\&    CLIENT\->stop(FILE,LINE) # when execution stops
\&    CLIENT\->idle()          # while stopped (can be a client event loop)
\&    CLIENT\->cleanup()       # just before exit
\&    CLIENT\->output(LIST)    # called to print any output that API must show
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl debug information is frequently required not just by debuggers,
but also by modules that need some \*(L"special\*(R" information to do their
job properly, like profilers.
.PP
This module abstracts and provides all of the hooks into Perl internal
debugging functionality, so that various implementations of Perl debuggers
(or packages that want to simply get at the \*(L"privileged\*(R" debugging data)
can all benefit from the development of this common code.  Currently used
by Swat, the perl/Tk \s-1GUI\s0 debugger.
.PP
Note that multiple \*(L"front-ends\*(R" can latch into this debugging \s-1API\s0
simultaneously.  This is intended to facilitate things like
debugging with a command line and \s-1GUI\s0 at the same time, debugging 
debuggers etc.  [Sounds nice, but this needs some serious support \*(-- \s-1GSAR\s0]
.PP
In particular, this \s-1API\s0 does \fBnot\fR provide the following functions:
.IP "\(bu" 4
data display
.IP "\(bu" 4
command processing
.IP "\(bu" 4
command alias management
.IP "\(bu" 4
user interface (tty or graphical)
.PP
These are intended to be services performed by the clients of this \s-1API.\s0
.PP
This module attempts to be squeaky clean w.r.t \f(CW\*(C`use strict;\*(C'\fR and when
warnings are enabled.
.SS "Global Variables"
.IX Subsection "Global Variables"
The following \*(L"public\*(R" global names can be read by clients of this \s-1API.\s0
Beware that these should be considered \*(L"readonly\*(R".
.ie n .IP "$DB::sub" 8
.el .IP "\f(CW$DB::sub\fR" 8
.IX Item "$DB::sub"
Name of current executing subroutine.
.ie n .IP "%DB::sub" 8
.el .IP "\f(CW%DB::sub\fR" 8
.IX Item "%DB::sub"
The keys of this hash are the names of all the known subroutines.  Each value
is an encoded string that has the \fIsprintf\fR\|(3) format 
\&\f(CW\*(C`("%s:%d\-%d", filename, fromline, toline)\*(C'\fR.
.ie n .IP "$DB::single" 8
.el .IP "\f(CW$DB::single\fR" 8
.IX Item "$DB::single"
Single-step flag.  Will be true if the \s-1API\s0 will stop at the next statement.
.ie n .IP "$DB::signal" 8
.el .IP "\f(CW$DB::signal\fR" 8
.IX Item "$DB::signal"
Signal flag. Will be set to a true value if a signal was caught.  Clients may
check for this flag to abort time-consuming operations.
.ie n .IP "$DB::trace" 8
.el .IP "\f(CW$DB::trace\fR" 8
.IX Item "$DB::trace"
This flag is set to true if the \s-1API\s0 is tracing through subroutine calls.
.ie n .IP "@DB::args" 8
.el .IP "\f(CW@DB::args\fR" 8
.IX Item "@DB::args"
Contains the arguments of current subroutine, or the \f(CW@ARGV\fR array if in the 
toplevel context.
.ie n .IP "@DB::dbline" 8
.el .IP "\f(CW@DB::dbline\fR" 8
.IX Item "@DB::dbline"
List of lines in currently loaded file.
.ie n .IP "%DB::dbline" 8
.el .IP "\f(CW%DB::dbline\fR" 8
.IX Item "%DB::dbline"
Actions in current file (keys are line numbers).  The values are strings that
have the \fIsprintf\fR\|(3) format \f(CW\*(C`("%s\e000%s", breakcondition, actioncode)\*(C'\fR.
.ie n .IP "$DB::package" 8
.el .IP "\f(CW$DB::package\fR" 8
.IX Item "$DB::package"
Package namespace of currently executing code.
.ie n .IP "$DB::filename" 8
.el .IP "\f(CW$DB::filename\fR" 8
.IX Item "$DB::filename"
Currently loaded filename.
.ie n .IP "$DB::subname" 8
.el .IP "\f(CW$DB::subname\fR" 8
.IX Item "$DB::subname"
Fully qualified name of currently executing subroutine.
.ie n .IP "$DB::lineno" 8
.el .IP "\f(CW$DB::lineno\fR" 8
.IX Item "$DB::lineno"
Line number that will be executed next.
.SS "\s-1API\s0 Methods"
.IX Subsection "API Methods"
The following are methods in the \s-1DB\s0 base class.  A client must
access these methods by inheritance (*not* by calling them directly),
since the \s-1API\s0 keeps track of clients through the inheritance
mechanism.
.IP "\s-1CLIENT\-\s0>\fIregister()\fR" 8
.IX Item "CLIENT->register()"
register a client object/package
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
eval \s-1STRING\s0 in executing code context
.IP "\s-1CLIENT\-\s0>skippkg('D::hide')" 8
.IX Item "CLIENT->skippkg('D::hide')"
ask \s-1DB\s0 not to stop in these packages
.IP "\s-1CLIENT\-\s0>\fIrun()\fR" 8
.IX Item "CLIENT->run()"
run some more (until a breakpt is reached)
.IP "\s-1CLIENT\-\s0>\fIstep()\fR" 8
.IX Item "CLIENT->step()"
single step
.IP "\s-1CLIENT\-\s0>\fInext()\fR" 8
.IX Item "CLIENT->next()"
step over
.IP "\s-1CLIENT\-\s0>\fIdone()\fR" 8
.IX Item "CLIENT->done()"
de-register from the debugging \s-1API\s0
.SS "Client Callback Methods"
.IX Subsection "Client Callback Methods"
The following \*(L"virtual\*(R" methods can be defined by the client.  They will
be called by the \s-1API\s0 at appropriate points.  Note that unless specified
otherwise, the debug \s-1API\s0 only defines empty, non-functional default versions
of these methods.
.IP "\s-1CLIENT\-\s0>\fIinit()\fR" 8
.IX Item "CLIENT->init()"
Called after debug \s-1API\s0 inits itself.
.IP "\s-1CLIENT\-\s0>prestop([\s-1STRING\s0])" 8
.IX Item "CLIENT->prestop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the prestop action string.
.IP "\s-1CLIENT\-\s0>\fIstop()\fR" 8
.IX Item "CLIENT->stop()"
Called when execution stops (w/ args file, line).
.IP "\s-1CLIENT\-\s0>\fIidle()\fR" 8
.IX Item "CLIENT->idle()"
Called while stopped (can be a client event loop).
.IP "\s-1CLIENT\-\s0>poststop([\s-1STRING\s0])" 8
.IX Item "CLIENT->poststop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the poststop action string.
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
Usually inherited from \s-1DB\s0 package.  Ask for a \s-1STRING\s0 to be \f(CW\*(C`eval\*(C'\fR\-ed
in executing code context.
.IP "\s-1CLIENT\-\s0>\fIcleanup()\fR" 8
.IX Item "CLIENT->cleanup()"
Called just before exit.
.IP "\s-1CLIENT\-\s0>output(\s-1LIST\s0)" 8
.IX Item "CLIENT->output(LIST)"
Called when \s-1API\s0 must show a message (warnings, errors etc.).
.SH "BUGS"
.IX Header "BUGS"
The interface defined by this module is missing some of the later additions
to perl's debugging functionality.  As such, this interface should be considered
highly experimental and subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy	gsar@activestate.com
.PP
This code heavily adapted from an early version of perl5db.pl attributable
to Larry Wall and the Perl Porters.
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DB5.16.3pm                                   0100644 0001750 0001750 00000030044 12566207432 022100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DB 3pm"
.TH DB 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DB \- programmatic interface to the Perl debugging API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package CLIENT;
\&    use DB;
\&    @ISA = qw(DB);
\&
\&    # these (inherited) methods can be called by the client
\&
\&    CLIENT\->register()      # register a client package name
\&    CLIENT\->done()          # de\-register from the debugging API
\&    CLIENT\->skippkg(\*(Aqhide::hide\*(Aq)  # ask DB not to stop in this package
\&    CLIENT\->cont([WHERE])       # run some more (until BREAK or another breakpt)
\&    CLIENT\->step()              # single step
\&    CLIENT\->next()              # step over
\&    CLIENT\->ret()               # return from current subroutine
\&    CLIENT\->backtrace()         # return the call stack description
\&    CLIENT\->ready()             # call when client setup is done
\&    CLIENT\->trace_toggle()      # toggle subroutine call trace mode
\&    CLIENT\->subs([SUBS])        # return subroutine information
\&    CLIENT\->files()             # return list of all files known to DB
\&    CLIENT\->lines()             # return lines in currently loaded file
\&    CLIENT\->loadfile(FILE,LINE) # load a file and let other clients know
\&    CLIENT\->lineevents()        # return info on lines with actions
\&    CLIENT\->set_break([WHERE],[COND])
\&    CLIENT\->set_tbreak([WHERE])
\&    CLIENT\->clr_breaks([LIST])
\&    CLIENT\->set_action(WHERE,ACTION)
\&    CLIENT\->clr_actions([LIST])
\&    CLIENT\->evalcode(STRING)  # eval STRING in executing code\*(Aqs context
\&    CLIENT\->prestop([STRING]) # execute in code context before stopping
\&    CLIENT\->poststop([STRING])# execute in code context before resuming
\&
\&    # These methods will be called at the appropriate times.
\&    # Stub versions provided do nothing.
\&    # None of these can block.
\&
\&    CLIENT\->init()          # called when debug API inits itself
\&    CLIENT\->stop(FILE,LINE) # when execution stops
\&    CLIENT\->idle()          # while stopped (can be a client event loop)
\&    CLIENT\->cleanup()       # just before exit
\&    CLIENT\->output(LIST)    # called to print any output that API must show
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl debug information is frequently required not just by debuggers,
but also by modules that need some \*(L"special\*(R" information to do their
job properly, like profilers.
.PP
This module abstracts and provides all of the hooks into Perl internal
debugging functionality, so that various implementations of Perl debuggers
(or packages that want to simply get at the \*(L"privileged\*(R" debugging data)
can all benefit from the development of this common code.  Currently used
by Swat, the perl/Tk \s-1GUI\s0 debugger.
.PP
Note that multiple \*(L"front-ends\*(R" can latch into this debugging \s-1API\s0
simultaneously.  This is intended to facilitate things like
debugging with a command line and \s-1GUI\s0 at the same time, debugging 
debuggers etc.  [Sounds nice, but this needs some serious support \*(-- \s-1GSAR\s0]
.PP
In particular, this \s-1API\s0 does \fBnot\fR provide the following functions:
.IP "\(bu" 4
data display
.IP "\(bu" 4
command processing
.IP "\(bu" 4
command alias management
.IP "\(bu" 4
user interface (tty or graphical)
.PP
These are intended to be services performed by the clients of this \s-1API\s0.
.PP
This module attempts to be squeaky clean w.r.t \f(CW\*(C`use strict;\*(C'\fR and when
warnings are enabled.
.SS "Global Variables"
.IX Subsection "Global Variables"
The following \*(L"public\*(R" global names can be read by clients of this \s-1API\s0.
Beware that these should be considered \*(L"readonly\*(R".
.ie n .IP "$DB::sub" 8
.el .IP "\f(CW$DB::sub\fR" 8
.IX Item "$DB::sub"
Name of current executing subroutine.
.ie n .IP "%DB::sub" 8
.el .IP "\f(CW%DB::sub\fR" 8
.IX Item "%DB::sub"
The keys of this hash are the names of all the known subroutines.  Each value
is an encoded string that has the \fIsprintf\fR\|(3) format 
\&\f(CW\*(C`("%s:%d\-%d", filename, fromline, toline)\*(C'\fR.
.ie n .IP "$DB::single" 8
.el .IP "\f(CW$DB::single\fR" 8
.IX Item "$DB::single"
Single-step flag.  Will be true if the \s-1API\s0 will stop at the next statement.
.ie n .IP "$DB::signal" 8
.el .IP "\f(CW$DB::signal\fR" 8
.IX Item "$DB::signal"
Signal flag. Will be set to a true value if a signal was caught.  Clients may
check for this flag to abort time-consuming operations.
.ie n .IP "$DB::trace" 8
.el .IP "\f(CW$DB::trace\fR" 8
.IX Item "$DB::trace"
This flag is set to true if the \s-1API\s0 is tracing through subroutine calls.
.ie n .IP "@DB::args" 8
.el .IP "\f(CW@DB::args\fR" 8
.IX Item "@DB::args"
Contains the arguments of current subroutine, or the \f(CW@ARGV\fR array if in the 
toplevel context.
.ie n .IP "@DB::dbline" 8
.el .IP "\f(CW@DB::dbline\fR" 8
.IX Item "@DB::dbline"
List of lines in currently loaded file.
.ie n .IP "%DB::dbline" 8
.el .IP "\f(CW%DB::dbline\fR" 8
.IX Item "%DB::dbline"
Actions in current file (keys are line numbers).  The values are strings that
have the \fIsprintf\fR\|(3) format \f(CW\*(C`("%s\e000%s", breakcondition, actioncode)\*(C'\fR.
.ie n .IP "$DB::package" 8
.el .IP "\f(CW$DB::package\fR" 8
.IX Item "$DB::package"
Package namespace of currently executing code.
.ie n .IP "$DB::filename" 8
.el .IP "\f(CW$DB::filename\fR" 8
.IX Item "$DB::filename"
Currently loaded filename.
.ie n .IP "$DB::subname" 8
.el .IP "\f(CW$DB::subname\fR" 8
.IX Item "$DB::subname"
Fully qualified name of currently executing subroutine.
.ie n .IP "$DB::lineno" 8
.el .IP "\f(CW$DB::lineno\fR" 8
.IX Item "$DB::lineno"
Line number that will be executed next.
.SS "\s-1API\s0 Methods"
.IX Subsection "API Methods"
The following are methods in the \s-1DB\s0 base class.  A client must
access these methods by inheritance (*not* by calling them directly),
since the \s-1API\s0 keeps track of clients through the inheritance
mechanism.
.IP "\s-1CLIENT\-\s0>\fIregister()\fR" 8
.IX Item "CLIENT->register()"
register a client object/package
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
eval \s-1STRING\s0 in executing code context
.IP "\s-1CLIENT\-\s0>skippkg('D::hide')" 8
.IX Item "CLIENT->skippkg('D::hide')"
ask \s-1DB\s0 not to stop in these packages
.IP "\s-1CLIENT\-\s0>\fIrun()\fR" 8
.IX Item "CLIENT->run()"
run some more (until a breakpt is reached)
.IP "\s-1CLIENT\-\s0>\fIstep()\fR" 8
.IX Item "CLIENT->step()"
single step
.IP "\s-1CLIENT\-\s0>\fInext()\fR" 8
.IX Item "CLIENT->next()"
step over
.IP "\s-1CLIENT\-\s0>\fIdone()\fR" 8
.IX Item "CLIENT->done()"
de-register from the debugging \s-1API\s0
.SS "Client Callback Methods"
.IX Subsection "Client Callback Methods"
The following \*(L"virtual\*(R" methods can be defined by the client.  They will
be called by the \s-1API\s0 at appropriate points.  Note that unless specified
otherwise, the debug \s-1API\s0 only defines empty, non-functional default versions
of these methods.
.IP "\s-1CLIENT\-\s0>\fIinit()\fR" 8
.IX Item "CLIENT->init()"
Called after debug \s-1API\s0 inits itself.
.IP "\s-1CLIENT\-\s0>prestop([\s-1STRING\s0])" 8
.IX Item "CLIENT->prestop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the prestop action string.
.IP "\s-1CLIENT\-\s0>\fIstop()\fR" 8
.IX Item "CLIENT->stop()"
Called when execution stops (w/ args file, line).
.IP "\s-1CLIENT\-\s0>\fIidle()\fR" 8
.IX Item "CLIENT->idle()"
Called while stopped (can be a client event loop).
.IP "\s-1CLIENT\-\s0>poststop([\s-1STRING\s0])" 8
.IX Item "CLIENT->poststop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the poststop action string.
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
Usually inherited from \s-1DB\s0 package.  Ask for a \s-1STRING\s0 to be \f(CW\*(C`eval\*(C'\fR\-ed
in executing code context.
.IP "\s-1CLIENT\-\s0>\fIcleanup()\fR" 8
.IX Item "CLIENT->cleanup()"
Called just before exit.
.IP "\s-1CLIENT\-\s0>output(\s-1LIST\s0)" 8
.IX Item "CLIENT->output(LIST)"
Called when \s-1API\s0 must show a message (warnings, errors etc.).
.SH "BUGS"
.IX Header "BUGS"
The interface defined by this module is missing some of the later additions
to perl's debugging functionality.  As such, this interface should be considered
highly experimental and subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy	gsar@activestate.com
.PP
This code heavily adapted from an early version of perl5db.pl attributable
to Larry Wall and the Perl Porters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DB5.18.3pm                                   0100644 0001750 0001750 00000030365 12566207453 022113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DB 3pm"
.TH DB 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DB \- programmatic interface to the Perl debugging API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package CLIENT;
\&    use DB;
\&    @ISA = qw(DB);
\&
\&    # these (inherited) methods can be called by the client
\&
\&    CLIENT\->register()      # register a client package name
\&    CLIENT\->done()          # de\-register from the debugging API
\&    CLIENT\->skippkg(\*(Aqhide::hide\*(Aq)  # ask DB not to stop in this package
\&    CLIENT\->cont([WHERE])       # run some more (until BREAK or another breakpt)
\&    CLIENT\->step()              # single step
\&    CLIENT\->next()              # step over
\&    CLIENT\->ret()               # return from current subroutine
\&    CLIENT\->backtrace()         # return the call stack description
\&    CLIENT\->ready()             # call when client setup is done
\&    CLIENT\->trace_toggle()      # toggle subroutine call trace mode
\&    CLIENT\->subs([SUBS])        # return subroutine information
\&    CLIENT\->files()             # return list of all files known to DB
\&    CLIENT\->lines()             # return lines in currently loaded file
\&    CLIENT\->loadfile(FILE,LINE) # load a file and let other clients know
\&    CLIENT\->lineevents()        # return info on lines with actions
\&    CLIENT\->set_break([WHERE],[COND])
\&    CLIENT\->set_tbreak([WHERE])
\&    CLIENT\->clr_breaks([LIST])
\&    CLIENT\->set_action(WHERE,ACTION)
\&    CLIENT\->clr_actions([LIST])
\&    CLIENT\->evalcode(STRING)  # eval STRING in executing code\*(Aqs context
\&    CLIENT\->prestop([STRING]) # execute in code context before stopping
\&    CLIENT\->poststop([STRING])# execute in code context before resuming
\&
\&    # These methods will be called at the appropriate times.
\&    # Stub versions provided do nothing.
\&    # None of these can block.
\&
\&    CLIENT\->init()          # called when debug API inits itself
\&    CLIENT\->stop(FILE,LINE) # when execution stops
\&    CLIENT\->idle()          # while stopped (can be a client event loop)
\&    CLIENT\->cleanup()       # just before exit
\&    CLIENT\->output(LIST)    # called to print any output that API must show
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl debug information is frequently required not just by debuggers,
but also by modules that need some \*(L"special\*(R" information to do their
job properly, like profilers.
.PP
This module abstracts and provides all of the hooks into Perl internal
debugging functionality, so that various implementations of Perl debuggers
(or packages that want to simply get at the \*(L"privileged\*(R" debugging data)
can all benefit from the development of this common code.  Currently used
by Swat, the perl/Tk \s-1GUI\s0 debugger.
.PP
Note that multiple \*(L"front-ends\*(R" can latch into this debugging \s-1API\s0
simultaneously.  This is intended to facilitate things like
debugging with a command line and \s-1GUI\s0 at the same time, debugging 
debuggers etc.  [Sounds nice, but this needs some serious support \*(-- \s-1GSAR\s0]
.PP
In particular, this \s-1API\s0 does \fBnot\fR provide the following functions:
.IP "\(bu" 4
data display
.IP "\(bu" 4
command processing
.IP "\(bu" 4
command alias management
.IP "\(bu" 4
user interface (tty or graphical)
.PP
These are intended to be services performed by the clients of this \s-1API.\s0
.PP
This module attempts to be squeaky clean w.r.t \f(CW\*(C`use strict;\*(C'\fR and when
warnings are enabled.
.SS "Global Variables"
.IX Subsection "Global Variables"
The following \*(L"public\*(R" global names can be read by clients of this \s-1API.\s0
Beware that these should be considered \*(L"readonly\*(R".
.ie n .IP "$DB::sub" 8
.el .IP "\f(CW$DB::sub\fR" 8
.IX Item "$DB::sub"
Name of current executing subroutine.
.ie n .IP "%DB::sub" 8
.el .IP "\f(CW%DB::sub\fR" 8
.IX Item "%DB::sub"
The keys of this hash are the names of all the known subroutines.  Each value
is an encoded string that has the \fIsprintf\fR\|(3) format 
\&\f(CW\*(C`("%s:%d\-%d", filename, fromline, toline)\*(C'\fR.
.ie n .IP "$DB::single" 8
.el .IP "\f(CW$DB::single\fR" 8
.IX Item "$DB::single"
Single-step flag.  Will be true if the \s-1API\s0 will stop at the next statement.
.ie n .IP "$DB::signal" 8
.el .IP "\f(CW$DB::signal\fR" 8
.IX Item "$DB::signal"
Signal flag. Will be set to a true value if a signal was caught.  Clients may
check for this flag to abort time-consuming operations.
.ie n .IP "$DB::trace" 8
.el .IP "\f(CW$DB::trace\fR" 8
.IX Item "$DB::trace"
This flag is set to true if the \s-1API\s0 is tracing through subroutine calls.
.ie n .IP "@DB::args" 8
.el .IP "\f(CW@DB::args\fR" 8
.IX Item "@DB::args"
Contains the arguments of current subroutine, or the \f(CW@ARGV\fR array if in the 
toplevel context.
.ie n .IP "@DB::dbline" 8
.el .IP "\f(CW@DB::dbline\fR" 8
.IX Item "@DB::dbline"
List of lines in currently loaded file.
.ie n .IP "%DB::dbline" 8
.el .IP "\f(CW%DB::dbline\fR" 8
.IX Item "%DB::dbline"
Actions in current file (keys are line numbers).  The values are strings that
have the \fIsprintf\fR\|(3) format \f(CW\*(C`("%s\e000%s", breakcondition, actioncode)\*(C'\fR.
.ie n .IP "$DB::package" 8
.el .IP "\f(CW$DB::package\fR" 8
.IX Item "$DB::package"
Package namespace of currently executing code.
.ie n .IP "$DB::filename" 8
.el .IP "\f(CW$DB::filename\fR" 8
.IX Item "$DB::filename"
Currently loaded filename.
.ie n .IP "$DB::subname" 8
.el .IP "\f(CW$DB::subname\fR" 8
.IX Item "$DB::subname"
Fully qualified name of currently executing subroutine.
.ie n .IP "$DB::lineno" 8
.el .IP "\f(CW$DB::lineno\fR" 8
.IX Item "$DB::lineno"
Line number that will be executed next.
.SS "\s-1API\s0 Methods"
.IX Subsection "API Methods"
The following are methods in the \s-1DB\s0 base class.  A client must
access these methods by inheritance (*not* by calling them directly),
since the \s-1API\s0 keeps track of clients through the inheritance
mechanism.
.IP "\s-1CLIENT\-\s0>\fIregister()\fR" 8
.IX Item "CLIENT->register()"
register a client object/package
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
eval \s-1STRING\s0 in executing code context
.IP "\s-1CLIENT\-\s0>skippkg('D::hide')" 8
.IX Item "CLIENT->skippkg('D::hide')"
ask \s-1DB\s0 not to stop in these packages
.IP "\s-1CLIENT\-\s0>\fIrun()\fR" 8
.IX Item "CLIENT->run()"
run some more (until a breakpt is reached)
.IP "\s-1CLIENT\-\s0>\fIstep()\fR" 8
.IX Item "CLIENT->step()"
single step
.IP "\s-1CLIENT\-\s0>\fInext()\fR" 8
.IX Item "CLIENT->next()"
step over
.IP "\s-1CLIENT\-\s0>\fIdone()\fR" 8
.IX Item "CLIENT->done()"
de-register from the debugging \s-1API\s0
.SS "Client Callback Methods"
.IX Subsection "Client Callback Methods"
The following \*(L"virtual\*(R" methods can be defined by the client.  They will
be called by the \s-1API\s0 at appropriate points.  Note that unless specified
otherwise, the debug \s-1API\s0 only defines empty, non-functional default versions
of these methods.
.IP "\s-1CLIENT\-\s0>\fIinit()\fR" 8
.IX Item "CLIENT->init()"
Called after debug \s-1API\s0 inits itself.
.IP "\s-1CLIENT\-\s0>prestop([\s-1STRING\s0])" 8
.IX Item "CLIENT->prestop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the prestop action string.
.IP "\s-1CLIENT\-\s0>\fIstop()\fR" 8
.IX Item "CLIENT->stop()"
Called when execution stops (w/ args file, line).
.IP "\s-1CLIENT\-\s0>\fIidle()\fR" 8
.IX Item "CLIENT->idle()"
Called while stopped (can be a client event loop).
.IP "\s-1CLIENT\-\s0>poststop([\s-1STRING\s0])" 8
.IX Item "CLIENT->poststop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments are passed,
returns the poststop action string.
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
Usually inherited from \s-1DB\s0 package.  Ask for a \s-1STRING\s0 to be \f(CW\*(C`eval\*(C'\fR\-ed
in executing code context.
.IP "\s-1CLIENT\-\s0>\fIcleanup()\fR" 8
.IX Item "CLIENT->cleanup()"
Called just before exit.
.IP "\s-1CLIENT\-\s0>output(\s-1LIST\s0)" 8
.IX Item "CLIENT->output(LIST)"
Called when \s-1API\s0 must show a message (warnings, errors etc.).
.SH "BUGS"
.IX Header "BUGS"
The interface defined by this module is missing some of the later additions
to perl's debugging functionality.  As such, this interface should be considered
highly experimental and subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy	gsar@activestate.com
.PP
This code heavily adapted from an early version of perl5db.pl attributable
to Larry Wall and the Perl Porters.
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::DBM.3pm                                 0100644 0001750 0001750 00000123730 12566241601 022402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::DBM 3"
.TH DBD::DBM 3 "2013-09-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::DBM \- a DBI driver for DBM & MLDBM files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use DBI;
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                    # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(AqDBI:DBM(RaiseError=1):\*(Aq);      # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_type=DB_File\*(Aq);    # defaults to DB_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # MLDBM with SDBM_File
\&
\& # or
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef);
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     f_ext              => \*(Aq.db/r\*(Aq,
\&     f_dir              => \*(Aq/path/to/dbfiles/\*(Aq,
\&     f_lockfile         => \*(Aq.lck\*(Aq,
\&     dbm_type           => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm          => \*(AqFreezeThaw\*(Aq,
\&     dbm_store_metadata => 1,
\&     dbm_berkeley_flags => {
\&         \*(Aq\-Cachesize\*(Aq => 1000, # set a ::Hash flag
\&     },
\& });
.Ve
.PP
and other variations on \fIconnect()\fR as shown in the \s-1DBI\s0 docs,
DBD::File metadata and \*(L"Metadata\*(R"
shown below.
.PP
Use standard \s-1DBI\s0 prepare, execute, fetch, placeholders, etc.,
see \*(L"\s-1QUICK START\*(R"\s0 for an example.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBD::DBM\s0 is a database management system that works right out of the
box.  If you have a standard installation of Perl and \s-1DBI\s0 you can
begin creating, accessing, and modifying simple database tables
without any further modules.  You can add other modules (e.g.,
SQL::Statement, DB_File etc) for improved functionality.
.PP
The module uses a \s-1DBM\s0 file storage layer.  \s-1DBM\s0 file storage is common on
many platforms and files can be created with it in many programming
languages using different APIs. That means, in addition to creating
files with \s-1DBI/SQL,\s0 you can also use \s-1DBI/SQL\s0 to access and modify files
created by other \s-1DBM\s0 modules and programs and vice versa. \fBNote\fR that
in those cases it might be necessary to use a common subset of the
provided features.
.PP
\&\s-1DBM\s0 files are stored in binary format optimized for quick retrieval
when using a key field.  That optimization can be used advantageously
to make \s-1DBD::DBM SQL\s0 operations that use key fields very fast.  There
are several different \*(L"flavors\*(R" of \s-1DBM\s0 which use different storage
formats supported by perl modules such as SDBM_File and \s-1MLDBM. \s0 This
module supports all of the flavors that perl supports and, when used
with \s-1MLDBM,\s0 supports tables with any number of columns and insertion
of Perl objects into tables.
.PP
\&\s-1DBD::DBM\s0 has been tested with the following \s-1DBM\s0 types: SDBM_File,
NDBM_File, ODBM_File, GDBM_File, DB_File, BerkeleyDB.  Each type was
tested both with and without \s-1MLDBM\s0 and with the Data::Dumper,
Storable, FreezeThaw, \s-1YAML\s0 and \s-1JSON\s0 serializers using the DBI::SQL::Nano
or the SQL::Statement engines.
.SH "QUICK START"
.IX Header "QUICK START"
\&\s-1DBD::DBM\s0 operates like all other \s-1DBD\s0 drivers \- it's basic syntax and
operation is specified by \s-1DBI. \s0 If you're not familiar with \s-1DBI,\s0 you should
start by reading \s-1DBI\s0 and the documents it points to and then come back
and read this file.  If you are familiar with \s-1DBI,\s0 you already know most of
what you need to know to operate this module.  Just jump in and create a
test script something like the one shown below.
.PP
You should be aware that there are several options for the \s-1SQL\s0 engine
underlying \s-1DBD::DBM,\s0 see \*(L"Supported \s-1SQL\s0 syntax\*(R".  There are also many
options for \s-1DBM\s0 support, see especially the section on \*(L"Adding
multi-column support with \s-1MLDBM\*(R"\s0.
.PP
But here's a sample to get you started.
.PP
.Vb 10
\& use DBI;
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->{RaiseError} = 1;
\& for my $sql( split /;\en+/,"
\&     CREATE TABLE user ( user_name TEXT, phone TEXT );
\&     INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\&     INSERT INTO user VALUES (\*(AqSanjay Patel\*(Aq,\*(Aq777\-3333\*(Aq);
\&     INSERT INTO user VALUES (\*(AqJunk\*(Aq,\*(Aqxxx\-xxxx\*(Aq);
\&     DELETE FROM user WHERE user_name = \*(AqJunk\*(Aq;
\&     UPDATE user SET phone = \*(Aq999\-4444\*(Aq WHERE user_name = \*(AqSanjay Patel\*(Aq;
\&     SELECT * FROM user
\& "){
\&     my $sth = $dbh\->prepare($sql);
\&     $sth\->execute;
\&     $sth\->dump_results if $sth\->{NUM_OF_FIELDS};
\& }
\& $dbh\->disconnect;
.Ve
.SH "USAGE"
.IX Header "USAGE"
This section will explain some usage cases in more detail. To get an
overview about the available attributes, see \*(L"Metadata\*(R".
.SS "Specifying Files and Directories"
.IX Subsection "Specifying Files and Directories"
\&\s-1DBD::DBM\s0 will automatically supply an appropriate file extension for the
type of \s-1DBM\s0 you are using.  For example, if you use SDBM_File, a table
called \*(L"fruit\*(R" will be stored in two files called \*(L"fruit.pag\*(R" and
\&\*(L"fruit.dir\*(R".  You should \fBnever\fR specify the file extensions in your \s-1SQL\s0
statements.
.PP
\&\s-1DBD::DBM\s0 recognizes following default extensions for following types:
.IP ".pag/r" 4
.IX Item ".pag/r"
Chosen for dbm_type \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR
when an implementation is detected which wraps \f(CW\*(C`\-ldbm\*(C'\fR for
\&\f(CW\*(C`NDBM_File\*(C'\fR (e.g. Solaris, \s-1AIX, ...\s0).
.Sp
For those types, the \f(CW\*(C`.dir\*(C'\fR extension is recognized, too (for being
deleted when dropping a table).
.IP ".db/r" 4
.IX Item ".db/r"
Chosen for dbm_type \f(CW\*(C`NDBM_File\*(C'\fR when an implementation is detected
which wraps BerkeleyDB 1.x for \f(CW\*(C`NDBM_File\*(C'\fR (typically \s-1BSD\s0's, Darwin).
.PP
\&\f(CW\*(C`GDBM_File\*(C'\fR, \f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR don't usually
use a file extension.
.PP
If your \s-1DBM\s0 type uses an extension other than one of the recognized
types of extensions, you should set the \fIf_ext\fR attribute to the
extension \fBand\fR file a bug report as described in \s-1DBI\s0 with the name
of the implementation and extension so we can add it to \s-1DBD::DBM.\s0
Thanks in advance for that :\-).
.PP
.Vb 2
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=.db\*(Aq);  # .db extension is used
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=\*(Aq);     # no extension is used
\&
\&  # or
\&  $dbh\->{f_ext}=\*(Aq.db\*(Aq;                       # global setting
\&  $dbh\->{f_meta}\->{\*(Aqqux\*(Aq}\->{f_ext}=\*(Aq.db\*(Aq;    # setting for table \*(Aqqux\*(Aq
.Ve
.PP
By default files are assumed to be in the current working directory.
To use other directories specify the \fIf_dir\fR attribute in either the
connect string or by setting the database handle attribute.
.PP
For example, this will look for the file /foo/bar/fruit (or
/foo/bar/fruit.pag for \s-1DBM\s0 types that use that extension)
.PP
.Vb 6
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:f_dir=/foo/bar\*(Aq);
\&  # and this will too:
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&  $dbh\->{f_dir} = \*(Aq/foo/bar\*(Aq;
\&  # but this is recommended
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { f_dir => \*(Aq/foo/bar\*(Aq } );
\&
\&  # now you can do
\&  my $ary = $dbh\->selectall_arrayref(q{ SELECT x FROM fruit });
.Ve
.PP
You can also use delimited identifiers to specify paths directly in \s-1SQL\s0
statements.  This looks in the same place as the two examples above but
without setting \fIf_dir\fR:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT x FROM "/foo/bar/fruit"
\&   });
.Ve
.PP
You can also tell \s-1DBD::DBM\s0 to use a specified path for a specific table:
.PP
.Vb 1
\&  $dbh\->{dbm_tables}\->{f}\->{file} = q(/foo/bar/fruit);
.Ve
.PP
Please be aware that you cannot specify this during connection.
.PP
If you have SQL::Statement installed, you can use table aliases:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT f.x FROM "/foo/bar/fruit" AS f
\&   });
.Ve
.PP
See the \*(L"\s-1GOTCHAS AND WARNINGS\*(R"\s0 for using \s-1DROP\s0 on tables.
.SS "Table locking and \fIflock()\fP"
.IX Subsection "Table locking and flock()"
Table locking is accomplished using a lockfile which has the same
basename as the table's file but with the file extension '.lck' (or a
lockfile extension that you supply, see below).  This lock file is
created with the table during a \s-1CREATE\s0 and removed during a \s-1DROP.\s0
Every time the table itself is opened, the lockfile is \fIflocked()\fR.  For
\&\s-1SELECT,\s0 this is a shared lock.  For all other operations, it is an
exclusive lock (except when you specify something different using the
\&\fIf_lock\fR attribute).
.PP
Since the locking depends on \fIflock()\fR, it only works on operating
systems that support \fIflock()\fR.  In cases where \fIflock()\fR is not
implemented, \s-1DBD::DBM\s0 will simply behave as if the \fIflock()\fR had
occurred although no actual locking will happen.  Read the
documentation for \fIflock()\fR for more information.
.PP
Even on those systems that do support \fIflock()\fR, locking is only
advisory \- as is always the case with \fIflock()\fR.  This means that if
another program tries to access the table file while \s-1DBD::DBM\s0 has the
table locked, that other program will *succeed* at opening unless
it is also using flock on the '.lck' file.  As a result \s-1DBD::DBM\s0's
locking only really applies to other programs using \s-1DBD::DBM\s0 or other
program written to cooperate with \s-1DBD::DBM\s0 locking.
.SS "Specifying the \s-1DBM\s0 type"
.IX Subsection "Specifying the DBM type"
Each \*(L"flavor\*(R" of \s-1DBM\s0 stores its files in a different format and has
different capabilities and limitations. See AnyDBM_File for a
comparison of \s-1DBM\s0 types.
.PP
By default, \s-1DBD::DBM\s0 uses the \f(CW\*(C`SDBM_File\*(C'\fR type of storage since
\&\f(CW\*(C`SDBM_File\*(C'\fR comes with Perl itself. If you have other types of
\&\s-1DBM\s0 storage available, you can use any of them with \s-1DBD::DBM.\s0 It is
strongly recommended to use at least \f(CW\*(C`DB_File\*(C'\fR, because \f(CW\*(C`SDBM_File\*(C'\fR has quirks and limitations and \f(CW\*(C`ODBM_file\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR and \f(CW\*(C`GDBM_File\*(C'\fR are not always available.
.PP
You can specify the \s-1DBM\s0 type using the \fIdbm_type\fR attribute which can
be set in the connection string or with \f(CW\*(C`$dbh\->{dbm_type}\*(C'\fR and
\&\f(CW\*(C`$dbh\->{f_meta}\->{$table_name}\->{type}\*(C'\fR for per-table settings in
cases where a single script is accessing more than one kind of \s-1DBM\s0
file.
.PP
In the connection string, just set \f(CW\*(C`dbm_type=TYPENAME\*(C'\fR where
\&\f(CW\*(C`TYPENAME\*(C'\fR is any \s-1DBM\s0 type such as GDBM_File, DB_File, etc. Do \fInot\fR
use \s-1MLDBM\s0 as your \fIdbm_type\fR as that is set differently, see below.
.PP
.Vb 2
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                # uses the default SDBM_File
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_type=GDBM_File\*(Aq); # uses the GDBM_File
\&
\& # You can also use $dbh\->{dbm_type} to set the DBM type for the connection:
\& $dbh\->{dbm_type} = \*(AqDB_File\*(Aq;    # set the global DBM type
\& print $dbh\->{dbm_type};          # display the global DBM type
.Ve
.PP
If you have several tables in your script that use different \s-1DBM\s0
types, you can use the \f(CW$dbh\fR\->{dbm_tables} hash to store different
settings for the various tables.  You can even use this to perform
joins on files that have completely different storage mechanisms.
.PP
.Vb 2
\& # sets global default of GDBM_File
\& my $dbh\->(\*(Aqdbi:DBM:type=GDBM_File\*(Aq);
\&
\& # overrides the global setting, but only for the tables called
\& # I<foo> and I<bar>
\& my $dbh\->{f_meta}\->{foo}\->{dbm_type} = \*(AqDB_File\*(Aq;
\& my $dbh\->{f_meta}\->{bar}\->{dbm_type} = \*(AqBerkeleyDB\*(Aq;
\&
\& # prints the dbm_type for the table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{dbm_type};
.Ve
.PP
\&\fBNote\fR that you must change the \fIdbm_type\fR of a table before you access
it for first time.
.SS "Adding multi-column support with \s-1MLDBM\s0"
.IX Subsection "Adding multi-column support with MLDBM"
Most of the \s-1DBM\s0 types only support two columns and even if it would
support more, \s-1DBD::DBM\s0 would only use two. However a \s-1CPAN\s0 module
called \s-1MLDBM\s0 overcomes this limitation by allowing more than two
columns.  \s-1MLDBM\s0 does this by serializing the data \- basically it puts
a reference to an array into the second column. It can also put almost
any kind of Perl object or even \fBPerl coderefs\fR into columns.
.PP
If you want more than two columns, you \fBmust\fR install \s-1MLDBM.\s0 It's available
for many platforms and is easy to install.
.PP
\&\s-1MLDBM\s0 is by default distributed with three serializers \- Data::Dumper,
Storable, and FreezeThaw. Data::Dumper is the default and Storable is the
fastest. \s-1MLDBM\s0 can also make use of user-defined serialization methods or
other serialization modules (e.g. \s-1YAML::MLDBM\s0 or
MLDBM::Serializer::JSON. You select the serializer using the
\&\fIdbm_mldbm\fR attribute.
.PP
Some examples:
.PP
.Vb 10
\& $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # use MLDBM with Storable
\& $dbh=DBI\->connect(
\&    \*(Aqdbi:DBM:dbm_mldbm=MySerializer\*(Aq # use MLDBM with a user defined module
\& );
\& $dbh=DBI\->connect(\*(Aqdbi::dbm:\*(Aq, undef,
\&     undef, { dbm_mldbm => \*(AqYAML\*(Aq }); # use 3rd party serializer
\& $dbh\->{dbm_mldbm} = \*(AqYAML\*(Aq; # same as above
\& print $dbh\->{dbm_mldbm} # show the MLDBM serializer
\& $dbh\->{f_meta}\->{foo}\->{dbm_mldbm}=\*(AqData::Dumper\*(Aq;   # set Data::Dumper for table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{mldbm}; # show serializer for table "foo"
.Ve
.PP
\&\s-1MLDBM\s0 works on top of other \s-1DBM\s0 modules so you can also set a \s-1DBM\s0 type
along with setting dbm_mldbm.  The examples above would default to using
SDBM_File with \s-1MLDBM. \s0 If you wanted GDBM_File instead, here's how:
.PP
.Vb 5
\& # uses DB_File with MLDBM and Storable
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqDB_File\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\& });
.Ve
.PP
SDBM_File, the default \fIdbm_type\fR is quite limited, so if you are going to
use \s-1MLDBM,\s0 you should probably use a different type, see AnyDBM_File.
.PP
See below for some \*(L"\s-1GOTCHAS AND WARNINGS\*(R"\s0 about \s-1MLDBM.\s0
.SS "Support for Berkeley \s-1DB\s0"
.IX Subsection "Support for Berkeley DB"
The Berkeley \s-1DB\s0 storage type is supported through two different Perl
modules \- DB_File (which supports only features in old versions of Berkeley
\&\s-1DB\s0) and BerkeleyDB (which supports all versions).  \s-1DBD::DBM\s0 supports
specifying either \*(L"DB_File\*(R" or \*(L"BerkeleyDB\*(R" as a \fIdbm_type\fR, with or
without \s-1MLDBM\s0 support.
.PP
The \*(L"BerkeleyDB\*(R" dbm_type is experimental and it's interface is likely to
change.  It currently defaults to BerkeleyDB::Hash and does not currently
support ::Btree or ::Recno.
.PP
With BerkeleyDB, you can specify initialization flags by setting them in
your script like this:
.PP
.Vb 12
\& use BerkeleyDB;
\& my $env = new BerkeleyDB::Env \-Home => $dir;  # and/or other Env flags
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\&     dbm_berkeley_flags => {
\&         \*(AqDB_CREATE\*(Aq  => DB_CREATE,  # pass in constants
\&         \*(AqDB_RDONLY\*(Aq  => DB_RDONLY,  # pass in constants
\&         \*(Aq\-Cachesize\*(Aq => 1000,       # set a ::Hash flag
\&         \*(Aq\-Env\*(Aq       => $env,       # pass in an environment
\&     },
\& });
.Ve
.PP
Do \fInot\fR set the \-Flags or \-Filename flags as those are determined and
overwritten by the \s-1SQL \s0(e.g. \-Flags => \s-1DB_RDONLY\s0 is set automatically
when you issue a \s-1SELECT\s0 statement).
.PP
Time has not permitted us to provide support in this release of \s-1DBD::DBM\s0
for further Berkeley \s-1DB\s0 features such as transactions, concurrency,
locking, etc. We will be working on these in the future and would value
suggestions, patches, etc.
.PP
See DB_File and BerkeleyDB for further details.
.SS "Optimizing the use of key fields"
.IX Subsection "Optimizing the use of key fields"
Most \*(L"flavors\*(R" of \s-1DBM\s0 have only two physical columns (but can contain
multiple logical columns as explained above in
\&\*(L"Adding multi-column support with \s-1MLDBM\*(R"\s0). They work similarly to a
Perl hash with the first column serving as the key. Like a Perl hash, \s-1DBM\s0
files permit you to do quick lookups by specifying the key and thus avoid
looping through all records (supported by DBI::SQL::Nano only). Also like
a Perl hash, the keys must be unique. It is impossible to create two
records with the same key.  To put this more simply and in \s-1SQL\s0 terms,
the key column functions as the \fI\s-1PRIMARY KEY\s0\fR or \s-1UNIQUE INDEX.\s0
.PP
In \s-1DBD::DBM,\s0 you can take advantage of the speed of keyed lookups by using
DBI::SQL::Nano and a \s-1WHERE\s0 clause with a single equal comparison on the key
field. For example, the following \s-1SQL\s0 statements are optimized for keyed
lookup:
.PP
.Vb 4
\& CREATE TABLE user ( user_name TEXT, phone TEXT);
\& INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\& # ... many more inserts
\& SELECT phone FROM user WHERE user_name=\*(AqFred Bloggs\*(Aq;
.Ve
.PP
The \*(L"user_name\*(R" column is the key column since it is the first
column. The \s-1SELECT\s0 statement uses the key column in a single equal
comparison \- \*(L"user_name='Fred Bloggs'\*(R" \- so the search will find it
very quickly without having to loop through all the names which were
inserted into the table.
.PP
In contrast, these searches on the same table are not optimized:
.PP
.Vb 2
\& 1. SELECT phone FROM user WHERE user_name < \*(AqFred\*(Aq;
\& 2. SELECT user_name FROM user WHERE phone = \*(Aq233\-7777\*(Aq;
.Ve
.PP
In #1, the operation uses a less-than (<) comparison rather than an equals
comparison, so it will not be optimized for key searching.  In #2, the key
field \*(L"user_name\*(R" is not specified in the \s-1WHERE\s0 clause, and therefore the
search will need to loop through all rows to find the requested row(s).
.PP
\&\fBNote\fR that the underlying \s-1DBM\s0 storage needs to loop over all \fIkey/value\fR
pairs when the optimized fetch is used. SQL::Statement has a massively
improved where clause evaluation which costs around 15% of the evaluation
in DBI::SQL::Nano \- combined with the loop in the \s-1DBM\s0 storage the speed
improvement isn't so impressive.
.PP
Even if lookups are faster by around 50%, DBI::SQL::Nano and
SQL::Statement can benefit from the key field optimizations on
updating and deleting rows \- and here the improved where clause
evaluation of SQL::Statement might beat DBI::SQL::Nano every time the
where clause contains not only the key field (or more than one).
.SS "Supported \s-1SQL\s0 syntax"
.IX Subsection "Supported SQL syntax"
\&\s-1DBD::DBM\s0 uses a subset of \s-1SQL. \s0 The robustness of that subset depends on
what other modules you have installed. Both options support basic \s-1SQL\s0
operations including \s-1CREATE TABLE, DROP TABLE, INSERT, DELETE, UPDATE,\s0 and
\&\s-1SELECT.\s0
.PP
\&\fBOption #1:\fR By default, this module inherits its \s-1SQL\s0 support from
DBI::SQL::Nano that comes with \s-1DBI. \s0 Nano is, as its name implies, a *very*
small \s-1SQL\s0 engine.  Although limited in scope, it is faster than option #2
for some operations (especially single \fIprimary key\fR lookups). See
DBI::SQL::Nano for a description of the \s-1SQL\s0 it supports and comparisons
of it with option #2.
.PP
\&\fBOption #2:\fR If you install the pure Perl \s-1CPAN\s0 module SQL::Statement,
\&\s-1DBD::DBM\s0 will use it instead of Nano.  This adds support for table aliases,
functions, joins, and much more.  If you're going to use \s-1DBD::DBM\s0
for anything other than very simple tables and queries, you should install
SQL::Statement.  You don't have to change \s-1DBD::DBM\s0 or your scripts in any
way, simply installing SQL::Statement will give you the more robust \s-1SQL\s0
capabilities without breaking scripts written for DBI::SQL::Nano.  See
SQL::Statement for a description of the \s-1SQL\s0 it supports.
.PP
To find out which \s-1SQL\s0 module is working in a given script, you can use the
\&\fIdbm_versions()\fR method or, if you don't need the full output and version
numbers, just do this:
.PP
.Vb 1
\& print $dbh\->{sql_handler}, "\en";
.Ve
.PP
That will print out either \*(L"SQL::Statement\*(R" or \*(L"DBI::SQL::Nano\*(R".
.PP
Baring the section about optimized access to the \s-1DBM\s0 storage in mind,
comparing the benefits of both engines:
.PP
.Vb 6
\&  # DBI::SQL::Nano is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=15" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "delete from foo where key=27" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "select * from foo where key=\*(Aqabc\*(Aq" );
\&
\&  # SQL::Statement might faster (depending on DB size)
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=?" );
\&  $sth\->execute(15);
\&  $sth = $dbh\->prepare( "update foo set value=? where key=15" );
\&  $sth\->execute(\*(Aqnew\*(Aq);
\&  $sth = $dbh\->prepare( "delete from foo where key=?" );
\&  $sth\->execute(27);
\&
\&  # SQL::Statement is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where value=\*(Aqold\*(Aq" );
\&  $sth\->execute();
\&  # must be expressed using "where key = 15 or key = 27 or key = 42 or key = \*(Aqabc\*(Aq"
\&  # in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "delete from foo where key in (15,27,42,\*(Aqabc\*(Aq)" );
\&  $sth\->execute();
\&  # must be expressed using "where key > 10 and key < 90" in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "select * from foo where key between (10,90)" );
\&  $sth\->execute();
\&
\&  # only SQL::Statement can handle
\&  $sth\->prepare( "select * from foo,bar where foo.name = bar.name" );
\&  $sth\->execute();
\&  $sth\->prepare( "insert into foo values ( 1, \*(Aqfoo\*(Aq ), ( 2, \*(Aqbar\*(Aq )" );
\&  $sth\->execute();
.Ve
.SS "Specifying Column Names"
.IX Subsection "Specifying Column Names"
\&\s-1DBM\s0 files don't have a standard way to store column names.   \s-1DBD::DBM\s0 gets
around this issue with a \s-1DBD::DBM\s0 specific way of storing the column names.
\&\fBIf you are working only with \s-1DBD::DBM\s0 and not using files created by or
accessed with other \s-1DBM\s0 programs, you can ignore this section.\fR
.PP
\&\s-1DBD::DBM\s0 stores column names as a row in the file with the key \fI_metadata
\&\e0\fR.  So this code
.PP
.Vb 3
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->do("CREATE TABLE baz (foo CHAR(10), bar INTEGER)");
\& $dbh\->do("INSERT INTO baz (foo,bar) VALUES (\*(Aqzippy\*(Aq,1)");
.Ve
.PP
Will create a file that has a structure something like this:
.PP
.Vb 2
\&  _metadata \e0 | <dbd_metadata><schema></schema><col_names>foo,bar</col_names></dbd_metadata>
\&  zippy        | 1
.Ve
.PP
The next time you access this table with \s-1DBD::DBM,\s0 it will treat the
\&\fI_metadata \e0\fR row as a header rather than as data and will pull the column
names from there.  However, if you access the file with something other
than \s-1DBD::DBM,\s0 the row will be treated as a regular data row.
.PP
If you do not want the column names stored as a data row in the table you
can set the \fIdbm_store_metadata\fR attribute to 0.
.PP
.Vb 1
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { dbm_store_metadata => 0 });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\&
\& # or for per\-table setting
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
.Ve
.PP
By default, \s-1DBD::DBM\s0 assumes that you have two columns named \*(L"k\*(R" and \*(L"v\*(R"
(short for \*(L"key\*(R" and \*(L"value\*(R").  So if you have \fIdbm_store_metadata\fR set to
1 and you want to use alternate column names, you need to specify the
column names like this:
.PP
.Vb 4
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_store_metadata => 0,
\&     dbm_cols => [ qw(foo bar) ],
\& });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\& $dbh\->{dbm_cols}           = \*(Aqfoo,bar\*(Aq;
\&
\& # or to set the column names on per\-table basis, do this:
\& # sets the column names only for table "qux"
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
\& $dbh\->{f_meta}\->{qux}\->{col_names}          = [qw(foo bar)];
.Ve
.PP
If you have a file that was created by another \s-1DBM\s0 program or created with
\&\fIdbm_store_metadata\fR set to zero and you want to convert it to using
\&\s-1DBD::DBM\s0's column name storage, just use one of the methods above to name
the columns but *without* specifying \fIdbm_store_metadata\fR as zero.  You
only have to do that once \- thereafter you can get by without setting
either \fIdbm_store_metadata\fR or setting \fIdbm_cols\fR because the names will
be stored in the file.
.SH "DBI database handle attributes"
.IX Header "DBI database handle attributes"
.SS "Metadata"
.IX Subsection "Metadata"
\fIStatement handle ($sth) attributes and methods\fR
.IX Subsection "Statement handle ($sth) attributes and methods"
.PP
Most statement handle attributes such as \s-1NAME, NUM_OF_FIELDS,\s0 etc. are
available only after an execute.  The same is true of \f(CW$sth\fR\->rows which is
available after the execute but does \fInot\fR require a fetch.
.PP
\fIDriver handle ($dbh) attributes\fR
.IX Subsection "Driver handle ($dbh) attributes"
.PP
It is not supported anymore to use dbm-attributes without the dbm_\-prefix.
Currently, if an \s-1DBD::DBM\s0 private attribute is accessed without an
underscore in it's name, dbm_ is prepended to that attribute and it's
processed further. If the resulting attribute name is invalid, an error is
thrown.
.PP
dbm_cols
.IX Subsection "dbm_cols"
.PP
Contains a comma separated list of column names or an array reference to
the column names.
.PP
dbm_type
.IX Subsection "dbm_type"
.PP
Contains the \s-1DBM\s0 storage type. Currently known supported type are
\&\f(CW\*(C`ODBM_File\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR, \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`GDBM_File\*(C'\fR,
\&\f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR. It is not recommended to use one
of the first three types \- even if \f(CW\*(C`SDBM_File\*(C'\fR is the most commonly
available \fIdbm_type\fR.
.PP
dbm_mldbm
.IX Subsection "dbm_mldbm"
.PP
Contains the serializer for \s-1DBM\s0 storage (value column). Requires the
\&\s-1CPAN\s0 module \s-1MLDBM\s0 installed.  Currently known supported serializers
are:
.IP "Data::Dumper" 8
.IX Item "Data::Dumper"
Default serializer. Deployed with Perl core.
.IP "Storable" 8
.IX Item "Storable"
Faster serializer. Deployed with Perl core.
.IP "FreezeThaw" 8
.IX Item "FreezeThaw"
Pure Perl serializer, requires FreezeThaw to be installed.
.IP "\s-1YAML\s0" 8
.IX Item "YAML"
Portable serializer (between languages but not architectures).
Requires \s-1YAML::MLDBM\s0 installation.
.IP "\s-1JSON\s0" 8
.IX Item "JSON"
Portable, fast serializer (between languages but not architectures).
Requires MLDBM::Serializer::JSON installation.
.PP
dbm_store_metadata
.IX Subsection "dbm_store_metadata"
.PP
Boolean value which determines if the metadata in \s-1DBM\s0 is stored or not.
.PP
dbm_berkeley_flags
.IX Subsection "dbm_berkeley_flags"
.PP
Hash reference with additional flags for BerkeleyDB::Hash instantiation.
.PP
dbm_version
.IX Subsection "dbm_version"
.PP
Readonly attribute containing the version of \s-1DBD::DBM.\s0
.PP
f_meta
.IX Subsection "f_meta"
.PP
In addition to the attributes DBD::File recognizes, \s-1DBD::DBM\s0 knows
about the (public) attributes \f(CW\*(C`col_names\*(C'\fR (\fBNote\fR not \fIdbm_cols\fR
here!), \f(CW\*(C`dbm_type\*(C'\fR, \f(CW\*(C`dbm_mldbm\*(C'\fR, \f(CW\*(C`dbm_store_metadata\*(C'\fR and
\&\f(CW\*(C`dbm_berkeley_flags\*(C'\fR.  As in DBD::File, there are undocumented,
internal attributes in \s-1DBD::DBM. \s0 Be very careful when modifying
attributes you do not know; the consequence might a destroyed or
corrupted table.
.PP
dbm_tables
.IX Subsection "dbm_tables"
.PP
This attribute provides restricted access to the table meta data. See
f_meta and \*(L"f_meta\*(R" in DBD::File for attribute details.
.PP
dbm_tables is a tied hash providing the internal table names as keys
(accessing unknown tables might create an entry) and their meta
data as another tied hash. The table meta storage is obtained via
the \f(CW\*(C`get_table_meta\*(C'\fR method from the table implementation (see
DBD::File::Developers). Attribute setting and getting within the
table meta data is handled via the methods \f(CW\*(C`set_table_meta_attr\*(C'\fR and
\&\f(CW\*(C`get_table_meta_attr\*(C'\fR.
.PP
\fIFollowing attributes are no longer handled by \s-1DBD::DBM:\s0\fR
.IX Subsection "Following attributes are no longer handled by DBD::DBM:"
.PP
dbm_ext
.IX Subsection "dbm_ext"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_ext\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.PP
dbm_lockfile
.IX Subsection "dbm_lockfile"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_lockfile\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.SH "DBI database handle methods"
.IX Header "DBI database handle methods"
.ie n .SS "The $dbh\->\fIdbm_versions()\fP method"
.el .SS "The \f(CW$dbh\fP\->\fIdbm_versions()\fP method"
.IX Subsection "The $dbh->dbm_versions() method"
The private method \fIdbm_versions()\fR returns a summary of what other modules
are being used at any given time.  \s-1DBD::DBM\s0 can work with or without many
other modules \- it can use either SQL::Statement or DBI::SQL::Nano as its
\&\s-1SQL\s0 engine, it can be run with \s-1DBI\s0 or DBI::PurePerl, it can use many kinds
of \s-1DBM\s0 modules, and many kinds of serializers when run with \s-1MLDBM. \s0 The
\&\fIdbm_versions()\fR method reports all of that and more.
.PP
.Vb 2
\&  print $dbh\->dbm_versions;               # displays global settings
\&  print $dbh\->dbm_versions($table_name);  # displays per table settings
.Ve
.PP
An important thing to note about this method is that when it called
with no arguments, it displays the *global* settings.  If you override
these by setting per-table attributes, these will \fInot\fR be shown
unless you specify a table name as an argument to the method call.
.SS "Storing Objects"
.IX Subsection "Storing Objects"
If you are using \s-1MLDBM,\s0 you can use \s-1DBD::DBM\s0 to take advantage of its
serializing abilities to serialize any Perl object that \s-1MLDBM\s0 can handle.
To store objects in columns, you should (but don't absolutely need to)
declare it as a column of type \s-1BLOB \s0(the type is *currently* ignored by
the \s-1SQL\s0 engine, but it's good form).
.SH "EXTENSIBILITY"
.IX Header "EXTENSIBILITY"
.ie n .IP """SQL::Statement""" 8
.el .IP "\f(CWSQL::Statement\fR" 8
.IX Item "SQL::Statement"
Improved \s-1SQL\s0 engine compared to the built-in DBI::SQL::Nano \- see
\&\*(L"Supported \s-1SQL\s0 syntax\*(R".
.ie n .IP """DB_File""" 8
.el .IP "\f(CWDB_File\fR" 8
.IX Item "DB_File"
Berkeley \s-1DB\s0 version 1. This database library is available on many
systems without additional installation and most systems are
supported.
.ie n .IP """GDBM_File""" 8
.el .IP "\f(CWGDBM_File\fR" 8
.IX Item "GDBM_File"
Simple dbm type (comparable to \f(CW\*(C`DB_File\*(C'\fR) under the \s-1GNU\s0 license.
Typically not available (or requires extra installation) on non-GNU
operating systems.
.ie n .IP """BerkeleyDB""" 8
.el .IP "\f(CWBerkeleyDB\fR" 8
.IX Item "BerkeleyDB"
Berkeley \s-1DB\s0 version up to v4 (and maybe higher) \- requires additional
installation but is easier than GDBM_File on non-GNU systems.
.Sp
db4 comes with a many tools which allow repairing and migrating
databases.  This is the \fBrecommended\fR dbm type for production use.
.ie n .IP """MLDBM""" 8
.el .IP "\f(CWMLDBM\fR" 8
.IX Item "MLDBM"
Serializer wrapper to support more than one column for the files.
Comes with serializers using \f(CW\*(C`Data::Dumper\*(C'\fR, \f(CW\*(C`FreezeThaw\*(C'\fR and
\&\f(CW\*(C`Storable\*(C'\fR.
.ie n .IP """YAML::MLDBM""" 8
.el .IP "\f(CWYAML::MLDBM\fR" 8
.IX Item "YAML::MLDBM"
Additional serializer for \s-1MLDBM. YAML\s0 is very portable between languages.
.ie n .IP """MLDBM::Serializer::JSON""" 8
.el .IP "\f(CWMLDBM::Serializer::JSON\fR" 8
.IX Item "MLDBM::Serializer::JSON"
Additional serializer for \s-1MLDBM. JSON\s0 is very portable between languages,
probably more than \s-1YAML.\s0
.SH "GOTCHAS AND WARNINGS"
.IX Header "GOTCHAS AND WARNINGS"
Using the \s-1SQL DROP\s0 command will remove any file that has the name specified
in the command with either '.pag' and '.dir', '.db' or your {f_ext} appended
to it.  So this be dangerous if you aren't sure what file it refers to:
.PP
.Vb 1
\& $dbh\->do(qq{DROP TABLE "/path/to/any/file"});
.Ve
.PP
Each \s-1DBM\s0 type has limitations.  SDBM_File, for example, can only store
values of less than 1,000 characters.  *You* as the script author must
ensure that you don't exceed those bounds.  If you try to insert a value
that is larger than \s-1DBM\s0 can store, the results will be unpredictable.
See the documentation for whatever \s-1DBM\s0 you are using for details.
.PP
Different \s-1DBM\s0 implementations return records in different orders.
That means that you \fIshould not\fR rely on the order of records unless
you use an \s-1ORDER BY\s0 statement.
.PP
\&\s-1DBM\s0 data files are platform-specific.  To move them from one platform to
another, you'll need to do something along the lines of dumping your data
to \s-1CSV\s0 on platform #1 and then dumping from \s-1CSV\s0 to \s-1DBM\s0 on platform #2.
DBD::AnyData and \s-1DBD::CSV\s0 can help with that.  There may also be \s-1DBM\s0
conversion tools for your platforms which would probably be quicker.
.PP
When using \s-1MLDBM,\s0 there is a very powerful serializer \- it will allow
you to store Perl code or objects in database columns.  When these get
de-serialized, they may be eval'ed \- in other words \s-1MLDBM \s0(or actually
Data::Dumper when used by \s-1MLDBM\s0) may take the values and try to
execute them in Perl.  Obviously, this can present dangers, so if you
do not know what is in a file, be careful before you access it with
\&\s-1MLDBM\s0 turned on!
.PP
See the entire section on \*(L"Table locking and \fIflock()\fR\*(R" for gotchas and
warnings about the use of \fIflock()\fR.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
This module uses hash interfaces of two column file databases. While
none of supported \s-1SQL\s0 engines have support for indices, the following
statements really do the same (even if they mean something completely
different) for each dbm type which lacks \f(CW\*(C`EXISTS\*(C'\fR support:
.PP
.Vb 1
\&  $sth\->do( "insert into foo values (1, \*(Aqhello\*(Aq)" );
\&
\&  # this statement does ...
\&  $sth\->do( "update foo set v=\*(Aqworld\*(Aq where k=1" );
\&  # ... the same as this statement
\&  $sth\->do( "insert into foo values (1, \*(Aqworld\*(Aq)" );
.Ve
.PP
This is considered to be a bug and might change in a future release.
.PP
Known affected dbm types are \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR. We highly
recommended you use a more modern dbm type such as \f(CW\*(C`DB_File\*(C'\fR.
.SH "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
.IX Header "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
If you need help installing or using \s-1DBD::DBM,\s0 please write to the \s-1DBI\s0
users mailing list at dbi\-users@perl.org or to the
comp.lang.perl.modules newsgroup on usenet.  I cannot always answer
every question quickly but there are many on the mailing list or in
the newsgroup who can.
.PP
\&\s-1DBD\s0 developers for \s-1DBD\s0's which rely on DBD::File or \s-1DBD::DBM\s0 or use
one of them as an example are suggested to join the \s-1DBI\s0 developers
mailing list at dbi\-dev@perl.org and strongly encouraged to join our
\&\s-1IRC\s0 channel at <irc://irc.perl.org/dbi>.
.PP
If you have suggestions, ideas for improvements, or bugs to report, please
report a bug as described in \s-1DBI.\s0 Do not mail any of the authors directly,
you might not get an answer.
.PP
When reporting bugs, please send the output of \f(CW$dbh\fR\->dbm_versions($table)
for a table that exhibits the bug and as small a sample as you can make of
the code that produces the bug.  And of course, patches are welcome, too
:\-).
.PP
If you need enhancements quickly, you can get commercial support as
described at <http://dbi.perl.org/support/> or you can contact Jens Rehsack
at rehsack@cpan.org for commercial support in Germany.
.PP
Please don't bother Jochen Wiedmann or Jeff Zucker for support \- they
handed over further maintenance to H.Merijn Brand and Jens Rehsack.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Many, many thanks to Tim Bunce for prodding me to write this, and for
copious, wise, and patient suggestions all along the way. (Jeff Zucker)
.PP
I send my thanks and acknowledgements to H.Merijn Brand for his
initial refactoring of DBD::File and his strong and ongoing support of
SQL::Statement. Without him, the current progress would never have
been made.  And I have to name Martin J. Evans for each laugh (and
correction) of all those funny word creations I (as non-native
speaker) made to the documentation. And \- of course \- I have to thank
all those unnamed contributors and testers from the Perl
community. (Jens Rehsack)
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is written by Jeff Zucker < jzucker \s-1AT\s0 cpan.org >, who also
maintained it till 2007. After that, in 2010, Jens Rehsack & H.Merijn Brand
took over maintenance.
.PP
.Vb 2
\& Copyright (c) 2004 by Jeff Zucker, all rights reserved.
\& Copyright (c) 2010\-2013 by Jens Rehsack & H.Merijn Brand, all rights reserved.
.Ve
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0,
SQL::Statement, DBI::SQL::Nano,
AnyDBM_File, DB_File, BerkeleyDB,
\&\s-1MLDBM\s0, \s-1YAML::MLDBM\s0, MLDBM::Serializer::JSON
                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::DBM5.16.3pm                             0100644 0001750 0001750 00000123611 12566241577 022726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::DBM 3"
.TH DBD::DBM 3 "2010-12-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::DBM \- a DBI driver for DBM & MLDBM files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use DBI;
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                    # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(AqDBI:DBM(RaiseError=1):\*(Aq);      # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_type=DB_File\*(Aq);    # defaults to DB_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # MLDBM with SDBM_File
\&
\& # or
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef);
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     f_ext              => \*(Aq.db/r\*(Aq,
\&     f_dir              => \*(Aq/path/to/dbfiles/\*(Aq,
\&     f_lockfile         => \*(Aq.lck\*(Aq,
\&     dbm_type           => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm          => \*(AqFreezeThaw\*(Aq,
\&     dbm_store_metadata => 1,
\&     dbm_berkeley_flags => {
\&         \*(Aq\-Cachesize\*(Aq => 1000, # set a ::Hash flag
\&     },
\& });
.Ve
.PP
and other variations on \fIconnect()\fR as shown in the \s-1DBI\s0 docs,
DBD::File/Metadata and \*(L"Metadata\*(R"
shown below.
.PP
Use standard \s-1DBI\s0 prepare, execute, fetch, placeholders, etc.,
see \*(L"\s-1QUICK\s0 \s-1START\s0\*(R" for an example.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBD::DBM\s0 is a database management system that works right out of the
box.  If you have a standard installation of Perl and \s-1DBI\s0 you can
begin creating, accessing, and modifying simple database tables
without any further modules.  You can add other modules (e.g.,
SQL::Statement, DB_File etc) for improved functionality.
.PP
The module uses a \s-1DBM\s0 file storage layer.  \s-1DBM\s0 file storage is common on
many platforms and files can be created with it in many programming
languages using different APIs. That means, in addition to creating
files with \s-1DBI/SQL\s0, you can also use \s-1DBI/SQL\s0 to access and modify files
created by other \s-1DBM\s0 modules and programs and vice versa. \fBNote\fR that
in those cases it might be necessary to use a common subset of the
provided features.
.PP
\&\s-1DBM\s0 files are stored in binary format optimized for quick retrieval
when using a key field.  That optimization can be used advantageously
to make \s-1DBD::DBM\s0 \s-1SQL\s0 operations that use key fields very fast.  There
are several different \*(L"flavors\*(R" of \s-1DBM\s0 which use different storage
formats supported by perl modules such as SDBM_File and \s-1MLDBM\s0.  This
module supports all of the flavors that perl supports and, when used
with \s-1MLDBM\s0, supports tables with any number of columns and insertion
of Perl objects into tables.
.PP
\&\s-1DBD::DBM\s0 has been tested with the following \s-1DBM\s0 types: SDBM_File,
NDBM_File, ODBM_File, GDBM_File, DB_File, BerkeleyDB.  Each type was
tested both with and without \s-1MLDBM\s0 and with the Data::Dumper,
Storable, FreezeThaw, \s-1YAML\s0 and \s-1JSON\s0 serializers using the DBI::SQL::Nano
or the SQL::Statement engines.
.SH "QUICK START"
.IX Header "QUICK START"
\&\s-1DBD::DBM\s0 operates like all other \s-1DBD\s0 drivers \- it's basic syntax and
operation is specified by \s-1DBI\s0.  If you're not familiar with \s-1DBI\s0, you should
start by reading \s-1DBI\s0 and the documents it points to and then come back
and read this file.  If you are familiar with \s-1DBI\s0, you already know most of
what you need to know to operate this module.  Just jump in and create a
test script something like the one shown below.
.PP
You should be aware that there are several options for the \s-1SQL\s0 engine
underlying \s-1DBD::DBM\s0, see \*(L"Supported \s-1SQL\s0 syntax\*(R".  There are also many
options for \s-1DBM\s0 support, see especially the section on \*(L"Adding
multi-column support with \s-1MLDBM\s0\*(R".
.PP
But here's a sample to get you started.
.PP
.Vb 10
\& use DBI;
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->{RaiseError} = 1;
\& for my $sql( split /;\en+/,"
\&     CREATE TABLE user ( user_name TEXT, phone TEXT );
\&     INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\&     INSERT INTO user VALUES (\*(AqSanjay Patel\*(Aq,\*(Aq777\-3333\*(Aq);
\&     INSERT INTO user VALUES (\*(AqJunk\*(Aq,\*(Aqxxx\-xxxx\*(Aq);
\&     DELETE FROM user WHERE user_name = \*(AqJunk\*(Aq;
\&     UPDATE user SET phone = \*(Aq999\-4444\*(Aq WHERE user_name = \*(AqSanjay Patel\*(Aq;
\&     SELECT * FROM user
\& "){
\&     my $sth = $dbh\->prepare($sql);
\&     $sth\->execute;
\&     $sth\->dump_results if $sth\->{NUM_OF_FIELDS};
\& }
\& $dbh\->disconnect;
.Ve
.SH "USAGE"
.IX Header "USAGE"
This section will explain some useage cases in more detail. To get an
overview about the available attributes, see \*(L"Metadata\*(R".
.SS "Specifying Files and Directories"
.IX Subsection "Specifying Files and Directories"
\&\s-1DBD::DBM\s0 will automatically supply an appropriate file extension for the
type of \s-1DBM\s0 you are using.  For example, if you use SDBM_File, a table
called \*(L"fruit\*(R" will be stored in two files called \*(L"fruit.pag\*(R" and
\&\*(L"fruit.dir\*(R".  You should \fBnever\fR specify the file extensions in your \s-1SQL\s0
statements.
.PP
\&\s-1DBD::DBM\s0 recognizes following default extensions for following types:
.IP ".pag/r" 4
.IX Item ".pag/r"
Chosen for dbm_type \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR
when an implementation is detected which wraps \f(CW\*(C`\-ldbm\*(C'\fR for
\&\f(CW\*(C`NDBM_File\*(C'\fR (e.g. Solaris, \s-1AIX\s0, ...).
.Sp
For those types, the \f(CW\*(C`.dir\*(C'\fR extension is recognized, too (for being
deleted when dropping a table).
.IP ".db/r" 4
.IX Item ".db/r"
Chosen for dbm_type \f(CW\*(C`NDBM_File\*(C'\fR when an implementation is detected
which wraps BerkeleyDB 1.x for \f(CW\*(C`NDBM_File\*(C'\fR (typically \s-1BSD\s0's, Darwin).
.PP
\&\f(CW\*(C`GDBM_File\*(C'\fR, \f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR don't usually
use a file extension.
.PP
If your \s-1DBM\s0 type uses an extension other than one of the recognized
types of extensions, you should set the \fIf_ext\fR attribute to the
extension \fBand\fR file a bug report as described in \s-1DBI\s0 with the name
of the implementation and extension so we can add it to \s-1DBD::DBM\s0.
Thanks in advance for that :\-).
.PP
.Vb 2
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=.db\*(Aq);  # .db extension is used
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=\*(Aq);     # no extension is used
\&
\&  # or
\&  $dbh\->{f_ext}=\*(Aq.db\*(Aq;                       # global setting
\&  $dbh\->{f_meta}\->{\*(Aqqux\*(Aq}\->{f_ext}=\*(Aq.db\*(Aq;    # setting for table \*(Aqqux\*(Aq
.Ve
.PP
By default files are assumed to be in the current working directory.
To use other directories specify the \fIf_dir\fR attribute in either the
connect string or by setting the database handle attribute.
.PP
For example, this will look for the file /foo/bar/fruit (or
/foo/bar/fruit.pag for \s-1DBM\s0 types that use that extension)
.PP
.Vb 6
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:f_dir=/foo/bar\*(Aq);
\&  # and this will too:
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&  $dbh\->{f_dir} = \*(Aq/foo/bar\*(Aq;
\&  # but this is recommended
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { f_dir => \*(Aq/foo/bar\*(Aq } );
\&
\&  # now you can do
\&  my $ary = $dbh\->selectall_arrayref(q{ SELECT x FROM fruit });
.Ve
.PP
You can also use delimited identifiers to specify paths directly in \s-1SQL\s0
statements.  This looks in the same place as the two examples above but
without setting \fIf_dir\fR:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT x FROM "/foo/bar/fruit"
\&   });
.Ve
.PP
You can also tell \s-1DBD::DBM\s0 to use a specified path for a specific table:
.PP
.Vb 1
\&  $dbh\->{dbm_tables}\->{f}\->{file} = q(/foo/bar/fruit);
.Ve
.PP
Please be aware that you cannot specify this during connection.
.PP
If you have SQL::Statement installed, you can use table aliases:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT f.x FROM "/foo/bar/fruit" AS f
\&   });
.Ve
.PP
See the \*(L"\s-1GOTCHAS\s0 \s-1AND\s0 \s-1WARNINGS\s0\*(R" for using \s-1DROP\s0 on tables.
.SS "Table locking and \fIflock()\fP"
.IX Subsection "Table locking and flock()"
Table locking is accomplished using a lockfile which has the same
basename as the table's file but with the file extension '.lck' (or a
lockfile extension that you supply, see below).  This lock file is
created with the table during a \s-1CREATE\s0 and removed during a \s-1DROP\s0.
Every time the table itself is opened, the lockfile is \fIflocked()\fR.  For
\&\s-1SELECT\s0, this is a shared lock.  For all other operations, it is an
exclusive lock (except when you specify something different using the
\&\fIf_lock\fR attribute).
.PP
Since the locking depends on \fIflock()\fR, it only works on operating
systems that support \fIflock()\fR.  In cases where \fIflock()\fR is not
implemented, \s-1DBD::DBM\s0 will simply behave as if the \fIflock()\fR had
occurred although no actual locking will happen.  Read the
documentation for \fIflock()\fR for more information.
.PP
Even on those systems that do support \fIflock()\fR, locking is only
advisory \- as is always the case with \fIflock()\fR.  This means that if
another program tries to access the table file while \s-1DBD::DBM\s0 has the
table locked, that other program will *succeed* at opening unless
it is also using flock on the '.lck' file.  As a result \s-1DBD::DBM\s0's
locking only really applies to other programs using \s-1DBD::DBM\s0 or other
program written to cooperate with \s-1DBD::DBM\s0 locking.
.SS "Specifying the \s-1DBM\s0 type"
.IX Subsection "Specifying the DBM type"
Each \*(L"flavor\*(R" of \s-1DBM\s0 stores its files in a different format and has
different capabilities and limitations. See AnyDBM_File for a
comparison of \s-1DBM\s0 types.
.PP
By default, \s-1DBD::DBM\s0 uses the \f(CW\*(C`SDBM_File\*(C'\fR type of storage since
\&\f(CW\*(C`SDBM_File\*(C'\fR comes with Perl itself. If you have other types of
\&\s-1DBM\s0 storage available, you can use any of them with \s-1DBD::DBM\s0. It is
strongly recommended to use at least \f(CW\*(C`DB_File\*(C'\fR, because \f(CW\*(C`SDBM_File\*(C'\fR has quirks and limitations and \f(CW\*(C`ODBM_file\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR and \f(CW\*(C`GDBM_File\*(C'\fR are not always available.
.PP
You can specify the \s-1DBM\s0 type using the \fIdbm_type\fR attribute which can
be set in the connection string or with \f(CW\*(C`$dbh\->{dbm_type}\*(C'\fR and
\&\f(CW\*(C`$dbh\->{f_meta}\->{$table_name}\->{type}\*(C'\fR for per-table settings in
cases where a single script is accessing more than one kind of \s-1DBM\s0
file.
.PP
In the connection string, just set \f(CW\*(C`dbm_type=TYPENAME\*(C'\fR where
\&\f(CW\*(C`TYPENAME\*(C'\fR is any \s-1DBM\s0 type such as GDBM_File, DB_File, etc. Do \fInot\fR
use \s-1MLDBM\s0 as your \fIdbm_type\fR as that is set differently, see below.
.PP
.Vb 2
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                # uses the default SDBM_File
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_type=GDBM_File\*(Aq); # uses the GDBM_File
\&
\& # You can also use $dbh\->{dbm_type} to set the DBM type for the connection:
\& $dbh\->{dbm_type} = \*(AqDB_File\*(Aq;    # set the global DBM type
\& print $dbh\->{dbm_type};          # display the global DBM type
.Ve
.PP
If you have several tables in your script that use different \s-1DBM\s0
types, you can use the \f(CW$dbh\fR\->{dbm_tables} hash to store different
settings for the various tables.  You can even use this to perform
joins on files that have completely different storage mechanisms.
.PP
.Vb 2
\& # sets global default of GDBM_File
\& my $dbh\->(\*(Aqdbi:DBM:type=GDBM_File\*(Aq);
\&
\& # overrides the global setting, but only for the tables called
\& # I<foo> and I<bar>
\& my $dbh\->{f_meta}\->{foo}\->{dbm_type} = \*(AqDB_File\*(Aq;
\& my $dbh\->{f_meta}\->{bar}\->{dbm_type} = \*(AqBerkeleyDB\*(Aq;
\&
\& # prints the dbm_type for the table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{dbm_type};
.Ve
.PP
\&\fBNote\fR that you must change the \fIdbm_type\fR of a table before you access
it for first time.
.SS "Adding multi-column support with \s-1MLDBM\s0"
.IX Subsection "Adding multi-column support with MLDBM"
Most of the \s-1DBM\s0 types only support two columns and even if it would
support more, \s-1DBD::DBM\s0 would only use two. However a \s-1CPAN\s0 module
called \s-1MLDBM\s0 overcomes this limitation by allowing more than two
columns.  \s-1MLDBM\s0 does this by serializing the data \- basically it puts
a reference to an array into the second column. It can also put almost
any kind of Perl object or even \fBPerl coderefs\fR into columns.
.PP
If you want more than two columns, you \fBmust\fR install \s-1MLDBM\s0. It's available
for many platforms and is easy to install.
.PP
\&\s-1MLDBM\s0 is by default distributed with three serializers \- Data::Dumper,
Storable, and FreezeThaw. Data::Dumper is the default and Storable is the
fastest. \s-1MLDBM\s0 can also make use of user-defined serialization methods or
other serialization modules (e.g. \s-1YAML::MLDBM\s0 or
MLDBM::Serializer::JSON. You select the serializer using the
\&\fIdbm_mldbm\fR attribute.
.PP
Some examples:
.PP
.Vb 10
\& $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # use MLDBM with Storable
\& $dbh=DBI\->connect(
\&    \*(Aqdbi:DBM:dbm_mldbm=MySerializer\*(Aq # use MLDBM with a user defined module
\& );
\& $dbh=DBI\->connect(\*(Aqdbi::dbm:\*(Aq, undef,
\&     undef, { dbm_mldbm => \*(AqYAML\*(Aq }); # use 3rd party serializer
\& $dbh\->{dbm_mldbm} = \*(AqYAML\*(Aq; # same as above
\& print $dbh\->{dbm_mldbm} # show the MLDBM serializer
\& $dbh\->{f_meta}\->{foo}\->{dbm_mldbm}=\*(AqData::Dumper\*(Aq;   # set Data::Dumper for table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{mldbm}; # show serializer for table "foo"
.Ve
.PP
\&\s-1MLDBM\s0 works on top of other \s-1DBM\s0 modules so you can also set a \s-1DBM\s0 type
along with setting dbm_mldbm.  The examples above would default to using
SDBM_File with \s-1MLDBM\s0.  If you wanted GDBM_File instead, here's how:
.PP
.Vb 5
\& # uses DB_File with MLDBM and Storable
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqDB_File\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\& });
.Ve
.PP
SDBM_File, the default \fIdbm_type\fR is quite limited, so if you are going to
use \s-1MLDBM\s0, you should probably use a different type, see AnyDBM_File.
.PP
See below for some \*(L"\s-1GOTCHAS\s0 \s-1AND\s0 \s-1WARNINGS\s0\*(R" about \s-1MLDBM\s0.
.SS "Support for Berkeley \s-1DB\s0"
.IX Subsection "Support for Berkeley DB"
The Berkeley \s-1DB\s0 storage type is supported through two different Perl
modules \- DB_File (which supports only features in old versions of Berkeley
\&\s-1DB\s0) and BerkeleyDB (which supports all versions).  \s-1DBD::DBM\s0 supports
specifying either \*(L"DB_File\*(R" or \*(L"BerkeleyDB\*(R" as a \fIdbm_type\fR, with or
without \s-1MLDBM\s0 support.
.PP
The \*(L"BerkeleyDB\*(R" dbm_type is experimental and it's interface is likely to
change.  It currently defaults to BerkeleyDB::Hash and does not currently
support ::Btree or ::Recno.
.PP
With BerkeleyDB, you can specify initialization flags by setting them in
your script like this:
.PP
.Vb 12
\& use BerkeleyDB;
\& my $env = new BerkeleyDB::Env \-Home => $dir;  # and/or other Env flags
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\&     dbm_berkeley_flags => {
\&         \*(AqDB_CREATE\*(Aq  => DB_CREATE,  # pass in constants
\&         \*(AqDB_RDONLY\*(Aq  => DB_RDONLY,  # pass in constants
\&         \*(Aq\-Cachesize\*(Aq => 1000,       # set a ::Hash flag
\&         \*(Aq\-Env\*(Aq       => $env,       # pass in an environment
\&     },
\& });
.Ve
.PP
Do \fInot\fR set the \-Flags or \-Filename flags as those are determined and
overwritten by the \s-1SQL\s0 (e.g. \-Flags => \s-1DB_RDONLY\s0 is set automatically
when you issue a \s-1SELECT\s0 statement).
.PP
Time has not permitted us to provide support in this release of \s-1DBD::DBM\s0
for further Berkeley \s-1DB\s0 features such as transactions, concurrency,
locking, etc. We will be working on these in the future and would value
suggestions, patches, etc.
.PP
See DB_File and BerkeleyDB for further details.
.SS "Optimizing the use of key fields"
.IX Subsection "Optimizing the use of key fields"
Most \*(L"flavors\*(R" of \s-1DBM\s0 have only two physical columns (but can contain
multiple logical columns as explained above in
\&\*(L"Adding multi-column support with \s-1MLDBM\s0\*(R"). They work similarly to a
Perl hash with the first column serving as the key. Like a Perl hash, \s-1DBM\s0
files permit you to do quick lookups by specifying the key and thus avoid
looping through all records (supported by DBI::SQL::Nano only). Also like
a Perl hash, the keys must be unique. It is impossible to create two
records with the same key.  To put this more simply and in \s-1SQL\s0 terms,
the key column functions as the \fI\s-1PRIMARY\s0 \s-1KEY\s0\fR or \s-1UNIQUE\s0 \s-1INDEX\s0.
.PP
In \s-1DBD::DBM\s0, you can take advantage of the speed of keyed lookups by using
DBI::SQL::Nano and a \s-1WHERE\s0 clause with a single equal comparison on the key
field. For example, the following \s-1SQL\s0 statements are optimized for keyed
lookup:
.PP
.Vb 4
\& CREATE TABLE user ( user_name TEXT, phone TEXT);
\& INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\& # ... many more inserts
\& SELECT phone FROM user WHERE user_name=\*(AqFred Bloggs\*(Aq;
.Ve
.PP
The \*(L"user_name\*(R" column is the key column since it is the first
column. The \s-1SELECT\s0 statement uses the key column in a single equal
comparison \- \*(L"user_name='Fred Bloggs'\*(R" \- so the search will find it
very quickly without having to loop through all the names which were
inserted into the table.
.PP
In contrast, these searches on the same table are not optimized:
.PP
.Vb 2
\& 1. SELECT phone FROM user WHERE user_name < \*(AqFred\*(Aq;
\& 2. SELECT user_name FROM user WHERE phone = \*(Aq233\-7777\*(Aq;
.Ve
.PP
In #1, the operation uses a less-than (<) comparison rather than an equals
comparison, so it will not be optimized for key searching.  In #2, the key
field \*(L"user_name\*(R" is not specified in the \s-1WHERE\s0 clause, and therefore the
search will need to loop through all rows to find the requested row(s).
.PP
\&\fBNote\fR that the underlying \s-1DBM\s0 storage needs to loop over all \fIkey/value\fR
pairs when the optimized fetch is used. SQL::Statement has a massively
improved where clause evaluation which costs around 15% of the evaluation
in DBI::SQL::Nano \- combined with the loop in the \s-1DBM\s0 storage the speed
improvement isn't so impressive.
.PP
Even if lookups are faster by around 50%, DBI::SQL::Nano and
SQL::Statement can benefit from the key field optimizations on
updating and deleting rows \- and here the improved where clause
evaluation of SQL::Statement might beat DBI::SQL::Nano every time the
where clause contains not only the key field (or more than one).
.SS "Supported \s-1SQL\s0 syntax"
.IX Subsection "Supported SQL syntax"
\&\s-1DBD::DBM\s0 uses a subset of \s-1SQL\s0.  The robustness of that subset depends on
what other modules you have installed. Both options support basic \s-1SQL\s0
operations including \s-1CREATE\s0 \s-1TABLE\s0, \s-1DROP\s0 \s-1TABLE\s0, \s-1INSERT\s0, \s-1DELETE\s0, \s-1UPDATE\s0, and
\&\s-1SELECT\s0.
.PP
\&\fBOption #1:\fR By default, this module inherits its \s-1SQL\s0 support from
DBI::SQL::Nano that comes with \s-1DBI\s0.  Nano is, as its name implies, a *very*
small \s-1SQL\s0 engine.  Although limited in scope, it is faster than option #2
for some operations (especially single \fIprimary key\fR lookups). See
DBI::SQL::Nano for a description of the \s-1SQL\s0 it supports and comparisons
of it with option #2.
.PP
\&\fBOption #2:\fR If you install the pure Perl \s-1CPAN\s0 module SQL::Statement,
\&\s-1DBD::DBM\s0 will use it instead of Nano.  This adds support for table aliases,
functions, joins, and much more.  If you're going to use \s-1DBD::DBM\s0
for anything other than very simple tables and queries, you should install
SQL::Statement.  You don't have to change \s-1DBD::DBM\s0 or your scripts in any
way, simply installing SQL::Statement will give you the more robust \s-1SQL\s0
capabilities without breaking scripts written for DBI::SQL::Nano.  See
SQL::Statement for a description of the \s-1SQL\s0 it supports.
.PP
To find out which \s-1SQL\s0 module is working in a given script, you can use the
\&\fIdbm_versions()\fR method or, if you don't need the full output and version
numbers, just do this:
.PP
.Vb 1
\& print $dbh\->{sql_handler}, "\en";
.Ve
.PP
That will print out either \*(L"SQL::Statement\*(R" or \*(L"DBI::SQL::Nano\*(R".
.PP
Baring the section about optimized access to the \s-1DBM\s0 storage in mind,
comparing the benefits of both engines:
.PP
.Vb 6
\&  # DBI::SQL::Nano is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=15" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "delete from foo where key=27" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "select * from foo where key=\*(Aqabc\*(Aq" );
\&
\&  # SQL::Statement might faster (depending on DB size)
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=?" );
\&  $sth\->execute(15);
\&  $sth = $dbh\->prepare( "update foo set value=? where key=15" );
\&  $sth\->execute(\*(Aqnew\*(Aq);
\&  $sth = $dbh\->prepare( "delete from foo where key=?" );
\&  $sth\->execute(27);
\&
\&  # SQL::Statement is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where value=\*(Aqold\*(Aq" );
\&  $sth\->execute();
\&  # must be expressed using "where key = 15 or key = 27 or key = 42 or key = \*(Aqabc\*(Aq"
\&  # in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "delete from foo where key in (15,27,42,\*(Aqabc\*(Aq)" );
\&  $sth\->execute();
\&  # must be expressed using "where key > 10 and key < 90" in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "select * from foo where key between (10,90)" );
\&  $sth\->execute();
\&
\&  # only SQL::Statement can handle
\&  $sth\->prepare( "select * from foo,bar where foo.name = bar.name" );
\&  $sth\->execute();
\&  $sth\->prepare( "insert into foo values ( 1, \*(Aqfoo\*(Aq ), ( 2, \*(Aqbar\*(Aq )" );
\&  $sth\->execute();
.Ve
.SS "Specifying Column Names"
.IX Subsection "Specifying Column Names"
\&\s-1DBM\s0 files don't have a standard way to store column names.   \s-1DBD::DBM\s0 gets
around this issue with a \s-1DBD::DBM\s0 specific way of storing the column names.
\&\fBIf you are working only with \s-1DBD::DBM\s0 and not using files created by or
accessed with other \s-1DBM\s0 programs, you can ignore this section.\fR
.PP
\&\s-1DBD::DBM\s0 stores column names as a row in the file with the key \fI_metadata
\&\e0\fR.  So this code
.PP
.Vb 3
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->do("CREATE TABLE baz (foo CHAR(10), bar INTEGER)");
\& $dbh\->do("INSERT INTO baz (foo,bar) VALUES (\*(Aqzippy\*(Aq,1)");
.Ve
.PP
Will create a file that has a structure something like this:
.PP
.Vb 2
\&  _metadata \e0 | <dbd_metadata><schema></schema><col_names>foo,bar</col_names></dbd_metadata>
\&  zippy        | 1
.Ve
.PP
The next time you access this table with \s-1DBD::DBM\s0, it will treat the
\&\fI_metadata \e0\fR row as a header rather than as data and will pull the column
names from there.  However, if you access the file with something other
than \s-1DBD::DBM\s0, the row will be treated as a regular data row.
.PP
If you do not want the column names stored as a data row in the table you
can set the \fIdbm_store_metadata\fR attribute to 0.
.PP
.Vb 1
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { dbm_store_metadata => 0 });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\&
\& # or for per\-table setting
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
.Ve
.PP
By default, \s-1DBD::DBM\s0 assumes that you have two columns named \*(L"k\*(R" and \*(L"v\*(R"
(short for \*(L"key\*(R" and \*(L"value\*(R").  So if you have \fIdbm_store_metadata\fR set to
1 and you want to use alternate column names, you need to specify the
column names like this:
.PP
.Vb 4
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_store_metadata => 0,
\&     dbm_cols => [ qw(foo bar) ],
\& });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\& $dbh\->{dbm_cols}           = \*(Aqfoo,bar\*(Aq;
\&
\& # or to set the column names on per\-table basis, do this:
\& # sets the column names only for table "qux"
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
\& $dbh\->{f_meta}\->{qux}\->{col_names}          = [qw(foo bar)];
.Ve
.PP
If you have a file that was created by another \s-1DBM\s0 program or created with
\&\fIdbm_store_metadata\fR set to zero and you want to convert it to using
\&\s-1DBD::DBM\s0's column name storage, just use one of the methods above to name
the columns but *without* specifying \fIdbm_store_metadata\fR as zero.  You
only have to do that once \- thereafter you can get by without setting
either \fIdbm_store_metadata\fR or setting \fIdbm_cols\fR because the names will
be stored in the file.
.SH "DBI database handle attributes"
.IX Header "DBI database handle attributes"
.SS "Metadata"
.IX Subsection "Metadata"
\fIStatement handle ($sth) attributes and methods\fR
.IX Subsection "Statement handle ($sth) attributes and methods"
.PP
Most statement handle attributes such as \s-1NAME\s0, \s-1NUM_OF_FIELDS\s0, etc. are
available only after an execute.  The same is true of \f(CW$sth\fR\->rows which is
available after the execute but does \fInot\fR require a fetch.
.PP
\fIDriver handle ($dbh) attributes\fR
.IX Subsection "Driver handle ($dbh) attributes"
.PP
It is not supported anymore to use dbm-attributes without the dbm_\-prefix.
Currently, if an \s-1DBD::DBM\s0 private attribute is accessed without an
underscore in it's name, dbm_ is prepended to that attribute and it's
processed further. If the resulting attribute name is invalid, an error is
thrown.
.PP
dbm_cols
.IX Subsection "dbm_cols"
.PP
Contains a comma separated list of column names or an array reference to
the column names.
.PP
dbm_type
.IX Subsection "dbm_type"
.PP
Contains the \s-1DBM\s0 storage type. Currently known supported type are
\&\f(CW\*(C`ODBM_File\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR, \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`GDBM_File\*(C'\fR,
\&\f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR. It is not recommended to use one
of the first three types \- even if \f(CW\*(C`SDBM_File\*(C'\fR is the most commonly
available \fIdbm_type\fR.
.PP
dbm_mldbm
.IX Subsection "dbm_mldbm"
.PP
Contains the serializer for \s-1DBM\s0 storage (value column). Requires the
\&\s-1CPAN\s0 module \s-1MLDBM\s0 installed.  Currently known supported serializers
are:
.IP "Data::Dumper" 8
.IX Item "Data::Dumper"
Default serializer. Deployed with Perl core.
.IP "Storable" 8
.IX Item "Storable"
Faster serializer. Deployed with Perl core.
.IP "FreezeThaw" 8
.IX Item "FreezeThaw"
Pure Perl serializer, requires FreezeThaw to be installed.
.IP "\s-1YAML\s0" 8
.IX Item "YAML"
Portable serializer (between languages but not architectures).
Requires \s-1YAML::MLDBM\s0 installation.
.IP "\s-1JSON\s0" 8
.IX Item "JSON"
Portable, fast serializer (between languages but not architectures).
Requires MLDBM::Serializer::JSON installation.
.PP
dbm_store_metadata
.IX Subsection "dbm_store_metadata"
.PP
Boolean value which determines if the metadata in \s-1DBM\s0 is stored or not.
.PP
dbm_berkeley_flags
.IX Subsection "dbm_berkeley_flags"
.PP
Hash reference with additional flags for BerkeleyDB::Hash instantiation.
.PP
dbm_version
.IX Subsection "dbm_version"
.PP
Readonly attribute containing the version of \s-1DBD::DBM\s0.
.PP
f_meta
.IX Subsection "f_meta"
.PP
In addition to the attributes DBD::File recognizes, \s-1DBD::DBM\s0 knows
about the (public) attributes \f(CW\*(C`col_names\*(C'\fR (\fBNote\fR not \fIdbm_cols\fR
here!), \f(CW\*(C`dbm_type\*(C'\fR, \f(CW\*(C`dbm_mldbm\*(C'\fR, \f(CW\*(C`dbm_store_metadata\*(C'\fR and
\&\f(CW\*(C`dbm_berkeley_flags\*(C'\fR.  As in DBD::File, there are undocumented,
internal attributes in \s-1DBD::DBM\s0.  Be very careful when modifying
attributes you do not know; the consequence might a destroyed or
corrupted table.
.PP
dbm_tables
.IX Subsection "dbm_tables"
.PP
This attribute provides restricted access to the table meta data. See
f_meta and \*(L"f_meta\*(R" in DBD::File for attribute details.
.PP
dbm_tables is a tied hash providing the internal table names as keys
(accessing unknown tables might create an entry) and their meta
data as another tied hash. The table meta storage is obtained via
the \f(CW\*(C`get_table_meta\*(C'\fR method from the table implementation (see
DBD::File::Developers). Attribute setting and getting within the
table meta data is handled via the methods \f(CW\*(C`set_table_meta_attr\*(C'\fR and
\&\f(CW\*(C`get_table_meta_attr\*(C'\fR.
.PP
\fIFollowing attributes are no longer handled by \s-1DBD::DBM:\s0\fR
.IX Subsection "Following attributes are no longer handled by DBD::DBM:"
.PP
dbm_ext
.IX Subsection "dbm_ext"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_ext\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.PP
dbm_lockfile
.IX Subsection "dbm_lockfile"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_lockfile\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.SH "DBI database handle methods"
.IX Header "DBI database handle methods"
.ie n .SS "The $dbh\->\fIdbm_versions()\fP method"
.el .SS "The \f(CW$dbh\fP\->\fIdbm_versions()\fP method"
.IX Subsection "The $dbh->dbm_versions() method"
The private method \fIdbm_versions()\fR returns a summary of what other modules
are being used at any given time.  \s-1DBD::DBM\s0 can work with or without many
other modules \- it can use either SQL::Statement or DBI::SQL::Nano as its
\&\s-1SQL\s0 engine, it can be run with \s-1DBI\s0 or DBI::PurePerl, it can use many kinds
of \s-1DBM\s0 modules, and many kinds of serializers when run with \s-1MLDBM\s0.  The
\&\fIdbm_versions()\fR method reports all of that and more.
.PP
.Vb 2
\&  print $dbh\->dbm_versions;               # displays global settings
\&  print $dbh\->dbm_versions($table_name);  # displays per table settings
.Ve
.PP
An important thing to note about this method is that when it called
with no arguments, it displays the *global* settings.  If you override
these by setting per-table attributes, these will \fInot\fR be shown
unless you specify a table name as an argument to the method call.
.SS "Storing Objects"
.IX Subsection "Storing Objects"
If you are using \s-1MLDBM\s0, you can use \s-1DBD::DBM\s0 to take advantage of its
serializing abilities to serialize any Perl object that \s-1MLDBM\s0 can handle.
To store objects in columns, you should (but don't absolutely need to)
declare it as a column of type \s-1BLOB\s0 (the type is *currently* ignored by
the \s-1SQL\s0 engine, but it's good form).
.SH "EXTENSIBILITY"
.IX Header "EXTENSIBILITY"
.ie n .IP """SQL::Statement""" 8
.el .IP "\f(CWSQL::Statement\fR" 8
.IX Item "SQL::Statement"
Improved \s-1SQL\s0 engine compared to the built-in DBI::SQL::Nano \- see
\&\*(L"Supported \s-1SQL\s0 syntax\*(R".
.ie n .IP """DB_File""" 8
.el .IP "\f(CWDB_File\fR" 8
.IX Item "DB_File"
Berkeley \s-1DB\s0 version 1. This database library is available on many
systems without additional installation and most systems are
supported.
.ie n .IP """GDBM_File""" 8
.el .IP "\f(CWGDBM_File\fR" 8
.IX Item "GDBM_File"
Simple dbm type (comparable to \f(CW\*(C`DB_File\*(C'\fR) under the \s-1GNU\s0 license.
Typically not available (or requires extra installation) on non-GNU
operating systems.
.ie n .IP """BerkeleyDB""" 8
.el .IP "\f(CWBerkeleyDB\fR" 8
.IX Item "BerkeleyDB"
Berkeley \s-1DB\s0 version up to v4 (and maybe higher) \- requires additional
installation but is easier than GDBM_File on non-GNU systems.
.Sp
db4 comes with a many tools which allow repairing and migrating
databases.  This is the \fBrecommended\fR dbm type for production use.
.ie n .IP """MLDBM""" 8
.el .IP "\f(CWMLDBM\fR" 8
.IX Item "MLDBM"
Serializer wrapper to support more than one column for the files.
Comes with serializers using \f(CW\*(C`Data::Dumper\*(C'\fR, \f(CW\*(C`FreezeThaw\*(C'\fR and
\&\f(CW\*(C`Storable\*(C'\fR.
.ie n .IP """YAML::MLDBM""" 8
.el .IP "\f(CWYAML::MLDBM\fR" 8
.IX Item "YAML::MLDBM"
Additional serializer for \s-1MLDBM\s0. \s-1YAML\s0 is very portable between languanges.
.ie n .IP """MLDBM::Serializer::JSON""" 8
.el .IP "\f(CWMLDBM::Serializer::JSON\fR" 8
.IX Item "MLDBM::Serializer::JSON"
Additional serializer for \s-1MLDBM\s0. \s-1JSON\s0 is very portable between languanges,
probably more than \s-1YAML\s0.
.SH "GOTCHAS AND WARNINGS"
.IX Header "GOTCHAS AND WARNINGS"
Using the \s-1SQL\s0 \s-1DROP\s0 command will remove any file that has the name specified
in the command with either '.pag' and '.dir', '.db' or your {f_ext} appended
to it.  So this be dangerous if you aren't sure what file it refers to:
.PP
.Vb 1
\& $dbh\->do(qq{DROP TABLE "/path/to/any/file"});
.Ve
.PP
Each \s-1DBM\s0 type has limitations.  SDBM_File, for example, can only store
values of less than 1,000 characters.  *You* as the script author must
ensure that you don't exceed those bounds.  If you try to insert a value
that is larger than \s-1DBM\s0 can store, the results will be unpredictable.
See the documentation for whatever \s-1DBM\s0 you are using for details.
.PP
Different \s-1DBM\s0 implementations return records in different orders.
That means that you \fIshould not\fR rely on the order of records unless
you use an \s-1ORDER\s0 \s-1BY\s0 statement.
.PP
\&\s-1DBM\s0 data files are platform-specific.  To move them from one platform to
another, you'll need to do something along the lines of dumping your data
to \s-1CSV\s0 on platform #1 and then dumping from \s-1CSV\s0 to \s-1DBM\s0 on platform #2.
DBD::AnyData and \s-1DBD::CSV\s0 can help with that.  There may also be \s-1DBM\s0
conversion tools for your platforms which would probably be quicker.
.PP
When using \s-1MLDBM\s0, there is a very powerful serializer \- it will allow
you to store Perl code or objects in database columns.  When these get
de-serialized, they may be eval'ed \- in other words \s-1MLDBM\s0 (or actually
Data::Dumper when used by \s-1MLDBM\s0) may take the values and try to
execute them in Perl.  Obviously, this can present dangers, so if you
do not know what is in a file, be careful before you access it with
\&\s-1MLDBM\s0 turned on!
.PP
See the entire section on \*(L"Table locking and \fIflock()\fR\*(R" for gotchas and
warnings about the use of \fIflock()\fR.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
This module uses hash interfaces of two column file databases. While
none of supported \s-1SQL\s0 engines have support for indices, the following
statements really do the same (even if they mean something completely
different) for each dbm type which lacks \f(CW\*(C`EXISTS\*(C'\fR support:
.PP
.Vb 1
\&  $sth\->do( "insert into foo values (1, \*(Aqhello\*(Aq)" );
\&
\&  # this statement does ...
\&  $sth\->do( "update foo set v=\*(Aqworld\*(Aq where k=1" );
\&  # ... the same as this statement
\&  $sth\->do( "insert into foo values (1, \*(Aqworld\*(Aq)" );
.Ve
.PP
This is considered to be a bug and might change in a future release.
.PP
Known affected dbm types are \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR. We highly
recommended you use a more modern dbm type such as \f(CW\*(C`DB_File\*(C'\fR.
.SH "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
.IX Header "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
If you need help installing or using \s-1DBD::DBM\s0, please write to the \s-1DBI\s0
users mailing list at dbi\-users@perl.org or to the
comp.lang.perl.modules newsgroup on usenet.  I cannot always answer
every question quickly but there are many on the mailing list or in
the newsgroup who can.
.PP
\&\s-1DBD\s0 developers for \s-1DBD\s0's which rely on DBD::File or \s-1DBD::DBM\s0 or use
one of them as an example are suggested to join the \s-1DBI\s0 developers
mailing list at dbi\-dev@perl.org and strongly encouraged to join our
\&\s-1IRC\s0 channel at <irc://irc.perl.org/dbi>.
.PP
If you have suggestions, ideas for improvements, or bugs to report, please
report a bug as described in \s-1DBI\s0. Do not mail any of the authors directly,
you might not get an answer.
.PP
When reporting bugs, please send the output of \f(CW$dbh\fR\->dbm_versions($table)
for a table that exhibits the bug and as small a sample as you can make of
the code that produces the bug.  And of course, patches are welcome, too
:\-).
.PP
If you need enhancements quickly, you can get commercial support as
described at <http://dbi.perl.org/support/> or you can contact Jens Rehsack
at rehsack@cpan.org for commercial support in Germany.
.PP
Please don't bother Jochen Wiedmann or Jeff Zucker for support \- they
handed over further maintenance to H.Merijn Brand and Jens Rehsack.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Many, many thanks to Tim Bunce for prodding me to write this, and for
copious, wise, and patient suggestions all along the way. (Jeff Zucker)
.PP
I send my thanks and acknowledgements to H.Merijn Brand for his
initial refactoring of DBD::File and his strong and ongoing support of
SQL::Statement. Without him, the current progress would never have
been made.  And I have to name Martin J. Evans for each laugh (and
correction) of all those funny word creations I (as non-native
speaker) made to the documentation. And \- of course \- I have to thank
all those unnamed contributors and testers from the Perl
community. (Jens Rehsack)
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is written by Jeff Zucker < jzucker \s-1AT\s0 cpan.org >, who also
maintained it till 2007. After that, in 2010, Jens Rehsack & H.Merijn Brand
took over maintenance.
.PP
.Vb 2
\& Copyright (c) 2004 by Jeff Zucker, all rights reserved.
\& Copyright (c) 2010 by Jens Rehsack & H.Merijn Brand, all rights reserved.
.Ve
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0,
SQL::Statement, DBI::SQL::Nano,
AnyDBM_File, DB_File, BerkeleyDB,
\&\s-1MLDBM\s0, \s-1YAML::MLDBM\s0, MLDBM::Serializer::JSON
                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::DBM5.18.3pm                             0100644 0001750 0001750 00000123730 12566241601 022716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::DBM 3"
.TH DBD::DBM 3 "2013-09-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::DBM \- a DBI driver for DBM & MLDBM files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use DBI;
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                    # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(AqDBI:DBM(RaiseError=1):\*(Aq);      # defaults to SDBM_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_type=DB_File\*(Aq);    # defaults to DB_File
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # MLDBM with SDBM_File
\&
\& # or
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef);
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     f_ext              => \*(Aq.db/r\*(Aq,
\&     f_dir              => \*(Aq/path/to/dbfiles/\*(Aq,
\&     f_lockfile         => \*(Aq.lck\*(Aq,
\&     dbm_type           => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm          => \*(AqFreezeThaw\*(Aq,
\&     dbm_store_metadata => 1,
\&     dbm_berkeley_flags => {
\&         \*(Aq\-Cachesize\*(Aq => 1000, # set a ::Hash flag
\&     },
\& });
.Ve
.PP
and other variations on \fIconnect()\fR as shown in the \s-1DBI\s0 docs,
DBD::File metadata and \*(L"Metadata\*(R"
shown below.
.PP
Use standard \s-1DBI\s0 prepare, execute, fetch, placeholders, etc.,
see \*(L"\s-1QUICK START\*(R"\s0 for an example.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DBD::DBM\s0 is a database management system that works right out of the
box.  If you have a standard installation of Perl and \s-1DBI\s0 you can
begin creating, accessing, and modifying simple database tables
without any further modules.  You can add other modules (e.g.,
SQL::Statement, DB_File etc) for improved functionality.
.PP
The module uses a \s-1DBM\s0 file storage layer.  \s-1DBM\s0 file storage is common on
many platforms and files can be created with it in many programming
languages using different APIs. That means, in addition to creating
files with \s-1DBI/SQL,\s0 you can also use \s-1DBI/SQL\s0 to access and modify files
created by other \s-1DBM\s0 modules and programs and vice versa. \fBNote\fR that
in those cases it might be necessary to use a common subset of the
provided features.
.PP
\&\s-1DBM\s0 files are stored in binary format optimized for quick retrieval
when using a key field.  That optimization can be used advantageously
to make \s-1DBD::DBM SQL\s0 operations that use key fields very fast.  There
are several different \*(L"flavors\*(R" of \s-1DBM\s0 which use different storage
formats supported by perl modules such as SDBM_File and \s-1MLDBM. \s0 This
module supports all of the flavors that perl supports and, when used
with \s-1MLDBM,\s0 supports tables with any number of columns and insertion
of Perl objects into tables.
.PP
\&\s-1DBD::DBM\s0 has been tested with the following \s-1DBM\s0 types: SDBM_File,
NDBM_File, ODBM_File, GDBM_File, DB_File, BerkeleyDB.  Each type was
tested both with and without \s-1MLDBM\s0 and with the Data::Dumper,
Storable, FreezeThaw, \s-1YAML\s0 and \s-1JSON\s0 serializers using the DBI::SQL::Nano
or the SQL::Statement engines.
.SH "QUICK START"
.IX Header "QUICK START"
\&\s-1DBD::DBM\s0 operates like all other \s-1DBD\s0 drivers \- it's basic syntax and
operation is specified by \s-1DBI. \s0 If you're not familiar with \s-1DBI,\s0 you should
start by reading \s-1DBI\s0 and the documents it points to and then come back
and read this file.  If you are familiar with \s-1DBI,\s0 you already know most of
what you need to know to operate this module.  Just jump in and create a
test script something like the one shown below.
.PP
You should be aware that there are several options for the \s-1SQL\s0 engine
underlying \s-1DBD::DBM,\s0 see \*(L"Supported \s-1SQL\s0 syntax\*(R".  There are also many
options for \s-1DBM\s0 support, see especially the section on \*(L"Adding
multi-column support with \s-1MLDBM\*(R"\s0.
.PP
But here's a sample to get you started.
.PP
.Vb 10
\& use DBI;
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->{RaiseError} = 1;
\& for my $sql( split /;\en+/,"
\&     CREATE TABLE user ( user_name TEXT, phone TEXT );
\&     INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\&     INSERT INTO user VALUES (\*(AqSanjay Patel\*(Aq,\*(Aq777\-3333\*(Aq);
\&     INSERT INTO user VALUES (\*(AqJunk\*(Aq,\*(Aqxxx\-xxxx\*(Aq);
\&     DELETE FROM user WHERE user_name = \*(AqJunk\*(Aq;
\&     UPDATE user SET phone = \*(Aq999\-4444\*(Aq WHERE user_name = \*(AqSanjay Patel\*(Aq;
\&     SELECT * FROM user
\& "){
\&     my $sth = $dbh\->prepare($sql);
\&     $sth\->execute;
\&     $sth\->dump_results if $sth\->{NUM_OF_FIELDS};
\& }
\& $dbh\->disconnect;
.Ve
.SH "USAGE"
.IX Header "USAGE"
This section will explain some usage cases in more detail. To get an
overview about the available attributes, see \*(L"Metadata\*(R".
.SS "Specifying Files and Directories"
.IX Subsection "Specifying Files and Directories"
\&\s-1DBD::DBM\s0 will automatically supply an appropriate file extension for the
type of \s-1DBM\s0 you are using.  For example, if you use SDBM_File, a table
called \*(L"fruit\*(R" will be stored in two files called \*(L"fruit.pag\*(R" and
\&\*(L"fruit.dir\*(R".  You should \fBnever\fR specify the file extensions in your \s-1SQL\s0
statements.
.PP
\&\s-1DBD::DBM\s0 recognizes following default extensions for following types:
.IP ".pag/r" 4
.IX Item ".pag/r"
Chosen for dbm_type \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR
when an implementation is detected which wraps \f(CW\*(C`\-ldbm\*(C'\fR for
\&\f(CW\*(C`NDBM_File\*(C'\fR (e.g. Solaris, \s-1AIX, ...\s0).
.Sp
For those types, the \f(CW\*(C`.dir\*(C'\fR extension is recognized, too (for being
deleted when dropping a table).
.IP ".db/r" 4
.IX Item ".db/r"
Chosen for dbm_type \f(CW\*(C`NDBM_File\*(C'\fR when an implementation is detected
which wraps BerkeleyDB 1.x for \f(CW\*(C`NDBM_File\*(C'\fR (typically \s-1BSD\s0's, Darwin).
.PP
\&\f(CW\*(C`GDBM_File\*(C'\fR, \f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR don't usually
use a file extension.
.PP
If your \s-1DBM\s0 type uses an extension other than one of the recognized
types of extensions, you should set the \fIf_ext\fR attribute to the
extension \fBand\fR file a bug report as described in \s-1DBI\s0 with the name
of the implementation and extension so we can add it to \s-1DBD::DBM.\s0
Thanks in advance for that :\-).
.PP
.Vb 2
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=.db\*(Aq);  # .db extension is used
\&  $dbh = DBI\->connect(\*(Aqdbi:DBM:f_ext=\*(Aq);     # no extension is used
\&
\&  # or
\&  $dbh\->{f_ext}=\*(Aq.db\*(Aq;                       # global setting
\&  $dbh\->{f_meta}\->{\*(Aqqux\*(Aq}\->{f_ext}=\*(Aq.db\*(Aq;    # setting for table \*(Aqqux\*(Aq
.Ve
.PP
By default files are assumed to be in the current working directory.
To use other directories specify the \fIf_dir\fR attribute in either the
connect string or by setting the database handle attribute.
.PP
For example, this will look for the file /foo/bar/fruit (or
/foo/bar/fruit.pag for \s-1DBM\s0 types that use that extension)
.PP
.Vb 6
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:f_dir=/foo/bar\*(Aq);
\&  # and this will too:
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&  $dbh\->{f_dir} = \*(Aq/foo/bar\*(Aq;
\&  # but this is recommended
\&  my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { f_dir => \*(Aq/foo/bar\*(Aq } );
\&
\&  # now you can do
\&  my $ary = $dbh\->selectall_arrayref(q{ SELECT x FROM fruit });
.Ve
.PP
You can also use delimited identifiers to specify paths directly in \s-1SQL\s0
statements.  This looks in the same place as the two examples above but
without setting \fIf_dir\fR:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT x FROM "/foo/bar/fruit"
\&   });
.Ve
.PP
You can also tell \s-1DBD::DBM\s0 to use a specified path for a specific table:
.PP
.Vb 1
\&  $dbh\->{dbm_tables}\->{f}\->{file} = q(/foo/bar/fruit);
.Ve
.PP
Please be aware that you cannot specify this during connection.
.PP
If you have SQL::Statement installed, you can use table aliases:
.PP
.Vb 4
\&   my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\&   my $ary = $dbh\->selectall_arrayref(q{
\&       SELECT f.x FROM "/foo/bar/fruit" AS f
\&   });
.Ve
.PP
See the \*(L"\s-1GOTCHAS AND WARNINGS\*(R"\s0 for using \s-1DROP\s0 on tables.
.SS "Table locking and \fIflock()\fP"
.IX Subsection "Table locking and flock()"
Table locking is accomplished using a lockfile which has the same
basename as the table's file but with the file extension '.lck' (or a
lockfile extension that you supply, see below).  This lock file is
created with the table during a \s-1CREATE\s0 and removed during a \s-1DROP.\s0
Every time the table itself is opened, the lockfile is \fIflocked()\fR.  For
\&\s-1SELECT,\s0 this is a shared lock.  For all other operations, it is an
exclusive lock (except when you specify something different using the
\&\fIf_lock\fR attribute).
.PP
Since the locking depends on \fIflock()\fR, it only works on operating
systems that support \fIflock()\fR.  In cases where \fIflock()\fR is not
implemented, \s-1DBD::DBM\s0 will simply behave as if the \fIflock()\fR had
occurred although no actual locking will happen.  Read the
documentation for \fIflock()\fR for more information.
.PP
Even on those systems that do support \fIflock()\fR, locking is only
advisory \- as is always the case with \fIflock()\fR.  This means that if
another program tries to access the table file while \s-1DBD::DBM\s0 has the
table locked, that other program will *succeed* at opening unless
it is also using flock on the '.lck' file.  As a result \s-1DBD::DBM\s0's
locking only really applies to other programs using \s-1DBD::DBM\s0 or other
program written to cooperate with \s-1DBD::DBM\s0 locking.
.SS "Specifying the \s-1DBM\s0 type"
.IX Subsection "Specifying the DBM type"
Each \*(L"flavor\*(R" of \s-1DBM\s0 stores its files in a different format and has
different capabilities and limitations. See AnyDBM_File for a
comparison of \s-1DBM\s0 types.
.PP
By default, \s-1DBD::DBM\s0 uses the \f(CW\*(C`SDBM_File\*(C'\fR type of storage since
\&\f(CW\*(C`SDBM_File\*(C'\fR comes with Perl itself. If you have other types of
\&\s-1DBM\s0 storage available, you can use any of them with \s-1DBD::DBM.\s0 It is
strongly recommended to use at least \f(CW\*(C`DB_File\*(C'\fR, because \f(CW\*(C`SDBM_File\*(C'\fR has quirks and limitations and \f(CW\*(C`ODBM_file\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR and \f(CW\*(C`GDBM_File\*(C'\fR are not always available.
.PP
You can specify the \s-1DBM\s0 type using the \fIdbm_type\fR attribute which can
be set in the connection string or with \f(CW\*(C`$dbh\->{dbm_type}\*(C'\fR and
\&\f(CW\*(C`$dbh\->{f_meta}\->{$table_name}\->{type}\*(C'\fR for per-table settings in
cases where a single script is accessing more than one kind of \s-1DBM\s0
file.
.PP
In the connection string, just set \f(CW\*(C`dbm_type=TYPENAME\*(C'\fR where
\&\f(CW\*(C`TYPENAME\*(C'\fR is any \s-1DBM\s0 type such as GDBM_File, DB_File, etc. Do \fInot\fR
use \s-1MLDBM\s0 as your \fIdbm_type\fR as that is set differently, see below.
.PP
.Vb 2
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:\*(Aq);                # uses the default SDBM_File
\& my $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_type=GDBM_File\*(Aq); # uses the GDBM_File
\&
\& # You can also use $dbh\->{dbm_type} to set the DBM type for the connection:
\& $dbh\->{dbm_type} = \*(AqDB_File\*(Aq;    # set the global DBM type
\& print $dbh\->{dbm_type};          # display the global DBM type
.Ve
.PP
If you have several tables in your script that use different \s-1DBM\s0
types, you can use the \f(CW$dbh\fR\->{dbm_tables} hash to store different
settings for the various tables.  You can even use this to perform
joins on files that have completely different storage mechanisms.
.PP
.Vb 2
\& # sets global default of GDBM_File
\& my $dbh\->(\*(Aqdbi:DBM:type=GDBM_File\*(Aq);
\&
\& # overrides the global setting, but only for the tables called
\& # I<foo> and I<bar>
\& my $dbh\->{f_meta}\->{foo}\->{dbm_type} = \*(AqDB_File\*(Aq;
\& my $dbh\->{f_meta}\->{bar}\->{dbm_type} = \*(AqBerkeleyDB\*(Aq;
\&
\& # prints the dbm_type for the table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{dbm_type};
.Ve
.PP
\&\fBNote\fR that you must change the \fIdbm_type\fR of a table before you access
it for first time.
.SS "Adding multi-column support with \s-1MLDBM\s0"
.IX Subsection "Adding multi-column support with MLDBM"
Most of the \s-1DBM\s0 types only support two columns and even if it would
support more, \s-1DBD::DBM\s0 would only use two. However a \s-1CPAN\s0 module
called \s-1MLDBM\s0 overcomes this limitation by allowing more than two
columns.  \s-1MLDBM\s0 does this by serializing the data \- basically it puts
a reference to an array into the second column. It can also put almost
any kind of Perl object or even \fBPerl coderefs\fR into columns.
.PP
If you want more than two columns, you \fBmust\fR install \s-1MLDBM.\s0 It's available
for many platforms and is easy to install.
.PP
\&\s-1MLDBM\s0 is by default distributed with three serializers \- Data::Dumper,
Storable, and FreezeThaw. Data::Dumper is the default and Storable is the
fastest. \s-1MLDBM\s0 can also make use of user-defined serialization methods or
other serialization modules (e.g. \s-1YAML::MLDBM\s0 or
MLDBM::Serializer::JSON. You select the serializer using the
\&\fIdbm_mldbm\fR attribute.
.PP
Some examples:
.PP
.Vb 10
\& $dbh=DBI\->connect(\*(Aqdbi:DBM:dbm_mldbm=Storable\*(Aq);  # use MLDBM with Storable
\& $dbh=DBI\->connect(
\&    \*(Aqdbi:DBM:dbm_mldbm=MySerializer\*(Aq # use MLDBM with a user defined module
\& );
\& $dbh=DBI\->connect(\*(Aqdbi::dbm:\*(Aq, undef,
\&     undef, { dbm_mldbm => \*(AqYAML\*(Aq }); # use 3rd party serializer
\& $dbh\->{dbm_mldbm} = \*(AqYAML\*(Aq; # same as above
\& print $dbh\->{dbm_mldbm} # show the MLDBM serializer
\& $dbh\->{f_meta}\->{foo}\->{dbm_mldbm}=\*(AqData::Dumper\*(Aq;   # set Data::Dumper for table "foo"
\& print $dbh\->{f_meta}\->{foo}\->{mldbm}; # show serializer for table "foo"
.Ve
.PP
\&\s-1MLDBM\s0 works on top of other \s-1DBM\s0 modules so you can also set a \s-1DBM\s0 type
along with setting dbm_mldbm.  The examples above would default to using
SDBM_File with \s-1MLDBM. \s0 If you wanted GDBM_File instead, here's how:
.PP
.Vb 5
\& # uses DB_File with MLDBM and Storable
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqDB_File\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\& });
.Ve
.PP
SDBM_File, the default \fIdbm_type\fR is quite limited, so if you are going to
use \s-1MLDBM,\s0 you should probably use a different type, see AnyDBM_File.
.PP
See below for some \*(L"\s-1GOTCHAS AND WARNINGS\*(R"\s0 about \s-1MLDBM.\s0
.SS "Support for Berkeley \s-1DB\s0"
.IX Subsection "Support for Berkeley DB"
The Berkeley \s-1DB\s0 storage type is supported through two different Perl
modules \- DB_File (which supports only features in old versions of Berkeley
\&\s-1DB\s0) and BerkeleyDB (which supports all versions).  \s-1DBD::DBM\s0 supports
specifying either \*(L"DB_File\*(R" or \*(L"BerkeleyDB\*(R" as a \fIdbm_type\fR, with or
without \s-1MLDBM\s0 support.
.PP
The \*(L"BerkeleyDB\*(R" dbm_type is experimental and it's interface is likely to
change.  It currently defaults to BerkeleyDB::Hash and does not currently
support ::Btree or ::Recno.
.PP
With BerkeleyDB, you can specify initialization flags by setting them in
your script like this:
.PP
.Vb 12
\& use BerkeleyDB;
\& my $env = new BerkeleyDB::Env \-Home => $dir;  # and/or other Env flags
\& $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_type  => \*(AqBerkeleyDB\*(Aq,
\&     dbm_mldbm => \*(AqStorable\*(Aq,
\&     dbm_berkeley_flags => {
\&         \*(AqDB_CREATE\*(Aq  => DB_CREATE,  # pass in constants
\&         \*(AqDB_RDONLY\*(Aq  => DB_RDONLY,  # pass in constants
\&         \*(Aq\-Cachesize\*(Aq => 1000,       # set a ::Hash flag
\&         \*(Aq\-Env\*(Aq       => $env,       # pass in an environment
\&     },
\& });
.Ve
.PP
Do \fInot\fR set the \-Flags or \-Filename flags as those are determined and
overwritten by the \s-1SQL \s0(e.g. \-Flags => \s-1DB_RDONLY\s0 is set automatically
when you issue a \s-1SELECT\s0 statement).
.PP
Time has not permitted us to provide support in this release of \s-1DBD::DBM\s0
for further Berkeley \s-1DB\s0 features such as transactions, concurrency,
locking, etc. We will be working on these in the future and would value
suggestions, patches, etc.
.PP
See DB_File and BerkeleyDB for further details.
.SS "Optimizing the use of key fields"
.IX Subsection "Optimizing the use of key fields"
Most \*(L"flavors\*(R" of \s-1DBM\s0 have only two physical columns (but can contain
multiple logical columns as explained above in
\&\*(L"Adding multi-column support with \s-1MLDBM\*(R"\s0). They work similarly to a
Perl hash with the first column serving as the key. Like a Perl hash, \s-1DBM\s0
files permit you to do quick lookups by specifying the key and thus avoid
looping through all records (supported by DBI::SQL::Nano only). Also like
a Perl hash, the keys must be unique. It is impossible to create two
records with the same key.  To put this more simply and in \s-1SQL\s0 terms,
the key column functions as the \fI\s-1PRIMARY KEY\s0\fR or \s-1UNIQUE INDEX.\s0
.PP
In \s-1DBD::DBM,\s0 you can take advantage of the speed of keyed lookups by using
DBI::SQL::Nano and a \s-1WHERE\s0 clause with a single equal comparison on the key
field. For example, the following \s-1SQL\s0 statements are optimized for keyed
lookup:
.PP
.Vb 4
\& CREATE TABLE user ( user_name TEXT, phone TEXT);
\& INSERT INTO user VALUES (\*(AqFred Bloggs\*(Aq,\*(Aq233\-7777\*(Aq);
\& # ... many more inserts
\& SELECT phone FROM user WHERE user_name=\*(AqFred Bloggs\*(Aq;
.Ve
.PP
The \*(L"user_name\*(R" column is the key column since it is the first
column. The \s-1SELECT\s0 statement uses the key column in a single equal
comparison \- \*(L"user_name='Fred Bloggs'\*(R" \- so the search will find it
very quickly without having to loop through all the names which were
inserted into the table.
.PP
In contrast, these searches on the same table are not optimized:
.PP
.Vb 2
\& 1. SELECT phone FROM user WHERE user_name < \*(AqFred\*(Aq;
\& 2. SELECT user_name FROM user WHERE phone = \*(Aq233\-7777\*(Aq;
.Ve
.PP
In #1, the operation uses a less-than (<) comparison rather than an equals
comparison, so it will not be optimized for key searching.  In #2, the key
field \*(L"user_name\*(R" is not specified in the \s-1WHERE\s0 clause, and therefore the
search will need to loop through all rows to find the requested row(s).
.PP
\&\fBNote\fR that the underlying \s-1DBM\s0 storage needs to loop over all \fIkey/value\fR
pairs when the optimized fetch is used. SQL::Statement has a massively
improved where clause evaluation which costs around 15% of the evaluation
in DBI::SQL::Nano \- combined with the loop in the \s-1DBM\s0 storage the speed
improvement isn't so impressive.
.PP
Even if lookups are faster by around 50%, DBI::SQL::Nano and
SQL::Statement can benefit from the key field optimizations on
updating and deleting rows \- and here the improved where clause
evaluation of SQL::Statement might beat DBI::SQL::Nano every time the
where clause contains not only the key field (or more than one).
.SS "Supported \s-1SQL\s0 syntax"
.IX Subsection "Supported SQL syntax"
\&\s-1DBD::DBM\s0 uses a subset of \s-1SQL. \s0 The robustness of that subset depends on
what other modules you have installed. Both options support basic \s-1SQL\s0
operations including \s-1CREATE TABLE, DROP TABLE, INSERT, DELETE, UPDATE,\s0 and
\&\s-1SELECT.\s0
.PP
\&\fBOption #1:\fR By default, this module inherits its \s-1SQL\s0 support from
DBI::SQL::Nano that comes with \s-1DBI. \s0 Nano is, as its name implies, a *very*
small \s-1SQL\s0 engine.  Although limited in scope, it is faster than option #2
for some operations (especially single \fIprimary key\fR lookups). See
DBI::SQL::Nano for a description of the \s-1SQL\s0 it supports and comparisons
of it with option #2.
.PP
\&\fBOption #2:\fR If you install the pure Perl \s-1CPAN\s0 module SQL::Statement,
\&\s-1DBD::DBM\s0 will use it instead of Nano.  This adds support for table aliases,
functions, joins, and much more.  If you're going to use \s-1DBD::DBM\s0
for anything other than very simple tables and queries, you should install
SQL::Statement.  You don't have to change \s-1DBD::DBM\s0 or your scripts in any
way, simply installing SQL::Statement will give you the more robust \s-1SQL\s0
capabilities without breaking scripts written for DBI::SQL::Nano.  See
SQL::Statement for a description of the \s-1SQL\s0 it supports.
.PP
To find out which \s-1SQL\s0 module is working in a given script, you can use the
\&\fIdbm_versions()\fR method or, if you don't need the full output and version
numbers, just do this:
.PP
.Vb 1
\& print $dbh\->{sql_handler}, "\en";
.Ve
.PP
That will print out either \*(L"SQL::Statement\*(R" or \*(L"DBI::SQL::Nano\*(R".
.PP
Baring the section about optimized access to the \s-1DBM\s0 storage in mind,
comparing the benefits of both engines:
.PP
.Vb 6
\&  # DBI::SQL::Nano is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=15" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "delete from foo where key=27" );
\&  $sth\->execute();
\&  $sth = $dbh\->prepare( "select * from foo where key=\*(Aqabc\*(Aq" );
\&
\&  # SQL::Statement might faster (depending on DB size)
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where key=?" );
\&  $sth\->execute(15);
\&  $sth = $dbh\->prepare( "update foo set value=? where key=15" );
\&  $sth\->execute(\*(Aqnew\*(Aq);
\&  $sth = $dbh\->prepare( "delete from foo where key=?" );
\&  $sth\->execute(27);
\&
\&  # SQL::Statement is faster
\&  $sth = $dbh\->prepare( "update foo set value=\*(Aqnew\*(Aq where value=\*(Aqold\*(Aq" );
\&  $sth\->execute();
\&  # must be expressed using "where key = 15 or key = 27 or key = 42 or key = \*(Aqabc\*(Aq"
\&  # in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "delete from foo where key in (15,27,42,\*(Aqabc\*(Aq)" );
\&  $sth\->execute();
\&  # must be expressed using "where key > 10 and key < 90" in DBI::SQL::Nano
\&  $sth = $dbh\->prepare( "select * from foo where key between (10,90)" );
\&  $sth\->execute();
\&
\&  # only SQL::Statement can handle
\&  $sth\->prepare( "select * from foo,bar where foo.name = bar.name" );
\&  $sth\->execute();
\&  $sth\->prepare( "insert into foo values ( 1, \*(Aqfoo\*(Aq ), ( 2, \*(Aqbar\*(Aq )" );
\&  $sth\->execute();
.Ve
.SS "Specifying Column Names"
.IX Subsection "Specifying Column Names"
\&\s-1DBM\s0 files don't have a standard way to store column names.   \s-1DBD::DBM\s0 gets
around this issue with a \s-1DBD::DBM\s0 specific way of storing the column names.
\&\fBIf you are working only with \s-1DBD::DBM\s0 and not using files created by or
accessed with other \s-1DBM\s0 programs, you can ignore this section.\fR
.PP
\&\s-1DBD::DBM\s0 stores column names as a row in the file with the key \fI_metadata
\&\e0\fR.  So this code
.PP
.Vb 3
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq);
\& $dbh\->do("CREATE TABLE baz (foo CHAR(10), bar INTEGER)");
\& $dbh\->do("INSERT INTO baz (foo,bar) VALUES (\*(Aqzippy\*(Aq,1)");
.Ve
.PP
Will create a file that has a structure something like this:
.PP
.Vb 2
\&  _metadata \e0 | <dbd_metadata><schema></schema><col_names>foo,bar</col_names></dbd_metadata>
\&  zippy        | 1
.Ve
.PP
The next time you access this table with \s-1DBD::DBM,\s0 it will treat the
\&\fI_metadata \e0\fR row as a header rather than as data and will pull the column
names from there.  However, if you access the file with something other
than \s-1DBD::DBM,\s0 the row will be treated as a regular data row.
.PP
If you do not want the column names stored as a data row in the table you
can set the \fIdbm_store_metadata\fR attribute to 0.
.PP
.Vb 1
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, { dbm_store_metadata => 0 });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\&
\& # or for per\-table setting
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
.Ve
.PP
By default, \s-1DBD::DBM\s0 assumes that you have two columns named \*(L"k\*(R" and \*(L"v\*(R"
(short for \*(L"key\*(R" and \*(L"value\*(R").  So if you have \fIdbm_store_metadata\fR set to
1 and you want to use alternate column names, you need to specify the
column names like this:
.PP
.Vb 4
\& my $dbh = DBI\->connect(\*(Aqdbi:DBM:\*(Aq, undef, undef, {
\&     dbm_store_metadata => 0,
\&     dbm_cols => [ qw(foo bar) ],
\& });
\&
\& # or
\& $dbh\->{dbm_store_metadata} = 0;
\& $dbh\->{dbm_cols}           = \*(Aqfoo,bar\*(Aq;
\&
\& # or to set the column names on per\-table basis, do this:
\& # sets the column names only for table "qux"
\& $dbh\->{f_meta}\->{qux}\->{dbm_store_metadata} = 0;
\& $dbh\->{f_meta}\->{qux}\->{col_names}          = [qw(foo bar)];
.Ve
.PP
If you have a file that was created by another \s-1DBM\s0 program or created with
\&\fIdbm_store_metadata\fR set to zero and you want to convert it to using
\&\s-1DBD::DBM\s0's column name storage, just use one of the methods above to name
the columns but *without* specifying \fIdbm_store_metadata\fR as zero.  You
only have to do that once \- thereafter you can get by without setting
either \fIdbm_store_metadata\fR or setting \fIdbm_cols\fR because the names will
be stored in the file.
.SH "DBI database handle attributes"
.IX Header "DBI database handle attributes"
.SS "Metadata"
.IX Subsection "Metadata"
\fIStatement handle ($sth) attributes and methods\fR
.IX Subsection "Statement handle ($sth) attributes and methods"
.PP
Most statement handle attributes such as \s-1NAME, NUM_OF_FIELDS,\s0 etc. are
available only after an execute.  The same is true of \f(CW$sth\fR\->rows which is
available after the execute but does \fInot\fR require a fetch.
.PP
\fIDriver handle ($dbh) attributes\fR
.IX Subsection "Driver handle ($dbh) attributes"
.PP
It is not supported anymore to use dbm-attributes without the dbm_\-prefix.
Currently, if an \s-1DBD::DBM\s0 private attribute is accessed without an
underscore in it's name, dbm_ is prepended to that attribute and it's
processed further. If the resulting attribute name is invalid, an error is
thrown.
.PP
dbm_cols
.IX Subsection "dbm_cols"
.PP
Contains a comma separated list of column names or an array reference to
the column names.
.PP
dbm_type
.IX Subsection "dbm_type"
.PP
Contains the \s-1DBM\s0 storage type. Currently known supported type are
\&\f(CW\*(C`ODBM_File\*(C'\fR, \f(CW\*(C`NDBM_File\*(C'\fR, \f(CW\*(C`SDBM_File\*(C'\fR, \f(CW\*(C`GDBM_File\*(C'\fR,
\&\f(CW\*(C`DB_File\*(C'\fR and \f(CW\*(C`BerkeleyDB\*(C'\fR. It is not recommended to use one
of the first three types \- even if \f(CW\*(C`SDBM_File\*(C'\fR is the most commonly
available \fIdbm_type\fR.
.PP
dbm_mldbm
.IX Subsection "dbm_mldbm"
.PP
Contains the serializer for \s-1DBM\s0 storage (value column). Requires the
\&\s-1CPAN\s0 module \s-1MLDBM\s0 installed.  Currently known supported serializers
are:
.IP "Data::Dumper" 8
.IX Item "Data::Dumper"
Default serializer. Deployed with Perl core.
.IP "Storable" 8
.IX Item "Storable"
Faster serializer. Deployed with Perl core.
.IP "FreezeThaw" 8
.IX Item "FreezeThaw"
Pure Perl serializer, requires FreezeThaw to be installed.
.IP "\s-1YAML\s0" 8
.IX Item "YAML"
Portable serializer (between languages but not architectures).
Requires \s-1YAML::MLDBM\s0 installation.
.IP "\s-1JSON\s0" 8
.IX Item "JSON"
Portable, fast serializer (between languages but not architectures).
Requires MLDBM::Serializer::JSON installation.
.PP
dbm_store_metadata
.IX Subsection "dbm_store_metadata"
.PP
Boolean value which determines if the metadata in \s-1DBM\s0 is stored or not.
.PP
dbm_berkeley_flags
.IX Subsection "dbm_berkeley_flags"
.PP
Hash reference with additional flags for BerkeleyDB::Hash instantiation.
.PP
dbm_version
.IX Subsection "dbm_version"
.PP
Readonly attribute containing the version of \s-1DBD::DBM.\s0
.PP
f_meta
.IX Subsection "f_meta"
.PP
In addition to the attributes DBD::File recognizes, \s-1DBD::DBM\s0 knows
about the (public) attributes \f(CW\*(C`col_names\*(C'\fR (\fBNote\fR not \fIdbm_cols\fR
here!), \f(CW\*(C`dbm_type\*(C'\fR, \f(CW\*(C`dbm_mldbm\*(C'\fR, \f(CW\*(C`dbm_store_metadata\*(C'\fR and
\&\f(CW\*(C`dbm_berkeley_flags\*(C'\fR.  As in DBD::File, there are undocumented,
internal attributes in \s-1DBD::DBM. \s0 Be very careful when modifying
attributes you do not know; the consequence might a destroyed or
corrupted table.
.PP
dbm_tables
.IX Subsection "dbm_tables"
.PP
This attribute provides restricted access to the table meta data. See
f_meta and \*(L"f_meta\*(R" in DBD::File for attribute details.
.PP
dbm_tables is a tied hash providing the internal table names as keys
(accessing unknown tables might create an entry) and their meta
data as another tied hash. The table meta storage is obtained via
the \f(CW\*(C`get_table_meta\*(C'\fR method from the table implementation (see
DBD::File::Developers). Attribute setting and getting within the
table meta data is handled via the methods \f(CW\*(C`set_table_meta_attr\*(C'\fR and
\&\f(CW\*(C`get_table_meta_attr\*(C'\fR.
.PP
\fIFollowing attributes are no longer handled by \s-1DBD::DBM:\s0\fR
.IX Subsection "Following attributes are no longer handled by DBD::DBM:"
.PP
dbm_ext
.IX Subsection "dbm_ext"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_ext\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.PP
dbm_lockfile
.IX Subsection "dbm_lockfile"
.PP
This attribute is silently mapped to DBD::File's attribute \fIf_lockfile\fR.
Later versions of \s-1DBI\s0 might show a depreciated warning when this attribute
is used and eventually it will be removed.
.SH "DBI database handle methods"
.IX Header "DBI database handle methods"
.ie n .SS "The $dbh\->\fIdbm_versions()\fP method"
.el .SS "The \f(CW$dbh\fP\->\fIdbm_versions()\fP method"
.IX Subsection "The $dbh->dbm_versions() method"
The private method \fIdbm_versions()\fR returns a summary of what other modules
are being used at any given time.  \s-1DBD::DBM\s0 can work with or without many
other modules \- it can use either SQL::Statement or DBI::SQL::Nano as its
\&\s-1SQL\s0 engine, it can be run with \s-1DBI\s0 or DBI::PurePerl, it can use many kinds
of \s-1DBM\s0 modules, and many kinds of serializers when run with \s-1MLDBM. \s0 The
\&\fIdbm_versions()\fR method reports all of that and more.
.PP
.Vb 2
\&  print $dbh\->dbm_versions;               # displays global settings
\&  print $dbh\->dbm_versions($table_name);  # displays per table settings
.Ve
.PP
An important thing to note about this method is that when it called
with no arguments, it displays the *global* settings.  If you override
these by setting per-table attributes, these will \fInot\fR be shown
unless you specify a table name as an argument to the method call.
.SS "Storing Objects"
.IX Subsection "Storing Objects"
If you are using \s-1MLDBM,\s0 you can use \s-1DBD::DBM\s0 to take advantage of its
serializing abilities to serialize any Perl object that \s-1MLDBM\s0 can handle.
To store objects in columns, you should (but don't absolutely need to)
declare it as a column of type \s-1BLOB \s0(the type is *currently* ignored by
the \s-1SQL\s0 engine, but it's good form).
.SH "EXTENSIBILITY"
.IX Header "EXTENSIBILITY"
.ie n .IP """SQL::Statement""" 8
.el .IP "\f(CWSQL::Statement\fR" 8
.IX Item "SQL::Statement"
Improved \s-1SQL\s0 engine compared to the built-in DBI::SQL::Nano \- see
\&\*(L"Supported \s-1SQL\s0 syntax\*(R".
.ie n .IP """DB_File""" 8
.el .IP "\f(CWDB_File\fR" 8
.IX Item "DB_File"
Berkeley \s-1DB\s0 version 1. This database library is available on many
systems without additional installation and most systems are
supported.
.ie n .IP """GDBM_File""" 8
.el .IP "\f(CWGDBM_File\fR" 8
.IX Item "GDBM_File"
Simple dbm type (comparable to \f(CW\*(C`DB_File\*(C'\fR) under the \s-1GNU\s0 license.
Typically not available (or requires extra installation) on non-GNU
operating systems.
.ie n .IP """BerkeleyDB""" 8
.el .IP "\f(CWBerkeleyDB\fR" 8
.IX Item "BerkeleyDB"
Berkeley \s-1DB\s0 version up to v4 (and maybe higher) \- requires additional
installation but is easier than GDBM_File on non-GNU systems.
.Sp
db4 comes with a many tools which allow repairing and migrating
databases.  This is the \fBrecommended\fR dbm type for production use.
.ie n .IP """MLDBM""" 8
.el .IP "\f(CWMLDBM\fR" 8
.IX Item "MLDBM"
Serializer wrapper to support more than one column for the files.
Comes with serializers using \f(CW\*(C`Data::Dumper\*(C'\fR, \f(CW\*(C`FreezeThaw\*(C'\fR and
\&\f(CW\*(C`Storable\*(C'\fR.
.ie n .IP """YAML::MLDBM""" 8
.el .IP "\f(CWYAML::MLDBM\fR" 8
.IX Item "YAML::MLDBM"
Additional serializer for \s-1MLDBM. YAML\s0 is very portable between languages.
.ie n .IP """MLDBM::Serializer::JSON""" 8
.el .IP "\f(CWMLDBM::Serializer::JSON\fR" 8
.IX Item "MLDBM::Serializer::JSON"
Additional serializer for \s-1MLDBM. JSON\s0 is very portable between languages,
probably more than \s-1YAML.\s0
.SH "GOTCHAS AND WARNINGS"
.IX Header "GOTCHAS AND WARNINGS"
Using the \s-1SQL DROP\s0 command will remove any file that has the name specified
in the command with either '.pag' and '.dir', '.db' or your {f_ext} appended
to it.  So this be dangerous if you aren't sure what file it refers to:
.PP
.Vb 1
\& $dbh\->do(qq{DROP TABLE "/path/to/any/file"});
.Ve
.PP
Each \s-1DBM\s0 type has limitations.  SDBM_File, for example, can only store
values of less than 1,000 characters.  *You* as the script author must
ensure that you don't exceed those bounds.  If you try to insert a value
that is larger than \s-1DBM\s0 can store, the results will be unpredictable.
See the documentation for whatever \s-1DBM\s0 you are using for details.
.PP
Different \s-1DBM\s0 implementations return records in different orders.
That means that you \fIshould not\fR rely on the order of records unless
you use an \s-1ORDER BY\s0 statement.
.PP
\&\s-1DBM\s0 data files are platform-specific.  To move them from one platform to
another, you'll need to do something along the lines of dumping your data
to \s-1CSV\s0 on platform #1 and then dumping from \s-1CSV\s0 to \s-1DBM\s0 on platform #2.
DBD::AnyData and \s-1DBD::CSV\s0 can help with that.  There may also be \s-1DBM\s0
conversion tools for your platforms which would probably be quicker.
.PP
When using \s-1MLDBM,\s0 there is a very powerful serializer \- it will allow
you to store Perl code or objects in database columns.  When these get
de-serialized, they may be eval'ed \- in other words \s-1MLDBM \s0(or actually
Data::Dumper when used by \s-1MLDBM\s0) may take the values and try to
execute them in Perl.  Obviously, this can present dangers, so if you
do not know what is in a file, be careful before you access it with
\&\s-1MLDBM\s0 turned on!
.PP
See the entire section on \*(L"Table locking and \fIflock()\fR\*(R" for gotchas and
warnings about the use of \fIflock()\fR.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
This module uses hash interfaces of two column file databases. While
none of supported \s-1SQL\s0 engines have support for indices, the following
statements really do the same (even if they mean something completely
different) for each dbm type which lacks \f(CW\*(C`EXISTS\*(C'\fR support:
.PP
.Vb 1
\&  $sth\->do( "insert into foo values (1, \*(Aqhello\*(Aq)" );
\&
\&  # this statement does ...
\&  $sth\->do( "update foo set v=\*(Aqworld\*(Aq where k=1" );
\&  # ... the same as this statement
\&  $sth\->do( "insert into foo values (1, \*(Aqworld\*(Aq)" );
.Ve
.PP
This is considered to be a bug and might change in a future release.
.PP
Known affected dbm types are \f(CW\*(C`ODBM_File\*(C'\fR and \f(CW\*(C`NDBM_File\*(C'\fR. We highly
recommended you use a more modern dbm type such as \f(CW\*(C`DB_File\*(C'\fR.
.SH "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
.IX Header "GETTING HELP, MAKING SUGGESTIONS, AND REPORTING BUGS"
If you need help installing or using \s-1DBD::DBM,\s0 please write to the \s-1DBI\s0
users mailing list at dbi\-users@perl.org or to the
comp.lang.perl.modules newsgroup on usenet.  I cannot always answer
every question quickly but there are many on the mailing list or in
the newsgroup who can.
.PP
\&\s-1DBD\s0 developers for \s-1DBD\s0's which rely on DBD::File or \s-1DBD::DBM\s0 or use
one of them as an example are suggested to join the \s-1DBI\s0 developers
mailing list at dbi\-dev@perl.org and strongly encouraged to join our
\&\s-1IRC\s0 channel at <irc://irc.perl.org/dbi>.
.PP
If you have suggestions, ideas for improvements, or bugs to report, please
report a bug as described in \s-1DBI.\s0 Do not mail any of the authors directly,
you might not get an answer.
.PP
When reporting bugs, please send the output of \f(CW$dbh\fR\->dbm_versions($table)
for a table that exhibits the bug and as small a sample as you can make of
the code that produces the bug.  And of course, patches are welcome, too
:\-).
.PP
If you need enhancements quickly, you can get commercial support as
described at <http://dbi.perl.org/support/> or you can contact Jens Rehsack
at rehsack@cpan.org for commercial support in Germany.
.PP
Please don't bother Jochen Wiedmann or Jeff Zucker for support \- they
handed over further maintenance to H.Merijn Brand and Jens Rehsack.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Many, many thanks to Tim Bunce for prodding me to write this, and for
copious, wise, and patient suggestions all along the way. (Jeff Zucker)
.PP
I send my thanks and acknowledgements to H.Merijn Brand for his
initial refactoring of DBD::File and his strong and ongoing support of
SQL::Statement. Without him, the current progress would never have
been made.  And I have to name Martin J. Evans for each laugh (and
correction) of all those funny word creations I (as non-native
speaker) made to the documentation. And \- of course \- I have to thank
all those unnamed contributors and testers from the Perl
community. (Jens Rehsack)
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This module is written by Jeff Zucker < jzucker \s-1AT\s0 cpan.org >, who also
maintained it till 2007. After that, in 2010, Jens Rehsack & H.Merijn Brand
took over maintenance.
.PP
.Vb 2
\& Copyright (c) 2004 by Jeff Zucker, all rights reserved.
\& Copyright (c) 2010\-2013 by Jens Rehsack & H.Merijn Brand, all rights reserved.
.Ve
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0,
SQL::Statement, DBI::SQL::Nano,
AnyDBM_File, DB_File, BerkeleyDB,
\&\s-1MLDBM\s0, \s-1YAML::MLDBM\s0, MLDBM::Serializer::JSON
                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File.3pm                                0100644 0001750 0001750 00000050331 12566241600 022652  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File 3"
.TH DBD::File 3 "2013-07-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File \- Base class for writing file based DBI drivers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module is a base class for writing other \s-1DBD\s0s.
It is not intended to function as a \s-1DBD\s0 itself (though it is possible).
If you want to access flat files, use DBD::AnyData, or
\&\s-1DBD::CSV\s0 (both of which are subclasses of DBD::File).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The DBD::File module is not a true \s-1DBI\s0 driver, but an abstract
base class for deriving concrete \s-1DBI\s0 drivers from it. The implication
is, that these drivers work with plain files, for example \s-1CSV\s0 files or
\&\s-1INI\s0 files. The module is based on the SQL::Statement
module, a simple \s-1SQL\s0 engine.
.PP
See \s-1DBI\s0 for details on \s-1DBI, \s0SQL::Statement for
details on SQL::Statement and \s-1DBD::CSV\s0, \s-1DBD::DBM\s0
or DBD::AnyData for example drivers.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by DBD::File,
thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBD::File:\fR
.IX Subsection "The following DBI attributes are handled by DBD::File:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, except the
affected table has been created in this session.  Valid after
\&\f(CW\*(C`$sth\->execute\*(C'\fR; undef for non-select statements.
.PP
\fIUnsupported \s-1DBI\s0 attributes and methods\fR
.IX Subsection "Unsupported DBI attributes and methods"
.PP
bind_param_inout
.IX Subsection "bind_param_inout"
.PP
CursorName
.IX Subsection "CursorName"
.PP
LongReadLen
.IX Subsection "LongReadLen"
.PP
LongTruncOk
.IX Subsection "LongTruncOk"
.PP
\fIDBD::File specific attributes\fR
.IX Subsection "DBD::File specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
f_dir
.IX Subsection "f_dir"
.PP
This attribute is used for setting the directory where the files are
opened and it defaults to the current directory (\fI.\fR). Usually you set
it on the dbh but it may be overridden per table (see f_meta).
.PP
When the value for \f(CW\*(C`f_dir\*(C'\fR is a relative path, it is converted into
the appropriate absolute path name (based on the current working
directory) when the dbh attribute is set.
.PP
.Vb 1
\&  f_dir => "/data/foo/csv",
.Ve
.PP
See \*(L"\s-1KNOWN BUGS AND LIMITATIONS\*(R"\s0.
.PP
f_dir_search
.IX Subsection "f_dir_search"
.PP
This optional attribute can be set to pass a list of folders to also
find existing tables. It will \fBnot\fR be used to create new files.
.PP
.Vb 1
\&  f_dir_search => [ "/data/bar/csv", "/dump/blargh/data" ],
.Ve
.PP
f_ext
.IX Subsection "f_ext"
.PP
This attribute is used for setting the file extension. The format is:
.PP
.Vb 1
\&  extension{/flag}
.Ve
.PP
where the /flag is optional and the extension is case-insensitive.
\&\f(CW\*(C`f_ext\*(C'\fR allows you to specify an extension which:
.PP
.Vb 1
\&  f_ext => ".csv/r",
.Ve
.IP "\(bu" 4
makes DBD::File prefer \fItable.extension\fR over \fItable\fR.
.IP "\(bu" 4
makes the table name the filename minus the extension.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv
.Ve
.PP
In the above example and when \f(CW\*(C`f_dir\*(C'\fR contains both \fItable.csv\fR and
\&\fItable\fR, DBD::File will open \fItable.csv\fR and the table will be
named \*(L"table\*(R". If \fItable.csv\fR does not exist but \fItable\fR does
that file is opened and the table is also called \*(L"table\*(R".
.PP
If \f(CW\*(C`f_ext\*(C'\fR is not specified and \fItable.csv\fR exists it will be opened
and the table will be called \*(L"table.csv\*(R" which is probably not what
you want.
.PP
\&\s-1NOTE:\s0 even though extensions are case-insensitive, table names are
not.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv/r
.Ve
.PP
The \f(CW\*(C`r\*(C'\fR flag means the file extension is required and any filename
that does not match the extension is ignored.
.PP
Usually you set it on the dbh but it may be overridden per table
(see f_meta).
.PP
f_schema
.IX Subsection "f_schema"
.PP
This will set the schema name and defaults to the owner of the
directory in which the table file resides. You can set \f(CW\*(C`f_schema\*(C'\fR to
\&\f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 5
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_schema => undef,
\&        f_dir    => "data",
\&        f_ext    => ".csv/r",
\&        }) or die $DBI::errstr;
.Ve
.PP
By setting the schema you affect the results from the tables call:
.PP
.Vb 1
\&    my @tables = $dbh\->tables ();
\&
\&    # no f_schema
\&    "merijn".foo
\&    "merijn".bar
\&
\&    # f_schema => "dbi"
\&    "dbi".foo
\&    "dbi".bar
\&
\&    # f_schema => undef
\&    foo
\&    bar
.Ve
.PP
Defining \f(CW\*(C`f_schema\*(C'\fR to the empty string is equal to setting it to \f(CW\*(C`undef\*(C'\fR
so the \s-1DSN\s0 can be \f(CW"dbi:CSV:f_schema=;f_dir=."\fR.
.PP
f_lock
.IX Subsection "f_lock"
.PP
The \f(CW\*(C`f_lock\*(C'\fR attribute is used to set the locking mode on the opened
table files. Note that not all platforms support locking.  By default,
tables are opened with a shared lock for reading, and with an
exclusive lock for writing. The supported modes are:
.PP
.Vb 1
\&  0: No locking at all.
\&
\&  1: Shared locks will be used.
\&
\&  2: Exclusive locks will be used.
.Ve
.PP
But see \s-1KNOWN BUGS\s0 below.
.PP
f_lockfile
.IX Subsection "f_lockfile"
.PP
If you wish to use a lockfile extension other than \f(CW\*(C`.lck\*(C'\fR, simply specify
the \f(CW\*(C`f_lockfile\*(C'\fR attribute:
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=.foo");
\&  $dbh\->{f_lockfile} = ".foo";
\&  $dbh\->{dbm_tables}{qux}{f_lockfile} = ".foo";
.Ve
.PP
If you wish to disable locking, set the \f(CW\*(C`f_lockfile\*(C'\fR to \f(CW0\fR.
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=0");
\&  $dbh\->{f_lockfile} = 0;
\&  $dbh\->{dbm_tables}{qux}{f_lockfile} = 0;
.Ve
.PP
f_encoding
.IX Subsection "f_encoding"
.PP
With this attribute, you can set the encoding in which the file is opened.
This is implemented using \f(CW\*(C`binmode $fh, ":encoding(<f_encoding>)"\*(C'\fR.
.PP
f_meta
.IX Subsection "f_meta"
.PP
Private data area aliasing \*(L"sql_meta\*(R" in DBI::DBD::SqlEngine which
contains information about the tables this module handles. Table meta
data might not be available until the table has been accessed for the
first time e.g., by issuing a select on it however it is possible to
pre-initialize attributes for each table you use.
.PP
DBD::File recognizes the (public) attributes \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR,
in addition to the attributes \*(L"sql_meta\*(R" in DBI::DBD::SqlEngine already
supports. Be very careful when modifying attributes you do not know,
the consequence might be a destroyed or corrupted table.
.PP
\&\f(CW\*(C`f_file\*(C'\fR is an attribute applicable to table meta data only and you
will not find a corresponding attribute in the dbh. Whilst it may be
reasonable to have several tables with the same column names, it is
not for the same file name. If you need access to the same file using
different table names, use \f(CW\*(C`SQL::Statement\*(C'\fR as the \s-1SQL\s0 engine and the
\&\f(CW\*(C`AS\*(C'\fR keyword:
.PP
.Vb 1
\&    SELECT * FROM tbl AS t1, tbl AS t2 WHERE t1.id = t2.id
.Ve
.PP
\&\f(CW\*(C`f_file\*(C'\fR can be an absolute path name or a relative path name but if
it is relative, it is interpreted as being relative to the \f(CW\*(C`f_dir\*(C'\fR
attribute of the table meta data. When \f(CW\*(C`f_file\*(C'\fR is set DBD::File will
use \f(CW\*(C`f_file\*(C'\fR as specified and will not attempt to work out an
alternative for \f(CW\*(C`f_file\*(C'\fR using the \f(CW\*(C`table name\*(C'\fR and \f(CW\*(C`f_ext\*(C'\fR
attribute.
.PP
While \f(CW\*(C`f_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
\fINew opportunities for attributes from DBI::DBD::SqlEngine\fR
.IX Subsection "New opportunities for attributes from DBI::DBD::SqlEngine"
.PP
sql_table_source
.IX Subsection "sql_table_source"
.PP
\&\f(CW\*(C`$dbh\->{sql_table_source}\*(C'\fR can be set to
\&\fIDBD::File::TableSource::FileSystem\fR (and is the default setting
of DBD::File). This provides usual behaviour of previous DBD::File
releases on
.PP
.Vb 2
\&  @ary = DBI\->data_sources ($driver);
\&  @ary = DBI\->data_sources ($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources ();
\&  @ary = $dbh\->data_sources (\e%attr);
\&
\&  @names = $dbh\->tables ($catalog, $schema, $table, $type);
\&  
\&  $sth = $dbh\->table_info ($catalog, $schema, $table, $type);
\&  $sth = $dbh\->table_info ($catalog, $schema, $table, $type, \e%attr);
\&
\&  $dbh\->func ("list_tables");
.Ve
.PP
sql_data_source
.IX Subsection "sql_data_source"
.PP
\&\f(CW\*(C`$dbh\->{sql_data_source}\*(C'\fR can be set to either
\&\fIDBD::File::DataSource::File\fR, which is default and provides the
well known behavior of DBD::File releases prior to 0.41, or
\&\fIDBD::File::DataSource::Stream\fR, which reuses already opened
file-handle for operations.
.PP
\fIInternally private attributes to deal with \s-1SQL\s0 backends\fR
.IX Subsection "Internally private attributes to deal with SQL backends"
.PP
Do not modify any of these private attributes unless you understand
the implications of doing so. The behavior of DBD::File and derived
DBDs might be unpredictable when one or more of those attributes are
modified.
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the version of loaded DBI::SQL::Nano.
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the version of loaded SQL::Statement.
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains either the text 'SQL::Statement' or 'DBI::SQL::Nano'.
.PP
sql_ram_tables
.IX Subsection "sql_ram_tables"
.PP
Contains optionally temporary tables.
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains optional flags to instantiate the SQL::Parser parsing engine
when SQL::Statement is used as \s-1SQL\s0 engine. See SQL::Parser for valid
flags.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBD::File is used directly. Because this is only reasonable for testing
purposes, the real names must be used instead. Those names can be computed
by replacing the \f(CW\*(C`f_\*(C'\fR in the method name with the driver prefix.
.PP
f_versions
.IX Subsection "f_versions"
.PP
Signature:
.PP
.Vb 6
\&  sub f_versions (;$)
\&  {
\&    my ($table_name) = @_;
\&    $table_name ||= ".";
\&    ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 9
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $f_versions = $dbh\->func ("f_versions");
\&    print "$f_versions\en";
\&    _\|_END_\|_
\&    # DBD::File              0.41 using IO::File (1.16)
\&    #   DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.406
\&    # DBI                    1.623
\&    # OS                     darwin (12.2.1)
\&    # Perl                   5.017006 (darwin\-thread\-multi\-ld\-2level)
.Ve
.PP
Called in list context, f_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
.IP "\(bu" 4
This module uses flock () internally but flock is not available on all
platforms. On MacOS and Windows 95 there is no locking at all (perhaps
not so important on MacOS and Windows 95, as there is only a single
user).
.IP "\(bu" 4
The module stores details about the handled tables in a private area
of the driver handle (\f(CW$drh\fR). This data area is not shared between
different driver instances, so several \f(CW\*(C`DBI\->connect ()\*(C'\fR calls will
cause different table instances and private data areas.
.Sp
This data area is filled for the first time when a table is accessed,
either via an \s-1SQL\s0 statement or via \f(CW\*(C`table_info\*(C'\fR and is not
destroyed until the table is dropped or the driver handle is released.
Manual destruction is possible via f_clear_meta.
.Sp
The following attributes are preserved in the data area and will
evaluated instead of driver globals:
.RS 4
.IP "f_ext" 8
.IX Item "f_ext"
.PD 0
.IP "f_dir" 8
.IX Item "f_dir"
.IP "f_dir_search" 8
.IX Item "f_dir_search"
.IP "f_lock" 8
.IX Item "f_lock"
.IP "f_lockfile" 8
.IX Item "f_lockfile"
.IP "f_encoding" 8
.IX Item "f_encoding"
.IP "f_schema" 8
.IX Item "f_schema"
.IP "col_names" 8
.IX Item "col_names"
.IP "sql_identifier_case" 8
.IX Item "sql_identifier_case"
.RE
.RS 4
.PD
.Sp
The following attributes are preserved in the data area only and
cannot be set globally.
.IP "f_file" 8
.IX Item "f_file"
.RE
.RS 4
.Sp
The following attributes are preserved in the data area only and are
computed when initializing the data area:
.IP "f_fqfn" 8
.IX Item "f_fqfn"
.PD 0
.IP "f_fqbn" 8
.IX Item "f_fqbn"
.IP "f_fqln" 8
.IX Item "f_fqln"
.IP "table_name" 8
.IX Item "table_name"
.RE
.RS 4
.PD
.Sp
For \s-1DBD::CSV\s0 tables this means, once opened \*(L"foo.csv\*(R" as table named \*(L"foo\*(R",
another table named \*(L"foo\*(R" accessing the file \*(L"foo.txt\*(R" cannot be opened.
Accessing \*(L"foo\*(R" will always access the file \*(L"foo.csv\*(R" in memorized
\&\f(CW\*(C`f_dir\*(C'\fR, locking \f(CW\*(C`f_lockfile\*(C'\fR via memorized \f(CW\*(C`f_lock\*(C'\fR.
.Sp
You can use f_clear_meta or the \f(CW\*(C`f_file\*(C'\fR attribute for a specific table
to work around this.
.RE
.IP "\(bu" 4
When used with SQL::Statement and temporary tables e.g.,
.Sp
.Vb 1
\&  CREATE TEMP TABLE ...
.Ve
.Sp
the table data processing bypasses DBD::File::Table. No file system
calls will be made and there are no clashes with existing (file based)
tables with the same name. Temporary tables are chosen over file
tables, but they will not covered by \f(CW\*(C`table_info\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2013 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, \s-1DBD::DBM\s0, \s-1DBD::CSV\s0, Text::CSV,
Text::CSV_XS, SQL::Statement, and
DBI::SQL::Nano
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File5.16.3pm                            0100644 0001750 0001750 00000051071 12566241577 023203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File 3"
.TH DBD::File 3 "2012-02-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File \- Base class for writing file based DBI drivers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module is a base class for writing other \s-1DBD\s0s.
It is not intended to function as a \s-1DBD\s0 itself (though it is possible).
If you want to access flat files, use DBD::AnyData, or
\&\s-1DBD::CSV\s0 (both of which are subclasses of DBD::File).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The DBD::File module is not a true \s-1DBI\s0 driver, but an abstract
base class for deriving concrete \s-1DBI\s0 drivers from it. The implication
is, that these drivers work with plain files, for example \s-1CSV\s0 files or
\&\s-1INI\s0 files. The module is based on the SQL::Statement
module, a simple \s-1SQL\s0 engine.
.PP
See \s-1DBI\s0 for details on \s-1DBI\s0, SQL::Statement for
details on SQL::Statement and \s-1DBD::CSV\s0, \s-1DBD::DBM\s0
or DBD::AnyData for example drivers.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by DBD::File,
thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBD::File:\fR
.IX Subsection "The following DBI attributes are handled by DBD::File:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, except the
affected table has been created in this session.  Valid after
\&\f(CW\*(C`$sth\->execute\*(C'\fR; undef for non-select statements.
.PP
\fIThe following \s-1DBI\s0 attributes and methods are not supported:\fR
.IX Subsection "The following DBI attributes and methods are not supported:"
.IP "bind_param_inout" 4
.IX Item "bind_param_inout"
.PD 0
.IP "CursorName" 4
.IX Item "CursorName"
.IP "LongReadLen" 4
.IX Item "LongReadLen"
.IP "LongTruncOk" 4
.IX Item "LongTruncOk"
.PD
.PP
\fIDBD::File specific attributes\fR
.IX Subsection "DBD::File specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
f_dir
.IX Subsection "f_dir"
.PP
This attribute is used for setting the directory where the files are
opened and it defaults to the current directory (\fI.\fR). Usually you set
it on the dbh but it may be overridden per table (see f_meta).
.PP
When the value for \f(CW\*(C`f_dir\*(C'\fR is a relative path, it is converted into
the appropriate absolute path name (based on the current working
directory) when the dbh attribute is set.
.PP
See \*(L"\s-1KNOWN\s0 \s-1BUGS\s0 \s-1AND\s0 \s-1LIMITATIONS\s0\*(R".
.PP
f_ext
.IX Subsection "f_ext"
.PP
This attribute is used for setting the file extension. The format is:
.PP
.Vb 1
\&  extension{/flag}
.Ve
.PP
where the /flag is optional and the extension is case-insensitive.
\&\f(CW\*(C`f_ext\*(C'\fR allows you to specify an extension which:
.IP "\(bu" 4
makes DBD::File prefer \fItable.extension\fR over \fItable\fR.
.IP "\(bu" 4
makes the table name the filename minus the extension.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv
.Ve
.PP
In the above example and when \f(CW\*(C`f_dir\*(C'\fR contains both \fItable.csv\fR and
\&\fItable\fR, DBD::File will open \fItable.csv\fR and the table will be
named \*(L"table\*(R". If \fItable.csv\fR does not exist but \fItable\fR does
that file is opened and the table is also called \*(L"table\*(R".
.PP
If \f(CW\*(C`f_ext\*(C'\fR is not specified and \fItable.csv\fR exists it will be opened
and the table will be called \*(L"table.csv\*(R" which is probably not what
you want.
.PP
\&\s-1NOTE:\s0 even though extensions are case-insensitive, table names are
not.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv/r
.Ve
.PP
The \f(CW\*(C`r\*(C'\fR flag means the file extension is required and any filename
that does not match the extension is ignored.
.PP
Usually you set it on the dbh but it may be overridden per table
(see f_meta).
.PP
f_schema
.IX Subsection "f_schema"
.PP
This will set the schema name and defaults to the owner of the
directory in which the table file resides. You can set \f(CW\*(C`f_schema\*(C'\fR to
\&\f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 5
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_schema => undef,
\&        f_dir    => "data",
\&        f_ext    => ".csv/r",
\&        }) or die $DBI::errstr;
.Ve
.PP
By setting the schema you affect the results from the tables call:
.PP
.Vb 1
\&    my @tables = $dbh\->tables ();
\&
\&    # no f_schema
\&    "merijn".foo
\&    "merijn".bar
\&
\&    # f_schema => "dbi"
\&    "dbi".foo
\&    "dbi".bar
\&
\&    # f_schema => undef
\&    foo
\&    bar
.Ve
.PP
Defining \f(CW\*(C`f_schema\*(C'\fR to the empty string is equal to setting it to \f(CW\*(C`undef\*(C'\fR
so the \s-1DSN\s0 can be \f(CW"dbi:CSV:f_schema=;f_dir=."\fR.
.PP
f_lock
.IX Subsection "f_lock"
.PP
The \f(CW\*(C`f_lock\*(C'\fR attribute is used to set the locking mode on the opened
table files. Note that not all platforms support locking.  By default,
tables are opened with a shared lock for reading, and with an
exclusive lock for writing. The supported modes are:
.PP
.Vb 1
\&  0: No locking at all.
\&
\&  1: Shared locks will be used.
\&
\&  2: Exclusive locks will be used.
.Ve
.PP
But see \s-1KNOWN\s0 \s-1BUGS\s0 below.
.PP
f_lockfile
.IX Subsection "f_lockfile"
.PP
If you wish to use a lockfile extension other than \f(CW\*(C`.lck\*(C'\fR, simply specify
the \f(CW\*(C`f_lockfile\*(C'\fR attribute:
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=.foo");
\&  $dbh\->{f_lockfile} = ".foo";
\&  $dbh\->{f_meta}{qux}{f_lockfile} = ".foo";
.Ve
.PP
If you wish to disable locking, set the \f(CW\*(C`f_lockfile\*(C'\fR to \f(CW0\fR.
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=0");
\&  $dbh\->{f_lockfile} = 0;
\&  $dbh\->{f_meta}{qux}{f_lockfile} = 0;
.Ve
.PP
f_encoding
.IX Subsection "f_encoding"
.PP
With this attribute, you can set the encoding in which the file is opened.
This is implemented using \f(CW\*(C`binmode $fh, ":encoding(<f_encoding>)"\*(C'\fR.
.PP
f_meta
.IX Subsection "f_meta"
.PP
Private data area which contains information about the tables this
module handles. Table meta data might not be available until the
table has been accessed for the first time e.g., by issuing a select
on it however it is possible to pre-initialize attributes for each table
you use.
.PP
DBD::File recognizes the (public) attributes \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR,
\&\f(CW\*(C`col_names\*(C'\fR, \f(CW\*(C`table_name\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR. Be very careful
when modifying attributes you do not know, the consequence might be a
destroyed or corrupted table.
.PP
\&\f(CW\*(C`f_file\*(C'\fR is an attribute applicable to table meta data only and you
will not find a corresponding attribute in the dbh. Whilst it may be
reasonable to have several tables with the same column names, it is
not for the same file name. If you need access to the same file using
different table names, use \f(CW\*(C`SQL::Statement\*(C'\fR as the \s-1SQL\s0 engine and the
\&\f(CW\*(C`AS\*(C'\fR keyword:
.PP
.Vb 1
\&    SELECT * FROM tbl AS t1, tbl AS t2 WHERE t1.id = t2.id
.Ve
.PP
\&\f(CW\*(C`f_file\*(C'\fR can be an absolute path name or a relative path name but if
it is relative, it is interpreted as being relative to the \f(CW\*(C`f_dir\*(C'\fR
attribute of the table meta data. When \f(CW\*(C`f_file\*(C'\fR is set DBD::File will
use \f(CW\*(C`f_file\*(C'\fR as specified and will not attempt to work out an
alternative for \f(CW\*(C`f_file\*(C'\fR using the \f(CW\*(C`table name\*(C'\fR and \f(CW\*(C`f_ext\*(C'\fR
attribute.
.PP
While \f(CW\*(C`f_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
\fIInternally private attributes to deal with \s-1SQL\s0 backends:\fR
.IX Subsection "Internally private attributes to deal with SQL backends:"
.PP
Do not modify any of these private attributes unless you understand
the implications of doing so. The behavior of DBD::File and derived
DBDs might be unpredictable when one or more of those attributes are
modified.
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the version of loaded DBI::SQL::Nano.
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the version of loaded SQL::Statement.
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains either the text 'SQL::Statement' or 'DBI::SQL::Nano'.
.PP
sql_ram_tables
.IX Subsection "sql_ram_tables"
.PP
Contains optionally temporary tables.
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains optional flags to instantiate the SQL::Parser parsing engine
when SQL::Statement is used as \s-1SQL\s0 engine. See SQL::Parser for valid
flags.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
list_tables
.IX Subsection "list_tables"
.PP
This method returns a list of file names inside \f(CW$dbh\fR\->{f_dir}.
Example:
.PP
.Vb 2
\&    my ($dbh)  = DBI\->connect ("dbi:CSV:f_dir=/usr/local/csv_data");
\&    my (@list) = $dbh\->func ("list_tables");
.Ve
.PP
Note that the list includes all files contained in the directory, even
those that have non-valid table names, from the view of \s-1SQL\s0.
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBD::File is used directly. Because this is only reasonable for testing
purposes, the real names must be used instead. Those names can be computed
by replacing the \f(CW\*(C`f_\*(C'\fR in the method name with the driver prefix.
.PP
f_versions
.IX Subsection "f_versions"
.PP
Signature:
.PP
.Vb 6
\&    sub f_versions (;$)
\&    {
\&        my ($table_name) = @_;
\&        $table_name ||= ".";
\&        ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 8
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $f_versions = $dbh\->f_versions ();
\&    print "$f_versions\en";
\&    _\|_END_\|_
\&    # DBD::File        0.39 using SQL::Statement 1.28
\&    # DBI              1.612
\&    # OS               netbsd (5.99.24)
\&    # Perl             5.010001 (x86_64\-netbsd\-thread\-multi)
.Ve
.PP
Called in list context, f_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.PP
f_get_meta
.IX Subsection "f_get_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub f_get_meta ($$)
\&    {
\&        my ($table_name, $attrib) = @_;
\&        ...
\&    }
.Ve
.PP
Returns the value of a meta attribute set for a specific table, if any.
See f_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table.
This will retrieve the appropriate attribute globally from the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.PP
f_set_meta
.IX Subsection "f_set_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub f_set_meta ($$$)
\&    {
\&        my ($table_name, $attrib, $value) = @_;
\&        ...
\&    }
.Ve
.PP
Sets the value of a meta attribute set for a specific table.
See f_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table
which will set the specified attribute globally for the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib} = $value\*(C'\fR.
.PP
f_clear_meta
.IX Subsection "f_clear_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub f_clear_meta ($)
\&    {
\&        my ($table_name) = @_;
\&        ...
\&    }
.Ve
.PP
Clears the table specific meta information in the private storage of the
dbh.
.SH "SQL ENGINES"
.IX Header "SQL ENGINES"
DBD::File currently supports two \s-1SQL\s0 engines: SQL::Statement
and DBI::SQL::Nano::Statement_. DBI::SQL::Nano supports a
\&\fIvery\fR limited subset of \s-1SQL\s0 statements, but it might be faster for some
very simple tasks. SQL::Statement in contrast supports a much larger subset
of \s-1ANSI\s0 \s-1SQL\s0.
.PP
To use SQL::Statement, you need at least version 1.28 of
SQL::Statement and the environment variable \f(CW\*(C`DBI_SQL_NANO\*(C'\fR must not
be set to a true value.
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
.IP "\(bu" 4
This module uses flock () internally but flock is not available on all
platforms. On MacOS and Windows 95 there is no locking at all (perhaps
not so important on MacOS and Windows 95, as there is only a single
user).
.IP "\(bu" 4
The module stores details about the handled tables in a private area
of the driver handle (\f(CW$drh\fR). This data area is not shared between
different driver instances, so several \f(CW\*(C`DBI\->connect ()\*(C'\fR calls will
cause different table instances and private data areas.
.Sp
This data area is filled for the first time when a table is accessed,
either via an \s-1SQL\s0 statement or via \f(CW\*(C`table_info\*(C'\fR and is not
destroyed until the table is dropped or the driver handle is released.
Manual destruction is possible via f_clear_meta.
.Sp
The following attributes are preserved in the data area and will
evaluated instead of driver globals:
.RS 4
.IP "f_ext" 8
.IX Item "f_ext"
.PD 0
.IP "f_dir" 8
.IX Item "f_dir"
.IP "f_lock" 8
.IX Item "f_lock"
.IP "f_lockfile" 8
.IX Item "f_lockfile"
.IP "f_encoding" 8
.IX Item "f_encoding"
.IP "f_schema" 8
.IX Item "f_schema"
.IP "col_names" 8
.IX Item "col_names"
.IP "sql_identifier_case" 8
.IX Item "sql_identifier_case"
.RE
.RS 4
.PD
.Sp
The following attributes are preserved in the data area only and
cannot be set globally.
.IP "f_file" 8
.IX Item "f_file"
.RE
.RS 4
.Sp
The following attributes are preserved in the data area only and are
computed when initializing the data area:
.IP "f_fqfn" 8
.IX Item "f_fqfn"
.PD 0
.IP "f_fqbn" 8
.IX Item "f_fqbn"
.IP "f_fqln" 8
.IX Item "f_fqln"
.IP "table_name" 8
.IX Item "table_name"
.RE
.RS 4
.PD
.Sp
For \s-1DBD::CSV\s0 tables this means, once opened \*(L"foo.csv\*(R" as table named \*(L"foo\*(R",
another table named \*(L"foo\*(R" accessing the file \*(L"foo.txt\*(R" cannot be opened.
Accessing \*(L"foo\*(R" will always access the file \*(L"foo.csv\*(R" in memorized
\&\f(CW\*(C`f_dir\*(C'\fR, locking \f(CW\*(C`f_lockfile\*(C'\fR via memorized \f(CW\*(C`f_lock\*(C'\fR.
.Sp
You can use f_clear_meta or the \f(CW\*(C`f_file\*(C'\fR attribute for a specific table
to work around this.
.RE
.IP "\(bu" 4
When used with SQL::Statement and temporary tables e.g.,
.Sp
.Vb 1
\&  CREATE TEMP TABLE ...
.Ve
.Sp
the table data processing bypasses DBD::File::Table. No file system
calls will be made and there are no clashes with existing (file based)
tables with the same name. Temporary tables are chosen over file
tables, but they will not covered by \f(CW\*(C`table_info\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2010 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, \s-1DBD::DBM\s0, \s-1DBD::CSV\s0, Text::CSV,
Text::CSV_XS, SQL::Statement, and
DBI::SQL::Nano
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File5.18.3pm                            0100644 0001750 0001750 00000050331 12566241600 023166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File 3"
.TH DBD::File 3 "2013-07-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File \- Base class for writing file based DBI drivers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module is a base class for writing other \s-1DBD\s0s.
It is not intended to function as a \s-1DBD\s0 itself (though it is possible).
If you want to access flat files, use DBD::AnyData, or
\&\s-1DBD::CSV\s0 (both of which are subclasses of DBD::File).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The DBD::File module is not a true \s-1DBI\s0 driver, but an abstract
base class for deriving concrete \s-1DBI\s0 drivers from it. The implication
is, that these drivers work with plain files, for example \s-1CSV\s0 files or
\&\s-1INI\s0 files. The module is based on the SQL::Statement
module, a simple \s-1SQL\s0 engine.
.PP
See \s-1DBI\s0 for details on \s-1DBI, \s0SQL::Statement for
details on SQL::Statement and \s-1DBD::CSV\s0, \s-1DBD::DBM\s0
or DBD::AnyData for example drivers.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by DBD::File,
thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBD::File:\fR
.IX Subsection "The following DBI attributes are handled by DBD::File:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, except the
affected table has been created in this session.  Valid after
\&\f(CW\*(C`$sth\->execute\*(C'\fR; undef for non-select statements.
.PP
\fIUnsupported \s-1DBI\s0 attributes and methods\fR
.IX Subsection "Unsupported DBI attributes and methods"
.PP
bind_param_inout
.IX Subsection "bind_param_inout"
.PP
CursorName
.IX Subsection "CursorName"
.PP
LongReadLen
.IX Subsection "LongReadLen"
.PP
LongTruncOk
.IX Subsection "LongTruncOk"
.PP
\fIDBD::File specific attributes\fR
.IX Subsection "DBD::File specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
f_dir
.IX Subsection "f_dir"
.PP
This attribute is used for setting the directory where the files are
opened and it defaults to the current directory (\fI.\fR). Usually you set
it on the dbh but it may be overridden per table (see f_meta).
.PP
When the value for \f(CW\*(C`f_dir\*(C'\fR is a relative path, it is converted into
the appropriate absolute path name (based on the current working
directory) when the dbh attribute is set.
.PP
.Vb 1
\&  f_dir => "/data/foo/csv",
.Ve
.PP
See \*(L"\s-1KNOWN BUGS AND LIMITATIONS\*(R"\s0.
.PP
f_dir_search
.IX Subsection "f_dir_search"
.PP
This optional attribute can be set to pass a list of folders to also
find existing tables. It will \fBnot\fR be used to create new files.
.PP
.Vb 1
\&  f_dir_search => [ "/data/bar/csv", "/dump/blargh/data" ],
.Ve
.PP
f_ext
.IX Subsection "f_ext"
.PP
This attribute is used for setting the file extension. The format is:
.PP
.Vb 1
\&  extension{/flag}
.Ve
.PP
where the /flag is optional and the extension is case-insensitive.
\&\f(CW\*(C`f_ext\*(C'\fR allows you to specify an extension which:
.PP
.Vb 1
\&  f_ext => ".csv/r",
.Ve
.IP "\(bu" 4
makes DBD::File prefer \fItable.extension\fR over \fItable\fR.
.IP "\(bu" 4
makes the table name the filename minus the extension.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv
.Ve
.PP
In the above example and when \f(CW\*(C`f_dir\*(C'\fR contains both \fItable.csv\fR and
\&\fItable\fR, DBD::File will open \fItable.csv\fR and the table will be
named \*(L"table\*(R". If \fItable.csv\fR does not exist but \fItable\fR does
that file is opened and the table is also called \*(L"table\*(R".
.PP
If \f(CW\*(C`f_ext\*(C'\fR is not specified and \fItable.csv\fR exists it will be opened
and the table will be called \*(L"table.csv\*(R" which is probably not what
you want.
.PP
\&\s-1NOTE:\s0 even though extensions are case-insensitive, table names are
not.
.PP
.Vb 1
\&    DBI:CSV:f_dir=data;f_ext=.csv/r
.Ve
.PP
The \f(CW\*(C`r\*(C'\fR flag means the file extension is required and any filename
that does not match the extension is ignored.
.PP
Usually you set it on the dbh but it may be overridden per table
(see f_meta).
.PP
f_schema
.IX Subsection "f_schema"
.PP
This will set the schema name and defaults to the owner of the
directory in which the table file resides. You can set \f(CW\*(C`f_schema\*(C'\fR to
\&\f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 5
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_schema => undef,
\&        f_dir    => "data",
\&        f_ext    => ".csv/r",
\&        }) or die $DBI::errstr;
.Ve
.PP
By setting the schema you affect the results from the tables call:
.PP
.Vb 1
\&    my @tables = $dbh\->tables ();
\&
\&    # no f_schema
\&    "merijn".foo
\&    "merijn".bar
\&
\&    # f_schema => "dbi"
\&    "dbi".foo
\&    "dbi".bar
\&
\&    # f_schema => undef
\&    foo
\&    bar
.Ve
.PP
Defining \f(CW\*(C`f_schema\*(C'\fR to the empty string is equal to setting it to \f(CW\*(C`undef\*(C'\fR
so the \s-1DSN\s0 can be \f(CW"dbi:CSV:f_schema=;f_dir=."\fR.
.PP
f_lock
.IX Subsection "f_lock"
.PP
The \f(CW\*(C`f_lock\*(C'\fR attribute is used to set the locking mode on the opened
table files. Note that not all platforms support locking.  By default,
tables are opened with a shared lock for reading, and with an
exclusive lock for writing. The supported modes are:
.PP
.Vb 1
\&  0: No locking at all.
\&
\&  1: Shared locks will be used.
\&
\&  2: Exclusive locks will be used.
.Ve
.PP
But see \s-1KNOWN BUGS\s0 below.
.PP
f_lockfile
.IX Subsection "f_lockfile"
.PP
If you wish to use a lockfile extension other than \f(CW\*(C`.lck\*(C'\fR, simply specify
the \f(CW\*(C`f_lockfile\*(C'\fR attribute:
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=.foo");
\&  $dbh\->{f_lockfile} = ".foo";
\&  $dbh\->{dbm_tables}{qux}{f_lockfile} = ".foo";
.Ve
.PP
If you wish to disable locking, set the \f(CW\*(C`f_lockfile\*(C'\fR to \f(CW0\fR.
.PP
.Vb 3
\&  $dbh = DBI\->connect ("dbi:DBM:f_lockfile=0");
\&  $dbh\->{f_lockfile} = 0;
\&  $dbh\->{dbm_tables}{qux}{f_lockfile} = 0;
.Ve
.PP
f_encoding
.IX Subsection "f_encoding"
.PP
With this attribute, you can set the encoding in which the file is opened.
This is implemented using \f(CW\*(C`binmode $fh, ":encoding(<f_encoding>)"\*(C'\fR.
.PP
f_meta
.IX Subsection "f_meta"
.PP
Private data area aliasing \*(L"sql_meta\*(R" in DBI::DBD::SqlEngine which
contains information about the tables this module handles. Table meta
data might not be available until the table has been accessed for the
first time e.g., by issuing a select on it however it is possible to
pre-initialize attributes for each table you use.
.PP
DBD::File recognizes the (public) attributes \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR,
in addition to the attributes \*(L"sql_meta\*(R" in DBI::DBD::SqlEngine already
supports. Be very careful when modifying attributes you do not know,
the consequence might be a destroyed or corrupted table.
.PP
\&\f(CW\*(C`f_file\*(C'\fR is an attribute applicable to table meta data only and you
will not find a corresponding attribute in the dbh. Whilst it may be
reasonable to have several tables with the same column names, it is
not for the same file name. If you need access to the same file using
different table names, use \f(CW\*(C`SQL::Statement\*(C'\fR as the \s-1SQL\s0 engine and the
\&\f(CW\*(C`AS\*(C'\fR keyword:
.PP
.Vb 1
\&    SELECT * FROM tbl AS t1, tbl AS t2 WHERE t1.id = t2.id
.Ve
.PP
\&\f(CW\*(C`f_file\*(C'\fR can be an absolute path name or a relative path name but if
it is relative, it is interpreted as being relative to the \f(CW\*(C`f_dir\*(C'\fR
attribute of the table meta data. When \f(CW\*(C`f_file\*(C'\fR is set DBD::File will
use \f(CW\*(C`f_file\*(C'\fR as specified and will not attempt to work out an
alternative for \f(CW\*(C`f_file\*(C'\fR using the \f(CW\*(C`table name\*(C'\fR and \f(CW\*(C`f_ext\*(C'\fR
attribute.
.PP
While \f(CW\*(C`f_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
\fINew opportunities for attributes from DBI::DBD::SqlEngine\fR
.IX Subsection "New opportunities for attributes from DBI::DBD::SqlEngine"
.PP
sql_table_source
.IX Subsection "sql_table_source"
.PP
\&\f(CW\*(C`$dbh\->{sql_table_source}\*(C'\fR can be set to
\&\fIDBD::File::TableSource::FileSystem\fR (and is the default setting
of DBD::File). This provides usual behaviour of previous DBD::File
releases on
.PP
.Vb 2
\&  @ary = DBI\->data_sources ($driver);
\&  @ary = DBI\->data_sources ($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources ();
\&  @ary = $dbh\->data_sources (\e%attr);
\&
\&  @names = $dbh\->tables ($catalog, $schema, $table, $type);
\&  
\&  $sth = $dbh\->table_info ($catalog, $schema, $table, $type);
\&  $sth = $dbh\->table_info ($catalog, $schema, $table, $type, \e%attr);
\&
\&  $dbh\->func ("list_tables");
.Ve
.PP
sql_data_source
.IX Subsection "sql_data_source"
.PP
\&\f(CW\*(C`$dbh\->{sql_data_source}\*(C'\fR can be set to either
\&\fIDBD::File::DataSource::File\fR, which is default and provides the
well known behavior of DBD::File releases prior to 0.41, or
\&\fIDBD::File::DataSource::Stream\fR, which reuses already opened
file-handle for operations.
.PP
\fIInternally private attributes to deal with \s-1SQL\s0 backends\fR
.IX Subsection "Internally private attributes to deal with SQL backends"
.PP
Do not modify any of these private attributes unless you understand
the implications of doing so. The behavior of DBD::File and derived
DBDs might be unpredictable when one or more of those attributes are
modified.
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the version of loaded DBI::SQL::Nano.
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the version of loaded SQL::Statement.
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains either the text 'SQL::Statement' or 'DBI::SQL::Nano'.
.PP
sql_ram_tables
.IX Subsection "sql_ram_tables"
.PP
Contains optionally temporary tables.
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains optional flags to instantiate the SQL::Parser parsing engine
when SQL::Statement is used as \s-1SQL\s0 engine. See SQL::Parser for valid
flags.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBD::File is used directly. Because this is only reasonable for testing
purposes, the real names must be used instead. Those names can be computed
by replacing the \f(CW\*(C`f_\*(C'\fR in the method name with the driver prefix.
.PP
f_versions
.IX Subsection "f_versions"
.PP
Signature:
.PP
.Vb 6
\&  sub f_versions (;$)
\&  {
\&    my ($table_name) = @_;
\&    $table_name ||= ".";
\&    ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 9
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $f_versions = $dbh\->func ("f_versions");
\&    print "$f_versions\en";
\&    _\|_END_\|_
\&    # DBD::File              0.41 using IO::File (1.16)
\&    #   DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.406
\&    # DBI                    1.623
\&    # OS                     darwin (12.2.1)
\&    # Perl                   5.017006 (darwin\-thread\-multi\-ld\-2level)
.Ve
.PP
Called in list context, f_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
.IP "\(bu" 4
This module uses flock () internally but flock is not available on all
platforms. On MacOS and Windows 95 there is no locking at all (perhaps
not so important on MacOS and Windows 95, as there is only a single
user).
.IP "\(bu" 4
The module stores details about the handled tables in a private area
of the driver handle (\f(CW$drh\fR). This data area is not shared between
different driver instances, so several \f(CW\*(C`DBI\->connect ()\*(C'\fR calls will
cause different table instances and private data areas.
.Sp
This data area is filled for the first time when a table is accessed,
either via an \s-1SQL\s0 statement or via \f(CW\*(C`table_info\*(C'\fR and is not
destroyed until the table is dropped or the driver handle is released.
Manual destruction is possible via f_clear_meta.
.Sp
The following attributes are preserved in the data area and will
evaluated instead of driver globals:
.RS 4
.IP "f_ext" 8
.IX Item "f_ext"
.PD 0
.IP "f_dir" 8
.IX Item "f_dir"
.IP "f_dir_search" 8
.IX Item "f_dir_search"
.IP "f_lock" 8
.IX Item "f_lock"
.IP "f_lockfile" 8
.IX Item "f_lockfile"
.IP "f_encoding" 8
.IX Item "f_encoding"
.IP "f_schema" 8
.IX Item "f_schema"
.IP "col_names" 8
.IX Item "col_names"
.IP "sql_identifier_case" 8
.IX Item "sql_identifier_case"
.RE
.RS 4
.PD
.Sp
The following attributes are preserved in the data area only and
cannot be set globally.
.IP "f_file" 8
.IX Item "f_file"
.RE
.RS 4
.Sp
The following attributes are preserved in the data area only and are
computed when initializing the data area:
.IP "f_fqfn" 8
.IX Item "f_fqfn"
.PD 0
.IP "f_fqbn" 8
.IX Item "f_fqbn"
.IP "f_fqln" 8
.IX Item "f_fqln"
.IP "table_name" 8
.IX Item "table_name"
.RE
.RS 4
.PD
.Sp
For \s-1DBD::CSV\s0 tables this means, once opened \*(L"foo.csv\*(R" as table named \*(L"foo\*(R",
another table named \*(L"foo\*(R" accessing the file \*(L"foo.txt\*(R" cannot be opened.
Accessing \*(L"foo\*(R" will always access the file \*(L"foo.csv\*(R" in memorized
\&\f(CW\*(C`f_dir\*(C'\fR, locking \f(CW\*(C`f_lockfile\*(C'\fR via memorized \f(CW\*(C`f_lock\*(C'\fR.
.Sp
You can use f_clear_meta or the \f(CW\*(C`f_file\*(C'\fR attribute for a specific table
to work around this.
.RE
.IP "\(bu" 4
When used with SQL::Statement and temporary tables e.g.,
.Sp
.Vb 1
\&  CREATE TEMP TABLE ...
.Ve
.Sp
the table data processing bypasses DBD::File::Table. No file system
calls will be made and there are no clashes with existing (file based)
tables with the same name. Temporary tables are chosen over file
tables, but they will not covered by \f(CW\*(C`table_info\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2013 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, \s-1DBD::DBM\s0, \s-1DBD::CSV\s0, Text::CSV,
Text::CSV_XS, SQL::Statement, and
DBI::SQL::Nano
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Developers.3pm                    0100644 0001750 0001750 00000067640 12566241602 025104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Developers 3"
.TH DBD::File::Developers 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Developers \- Developers documentation for DBD::File
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw( DBD::File );
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver ($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw( DBD::File::dr );
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw( DBD::File::db );
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw( DBD::File::st );
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw( DBD::File::Statement );
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw( DBD::File::Table );
\&
\&    my %reset_on_modify = (
\&        myd_abc => "myd_foo",
\&        myd_mno => "myd_bar",
\&        );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify (\e%reset_on_modify);
\&    my %compat_map = (
\&        abc => \*(Aqfoo_abc\*(Aq,
\&        xyz => \*(Aqfoo_xyz\*(Aq,
\&        );
\&    _\|_PACKAGE_\|_\->register_compat_map (\e%compat_map);
\&
\&    sub bootstrap_table_meta { ... }
\&    sub init_table_meta { ... }
\&    sub table_meta_attr_changed { ... }
\&    sub open_data { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes how \s-1DBD\s0 developers can write DBD::File based \s-1DBI\s0
drivers. It supplements \s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::Developers,
which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and three
\&\s-1DBI\s0 related classes:
.IP "DBD::File::dr" 4
.IX Item "DBD::File::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw( DBD::File::dr );
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&      }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources\*(C'\fR and \f(CW\*(C`disconnect_all\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBD::File do not usually need to
override any of the methods provided through the DBD::XXX::dr package
however if you need additional initialization in the connect method
you may need to.
.IP "DBD::File::db" 4
.IX Item "DBD::File::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBD::File provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBD::File need to override the methods \f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBD::File::st" 4
.IX Item "DBD::File::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.SS "DBD::File"
.IX Subsection "DBD::File"
This is the main package containing the routines to initialize
DBD::File based \s-1DBI\s0 drivers. Primarily the \f(CW\*(C`DBD::File::driver\*(C'\fR
method is invoked, either directly from \s-1DBI\s0 when the driver is
initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBD::File );
\&
\&  sub driver
\&  {
\&      my ($class, $attr) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver ($attr);
\&      ...
\&      return $drh;
\&      }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBD::File takes care of it.
.SS "DBD::File::dr"
.IX Subsection "DBD::File::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBD::File based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.SS "DBD::File::db"
.IX Subsection "DBD::File::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
Methods provided by DBD::File:
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{$drv_prefix . "valid_attrs"}\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBD::File::db or a derived class.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attribute \f(CW\*(C`f_version\*(C'\fR with the version of DBD::File.
.Sp
This method is called at the begin of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_valid_attrs\*(C'\fR and \f(CW\*(C`f_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else. Compatibility table attribute
access must be initialized here to allow DBD::File to instantiate the
map tie:
.Sp
.Vb 6
\&    # for DBD::CSV
\&    $dbh\->{csv_meta} = "csv_tables";
\&    # for DBD::DBM
\&    $dbh\->{dbm_meta} = "dbm_tables";
\&    # for DBD::AnyData
\&    $dbh\->{ad_meta}  = "ad_tables";
.Ve
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes.
.Sp
\&\f(CW\*(C`DBD::File::db::init_default_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_meta\*(C'\fR, \f(CW\*(C`f_meta_map\*(C'\fR, \f(CW\*(C`f_version\*(C'\fR.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.
\&\f(CW\*(C`$dbh\->{dbm_readonly_attrs} = {...};\*(C'\fR), the attributes
\&\f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR, \f(CW\*(C`drv_version\*(C'\fR and \f(CW\*(C`drv_meta\*(C'\fR
are added (when available) to the list of valid and immutable attributes
(where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver prefix).
.Sp
If \f(CW\*(C`drv_meta\*(C'\fR is set, an attribute with the name in \f(CW\*(C`drv_meta\*(C'\fR is
initialized providing restricted read/write access to the meta data of the
tables using \f(CW\*(C`DBD::File::TieTables\*(C'\fR in the first (table) level and
\&\f(CW\*(C`DBD::File::TieMeta\*(C'\fR for the meta attribute level. \f(CW\*(C`DBD::File::TieTables\*(C'\fR
uses \f(CW\*(C`DBD::DRV::Table::get_table_meta\*(C'\fR to initialize the second level
tied hash on \s-1FETCH/STORE.\s0 The \f(CW\*(C`DBD::File::TieMeta\*(C'\fR class uses
\&\f(CW\*(C`DBD::DRV::Table::get_table_meta_attr\*(C'\fR to \s-1FETCH\s0 attribute values and
\&\f(CW\*(C`DBD::DRV::Table::set_table_meta_attr\*(C'\fR to \s-1STORE\s0 attribute values. This
allows it to map meta attributes for compatibility reasons.
.IP "get_single_table_meta" 4
.IX Item "get_single_table_meta"
.PD 0
.IP "get_file_meta" 4
.IX Item "get_file_meta"
.PD
Retrieve an attribute from a table's meta information. The method
signature is \f(CW\*(C`get_file_meta ($dbh, $table, $attr)\*(C'\fR. This method
is called by the injected db handle method \f(CW\*(C`${drv_prefix}get_meta\*(C'\fR.
.Sp
While get_file_meta allows \f(CW$table\fR or \f(CW$attr\fR to be a list of tables or
attributes to retrieve, get_single_table_meta allows only one table name
and only one attribute name. A table name of \f(CW\*(Aq.\*(Aq\fR (single dot) is
interpreted as the default table and this will retrieve the appropriate
attribute globally from the dbh. This has the same restrictions as
\&\f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.Sp
get_file_meta allows \f(CW\*(Aq+\*(Aq\fR and \f(CW\*(Aq*\*(Aq\fR as wildcards for table names and
\&\f(CW$table\fR being a regular expression matching against the table names
(evaluated without the default table). The table name \f(CW\*(Aq*\*(Aq\fR is
\&\fIall currently known tables, including the default one\fR. The table
name \f(CW\*(Aq+\*(Aq\fR is \fIall table names which conform to
\&\s-1ANSI\s0 file name restrictions\fR (/^[_A\-Za\-z0\-9]+$/).
.Sp
The table meta information is retrieved using the get_table_meta and
get_table_meta_attr methods of the table class of the implementation.
.IP "set_single_table_meta" 4
.IX Item "set_single_table_meta"
.PD 0
.IP "set_file_meta" 4
.IX Item "set_file_meta"
.PD
Sets an attribute in a table's meta information. The method signature is
\&\f(CW\*(C`set_file_meta ($dbh, $table, $attr, $value)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}set_meta\*(C'\fR.
.Sp
While set_file_meta allows \f(CW$table\fR to be a list of tables and \f(CW$attr\fR
to be a hash of several attributes to set, set_single_table_meta allows
only one table name and only one attribute name/value pair.
.Sp
The wildcard characters for the table name are the same as for
get_file_meta.
.Sp
The table meta information is updated using the get_table_meta and
set_table_meta_attr methods of the table class of the implementation.
.IP "clear_file_meta" 4
.IX Item "clear_file_meta"
Clears all meta information cached about a table. The method signature is
\&\f(CW\*(C`clear_file_meta ($dbh, $table)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}clear_meta\*(C'\fR.
.SS "DBD::File::st"
.IX Subsection "DBD::File::st"
Contains the methods to deal with prepared statement handles:
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches statement handle attributes. Supported attributes (for full overview
see \*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0) are \f(CW\*(C`NAME\*(C'\fR, \f(CW\*(C`TYPE\*(C'\fR, \f(CW\*(C`PRECISION\*(C'\fR
and \f(CW\*(C`NULLABLE\*(C'\fR in case that SQL::Statement is used as \s-1SQL\s0 execution engine
and a statement is successful prepared.  When SQL::Statement has additional
information about a table, those information are returned. Otherwise, the
same defaults as in DBI::DBD::SqlEngine are used.
.Sp
This method usually requires extending in a derived implementation.
See \s-1DBD::CSV\s0 or \s-1DBD::DBM\s0 for some example.
.SS "DBD::File::TableSource::FileSystem"
.IX Subsection "DBD::File::TableSource::FileSystem"
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBD::File::TableSource::FileSystem;
\&
\&  sub data_sources ($;$)
\&  {
\&      my ($class, $drh, $attrs) = @_;
\&      ...
\&      }
\&
\&  sub avail_tables
\&  {
\&      my ($class, $drh) = @_;
\&      ...
\&      }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources ($driver);
\&  @ary = DBI\->data_sources ($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources ();
\&  @ary = $dbh\->data_sources (\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables ($catalog, $schema, $table, $type);
\&  
\&  $sth   = $dbh\->table_info ($catalog, $schema, $table, $type);
\&  $sth   = $dbh\->table_info ($catalog, $schema, $table, $type, \e%attr);
\&
\&  $dbh\->func ("list_tables");
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default.
.SS "DBD::File::DataSource::Stream"
.IX Subsection "DBD::File::DataSource::Stream"
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  @DBD::File::DataSource::Stream::ISA = \*(AqDBI::DBD::SqlEngine::DataSource\*(Aq;
\&
\&  sub complete_table_name
\&  {
\&      my ($self, $meta, $file, $respect_case) = @_;
\&      ...
\&      }
.Ve
.PP
Clears all meta attributes identifying a file: \f(CW\*(C`f_fqfn\*(C'\fR, \f(CW\*(C`f_fqbn\*(C'\fR and
\&\f(CW\*(C`f_fqln\*(C'\fR. The table name is set according to \f(CW$respect_case\fR and
\&\f(CW\*(C`$meta\->{sql_identifier_case}\*(C'\fR (\s-1SQL_IC_LOWER, SQL_IC_UPPER\s0).
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub apply_encoding
\&  {
\&      my ($self, $meta, $fn) = @_;
\&      ...
\&      }
.Ve
.PP
Applies the encoding from \fImeta information\fR (\f(CW\*(C`$meta\->{f_encoding}\*(C'\fR)
to the file handled opened in \f(CW\*(C`open_data\*(C'\fR.
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub open_data
\&  {
\&      my ($self, $meta, $attrs, $flags) = @_;
\&      ...
\&      }
.Ve
.PP
Opens (\f(CW\*(C`dup (2)\*(C'\fR) the file handle provided in \f(CW\*(C`$meta\->{f_file}\*(C'\fR.
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub can_flock { ... }
.Ve
.PP
Returns whether \f(CW\*(C`flock (2)\*(C'\fR is available or not (avoids retesting in
subclasses).
.SS "DBD::File::DataSource::File"
.IX Subsection "DBD::File::DataSource::File"
.Vb 1
\&  package DBD::File::DataSource::File;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&      my ($self, $meta, $table, $respect_case) = @_;
\&      ...
\&      }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR tries to map a filename to the associated
table name.  It is called with a partially filled meta structure for the
resulting table containing at least the following attributes:
\&\f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
.PP
If a file/table map can be found then this method sets the \f(CW\*(C`f_fqfn\*(C'\fR, \f(CW\*(C`f_fqbn\*(C'\fR, \f(CW\*(C`f_fqln\*(C'\fR and \f(CW\*(C`table_name\*(C'\fR attributes in
the meta structure. If a map cannot be found the table name will be
undef.
.PP
.Vb 1
\&  package DBD::File::DataSource::File;
\&
\&  sub open_data ($)
\&  {
\&      my ($self, $meta, $attrs, $flags) = @_;
\&      ...
\&      }
.Ve
.PP
Depending on the attributes set in the table's meta data, the
following steps are performed. Unless \f(CW\*(C`f_dontopen\*(C'\fR is set to a
true value, \f(CW\*(C`f_fqfn\*(C'\fR must contain the full qualified file name
for the table to work on (file2table ensures this). The encoding in
\&\f(CW\*(C`f_encoding\*(C'\fR is applied if set and the file is opened. If
\&\f(CW\*(C`<f_fqln \*(C'\fR> (full qualified lock name) is set, this file is opened,
too. Depending on the value in \f(CW\*(C`f_lock\*(C'\fR, the appropriate lock is
set on the opened data file or lock file.
.SS "DBD::File::Statement"
.IX Subsection "DBD::File::Statement"
Derives from DBI::SQL::Nano::Statement to provide following method:
.IP "open_table" 4
.IX Item "open_table"
Implements the open_table method required by SQL::Statement and
DBI::SQL::Nano. All the work for opening the file(s) belonging to the
table is handled and parametrized in DBD::File::Table. Unless you intend
to add anything to the following implementation, an empty DBD::XXX::Statement
package satisfies DBD::File.
.Sp
.Vb 3
\&  sub open_table ($$$$$)
\&  {
\&      my ($self, $data, $table, $createMode, $lockMode) = @_;
\&
\&      my $class = ref $self;
\&      $class =~ s/::Statement/::Table/;
\&
\&      my $flags = {
\&          createMode => $createMode,
\&          lockMode   => $lockMode,
\&          };
\&      $self\->{command} eq "DROP" and $flags\->{dropMode} = 1;
\&
\&      return $class\->new ($data, { table => $table }, $flags);
\&      } # open_table
.Ve
.SS "DBD::File::Table"
.IX Subsection "DBD::File::Table"
Derives from DBI::SQL::Nano::Table and provides physical file access for
the table data which are stored in the files.
.IP "bootstrap_table_meta" 4
.IX Item "bootstrap_table_meta"
Initializes a table meta structure. Can be safely overridden in a
derived class, as long as the \f(CW\*(C`SUPER\*(C'\fR method is called at the end
of the overridden method.
.Sp
It copies the following attributes from the database into the table meta data
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR
and \f(CW\*(C`f_lockfile\*(C'\fR and makes them sticky to the table.
.Sp
This method should be called before you attempt to map between file
name and table name to ensure the correct directory, extension etc. are
used.
.IP "init_table_meta" 4
.IX Item "init_table_meta"
Initializes more attributes of the table meta data \- usually more
expensive ones (e.g. those which require class instantiations) \- when
the file name and the table name could mapped.
.IP "get_table_meta" 4
.IX Item "get_table_meta"
Returns the table meta data. If there are none for the required
table, a new one is initialized. When it fails, nothing is
returned. On success, the name of the table and the meta data
structure is returned.
.IP "get_table_meta_attr" 4
.IX Item "get_table_meta_attr"
Returns a single attribute from the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "set_table_meta_attr" 4
.IX Item "set_table_meta_attr"
Sets a single attribute in the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "table_meta_attr_changed" 4
.IX Item "table_meta_attr_changed"
Called when an attribute of the meta data is modified.
.Sp
If the modified attribute requires to reset a calculated attribute, the
calculated attribute is reset (deleted from meta data structure) and
the \fIinitialized\fR flag is removed, too. The decision is made based on
\&\f(CW%register_reset_on_modify\fR.
.IP "register_reset_on_modify" 4
.IX Item "register_reset_on_modify"
Allows \f(CW\*(C`set_table_meta_attr\*(C'\fR to reset meta attributes when special
attributes are modified. For DBD::File, modifying one of \f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_ext\*(C'\fR or \f(CW\*(C`f_lockfile\*(C'\fR will reset \f(CW\*(C`f_fqfn\*(C'\fR. \s-1DBD::DBM\s0 extends the
list for \f(CW\*(C`dbm_type\*(C'\fR and \f(CW\*(C`dbm_mldbm\*(C'\fR to reset the value of \f(CW\*(C`dbm_tietype\*(C'\fR.
.Sp
If your \s-1DBD\s0 has calculated values in the meta data area, then call
\&\f(CW\*(C`register_reset_on_modify\*(C'\fR:
.Sp
.Vb 2
\&  my %reset_on_modify = (xxx_foo => "xxx_bar");
\&  _\|_PACKAGE_\|_\->register_reset_on_modify (\e%reset_on_modify);
.Ve
.IP "register_compat_map" 4
.IX Item "register_compat_map"
Allows \f(CW\*(C`get_table_meta_attr\*(C'\fR and \f(CW\*(C`set_table_meta_attr\*(C'\fR to update the
attribute name to the current favored one:
.Sp
.Vb 3
\&  # from DBD::DBM
\&  my %compat_map = (dbm_ext => "f_ext");
\&  _\|_PACKAGE_\|_\->register_compat_map (\e%compat_map);
.Ve
.IP "open_file" 4
.IX Item "open_file"
Called to open the table's data file.
.Sp
Depending on the attributes set in the table's meta data, the
following steps are performed. Unless \f(CW\*(C`f_dontopen\*(C'\fR is set to a
true value, \f(CW\*(C`f_fqfn\*(C'\fR must contain the full qualified file name
for the table to work on (file2table ensures this). The encoding in
\&\f(CW\*(C`f_encoding\*(C'\fR is applied if set and the file is opened. If
\&\f(CW\*(C`<f_fqln \*(C'\fR> (full qualified lock name) is set, this file is opened,
too. Depending on the value in \f(CW\*(C`f_lock\*(C'\fR, the appropriate lock is
set on the opened data file or lock file.
.Sp
After this is done, a derived class might add more steps in an overridden
\&\f(CW\*(C`open_file\*(C'\fR method.
.IP "new" 4
.IX Item "new"
Instantiates the table. This is done in 3 steps:
.Sp
.Vb 3
\& 1. get the table meta data
\& 2. open the data file
\& 3. bless the table data structure using inherited constructor new
.Ve
.Sp
It is not recommended to override the constructor of the table class.
Find a reasonable place to add you extensions in one of the above four
methods.
.IP "drop" 4
.IX Item "drop"
Implements the abstract table method for the \f(CW\*(C`DROP\*(C'\fR
command. Discards table meta data after all files belonging to the
table are closed and unlinked.
.Sp
Overriding this method might be reasonable in very rare cases.
.IP "seek" 4
.IX Item "seek"
Implements the abstract table method used when accessing the table from the
engine. \f(CW\*(C`seek\*(C'\fR is called every time the engine uses dumb algorithms
for iterating over the table content.
.IP "truncate" 4
.IX Item "truncate"
Implements the abstract table method used when dumb table algorithms
for \f(CW\*(C`UPDATE\*(C'\fR or \f(CW\*(C`DELETE\*(C'\fR need to truncate the table storage
after the last written row.
.PP
You should consult the documentation of \f(CW\*(C`SQL::Eval::Table\*(C'\fR (see
SQL::Eval) to get more information about the abstract methods of the
table's base class you have to override and a description of the table
meta information expected by the \s-1SQL\s0 engines.
.SH "AUTHOR"
.IX Header "AUTHOR"
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010\-2013 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Developers5.16.3pm                0100644 0001750 0001750 00000060441 12566241600 025404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Developers 3"
.TH DBD::File::Developers 3 "2010-09-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Developers \- Developers documentation for DBD::File
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBD::File);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBD::File::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBD::File::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBD::File::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBD::File::Statement);
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBD::File::Table);
\&
\&    my %reset_on_modify = (
\&                            myd_abc => "myd_foo",
\&                            myd_mno => "myd_bar",
\&                          );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
\&    my %compat_map = (
\&                       abc => \*(Aqfoo_abc\*(Aq,
\&                       xyz => \*(Aqfoo_xyz\*(Aq,
\&                     );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
\&
\&    sub bootstrap_table_meta { ... }
\&    sub init_table_meta { ... }
\&    sub table_meta_attr_changed { ... }
\&    sub open_file { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes how \s-1DBD\s0 developers can write DBD::File based \s-1DBI\s0
drivers. It supplements \s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::Developers,
which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and three
\&\s-1DBI\s0 related classes:
.IP "DBD::File::dr" 4
.IX Item "DBD::File::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw(DBD::File::dr);
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&  }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources ()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBD::File do not usually need to
override any of the methods provided through the DBD::XXX::dr package
however if you need additional initialization in the connect method
you may need to.
.IP "DBD::File::db" 4
.IX Item "DBD::File::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBD::File provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBD::File need to override the methods \f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBD::File::st" 4
.IX Item "DBD::File::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.SS "DBD::File"
.IX Subsection "DBD::File"
This is the main package containing the routines to initialize
DBD::File based \s-1DBI\s0 drivers. Primarily the \f(CW\*(C`DBD::File::driver\*(C'\fR
method is invoked, either directly from \s-1DBI\s0 when the driver is
initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBD::File );
\&
\&  sub driver
\&  {
\&      my ( $class, $attr ) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver( $attr );
\&      ...
\&      return $drh;
\&  }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBD::File takes care of it.
.SS "DBD::File::dr"
.IX Subsection "DBD::File::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBD::File based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.SS "DBD::File::db"
.IX Subsection "DBD::File::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
Methods provided by DBD::File:
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{ $drv_prefix . "valid_attrs" }\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBD::File::db or a derived class.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attribute \f(CW\*(C`f_version\*(C'\fR with the version of DBD::File.
.Sp
This method is called at the begin of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_valid_attrs\*(C'\fR and \f(CW\*(C`f_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else. Compatibility table attribute
access must be initialized here to allow DBD::File to instantiate the
map tie:
.Sp
.Vb 6
\&    # for DBD::CSV
\&    $dbh\->{csv_meta} = "csv_tables";
\&    # for DBD::DBM
\&    $dbh\->{dbm_meta} = "dbm_tables";
\&    # for DBD::AnyData
\&    $dbh\->{ad_meta}  = "ad_tables";
.Ve
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes.
.Sp
\&\f(CW\*(C`DBD::File::db::init_default_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_meta\*(C'\fR, \f(CW\*(C`f_meta_map\*(C'\fR, \f(CW\*(C`f_version\*(C'\fR.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.  \f(CW\*(C`$dbh\->{dbm_readonly_attrs}
= {...};\*(C'\fR), the attributes \f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR,
\&\f(CW\*(C`drv_version\*(C'\fR and \f(CW\*(C`drv_meta\*(C'\fR are added (when available) to the list of
valid and immutable attributes (where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver
prefix).
.Sp
If \f(CW\*(C`drv_meta\*(C'\fR is set, an attribute with the name in \f(CW\*(C`drv_meta\*(C'\fR is
initialized providing restricted read/write access to the meta data of the
tables using \f(CW\*(C`DBD::File::TieTables\*(C'\fR in the first (table) level and
\&\f(CW\*(C`DBD::File::TieMeta\*(C'\fR for the meta attribute level. \f(CW\*(C`DBD::File::TieTables\*(C'\fR
uses \f(CW\*(C`DBD::DRV::Table::get_table_meta\*(C'\fR to initialize the second level
tied hash on \s-1FETCH/STORE\s0. The \f(CW\*(C`DBD::File::TieMeta\*(C'\fR class uses
\&\f(CW\*(C`DBD::DRV::Table::get_table_meta_attr\*(C'\fR to \s-1FETCH\s0 attribute values and
\&\f(CW\*(C`DBD::DRV::Table::set_table_meta_attr\*(C'\fR to \s-1STORE\s0 attribute values. This
allows it to map meta attributes for compatibility reasons.
.IP "get_single_table_meta" 4
.IX Item "get_single_table_meta"
.PD 0
.IP "get_file_meta" 4
.IX Item "get_file_meta"
.PD
Retrieve an attribute from a table's meta information. The method
signature is \f(CW\*(C`get_file_meta ($dbh, $table, $attr)\*(C'\fR. This method
is called by the injected db handle method \f(CW\*(C`${drv_prefix}get_meta\*(C'\fR.
.Sp
While get_file_meta allows \f(CW$table\fR or \f(CW$attr\fR to be a list of tables or
attributes to retrieve, get_single_table_meta allows only one table name
and only one attribute name. A table name of \f(CW\*(Aq.\*(Aq\fR (single dot) is
interpreted as the default table and this will retrieve the appropriate
attribute globally from the dbh. This has the same restrictions as
\&\f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.Sp
get_file_meta allows \f(CW\*(Aq+\*(Aq\fR and \f(CW\*(Aq*\*(Aq\fR as wildcards for table names and
\&\f(CW$table\fR being a regular expression matching against the table names
(evaluated without the default table). The table name \f(CW\*(Aq*\*(Aq\fR is
\&\fIall currently known tables, including the default one\fR. The table
name \f(CW\*(Aq+\*(Aq\fR is \fIall table names which conform to
\&\s-1ANSI\s0 file name restrictions\fR (/^[_A\-Za\-z0\-9]+$/).
.Sp
The table meta information is retrieved using the get_table_meta and
get_table_meta_attr methods of the table class of the implementation.
.IP "set_single_table_meta" 4
.IX Item "set_single_table_meta"
.PD 0
.IP "set_file_meta" 4
.IX Item "set_file_meta"
.PD
Sets an attribute in a table's meta information. The method signature is
\&\f(CW\*(C`set_file_meta ($dbh, $table, $attr, $value)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}set_meta\*(C'\fR.
.Sp
While set_file_meta allows \f(CW$table\fR to be a list of tables and \f(CW$attr\fR
to be a hash of several attributes to set, set_single_table_meta allows
only one table name and only one attribute name/value pair.
.Sp
The wildcard characters for the table name are the same as for
get_file_meta.
.Sp
The table meta information is updated using the get_table_meta and
set_table_meta_attr methods of the table class of the implementation.
.IP "clear_file_meta" 4
.IX Item "clear_file_meta"
Clears all meta information cached about a table. The method signature is
\&\f(CW\*(C`clear_file_meta ($dbh, $table)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}clear_meta\*(C'\fR.
.SS "DBD::File::st"
.IX Subsection "DBD::File::st"
Contains the methods to deal with prepared statement handles:
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches statement handle attributes. Supported attributes (for full overview
see \*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0) are \f(CW\*(C`NAME\*(C'\fR, \f(CW\*(C`TYPE\*(C'\fR, \f(CW\*(C`PRECISION\*(C'\fR
and \f(CW\*(C`NULLABLE\*(C'\fR in case that SQL::Statement is used as \s-1SQL\s0 execution engine
and a statement is successful prepared.  When SQL::Statement has additional
information about a table, those information are returned. Otherwise, the
same defaults as in DBI::DBD::SqlEngine are used.
.Sp
This method usually requires extending in a derived implementation.
See \s-1DBD::CSV\s0 or \s-1DBD::DBM\s0 for some example.
.SS "DBD::File::Statement"
.IX Subsection "DBD::File::Statement"
Derives from DBI::SQL::Nano::Statement to provide following method:
.IP "open_table" 4
.IX Item "open_table"
Implements the open_table method required by SQL::Statement and
DBI::SQL::Nano. All the work for opening the file(s) belonging to the
table is handled and parameterized in DBD::File::Table. Unless you intend
to add anything to the following implementation, an empty DBD::XXX::Statement
package satisfies DBD::File.
.Sp
.Vb 3
\&  sub open_table ($$$$$)
\&  {
\&      my ($self, $data, $table, $createMode, $lockMode) = @_;
\&
\&      my $class = ref $self;
\&      $class =~ s/::Statement/::Table/;
\&
\&      my $flags = {
\&          createMode    => $createMode,
\&          lockMode      => $lockMode,
\&          };
\&      $self\->{command} eq "DROP" and $flags\->{dropMode} = 1;
\&
\&      return $class\->new ($data, { table => $table }, $flags);
\&      } # open_table
.Ve
.SS "DBD::File::Table"
.IX Subsection "DBD::File::Table"
Derives from DBI::SQL::Nano::Table and provides physical file access for
the table data which are stored in the files.
.IP "file2table" 4
.IX Item "file2table"
This method tries to map a filename to the associated table
name.  It is called with a partially filled meta structure for the
resulting table containing at least the following attributes:
\&\f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
.Sp
If a file/table map can be found then this method sets the \f(CW\*(C`f_fqfn\*(C'\fR, \f(CW\*(C`f_fqbn\*(C'\fR, \f(CW\*(C`f_fqln\*(C'\fR and \f(CW\*(C`table_name\*(C'\fR attributes in
the meta structure. If a map cannot be found the table name will be
undef.
.IP "bootstrap_table_meta" 4
.IX Item "bootstrap_table_meta"
Initializes a table meta structure. Can be safely overridden in a
derived class, as long as the \f(CW\*(C`SUPER\*(C'\fR method is called at the end
of the overridden method.
.Sp
It copies the following attributes from the database into the table meta data
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR,
\&\f(CW\*(C`f_lockfile\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR and makes them sticky to the
table.
.Sp
This method should be called before you attempt to map between file
name and table name to ensure the correct directory, extension etc. are
used.
.IP "init_table_meta" 4
.IX Item "init_table_meta"
Initializes more attributes of the table meta data \- usually more
expensive ones (e.g. those which require class instantiations) \- when
the file name and the table name could mapped.
.IP "get_table_meta" 4
.IX Item "get_table_meta"
Returns the table meta data. If there are none for the required
table, a new one is initialized. When it fails, nothing is
returned. On success, the name of the table and the meta data
structure is returned.
.IP "get_table_meta_attr" 4
.IX Item "get_table_meta_attr"
Returns a single attribute from the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "set_table_meta_attr" 4
.IX Item "set_table_meta_attr"
Sets a single attribute in the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "table_meta_attr_changed" 4
.IX Item "table_meta_attr_changed"
Called when an attribute of the meta data is modified.
.Sp
If the modified attribute requires to reset a calculated attribute, the
calculated attribute is reset (deleted from meta data structure) and
the \fIinitialized\fR flag is removed, too. The decision is made based on
\&\f(CW%register_reset_on_modify\fR.
.IP "register_reset_on_modify" 4
.IX Item "register_reset_on_modify"
Allows \f(CW\*(C`set_table_meta_attr\*(C'\fR to reset meta attributes when special
attributes are modified. For DBD::File, modifying one of \f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_ext\*(C'\fR or \f(CW\*(C`f_lockfile\*(C'\fR will reset \f(CW\*(C`f_fqfn\*(C'\fR. \s-1DBD::DBM\s0 extends the
list for \f(CW\*(C`dbm_type\*(C'\fR and \f(CW\*(C`dbm_mldbm\*(C'\fR to reset the value of \f(CW\*(C`dbm_tietype\*(C'\fR.
.Sp
If your \s-1DBD\s0 has calculated values in the meta data area, then call
\&\f(CW\*(C`register_reset_on_modify\*(C'\fR:
.Sp
.Vb 2
\&    my %reset_on_modify = ( "xxx_foo" => "xxx_bar" );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
.Ve
.IP "register_compat_map" 4
.IX Item "register_compat_map"
Allows \f(CW\*(C`get_table_meta_attr\*(C'\fR and \f(CW\*(C`set_table_meta_attr\*(C'\fR to update the
attribute name to the current favored one:
.Sp
.Vb 3
\&    # from DBD::DBM
\&    my %compat_map = ( "dbm_ext" => "f_ext" );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
.Ve
.IP "open_file" 4
.IX Item "open_file"
Called to open the table's data file.
.Sp
Depending on the attributes set in the table's meta data, the
following steps are performed. Unless \f(CW\*(C`f_dontopen\*(C'\fR is set to a
true value, \f(CW\*(C`f_fqfn\*(C'\fR must contain the full qualified file name
for the table to work on (file2table ensures this). The encoding in
\&\f(CW\*(C`f_encoding\*(C'\fR is applied if set and the file is opened. If
\&\f(CW\*(C`<f_fqln \*(C'\fR> (full qualified lock name) is set, this file is opened,
too. Depending on the value in \f(CW\*(C`f_lock\*(C'\fR, the appropriate lock is
set on the opened data file or lock file.
.Sp
After this is done, a derived class might add more steps in an overridden
\&\f(CW\*(C`open_file\*(C'\fR method.
.IP "new" 4
.IX Item "new"
Instantiates the table. This is done in 3 steps:
.Sp
.Vb 3
\& 1. get the table meta data
\& 2. open the data file
\& 3. bless the table data structure using inherited constructor new
.Ve
.Sp
It is not recommended to override the constructor of the table class.
Find a reasonable place to add you extensions in one of the above four
methods.
.IP "drop" 4
.IX Item "drop"
Implements the abstract table method for the \f(CW\*(C`DROP\*(C'\fR
command. Discards table meta data after all files belonging to the
table are closed and unlinked.
.Sp
Overriding this method might be reasonable in very rare cases.
.IP "seek" 4
.IX Item "seek"
Implements the abstract table method used when accessing the table from the
engine. \f(CW\*(C`seek\*(C'\fR is called every time the engine uses dumb algorithms
for iterating over the table content.
.IP "truncate" 4
.IX Item "truncate"
Implements the abstract table method used when dumb table algorithms
for \f(CW\*(C`UPDATE\*(C'\fR or \f(CW\*(C`DELETE\*(C'\fR need to truncate the table storage
after the last written row.
.PP
You should consult the documentation of \f(CW\*(C`SQL::Eval::Table\*(C'\fR (see
SQL::Eval) to get more information about the abstract methods of the
table's base class you have to override and a description of the table
meta information expected by the \s-1SQL\s0 engines.
.SH "AUTHOR"
.IX Header "AUTHOR"
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Developers5.18.3pm                0100644 0001750 0001750 00000067640 12566241602 025420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Developers 3"
.TH DBD::File::Developers 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Developers \- Developers documentation for DBD::File
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw( DBD::File );
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver ($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw( DBD::File::dr );
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw( DBD::File::db );
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw( DBD::File::st );
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw( DBD::File::Statement );
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw( DBD::File::Table );
\&
\&    my %reset_on_modify = (
\&        myd_abc => "myd_foo",
\&        myd_mno => "myd_bar",
\&        );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify (\e%reset_on_modify);
\&    my %compat_map = (
\&        abc => \*(Aqfoo_abc\*(Aq,
\&        xyz => \*(Aqfoo_xyz\*(Aq,
\&        );
\&    _\|_PACKAGE_\|_\->register_compat_map (\e%compat_map);
\&
\&    sub bootstrap_table_meta { ... }
\&    sub init_table_meta { ... }
\&    sub table_meta_attr_changed { ... }
\&    sub open_data { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes how \s-1DBD\s0 developers can write DBD::File based \s-1DBI\s0
drivers. It supplements \s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::Developers,
which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and three
\&\s-1DBI\s0 related classes:
.IP "DBD::File::dr" 4
.IX Item "DBD::File::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw( DBD::File::dr );
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&      }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources\*(C'\fR and \f(CW\*(C`disconnect_all\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBD::File do not usually need to
override any of the methods provided through the DBD::XXX::dr package
however if you need additional initialization in the connect method
you may need to.
.IP "DBD::File::db" 4
.IX Item "DBD::File::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBD::File provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBD::File need to override the methods \f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBD::File::st" 4
.IX Item "DBD::File::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.SS "DBD::File"
.IX Subsection "DBD::File"
This is the main package containing the routines to initialize
DBD::File based \s-1DBI\s0 drivers. Primarily the \f(CW\*(C`DBD::File::driver\*(C'\fR
method is invoked, either directly from \s-1DBI\s0 when the driver is
initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBD::File );
\&
\&  sub driver
\&  {
\&      my ($class, $attr) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver ($attr);
\&      ...
\&      return $drh;
\&      }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBD::File takes care of it.
.SS "DBD::File::dr"
.IX Subsection "DBD::File::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBD::File based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.SS "DBD::File::db"
.IX Subsection "DBD::File::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
Methods provided by DBD::File:
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{$drv_prefix . "valid_attrs"}\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBD::File::db or a derived class.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attribute \f(CW\*(C`f_version\*(C'\fR with the version of DBD::File.
.Sp
This method is called at the begin of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBD::File::db::init_valid_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_valid_attrs\*(C'\fR and \f(CW\*(C`f_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else. Compatibility table attribute
access must be initialized here to allow DBD::File to instantiate the
map tie:
.Sp
.Vb 6
\&    # for DBD::CSV
\&    $dbh\->{csv_meta} = "csv_tables";
\&    # for DBD::DBM
\&    $dbh\->{dbm_meta} = "dbm_tables";
\&    # for DBD::AnyData
\&    $dbh\->{ad_meta}  = "ad_tables";
.Ve
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes.
.Sp
\&\f(CW\*(C`DBD::File::db::init_default_attributes\*(C'\fR initializes the attributes
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_meta\*(C'\fR, \f(CW\*(C`f_meta_map\*(C'\fR, \f(CW\*(C`f_version\*(C'\fR.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.
\&\f(CW\*(C`$dbh\->{dbm_readonly_attrs} = {...};\*(C'\fR), the attributes
\&\f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR, \f(CW\*(C`drv_version\*(C'\fR and \f(CW\*(C`drv_meta\*(C'\fR
are added (when available) to the list of valid and immutable attributes
(where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver prefix).
.Sp
If \f(CW\*(C`drv_meta\*(C'\fR is set, an attribute with the name in \f(CW\*(C`drv_meta\*(C'\fR is
initialized providing restricted read/write access to the meta data of the
tables using \f(CW\*(C`DBD::File::TieTables\*(C'\fR in the first (table) level and
\&\f(CW\*(C`DBD::File::TieMeta\*(C'\fR for the meta attribute level. \f(CW\*(C`DBD::File::TieTables\*(C'\fR
uses \f(CW\*(C`DBD::DRV::Table::get_table_meta\*(C'\fR to initialize the second level
tied hash on \s-1FETCH/STORE.\s0 The \f(CW\*(C`DBD::File::TieMeta\*(C'\fR class uses
\&\f(CW\*(C`DBD::DRV::Table::get_table_meta_attr\*(C'\fR to \s-1FETCH\s0 attribute values and
\&\f(CW\*(C`DBD::DRV::Table::set_table_meta_attr\*(C'\fR to \s-1STORE\s0 attribute values. This
allows it to map meta attributes for compatibility reasons.
.IP "get_single_table_meta" 4
.IX Item "get_single_table_meta"
.PD 0
.IP "get_file_meta" 4
.IX Item "get_file_meta"
.PD
Retrieve an attribute from a table's meta information. The method
signature is \f(CW\*(C`get_file_meta ($dbh, $table, $attr)\*(C'\fR. This method
is called by the injected db handle method \f(CW\*(C`${drv_prefix}get_meta\*(C'\fR.
.Sp
While get_file_meta allows \f(CW$table\fR or \f(CW$attr\fR to be a list of tables or
attributes to retrieve, get_single_table_meta allows only one table name
and only one attribute name. A table name of \f(CW\*(Aq.\*(Aq\fR (single dot) is
interpreted as the default table and this will retrieve the appropriate
attribute globally from the dbh. This has the same restrictions as
\&\f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.Sp
get_file_meta allows \f(CW\*(Aq+\*(Aq\fR and \f(CW\*(Aq*\*(Aq\fR as wildcards for table names and
\&\f(CW$table\fR being a regular expression matching against the table names
(evaluated without the default table). The table name \f(CW\*(Aq*\*(Aq\fR is
\&\fIall currently known tables, including the default one\fR. The table
name \f(CW\*(Aq+\*(Aq\fR is \fIall table names which conform to
\&\s-1ANSI\s0 file name restrictions\fR (/^[_A\-Za\-z0\-9]+$/).
.Sp
The table meta information is retrieved using the get_table_meta and
get_table_meta_attr methods of the table class of the implementation.
.IP "set_single_table_meta" 4
.IX Item "set_single_table_meta"
.PD 0
.IP "set_file_meta" 4
.IX Item "set_file_meta"
.PD
Sets an attribute in a table's meta information. The method signature is
\&\f(CW\*(C`set_file_meta ($dbh, $table, $attr, $value)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}set_meta\*(C'\fR.
.Sp
While set_file_meta allows \f(CW$table\fR to be a list of tables and \f(CW$attr\fR
to be a hash of several attributes to set, set_single_table_meta allows
only one table name and only one attribute name/value pair.
.Sp
The wildcard characters for the table name are the same as for
get_file_meta.
.Sp
The table meta information is updated using the get_table_meta and
set_table_meta_attr methods of the table class of the implementation.
.IP "clear_file_meta" 4
.IX Item "clear_file_meta"
Clears all meta information cached about a table. The method signature is
\&\f(CW\*(C`clear_file_meta ($dbh, $table)\*(C'\fR. This method is called
by the injected db handle method \f(CW\*(C`${drv_prefix}clear_meta\*(C'\fR.
.SS "DBD::File::st"
.IX Subsection "DBD::File::st"
Contains the methods to deal with prepared statement handles:
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches statement handle attributes. Supported attributes (for full overview
see \*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0) are \f(CW\*(C`NAME\*(C'\fR, \f(CW\*(C`TYPE\*(C'\fR, \f(CW\*(C`PRECISION\*(C'\fR
and \f(CW\*(C`NULLABLE\*(C'\fR in case that SQL::Statement is used as \s-1SQL\s0 execution engine
and a statement is successful prepared.  When SQL::Statement has additional
information about a table, those information are returned. Otherwise, the
same defaults as in DBI::DBD::SqlEngine are used.
.Sp
This method usually requires extending in a derived implementation.
See \s-1DBD::CSV\s0 or \s-1DBD::DBM\s0 for some example.
.SS "DBD::File::TableSource::FileSystem"
.IX Subsection "DBD::File::TableSource::FileSystem"
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBD::File::TableSource::FileSystem;
\&
\&  sub data_sources ($;$)
\&  {
\&      my ($class, $drh, $attrs) = @_;
\&      ...
\&      }
\&
\&  sub avail_tables
\&  {
\&      my ($class, $drh) = @_;
\&      ...
\&      }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources ($driver);
\&  @ary = DBI\->data_sources ($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources ();
\&  @ary = $dbh\->data_sources (\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables ($catalog, $schema, $table, $type);
\&  
\&  $sth   = $dbh\->table_info ($catalog, $schema, $table, $type);
\&  $sth   = $dbh\->table_info ($catalog, $schema, $table, $type, \e%attr);
\&
\&  $dbh\->func ("list_tables");
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default.
.SS "DBD::File::DataSource::Stream"
.IX Subsection "DBD::File::DataSource::Stream"
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  @DBD::File::DataSource::Stream::ISA = \*(AqDBI::DBD::SqlEngine::DataSource\*(Aq;
\&
\&  sub complete_table_name
\&  {
\&      my ($self, $meta, $file, $respect_case) = @_;
\&      ...
\&      }
.Ve
.PP
Clears all meta attributes identifying a file: \f(CW\*(C`f_fqfn\*(C'\fR, \f(CW\*(C`f_fqbn\*(C'\fR and
\&\f(CW\*(C`f_fqln\*(C'\fR. The table name is set according to \f(CW$respect_case\fR and
\&\f(CW\*(C`$meta\->{sql_identifier_case}\*(C'\fR (\s-1SQL_IC_LOWER, SQL_IC_UPPER\s0).
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub apply_encoding
\&  {
\&      my ($self, $meta, $fn) = @_;
\&      ...
\&      }
.Ve
.PP
Applies the encoding from \fImeta information\fR (\f(CW\*(C`$meta\->{f_encoding}\*(C'\fR)
to the file handled opened in \f(CW\*(C`open_data\*(C'\fR.
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub open_data
\&  {
\&      my ($self, $meta, $attrs, $flags) = @_;
\&      ...
\&      }
.Ve
.PP
Opens (\f(CW\*(C`dup (2)\*(C'\fR) the file handle provided in \f(CW\*(C`$meta\->{f_file}\*(C'\fR.
.PP
.Vb 1
\&  package DBD::File::DataSource::Stream;
\&
\&  sub can_flock { ... }
.Ve
.PP
Returns whether \f(CW\*(C`flock (2)\*(C'\fR is available or not (avoids retesting in
subclasses).
.SS "DBD::File::DataSource::File"
.IX Subsection "DBD::File::DataSource::File"
.Vb 1
\&  package DBD::File::DataSource::File;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&      my ($self, $meta, $table, $respect_case) = @_;
\&      ...
\&      }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR tries to map a filename to the associated
table name.  It is called with a partially filled meta structure for the
resulting table containing at least the following attributes:
\&\f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_lockfile\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
.PP
If a file/table map can be found then this method sets the \f(CW\*(C`f_fqfn\*(C'\fR, \f(CW\*(C`f_fqbn\*(C'\fR, \f(CW\*(C`f_fqln\*(C'\fR and \f(CW\*(C`table_name\*(C'\fR attributes in
the meta structure. If a map cannot be found the table name will be
undef.
.PP
.Vb 1
\&  package DBD::File::DataSource::File;
\&
\&  sub open_data ($)
\&  {
\&      my ($self, $meta, $attrs, $flags) = @_;
\&      ...
\&      }
.Ve
.PP
Depending on the attributes set in the table's meta data, the
following steps are performed. Unless \f(CW\*(C`f_dontopen\*(C'\fR is set to a
true value, \f(CW\*(C`f_fqfn\*(C'\fR must contain the full qualified file name
for the table to work on (file2table ensures this). The encoding in
\&\f(CW\*(C`f_encoding\*(C'\fR is applied if set and the file is opened. If
\&\f(CW\*(C`<f_fqln \*(C'\fR> (full qualified lock name) is set, this file is opened,
too. Depending on the value in \f(CW\*(C`f_lock\*(C'\fR, the appropriate lock is
set on the opened data file or lock file.
.SS "DBD::File::Statement"
.IX Subsection "DBD::File::Statement"
Derives from DBI::SQL::Nano::Statement to provide following method:
.IP "open_table" 4
.IX Item "open_table"
Implements the open_table method required by SQL::Statement and
DBI::SQL::Nano. All the work for opening the file(s) belonging to the
table is handled and parametrized in DBD::File::Table. Unless you intend
to add anything to the following implementation, an empty DBD::XXX::Statement
package satisfies DBD::File.
.Sp
.Vb 3
\&  sub open_table ($$$$$)
\&  {
\&      my ($self, $data, $table, $createMode, $lockMode) = @_;
\&
\&      my $class = ref $self;
\&      $class =~ s/::Statement/::Table/;
\&
\&      my $flags = {
\&          createMode => $createMode,
\&          lockMode   => $lockMode,
\&          };
\&      $self\->{command} eq "DROP" and $flags\->{dropMode} = 1;
\&
\&      return $class\->new ($data, { table => $table }, $flags);
\&      } # open_table
.Ve
.SS "DBD::File::Table"
.IX Subsection "DBD::File::Table"
Derives from DBI::SQL::Nano::Table and provides physical file access for
the table data which are stored in the files.
.IP "bootstrap_table_meta" 4
.IX Item "bootstrap_table_meta"
Initializes a table meta structure. Can be safely overridden in a
derived class, as long as the \f(CW\*(C`SUPER\*(C'\fR method is called at the end
of the overridden method.
.Sp
It copies the following attributes from the database into the table meta data
\&\f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_ext\*(C'\fR, \f(CW\*(C`f_encoding\*(C'\fR, \f(CW\*(C`f_lock\*(C'\fR, \f(CW\*(C`f_schema\*(C'\fR
and \f(CW\*(C`f_lockfile\*(C'\fR and makes them sticky to the table.
.Sp
This method should be called before you attempt to map between file
name and table name to ensure the correct directory, extension etc. are
used.
.IP "init_table_meta" 4
.IX Item "init_table_meta"
Initializes more attributes of the table meta data \- usually more
expensive ones (e.g. those which require class instantiations) \- when
the file name and the table name could mapped.
.IP "get_table_meta" 4
.IX Item "get_table_meta"
Returns the table meta data. If there are none for the required
table, a new one is initialized. When it fails, nothing is
returned. On success, the name of the table and the meta data
structure is returned.
.IP "get_table_meta_attr" 4
.IX Item "get_table_meta_attr"
Returns a single attribute from the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "set_table_meta_attr" 4
.IX Item "set_table_meta_attr"
Sets a single attribute in the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "table_meta_attr_changed" 4
.IX Item "table_meta_attr_changed"
Called when an attribute of the meta data is modified.
.Sp
If the modified attribute requires to reset a calculated attribute, the
calculated attribute is reset (deleted from meta data structure) and
the \fIinitialized\fR flag is removed, too. The decision is made based on
\&\f(CW%register_reset_on_modify\fR.
.IP "register_reset_on_modify" 4
.IX Item "register_reset_on_modify"
Allows \f(CW\*(C`set_table_meta_attr\*(C'\fR to reset meta attributes when special
attributes are modified. For DBD::File, modifying one of \f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_ext\*(C'\fR or \f(CW\*(C`f_lockfile\*(C'\fR will reset \f(CW\*(C`f_fqfn\*(C'\fR. \s-1DBD::DBM\s0 extends the
list for \f(CW\*(C`dbm_type\*(C'\fR and \f(CW\*(C`dbm_mldbm\*(C'\fR to reset the value of \f(CW\*(C`dbm_tietype\*(C'\fR.
.Sp
If your \s-1DBD\s0 has calculated values in the meta data area, then call
\&\f(CW\*(C`register_reset_on_modify\*(C'\fR:
.Sp
.Vb 2
\&  my %reset_on_modify = (xxx_foo => "xxx_bar");
\&  _\|_PACKAGE_\|_\->register_reset_on_modify (\e%reset_on_modify);
.Ve
.IP "register_compat_map" 4
.IX Item "register_compat_map"
Allows \f(CW\*(C`get_table_meta_attr\*(C'\fR and \f(CW\*(C`set_table_meta_attr\*(C'\fR to update the
attribute name to the current favored one:
.Sp
.Vb 3
\&  # from DBD::DBM
\&  my %compat_map = (dbm_ext => "f_ext");
\&  _\|_PACKAGE_\|_\->register_compat_map (\e%compat_map);
.Ve
.IP "open_file" 4
.IX Item "open_file"
Called to open the table's data file.
.Sp
Depending on the attributes set in the table's meta data, the
following steps are performed. Unless \f(CW\*(C`f_dontopen\*(C'\fR is set to a
true value, \f(CW\*(C`f_fqfn\*(C'\fR must contain the full qualified file name
for the table to work on (file2table ensures this). The encoding in
\&\f(CW\*(C`f_encoding\*(C'\fR is applied if set and the file is opened. If
\&\f(CW\*(C`<f_fqln \*(C'\fR> (full qualified lock name) is set, this file is opened,
too. Depending on the value in \f(CW\*(C`f_lock\*(C'\fR, the appropriate lock is
set on the opened data file or lock file.
.Sp
After this is done, a derived class might add more steps in an overridden
\&\f(CW\*(C`open_file\*(C'\fR method.
.IP "new" 4
.IX Item "new"
Instantiates the table. This is done in 3 steps:
.Sp
.Vb 3
\& 1. get the table meta data
\& 2. open the data file
\& 3. bless the table data structure using inherited constructor new
.Ve
.Sp
It is not recommended to override the constructor of the table class.
Find a reasonable place to add you extensions in one of the above four
methods.
.IP "drop" 4
.IX Item "drop"
Implements the abstract table method for the \f(CW\*(C`DROP\*(C'\fR
command. Discards table meta data after all files belonging to the
table are closed and unlinked.
.Sp
Overriding this method might be reasonable in very rare cases.
.IP "seek" 4
.IX Item "seek"
Implements the abstract table method used when accessing the table from the
engine. \f(CW\*(C`seek\*(C'\fR is called every time the engine uses dumb algorithms
for iterating over the table content.
.IP "truncate" 4
.IX Item "truncate"
Implements the abstract table method used when dumb table algorithms
for \f(CW\*(C`UPDATE\*(C'\fR or \f(CW\*(C`DELETE\*(C'\fR need to truncate the table storage
after the last written row.
.PP
You should consult the documentation of \f(CW\*(C`SQL::Eval::Table\*(C'\fR (see
SQL::Eval) to get more information about the abstract methods of the
table's base class you have to override and a description of the table
meta information expected by the \s-1SQL\s0 engines.
.SH "AUTHOR"
.IX Header "AUTHOR"
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original author is Jochen Wiedmann.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010\-2013 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::HowTo.3pm                         0100644 0001750 0001750 00000023270 12566241601 024022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::HowTo 3"
.TH DBD::File::HowTo 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::HowTo \- Guide to create DBD::File based driver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&  perldoc DBD::File::HowTo
\&  perldoc DBI
\&  perldoc DBI::DBD
\&  perldoc DBD::File::Developers
\&  perldoc DBI::DBD::SqlEngine::Developers
\&  perldoc DBI::DBD::SqlEngine
\&  perldoc SQL::Eval
\&  perldoc DBI::DBD::SqlEngine::HowTo
\&  perldoc SQL::Statement::Embed
\&  perldoc DBD::File
\&  perldoc DBD::File::HowTo
\&  perldoc DBD::File::Developers
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides a step-by-step guide, how to create a new
\&\f(CW\*(C`DBD::File\*(C'\fR based \s-1DBD.\s0 It expects that you carefully read the \s-1DBI\s0
documentation and that you're familiar with \s-1DBI::DBD\s0 and had read and
understood DBD::ExampleP.
.PP
This document addresses experienced developers who are really sure that
they need to invest time when writing a new \s-1DBI\s0 Driver. Writing a \s-1DBI\s0
Driver is neither a weekend project nor an easy job for hobby coders
after work. Expect one or two man-month of time for the first start.
.PP
Those who are still reading, should be able to sing the rules of
\&\*(L"\s-1CREATING A NEW DRIVER\*(R"\s0 in \s-1DBI::DBD\s0.
.PP
Of course, DBD::File is a DBI::DBD::SqlEngine and you surely read
DBI::DBD::SqlEngine::HowTo before continuing here.
.SH "CREATING DRIVER CLASSES"
.IX Header "CREATING DRIVER CLASSES"
Do you have an entry in \s-1DBI\s0's \s-1DBD\s0 registry? For this guide, a prefix of
\&\f(CW\*(C`foo_\*(C'\fR is assumed.
.SS "Sample Skeleton"
.IX Subsection "Sample Skeleton"
.Vb 1
\&    package DBD::Foo;
\&
\&    use strict;
\&    use warnings;
\&    use vars qw(@ISA $VERSION);
\&    use base qw(DBD::File);
\&
\&    use DBI ();
\&
\&    $VERSION = "0.001";
\&
\&    package DBD::Foo::dr;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::dr);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::db;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::db);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::st;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::st);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::Statement;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Statement);
\&
\&    package DBD::Foo::Table;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Table);
\&
\&    1;
.Ve
.PP
Tiny, eh? And all you have now is a \s-1DBD\s0 named foo which will is able to
deal with temporary tables, as long as you use SQL::Statement. In
DBI::SQL::Nano environments, this \s-1DBD\s0 can do nothing.
.SS "Start over"
.IX Subsection "Start over"
Based on DBI::DBD::SqlEngine::HowTo, we're now having a driver which
could do basic things. Of course, it should now derive from DBD::File
instead of DBI::DBD::SqlEngine, shouldn't it?
.PP
DBD::File extends DBI::DBD::SqlEngine to deal with any kind of files.
In principle, the only extensions required are to the table class:
.PP
.Vb 1
\&    package DBD::Foo::Table;
\&
\&    sub bootstrap_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # initialize all $meta attributes which might be relevant for
\&        # file2table
\&
\&        return $self\->SUPER::bootstrap_table_meta($dbh, $meta, $table);
\&    }
\&
\&    sub init_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # called after $meta contains the results from file2table
\&        # initialize all missing $meta attributes
\&
\&        $self\->SUPER::init_table_meta( $dbh, $meta, $table );
\&    }
.Ve
.PP
In case \f(CW\*(C`DBD::File::Table::open_file\*(C'\fR doesn't open the files as the driver
needs that, override it!
.PP
.Vb 7
\&    sub open_file
\&    {
\&        my ( $self, $meta, $attrs, $flags ) = @_;
\&        # ensure that $meta\->{f_dontopen} is set
\&        $self\->SUPER::open_file( $meta, $attrs, $flags );
\&        # now do what ever needs to be done
\&    }
.Ve
.PP
Combined with the methods implemented using the SQL::Statement::Embed
guide, the table is full working and you could try a start over.
.SS "User comfort"
.IX Subsection "User comfort"
\&\f(CW\*(C`DBD::File\*(C'\fR since \f(CW0.39\fR consolidates all persistent meta data of a table
into a single structure stored in \f(CW\*(C`$dbh\->{f_meta}\*(C'\fR. With \f(CW\*(C`DBD::File\*(C'\fR
version \f(CW0.41\fR and \f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR version \f(CW0.05\fR, this
consolidation moves to DBI::DBD::SqlEngine. It's still the
\&\f(CW\*(C`$dbh\->{$drv_prefix . "_meta"}\*(C'\fR attribute which cares, so what you
learned at this place before, is still valid.
.PP
.Vb 3
\&    sub init_valid_attributes
\&    {
\&        my $dbh = $_[0];
\&
\&        $dbh\->SUPER::init_valid_attributes ();
\&
\&        $dbh\->{foo_valid_attrs} = { ... };
\&        $dbh\->{foo_readonly_attrs} = { ...  };
\&
\&        $dbh\->{foo_meta} = "foo_tables";
\&
\&        return $dbh;
\&    }
.Ve
.PP
See updates at \*(L"User comfort\*(R" in DBI::DBD::SqlEngine::HowTo.
.SS "Testing"
.IX Subsection "Testing"
Now you should have your own DBD::File based driver. Was easy, wasn't it?
But does it work well?  Prove it by writing tests and remember to use
dbd_edit_mm_attribs from \s-1DBI::DBD\s0 to ensure testing even rare cases.
.SH "AUTHOR"
.IX Header "AUTHOR"
This guide is written by Jens Rehsack. DBD::File is written by Jochen
Wiedmann and Jeff Zucker.
.PP
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::HowTo5.16.3pm                     0100644 0001750 0001750 00000032213 12566241577 024345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::HowTo 3"
.TH DBD::File::HowTo 3 "2010-09-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::HowTo \- Guide to create DBD::File based driver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&  perldoc DBD::File::HowTo
\&  perldoc DBI
\&  perldoc DBI::DBD
\&  perldoc DBD::File::Developers
\&  perldoc DBI::DBD::SqlEngine::Developers
\&  perldoc DBI::DBD::SqlEngine
\&  perldoc SQL::Eval
\&  perldoc DBI::DBD::SqlEngine::HowTo
\&  perldoc SQL::Statement::Embed
\&  perldoc DBD::File
\&  perldoc DBD::File::HowTo
\&  perldoc DBD::File::Developers
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides a step-by-step guide, how to create a new
\&\f(CW\*(C`DBD::File\*(C'\fR based \s-1DBD\s0. It expects that you carefully read the \s-1DBI\s0
documentation and that you're familiar with \s-1DBI::DBD\s0 and had read and
understood DBD::ExampleP.
.PP
This document addresses experienced developers who are really sure that
they need to invest time when writing a new \s-1DBI\s0 Driver. Writing a \s-1DBI\s0
Driver is neither a weekend project nor an easy job for hobby coders
after work. Expect one or two man-month of time for the first start.
.PP
Those who are still reading, should be able to sing the rules of
\&\*(L"\s-1CREATING\s0 A \s-1NEW\s0 \s-1DRIVER\s0\*(R" in \s-1DBI::DBD\s0.
.PP
Of course, DBD::File is a DBI::DBD::SqlEngine and you surely read
DBI::DBD::SqlEngine::HowTo before continuing here.
.SH "CREATING DRIVER CLASSES"
.IX Header "CREATING DRIVER CLASSES"
Do you have an entry in \s-1DBI\s0's \s-1DBD\s0 registry? For this guide, a prefix of
\&\f(CW\*(C`foo_\*(C'\fR is assumed.
.SS "Sample Skeleton"
.IX Subsection "Sample Skeleton"
.Vb 1
\&    package DBD::Foo;
\&
\&    use strict;
\&    use warnings;
\&    use vars qw(@ISA $VERSION);
\&    use base qw(DBD::File);
\&
\&    use DBI ();
\&
\&    $VERSION = "0.001";
\&
\&    package DBD::Foo::dr;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::dr);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::db;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::db);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::st;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::st);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::Statement;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Statement);
\&
\&    package DBD::Foo::Table;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Table);
\&
\&    1;
.Ve
.PP
Tiny, eh? And all you have now is a \s-1DBD\s0 named foo which will is able to
deal with temporary tables, as long as you use SQL::Statement. In
DBI::SQL::Nano environments, this \s-1DBD\s0 can do nothing.
.SS "Start over"
.IX Subsection "Start over"
Based on DBI::DBD::SqlEngine::HowTo, we're now having a driver which
could do basic things. Of course, it should now derive from DBD::File
instead of DBI::DBD::SqlEngine, shouldn't it?
.PP
DBD::File extends DBI::DBD::SqlEngine to deal with any kind of files.
In principle, the only extensions required are to the table class:
.PP
.Vb 1
\&    package DBD::Foo::Table;
\&
\&    sub bootstrap_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # initialize all $meta attributes which might be relevant for
\&        # file2table
\&
\&        return $self\->SUPER::bootstrap_table_meta($dbh, $meta, $table);
\&    }
\&
\&    sub init_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # called after $meta contains the results from file2table
\&        # initialize all missing $meta attributes
\&
\&        $self\->SUPER::init_table_meta( $dbh, $meta, $table );
\&    }
.Ve
.PP
In case \f(CW\*(C`DBD::File::Table::open_file\*(C'\fR doesn't open the files as the driver
needs that, override it!
.PP
.Vb 7
\&    sub open_file
\&    {
\&        my ( $self, $meta, $attrs, $flags ) = @_;
\&        # ensure that $meta\->{f_dontopen} is set
\&        $self\->SUPER::open_file( $meta, $attrs, $flags );
\&        # now do what ever needs to be done
\&    }
.Ve
.PP
Combined with the methods implemented using the SQL::Statement::Embed
guide, the table is full working and you could try a start over.
.SS "User comfort"
.IX Subsection "User comfort"
\&\f(CW\*(C`DBD::File\*(C'\fR since \f(CW0.39\fR consolidates all persistent meta data of a table
into a single structure stored in \f(CW\*(C`$dbh\->{f_meta}\*(C'\fR. While DBD::File
provides only readonly access to this structure, modifications are still
allowed.
.PP
Primarily DBD::File provides access via setters \f(CW\*(C`get_file_meta\*(C'\fR,
\&\f(CW\*(C`set_file_meta\*(C'\fR and \f(CW\*(C`clear_file_meta\*(C'\fR. Those methods are easily
accessible by the users via the \f(CW\*(C`$dbh\->func ()\*(C'\fR interface provided
by \s-1DBI\s0. Well, many users don't feel comfortize when calling
.PP
.Vb 2
\&    # don\*(Aqt require extension for tables cars
\&    $dbh\->func ("cars", "f_ext", ".csv", "set_file_meta");
.Ve
.PP
DBD::File will inject a method into your driver to increase the user
comfort to allow:
.PP
.Vb 2
\&    # don\*(Aqt require extension for tables cars
\&    $dbh\->foo_set_meta ("cars", "f_ext", ".csv");
.Ve
.PP
Better, but here and there users likes to do:
.PP
.Vb 2
\&    # don\*(Aqt require extension for tables cars
\&    $dbh\->{foo_tables}\->{cars}\->{f_ext} = ".csv";
.Ve
.PP
This interface is provided when derived \s-1DBD\s0's define following in
\&\f(CW\*(C`init_valid_attributes\*(C'\fR (please compare carefully with the example in
DBI::DBD::SqlEngine::HowTo):
.PP
.Vb 3
\&    sub init_valid_attributes
\&    {
\&        my $dbh = $_[0];
\&
\&        $dbh\->SUPER::init_valid_attributes ();
\&
\&        $dbh\->{foo_valid_attrs} = {
\&            foo_version         => 1,   # contains version of this driver
\&            foo_valid_attrs     => 1,   # contains the valid attributes of foo drivers
\&            foo_readonly_attrs  => 1,   # contains immutable attributes of foo drivers
\&            foo_bar             => 1,   # contains the bar attribute
\&            foo_baz             => 1,   # contains the baz attribute
\&            foo_manager         => 1,   # contains the manager of the driver instance
\&            foo_manager_type    => 1,   # contains the manager class of the driver instance
\&            foo_meta            => 1,   # contains the public interface to modify table meta attributes
\&        };
\&        $dbh\->{foo_readonly_attrs} = {
\&            foo_version         => 1,   # ensure no\-one modifies the driver version
\&            foo_valid_attrs     => 1,   # do not permit to add more valid attributes ...
\&            foo_readonly_attrs  => 1,   # ... or make the immutable mutable
\&            foo_manager         => 1,   # manager is set internally only
\&            foo_meta            => 1,   # ensure public interface to modify table meta attributes are immutable
\&        };
\&
\&        $dbh\->{foo_meta} = "foo_tables";
\&
\&        return $dbh;
\&    }
.Ve
.PP
This provides a tied hash in \f(CW\*(C`$dbh\->{foo_tables}\*(C'\fR and a tied hash for
each table's meta data in \f(CW\*(C`$dbh\->{foo_tables}\->{$table_name}\*(C'\fR.
Modifications on the table meta attributes are done using the table
methods:
.PP
.Vb 2
\&    sub get_table_meta_attr { ... }
\&    sub set_table_meta_attr { ... }
.Ve
.PP
Both methods can adjust the attribute name for compatibility reasons, e.g.
when former versions of the \s-1DBD\s0 allowed different names to be used for the
same flag:
.PP
.Vb 5
\&    my %compat_map = (
\&                       abc => \*(Aqfoo_abc\*(Aq,
\&                       xyz => \*(Aqfoo_xyz\*(Aq,
\&                     );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
.Ve
.PP
If any user modification on a meta attribute needs reinitialization of
the meta structure (in case of \f(CW\*(C`DBD::File\*(C'\fR these are the attributes
\&\f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR, \f(CW\*(C`f_ext\*(C'\fR and \f(CW\*(C`f_lockfile\*(C'\fR), inform DBD::File by
doing
.PP
.Vb 5
\&    my %reset_on_modify = (
\&                            foo_xyz => "foo_bar",
\&                            foo_abc => "foo_bar",
\&                          );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
.Ve
.PP
The next access to the table meta data will force DBD::File to re-do the
entire meta initialization process.
.PP
Any further action which needs to be taken can handled in
\&\f(CW\*(C`table_meta_attr_changed\*(C'\fR:
.PP
.Vb 6
\&    sub table_meta_attr_changed
\&    {
\&        my ($class, $meta, $attrib, $value) = @_;
\&        ...
\&        $class\->SUPER::table_meta_attr_changed ($meta, $attrib, $value);
\&    }
.Ve
.PP
This is done before the new value is set in \f(CW$meta\fR, so the attribute
changed handler can act depending on the old value.
.SS "Testing"
.IX Subsection "Testing"
Now you should have your own DBD::File based driver. Was easy, wasn't it?
But does it work well?  Prove it by writing tests and remember to use
dbd_edit_mm_attribs from \s-1DBI::DBD\s0 to ensure testing even rare cases.
.SH "AUTHOR"
.IX Header "AUTHOR"
This guide is written by Jens Rehsack. DBD::File is written by Jochen
Wiedmann and Jeff Zucker.
.PP
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::HowTo5.18.3pm                     0100644 0001750 0001750 00000023270 12566241601 024336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::HowTo 3"
.TH DBD::File::HowTo 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::HowTo \- Guide to create DBD::File based driver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&  perldoc DBD::File::HowTo
\&  perldoc DBI
\&  perldoc DBI::DBD
\&  perldoc DBD::File::Developers
\&  perldoc DBI::DBD::SqlEngine::Developers
\&  perldoc DBI::DBD::SqlEngine
\&  perldoc SQL::Eval
\&  perldoc DBI::DBD::SqlEngine::HowTo
\&  perldoc SQL::Statement::Embed
\&  perldoc DBD::File
\&  perldoc DBD::File::HowTo
\&  perldoc DBD::File::Developers
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides a step-by-step guide, how to create a new
\&\f(CW\*(C`DBD::File\*(C'\fR based \s-1DBD.\s0 It expects that you carefully read the \s-1DBI\s0
documentation and that you're familiar with \s-1DBI::DBD\s0 and had read and
understood DBD::ExampleP.
.PP
This document addresses experienced developers who are really sure that
they need to invest time when writing a new \s-1DBI\s0 Driver. Writing a \s-1DBI\s0
Driver is neither a weekend project nor an easy job for hobby coders
after work. Expect one or two man-month of time for the first start.
.PP
Those who are still reading, should be able to sing the rules of
\&\*(L"\s-1CREATING A NEW DRIVER\*(R"\s0 in \s-1DBI::DBD\s0.
.PP
Of course, DBD::File is a DBI::DBD::SqlEngine and you surely read
DBI::DBD::SqlEngine::HowTo before continuing here.
.SH "CREATING DRIVER CLASSES"
.IX Header "CREATING DRIVER CLASSES"
Do you have an entry in \s-1DBI\s0's \s-1DBD\s0 registry? For this guide, a prefix of
\&\f(CW\*(C`foo_\*(C'\fR is assumed.
.SS "Sample Skeleton"
.IX Subsection "Sample Skeleton"
.Vb 1
\&    package DBD::Foo;
\&
\&    use strict;
\&    use warnings;
\&    use vars qw(@ISA $VERSION);
\&    use base qw(DBD::File);
\&
\&    use DBI ();
\&
\&    $VERSION = "0.001";
\&
\&    package DBD::Foo::dr;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::dr);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::db;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::db);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::st;
\&
\&    use vars qw(@ISA $imp_data_size);
\&
\&    @ISA = qw(DBD::File::st);
\&    $imp_data_size = 0;
\&
\&    package DBD::Foo::Statement;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Statement);
\&
\&    package DBD::Foo::Table;
\&
\&    use vars qw(@ISA);
\&
\&    @ISA = qw(DBD::File::Table);
\&
\&    1;
.Ve
.PP
Tiny, eh? And all you have now is a \s-1DBD\s0 named foo which will is able to
deal with temporary tables, as long as you use SQL::Statement. In
DBI::SQL::Nano environments, this \s-1DBD\s0 can do nothing.
.SS "Start over"
.IX Subsection "Start over"
Based on DBI::DBD::SqlEngine::HowTo, we're now having a driver which
could do basic things. Of course, it should now derive from DBD::File
instead of DBI::DBD::SqlEngine, shouldn't it?
.PP
DBD::File extends DBI::DBD::SqlEngine to deal with any kind of files.
In principle, the only extensions required are to the table class:
.PP
.Vb 1
\&    package DBD::Foo::Table;
\&
\&    sub bootstrap_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # initialize all $meta attributes which might be relevant for
\&        # file2table
\&
\&        return $self\->SUPER::bootstrap_table_meta($dbh, $meta, $table);
\&    }
\&
\&    sub init_table_meta
\&    {
\&        my ( $self, $dbh, $meta, $table ) = @_;
\&
\&        # called after $meta contains the results from file2table
\&        # initialize all missing $meta attributes
\&
\&        $self\->SUPER::init_table_meta( $dbh, $meta, $table );
\&    }
.Ve
.PP
In case \f(CW\*(C`DBD::File::Table::open_file\*(C'\fR doesn't open the files as the driver
needs that, override it!
.PP
.Vb 7
\&    sub open_file
\&    {
\&        my ( $self, $meta, $attrs, $flags ) = @_;
\&        # ensure that $meta\->{f_dontopen} is set
\&        $self\->SUPER::open_file( $meta, $attrs, $flags );
\&        # now do what ever needs to be done
\&    }
.Ve
.PP
Combined with the methods implemented using the SQL::Statement::Embed
guide, the table is full working and you could try a start over.
.SS "User comfort"
.IX Subsection "User comfort"
\&\f(CW\*(C`DBD::File\*(C'\fR since \f(CW0.39\fR consolidates all persistent meta data of a table
into a single structure stored in \f(CW\*(C`$dbh\->{f_meta}\*(C'\fR. With \f(CW\*(C`DBD::File\*(C'\fR
version \f(CW0.41\fR and \f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR version \f(CW0.05\fR, this
consolidation moves to DBI::DBD::SqlEngine. It's still the
\&\f(CW\*(C`$dbh\->{$drv_prefix . "_meta"}\*(C'\fR attribute which cares, so what you
learned at this place before, is still valid.
.PP
.Vb 3
\&    sub init_valid_attributes
\&    {
\&        my $dbh = $_[0];
\&
\&        $dbh\->SUPER::init_valid_attributes ();
\&
\&        $dbh\->{foo_valid_attrs} = { ... };
\&        $dbh\->{foo_readonly_attrs} = { ...  };
\&
\&        $dbh\->{foo_meta} = "foo_tables";
\&
\&        return $dbh;
\&    }
.Ve
.PP
See updates at \*(L"User comfort\*(R" in DBI::DBD::SqlEngine::HowTo.
.SS "Testing"
.IX Subsection "Testing"
Now you should have your own DBD::File based driver. Was easy, wasn't it?
But does it work well?  Prove it by writing tests and remember to use
dbd_edit_mm_attribs from \s-1DBI::DBD\s0 to ensure testing even rare cases.
.SH "AUTHOR"
.IX Header "AUTHOR"
This guide is written by Jens Rehsack. DBD::File is written by Jochen
Wiedmann and Jeff Zucker.
.PP
The module DBD::File is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Roadmap.3pm                       0100644 0001750 0001750 00000025152 12566241601 024346  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Roadmap 3"
.TH DBD::File::Roadmap 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Roadmap \- Planned Enhancements for DBD::File and pure Perl DBD's
.PP
Jens Rehsack \- May 2010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document gives a high level overview of the future of the DBD::File \s-1DBI\s0
driver and groundwork for pure Perl \s-1DBI\s0 drivers.
.PP
The planned enhancements cover features, testing, performance, reliability,
extensibility and more.
.SH "CHANGES AND ENHANCEMENTS"
.IX Header "CHANGES AND ENHANCEMENTS"
.SS "Features"
.IX Subsection "Features"
There are some features missing we would like to add, but there is
no time plan:
.IP "\s-1LOCK TABLE\s0" 4
.IX Item "LOCK TABLE"
The newly implemented internal common table meta storage area would allow
us to implement \s-1LOCK TABLE\s0 support based on file system \f(CW\*(C`flock ()\*(C'\fR
support.
.IP "Transaction support" 4
.IX Item "Transaction support"
While DBD::AnyData recommends explicitly committing by importing and
exporting tables, DBD::File might be enhanced in a future version to allow
transparent transactions using the temporary tables of SQL::Statement as
shadow (dirty) tables.
.Sp
Transaction support will heavily rely on lock table support.
.IP "Data Dictionary Persistence" 4
.IX Item "Data Dictionary Persistence"
SQL::Statement provides dictionary information when a \*(L"\s-1CREATE TABLE ...\*(R"\s0
statement is executed. This dictionary is preserved for some statement
handle attribute fetches (as \f(CW\*(C`NULLABLE\*(C'\fR or \f(CW\*(C`PRECISION\*(C'\fR).
.Sp
It is planned to extend DBD::File to support data dictionaries to work
on the tables in it. It is not planned to support one table in different
dictionaries, but you can have several dictionaries in one directory.
.IP "\s-1SQL\s0 Engine selecting on connect" 4
.IX Item "SQL Engine selecting on connect"
Currently the \s-1SQL\s0 engine selected is chosen during the loading of the module
DBI::SQL::Nano. Ideally end users should be able to select the engine
used in \f(CW\*(C`DBI\->connect ()\*(C'\fR with a special DBD::File attribute.
.PP
Other points of view to the planned features (and more features for the
SQL::Statement engine) are shown in SQL::Statement::Roadmap.
.SS "Testing"
.IX Subsection "Testing"
DBD::File and the dependent \s-1DBD::DBM\s0 requires a lot more automated tests
covering \s-1API\s0 stability and compatibility with optional modules
like SQL::Statement.
.SS "Performance"
.IX Subsection "Performance"
Several arguments for support of features like indexes on columns
and cursors are made for \s-1DBD::CSV \s0(which is a DBD::File based driver,
too).  Similar arguments could be made for \s-1DBD::DBM,\s0 DBD::AnyData,
\&\s-1DBD::RAM\s0 or \s-1DBD::PO\s0 etc.
.PP
To improve the performance of the underlying \s-1SQL\s0 engines, a clean
re-implementation seems to be required. Currently both engines are
prematurely optimized and therefore it is not trivial to provide
further optimization without the risk of breaking existing features.
.PP
Join the \s-1DBI\s0 developers \s-1IRC\s0 channel at <irc://irc.perl.org/dbi> to
participate or post to the \s-1DBI\s0 Developers Mailing List.
.SS "Reliability"
.IX Subsection "Reliability"
DBD::File currently lacks the following points:
.IP "duplicate table names" 4
.IX Item "duplicate table names"
It is currently possible to access a table quoted with a relative path
(a) and additionally using an absolute path (b). If (a) and (b) are
the same file that is not recognized (except for
flock protection handled by the Operating System) and two independent
tables are handled.
.IP "invalid table names" 4
.IX Item "invalid table names"
The current implementation does not prevent someone choosing a
directory name as a physical file name for the table to open.
.SS "Extensibility"
.IX Subsection "Extensibility"
I (Jens Rehsack) have some (partially for example only) \s-1DBD\s0's in mind:
.IP "DBD::Sys" 4
.IX Item "DBD::Sys"
Derive DBD::Sys from a common code base shared with DBD::File which handles
all the emulation \s-1DBI\s0 needs (as getinfo, \s-1SQL\s0 engine handling, ...)
.IP "DBD::Dir" 4
.IX Item "DBD::Dir"
Provide a DBD::File derived to work with fixed table definitions through the
file system to demonstrate how \s-1DBI /\s0 Pure Perl DBDs could handle databases
with hierarchical structures.
.IP "DBD::Join" 4
.IX Item "DBD::Join"
Provide a \s-1DBI\s0 driver which is able to manage multiple connections to other
Databases (as DBD::Multiplex), but allow them to point to different data
sources and allow joins between the tables of them:
.Sp
.Vb 6
\&  # Example
\&  # Let table \*(Aqlsof\*(Aq being a table in DBD::Sys giving a list of open files using lsof utility
\&  # Let table \*(Aqdir\*(Aq being a atable from DBD::Dir
\&  $sth = $dbh\->prepare( "select * from dir,lsof where path=\*(Aq/documents\*(Aq and dir.entry = lsof.filename" )
\&  $sth\->execute(); # gives all open files in \*(Aq/documents\*(Aq
\&  ...
\&
\&  # Let table \*(Aqfilesys\*(Aq a DBD::Sys table of known file systems on current host
\&  # Let table \*(Aqapplications\*(Aq a table of your Configuration Management Database
\&  #  where current applications (relocatable, with mountpoints for filesystems)
\&  #  are stored
\&  $sth = dbh\->prepare( "select * from applications,filesys where " .
\&                       "application.mountpoint = filesys.mountpoint and ".
\&                       "filesys.mounted is true" );
\&  $sth\->execute(); # gives all currently mounted applications on this host
.Ve
.SH "PRIORITIES"
.IX Header "PRIORITIES"
Our priorities are focused on current issues. Initially many new test
cases for DBD::File and \s-1DBD::DBM\s0 should be added to the \s-1DBI\s0 test
suite. After that some additional documentation on how to use the
DBD::File \s-1API\s0 will be provided.
.PP
Any additional priorities will come later and can be modified by (paying)
users.
.SH "RESOURCES AND CONTRIBUTIONS"
.IX Header "RESOURCES AND CONTRIBUTIONS"
See <http://dbi.perl.org/contributing> for \fIhow you can help\fR.
.PP
If your company has benefited from \s-1DBI,\s0 please consider if
it could make a donation to The Perl Foundation \*(L"\s-1DBI\s0 Development\*(R"
fund at <http://dbi.perl.org/donate> to secure future development.
.PP
Alternatively, if your company would benefit from a specific new
\&\s-1DBI\s0 feature, please consider sponsoring it's development through
the options listed in the section \*(L"Commercial Support from the Author\*(R"
on <http://dbi.perl.org/support/>.
.PP
Using such targeted financing allows you to contribute to \s-1DBI\s0
development and rapidly get something specific and directly valuable
to you in return.
.PP
My company also offers annual support contracts for the \s-1DBI,\s0 which
provide another way to support the \s-1DBI\s0 and get something specific
in return. Contact me for details.
.PP
Thank you.
                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Roadmap5.16.3pm                   0100644 0001750 0001750 00000024656 12566241577 024704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Roadmap 3"
.TH DBD::File::Roadmap 3 "2010-07-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Roadmap \- Planned Enhancements for DBD::File and pure Perl DBD's
.PP
Jens Rehsack \- May 2010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document gives a high level overview of the future of the DBD::File \s-1DBI\s0
driver and groundwork for pure Perl \s-1DBI\s0 drivers.
.PP
The planned enhancements cover features, testing, performance, reliability,
extensibility and more.
.SH "CHANGES AND ENHANCEMENTS"
.IX Header "CHANGES AND ENHANCEMENTS"
.SS "Features"
.IX Subsection "Features"
There are some features missing we would like to add, but there is
no time plan:
.IP "\s-1LOCK\s0 \s-1TABLE\s0" 4
.IX Item "LOCK TABLE"
The newly implemented internal common table meta storage area would allow
us to implement \s-1LOCK\s0 \s-1TABLE\s0 support based on file system \f(CW\*(C`flock ()\*(C'\fR
support.
.IP "Transaction support" 4
.IX Item "Transaction support"
While DBD::AnyData recommends explicitly committing by importing and
exporting tables, DBD::File might be enhanced in a future version to allow
transparent transactions using the temporary tables of SQL::Statement as
shadow (dirty) tables.
.Sp
Transaction support will heavily rely on lock table support.
.IP "Data Dictionary Persistence" 4
.IX Item "Data Dictionary Persistence"
SQL::Statement provides dictionary information when a \*(L"\s-1CREATE\s0 \s-1TABLE\s0 ...\*(R"
statement is executed. This dictionary is preserved for some statement
handle attribute fetches (as \f(CW\*(C`NULLABLE\*(C'\fR or \f(CW\*(C`PRECISION\*(C'\fR).
.Sp
It is planned to extend DBD::File to support data dictionaries to work
on the tables in it. It is not planned to support one table in different
dictionaries, but you can have several dictionaries in one directory.
.IP "\s-1SQL\s0 Engine selecting on connect" 4
.IX Item "SQL Engine selecting on connect"
Currently the \s-1SQL\s0 engine selected is chosen during the loading of the module
DBI::SQL::Nano. Ideally end users should be able to select the engine
used in \f(CW\*(C`DBI\->connect ()\*(C'\fR with a special DBD::File attribute.
.PP
Other points of view to the planned features (and more features for the
SQL::Statement engine) are shown in SQL::Statement::Roadmap.
.SS "Testing"
.IX Subsection "Testing"
DBD::File and the dependent \s-1DBD::DBM\s0 requires a lot more automated tests
covering \s-1API\s0 stability and compatibility with optional modules
like SQL::Statement.
.SS "Performance"
.IX Subsection "Performance"
Several arguments for support of features like indexes on columns
and cursors are made for \s-1DBD::CSV\s0 (which is a DBD::File based driver,
too).  Similar arguments could be made for \s-1DBD::DBM\s0, DBD::AnyData,
\&\s-1DBD::RAM\s0 or \s-1DBD::PO\s0 etc.
.PP
To improve the performance of the underlying \s-1SQL\s0 engines, a clean
reimplementation seems to be required. Currently both engines are
prematurely optimized and therefore it is not trivial to provide
further optimization without the risk of breaking existing features.
.PP
Join the \s-1DBI\s0 developers \s-1IRC\s0 channel at <irc://irc.perl.org/dbi> to
participate or post to the \s-1DBI\s0 Developers Mailing List.
.SS "Reliability"
.IX Subsection "Reliability"
DBD::File currently lacks the following points:
.IP "duplicate table names" 4
.IX Item "duplicate table names"
It is currently possible to access a table quoted with a relative path
(a) and additionally using an absolute path (b). If (a) and (b) are
the same file that is not recognized (except for
flock protection handled by the Operating System) and two independent
tables are handled.
.IP "invalid table names" 4
.IX Item "invalid table names"
The current implementation does not prevent someone choosing a
directory name as a physical file name for the table to open.
.SS "Extensibility"
.IX Subsection "Extensibility"
I (Jens Rehsack) have some (partially for example only) \s-1DBD\s0's in mind:
.IP "DBD::Sys" 4
.IX Item "DBD::Sys"
Derive DBD::Sys from a common code base shared with DBD::File which handles
all the emulation \s-1DBI\s0 needs (as getinfo, \s-1SQL\s0 engine handling, ...)
.IP "DBD::Dir" 4
.IX Item "DBD::Dir"
Provide a DBD::File derived to work with fixed table definitions through the
file system to demonstrate how \s-1DBI\s0 / Pure Perl DBDs could handle databases
with hierarchical structures.
.IP "DBD::Join" 4
.IX Item "DBD::Join"
Provide a \s-1DBI\s0 driver which is able to manage multiple connections to other
Databases (as DBD::Multiplex), but allow them to point to different data
sources and allow joins between the tables of them:
.Sp
.Vb 6
\&  # Example
\&  # Let table \*(Aqlsof\*(Aq being a table in DBD::Sys giving a list of open files using lsof utility
\&  # Let table \*(Aqdir\*(Aq being a atable from DBD::Dir
\&  $sth = $dbh\->prepare( "select * from dir,lsof where path=\*(Aq/documents\*(Aq and dir.entry = lsof.filename" )
\&  $sth\->execute(); # gives all open files in \*(Aq/documents\*(Aq
\&  ...
\&
\&  # Let table \*(Aqfilesys\*(Aq a DBD::Sys table of known file systems on current host
\&  # Let table \*(Aqapplications\*(Aq a table of your Configuration Management Database
\&  #  where current applications (relocatable, with mountpoints for filesystems)
\&  #  are stored
\&  $sth = dbh\->prepare( "select * from applications,filesys where " .
\&                       "application.mountpoint = filesys.mountpoint and ".
\&                       "filesys.mounted is true" );
\&  $sth\->execute(); # gives all currently mounted applications on this host
.Ve
.SH "PRIORITIES"
.IX Header "PRIORITIES"
Our priorities are focussed on current issues. Initially many new test
cases for DBD::File and \s-1DBD::DBM\s0 should be added to the \s-1DBI\s0 test
suite. After that some additional documentation on how to use the
DBD::File \s-1API\s0 will be provided.
.PP
Any additional priorities will come later and can be modified by (paying)
users.
.SH "RESOURCES AND CONTRIBUTIONS"
.IX Header "RESOURCES AND CONTRIBUTIONS"
See <http://dbi.perl.org/contributing> for \fIhow you can help\fR.
.PP
If your company has benefited from \s-1DBI\s0, please consider if
it could make a donation to The Perl Foundation \*(L"\s-1DBI\s0 Development\*(R"
fund at <http://dbi.perl.org/donate> to secure future development.
.PP
Alternatively, if your company would benefit from a specific new
\&\s-1DBI\s0 feature, please consider sponsoring it's development through
the options listed in the section \*(L"Commercial Support from the Author\*(R"
on <http://dbi.perl.org/support/>.
.PP
Using such targeted financing allows you to contribute to \s-1DBI\s0
development and rapidly get something specific and directly valuable
to you in return.
.PP
My company also offers annual support contracts for the \s-1DBI\s0, which
provide another way to support the \s-1DBI\s0 and get something specific
in return. Contact me for details.
.PP
Thank you.
                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::File::Roadmap5.18.3pm                   0100644 0001750 0001750 00000025152 12566241601 024662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::File::Roadmap 3"
.TH DBD::File::Roadmap 3 "2013-04-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::File::Roadmap \- Planned Enhancements for DBD::File and pure Perl DBD's
.PP
Jens Rehsack \- May 2010
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document gives a high level overview of the future of the DBD::File \s-1DBI\s0
driver and groundwork for pure Perl \s-1DBI\s0 drivers.
.PP
The planned enhancements cover features, testing, performance, reliability,
extensibility and more.
.SH "CHANGES AND ENHANCEMENTS"
.IX Header "CHANGES AND ENHANCEMENTS"
.SS "Features"
.IX Subsection "Features"
There are some features missing we would like to add, but there is
no time plan:
.IP "\s-1LOCK TABLE\s0" 4
.IX Item "LOCK TABLE"
The newly implemented internal common table meta storage area would allow
us to implement \s-1LOCK TABLE\s0 support based on file system \f(CW\*(C`flock ()\*(C'\fR
support.
.IP "Transaction support" 4
.IX Item "Transaction support"
While DBD::AnyData recommends explicitly committing by importing and
exporting tables, DBD::File might be enhanced in a future version to allow
transparent transactions using the temporary tables of SQL::Statement as
shadow (dirty) tables.
.Sp
Transaction support will heavily rely on lock table support.
.IP "Data Dictionary Persistence" 4
.IX Item "Data Dictionary Persistence"
SQL::Statement provides dictionary information when a \*(L"\s-1CREATE TABLE ...\*(R"\s0
statement is executed. This dictionary is preserved for some statement
handle attribute fetches (as \f(CW\*(C`NULLABLE\*(C'\fR or \f(CW\*(C`PRECISION\*(C'\fR).
.Sp
It is planned to extend DBD::File to support data dictionaries to work
on the tables in it. It is not planned to support one table in different
dictionaries, but you can have several dictionaries in one directory.
.IP "\s-1SQL\s0 Engine selecting on connect" 4
.IX Item "SQL Engine selecting on connect"
Currently the \s-1SQL\s0 engine selected is chosen during the loading of the module
DBI::SQL::Nano. Ideally end users should be able to select the engine
used in \f(CW\*(C`DBI\->connect ()\*(C'\fR with a special DBD::File attribute.
.PP
Other points of view to the planned features (and more features for the
SQL::Statement engine) are shown in SQL::Statement::Roadmap.
.SS "Testing"
.IX Subsection "Testing"
DBD::File and the dependent \s-1DBD::DBM\s0 requires a lot more automated tests
covering \s-1API\s0 stability and compatibility with optional modules
like SQL::Statement.
.SS "Performance"
.IX Subsection "Performance"
Several arguments for support of features like indexes on columns
and cursors are made for \s-1DBD::CSV \s0(which is a DBD::File based driver,
too).  Similar arguments could be made for \s-1DBD::DBM,\s0 DBD::AnyData,
\&\s-1DBD::RAM\s0 or \s-1DBD::PO\s0 etc.
.PP
To improve the performance of the underlying \s-1SQL\s0 engines, a clean
re-implementation seems to be required. Currently both engines are
prematurely optimized and therefore it is not trivial to provide
further optimization without the risk of breaking existing features.
.PP
Join the \s-1DBI\s0 developers \s-1IRC\s0 channel at <irc://irc.perl.org/dbi> to
participate or post to the \s-1DBI\s0 Developers Mailing List.
.SS "Reliability"
.IX Subsection "Reliability"
DBD::File currently lacks the following points:
.IP "duplicate table names" 4
.IX Item "duplicate table names"
It is currently possible to access a table quoted with a relative path
(a) and additionally using an absolute path (b). If (a) and (b) are
the same file that is not recognized (except for
flock protection handled by the Operating System) and two independent
tables are handled.
.IP "invalid table names" 4
.IX Item "invalid table names"
The current implementation does not prevent someone choosing a
directory name as a physical file name for the table to open.
.SS "Extensibility"
.IX Subsection "Extensibility"
I (Jens Rehsack) have some (partially for example only) \s-1DBD\s0's in mind:
.IP "DBD::Sys" 4
.IX Item "DBD::Sys"
Derive DBD::Sys from a common code base shared with DBD::File which handles
all the emulation \s-1DBI\s0 needs (as getinfo, \s-1SQL\s0 engine handling, ...)
.IP "DBD::Dir" 4
.IX Item "DBD::Dir"
Provide a DBD::File derived to work with fixed table definitions through the
file system to demonstrate how \s-1DBI /\s0 Pure Perl DBDs could handle databases
with hierarchical structures.
.IP "DBD::Join" 4
.IX Item "DBD::Join"
Provide a \s-1DBI\s0 driver which is able to manage multiple connections to other
Databases (as DBD::Multiplex), but allow them to point to different data
sources and allow joins between the tables of them:
.Sp
.Vb 6
\&  # Example
\&  # Let table \*(Aqlsof\*(Aq being a table in DBD::Sys giving a list of open files using lsof utility
\&  # Let table \*(Aqdir\*(Aq being a atable from DBD::Dir
\&  $sth = $dbh\->prepare( "select * from dir,lsof where path=\*(Aq/documents\*(Aq and dir.entry = lsof.filename" )
\&  $sth\->execute(); # gives all open files in \*(Aq/documents\*(Aq
\&  ...
\&
\&  # Let table \*(Aqfilesys\*(Aq a DBD::Sys table of known file systems on current host
\&  # Let table \*(Aqapplications\*(Aq a table of your Configuration Management Database
\&  #  where current applications (relocatable, with mountpoints for filesystems)
\&  #  are stored
\&  $sth = dbh\->prepare( "select * from applications,filesys where " .
\&                       "application.mountpoint = filesys.mountpoint and ".
\&                       "filesys.mounted is true" );
\&  $sth\->execute(); # gives all currently mounted applications on this host
.Ve
.SH "PRIORITIES"
.IX Header "PRIORITIES"
Our priorities are focused on current issues. Initially many new test
cases for DBD::File and \s-1DBD::DBM\s0 should be added to the \s-1DBI\s0 test
suite. After that some additional documentation on how to use the
DBD::File \s-1API\s0 will be provided.
.PP
Any additional priorities will come later and can be modified by (paying)
users.
.SH "RESOURCES AND CONTRIBUTIONS"
.IX Header "RESOURCES AND CONTRIBUTIONS"
See <http://dbi.perl.org/contributing> for \fIhow you can help\fR.
.PP
If your company has benefited from \s-1DBI,\s0 please consider if
it could make a donation to The Perl Foundation \*(L"\s-1DBI\s0 Development\*(R"
fund at <http://dbi.perl.org/donate> to secure future development.
.PP
Alternatively, if your company would benefit from a specific new
\&\s-1DBI\s0 feature, please consider sponsoring it's development through
the options listed in the section \*(L"Commercial Support from the Author\*(R"
on <http://dbi.perl.org/support/>.
.PP
Using such targeted financing allows you to contribute to \s-1DBI\s0
development and rapidly get something specific and directly valuable
to you in return.
.PP
My company also offers annual support contracts for the \s-1DBI,\s0 which
provide another way to support the \s-1DBI\s0 and get something specific
in return. Contact me for details.
.PP
Thank you.
                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::Gofer.3pm                               0100644 0001750 0001750 00000062430 12566241601 023041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::Gofer 3"
.TH DBD::Gofer 3 "2013-11-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::Gofer \- A stateless\-proxy driver for communicating with a remote DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI;
\&
\&  $original_dsn = "dbi:..."; # your original DBI Data Source Name
\&
\&  $dbh = DBI\->connect("dbi:Gofer:transport=$transport;...;dsn=$original_dsn",
\&                      $user, $passwd, \e%attributes);
\&
\&  ... use $dbh as if it was connected to $original_dsn ...
.Ve
.PP
The \f(CW\*(C`transport=$transport\*(C'\fR part specifies the name of the module to use to
transport the requests to the remote \s-1DBI.\s0 If \f(CW$transport\fR doesn't contain any
double colons then it's prefixed with \f(CW\*(C`DBD::Gofer::Transport::\*(C'\fR.
.PP
The \f(CW\*(C`dsn=$original_dsn\*(C'\fR part \fImust be the last element\fR of the \s-1DSN\s0 because
everything after \f(CW\*(C`dsn=\*(C'\fR is assumed to be the \s-1DSN\s0 that the remote \s-1DBI\s0 should
use.
.PP
The \f(CW\*(C`...\*(C'\fR represents attributes that influence the operation of the Gofer
driver or transport. These are described below or in the documentation of the
transport module being used.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBD::Gofer is a \s-1DBI\s0 database driver that forwards requests to another \s-1DBI\s0
driver, usually in a separate process, often on a separate machine. It tries to
be as transparent as possible so it appears that you are using the remote
driver directly.
.PP
DBD::Gofer is very similar to DBD::Proxy. The major difference is that with
DBD::Gofer no state is maintained on the remote end. That means every
request contains all the information needed to create the required state. (So,
for example, every request includes the \s-1DSN\s0 to connect to.) Each request can be
sent to any available server. The server executes the request and returns a
single response that includes all the data.
.PP
This is very similar to the way http works as a stateless protocol for the web.
Each request from your web browser can be handled by a different web server process.
.SS "Use Cases"
.IX Subsection "Use Cases"
This may seem like pointless overhead but there are situations where this is a
very good thing. Let's consider a specific case.
.PP
Imagine using DBD::Gofer with an http transport. Your application calls
\&\fIconnect()\fR, prepare(\*(L"select * from table where foo=?\*(R"), \fIbind_param()\fR, and \fIexecute()\fR.
At this point DBD::Gofer builds a request containing all the information
about the method calls. It then uses the httpd transport to send that request
to an apache web server.
.PP
This 'dbi execute' web server executes the request (using DBI::Gofer::Execute
and related modules) and builds a response that contains all the rows of data,
if the statement returned any, along with all the attributes that describe the
results, such as \f(CW$sth\fR\->{\s-1NAME\s0}. This response is sent back to DBD::Gofer which
unpacks it and presents it to the application as if it had executed the
statement itself.
.SS "Advantages"
.IX Subsection "Advantages"
Okay, but you still don't see the point? Well let's consider what we've gained:
.PP
\fIConnection Pooling and Throttling\fR
.IX Subsection "Connection Pooling and Throttling"
.PP
The 'dbi execute' web server leverages all the functionality of web
infrastructure in terms of load balancing, high-availability, firewalls, access
management, proxying, caching.
.PP
At its most basic level you get a configurable pool of persistent database connections.
.PP
\fISimple Scaling\fR
.IX Subsection "Simple Scaling"
.PP
Got thousands of processes all trying to connect to the database? You can use
DBD::Gofer to connect them to your smaller pool of 'dbi execute' web servers instead.
.PP
\fICaching\fR
.IX Subsection "Caching"
.PP
Client-side caching is as simple as adding "\f(CW\*(C`cache=1\*(C'\fR" to the \s-1DSN.\s0
This feature alone can be worth using DBD::Gofer for.
.PP
\fIFewer Network Round-trips\fR
.IX Subsection "Fewer Network Round-trips"
.PP
DBD::Gofer sends as few requests as possible (dependent on the policy being used).
.PP
\fIThin Clients / Unsupported Platforms\fR
.IX Subsection "Thin Clients / Unsupported Platforms"
.PP
You no longer need drivers for your database on every system.  DBD::Gofer is pure perl.
.SH "CONSTRAINTS"
.IX Header "CONSTRAINTS"
There are some natural constraints imposed by the DBD::Gofer 'stateless' approach.
But not many:
.SS "You can't change database handle attributes after \fIconnect()\fP"
.IX Subsection "You can't change database handle attributes after connect()"
You can't change database handle attributes after you've connected.
Use the \fIconnect()\fR call to specify all the attribute settings you want.
.PP
This is because it's critical that when a request is complete the database
handle is left in the same state it was when first connected.
.PP
An exception is made for attributes with names starting "\f(CW\*(C`private_\*(C'\fR":
They can be set after \fIconnect()\fR but the change is only applied locally.
.SS "You can't change statement handle attributes after \fIprepare()\fP"
.IX Subsection "You can't change statement handle attributes after prepare()"
You can't change statement handle attributes after prepare.
.PP
An exception is made for attributes with names starting "\f(CW\*(C`private_\*(C'\fR":
They can be set after \fIprepare()\fR but the change is only applied locally.
.SS "You can't use transactions"
.IX Subsection "You can't use transactions"
AutoCommit only. Transactions aren't supported.
.PP
(In theory transactions could be supported when using a transport that
maintains a connection, like \f(CW\*(C`stream\*(C'\fR does. If you're interested in this
please get in touch via dbi\-dev@perl.org)
.SS "You can't call driver-private sth methods"
.IX Subsection "You can't call driver-private sth methods"
But that's rarely needed anyway.
.SH "GENERAL CAVEATS"
.IX Header "GENERAL CAVEATS"
A few important things to keep in mind when using DBD::Gofer:
.SS "Temporary tables, locks, and other per-connection persistent state"
.IX Subsection "Temporary tables, locks, and other per-connection persistent state"
You shouldn't expect any per-session state to persist between requests.
This includes locks and temporary tables.
.PP
Because the server-side may execute your requests via a different
database connections, you can't rely on any per-connection persistent state,
such as temporary tables, being available from one request to the next.
.PP
This is an easy trap to fall into. A good way to check for this is to test your
code with a Gofer policy package that sets the \f(CW\*(C`connect_method\*(C'\fR policy to
\&'connect' to force a new connection for each request. The \f(CW\*(C`pedantic\*(C'\fR policy does this.
.SS "Driver-private Database Handle Attributes"
.IX Subsection "Driver-private Database Handle Attributes"
Some driver-private dbh attributes may not be available if the driver has not
implemented the \fIprivate_attribute_info()\fR method (added in \s-1DBI 1.54\s0).
.SS "Driver-private Statement Handle Attributes"
.IX Subsection "Driver-private Statement Handle Attributes"
Driver-private sth attributes can be set in the \fIprepare()\fR call. \s-1TODO\s0
.PP
Some driver-private sth attributes may not be available if the driver has not
implemented the \fIprivate_attribute_info()\fR method (added in \s-1DBI 1.54\s0).
.SS "Multiple Resultsets"
.IX Subsection "Multiple Resultsets"
Multiple resultsets are supported only if the driver supports the \fImore_results()\fR method
(an exception is made for DBD::Sybase).
.SS "Statement activity that also updates dbh attributes"
.IX Subsection "Statement activity that also updates dbh attributes"
Some drivers may update one or more dbh attributes after performing activity on
a child sth.  For example, DBD::mysql provides \f(CW$dbh\fR\->{mysql_insertid} in addition to
\&\f(CW$sth\fR\->{mysql_insertid}. Currently mysql_insertid is supported via a hack but a
more general mechanism is needed for other drivers to use.
.SS "Methods that report an error always return undef"
.IX Subsection "Methods that report an error always return undef"
With DBD::Gofer, a method that sets an error always return an undef or empty list.
That shouldn't be a problem in practice because the \s-1DBI\s0 doesn't define any
methods that return meaningful values while also reporting an error.
.SS "Subclassing only applies to client-side"
.IX Subsection "Subclassing only applies to client-side"
The RootClass and DbTypeSubclass attributes are not passed to the Gofer server.
.SH "CAVEATS FOR SPECIFIC METHODS"
.IX Header "CAVEATS FOR SPECIFIC METHODS"
.SS "last_insert_id"
.IX Subsection "last_insert_id"
To enable use of last_insert_id you need to indicate to DBD::Gofer that you'd
like to use it.  You do that my adding a \f(CW\*(C`go_last_insert_id_args\*(C'\fR attribute to
the \fIdo()\fR or \fIprepare()\fR method calls. For example:
.PP
.Vb 1
\&    $dbh\->do($sql, { go_last_insert_id_args => [...] });
.Ve
.PP
or
.PP
.Vb 1
\&    $sth = $dbh\->prepare($sql, { go_last_insert_id_args => [...] });
.Ve
.PP
The array reference should contains the args that you want passed to the
\&\fIlast_insert_id()\fR method.
.SS "execute_for_fetch"
.IX Subsection "execute_for_fetch"
The array methods \fIbind_param_array()\fR and \fIexecute_array()\fR are supported.
When \fIexecute_array()\fR is called the data is serialized and executed in a single
round-trip to the Gofer server. This makes it very fast, but requires enough
memory to store all the serialized data.
.PP
The \fIexecute_for_fetch()\fR method currently isn't optimised, it uses the \s-1DBI\s0
fallback behaviour of executing each tuple individually.
(It could be implemented as a wrapper for \fIexecute_array()\fR \- patches welcome.)
.SH "TRANSPORTS"
.IX Header "TRANSPORTS"
DBD::Gofer doesn't concern itself with transporting requests and responses to and fro.
For that it uses special Gofer transport modules.
.PP
Gofer transport modules usually come in pairs: one for the 'client' DBD::Gofer
driver to use and one for the remote 'server' end. They have very similar names:
.PP
.Vb 2
\&    DBD::Gofer::Transport::<foo>
\&    DBI::Gofer::Transport::<foo>
.Ve
.PP
Sometimes the transports on the \s-1DBD\s0 and \s-1DBI\s0 sides may have different names. For
example DBD::Gofer::Transport::http is typically used with DBI::Gofer::Transport::mod_perl
(DBD::Gofer::Transport::http and DBI::Gofer::Transport::mod_perl modules are
part of the GoferTransport-http distribution).
.SS "Bundled Transports"
.IX Subsection "Bundled Transports"
Several transport modules are provided with DBD::Gofer:
.PP
\fInull\fR
.IX Subsection "null"
.PP
The null transport is the simplest of them all. It doesn't actually transport the request anywhere.
It just serializes (freezes) the request into a string, then thaws it back into
a data structure before passing it to DBI::Gofer::Execute to execute. The same
freeze and thaw is applied to the results.
.PP
The null transport is the best way to test if your application will work with Gofer.
Just set the \s-1DBI_AUTOPROXY\s0 environment variable to "\f(CW\*(C`dbi:Gofer:transport=null;policy=pedantic\*(C'\fR"
(see \*(L"Using \s-1DBI_AUTOPROXY\*(R"\s0 below) and run your application, or ideally its test suite, as usual.
.PP
It doesn't take any parameters.
.PP
\fIpipeone\fR
.IX Subsection "pipeone"
.PP
The pipeone transport launches a subprocess for each request. It passes in the
request and reads the response.
.PP
The fact that a new subprocess is started for each request ensures that the
server side is truly stateless. While this does make the transport \fIvery\fR slow,
it is useful as a way to test that your application doesn't depend on
per-connection state, such as temporary tables, persisting between requests.
.PP
It's also useful both as a proof of concept and as a base class for the stream
driver.
.PP
\fIstream\fR
.IX Subsection "stream"
.PP
The stream driver also launches a subprocess and writes requests and reads
responses, like the pipeone transport.  In this case, however, the subprocess
is expected to handle more that one request. (Though it will be automatically
restarted if it exits.)
.PP
This is the first transport that is truly useful because it can launch the
subprocess on a remote machine using \f(CW\*(C`ssh\*(C'\fR. This means you can now use DBD::Gofer
to easily access any databases that's accessible from any system you can login to.
You also get all the benefits of ssh, including encryption and optional compression.
.PP
See \*(L"Using \s-1DBI_AUTOPROXY\*(R"\s0 below for an example.
.SS "Other Transports"
.IX Subsection "Other Transports"
Implementing a Gofer transport is \fIvery\fR simple, and more transports are very welcome.
Just take a look at any existing transports that are similar to your needs.
.PP
\fIhttp\fR
.IX Subsection "http"
.PP
See the GoferTransport-http distribution on \s-1CPAN:\s0 http://search.cpan.org/dist/GoferTransport\-http/
.PP
\fIGearman\fR
.IX Subsection "Gearman"
.PP
I know Ask Bjo\*/rn Hansen has implemented a transport for the \f(CW\*(C`gearman\*(C'\fR distributed
job system, though it's not on \s-1CPAN\s0 at the time of writing this.
.SH "CONNECTING"
.IX Header "CONNECTING"
Simply prefix your existing \s-1DSN\s0 with "\f(CW\*(C`dbi:Gofer:transport=$transport;dsn=\*(C'\fR"
where \f(CW$transport\fR is the name of the Gofer transport you want to use (see \*(L"\s-1TRANSPORTS\*(R"\s0).
The \f(CW\*(C`transport\*(C'\fR and \f(CW\*(C`dsn\*(C'\fR attributes must be specified and the \f(CW\*(C`dsn\*(C'\fR attributes must be last.
.PP
Other attributes can be specified in the \s-1DSN\s0 to configure DBD::Gofer and/or the
Gofer transport module being used. The main attributes after \f(CW\*(C`transport\*(C'\fR, are
\&\f(CW\*(C`url\*(C'\fR and \f(CW\*(C`policy\*(C'\fR. These and other attributes are described below.
.SS "Using \s-1DBI_AUTOPROXY\s0"
.IX Subsection "Using DBI_AUTOPROXY"
The simplest way to try out DBD::Gofer is to set the \s-1DBI_AUTOPROXY\s0 environment variable.
In this case you don't include the \f(CW\*(C`dsn=\*(C'\fR part. For example:
.PP
.Vb 1
\&    export DBI_AUTOPROXY="dbi:Gofer:transport=null"
.Ve
.PP
or, for a more useful example, try:
.PP
.Vb 1
\&    export DBI_AUTOPROXY="dbi:Gofer:transport=stream;url=ssh:user@example.com"
.Ve
.SS "Connection Attributes"
.IX Subsection "Connection Attributes"
These attributes can be specified in the \s-1DSN.\s0 They can also be passed in the
\&\e%attr parameter of the \s-1DBI\s0 connect method by adding a "\f(CW\*(C`go_\*(C'\fR" prefix to the name.
.PP
\fItransport\fR
.IX Subsection "transport"
.PP
Specifies the Gofer transport class to use. Required. See \*(L"\s-1TRANSPORTS\*(R"\s0 above.
.PP
If the value does not include \f(CW\*(C`::\*(C'\fR then "\f(CW\*(C`DBD::Gofer::Transport::\*(C'\fR" is prefixed.
.PP
The transport object can be accessed via \f(CW$h\fR\->{go_transport}.
.PP
\fIdsn\fR
.IX Subsection "dsn"
.PP
Specifies the \s-1DSN\s0 for the remote side to connect to. Required, and must be last.
.PP
\fIurl\fR
.IX Subsection "url"
.PP
Used to tell the transport where to connect to. The exact form of the value depends on the transport used.
.PP
\fIpolicy\fR
.IX Subsection "policy"
.PP
Specifies the policy to use. See \*(L"\s-1CONFIGURING BEHAVIOUR POLICY\*(R"\s0.
.PP
If the value does not include \f(CW\*(C`::\*(C'\fR then "\f(CW\*(C`DBD::Gofer::Policy\*(C'\fR" is prefixed.
.PP
The policy object can be accessed via \f(CW$h\fR\->{go_policy}.
.PP
\fItimeout\fR
.IX Subsection "timeout"
.PP
Specifies a timeout, in seconds, to use when waiting for responses from the server side.
.PP
\fIretry_limit\fR
.IX Subsection "retry_limit"
.PP
Specifies the number of times a failed request will be retried. Default is 0.
.PP
\fIretry_hook\fR
.IX Subsection "retry_hook"
.PP
Specifies a code reference to be called to decide if a failed request should be retried.
The code reference is called like this:
.PP
.Vb 2
\&  $transport = $h\->{go_transport};
\&  $retry = $transport\->go_retry_hook\->($request, $response, $transport);
.Ve
.PP
If it returns true then the request will be retried, up to the \f(CW\*(C`retry_limit\*(C'\fR.
If it returns a false but defined value then the request will not be retried.
If it returns undef then the default behaviour will be used, as if \f(CW\*(C`retry_hook\*(C'\fR
had not been specified.
.PP
The default behaviour is to retry requests where \f(CW$request\fR\->is_idempotent is true,
or the error message matches \f(CW\*(C`/induced by DBI_GOFER_RANDOM/\*(C'\fR.
.PP
\fIcache\fR
.IX Subsection "cache"
.PP
Specifies that client-side caching should be performed.  The value is the name
of a cache class to use.
.PP
Any class implementing get($key) and set($key, \f(CW$value\fR) methods can be used.
That includes a great many powerful caching classes on \s-1CPAN,\s0 including the
Cache and Cache::Cache distributions.
.PP
You can use "\f(CW\*(C`cache=1\*(C'\fR\*(L" is a shortcut for \*(R"\f(CW\*(C`cache=DBI::Util::CacheMemory\*(C'\fR".
See DBI::Util::CacheMemory for a description of this simple fast default cache.
.PP
The cache object can be accessed via \f(CW$h\fR\->go_cache. For example:
.PP
.Vb 1
\&    $dbh\->go_cache\->clear; # free up memory being used by the cache
.Ve
.PP
The cache keys are the frozen (serialized) requests, and the values are the
frozen responses.
.PP
The default behaviour is to only use the cache for requests where
\&\f(CW$request\fR\->is_idempotent is true (i.e., the dbh has the ReadOnly attribute set
or the \s-1SQL\s0 statement is obviously a \s-1SELECT\s0 without a \s-1FOR UPDATE\s0 clause.)
.PP
For even more control you can use the \f(CW\*(C`go_cache\*(C'\fR attribute to pass in an
instantiated cache object. Individual methods, including \fIprepare()\fR, can also
specify alternative caches via the \f(CW\*(C`go_cache\*(C'\fR attribute. For example, to
specify no caching for a particular query, you could use
.PP
.Vb 1
\&    $sth = $dbh\->prepare( $sql, { go_cache => 0 } );
.Ve
.PP
This can be used to implement different caching policies for different statements.
.PP
It's interesting to note that DBD::Gofer can be used to add client-side caching
to any (gofer compatible) application, with no code changes and no need for a
gofer server.  Just set the \s-1DBI_AUTOPROXY\s0 environment variable like this:
.PP
.Vb 1
\&    DBI_AUTOPROXY=\*(Aqdbi:Gofer:transport=null;cache=1\*(Aq
.Ve
.SH "CONFIGURING BEHAVIOUR POLICY"
.IX Header "CONFIGURING BEHAVIOUR POLICY"
DBD::Gofer supports a 'policy' mechanism that allows you to fine-tune the number of round-trips to the Gofer server.
The policies are grouped into classes (which may be subclassed) and referenced by the name of the class.
.PP
The DBD::Gofer::Policy::Base class is the base class for all the policy
packages and describes all the available policies.
.PP
Three policy packages are supplied with DBD::Gofer:
.PP
DBD::Gofer::Policy::pedantic is most 'transparent' but slowest because it
makes more  round-trips to the Gofer server.
.PP
DBD::Gofer::Policy::classic is a reasonable compromise \- it's the default policy.
.PP
DBD::Gofer::Policy::rush is fastest, but may require code changes in your applications.
.PP
Generally the default \f(CW\*(C`classic\*(C'\fR policy is fine. When first testing an existing
application with Gofer it is a good idea to start with the \f(CW\*(C`pedantic\*(C'\fR policy
first and then switch to \f(CW\*(C`classic\*(C'\fR or a custom policy, for final testing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tim Bunce, <http://www.tim.bunce.name>
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2007, Tim Bunce, Ireland. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The development of DBD::Gofer and related modules was sponsored by
Shopzilla.com (<http://Shopzilla.com>), where I currently work.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBI::Gofer::Request, DBI::Gofer::Response, DBI::Gofer::Execute.
.PP
DBI::Gofer::Transport::Base, DBD::Gofer::Policy::Base.
.PP
\&\s-1DBI\s0
.SH "Caveats for specific drivers"
.IX Header "Caveats for specific drivers"
This section aims to record issues to be aware of when using Gofer with specific drivers.
It usually only documents issues that are not natural consequences of the limitations
of the Gofer approach \- as documented above.
.SH "TODO"
.IX Header "TODO"
This is just a random brain dump... (There's more in the source of the Changes file, not the pod)
.PP
Document policy mechanism
.PP
Add mechanism for transports to list config params and for Gofer to apply any that match (and warn if any left over?)
.PP
Driver-private sth attributes \- set via \fIprepare()\fR \- change \s-1DBI\s0 spec
.PP
add hooks into transport base class for checking & updating a result set cache
   ie via a standard cache interface such as:
   http://search.cpan.org/~robm/Cache\-FastMmap/FastMmap.pm
   http://search.cpan.org/~bradfitz/Cache\-Memcached/lib/Cache/Memcached.pm
   http://search.cpan.org/~dclinton/Cache\-Cache/
   http://search.cpan.org/~cleishman/Cache/
Also caching instructions could be passed through the httpd transport layer
in such a way that appropriate http cache headers are added to the results
so that web caches (squid etc) could be used to implement the caching.
(\s-1MUST\s0 require the use of \s-1GET\s0 rather than \s-1POST\s0 requests.)
.PP
Rework handling of installed_methods to not piggyback on dbh_attributes?
.PP
Perhaps support transactions for transports where it's possible (ie null and stream)?
Would make stream transport (ie ssh) more useful to more people.
.PP
Make sth_result_attr more like dbh_attributes (using '*' etc)
.PP
Add \f(CW@val\fR = FETCH_many(@names) to \s-1DBI\s0 in C and use in Gofer/Execute?
.PP
Implement _new_sth in C.
                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBD::Gofer5.16.3pm                           0100644 0001750 0001750 00000062133 12566241577 023367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBD::Gofer 3"
.TH DBD::Gofer 3 "2012-06-06" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::Gofer \- A stateless\-proxy driver for communicating with a remote DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI;
\&
\&  $original_dsn = "dbi:..."; # your original DBI Data Source Name
\&
\&  $dbh = DBI\->connect("dbi:Gofer:transport=$transport;...;dsn=$original_dsn",
\&                      $user, $passwd, \e%attributes);
\&
\&  ... use $dbh as if it was connected to $original_dsn ...
.Ve
.PP
The \f(CW\*(C`transport=$transport\*(C'\fR part specifies the name of the module to use to
transport the requests to the remote \s-1DBI\s0. If \f(CW$transport\fR doesn't contain any
double colons then it's prefixed with \f(CW\*(C`DBD::Gofer::Transport::\*(C'\fR.
.PP
The \f(CW\*(C`dsn=$original_dsn\*(C'\fR part \fImust be the last element\fR of the \s-1DSN\s0 because
everything after \f(CW\*(C`dsn=\*(C'\fR is assumed to be the \s-1DSN\s0 that the remote \s-1DBI\s0 should
use.
.PP
The \f(CW\*(C`...\*(C'\fR represents attributes that influence the operation of the Gofer
driver or transport. These are described below or in the documentation of the
transport module being used.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBD::Gofer is a \s-1DBI\s0 database driver that forwards requests to another \s-1DBI\s0
driver, usually in a separate process, often on a separate machine. It tries to
be as transparent as possible so it appears that you are using the remote
driver directly.
.PP
DBD::Gofer is very similar to DBD::Proxy. The major difference is that with
DBD::Gofer no state is maintained on the remote end. That means every
request contains all the information needed to create the required state. (So,
for example, every request includes the \s-1DSN\s0 to connect to.) Each request can be
sent to any available server. The server executes the request and returns a
single response that includes all the data.
.PP
This is very similar to the way http works as a stateless protocol for the web.
Each request from your web browser can be handled by a different web server process.
.SS "Use Cases"
.IX Subsection "Use Cases"
This may seem like pointless overhead but there are situations where this is a
very good thing. Let's consider a specific case.
.PP
Imagine using DBD::Gofer with an http transport. Your application calls
\&\fIconnect()\fR, prepare(\*(L"select * from table where foo=?\*(R"), \fIbind_param()\fR, and \fIexecute()\fR.
At this point DBD::Gofer builds a request containing all the information
about the method calls. It then uses the httpd transport to send that request
to an apache web server.
.PP
This 'dbi execute' web server executes the request (using DBI::Gofer::Execute
and related modules) and builds a response that contains all the rows of data,
if the statement returned any, along with all the attributes that describe the
results, such as \f(CW$sth\fR\->{\s-1NAME\s0}. This response is sent back to DBD::Gofer which
unpacks it and presents it to the application as if it had executed the
statement itself.
.SS "Advantages"
.IX Subsection "Advantages"
Okay, but you still don't see the point? Well let's consider what we've gained:
.PP
\fIConnection Pooling and Throttling\fR
.IX Subsection "Connection Pooling and Throttling"
.PP
The 'dbi execute' web server leverages all the functionality of web
infrastructure in terms of load balancing, high-availability, firewalls, access
management, proxying, caching.
.PP
At its most basic level you get a configurable pool of persistent database connections.
.PP
\fISimple Scaling\fR
.IX Subsection "Simple Scaling"
.PP
Got thousands of processes all trying to connect to the database? You can use
DBD::Gofer to connect them to your smaller pool of 'dbi execute' web servers instead.
.PP
\fICaching\fR
.IX Subsection "Caching"
.PP
Client-side caching is as simple as adding "\f(CW\*(C`cache=1\*(C'\fR" to the \s-1DSN\s0.
This feature alone can be worth using DBD::Gofer for.
.PP
\fIFewer Network Round-trips\fR
.IX Subsection "Fewer Network Round-trips"
.PP
DBD::Gofer sends as few requests as possible (dependent on the policy being used).
.PP
\fIThin Clients / Unsupported Platforms\fR
.IX Subsection "Thin Clients / Unsupported Platforms"
.PP
You no longer need drivers for your database on every system.  DBD::Gofer is pure perl.
.SH "CONSTRAINTS"
.IX Header "CONSTRAINTS"
There are some natural constraints imposed by the DBD::Gofer 'stateless' approach.
But not many:
.SS "You can't change database handle attributes after \fIconnect()\fP"
.IX Subsection "You can't change database handle attributes after connect()"
You can't change database handle attributes after you've connected.
Use the \fIconnect()\fR call to specify all the attribute settings you want.
.PP
This is because it's critical that when a request is complete the database
handle is left in the same state it was when first connected.
.PP
An exception is made for attributes with names starting "\f(CW\*(C`private_\*(C'\fR":
They can be set after \fIconnect()\fR but the change is only applied locally.
.SS "You can't change statement handle attributes after \fIprepare()\fP"
.IX Subsection "You can't change statement handle attributes after prepare()"
You can't change statement handle attributes after prepare.
.PP
An exception is made for attributes with names starting "\f(CW\*(C`private_\*(C'\fR":
They can be set after \fIprepare()\fR but the change is only applied locally.
.SS "You can't use transactions"
.IX Subsection "You can't use transactions"
AutoCommit only. Transactions aren't supported.
.PP
(In theory transactions could be supported when using a transport that
maintains a connection, like \f(CW\*(C`stream\*(C'\fR does. If you're interested in this
please get in touch via dbi\-dev@perl.org)
.SS "You can't call driver-private sth methods"
.IX Subsection "You can't call driver-private sth methods"
But that's rarely needed anyway.
.SH "GENERAL CAVEATS"
.IX Header "GENERAL CAVEATS"
A few important things to keep in mind when using DBD::Gofer:
.SS "Temporary tables, locks, and other per-connection persistent state"
.IX Subsection "Temporary tables, locks, and other per-connection persistent state"
You shouldn't expect any per-session state to persist between requests.
This includes locks and temporary tables.
.PP
Because the server-side may execute your requests via a different
database connections, you can't rely on any per-connection persistent state,
such as temporary tables, being available from one request to the next.
.PP
This is an easy trap to fall into. A good way to check for this is to test your
code with a Gofer policy package that sets the \f(CW\*(C`connect_method\*(C'\fR policy to
\&'connect' to force a new connection for each request. The \f(CW\*(C`pedantic\*(C'\fR policy does this.
.SS "Driver-private Database Handle Attributes"
.IX Subsection "Driver-private Database Handle Attributes"
Some driver-private dbh attributes may not be available if the driver has not
implemented the \fIprivate_attribute_info()\fR met