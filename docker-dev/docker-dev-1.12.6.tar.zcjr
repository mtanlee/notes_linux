#ifndef _NPY_COMMON_H_
#define _NPY_COMMON_H_

/* numpconfig.h is auto-generated */
#include "numpyconfig.h"
#ifdef HAVE_NPY_CONFIG_H
#include <npy_config.h>
#endif

/*
 * gcc does not unroll even with -O3
 * use with care, unrolling on modern cpus rarely speeds things up
 */
#ifdef HAVE_ATTRIBUTE_OPTIMIZE_UNROLL_LOOPS
#define NPY_GCC_UNROLL_LOOPS \
    __attribute__((optimize("unroll-loops")))
#else
#define NPY_GCC_UNROLL_LOOPS
#endif

#if defined HAVE_XMMINTRIN_H && defined HAVE__MM_LOAD_PS
#define NPY_HAVE_SSE_INTRINSICS
#endif

#if defined HAVE_EMMINTRIN_H && defined HAVE__MM_LOAD_PD
#define NPY_HAVE_SSE2_INTRINSICS
#endif

/*
 * give a hint to the compiler which branch is more likely or unlikely
 * to occur, e.g. rare error cases:
 *
 * if (NPY_UNLIKELY(failure == 0))
 *    return NULL;
 *
 * the double !! is to cast the expression (e.g. NULL) to a boolean required by
 * the intrinsic
 */
#ifdef HAVE___BUILTIN_EXPECT
#define NPY_LIKELY(x) __builtin_expect(!!(x), 1)
#define NPY_UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define NPY_LIKELY(x) (x)
#define NPY_UNLIKELY(x) (x)
#endif

#if defined(_MSC_VER)
        #define NPY_INLINE __inline
#elif defined(__GNUC__)
	#if defined(__STRICT_ANSI__)
		#define NPY_INLINE __inline__
	#else
		#define NPY_INLINE inline
	#endif
#else
        #define NPY_INLINE
#endif

/* Enable 64 bit file position support on win-amd64. Ticket #1660 */
#if defined(_MSC_VER) && defined(_WIN64) && (_MSC_VER > 1400)
    #define npy_fseek _fseeki64
    #define npy_ftell _ftelli64
#else
    #define npy_fseek fseek
    #define npy_ftell ftell
#endif

/* enums for detected endianness */
enum {
        NPY_CPU_UNKNOWN_ENDIAN,
        NPY_CPU_LITTLE,
        NPY_CPU_BIG
};

/*
 * This is to typedef npy_intp to the appropriate pointer size for this
 * platform.  Py_intptr_t, Py_uintptr_t are defined in pyport.h.
 */
typedef Py_intptr_t npy_intp;
typedef Py_uintptr_t npy_uintp;

/*
 * Define sizes that were not defined in numpyconfig.h.
 */
#define NPY_SIZEOF_CHAR 1
#define NPY_SIZEOF_BYTE 1
#define NPY_SIZEOF_DATETIME 8
#define NPY_SIZEOF_TIMEDELTA 8
#define NPY_SIZEOF_INTP NPY_SIZEOF_PY_INTPTR_T
#define NPY_SIZEOF_UINTP NPY_SIZEOF_PY_INTPTR_T
#define NPY_SIZEOF_HALF 2
#define NPY_SIZEOF_CFLOAT NPY_SIZEOF_COMPLEX_FLOAT
#define NPY_SIZEOF_CDOUBLE NPY_SIZEOF_COMPLEX_DOUBLE
#define NPY_SIZEOF_CLONGDOUBLE NPY_SIZEOF_COMPLEX_LONGDOUBLE

#ifdef constchar
#undef constchar
#endif

#define NPY_SSIZE_T_PYFMT "n"
#define constchar char

/* NPY_INTP_FMT Note:
 *      Unlike the other NPY_*_FMT macros which are used with
 *      PyOS_snprintf, NPY_INTP_FMT is used with PyErr_Format and
 *      PyString_Format. These functions use different formatting
 *      codes which are portably specified according to the Python
 *      documentation. See ticket #1795.
 *
 *      On Windows x64, the LONGLONG formatter should be used, but
 *      in Python 2.6 the %lld formatter is not supported. In this
 *      case we work around the problem by using the %zd formatter.
 */
#if NPY_SIZEOF_PY_INTPTR_T == NPY_SIZEOF_INT
        #define NPY_INTP NPY_INT
        #define NPY_UINTP NPY_UINT
        #define PyIntpArrType_Type PyIntArrType_Type
        #define PyUIntpArrType_Type PyUIntArrType_Type
        #define NPY_MAX_INTP NPY_MAX_INT
        #define NPY_MIN_INTP NPY_MIN_INT
        #define NPY_MAX_UINTP NPY_MAX_UINT
        #define NPY_INTP_FMT "d"
#elif NPY_SIZEOF_PY_INTPTR_T == NPY_SIZEOF_LONG
        #define NPY_INTP NPY_LONG
        #define NPY_UINTP NPY_ULONG
        #define PyIntpArrType_Type PyLongArrType_Type
        #define PyUIntpArrType_Type PyULongArrType_Type
        #define NPY_MAX_INTP NPY_MAX_LONG
        #define NPY_MIN_INTP NPY_MIN_LONG
        #define NPY_MAX_UINTP NPY_MAX_ULONG
        #define NPY_INTP_FMT "ld"
#elif defined(PY_LONG_LONG) && (NPY_SIZEOF_PY_INTPTR_T == NPY_SIZEOF_LONGLONG)
        #define NPY_INTP NPY_LONGLONG
        #define NPY_UINTP NPY_ULONGLONG
        #define PyIntpArrType_Type PyLongLongArrType_Type
        #define PyUIntpArrType_Type PyULongLongArrType_Type
        #define NPY_MAX_INTP NPY_MAX_LONGLONG
        #define NPY_MIN_INTP NPY_MIN_LONGLONG
        #define NPY_MAX_UINTP NPY_MAX_ULONGLONG
    #if (PY_VERSION_HEX >= 0x02070000)
        #define NPY_INTP_FMT "lld"
    #else
        #define NPY_INTP_FMT "zd"
    #endif
#endif

/*
 * We can only use C99 formats for npy_int_p if it is the same as
 * intp_t, hence the condition on HAVE_UNITPTR_T
 */
#if (NPY_USE_C99_FORMATS) == 1 \
        && (defined HAVE_UINTPTR_T) \
        && (defined HAVE_INTTYPES_H)
        #include <inttypes.h>
        #undef NPY_INTP_FMT
        #define NPY_INTP_FMT PRIdPTR
#endif


/*
 * Some platforms don't define bool, long long, or long double.
 * Handle that here.
 */
#define NPY_BYTE_FMT "hhd"
#define NPY_UBYTE_FMT "hhu"
#define NPY_SHORT_FMT "hd"
#define NPY_USHORT_FMT "hu"
#define NPY_INT_FMT "d"
#define NPY_UINT_FMT "u"
#define NPY_LONG_FMT "ld"
#define NPY_ULONG_FMT "lu"
#define NPY_HALF_FMT "g"
#define NPY_FLOAT_FMT "g"
#define NPY_DOUBLE_FMT "g"


#ifdef PY_LONG_LONG
typedef PY_LONG_LONG npy_longlong;
typedef unsigned PY_LONG_LONG npy_ulonglong;
#  ifdef _MSC_VER
#    define NPY_LONGLONG_FMT         "I64d"
#    define NPY_ULONGLONG_FMT        "I64u"
#  elif defined(__APPLE__) || defined(__FreeBSD__)
/*   "%Ld" only parses 4 bytes -- "L" is floating modifier on MacOS X/BSD */
#    define NPY_LONGLONG_FMT         "lld"
#    define NPY_ULONGLONG_FMT        "llu"
/*
     another possible variant -- *quad_t works on *BSD, but is deprecated:
     #define LONGLONG_FMT   "qd"
     #define ULONGLONG_FMT   "qu"
*/
#  else
#    define NPY_LONGLONG_FMT         "Ld"
#    define NPY_ULONGLONG_FMT        "Lu"
#  endif
#  ifdef _MSC_VER
#    define NPY_LONGLONG_SUFFIX(x)   (x##i64)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##Ui64)
#  else
#    define NPY_LONGLONG_SUFFIX(x)   (x##LL)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##ULL)
#  endif
#else
typedef long npy_longlong;
typedef unsigned long npy_ulonglong;
#  define NPY_LONGLONG_SUFFIX(x)  (x##L)
#  define NPY_ULONGLONG_SUFFIX(x) (x##UL)
#endif


typedef unsigned char npy_bool;
#define NPY_FALSE 0
#define NPY_TRUE 1


#if NPY_SIZEOF_LONGDOUBLE == NPY_SIZEOF_DOUBLE
        typedef double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "g"
#else
        typedef long double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "Lg"
#endif

#ifndef Py_USING_UNICODE
#error Must use Python with unicode enabled.
#endif


typedef signed char npy_byte;
typedef unsigned char npy_ubyte;
typedef unsigned short npy_ushort;
typedef unsigned int npy_uint;
typedef unsigned long npy_ulong;

/* These are for completeness */
typedef char npy_char;
typedef short npy_short;
typedef int npy_int;
typedef long npy_long;
typedef float npy_float;
typedef double npy_double;

/*
 * Disabling C99 complex usage: a lot of C code in numpy/scipy rely on being
 * able to do .real/.imag. Will have to convert code first.
 */
#if 0
#if defined(NPY_USE_C99_COMPLEX) && defined(NPY_HAVE_COMPLEX_DOUBLE)
typedef complex npy_cdouble;
#else
typedef struct { double real, imag; } npy_cdouble;
#endif

#if defined(NPY_USE_C99_COMPLEX) && defined(NPY_HAVE_COMPLEX_FLOAT)
typedef complex float npy_cfloat;
#else
typedef struct { float real, imag; } npy_cfloat;
#endif

#if defined(NPY_USE_C99_COMPLEX) && defined(NPY_HAVE_COMPLEX_LONG_DOUBLE)
typedef complex long double npy_clongdouble;
#else
typedef struct {npy_longdouble real, imag;} npy_clongdouble;
#endif
#endif
#if NPY_SIZEOF_COMPLEX_DOUBLE != 2 * NPY_SIZEOF_DOUBLE
#error npy_cdouble definition is not compatible with C99 complex definition ! \
        Please contact Numpy maintainers and give detailed information about your \
        compiler and platform
#endif
typedef struct { double real, imag; } npy_cdouble;

#if NPY_SIZEOF_COMPLEX_FLOAT != 2 * NPY_SIZEOF_FLOAT
#error npy_cfloat definition is not compatible with C99 complex definition ! \
        Please contact Numpy maintainers and give detailed information about your \
        compiler and platform
#endif
typedef struct { float real, imag; } npy_cfloat;

#if NPY_SIZEOF_COMPLEX_LONGDOUBLE != 2 * NPY_SIZEOF_LONGDOUBLE
#error npy_clongdouble definition is not compatible with C99 complex definition ! \
        Please contact Numpy maintainers and give detailed information about your \
        compiler and platform
#endif
typedef struct { npy_longdouble real, imag; } npy_clongdouble;

/*
 * numarray-style bit-width typedefs
 */
#define NPY_MAX_INT8 127
#define NPY_MIN_INT8 -128
#define NPY_MAX_UINT8 255
#define NPY_MAX_INT16 32767
#define NPY_MIN_INT16 -32768
#define NPY_MAX_UINT16 65535
#define NPY_MAX_INT32 2147483647
#define NPY_MIN_INT32 (-NPY_MAX_INT32 - 1)
#define NPY_MAX_UINT32 4294967295U
#define NPY_MAX_INT64 NPY_LONGLONG_SUFFIX(9223372036854775807)
#define NPY_MIN_INT64 (-NPY_MAX_INT64 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT64 NPY_ULONGLONG_SUFFIX(18446744073709551615)
#define NPY_MAX_INT128 NPY_LONGLONG_SUFFIX(85070591730234615865843651857942052864)
#define NPY_MIN_INT128 (-NPY_MAX_INT128 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT128 NPY_ULONGLONG_SUFFIX(170141183460469231731687303715884105728)
#define NPY_MAX_INT256 NPY_LONGLONG_SUFFIX(57896044618658097711785492504343953926634992332820282019728792003956564819967)
#define NPY_MIN_INT256 (-NPY_MAX_INT256 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT256 NPY_ULONGLONG_SUFFIX(115792089237316195423570985008687907853269984665640564039457584007913129639935)
#define NPY_MIN_DATETIME NPY_MIN_INT64
#define NPY_MAX_DATETIME NPY_MAX_INT64
#define NPY_MIN_TIMEDELTA NPY_MIN_INT64
#define NPY_MAX_TIMEDELTA NPY_MAX_INT64

        /* Need to find the number of bits for each type and
           make definitions accordingly.

           C states that sizeof(char) == 1 by definition

           So, just using the sizeof keyword won't help.

           It also looks like Python itself uses sizeof(char) quite a
           bit, which by definition should be 1 all the time.

           Idea: Make Use of CHAR_BIT which should tell us how many
           BITS per CHARACTER
        */

        /* Include platform definitions -- These are in the C89/90 standard */
#include <limits.h>
#define NPY_MAX_BYTE SCHAR_MAX
#define NPY_MIN_BYTE SCHAR_MIN
#define NPY_MAX_UBYTE UCHAR_MAX
#define NPY_MAX_SHORT SHRT_MAX
#define NPY_MIN_SHORT SHRT_MIN
#define NPY_MAX_USHORT USHRT_MAX
#define NPY_MAX_INT   INT_MAX
#ifndef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#endif
#define NPY_MIN_INT   INT_MIN
#define NPY_MAX_UINT  UINT_MAX
#define NPY_MAX_LONG  LONG_MAX
#define NPY_MIN_LONG  LONG_MIN
#define NPY_MAX_ULONG  ULONG_MAX

#define NPY_BITSOF_BOOL (sizeof(npy_bool) * CHAR_BIT)
#define NPY_BITSOF_CHAR CHAR_BIT
#define NPY_BITSOF_BYTE (NPY_SIZEOF_BYTE * CHAR_BIT)
#define NPY_BITSOF_SHORT (NPY_SIZEOF_SHORT * CHAR_BIT)
#define NPY_BITSOF_INT (NPY_SIZEOF_INT * CHAR_BIT)
#define NPY_BITSOF_LONG (NPY_SIZEOF_LONG * CHAR_BIT)
#define NPY_BITSOF_LONGLONG (NPY_SIZEOF_LONGLONG * CHAR_BIT)
#define NPY_BITSOF_INTP (NPY_SIZEOF_INTP * CHAR_BIT)
#define NPY_BITSOF_HALF (NPY_SIZEOF_HALF * CHAR_BIT)
#define NPY_BITSOF_FLOAT (NPY_SIZEOF_FLOAT * CHAR_BIT)
#define NPY_BITSOF_DOUBLE (NPY_SIZEOF_DOUBLE * CHAR_BIT)
#define NPY_BITSOF_LONGDOUBLE (NPY_SIZEOF_LONGDOUBLE * CHAR_BIT)
#define NPY_BITSOF_CFLOAT (NPY_SIZEOF_CFLOAT * CHAR_BIT)
#define NPY_BITSOF_CDOUBLE (NPY_SIZEOF_CDOUBLE * CHAR_BIT)
#define NPY_BITSOF_CLONGDOUBLE (NPY_SIZEOF_CLONGDOUBLE * CHAR_BIT)
#define NPY_BITSOF_DATETIME (NPY_SIZEOF_DATETIME * CHAR_BIT)
#define NPY_BITSOF_TIMEDELTA (NPY_SIZEOF_TIMEDELTA * CHAR_BIT)

#if NPY_BITSOF_LONG == 8
#define NPY_INT8 NPY_LONG
#define NPY_UINT8 NPY_ULONG
        typedef long npy_int8;
        typedef unsigned long npy_uint8;
#define PyInt8ScalarObject PyLongScalarObject
#define PyInt8ArrType_Type PyLongArrType_Type
#define PyUInt8ScalarObject PyULongScalarObject
#define PyUInt8ArrType_Type PyULongArrType_Type
#define NPY_INT8_FMT NPY_LONG_FMT
#define NPY_UINT8_FMT NPY_ULONG_FMT
#elif NPY_BITSOF_LONG == 16
#define NPY_INT16 NPY_LONG
#define NPY_UINT16 NPY_ULONG
        typedef long npy_int16;
        typedef unsigned long npy_uint16;
#define PyInt16ScalarObject PyLongScalarObject
#define PyInt16ArrType_Type PyLongArrType_Type
#define PyUInt16ScalarObject PyULongScalarObject
#define PyUInt16ArrType_Type PyULongArrType_Type
#define NPY_INT16_FMT NPY_LONG_FMT
#define NPY_UINT16_FMT NPY_ULONG_FMT
#elif NPY_BITSOF_LONG == 32
#define NPY_INT32 NPY_LONG
#define NPY_UINT32 NPY_ULONG
        typedef long npy_int32;
        typedef unsigned long npy_uint32;
        typedef unsigned long npy_ucs4;
#define PyInt32ScalarObject PyLongScalarObject
#define PyInt32ArrType_Type PyLongArrType_Type
#define PyUInt32ScalarObject PyULongScalarObject
#define PyUInt32ArrType_Type PyULongArrType_Type
#define NPY_INT32_FMT NPY_LONG_FMT
#define NPY_UINT32_FMT NPY_ULONG_FMT
#elif NPY_BITSOF_LONG == 64
#define NPY_INT64 NPY_LONG
#define NPY_UINT64 NPY_ULONG
        typedef long npy_int64;
        typedef unsigned long npy_uint64;
#define PyInt64ScalarObject PyLongScalarObject
#define PyInt64ArrType_Type PyLongArrType_Type
#define PyUInt64ScalarObject PyULongScalarObject
#define PyUInt64ArrType_Type PyULongArrType_Type
#define NPY_INT64_FMT NPY_LONG_FMT
#define NPY_UINT64_FMT NPY_ULONG_FMT
#define MyPyLong_FromInt64 PyLong_FromLong
#define MyPyLong_AsInt64 PyLong_AsLong
#elif NPY_BITSOF_LONG == 128
#define NPY_INT128 NPY_LONG
#define NPY_UINT128 NPY_ULONG
        typedef long npy_int128;
        typedef unsigned long npy_uint128;
#define PyInt128ScalarObject PyLongScalarObject
#define PyInt128ArrType_Type PyLongArrType_Type
#define PyUInt128ScalarObject PyULongScalarObject
#define PyUInt128ArrType_Type PyULongArrType_Type
#define NPY_INT128_FMT NPY_LONG_FMT
#define NPY_UINT128_FMT NPY_ULONG_FMT
#endif

#if NPY_BITSOF_LONGLONG == 8
#  ifndef NPY_INT8
#    define NPY_INT8 NPY_LONGLONG
#    define NPY_UINT8 NPY_ULONGLONG
        typedef npy_longlong npy_int8;
        typedef npy_ulonglong npy_uint8;
#    define PyInt8ScalarObject PyLongLongScalarObject
#    define PyInt8ArrType_Type PyLongLongArrType_Type
#    define PyUInt8ScalarObject PyULongLongScalarObject
#    define PyUInt8ArrType_Type PyULongLongArrType_Type
#define NPY_INT8_FMT NPY_LONGLONG_FMT
#define NPY_UINT8_FMT NPY_ULONGLONG_FMT
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT8
#  define NPY_MIN_LONGLONG NPY_MIN_INT8
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT8
#elif NPY_BITSOF_LONGLONG == 16
#  ifndef NPY_INT16
#    define NPY_INT16 NPY_LONGLONG
#    define NPY_UINT16 NPY_ULONGLONG
        typedef npy_longlong npy_int16;
        typedef npy_ulonglong npy_uint16;
#    define PyInt16ScalarObject PyLongLongScalarObject
#    define PyInt16ArrType_Type PyLongLongArrType_Type
#    define PyUInt16ScalarObject PyULongLongScalarObject
#    define PyUInt16ArrType_Type PyULongLongArrType_Type
#define NPY_INT16_FMT NPY_LONGLONG_FMT
#define NPY_UINT16_FMT NPY_ULONGLONG_FMT
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT16
#  define NPY_MIN_LONGLONG NPY_MIN_INT16
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT16
#elif NPY_BITSOF_LONGLONG == 32
#  ifndef NPY_INT32
#    define NPY_INT32 NPY_LONGLONG
#    define NPY_UINT32 NPY_ULONGLONG
        typedef npy_longlong npy_int32;
        typedef npy_ulonglong npy_uint32;
        typedef npy_ulonglong npy_ucs4;
#    define PyInt32ScalarObject PyLongLongScalarObject
#    define PyInt32ArrType_Type PyLongLongArrType_Type
#    define PyUInt32ScalarObject PyULongLongScalarObject
#    define PyUInt32ArrType_Type PyULongLongArrType_Type
#define NPY_INT32_FMT NPY_LONGLONG_FMT
#define NPY_UINT32_FMT NPY_ULONGLONG_FMT
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT32
#  define NPY_MIN_LONGLONG NPY_MIN_INT32
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT32
#elif NPY_BITSOF_LONGLONG == 64
#  ifndef NPY_INT64
#    define NPY_INT64 NPY_LONGLONG
#    define NPY_UINT64 NPY_ULONGLONG
        typedef npy_longlong npy_int64;
        typedef npy_ulonglong npy_uint64;
#    define PyInt64ScalarObject PyLongLongScalarObject
#    define PyInt64ArrType_Type PyLongLongArrType_Type
#    define PyUInt64ScalarObject PyULongLongScalarObject
#    define PyUInt64ArrType_Type PyULongLongArrType_Type
#define NPY_INT64_FMT NPY_LONGLONG_FMT
#define NPY_UINT64_FMT NPY_ULONGLONG_FMT
#    define MyPyLong_FromInt64 PyLong_FromLongLong
#    define MyPyLong_AsInt64 PyLong_AsLongLong
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT64
#  define NPY_MIN_LONGLONG NPY_MIN_INT64
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT64
#elif NPY_BITSOF_LONGLONG == 128
#  ifndef NPY_INT128
#    define NPY_INT128 NPY_LONGLONG
#    define NPY_UINT128 NPY_ULONGLONG
        typedef npy_longlong npy_int128;
        typedef npy_ulonglong npy_uint128;
#    define PyInt128ScalarObject PyLongLongScalarObject
#    define PyInt128ArrType_Type PyLongLongArrType_Type
#    define PyUInt128ScalarObject PyULongLongScalarObject
#    define PyUInt128ArrType_Type PyULongLongArrType_Type
#define NPY_INT128_FMT NPY_LONGLONG_FMT
#define NPY_UINT128_FMT NPY_ULONGLONG_FMT
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT128
#  define NPY_MIN_LONGLONG NPY_MIN_INT128
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT128
#elif NPY_BITSOF_LONGLONG == 256
#  define NPY_INT256 NPY_LONGLONG
#  define NPY_UINT256 NPY_ULONGLONG
        typedef npy_longlong npy_int256;
        typedef npy_ulonglong npy_uint256;
#  define PyInt256ScalarObject PyLongLongScalarObject
#  define PyInt256ArrType_Type PyLongLongArrType_Type
#  define PyUInt256ScalarObject PyULongLongScalarObject
#  define PyUInt256ArrType_Type PyULongLongArrType_Type
#define NPY_INT256_FMT NPY_LONGLONG_FMT
#define NPY_UINT256_FMT NPY_ULONGLONG_FMT
#  define NPY_MAX_LONGLONG NPY_MAX_INT256
#  define NPY_MIN_LONGLONG NPY_MIN_INT256
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT256
#endif

#if NPY_BITSOF_INT == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_INT
#define NPY_UINT8 NPY_UINT
        typedef int npy_int8;
        typedef unsigned int npy_uint8;
#    define PyInt8ScalarObject PyIntScalarObject
#    define PyInt8ArrType_Type PyIntArrType_Type
#    define PyUInt8ScalarObject PyUIntScalarObject
#    define PyUInt8ArrType_Type PyUIntArrType_Type
#define NPY_INT8_FMT NPY_INT_FMT
#define NPY_UINT8_FMT NPY_UINT_FMT
#endif
#elif NPY_BITSOF_INT == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_INT
#define NPY_UINT16 NPY_UINT
        typedef int npy_int16;
        typedef unsigned int npy_uint16;
#    define PyInt16ScalarObject PyIntScalarObject
#    define PyInt16ArrType_Type PyIntArrType_Type
#    define PyUInt16ScalarObject PyIntUScalarObject
#    define PyUInt16ArrType_Type PyIntUArrType_Type
#define NPY_INT16_FMT NPY_INT_FMT
#define NPY_UINT16_FMT NPY_UINT_FMT
#endif
#elif NPY_BITSOF_INT == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_INT
#define NPY_UINT32 NPY_UINT
        typedef int npy_int32;
        typedef unsigned int npy_uint32;
        typedef unsigned int npy_ucs4;
#    define PyInt32ScalarObject PyIntScalarObject
#    define PyInt32ArrType_Type PyIntArrType_Type
#    define PyUInt32ScalarObject PyUIntScalarObject
#    define PyUInt32ArrType_Type PyUIntArrType_Type
#define NPY_INT32_FMT NPY_INT_FMT
#define NPY_UINT32_FMT NPY_UINT_FMT
#endif
#elif NPY_BITSOF_INT == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_INT
#define NPY_UINT64 NPY_UINT
        typedef int npy_int64;
        typedef unsigned int npy_uint64;
#    define PyInt64ScalarObject PyIntScalarObject
#    define PyInt64ArrType_Type PyIntArrType_Type
#    define PyUInt64ScalarObject PyUIntScalarObject
#    define PyUInt64ArrType_Type PyUIntArrType_Type
#define NPY_INT64_FMT NPY_INT_FMT
#define NPY_UINT64_FMT NPY_UINT_FMT
#    define MyPyLong_FromInt64 PyLong_FromLong
#    define MyPyLong_AsInt64 PyLong_AsLong
#endif
#elif NPY_BITSOF_INT == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_INT
#define NPY_UINT128 NPY_UINT
        typedef int npy_int128;
        typedef unsigned int npy_uint128;
#    define PyInt128ScalarObject PyIntScalarObject
#    define PyInt128ArrType_Type PyIntArrType_Type
#    define PyUInt128ScalarObject PyUIntScalarObject
#    define PyUInt128ArrType_Type PyUIntArrType_Type
#define NPY_INT128_FMT NPY_INT_FMT
#define NPY_UINT128_FMT NPY_UINT_FMT
#endif
#endif

#if NPY_BITSOF_SHORT == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_SHORT
#define NPY_UINT8 NPY_USHORT
        typedef short npy_int8;
        typedef unsigned short npy_uint8;
#    define PyInt8ScalarObject PyShortScalarObject
#    define PyInt8ArrType_Type PyShortArrType_Type
#    define PyUInt8ScalarObject PyUShortScalarObject
#    define PyUInt8ArrType_Type PyUShortArrType_Type
#define NPY_INT8_FMT NPY_SHORT_FMT
#define NPY_UINT8_FMT NPY_USHORT_FMT
#endif
#elif NPY_BITSOF_SHORT == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_SHORT
#define NPY_UINT16 NPY_USHORT
        typedef short npy_int16;
        typedef unsigned short npy_uint16;
#    define PyInt16ScalarObject PyShortScalarObject
#    define PyInt16ArrType_Type PyShortArrType_Type
#    define PyUInt16ScalarObject PyUShortScalarObject
#    define PyUInt16ArrType_Type PyUShortArrType_Type
#define NPY_INT16_FMT NPY_SHORT_FMT
#define NPY_UINT16_FMT NPY_USHORT_FMT
#endif
#elif NPY_BITSOF_SHORT == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_SHORT
#define NPY_UINT32 NPY_USHORT
        typedef short npy_int32;
        typedef unsigned short npy_uint32;
        typedef unsigned short npy_ucs4;
#    define PyInt32ScalarObject PyShortScalarObject
#    define PyInt32ArrType_Type PyShortArrType_Type
#    define PyUInt32ScalarObject PyUShortScalarObject
#    define PyUInt32ArrType_Type PyUShortArrType_Type
#define NPY_INT32_FMT NPY_SHORT_FMT
#define NPY_UINT32_FMT NPY_USHORT_FMT
#endif
#elif NPY_BITSOF_SHORT == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_SHORT
#define NPY_UINT64 NPY_USHORT
        typedef short npy_int64;
        typedef unsigned short npy_uint64;
#    define PyInt64ScalarObject PyShortScalarObject
#    define PyInt64ArrType_Type PyShortArrType_Type
#    define PyUInt64ScalarObject PyUShortScalarObject
#    define PyUInt64ArrType_Type PyUShortArrType_Type
#define NPY_INT64_FMT NPY_SHORT_FMT
#define NPY_UINT64_FMT NPY_USHORT_FMT
#    define MyPyLong_FromInt64 PyLong_FromLong
#    define MyPyLong_AsInt64 PyLong_AsLong
#endif
#elif NPY_BITSOF_SHORT == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_SHORT
#define NPY_UINT128 NPY_USHORT
        typedef short npy_int128;
        typedef unsigned short npy_uint128;
#    define PyInt128ScalarObject PyShortScalarObject
#    define PyInt128ArrType_Type PyShortArrType_Type
#    define PyUInt128ScalarObject PyUShortScalarObject
#    define PyUInt128ArrType_Type PyUShortArrType_Type
#define NPY_INT128_FMT NPY_SHORT_FMT
#define NPY_UINT128_FMT NPY_USHORT_FMT
#endif
#endif


#if NPY_BITSOF_CHAR == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_BYTE
#define NPY_UINT8 NPY_UBYTE
        typedef signed char npy_int8;
        typedef unsigned char npy_uint8;
#    define PyInt8ScalarObject PyByteScalarObject
#    define PyInt8ArrType_Type PyByteArrType_Type
#    define PyUInt8ScalarObject PyUByteScalarObject
#    define PyUInt8ArrType_Type PyUByteArrType_Type
#define NPY_INT8_FMT NPY_BYTE_FMT
#define NPY_UINT8_FMT NPY_UBYTE_FMT
#endif
#elif NPY_BITSOF_CHAR == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_BYTE
#define NPY_UINT16 NPY_UBYTE
        typedef signed char npy_int16;
        typedef unsigned char npy_uint16;
#    define PyInt16ScalarObject PyByteScalarObject
#    define PyInt16ArrType_Type PyByteArrType_Type
#    define PyUInt16ScalarObject PyUByteScalarObject
#    define PyUInt16ArrType_Type PyUByteArrType_Type
#define NPY_INT16_FMT NPY_BYTE_FMT
#define NPY_UINT16_FMT NPY_UBYTE_FMT
#endif
#elif NPY_BITSOF_CHAR == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_BYTE
#define NPY_UINT32 NPY_UBYTE
        typedef signed char npy_int32;
        typedef unsigned char npy_uint32;
        typedef unsigned char npy_ucs4;
#    define PyInt32ScalarObject PyByteScalarObject
#    define PyInt32ArrType_Type PyByteArrType_Type
#    define PyUInt32ScalarObject PyUByteScalarObject
#    define PyUInt32ArrType_Type PyUByteArrType_Type
#define NPY_INT32_FMT NPY_BYTE_FMT
#define NPY_UINT32_FMT NPY_UBYTE_FMT
#endif
#elif NPY_BITSOF_CHAR == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_BYTE
#define NPY_UINT64 NPY_UBYTE
        typedef signed char npy_int64;
        typedef unsigned char npy_uint64;
#    define PyInt64ScalarObject PyByteScalarObject
#    define PyInt64ArrType_Type PyByteArrType_Type
#    define PyUInt64ScalarObject PyUByteScalarObject
#    define PyUInt64ArrType_Type PyUByteArrType_Type
#define NPY_INT64_FMT NPY_BYTE_FMT
#define NPY_UINT64_FMT NPY_UBYTE_FMT
#    define MyPyLong_FromInt64 PyLong_FromLong
#    define MyPyLong_AsInt64 PyLong_AsLong
#endif
#elif NPY_BITSOF_CHAR == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_BYTE
#define NPY_UINT128 NPY_UBYTE
        typedef signed char npy_int128;
        typedef unsigned char npy_uint128;
#    define PyInt128ScalarObject PyByteScalarObject
#    define PyInt128ArrType_Type PyByteArrType_Type
#    define PyUInt128ScalarObject PyUByteScalarObject
#    define PyUInt128ArrType_Type PyUByteArrType_Type
#define NPY_INT128_FMT NPY_BYTE_FMT
#define NPY_UINT128_FMT NPY_UBYTE_FMT
#endif
#endif



#if NPY_BITSOF_DOUBLE == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_DOUBLE
#define NPY_COMPLEX64 NPY_CDOUBLE
        typedef double npy_float32;
        typedef npy_cdouble npy_complex64;
#    define PyFloat32ScalarObject PyDoubleScalarObject
#    define PyComplex64ScalarObject PyCDoubleScalarObject
#    define PyFloat32ArrType_Type PyDoubleArrType_Type
#    define PyComplex64ArrType_Type PyCDoubleArrType_Type
#define NPY_FLOAT32_FMT NPY_DOUBLE_FMT
#define NPY_COMPLEX64_FMT NPY_CDOUBLE_FMT
#endif
#elif NPY_BITSOF_DOUBLE == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_DOUBLE
#define NPY_COMPLEX128 NPY_CDOUBLE
        typedef double npy_float64;
        typedef npy_cdouble npy_complex128;
#    define PyFloat64ScalarObject PyDoubleScalarObject
#    define PyComplex128ScalarObject PyCDoubleScalarObject
#    define PyFloat64ArrType_Type PyDoubleArrType_Type
#    define PyComplex128ArrType_Type PyCDoubleArrType_Type
#define NPY_FLOAT64_FMT NPY_DOUBLE_FMT
#define NPY_COMPLEX128_FMT NPY_CDOUBLE_FMT
#endif
#elif NPY_BITSOF_DOUBLE == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_DOUBLE
#define NPY_COMPLEX160 NPY_CDOUBLE
        typedef double npy_float80;
        typedef npy_cdouble npy_complex160;
#    define PyFloat80ScalarObject PyDoubleScalarObject
#    define PyComplex160ScalarObject PyCDoubleScalarObject
#    define PyFloat80ArrType_Type PyDoubleArrType_Type
#    define PyComplex160ArrType_Type PyCDoubleArrType_Type
#define NPY_FLOAT80_FMT NPY_DOUBLE_FMT
#define NPY_COMPLEX160_FMT NPY_CDOUBLE_FMT
#endif
#elif NPY_BITSOF_DOUBLE == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_DOUBLE
#define NPY_COMPLEX192 NPY_CDOUBLE
        typedef double npy_float96;
        typedef npy_cdouble npy_complex192;
#    define PyFloat96ScalarObject PyDoubleScalarObject
#    define PyComplex192ScalarObject PyCDoubleScalarObject
#    define PyFloat96ArrType_Type PyDoubleArrType_Type
#    define PyComplex192ArrType_Type PyCDoubleArrType_Type
#define NPY_FLOAT96_FMT NPY_DOUBLE_FMT
#define NPY_COMPLEX192_FMT NPY_CDOUBLE_FMT
#endif
#elif NPY_BITSOF_DOUBLE == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_DOUBLE
#define NPY_COMPLEX256 NPY_CDOUBLE
        typedef double npy_float128;
        typedef npy_cdouble npy_complex256;
#    define PyFloat128ScalarObject PyDoubleScalarObject
#    define PyComplex256ScalarObject PyCDoubleScalarObject
#    define PyFloat128ArrType_Type PyDoubleArrType_Type
#    define PyComplex256ArrType_Type PyCDoubleArrType_Type
#define NPY_FLOAT128_FMT NPY_DOUBLE_FMT
#define NPY_COMPLEX256_FMT NPY_CDOUBLE_FMT
#endif
#endif



#if NPY_BITSOF_FLOAT == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_FLOAT
#define NPY_COMPLEX64 NPY_CFLOAT
        typedef float npy_float32;
        typedef npy_cfloat npy_complex64;
#    define PyFloat32ScalarObject PyFloatScalarObject
#    define PyComplex64ScalarObject PyCFloatScalarObject
#    define PyFloat32ArrType_Type PyFloatArrType_Type
#    define PyComplex64ArrType_Type PyCFloatArrType_Type
#define NPY_FLOAT32_FMT NPY_FLOAT_FMT
#define NPY_COMPLEX64_FMT NPY_CFLOAT_FMT
#endif
#elif NPY_BITSOF_FLOAT == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_FLOAT
#define NPY_COMPLEX128 NPY_CFLOAT
        typedef float npy_float64;
        typedef npy_cfloat npy_complex128;
#    define PyFloat64ScalarObject PyFloatScalarObject
#    define PyComplex128ScalarObject PyCFloatScalarObject
#    define PyFloat64ArrType_Type PyFloatArrType_Type
#    define PyComplex128ArrType_Type PyCFloatArrType_Type
#define NPY_FLOAT64_FMT NPY_FLOAT_FMT
#define NPY_COMPLEX128_FMT NPY_CFLOAT_FMT
#endif
#elif NPY_BITSOF_FLOAT == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_FLOAT
#define NPY_COMPLEX160 NPY_CFLOAT
        typedef float npy_float80;
        typedef npy_cfloat npy_complex160;
#    define PyFloat80ScalarObject PyFloatScalarObject
#    define PyComplex160ScalarObject PyCFloatScalarObject
#    define PyFloat80ArrType_Type PyFloatArrType_Type
#    define PyComplex160ArrType_Type PyCFloatArrType_Type
#define NPY_FLOAT80_FMT NPY_FLOAT_FMT
#define NPY_COMPLEX160_FMT NPY_CFLOAT_FMT
#endif
#elif NPY_BITSOF_FLOAT == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_FLOAT
#define NPY_COMPLEX192 NPY_CFLOAT
        typedef float npy_float96;
        typedef npy_cfloat npy_complex192;
#    define PyFloat96ScalarObject PyFloatScalarObject
#    define PyComplex192ScalarObject PyCFloatScalarObject
#    define PyFloat96ArrType_Type PyFloatArrType_Type
#    define PyComplex192ArrType_Type PyCFloatArrType_Type
#define NPY_FLOAT96_FMT NPY_FLOAT_FMT
#define NPY_COMPLEX192_FMT NPY_CFLOAT_FMT
#endif
#elif NPY_BITSOF_FLOAT == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_FLOAT
#define NPY_COMPLEX256 NPY_CFLOAT
        typedef float npy_float128;
        typedef npy_cfloat npy_complex256;
#    define PyFloat128ScalarObject PyFloatScalarObject
#    define PyComplex256ScalarObject PyCFloatScalarObject
#    define PyFloat128ArrType_Type PyFloatArrType_Type
#    define PyComplex256ArrType_Type PyCFloatArrType_Type
#define NPY_FLOAT128_FMT NPY_FLOAT_FMT
#define NPY_COMPLEX256_FMT NPY_CFLOAT_FMT
#endif
#endif

/* half/float16 isn't a floating-point type in C */
#define NPY_FLOAT16 NPY_HALF
typedef npy_uint16 npy_half;
typedef npy_half npy_float16;

#if NPY_BITSOF_LONGDOUBLE == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_LONGDOUBLE
#define NPY_COMPLEX64 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float32;
        typedef npy_clongdouble npy_complex64;
#    define PyFloat32ScalarObject PyLongDoubleScalarObject
#    define PyComplex64ScalarObject PyCLongDoubleScalarObject
#    define PyFloat32ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex64ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT32_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX64_FMT NPY_CLONGDOUBLE_FMT
#endif
#elif NPY_BITSOF_LONGDOUBLE == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_LONGDOUBLE
#define NPY_COMPLEX128 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float64;
        typedef npy_clongdouble npy_complex128;
#    define PyFloat64ScalarObject PyLongDoubleScalarObject
#    define PyComplex128ScalarObject PyCLongDoubleScalarObject
#    define PyFloat64ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex128ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT64_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX128_FMT NPY_CLONGDOUBLE_FMT
#endif
#elif NPY_BITSOF_LONGDOUBLE == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_LONGDOUBLE
#define NPY_COMPLEX160 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float80;
        typedef npy_clongdouble npy_complex160;
#    define PyFloat80ScalarObject PyLongDoubleScalarObject
#    define PyComplex160ScalarObject PyCLongDoubleScalarObject
#    define PyFloat80ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex160ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT80_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX160_FMT NPY_CLONGDOUBLE_FMT
#endif
#elif NPY_BITSOF_LONGDOUBLE == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_LONGDOUBLE
#define NPY_COMPLEX192 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float96;
        typedef npy_clongdouble npy_complex192;
#    define PyFloat96ScalarObject PyLongDoubleScalarObject
#    define PyComplex192ScalarObject PyCLongDoubleScalarObject
#    define PyFloat96ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex192ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT96_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX192_FMT NPY_CLONGDOUBLE_FMT
#endif
#elif NPY_BITSOF_LONGDOUBLE == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_LONGDOUBLE
#define NPY_COMPLEX256 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float128;
        typedef npy_clongdouble npy_complex256;
#    define PyFloat128ScalarObject PyLongDoubleScalarObject
#    define PyComplex256ScalarObject PyCLongDoubleScalarObject
#    define PyFloat128ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex256ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT128_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX256_FMT NPY_CLONGDOUBLE_FMT
#endif
#elif NPY_BITSOF_LONGDOUBLE == 256
#define NPY_FLOAT256 NPY_LONGDOUBLE
#define NPY_COMPLEX512 NPY_CLONGDOUBLE
        typedef npy_longdouble npy_float256;
        typedef npy_clongdouble npy_complex512;
#    define PyFloat256ScalarObject PyLongDoubleScalarObject
#    define PyComplex512ScalarObject PyCLongDoubleScalarObject
#    define PyFloat256ArrType_Type PyLongDoubleArrType_Type
#    define PyComplex512ArrType_Type PyCLongDoubleArrType_Type
#define NPY_FLOAT256_FMT NPY_LONGDOUBLE_FMT
#define NPY_COMPLEX512_FMT NPY_CLONGDOUBLE_FMT
#endif

/* datetime typedefs */
typedef npy_int64 npy_timedelta;
typedef npy_int64 npy_datetime;
#define NPY_DATETIME_FMT NPY_INT64_FMT
#define NPY_TIMEDELTA_FMT NPY_INT64_FMT

/* End of typedefs for numarray style bit-width names */

#endif
                                                                                                                                                                                                                                                                            npy_cpu.h                                                                                           0100644 0001750 0001750 00000007354 12215056644 041744  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 /*
 * This set (target) cpu specific macros:
 *      - Possible values:
 *              NPY_CPU_X86
 *              NPY_CPU_AMD64
 *              NPY_CPU_PPC
 *              NPY_CPU_PPC64
 *              NPY_CPU_SPARC
 *              NPY_CPU_S390
 *              NPY_CPU_IA64
 *              NPY_CPU_HPPA
 *              NPY_CPU_ALPHA
 *              NPY_CPU_ARMEL
 *              NPY_CPU_ARMEB
 *              NPY_CPU_SH_LE
 *              NPY_CPU_SH_BE
 */
#ifndef _NPY_CPUARCH_H_
#define _NPY_CPUARCH_H_

#include "numpyconfig.h"

#if defined( __i386__ ) || defined(i386) || defined(_M_IX86)
    /*
     * __i386__ is defined by gcc and Intel compiler on Linux,
     * _M_IX86 by VS compiler,
     * i386 by Sun compilers on opensolaris at least
     */
    #define NPY_CPU_X86
#elif defined(__x86_64__) || defined(__amd64__) || defined(__x86_64) || defined(_M_AMD64)
    /*
     * both __x86_64__ and __amd64__ are defined by gcc
     * __x86_64 defined by sun compiler on opensolaris at least
     * _M_AMD64 defined by MS compiler
     */
    #define NPY_CPU_AMD64
#elif defined(__ppc__) || defined(__powerpc__) || defined(_ARCH_PPC)
    /*
     * __ppc__ is defined by gcc, I remember having seen __powerpc__ once,
     * but can't find it ATM
     * _ARCH_PPC is used by at least gcc on AIX
     */
    #define NPY_CPU_PPC
#elif defined(__ppc64__)
    #define NPY_CPU_PPC64
#elif defined(__sparc__) || defined(__sparc)
    /* __sparc__ is defined by gcc and Forte (e.g. Sun) compilers */
    #define NPY_CPU_SPARC
#elif defined(__s390__)
    #define NPY_CPU_S390
#elif defined(__ia64)
    #define NPY_CPU_IA64
#elif defined(__hppa)
    #define NPY_CPU_HPPA
#elif defined(__alpha__)
    #define NPY_CPU_ALPHA
#elif defined(__arm__) && defined(__ARMEL__)
    #define NPY_CPU_ARMEL
#elif defined(__arm__) && defined(__ARMEB__)
    #define NPY_CPU_ARMEB
#elif defined(__sh__) && defined(__LITTLE_ENDIAN__)
    #define NPY_CPU_SH_LE
#elif defined(__sh__) && defined(__BIG_ENDIAN__)
    #define NPY_CPU_SH_BE
#elif defined(__MIPSEL__)
    #define NPY_CPU_MIPSEL
#elif defined(__MIPSEB__)
    #define NPY_CPU_MIPSEB
#elif defined(__aarch64__)
    #define NPY_CPU_AARCH64
#elif defined(__mc68000__)
    #define NPY_CPU_M68K
#else
    #error Unknown CPU, please report this to numpy maintainers with \
    information about your platform (OS, CPU and compiler)
#endif

/*
   This "white-lists" the architectures that we know don't require
   pointer alignment.  We white-list, since the memcpy version will
   work everywhere, whereas assignment will only work where pointer
   dereferencing doesn't require alignment.

   TODO: There may be more architectures we can white list.
*/
#if defined(NPY_CPU_X86) || defined(NPY_CPU_AMD64)
    #define NPY_COPY_PYOBJECT_PTR(dst, src) (*((PyObject **)(dst)) = *((PyObject **)(src)))
#else
    #if NPY_SIZEOF_PY_INTPTR_T == 4
        #define NPY_COPY_PYOBJECT_PTR(dst, src) \
            ((char*)(dst))[0] = ((char*)(src))[0]; \
            ((char*)(dst))[1] = ((char*)(src))[1]; \
            ((char*)(dst))[2] = ((char*)(src))[2]; \
            ((char*)(dst))[3] = ((char*)(src))[3];
    #elif NPY_SIZEOF_PY_INTPTR_T == 8
        #define NPY_COPY_PYOBJECT_PTR(dst, src) \
            ((char*)(dst))[0] = ((char*)(src))[0]; \
            ((char*)(dst))[1] = ((char*)(src))[1]; \
            ((char*)(dst))[2] = ((char*)(src))[2]; \
            ((char*)(dst))[3] = ((char*)(src))[3]; \
            ((char*)(dst))[4] = ((char*)(src))[4]; \
            ((char*)(dst))[5] = ((char*)(src))[5]; \
            ((char*)(dst))[6] = ((char*)(src))[6]; \
            ((char*)(dst))[7] = ((char*)(src))[7];
    #else
        #error Unknown architecture, please report this to numpy maintainers with \
        information about your platform (OS, CPU and compiler)
    #endif
#endif

#endif
                                                                                                                                                                                                                                                                                    npy_endian.h                                                                                        0100644 0001750 0001750 00000002553 12215056644 042407  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef _NPY_ENDIAN_H_
#define _NPY_ENDIAN_H_

/*
 * NPY_BYTE_ORDER is set to the same value as BYTE_ORDER set by glibc in
 * endian.h
 */

#ifdef NPY_HAVE_ENDIAN_H
    /* Use endian.h if available */
    #include <endian.h>

    #define NPY_BYTE_ORDER __BYTE_ORDER
    #define NPY_LITTLE_ENDIAN __LITTLE_ENDIAN
    #define NPY_BIG_ENDIAN __BIG_ENDIAN
#else
    /* Set endianness info using target CPU */
    #include "npy_cpu.h"

    #define NPY_LITTLE_ENDIAN 1234
    #define NPY_BIG_ENDIAN 4321

    #if defined(NPY_CPU_X86)            \
            || defined(NPY_CPU_AMD64)   \
            || defined(NPY_CPU_IA64)    \
            || defined(NPY_CPU_ALPHA)   \
            || defined(NPY_CPU_ARMEL)   \
            || defined(NPY_CPU_AARCH64) \
            || defined(NPY_CPU_SH_LE)   \
            || defined(NPY_CPU_MIPSEL)
        #define NPY_BYTE_ORDER NPY_LITTLE_ENDIAN
    #elif defined(NPY_CPU_PPC)          \
            || defined(NPY_CPU_SPARC)   \
            || defined(NPY_CPU_S390)    \
            || defined(NPY_CPU_HPPA)    \
            || defined(NPY_CPU_PPC64)   \
            || defined(NPY_CPU_ARMEB)   \
            || defined(NPY_CPU_SH_BE)   \
            || defined(NPY_CPU_MIPSEB)  \
            || defined(NPY_CPU_M68K)
        #define NPY_BYTE_ORDER NPY_BIG_ENDIAN
    #else
        #error Unknown CPU: can not set endianness
    #endif
#endif

#endif
                                                                                                                                                     npy_interrupt.h                                                                                     0100644 0001750 0001750 00000006557 12215056622 043211  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 
/* Signal handling:

This header file defines macros that allow your code to handle
interrupts received during processing.  Interrupts that
could reasonably be handled:

SIGINT, SIGABRT, SIGALRM, SIGSEGV

****Warning***************

Do not allow code that creates temporary memory or increases reference
counts of Python objects to be interrupted unless you handle it
differently.

**************************

The mechanism for handling interrupts is conceptually simple:

  - replace the signal handler with our own home-grown version
     and store the old one.
  - run the code to be interrupted -- if an interrupt occurs
     the handler should basically just cause a return to the
     calling function for finish work.
  - restore the old signal handler

Of course, every code that allows interrupts must account for
returning via the interrupt and handle clean-up correctly.  But,
even still, the simple paradigm is complicated by at least three
factors.

 1) platform portability (i.e. Microsoft says not to use longjmp
     to return from signal handling.  They have a __try  and __except
     extension to C instead but what about mingw?).

 2) how to handle threads: apparently whether signals are delivered to
    every thread of the process or the "invoking" thread is platform
    dependent. --- we don't handle threads for now.

 3) do we need to worry about re-entrance.  For now, assume the
    code will not call-back into itself.

Ideas:

 1) Start by implementing an approach that works on platforms that
    can use setjmp and longjmp functionality and does nothing
    on other platforms.

 2) Ignore threads --- i.e. do not mix interrupt handling and threads

 3) Add a default signal_handler function to the C-API but have the rest
    use macros.


Simple Interface:


In your C-extension: around a block of code you want to be interruptable
with a SIGINT

NPY_SIGINT_ON
[code]
NPY_SIGINT_OFF

In order for this to work correctly, the
[code] block must not allocate any memory or alter the reference count of any
Python objects.  In other words [code] must be interruptible so that continuation
after NPY_SIGINT_OFF will only be "missing some computations"

Interrupt handling does not work well with threads.

*/

/* Add signal handling macros
   Make the global variable and signal handler part of the C-API
*/

#ifndef NPY_INTERRUPT_H
#define NPY_INTERRUPT_H

#ifndef NPY_NO_SIGNAL

#include <setjmp.h>
#include <signal.h>

#ifndef sigsetjmp

#define NPY_SIGSETJMP(arg1, arg2) setjmp(arg1)
#define NPY_SIGLONGJMP(arg1, arg2) longjmp(arg1, arg2)
#define NPY_SIGJMP_BUF jmp_buf

#else

#define NPY_SIGSETJMP(arg1, arg2) sigsetjmp(arg1, arg2)
#define NPY_SIGLONGJMP(arg1, arg2) siglongjmp(arg1, arg2)
#define NPY_SIGJMP_BUF sigjmp_buf

#endif

#    define NPY_SIGINT_ON {                                             \
                   PyOS_sighandler_t _npy_sig_save;                     \
                   _npy_sig_save = PyOS_setsig(SIGINT, _PyArray_SigintHandler); \
                   if (NPY_SIGSETJMP(*((NPY_SIGJMP_BUF *)_PyArray_GetSigintBuf()), \
                                 1) == 0) {                             \

#    define NPY_SIGINT_OFF }                                      \
        PyOS_setsig(SIGINT, _npy_sig_save);                       \
        }

#else /* NPY_NO_SIGNAL  */

#define NPY_SIGINT_ON
#define NPY_SIGINT_OFF

#endif /* HAVE_SIGSETJMP */

#endif /* NPY_INTERRUPT_H */
                                                                                                                                                 npy_math.h                                                                                          0100644 0001750 0001750 00000034307 12215056644 042104  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef __NPY_MATH_C99_H_
#define __NPY_MATH_C99_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <math.h>
#ifdef HAVE_NPY_CONFIG_H
#include <npy_config.h>
#endif
#include <numpy/npy_common.h>

/*
 * NAN and INFINITY like macros (same behavior as glibc for NAN, same as C99
 * for INFINITY)
 *
 * XXX: I should test whether INFINITY and NAN are available on the platform
 */
NPY_INLINE static float __npy_inff(void)
{
    const union { npy_uint32 __i; float __f;} __bint = {0x7f800000UL};
    return __bint.__f;
}

NPY_INLINE static float __npy_nanf(void)
{
    const union { npy_uint32 __i; float __f;} __bint = {0x7fc00000UL};
    return __bint.__f;
}

NPY_INLINE static float __npy_pzerof(void)
{
    const union { npy_uint32 __i; float __f;} __bint = {0x00000000UL};
    return __bint.__f;
}

NPY_INLINE static float __npy_nzerof(void)
{
    const union { npy_uint32 __i; float __f;} __bint = {0x80000000UL};
    return __bint.__f;
}

#define NPY_INFINITYF __npy_inff()
#define NPY_NANF __npy_nanf()
#define NPY_PZEROF __npy_pzerof()
#define NPY_NZEROF __npy_nzerof()

#define NPY_INFINITY ((npy_double)NPY_INFINITYF)
#define NPY_NAN ((npy_double)NPY_NANF)
#define NPY_PZERO ((npy_double)NPY_PZEROF)
#define NPY_NZERO ((npy_double)NPY_NZEROF)

#define NPY_INFINITYL ((npy_longdouble)NPY_INFINITYF)
#define NPY_NANL ((npy_longdouble)NPY_NANF)
#define NPY_PZEROL ((npy_longdouble)NPY_PZEROF)
#define NPY_NZEROL ((npy_longdouble)NPY_NZEROF)

/*
 * Useful constants
 */
#define NPY_E         2.718281828459045235360287471352662498  /* e */
#define NPY_LOG2E     1.442695040888963407359924681001892137  /* log_2 e */
#define NPY_LOG10E    0.434294481903251827651128918916605082  /* log_10 e */
#define NPY_LOGE2     0.693147180559945309417232121458176568  /* log_e 2 */
#define NPY_LOGE10    2.302585092994045684017991454684364208  /* log_e 10 */
#define NPY_PI        3.141592653589793238462643383279502884  /* pi */
#define NPY_PI_2      1.570796326794896619231321691639751442  /* pi/2 */
#define NPY_PI_4      0.785398163397448309615660845819875721  /* pi/4 */
#define NPY_1_PI      0.318309886183790671537767526745028724  /* 1/pi */
#define NPY_2_PI      0.636619772367581343075535053490057448  /* 2/pi */
#define NPY_EULER     0.577215664901532860606512090082402431  /* Euler constant */
#define NPY_SQRT2     1.414213562373095048801688724209698079  /* sqrt(2) */
#define NPY_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2) */

#define NPY_Ef        2.718281828459045235360287471352662498F /* e */
#define NPY_LOG2Ef    1.442695040888963407359924681001892137F /* log_2 e */
#define NPY_LOG10Ef   0.434294481903251827651128918916605082F /* log_10 e */
#define NPY_LOGE2f    0.693147180559945309417232121458176568F /* log_e 2 */
#define NPY_LOGE10f   2.302585092994045684017991454684364208F /* log_e 10 */
#define NPY_PIf       3.141592653589793238462643383279502884F /* pi */
#define NPY_PI_2f     1.570796326794896619231321691639751442F /* pi/2 */
#define NPY_PI_4f     0.785398163397448309615660845819875721F /* pi/4 */
#define NPY_1_PIf     0.318309886183790671537767526745028724F /* 1/pi */
#define NPY_2_PIf     0.636619772367581343075535053490057448F /* 2/pi */
#define NPY_EULERf    0.577215664901532860606512090082402431F /* Euler constan*/
#define NPY_SQRT2f    1.414213562373095048801688724209698079F /* sqrt(2) */
#define NPY_SQRT1_2f  0.707106781186547524400844362104849039F /* 1/sqrt(2) */

#define NPY_El        2.718281828459045235360287471352662498L /* e */
#define NPY_LOG2El    1.442695040888963407359924681001892137L /* log_2 e */
#define NPY_LOG10El   0.434294481903251827651128918916605082L /* log_10 e */
#define NPY_LOGE2l    0.693147180559945309417232121458176568L /* log_e 2 */
#define NPY_LOGE10l   2.302585092994045684017991454684364208L /* log_e 10 */
#define NPY_PIl       3.141592653589793238462643383279502884L /* pi */
#define NPY_PI_2l     1.570796326794896619231321691639751442L /* pi/2 */
#define NPY_PI_4l     0.785398163397448309615660845819875721L /* pi/4 */
#define NPY_1_PIl     0.318309886183790671537767526745028724L /* 1/pi */
#define NPY_2_PIl     0.636619772367581343075535053490057448L /* 2/pi */
#define NPY_EULERl    0.577215664901532860606512090082402431L /* Euler constan*/
#define NPY_SQRT2l    1.414213562373095048801688724209698079L /* sqrt(2) */
#define NPY_SQRT1_2l  0.707106781186547524400844362104849039L /* 1/sqrt(2) */

/*
 * C99 double math funcs
 */
double npy_sin(double x);
double npy_cos(double x);
double npy_tan(double x);
double npy_sinh(double x);
double npy_cosh(double x);
double npy_tanh(double x);

double npy_asin(double x);
double npy_acos(double x);
double npy_atan(double x);
double npy_aexp(double x);
double npy_alog(double x);
double npy_asqrt(double x);
double npy_afabs(double x);

double npy_log(double x);
double npy_log10(double x);
double npy_exp(double x);
double npy_sqrt(double x);

double npy_fabs(double x);
double npy_ceil(double x);
double npy_fmod(double x, double y);
double npy_floor(double x);

double npy_expm1(double x);
double npy_log1p(double x);
double npy_hypot(double x, double y);
double npy_acosh(double x);
double npy_asinh(double xx);
double npy_atanh(double x);
double npy_rint(double x);
double npy_trunc(double x);
double npy_exp2(double x);
double npy_log2(double x);

double npy_atan2(double x, double y);
double npy_pow(double x, double y);
double npy_modf(double x, double* y);

double npy_copysign(double x, double y);
double npy_nextafter(double x, double y);
double npy_spacing(double x);

/*
 * IEEE 754 fpu handling. Those are guaranteed to be macros
 */

/* use builtins to avoid function calls in tight loops
 * only available if npy_config.h is available (= numpys own build) */
#if HAVE___BUILTIN_ISNAN
    #define npy_isnan(x) __builtin_isnan(x)
#else
    #ifndef NPY_HAVE_DECL_ISNAN
        #define npy_isnan(x) ((x) != (x))
    #else
        #ifdef _MSC_VER
            #define npy_isnan(x) _isnan((x))
        #else
            #define npy_isnan(x) isnan(x)
        #endif
    #endif
#endif


/* only available if npy_config.h is available (= numpys own build) */
#if HAVE___BUILTIN_ISFINITE
    #define npy_isfinite(x) __builtin_isfinite(x)
#else
    #ifndef NPY_HAVE_DECL_ISFINITE
        #ifdef _MSC_VER
            #define npy_isfinite(x) _finite((x))
        #else
            #define npy_isfinite(x) !npy_isnan((x) + (-x))
        #endif
    #else
        #define npy_isfinite(x) isfinite((x))
    #endif
#endif

/* only available if npy_config.h is available (= numpys own build) */
#if HAVE___BUILTIN_ISINF
    #define npy_isinf(x) __builtin_isinf(x)
#else
    #ifndef NPY_HAVE_DECL_ISINF
        #define npy_isinf(x) (!npy_isfinite(x) && !npy_isnan(x))
    #else
        #ifdef _MSC_VER
            #define npy_isinf(x) (!_finite((x)) && !_isnan((x)))
        #else
            #define npy_isinf(x) isinf((x))
        #endif
    #endif
#endif

#ifndef NPY_HAVE_DECL_SIGNBIT
    int _npy_signbit_f(float x);
    int _npy_signbit_d(double x);
    int _npy_signbit_ld(long double x);
    #define npy_signbit(x) \
        (sizeof (x) == sizeof (long double) ? _npy_signbit_ld (x) \
         : sizeof (x) == sizeof (double) ? _npy_signbit_d (x) \
         : _npy_signbit_f (x))
#else
    #define npy_signbit(x) signbit((x))
#endif

/*
 * float C99 math functions
 */

float npy_sinf(float x);
float npy_cosf(float x);
float npy_tanf(float x);
float npy_sinhf(float x);
float npy_coshf(float x);
float npy_tanhf(float x);
float npy_fabsf(float x);
float npy_floorf(float x);
float npy_ceilf(float x);
float npy_rintf(float x);
float npy_truncf(float x);
float npy_sqrtf(float x);
float npy_log10f(float x);
float npy_logf(float x);
float npy_expf(float x);
float npy_expm1f(float x);
float npy_asinf(float x);
float npy_acosf(float x);
float npy_atanf(float x);
float npy_asinhf(float x);
float npy_acoshf(float x);
float npy_atanhf(float x);
float npy_log1pf(float x);
float npy_exp2f(float x);
float npy_log2f(float x);

float npy_atan2f(float x, float y);
float npy_hypotf(float x, float y);
float npy_powf(float x, float y);
float npy_fmodf(float x, float y);

float npy_modff(float x, float* y);

float npy_copysignf(float x, float y);
float npy_nextafterf(float x, float y);
float npy_spacingf(float x);

/*
 * float C99 math functions
 */

npy_longdouble npy_sinl(npy_longdouble x);
npy_longdouble npy_cosl(npy_longdouble x);
npy_longdouble npy_tanl(npy_longdouble x);
npy_longdouble npy_sinhl(npy_longdouble x);
npy_longdouble npy_coshl(npy_longdouble x);
npy_longdouble npy_tanhl(npy_longdouble x);
npy_longdouble npy_fabsl(npy_longdouble x);
npy_longdouble npy_floorl(npy_longdouble x);
npy_longdouble npy_ceill(npy_longdouble x);
npy_longdouble npy_rintl(npy_longdouble x);
npy_longdouble npy_truncl(npy_longdouble x);
npy_longdouble npy_sqrtl(npy_longdouble x);
npy_longdouble npy_log10l(npy_longdouble x);
npy_longdouble npy_logl(npy_longdouble x);
npy_longdouble npy_expl(npy_longdouble x);
npy_longdouble npy_expm1l(npy_longdouble x);
npy_longdouble npy_asinl(npy_longdouble x);
npy_longdouble npy_acosl(npy_longdouble x);
npy_longdouble npy_atanl(npy_longdouble x);
npy_longdouble npy_asinhl(npy_longdouble x);
npy_longdouble npy_acoshl(npy_longdouble x);
npy_longdouble npy_atanhl(npy_longdouble x);
npy_longdouble npy_log1pl(npy_longdouble x);
npy_longdouble npy_exp2l(npy_longdouble x);
npy_longdouble npy_log2l(npy_longdouble x);

npy_longdouble npy_atan2l(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_hypotl(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_powl(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_fmodl(npy_longdouble x, npy_longdouble y);

npy_longdouble npy_modfl(npy_longdouble x, npy_longdouble* y);

npy_longdouble npy_copysignl(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_nextafterl(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_spacingl(npy_longdouble x);

/*
 * Non standard functions
 */
double npy_deg2rad(double x);
double npy_rad2deg(double x);
double npy_logaddexp(double x, double y);
double npy_logaddexp2(double x, double y);

float npy_deg2radf(float x);
float npy_rad2degf(float x);
float npy_logaddexpf(float x, float y);
float npy_logaddexp2f(float x, float y);

npy_longdouble npy_deg2radl(npy_longdouble x);
npy_longdouble npy_rad2degl(npy_longdouble x);
npy_longdouble npy_logaddexpl(npy_longdouble x, npy_longdouble y);
npy_longdouble npy_logaddexp2l(npy_longdouble x, npy_longdouble y);

#define npy_degrees npy_rad2deg
#define npy_degreesf npy_rad2degf
#define npy_degreesl npy_rad2degl

#define npy_radians npy_deg2rad
#define npy_radiansf npy_deg2radf
#define npy_radiansl npy_deg2radl

/*
 * Complex declarations
 */

/*
 * C99 specifies that complex numbers have the same representation as
 * an array of two elements, where the first element is the real part
 * and the second element is the imaginary part.
 */
#define __NPY_CPACK_IMP(x, y, type, ctype)   \
    union {                                  \
        ctype z;                             \
        type a[2];                           \
    } z1;;                                   \
                                             \
    z1.a[0] = (x);                           \
    z1.a[1] = (y);                           \
                                             \
    return z1.z;

static NPY_INLINE npy_cdouble npy_cpack(double x, double y)
{
    __NPY_CPACK_IMP(x, y, double, npy_cdouble);
}

static NPY_INLINE npy_cfloat npy_cpackf(float x, float y)
{
    __NPY_CPACK_IMP(x, y, float, npy_cfloat);
}

static NPY_INLINE npy_clongdouble npy_cpackl(npy_longdouble x, npy_longdouble y)
{
    __NPY_CPACK_IMP(x, y, npy_longdouble, npy_clongdouble);
}
#undef __NPY_CPACK_IMP

/*
 * Same remark as above, but in the other direction: extract first/second
 * member of complex number, assuming a C99-compatible representation
 *
 * Those are defineds as static inline, and such as a reasonable compiler would
 * most likely compile this to one or two instructions (on CISC at least)
 */
#define __NPY_CEXTRACT_IMP(z, index, type, ctype)   \
    union {                                         \
        ctype z;                                    \
        type a[2];                                  \
    } __z_repr;                                     \
    __z_repr.z = z;                                 \
                                                    \
    return __z_repr.a[index];

static NPY_INLINE double npy_creal(npy_cdouble z)
{
    __NPY_CEXTRACT_IMP(z, 0, double, npy_cdouble);
}

static NPY_INLINE double npy_cimag(npy_cdouble z)
{
    __NPY_CEXTRACT_IMP(z, 1, double, npy_cdouble);
}

static NPY_INLINE float npy_crealf(npy_cfloat z)
{
    __NPY_CEXTRACT_IMP(z, 0, float, npy_cfloat);
}

static NPY_INLINE float npy_cimagf(npy_cfloat z)
{
    __NPY_CEXTRACT_IMP(z, 1, float, npy_cfloat);
}

static NPY_INLINE npy_longdouble npy_creall(npy_clongdouble z)
{
    __NPY_CEXTRACT_IMP(z, 0, npy_longdouble, npy_clongdouble);
}

static NPY_INLINE npy_longdouble npy_cimagl(npy_clongdouble z)
{
    __NPY_CEXTRACT_IMP(z, 1, npy_longdouble, npy_clongdouble);
}
#undef __NPY_CEXTRACT_IMP

/*
 * Double precision complex functions
 */
double npy_cabs(npy_cdouble z);
double npy_carg(npy_cdouble z);

npy_cdouble npy_cexp(npy_cdouble z);
npy_cdouble npy_clog(npy_cdouble z);
npy_cdouble npy_cpow(npy_cdouble x, npy_cdouble y);

npy_cdouble npy_csqrt(npy_cdouble z);

npy_cdouble npy_ccos(npy_cdouble z);
npy_cdouble npy_csin(npy_cdouble z);

/*
 * Single precision complex functions
 */
float npy_cabsf(npy_cfloat z);
float npy_cargf(npy_cfloat z);

npy_cfloat npy_cexpf(npy_cfloat z);
npy_cfloat npy_clogf(npy_cfloat z);
npy_cfloat npy_cpowf(npy_cfloat x, npy_cfloat y);

npy_cfloat npy_csqrtf(npy_cfloat z);

npy_cfloat npy_ccosf(npy_cfloat z);
npy_cfloat npy_csinf(npy_cfloat z);

/*
 * Extended precision complex functions
 */
npy_longdouble npy_cabsl(npy_clongdouble z);
npy_longdouble npy_cargl(npy_clongdouble z);

npy_clongdouble npy_cexpl(npy_clongdouble z);
npy_clongdouble npy_clogl(npy_clongdouble z);
npy_clongdouble npy_cpowl(npy_clongdouble x, npy_clongdouble y);

npy_clongdouble npy_csqrtl(npy_clongdouble z);

npy_clongdouble npy_ccosl(npy_clongdouble z);
npy_clongdouble npy_csinl(npy_clongdouble z);

/*
 * Functions that set the floating point error
 * status word.
 */

void npy_set_floatstatus_divbyzero(void);
void npy_set_floatstatus_overflow(void);
void npy_set_floatstatus_underflow(void);
void npy_set_floatstatus_invalid(void);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                         npy_no_deprecated_api.h                                                                             0100644 0001750 0001750 00000001067 12215056622 044571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 /*
 * This include file is provided for inclusion in Cython *.pyd files where
 * one would like to define the NPY_NO_DEPRECATED_API macro. It can be
 * included by
 *
 * cdef extern from "npy_no_deprecated_api.h": pass
 *
 */
#ifndef NPY_NO_DEPRECATED_API

/* put this check here since there may be multiple includes in C extensions. */
#if defined(NDARRAYTYPES_H) || defined(_NPY_DEPRECATED_API_H) || \
    defined(OLD_DEFINES_H)
#error "npy_no_deprecated_api.h" must be first among numpy includes.
#else
#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         npy_os.h                                                                                            0100644 0001750 0001750 00000001461 11777322264 041575  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef _NPY_OS_H_
#define _NPY_OS_H_

#if defined(linux) || defined(__linux) || defined(__linux__)
    #define NPY_OS_LINUX
#elif defined(__FreeBSD__) || defined(__NetBSD__) || \
            defined(__OpenBSD__) || defined(__DragonFly__)
    #define NPY_OS_BSD
    #ifdef __FreeBSD__
        #define NPY_OS_FREEBSD
    #elif defined(__NetBSD__)
        #define NPY_OS_NETBSD
    #elif defined(__OpenBSD__)
        #define NPY_OS_OPENBSD
    #elif defined(__DragonFly__)
        #define NPY_OS_DRAGONFLY
    #endif
#elif defined(sun) || defined(__sun)
    #define NPY_OS_SOLARIS
#elif defined(__CYGWIN__)
    #define NPY_OS_CYGWIN
#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
    #define NPY_OS_WIN32
#elif defined(__APPLE__)
    #define NPY_OS_DARWIN
#else
    #define NPY_OS_UNKNOWN
#endif

#endif
                                                                                                                                                                                                               numpyconfig.h                                                                                       0100644 0001750 0001750 00000001637 12215056622 042617  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef _NPY_NUMPYCONFIG_H_
#define _NPY_NUMPYCONFIG_H_

#include "_numpyconfig.h"

/*
 * On Mac OS X, because there is only one configuration stage for all the archs
 * in universal builds, any macro which depends on the arch needs to be
 * harcoded
 */
#ifdef __APPLE__
    #undef NPY_SIZEOF_LONG
    #undef NPY_SIZEOF_PY_INTPTR_T

    #ifdef __LP64__
        #define NPY_SIZEOF_LONG         8
        #define NPY_SIZEOF_PY_INTPTR_T  8
    #else
        #define NPY_SIZEOF_LONG         4
        #define NPY_SIZEOF_PY_INTPTR_T  4
    #endif
#endif

/**
 * To help with the NPY_NO_DEPRECATED_API macro, we include API version
 * numbers for specific versions of NumPy. To exclude all API that was
 * deprecated as of 1.7, add the following before #including any NumPy
 * headers:
 *   #define NPY_NO_DEPRECATED_API  NPY_1_7_API_VERSION
 */
#define NPY_1_7_API_VERSION 0x00000007
#define NPY_1_8_API_VERSION 0x00000008

#endif
                                                                                                 old_defines.h                                                                                       0100644 0001750 0001750 00000014242 12215056622 042530  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 /* This header is deprecated as of NumPy 1.7 */
#ifndef OLD_DEFINES_H
#define OLD_DEFINES_H

#if defined(NPY_NO_DEPRECATED_API) && NPY_NO_DEPRECATED_API >= NPY_1_7_API_VERSION
#error The header "old_defines.h" is deprecated as of NumPy 1.7.
#endif

#define NDARRAY_VERSION NPY_VERSION

#define PyArray_MIN_BUFSIZE NPY_MIN_BUFSIZE
#define PyArray_MAX_BUFSIZE NPY_MAX_BUFSIZE
#define PyArray_BUFSIZE NPY_BUFSIZE

#define PyArray_PRIORITY NPY_PRIORITY
#define PyArray_SUBTYPE_PRIORITY NPY_PRIORITY
#define PyArray_NUM_FLOATTYPE NPY_NUM_FLOATTYPE

#define NPY_MAX PyArray_MAX
#define NPY_MIN PyArray_MIN

#define PyArray_TYPES       NPY_TYPES
#define PyArray_BOOL        NPY_BOOL
#define PyArray_BYTE        NPY_BYTE
#define PyArray_UBYTE       NPY_UBYTE
#define PyArray_SHORT       NPY_SHORT
#define PyArray_USHORT      NPY_USHORT
#define PyArray_INT         NPY_INT
#define PyArray_UINT        NPY_UINT
#define PyArray_LONG        NPY_LONG
#define PyArray_ULONG       NPY_ULONG
#define PyArray_LONGLONG    NPY_LONGLONG
#define PyArray_ULONGLONG   NPY_ULONGLONG
#define PyArray_HALF        NPY_HALF
#define PyArray_FLOAT       NPY_FLOAT
#define PyArray_DOUBLE      NPY_DOUBLE
#define PyArray_LONGDOUBLE  NPY_LONGDOUBLE
#define PyArray_CFLOAT      NPY_CFLOAT
#define PyArray_CDOUBLE     NPY_CDOUBLE
#define PyArray_CLONGDOUBLE NPY_CLONGDOUBLE
#define PyArray_OBJECT      NPY_OBJECT
#define PyArray_STRING      NPY_STRING
#define PyArray_UNICODE     NPY_UNICODE
#define PyArray_VOID        NPY_VOID
#define PyArray_DATETIME    NPY_DATETIME
#define PyArray_TIMEDELTA   NPY_TIMEDELTA
#define PyArray_NTYPES      NPY_NTYPES
#define PyArray_NOTYPE      NPY_NOTYPE
#define PyArray_CHAR        NPY_CHAR
#define PyArray_USERDEF     NPY_USERDEF
#define PyArray_NUMUSERTYPES NPY_NUMUSERTYPES

#define PyArray_INTP        NPY_INTP
#define PyArray_UINTP       NPY_UINTP

#define PyArray_INT8    NPY_INT8
#define PyArray_UINT8   NPY_UINT8
#define PyArray_INT16   NPY_INT16
#define PyArray_UINT16  NPY_UINT16
#define PyArray_INT32   NPY_INT32
#define PyArray_UINT32  NPY_UINT32

#ifdef NPY_INT64
#define PyArray_INT64   NPY_INT64
#define PyArray_UINT64  NPY_UINT64
#endif

#ifdef NPY_INT128
#define PyArray_INT128 NPY_INT128
#define PyArray_UINT128 NPY_UINT128
#endif

#ifdef NPY_FLOAT16
#define PyArray_FLOAT16  NPY_FLOAT16
#define PyArray_COMPLEX32  NPY_COMPLEX32
#endif

#ifdef NPY_FLOAT80
#define PyArray_FLOAT80  NPY_FLOAT80
#define PyArray_COMPLEX160  NPY_COMPLEX160
#endif

#ifdef NPY_FLOAT96
#define PyArray_FLOAT96  NPY_FLOAT96
#define PyArray_COMPLEX192  NPY_COMPLEX192
#endif

#ifdef NPY_FLOAT128
#define PyArray_FLOAT128  NPY_FLOAT128
#define PyArray_COMPLEX256  NPY_COMPLEX256
#endif

#define PyArray_FLOAT32    NPY_FLOAT32
#define PyArray_COMPLEX64  NPY_COMPLEX64
#define PyArray_FLOAT64    NPY_FLOAT64
#define PyArray_COMPLEX128 NPY_COMPLEX128


#define PyArray_TYPECHAR        NPY_TYPECHAR
#define PyArray_BOOLLTR         NPY_BOOLLTR
#define PyArray_BYTELTR         NPY_BYTELTR
#define PyArray_UBYTELTR        NPY_UBYTELTR
#define PyArray_SHORTLTR        NPY_SHORTLTR
#define PyArray_USHORTLTR       NPY_USHORTLTR
#define PyArray_INTLTR          NPY_INTLTR
#define PyArray_UINTLTR         NPY_UINTLTR
#define PyArray_LONGLTR         NPY_LONGLTR
#define PyArray_ULONGLTR        NPY_ULONGLTR
#define PyArray_LONGLONGLTR     NPY_LONGLONGLTR
#define PyArray_ULONGLONGLTR    NPY_ULONGLONGLTR
#define PyArray_HALFLTR         NPY_HALFLTR
#define PyArray_FLOATLTR        NPY_FLOATLTR
#define PyArray_DOUBLELTR       NPY_DOUBLELTR
#define PyArray_LONGDOUBLELTR   NPY_LONGDOUBLELTR
#define PyArray_CFLOATLTR       NPY_CFLOATLTR
#define PyArray_CDOUBLELTR      NPY_CDOUBLELTR
#define PyArray_CLONGDOUBLELTR  NPY_CLONGDOUBLELTR
#define PyArray_OBJECTLTR       NPY_OBJECTLTR
#define PyArray_STRINGLTR       NPY_STRINGLTR
#define PyArray_STRINGLTR2      NPY_STRINGLTR2
#define PyArray_UNICODELTR      NPY_UNICODELTR
#define PyArray_VOIDLTR         NPY_VOIDLTR
#define PyArray_DATETIMELTR     NPY_DATETIMELTR
#define PyArray_TIMEDELTALTR    NPY_TIMEDELTALTR
#define PyArray_CHARLTR         NPY_CHARLTR
#define PyArray_INTPLTR         NPY_INTPLTR
#define PyArray_UINTPLTR        NPY_UINTPLTR
#define PyArray_GENBOOLLTR      NPY_GENBOOLLTR
#define PyArray_SIGNEDLTR       NPY_SIGNEDLTR
#define PyArray_UNSIGNEDLTR     NPY_UNSIGNEDLTR
#define PyArray_FLOATINGLTR     NPY_FLOATINGLTR
#define PyArray_COMPLEXLTR      NPY_COMPLEXLTR

#define PyArray_QUICKSORT   NPY_QUICKSORT
#define PyArray_HEAPSORT    NPY_HEAPSORT
#define PyArray_MERGESORT   NPY_MERGESORT
#define PyArray_SORTKIND    NPY_SORTKIND
#define PyArray_NSORTS      NPY_NSORTS

#define PyArray_NOSCALAR       NPY_NOSCALAR
#define PyArray_BOOL_SCALAR    NPY_BOOL_SCALAR
#define PyArray_INTPOS_SCALAR  NPY_INTPOS_SCALAR
#define PyArray_INTNEG_SCALAR  NPY_INTNEG_SCALAR
#define PyArray_FLOAT_SCALAR   NPY_FLOAT_SCALAR
#define PyArray_COMPLEX_SCALAR NPY_COMPLEX_SCALAR
#define PyArray_OBJECT_SCALAR  NPY_OBJECT_SCALAR
#define PyArray_SCALARKIND     NPY_SCALARKIND
#define PyArray_NSCALARKINDS   NPY_NSCALARKINDS

#define PyArray_ANYORDER     NPY_ANYORDER
#define PyArray_CORDER       NPY_CORDER
#define PyArray_FORTRANORDER NPY_FORTRANORDER
#define PyArray_ORDER        NPY_ORDER

#define PyDescr_ISBOOL      PyDataType_ISBOOL
#define PyDescr_ISUNSIGNED  PyDataType_ISUNSIGNED
#define PyDescr_ISSIGNED    PyDataType_ISSIGNED
#define PyDescr_ISINTEGER   PyDataType_ISINTEGER
#define PyDescr_ISFLOAT     PyDataType_ISFLOAT
#define PyDescr_ISNUMBER    PyDataType_ISNUMBER
#define PyDescr_ISSTRING    PyDataType_ISSTRING
#define PyDescr_ISCOMPLEX   PyDataType_ISCOMPLEX
#define PyDescr_ISPYTHON    PyDataType_ISPYTHON
#define PyDescr_ISFLEXIBLE  PyDataType_ISFLEXIBLE
#define PyDescr_ISUSERDEF   PyDataType_ISUSERDEF
#define PyDescr_ISEXTENDED  PyDataType_ISEXTENDED
#define PyDescr_ISOBJECT    PyDataType_ISOBJECT
#define PyDescr_HASFIELDS   PyDataType_HASFIELDS

#define PyArray_LITTLE NPY_LITTLE
#define PyArray_BIG NPY_BIG
#define PyArray_NATIVE NPY_NATIVE
#define PyArray_SWAP NPY_SWAP
#define PyArray_IGNORE NPY_IGNORE

#define PyArray_NATBYTE NPY_NATBYTE
#define PyArray_OPPBYTE NPY_OPPBYTE

#define PyArray_MAX_ELSIZE NPY_MAX_ELSIZE

#define PyArray_USE_PYMEM NPY_USE_PYMEM

#define PyArray_RemoveLargest PyArray_RemoveSmallest

#define PyArray_UCS4 npy_ucs4

#endif
                                                                                                                                                                                                                                                                                                                                                              oldnumeric.h                                                                                        0100644 0001750 0001750 00000001250 12215056622 042411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #include "arrayobject.h"

#ifndef REFCOUNT
#  define REFCOUNT NPY_REFCOUNT
#  define MAX_ELSIZE 16
#endif

#define PyArray_UNSIGNED_TYPES
#define PyArray_SBYTE NPY_BYTE
#define PyArray_CopyArray PyArray_CopyInto
#define _PyArray_multiply_list PyArray_MultiplyIntList
#define PyArray_ISSPACESAVER(m) NPY_FALSE
#define PyScalarArray_Check PyArray_CheckScalar

#define CONTIGUOUS NPY_CONTIGUOUS
#define OWN_DIMENSIONS 0
#define OWN_STRIDES 0
#define OWN_DATA NPY_OWNDATA
#define SAVESPACE 0
#define SAVESPACEBIT 0

#undef import_array
#define import_array() { if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, "numpy.core.multiarray failed to import"); } }
                                                                                                                                                                                                                                                                                                                                                        ufuncobject.h                                                                                       0100644 0001750 0001750 00000040773 12215056644 042600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef Py_UFUNCOBJECT_H
#define Py_UFUNCOBJECT_H

#include <numpy/npy_math.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The legacy generic inner loop for a standard element-wise or
 * generalized ufunc.
 */
typedef void (*PyUFuncGenericFunction)
            (char **args,
             npy_intp *dimensions,
             npy_intp *strides,
             void *innerloopdata);

/*
 * The most generic one-dimensional inner loop for
 * a standard element-wise ufunc. This typedef is also
 * more consistent with the other NumPy function pointer typedefs
 * than PyUFuncGenericFunction.
 */
typedef void (PyUFunc_StridedInnerLoopFunc)(
                char **dataptrs, npy_intp *strides,
                npy_intp count,
                NpyAuxData *innerloopdata);

/*
 * The most generic one-dimensional inner loop for
 * a masked standard element-wise ufunc. "Masked" here means that it skips
 * doing calculations on any items for which the maskptr array has a true
 * value.
 */
typedef void (PyUFunc_MaskedStridedInnerLoopFunc)(
                char **dataptrs, npy_intp *strides,
                char *maskptr, npy_intp mask_stride,
                npy_intp count,
                NpyAuxData *innerloopdata);

/* Forward declaration for the type resolver and loop selector typedefs */
struct _tagPyUFuncObject;

/*
 * Given the operands for calling a ufunc, should determine the
 * calculation input and output data types and return an inner loop function.
 * This function should validate that the casting rule is being followed,
 * and fail if it is not.
 *
 * For backwards compatibility, the regular type resolution function does not
 * support auxiliary data with object semantics. The type resolution call
 * which returns a masked generic function returns a standard NpyAuxData
 * object, for which the NPY_AUXDATA_FREE and NPY_AUXDATA_CLONE macros
 * work.
 *
 * ufunc:             The ufunc object.
 * casting:           The 'casting' parameter provided to the ufunc.
 * operands:          An array of length (ufunc->nin + ufunc->nout),
 *                    with the output parameters possibly NULL.
 * type_tup:          Either NULL, or the type_tup passed to the ufunc.
 * out_dtypes:        An array which should be populated with new
 *                    references to (ufunc->nin + ufunc->nout) new
 *                    dtypes, one for each input and output. These
 *                    dtypes should all be in native-endian format.
 *
 * Should return 0 on success, -1 on failure (with exception set),
 * or -2 if Py_NotImplemented should be returned.
 */
typedef int (PyUFunc_TypeResolutionFunc)(
                                struct _tagPyUFuncObject *ufunc,
                                NPY_CASTING casting,
                                PyArrayObject **operands,
                                PyObject *type_tup,
                                PyArray_Descr **out_dtypes);

/*
 * Given an array of DTypes as returned by the PyUFunc_TypeResolutionFunc,
 * and an array of fixed strides (the array will contain NPY_MAX_INTP for
 * strides which are not necessarily fixed), returns an inner loop
 * with associated auxiliary data.
 *
 * For backwards compatibility, there is a variant of the inner loop
 * selection which returns an inner loop irrespective of the strides,
 * and with a void* static auxiliary data instead of an NpyAuxData *
 * dynamically allocatable auxiliary data.
 *
 * ufunc:             The ufunc object.
 * dtypes:            An array which has been populated with dtypes,
 *                    in most cases by the type resolution funciton
 *                    for the same ufunc.
 * fixed_strides:     For each input/output, either the stride that
 *                    will be used every time the function is called
 *                    or NPY_MAX_INTP if the stride might change or
 *                    is not known ahead of time. The loop selection
 *                    function may use this stride to pick inner loops
 *                    which are optimized for contiguous or 0-stride
 *                    cases.
 * out_innerloop:     Should be populated with the correct ufunc inner
 *                    loop for the given type.
 * out_innerloopdata: Should be populated with the void* data to
 *                    be passed into the out_innerloop function.
 * out_needs_api:     If the inner loop needs to use the Python API,
 *                    should set the to 1, otherwise should leave
 *                    this untouched.
 */
typedef int (PyUFunc_LegacyInnerLoopSelectionFunc)(
                            struct _tagPyUFuncObject *ufunc,
                            PyArray_Descr **dtypes,
                            PyUFuncGenericFunction *out_innerloop,
                            void **out_innerloopdata,
                            int *out_needs_api);
typedef int (PyUFunc_InnerLoopSelectionFunc)(
                            struct _tagPyUFuncObject *ufunc,
                            PyArray_Descr **dtypes,
                            npy_intp *fixed_strides,
                            PyUFunc_StridedInnerLoopFunc **out_innerloop,
                            NpyAuxData **out_innerloopdata,
                            int *out_needs_api);
typedef int (PyUFunc_MaskedInnerLoopSelectionFunc)(
                            struct _tagPyUFuncObject *ufunc,
                            PyArray_Descr **dtypes,
                            PyArray_Descr *mask_dtype,
                            npy_intp *fixed_strides,
                            npy_intp fixed_mask_stride,
                            PyUFunc_MaskedStridedInnerLoopFunc **out_innerloop,
                            NpyAuxData **out_innerloopdata,
                            int *out_needs_api);

typedef struct _tagPyUFuncObject {
        PyObject_HEAD
        /*
         * nin: Number of inputs
         * nout: Number of outputs
         * nargs: Always nin + nout (Why is it stored?)
         */
        int nin, nout, nargs;

        /* Identity for reduction, either PyUFunc_One or PyUFunc_Zero */
        int identity;

        /* Array of one-dimensional core loops */
        PyUFuncGenericFunction *functions;
        /* Array of funcdata that gets passed into the functions */
        void **data;
        /* The number of elements in 'functions' and 'data' */
        int ntypes;

        /* Does not appear to be used */
        int check_return;

        /* The name of the ufunc */
        char *name;

        /* Array of type numbers, of size ('nargs' * 'ntypes') */
        char *types;

        /* Documentation string */
        char *doc;

        void *ptr;
        PyObject *obj;
        PyObject *userloops;

        /* generalized ufunc parameters */

        /* 0 for scalar ufunc; 1 for generalized ufunc */
        int core_enabled;
        /* number of distinct dimension names in signature */
        int core_num_dim_ix;

        /*
         * dimension indices of input/output argument k are stored in
         * core_dim_ixs[core_offsets[k]..core_offsets[k]+core_num_dims[k]-1]
         */

        /* numbers of core dimensions of each argument */
        int *core_num_dims;
        /*
         * dimension indices in a flatted form; indices
         * are in the range of [0,core_num_dim_ix)
         */
        int *core_dim_ixs;
        /*
         * positions of 1st core dimensions of each
         * argument in core_dim_ixs
         */
        int *core_offsets;
        /* signature string for printing purpose */
        char *core_signature;

        /*
         * A function which resolves the types and fills an array
         * with the dtypes for the inputs and outputs.
         */
        PyUFunc_TypeResolutionFunc *type_resolver;
        /*
         * A function which returns an inner loop written for
         * NumPy 1.6 and earlier ufuncs. This is for backwards
         * compatibility, and may be NULL if inner_loop_selector
         * is specified.
         */
        PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector;
        /*
         * A function which returns an inner loop for the new mechanism
         * in NumPy 1.7 and later. If provided, this is used, otherwise
         * if NULL the legacy_inner_loop_selector is used instead.
         */
        PyUFunc_InnerLoopSelectionFunc *inner_loop_selector;
        /*
         * A function which returns a masked inner loop for the ufunc.
         */
        PyUFunc_MaskedInnerLoopSelectionFunc *masked_inner_loop_selector;

        /*
         * List of flags for each operand when ufunc is called by nditer object.
         * These flags will be used in addition to the default flags for each
         * operand set by nditer object.
         */
        npy_uint32 *op_flags;

        /*
         * List of global flags used when ufunc is called by nditer object.
         * These flags will be used in addition to the default global flags
         * set by nditer object.
         */
        npy_uint32 iter_flags;
} PyUFuncObject;

#include "arrayobject.h"

#define UFUNC_ERR_IGNORE 0
#define UFUNC_ERR_WARN   1
#define UFUNC_ERR_RAISE  2
#define UFUNC_ERR_CALL   3
#define UFUNC_ERR_PRINT  4
#define UFUNC_ERR_LOG    5

        /* Python side integer mask */

#define UFUNC_MASK_DIVIDEBYZERO 0x07
#define UFUNC_MASK_OVERFLOW 0x3f
#define UFUNC_MASK_UNDERFLOW 0x1ff
#define UFUNC_MASK_INVALID 0xfff

#define UFUNC_SHIFT_DIVIDEBYZERO 0
#define UFUNC_SHIFT_OVERFLOW     3
#define UFUNC_SHIFT_UNDERFLOW    6
#define UFUNC_SHIFT_INVALID      9


/* platform-dependent code translates floating point
   status to an integer sum of these values
*/
#define UFUNC_FPE_DIVIDEBYZERO  1
#define UFUNC_FPE_OVERFLOW      2
#define UFUNC_FPE_UNDERFLOW     4
#define UFUNC_FPE_INVALID       8

/* Error mode that avoids look-up (no checking) */
#define UFUNC_ERR_DEFAULT       0

#define UFUNC_OBJ_ISOBJECT      1
#define UFUNC_OBJ_NEEDS_API     2

   /* Default user error mode */
#define UFUNC_ERR_DEFAULT2                               \
        (UFUNC_ERR_WARN << UFUNC_SHIFT_DIVIDEBYZERO) +  \
        (UFUNC_ERR_WARN << UFUNC_SHIFT_OVERFLOW) +      \
        (UFUNC_ERR_WARN << UFUNC_SHIFT_INVALID)

#if NPY_ALLOW_THREADS
#define NPY_LOOP_BEGIN_THREADS do {if (!(loop->obj & UFUNC_OBJ_NEEDS_API)) _save = PyEval_SaveThread();} while (0);
#define NPY_LOOP_END_THREADS   do {if (!(loop->obj & UFUNC_OBJ_NEEDS_API)) PyEval_RestoreThread(_save);} while (0);
#else
#define NPY_LOOP_BEGIN_THREADS
#define NPY_LOOP_END_THREADS
#endif

/*
 * UFunc has unit of 1, and the order of operations can be reordered
 * This case allows reduction with multiple axes at once.
 */
#define PyUFunc_One 1
/*
 * UFunc has unit of 0, and the order of operations can be reordered
 * This case allows reduction with multiple axes at once.
 */
#define PyUFunc_Zero 0
/*
 * UFunc has no unit, and the order of operations cannot be reordered.
 * This case does not allow reduction with multiple axes at once.
 */
#define PyUFunc_None -1
/*
 * UFunc has no unit, and the order of operations can be reordered
 * This case allows reduction with multiple axes at once.
 */
#define PyUFunc_ReorderableNone -2

#define UFUNC_REDUCE 0
#define UFUNC_ACCUMULATE 1
#define UFUNC_REDUCEAT 2
#define UFUNC_OUTER 3


typedef struct {
        int nin;
        int nout;
        PyObject *callable;
} PyUFunc_PyFuncData;

/* A linked-list of function information for
   user-defined 1-d loops.
 */
typedef struct _loop1d_info {
        PyUFuncGenericFunction func;
        void *data;
        int *arg_types;
        struct _loop1d_info *next;
        int nargs;
        PyArray_Descr **arg_dtypes;
} PyUFunc_Loop1d;


#include "__ufunc_api.h"

#define UFUNC_PYVALS_NAME "UFUNC_PYVALS"

#define UFUNC_CHECK_ERROR(arg) \
        do {if ((((arg)->obj & UFUNC_OBJ_NEEDS_API) && PyErr_Occurred()) || \
            ((arg)->errormask && \
             PyUFunc_checkfperr((arg)->errormask, \
                                (arg)->errobj, \
                                &(arg)->first))) \
                goto fail;} while (0)

/* This code checks the IEEE status flags in a platform-dependent way */
/* Adapted from Numarray  */

#if (defined(__unix__) || defined(unix)) && !defined(USG)
#include <sys/param.h>
#endif

/*  OSF/Alpha (Tru64)  ---------------------------------------------*/
#if defined(__osf__) && defined(__alpha)

#include <machine/fpu.h>

#define UFUNC_CHECK_STATUS(ret) { \
        unsigned long fpstatus; \
         \
        fpstatus = ieee_get_fp_control(); \
        /* clear status bits as well as disable exception mode if on */ \
        ieee_set_fp_control( 0 ); \
        ret = ((IEEE_STATUS_DZE & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((IEEE_STATUS_OVF & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
                | ((IEEE_STATUS_UNF & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((IEEE_STATUS_INV & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        }

/* MS Windows -----------------------------------------------------*/
#elif defined(_MSC_VER)

#include <float.h>

/* Clear the floating point exception default of Borland C++ */
#if defined(__BORLANDC__)
#define UFUNC_NOFPE _control87(MCW_EM, MCW_EM);
#endif

#if defined(_WIN64)
#define UFUNC_CHECK_STATUS(ret) { \
        int fpstatus = (int) _clearfp(); \
         \
        ret = ((SW_ZERODIVIDE & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((SW_OVERFLOW & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
                | ((SW_UNDERFLOW & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((SW_INVALID & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        }
#else
/* windows enables sse on 32 bit, so check both flags */
#define UFUNC_CHECK_STATUS(ret) { \
        int fpstatus, fpstatus2; \
        _statusfp2(&fpstatus, &fpstatus2); \
        _clearfp(); \
        fpstatus |= fpstatus2; \
         \
        ret = ((SW_ZERODIVIDE & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((SW_OVERFLOW & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
                | ((SW_UNDERFLOW & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((SW_INVALID & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        }
#endif

/* Solaris --------------------------------------------------------*/
/* --------ignoring SunOS ieee_flags approach, someone else can
**         deal with that! */
#elif defined(sun) || defined(__BSD__) || defined(__OpenBSD__) || \
      (defined(__FreeBSD__) && (__FreeBSD_version < 502114)) || \
      defined(__NetBSD__)
#include <ieeefp.h>

#define UFUNC_CHECK_STATUS(ret) { \
        int fpstatus; \
         \
        fpstatus = (int) fpgetsticky(); \
        ret = ((FP_X_DZ  & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((FP_X_OFL & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
                | ((FP_X_UFL & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((FP_X_INV & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        (void) fpsetsticky(0); \
        }

#elif defined(__GLIBC__) || defined(__APPLE__) || \
      defined(__CYGWIN__) || defined(__MINGW32__) || \
      (defined(__FreeBSD__) && (__FreeBSD_version >= 502114))

#if defined(__GLIBC__) || defined(__APPLE__) || \
    defined(__MINGW32__) || defined(__FreeBSD__)
#include <fenv.h>
#elif defined(__CYGWIN__)
#include "numpy/fenv/fenv.h"
#endif

#define UFUNC_CHECK_STATUS(ret) { \
        int fpstatus = (int) fetestexcept(FE_DIVBYZERO | FE_OVERFLOW | \
                                          FE_UNDERFLOW | FE_INVALID); \
        ret = ((FE_DIVBYZERO  & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((FE_OVERFLOW   & fpstatus) ? UFUNC_FPE_OVERFLOW : 0) \
                | ((FE_UNDERFLOW  & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((FE_INVALID    & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        (void) feclearexcept(FE_DIVBYZERO | FE_OVERFLOW | \
                             FE_UNDERFLOW | FE_INVALID); \
}

#elif defined(_AIX)

#include <float.h>
#include <fpxcp.h>

#define UFUNC_CHECK_STATUS(ret) { \
        fpflag_t fpstatus; \
 \
        fpstatus = fp_read_flag(); \
        ret = ((FP_DIV_BY_ZERO & fpstatus) ? UFUNC_FPE_DIVIDEBYZERO : 0) \
                | ((FP_OVERFLOW & fpstatus) ? UFUNC_FPE_OVERFLOW : 0)   \
                | ((FP_UNDERFLOW & fpstatus) ? UFUNC_FPE_UNDERFLOW : 0) \
                | ((FP_INVALID & fpstatus) ? UFUNC_FPE_INVALID : 0); \
        fp_swap_flag(0); \
}

#else

#define NO_FLOATING_POINT_SUPPORT
#define UFUNC_CHECK_STATUS(ret) { \
    ret = 0; \
  }

#endif

/*
 * THESE MACROS ARE DEPRECATED.
 * Use npy_set_floatstatus_* in the npymath library.
 */
#define generate_divbyzero_error() npy_set_floatstatus_divbyzero()
#define generate_overflow_error() npy_set_floatstatus_overflow()

  /* Make sure it gets defined if it isn't already */
#ifndef UFUNC_NOFPE
#define UFUNC_NOFPE
#endif


#ifdef __cplusplus
}
#endif
#endif /* !Py_UFUNCOBJECT_H */
     utils.h                                                                                             0100644 0001750 0001750 00000001164 11777322264 041426  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/core/include/numpy                                 #ifndef __NUMPY_UTILS_HEADER__
#define __NUMPY_UTILS_HEADER__

#ifndef __COMP_NPY_UNUSED
        #if defined(__GNUC__)
                #define __COMP_NPY_UNUSED __attribute__ ((__unused__))
        # elif defined(__ICC)
                #define __COMP_NPY_UNUSED __attribute__ ((__unused__))
        #else
                #define __COMP_NPY_UNUSED
        #endif
#endif

/* Use this to tag a variable as not used. It will remove unused variable
 * warning on support platforms (see __COM_NPY_UNUSED) and mangle the variable
 * to avoid accidental use */
#define NPY_UNUSED(x) (__NPY_UNUSED_TAGGED ## x) __COMP_NPY_UNUSED

#endif
                                                                                                                                                                                                                                                                                                                                                                                                            distutils/                                                                                          0040755 0001750 0001750 00000000000 12612224744 036410  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy                                                    tests/                                                                                              0040755 0001750 0001750 00000000000 12612224744 037552  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/distutils                                          swig_ext/                                                                                           0040755 0001750 0001750 00000000000 12612224744 041403  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/distutils/tests                                    src/                                                                                                0040755 0001750 0001750 00000000000 12612224744 042172  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/distutils/tests/swig_ext                           zoo.h                                                                                               0100644 0001750 0001750 00000000161 11472145622 043145  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/distutils/tests/swig_ext/src                       
class Zoo{
		int n;
		char animals[10][50];
public:
		Zoo();
		void shut_up(char *animal);
		void display();
};
                                                                                                                                                                                                                                                                                                                                                                                                               f2py/                                                                                               0040755 0001750 0001750 00000000000 12612224744 035244  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy                                                    src/                                                                                                0040755 0001750 0001750 00000000000 12612224744 036033  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/f2py                                               fortranobject.h                                                                                     0100644 0001750 0001750 00000011256 12215056645 041052  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/f2py/src                                           #ifndef Py_FORTRANOBJECT_H
#define Py_FORTRANOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

#include "Python.h"

#ifdef FORTRANOBJECT_C
#define NO_IMPORT_ARRAY
#endif
#define PY_ARRAY_UNIQUE_SYMBOL _npy_f2py_ARRAY_API
#include "numpy/arrayobject.h"

/*
 * Python 3 support macros
 */
#if PY_VERSION_HEX >= 0x03000000
#define PyString_Check PyBytes_Check
#define PyString_GET_SIZE PyBytes_GET_SIZE
#define PyString_AS_STRING PyBytes_AS_STRING
#define PyString_FromString PyBytes_FromString
#define PyString_ConcatAndDel PyBytes_ConcatAndDel
#define PyString_AsString PyBytes_AsString

#define PyInt_Check PyLong_Check
#define PyInt_FromLong PyLong_FromLong
#define PyInt_AS_LONG PyLong_AsLong
#define PyInt_AsLong PyLong_AsLong

#define PyNumber_Int PyNumber_Long
#endif


#ifdef F2PY_REPORT_ATEXIT
#include <sys/timeb.h>
  extern void f2py_start_clock(void);
  extern void f2py_stop_clock(void);
  extern void f2py_start_call_clock(void);
  extern void f2py_stop_call_clock(void);
  extern void f2py_cb_start_clock(void);
  extern void f2py_cb_stop_clock(void);
  extern void f2py_cb_start_call_clock(void);
  extern void f2py_cb_stop_call_clock(void);
  extern void f2py_report_on_exit(int,void*);
#endif

#ifdef DMALLOC
#include "dmalloc.h"
#endif

/* Fortran object interface */

/*
123456789-123456789-123456789-123456789-123456789-123456789-123456789-12

PyFortranObject represents various Fortran objects:
Fortran (module) routines, COMMON blocks, module data.

Author: Pearu Peterson <pearu@cens.ioc.ee>
*/

#define F2PY_MAX_DIMS 40

typedef void (*f2py_set_data_func)(char*,npy_intp*);
typedef void (*f2py_void_func)(void);
typedef void (*f2py_init_func)(int*,npy_intp*,f2py_set_data_func,int*);

  /*typedef void* (*f2py_c_func)(void*,...);*/

typedef void *(*f2pycfunc)(void);

typedef struct {
  char *name;                /* attribute (array||routine) name */
  int rank;                  /* array rank, 0 for scalar, max is F2PY_MAX_DIMS,
				|| rank=-1 for Fortran routine */
  struct {npy_intp d[F2PY_MAX_DIMS];} dims; /* dimensions of the array, || not used */
  int type;                  /* PyArray_<type> || not used */
  char *data;                /* pointer to array || Fortran routine */
  f2py_init_func func;            /* initialization function for
				allocatable arrays:
				func(&rank,dims,set_ptr_func,name,len(name))
				|| C/API wrapper for Fortran routine */
  char *doc;                 /* documentation string; only recommended
				for routines. */
} FortranDataDef;

typedef struct {
  PyObject_HEAD
  int len;                   /* Number of attributes */
  FortranDataDef *defs;      /* An array of FortranDataDef's */
  PyObject       *dict;      /* Fortran object attribute dictionary */
} PyFortranObject;

#define PyFortran_Check(op) (Py_TYPE(op) == &PyFortran_Type)
#define PyFortran_Check1(op) (0==strcmp(Py_TYPE(op)->tp_name,"fortran"))

  extern PyTypeObject PyFortran_Type;
  extern int F2PyDict_SetItemString(PyObject* dict, char *name, PyObject *obj);
  extern PyObject * PyFortranObject_New(FortranDataDef* defs, f2py_void_func init);
  extern PyObject * PyFortranObject_NewAsAttr(FortranDataDef* defs);

#if PY_VERSION_HEX >= 0x03000000

PyObject * F2PyCapsule_FromVoidPtr(void *ptr, void (*dtor)(PyObject *));
void * F2PyCapsule_AsVoidPtr(PyObject *obj);
int F2PyCapsule_Check(PyObject *ptr);

#else

PyObject * F2PyCapsule_FromVoidPtr(void *ptr, void (*dtor)(void *));
void * F2PyCapsule_AsVoidPtr(PyObject *ptr);
int F2PyCapsule_Check(PyObject *ptr);

#endif

#define ISCONTIGUOUS(m) ((m)->flags & NPY_CONTIGUOUS)
#define F2PY_INTENT_IN 1
#define F2PY_INTENT_INOUT 2
#define F2PY_INTENT_OUT 4
#define F2PY_INTENT_HIDE 8
#define F2PY_INTENT_CACHE 16
#define F2PY_INTENT_COPY 32
#define F2PY_INTENT_C 64
#define F2PY_OPTIONAL 128
#define F2PY_INTENT_INPLACE 256
#define F2PY_INTENT_ALIGNED4 512
#define F2PY_INTENT_ALIGNED8 1024
#define F2PY_INTENT_ALIGNED16 2048

#define ARRAY_ISALIGNED(ARR, SIZE) ((size_t)(PyArray_DATA(ARR)) % (SIZE) == 0)
#define F2PY_ALIGN4(intent) (intent & F2PY_INTENT_ALIGNED4)
#define F2PY_ALIGN8(intent) (intent & F2PY_INTENT_ALIGNED8)
#define F2PY_ALIGN16(intent) (intent & F2PY_INTENT_ALIGNED16)

#define F2PY_GET_ALIGNMENT(intent) \
	(F2PY_ALIGN4(intent) ? 4 : \
	 (F2PY_ALIGN8(intent) ? 8 : \
	  (F2PY_ALIGN16(intent) ? 16 : 1) ))
#define F2PY_CHECK_ALIGNMENT(arr, intent) ARRAY_ISALIGNED(arr, F2PY_GET_ALIGNMENT(intent))

  extern PyArrayObject* array_from_pyobj(const int type_num,
					 npy_intp *dims,
					 const int rank,
					 const int intent,
					 PyObject *obj);
  extern int copy_ND_array(const PyArrayObject *in, PyArrayObject *out);

#ifdef DEBUG_COPY_ND_ARRAY
  extern void dump_attrs(const PyArrayObject* arr);
#endif


#ifdef __cplusplus
}
#endif
#endif /* !Py_FORTRANOBJECT_H */
                                                                                                                                                                                                                                                                                                                                                  numarray/                                                                                           0040755 0001750 0001750 00000000000 12612224744 036222  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy                                                    include/                                                                                            0040755 0001750 0001750 00000000000 12612224744 037645  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray                                           numpy/                                                                                              0040755 0001750 0001750 00000000000 12612224744 041015  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include                                   arraybase.h                                                                                         0100644 0001750 0001750 00000003104 12222104616 043122  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             #if !defined(__arraybase_h)
#define _arraybase_h 1

#define SZ_BUF  79
#define MAXDIM NPY_MAXDIMS
#define MAXARGS 18

typedef npy_intp maybelong;
typedef npy_bool Bool;
typedef npy_int8 Int8;
typedef npy_uint8 UInt8;
typedef npy_int16 Int16;
typedef npy_uint16 UInt16;
typedef npy_int32 Int32;
typedef npy_uint32 UInt32;
typedef npy_int64 Int64;
typedef npy_uint64 UInt64;
typedef npy_float32 Float32;
typedef npy_float64 Float64;

typedef enum
{
  tAny = -1,
  tBool = NPY_BOOL,
  tInt8 = NPY_INT8,
  tUInt8 = NPY_UINT8,
  tInt16 = NPY_INT16,
  tUInt16 = NPY_UINT16,
  tInt32 = NPY_INT32,
  tUInt32 = NPY_UINT32,
  tInt64 = NPY_INT64,
  tUInt64 = NPY_UINT64,
  tFloat32 = NPY_FLOAT32,
  tFloat64 = NPY_FLOAT64,
  tComplex32 = NPY_COMPLEX64,
  tComplex64 = NPY_COMPLEX128,
  tObject = NPY_OBJECT,        /* placeholder... does nothing */
  tMaxType = NPY_NTYPES,
  tDefault = tFloat64,
#if NPY_BITSOF_LONG == 64
  tLong = tInt64,
#else
  tLong = tInt32,
#endif
} NumarrayType;

#define nNumarrayType PyArray_NTYPES

#define HAS_UINT64 1

typedef enum
{
        NUM_LITTLE_ENDIAN=0,
        NUM_BIG_ENDIAN = 1
} NumarrayByteOrder;

typedef struct { Float32 r, i; } Complex32;
typedef struct { Float64 r, i; } Complex64;

#define WRITABLE NPY_WRITEABLE
#define CHECKOVERFLOW 0x800
#define UPDATEDICT 0x1000
#define FORTRAN_CONTIGUOUS NPY_FORTRAN
#define IS_CARRAY (NPY_CONTIGUOUS | NPY_ALIGNED)

#define PyArray(m)                      ((PyArrayObject *)(m))
#define PyArray_ISFORTRAN_CONTIGUOUS(m) (((PyArray(m))->flags & FORTRAN_CONTIGUOUS) != 0)
#define PyArray_ISWRITABLE  PyArray_ISWRITEABLE


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                            cfunc.h                                                                                             0100644 0001750 0001750 00000005775 12222104616 042267  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             #if !defined(__cfunc__)
#define __cfunc__ 1

typedef PyObject *(*CFUNCasPyValue)(void *);
typedef int (*UFUNC)(long, long, long, void **, long*);
/* typedef void (*CFUNC_2ARG)(long, void *, void *); */
/* typedef void (*CFUNC_3ARG)(long, void *, void *, void *); */
typedef int (*CFUNCfromPyValue)(PyObject *, void *);
typedef int (*CFUNC_STRIDE_CONV_FUNC)(long, long, maybelong *,
	      void *, long, maybelong*, void *, long, maybelong *);

typedef int (*CFUNC_STRIDED_FUNC)(PyObject *, long, PyArrayObject **,
				  char **data);

#define MAXARRAYS 16

typedef enum {
	CFUNC_UFUNC,
	CFUNC_STRIDING,
	CFUNC_NSTRIDING,
	CFUNC_AS_PY_VALUE,
	CFUNC_FROM_PY_VALUE
} eCfuncType;

typedef struct {
	char *name;
        void *fptr;            /* Pointer to "un-wrapped" c function */
	eCfuncType type;       /* UFUNC, STRIDING, AsPyValue, FromPyValue */
	Bool chkself;          /* CFUNC does own alignment/bounds checking */
	Bool align;            /* CFUNC requires aligned buffer pointers */
	Int8 wantIn, wantOut;  /* required input/output arg counts. */
	Int8 sizes[MAXARRAYS]; /* array of align/itemsizes. */
	Int8 iters[MAXARRAYS]; /*  array of element counts. 0 --> niter. */
} CfuncDescriptor;

typedef struct {
    PyObject_HEAD
    CfuncDescriptor descr;
} CfuncObject;

#define SELF_CHECKED_CFUNC_DESCR(name, type)                                 \
   static CfuncDescriptor name##_descr = { #name, (void *) name, type, 1 }

#define CHECK_ALIGN 1

#define CFUNC_DESCR(name, type, align, iargs, oargs, s1, s2, s3, i1, i2, i3)  \
  static CfuncDescriptor name##_descr =                                       \
    { #name, (void *)name, type, 0, align, iargs, oargs, {s1, s2, s3}, {i1, i2, i3} }

#define UFUNC_DESCR1(name, s1)                                                \
   CFUNC_DESCR(name, CFUNC_UFUNC, CHECK_ALIGN, 0, 1, s1, 0, 0, 0, 0, 0)

#define UFUNC_DESCR2(name, s1, s2)                                            \
   CFUNC_DESCR(name, CFUNC_UFUNC, CHECK_ALIGN, 1, 1, s1, s2, 0, 0, 0, 0)

#define UFUNC_DESCR3(name, s1, s2, s3)                                        \
   CFUNC_DESCR(name, CFUNC_UFUNC, CHECK_ALIGN, 2, 1, s1, s2, s3, 0, 0, 0)

#define UFUNC_DESCR3sv(name, s1, s2, s3)                                      \
   CFUNC_DESCR(name, CFUNC_UFUNC, CHECK_ALIGN, 2, 1, s1, s2, s3, 1, 0, 0)

#define UFUNC_DESCR3vs(name, s1, s2, s3)                                      \
   CFUNC_DESCR(name, CFUNC_UFUNC, CHECK_ALIGN, 2, 1, s1, s2, s3, 0, 1, 0)

#define STRIDING_DESCR2(name, align, s1, s2)                                  \
   CFUNC_DESCR(name, CFUNC_STRIDING, align, 1, 1, s1, s2, 0, 0, 0, 0)

#define NSTRIDING_DESCR1(name)                                                \
   CFUNC_DESCR(name, CFUNC_NSTRIDING, 0, 0, 1, 0, 0, 0, 0, 0, 0)

#define NSTRIDING_DESCR2(name)                                                \
   CFUNC_DESCR(name, CFUNC_NSTRIDING, 0, 1, 1, 0, 0, 0, 0, 0, 0)

#define NSTRIDING_DESCR3(name)                                                \
   CFUNC_DESCR(name, CFUNC_NSTRIDING, 0, 2, 1, 0, 0, 0, 0, 0, 0)

#endif
   ieeespecial.h                                                                                       0100644 0001750 0001750 00000007263 12222104616 043433  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             /* 32-bit special value ranges */

#if defined(_MSC_VER)
#define MKINT(x) (x##UL)
#define MKINT64(x) (x##Ui64)
#define BIT(x) (1Ui64 << (x))
#else
#define MKINT(x) (x##U)
#define MKINT64(x) (x##ULL)
#define BIT(x) (1ULL << (x))
#endif


#define NEG_QUIET_NAN_MIN32    MKINT(0xFFC00001)
#define NEG_QUIET_NAN_MAX32    MKINT(0xFFFFFFFF)

#define INDETERMINATE_MIN32    MKINT(0xFFC00000)
#define INDETERMINATE_MAX32    MKINT(0xFFC00000)

#define NEG_SIGNAL_NAN_MIN32   MKINT(0xFF800001)
#define NEG_SIGNAL_NAN_MAX32   MKINT(0xFFBFFFFF)

#define NEG_INFINITY_MIN32     MKINT(0xFF800000)

#define NEG_NORMALIZED_MIN32   MKINT(0x80800000)
#define NEG_NORMALIZED_MAX32   MKINT(0xFF7FFFFF)

#define NEG_DENORMALIZED_MIN32 MKINT(0x80000001)
#define NEG_DENORMALIZED_MAX32 MKINT(0x807FFFFF)

#define NEG_ZERO_MIN32         MKINT(0x80000000)
#define NEG_ZERO_MAX32         MKINT(0x80000000)

#define POS_ZERO_MIN32         MKINT(0x00000000)
#define POS_ZERO_MAX32         MKINT(0x00000000)

#define POS_DENORMALIZED_MIN32 MKINT(0x00000001)
#define POS_DENORMALIZED_MAX32 MKINT(0x007FFFFF)

#define POS_NORMALIZED_MIN32   MKINT(0x00800000)
#define POS_NORMALIZED_MAX32   MKINT(0x7F7FFFFF)

#define POS_INFINITY_MIN32     MKINT(0x7F800000)
#define POS_INFINITY_MAX32     MKINT(0x7F800000)

#define POS_SIGNAL_NAN_MIN32   MKINT(0x7F800001)
#define POS_SIGNAL_NAN_MAX32   MKINT(0x7FBFFFFF)

#define POS_QUIET_NAN_MIN32    MKINT(0x7FC00000)
#define POS_QUIET_NAN_MAX32    MKINT(0x7FFFFFFF)

/* 64-bit special value ranges */

#define NEG_QUIET_NAN_MIN64    MKINT64(0xFFF8000000000001)
#define NEG_QUIET_NAN_MAX64    MKINT64(0xFFFFFFFFFFFFFFFF)

#define INDETERMINATE_MIN64    MKINT64(0xFFF8000000000000)
#define INDETERMINATE_MAX64    MKINT64(0xFFF8000000000000)

#define NEG_SIGNAL_NAN_MIN64   MKINT64(0xFFF7FFFFFFFFFFFF)
#define NEG_SIGNAL_NAN_MAX64   MKINT64(0xFFF0000000000001)

#define NEG_INFINITY_MIN64     MKINT64(0xFFF0000000000000)

#define NEG_NORMALIZED_MIN64   MKINT64(0xFFEFFFFFFFFFFFFF)
#define NEG_NORMALIZED_MAX64   MKINT64(0x8010000000000000)

#define NEG_DENORMALIZED_MIN64 MKINT64(0x800FFFFFFFFFFFFF)
#define NEG_DENORMALIZED_MAX64 MKINT64(0x8000000000000001)

#define NEG_ZERO_MIN64         MKINT64(0x8000000000000000)
#define NEG_ZERO_MAX64         MKINT64(0x8000000000000000)

#define POS_ZERO_MIN64         MKINT64(0x0000000000000000)
#define POS_ZERO_MAX64         MKINT64(0x0000000000000000)

#define POS_DENORMALIZED_MIN64 MKINT64(0x0000000000000001)
#define POS_DENORMALIZED_MAX64 MKINT64(0x000FFFFFFFFFFFFF)

#define POS_NORMALIZED_MIN64   MKINT64(0x0010000000000000)
#define POS_NORMALIZED_MAX64   MKINT64(0x7FEFFFFFFFFFFFFF)

#define POS_INFINITY_MIN64     MKINT64(0x7FF0000000000000)
#define POS_INFINITY_MAX64     MKINT64(0x7FF0000000000000)

#define POS_SIGNAL_NAN_MIN64   MKINT64(0x7FF0000000000001)
#define POS_SIGNAL_NAN_MAX64   MKINT64(0x7FF7FFFFFFFFFFFF)

#define POS_QUIET_NAN_MIN64    MKINT64(0x7FF8000000000000)
#define POS_QUIET_NAN_MAX64    MKINT64(0x7FFFFFFFFFFFFFFF)

typedef enum
{
	POS_QNAN_BIT,
	NEG_QNAN_BIT,
	POS_SNAN_BIT,
	NEG_SNAN_BIT,
	POS_INF_BIT,
	NEG_INF_BIT,
	POS_DEN_BIT,
	NEG_DEN_BIT,
	POS_NOR_BIT,
	NEG_NOR_BIT,
	POS_ZERO_BIT,
	NEG_ZERO_BIT,
	INDETERM_BIT,
	BUG_BIT
} ieee_selects;

#define MSK_POS_QNAN BIT(POS_QNAN_BIT)
#define MSK_POS_SNAN BIT(POS_SNAN_BIT)
#define MSK_POS_INF  BIT(POS_INF_BIT)
#define MSK_POS_DEN  BIT(POS_DEN_BIT)
#define MSK_POS_NOR  BIT(POS_NOR_BIT)
#define MSK_POS_ZERO BIT(POS_ZERO_BIT)
#define MSK_NEG_QNAN BIT(NEG_QNAN_BIT)
#define MSK_NEG_SNAN BIT(NEG_SNAN_BIT)
#define MSK_NEG_INF  BIT(NEG_INF_BIT)
#define MSK_NEG_DEN  BIT(NEG_DEN_BIT)
#define MSK_NEG_NOR  BIT(NEG_NOR_BIT)
#define MSK_NEG_ZERO BIT(NEG_ZERO_BIT)
#define MSK_INDETERM BIT(INDETERM_BIT)
#define MSK_BUG      BIT(BUG_BIT)
                                                                                                                                                                                                                                                                                                                                             libnumarray.h                                                                                       0100644 0001750 0001750 00000113116 12222104616 043503  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             /* Compatibility with numarray.  Do not use in new code.
 */

#ifndef NUMPY_LIBNUMARRAY_H
#define NUMPY_LIBNUMARRAY_H

#include "numpy/arrayobject.h"
#include "arraybase.h"
#include "nummacro.h"
#include "numcomplex.h"
#include "ieeespecial.h"
#include "cfunc.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Header file for libnumarray */

#if !defined(_libnumarray_MODULE)

/*
Extensions constructed from seperate compilation units can access the
C-API defined here by defining "libnumarray_UNIQUE_SYMBOL" to a global
name unique to the extension.  Doing this circumvents the requirement
to import libnumarray into each compilation unit, but is nevertheless
mildly discouraged as "outside the Python norm" and potentially
leading to problems.  Looking around at "existing Python art", most
extension modules are monolithic C files, and likely for good reason.
*/

/* C API address pointer */
#if defined(NO_IMPORT) || defined(NO_IMPORT_ARRAY)
extern void **libnumarray_API;
#else
#if defined(libnumarray_UNIQUE_SYMBOL)
void **libnumarray_API;
#else
static void **libnumarray_API;
#endif
#endif

#if PY_VERSION_HEX >= 0x03000000
#define _import_libnumarray()                                                    \
        {                                                                        \
        PyObject *module = PyImport_ImportModule("numpy.numarray._capi");        \
        if (module != NULL) {                                                    \
          PyObject *module_dict = PyModule_GetDict(module);                      \
          PyObject *c_api_object =                                               \
                 PyDict_GetItemString(module_dict, "_C_API");                    \
          if (c_api_object && PyCapsule_CheckExact(c_api_object)) {              \
            libnumarray_API = (void **)PyCapsule_GetPointer(c_api_object, NULL); \
          } else {                                                               \
            PyErr_Format(PyExc_ImportError,                                      \
                         "Can't get API for module 'numpy.numarray._capi'");     \
          }                                                                      \
        }                                                                        \
      }

#else
#define _import_libnumarray()                                                   \
        {                                                                       \
        PyObject *module = PyImport_ImportModule("numpy.numarray._capi");       \
        if (module != NULL) {                                                   \
          PyObject *module_dict = PyModule_GetDict(module);                     \
          PyObject *c_api_object =                                              \
                 PyDict_GetItemString(module_dict, "_C_API");                   \
          if (c_api_object && PyCObject_Check(c_api_object)) {                  \
            libnumarray_API = (void **)PyCObject_AsVoidPtr(c_api_object);       \
          } else {                                                              \
            PyErr_Format(PyExc_ImportError,                                     \
                         "Can't get API for module 'numpy.numarray._capi'");    \
          }                                                                     \
        }                                                                       \
      }
#endif

#define import_libnumarray() _import_libnumarray(); if (PyErr_Occurred()) { PyErr_Print(); PyErr_SetString(PyExc_ImportError, "numpy.numarray._capi failed to import.\n"); return; }

#endif


#define libnumarray_FatalApiError (Py_FatalError("Call to API function without first calling import_libnumarray() in " __FILE__), NULL)


/* Macros defining components of function prototypes */

#ifdef _libnumarray_MODULE
  /* This section is used when compiling libnumarray */

static PyObject *_Error;

static PyObject*  getBuffer  (PyObject*o);

static int  isBuffer  (PyObject*o);

static int  getWriteBufferDataPtr  (PyObject*o,void**p);

static int  isBufferWriteable  (PyObject*o);

static int  getReadBufferDataPtr  (PyObject*o,void**p);

static int  getBufferSize  (PyObject*o);

static double  num_log  (double x);

static double  num_log10  (double x);

static double  num_pow  (double x, double y);

static double  num_acosh  (double x);

static double  num_asinh  (double x);

static double  num_atanh  (double x);

static double  num_round  (double x);

static int  int_dividebyzero_error  (long value, long unused);

static int  int_overflow_error  (Float64 value);

static int  umult64_overflow  (UInt64 a, UInt64 b);

static int  smult64_overflow  (Int64 a0, Int64 b0);

static void  NA_Done  (void);

static PyArrayObject*  NA_NewAll  (int ndim, maybelong* shape, NumarrayType type, void* buffer, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable);

static PyArrayObject*  NA_NewAllStrides  (int ndim, maybelong* shape, maybelong* strides, NumarrayType type, void* buffer, maybelong byteoffset, int byteorder, int aligned, int writeable);

static PyArrayObject*  NA_New  (void* buffer, NumarrayType type, int ndim,...);

static PyArrayObject*  NA_Empty  (int ndim, maybelong* shape, NumarrayType type);

static PyArrayObject*  NA_NewArray  (void* buffer, NumarrayType type, int ndim, ...);

static PyArrayObject*  NA_vNewArray  (void* buffer, NumarrayType type, int ndim, maybelong *shape);

static PyObject*  NA_ReturnOutput  (PyObject*,PyArrayObject*);

static long  NA_getBufferPtrAndSize  (PyObject*,int,void**);

static int  NA_checkIo  (char*,int,int,int,int);

static int  NA_checkOneCBuffer  (char*,long,void*,long,size_t);

static int  NA_checkNCBuffers  (char*,int,long,void**,long*,Int8*,Int8*);

static int  NA_checkOneStriding  (char*,long,maybelong*,long,maybelong*,long,long,int);

static PyObject*  NA_new_cfunc  (CfuncDescriptor*);

static int  NA_add_cfunc  (PyObject*,char*,CfuncDescriptor*);

static PyArrayObject*  NA_InputArray  (PyObject*,NumarrayType,int);

static PyArrayObject*  NA_OutputArray  (PyObject*,NumarrayType,int);

static PyArrayObject*  NA_IoArray  (PyObject*,NumarrayType,int);

static PyArrayObject*  NA_OptionalOutputArray  (PyObject*,NumarrayType,int,PyArrayObject*);

static long  NA_get_offset  (PyArrayObject*,int,...);

static Float64  NA_get_Float64  (PyArrayObject*,long);

static void  NA_set_Float64  (PyArrayObject*,long,Float64);

static Complex64  NA_get_Complex64  (PyArrayObject*,long);

static void  NA_set_Complex64  (PyArrayObject*,long,Complex64);

static Int64  NA_get_Int64  (PyArrayObject*,long);

static void  NA_set_Int64  (PyArrayObject*,long,Int64);

static Float64  NA_get1_Float64  (PyArrayObject*,long);

static Float64  NA_get2_Float64  (PyArrayObject*,long,long);

static Float64  NA_get3_Float64  (PyArrayObject*,long,long,long);

static void  NA_set1_Float64  (PyArrayObject*,long,Float64);

static void  NA_set2_Float64  (PyArrayObject*,long,long,Float64);

static void  NA_set3_Float64  (PyArrayObject*,long,long,long,Float64);

static Complex64  NA_get1_Complex64  (PyArrayObject*,long);

static Complex64  NA_get2_Complex64  (PyArrayObject*,long,long);

static Complex64  NA_get3_Complex64  (PyArrayObject*,long,long,long);

static void  NA_set1_Complex64  (PyArrayObject*,long,Complex64);

static void  NA_set2_Complex64  (PyArrayObject*,long,long,Complex64);

static void  NA_set3_Complex64  (PyArrayObject*,long,long,long,Complex64);

static Int64  NA_get1_Int64  (PyArrayObject*,long);

static Int64  NA_get2_Int64  (PyArrayObject*,long,long);

static Int64  NA_get3_Int64  (PyArrayObject*,long,long,long);

static void  NA_set1_Int64  (PyArrayObject*,long,Int64);

static void  NA_set2_Int64  (PyArrayObject*,long,long,Int64);

static void  NA_set3_Int64  (PyArrayObject*,long,long,long,Int64);

static int  NA_get1D_Float64  (PyArrayObject*,long,int,Float64*);

static int  NA_set1D_Float64  (PyArrayObject*,long,int,Float64*);

static int  NA_get1D_Int64  (PyArrayObject*,long,int,Int64*);

static int  NA_set1D_Int64  (PyArrayObject*,long,int,Int64*);

static int  NA_get1D_Complex64  (PyArrayObject*,long,int,Complex64*);

static int  NA_set1D_Complex64  (PyArrayObject*,long,int,Complex64*);

static int  NA_ShapeEqual  (PyArrayObject*,PyArrayObject*);

static int  NA_ShapeLessThan  (PyArrayObject*,PyArrayObject*);

static int  NA_ByteOrder  (void);

static Bool  NA_IeeeSpecial32  (Float32*,Int32*);

static Bool  NA_IeeeSpecial64  (Float64*,Int32*);

static PyArrayObject*  NA_updateDataPtr  (PyArrayObject*);

static char*  NA_typeNoToName  (int);

static int  NA_nameToTypeNo  (char*);

static PyObject*  NA_typeNoToTypeObject  (int);

static PyObject*  NA_intTupleFromMaybeLongs  (int,maybelong*);

static long  NA_maybeLongsFromIntTuple  (int,maybelong*,PyObject*);

static int  NA_intTupleProduct  (PyObject *obj, long *product);

static long  NA_isIntegerSequence  (PyObject*);

static PyObject*  NA_setArrayFromSequence  (PyArrayObject*,PyObject*);

static int  NA_maxType  (PyObject*);

static int  NA_isPythonScalar  (PyObject *obj);

static PyObject*  NA_getPythonScalar  (PyArrayObject*,long);

static int  NA_setFromPythonScalar  (PyArrayObject*,long,PyObject*);

static int  NA_NDArrayCheck  (PyObject*);

static int  NA_NumArrayCheck  (PyObject*);

static int  NA_ComplexArrayCheck  (PyObject*);

static unsigned long  NA_elements  (PyArrayObject*);

static int  NA_typeObjectToTypeNo  (PyObject*);

static int  NA_copyArray  (PyArrayObject* to, const PyArrayObject* from);

static PyArrayObject*  NA_copy  (PyArrayObject*);

static PyObject*  NA_getType  (PyObject *typeobj_or_name);

static PyObject *  NA_callCUFuncCore  (PyObject *cfunc, long niter, long ninargs, long noutargs, PyObject **BufferObj, long *offset);

static PyObject *  NA_callStrideConvCFuncCore  (PyObject *cfunc, int nshape, maybelong *shape, PyObject *inbuffObj,  long inboffset, int nstrides0, maybelong *inbstrides, PyObject *outbuffObj, long outboffset, int nstrides1, maybelong *outbstrides, long nbytes);

static void  NA_stridesFromShape  (int nshape, maybelong *shape, maybelong bytestride, maybelong *strides);

static int  NA_OperatorCheck  (PyObject *obj);

static int  NA_ConverterCheck  (PyObject *obj);

static int  NA_UfuncCheck  (PyObject *obj);

static int  NA_CfuncCheck  (PyObject *obj);

static int  NA_getByteOffset  (PyArrayObject *array, int nindices, maybelong *indices, long *offset);

static int  NA_swapAxes  (PyArrayObject *array, int x, int y);

static PyObject *  NA_initModuleGlobal  (char *module, char *global);

static NumarrayType  NA_NumarrayType  (PyObject *seq);

static PyArrayObject *  NA_NewAllFromBuffer  (int ndim, maybelong *shape, NumarrayType type, PyObject *bufferObject, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable);

static Float64 *  NA_alloc1D_Float64  (PyArrayObject *a, long offset, int cnt);

static Int64 *  NA_alloc1D_Int64  (PyArrayObject *a, long offset, int cnt);

static void  NA_updateAlignment  (PyArrayObject *self);

static void  NA_updateContiguous  (PyArrayObject *self);

static void  NA_updateStatus  (PyArrayObject *self);

static int  NA_NumArrayCheckExact  (PyObject *op);

static int  NA_NDArrayCheckExact  (PyObject *op);

static int  NA_OperatorCheckExact  (PyObject *op);

static int  NA_ConverterCheckExact  (PyObject *op);

static int  NA_UfuncCheckExact  (PyObject *op);

static int  NA_CfuncCheckExact  (PyObject *op);

static char *  NA_getArrayData  (PyArrayObject *ap);

static void  NA_updateByteswap  (PyArrayObject *ap);

static PyArray_Descr *  NA_DescrFromType  (int type);

static PyObject *  NA_Cast  (PyArrayObject *a, int type);

static int  NA_checkFPErrors  (void);

static void  NA_clearFPErrors  (void);

static int  NA_checkAndReportFPErrors  (char *name);

static Bool  NA_IeeeMask32  (Float32,Int32);

static Bool  NA_IeeeMask64  (Float64,Int32);

static int  _NA_callStridingHelper  (PyObject *aux, long dim, long nnumarray, PyArrayObject *numarray[], char *data[], CFUNC_STRIDED_FUNC f);

static PyArrayObject *  NA_FromDimsStridesDescrAndData  (int nd, maybelong *dims, maybelong *strides, PyArray_Descr *descr, char *data);

static PyArrayObject *  NA_FromDimsTypeAndData  (int nd, maybelong *dims, int type, char *data);

static PyArrayObject *  NA_FromDimsStridesTypeAndData  (int nd, maybelong *dims, maybelong *strides, int type, char *data);

static int  NA_scipy_typestr  (NumarrayType t, int byteorder, char *typestr);

static PyArrayObject *  NA_FromArrayStruct  (PyObject *a);


#else
  /* This section is used in modules that use libnumarray */

#define  getBuffer (libnumarray_API ? (*(PyObject* (*)  (PyObject*o) ) libnumarray_API[ 0 ]) : (*(PyObject* (*)  (PyObject*o) ) libnumarray_FatalApiError))

#define  isBuffer (libnumarray_API ? (*(int (*)  (PyObject*o) ) libnumarray_API[ 1 ]) : (*(int (*)  (PyObject*o) ) libnumarray_FatalApiError))

#define  getWriteBufferDataPtr (libnumarray_API ? (*(int (*)  (PyObject*o,void**p) ) libnumarray_API[ 2 ]) : (*(int (*)  (PyObject*o,void**p) ) libnumarray_FatalApiError))

#define  isBufferWriteable (libnumarray_API ? (*(int (*)  (PyObject*o) ) libnumarray_API[ 3 ]) : (*(int (*)  (PyObject*o) ) libnumarray_FatalApiError))

#define  getReadBufferDataPtr (libnumarray_API ? (*(int (*)  (PyObject*o,void**p) ) libnumarray_API[ 4 ]) : (*(int (*)  (PyObject*o,void**p) ) libnumarray_FatalApiError))

#define  getBufferSize (libnumarray_API ? (*(int (*)  (PyObject*o) ) libnumarray_API[ 5 ]) : (*(int (*)  (PyObject*o) ) libnumarray_FatalApiError))

#define  num_log (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 6 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  num_log10 (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 7 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  num_pow (libnumarray_API ? (*(double (*)  (double x, double y) ) libnumarray_API[ 8 ]) : (*(double (*)  (double x, double y) ) libnumarray_FatalApiError))

#define  num_acosh (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 9 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  num_asinh (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 10 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  num_atanh (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 11 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  num_round (libnumarray_API ? (*(double (*)  (double x) ) libnumarray_API[ 12 ]) : (*(double (*)  (double x) ) libnumarray_FatalApiError))

#define  int_dividebyzero_error (libnumarray_API ? (*(int (*)  (long value, long unused) ) libnumarray_API[ 13 ]) : (*(int (*)  (long value, long unused) ) libnumarray_FatalApiError))

#define  int_overflow_error (libnumarray_API ? (*(int (*)  (Float64 value) ) libnumarray_API[ 14 ]) : (*(int (*)  (Float64 value) ) libnumarray_FatalApiError))

#define  umult64_overflow (libnumarray_API ? (*(int (*)  (UInt64 a, UInt64 b) ) libnumarray_API[ 15 ]) : (*(int (*)  (UInt64 a, UInt64 b) ) libnumarray_FatalApiError))

#define  smult64_overflow (libnumarray_API ? (*(int (*)  (Int64 a0, Int64 b0) ) libnumarray_API[ 16 ]) : (*(int (*)  (Int64 a0, Int64 b0) ) libnumarray_FatalApiError))

#define  NA_Done (libnumarray_API ? (*(void (*)  (void) ) libnumarray_API[ 17 ]) : (*(void (*)  (void) ) libnumarray_FatalApiError))

#define  NA_NewAll (libnumarray_API ? (*(PyArrayObject* (*)  (int ndim, maybelong* shape, NumarrayType type, void* buffer, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable) ) libnumarray_API[ 18 ]) : (*(PyArrayObject* (*)  (int ndim, maybelong* shape, NumarrayType type, void* buffer, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable) ) libnumarray_FatalApiError))

#define  NA_NewAllStrides (libnumarray_API ? (*(PyArrayObject* (*)  (int ndim, maybelong* shape, maybelong* strides, NumarrayType type, void* buffer, maybelong byteoffset, int byteorder, int aligned, int writeable) ) libnumarray_API[ 19 ]) : (*(PyArrayObject* (*)  (int ndim, maybelong* shape, maybelong* strides, NumarrayType type, void* buffer, maybelong byteoffset, int byteorder, int aligned, int writeable) ) libnumarray_FatalApiError))

#define  NA_New (libnumarray_API ? (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim,...) ) libnumarray_API[ 20 ]) : (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim,...) ) libnumarray_FatalApiError))

#define  NA_Empty (libnumarray_API ? (*(PyArrayObject* (*)  (int ndim, maybelong* shape, NumarrayType type) ) libnumarray_API[ 21 ]) : (*(PyArrayObject* (*)  (int ndim, maybelong* shape, NumarrayType type) ) libnumarray_FatalApiError))

#define  NA_NewArray (libnumarray_API ? (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim, ...) ) libnumarray_API[ 22 ]) : (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim, ...) ) libnumarray_FatalApiError))

#define  NA_vNewArray (libnumarray_API ? (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim, maybelong *shape) ) libnumarray_API[ 23 ]) : (*(PyArrayObject* (*)  (void* buffer, NumarrayType type, int ndim, maybelong *shape) ) libnumarray_FatalApiError))

#define  NA_ReturnOutput (libnumarray_API ? (*(PyObject* (*)  (PyObject*,PyArrayObject*) ) libnumarray_API[ 24 ]) : (*(PyObject* (*)  (PyObject*,PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_getBufferPtrAndSize (libnumarray_API ? (*(long (*)  (PyObject*,int,void**) ) libnumarray_API[ 25 ]) : (*(long (*)  (PyObject*,int,void**) ) libnumarray_FatalApiError))

#define  NA_checkIo (libnumarray_API ? (*(int (*)  (char*,int,int,int,int) ) libnumarray_API[ 26 ]) : (*(int (*)  (char*,int,int,int,int) ) libnumarray_FatalApiError))

#define  NA_checkOneCBuffer (libnumarray_API ? (*(int (*)  (char*,long,void*,long,size_t) ) libnumarray_API[ 27 ]) : (*(int (*)  (char*,long,void*,long,size_t) ) libnumarray_FatalApiError))

#define  NA_checkNCBuffers (libnumarray_API ? (*(int (*)  (char*,int,long,void**,long*,Int8*,Int8*) ) libnumarray_API[ 28 ]) : (*(int (*)  (char*,int,long,void**,long*,Int8*,Int8*) ) libnumarray_FatalApiError))

#define  NA_checkOneStriding (libnumarray_API ? (*(int (*)  (char*,long,maybelong*,long,maybelong*,long,long,int) ) libnumarray_API[ 29 ]) : (*(int (*)  (char*,long,maybelong*,long,maybelong*,long,long,int) ) libnumarray_FatalApiError))

#define  NA_new_cfunc (libnumarray_API ? (*(PyObject* (*)  (CfuncDescriptor*) ) libnumarray_API[ 30 ]) : (*(PyObject* (*)  (CfuncDescriptor*) ) libnumarray_FatalApiError))

#define  NA_add_cfunc (libnumarray_API ? (*(int (*)  (PyObject*,char*,CfuncDescriptor*) ) libnumarray_API[ 31 ]) : (*(int (*)  (PyObject*,char*,CfuncDescriptor*) ) libnumarray_FatalApiError))

#define  NA_InputArray (libnumarray_API ? (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_API[ 32 ]) : (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_FatalApiError))

#define  NA_OutputArray (libnumarray_API ? (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_API[ 33 ]) : (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_FatalApiError))

#define  NA_IoArray (libnumarray_API ? (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_API[ 34 ]) : (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int) ) libnumarray_FatalApiError))

#define  NA_OptionalOutputArray (libnumarray_API ? (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int,PyArrayObject*) ) libnumarray_API[ 35 ]) : (*(PyArrayObject* (*)  (PyObject*,NumarrayType,int,PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_get_offset (libnumarray_API ? (*(long (*)  (PyArrayObject*,int,...) ) libnumarray_API[ 36 ]) : (*(long (*)  (PyArrayObject*,int,...) ) libnumarray_FatalApiError))

#define  NA_get_Float64 (libnumarray_API ? (*(Float64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 37 ]) : (*(Float64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_set_Float64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Float64) ) libnumarray_API[ 38 ]) : (*(void (*)  (PyArrayObject*,long,Float64) ) libnumarray_FatalApiError))

#define  NA_get_Complex64 (libnumarray_API ? (*(Complex64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 39 ]) : (*(Complex64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_set_Complex64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Complex64) ) libnumarray_API[ 40 ]) : (*(void (*)  (PyArrayObject*,long,Complex64) ) libnumarray_FatalApiError))

#define  NA_get_Int64 (libnumarray_API ? (*(Int64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 41 ]) : (*(Int64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_set_Int64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Int64) ) libnumarray_API[ 42 ]) : (*(void (*)  (PyArrayObject*,long,Int64) ) libnumarray_FatalApiError))

#define  NA_get1_Float64 (libnumarray_API ? (*(Float64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 43 ]) : (*(Float64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_get2_Float64 (libnumarray_API ? (*(Float64 (*)  (PyArrayObject*,long,long) ) libnumarray_API[ 44 ]) : (*(Float64 (*)  (PyArrayObject*,long,long) ) libnumarray_FatalApiError))

#define  NA_get3_Float64 (libnumarray_API ? (*(Float64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_API[ 45 ]) : (*(Float64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_FatalApiError))

#define  NA_set1_Float64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Float64) ) libnumarray_API[ 46 ]) : (*(void (*)  (PyArrayObject*,long,Float64) ) libnumarray_FatalApiError))

#define  NA_set2_Float64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,Float64) ) libnumarray_API[ 47 ]) : (*(void (*)  (PyArrayObject*,long,long,Float64) ) libnumarray_FatalApiError))

#define  NA_set3_Float64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,long,Float64) ) libnumarray_API[ 48 ]) : (*(void (*)  (PyArrayObject*,long,long,long,Float64) ) libnumarray_FatalApiError))

#define  NA_get1_Complex64 (libnumarray_API ? (*(Complex64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 49 ]) : (*(Complex64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_get2_Complex64 (libnumarray_API ? (*(Complex64 (*)  (PyArrayObject*,long,long) ) libnumarray_API[ 50 ]) : (*(Complex64 (*)  (PyArrayObject*,long,long) ) libnumarray_FatalApiError))

#define  NA_get3_Complex64 (libnumarray_API ? (*(Complex64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_API[ 51 ]) : (*(Complex64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_FatalApiError))

#define  NA_set1_Complex64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Complex64) ) libnumarray_API[ 52 ]) : (*(void (*)  (PyArrayObject*,long,Complex64) ) libnumarray_FatalApiError))

#define  NA_set2_Complex64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,Complex64) ) libnumarray_API[ 53 ]) : (*(void (*)  (PyArrayObject*,long,long,Complex64) ) libnumarray_FatalApiError))

#define  NA_set3_Complex64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,long,Complex64) ) libnumarray_API[ 54 ]) : (*(void (*)  (PyArrayObject*,long,long,long,Complex64) ) libnumarray_FatalApiError))

#define  NA_get1_Int64 (libnumarray_API ? (*(Int64 (*)  (PyArrayObject*,long) ) libnumarray_API[ 55 ]) : (*(Int64 (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_get2_Int64 (libnumarray_API ? (*(Int64 (*)  (PyArrayObject*,long,long) ) libnumarray_API[ 56 ]) : (*(Int64 (*)  (PyArrayObject*,long,long) ) libnumarray_FatalApiError))

#define  NA_get3_Int64 (libnumarray_API ? (*(Int64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_API[ 57 ]) : (*(Int64 (*)  (PyArrayObject*,long,long,long) ) libnumarray_FatalApiError))

#define  NA_set1_Int64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,Int64) ) libnumarray_API[ 58 ]) : (*(void (*)  (PyArrayObject*,long,Int64) ) libnumarray_FatalApiError))

#define  NA_set2_Int64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,Int64) ) libnumarray_API[ 59 ]) : (*(void (*)  (PyArrayObject*,long,long,Int64) ) libnumarray_FatalApiError))

#define  NA_set3_Int64 (libnumarray_API ? (*(void (*)  (PyArrayObject*,long,long,long,Int64) ) libnumarray_API[ 60 ]) : (*(void (*)  (PyArrayObject*,long,long,long,Int64) ) libnumarray_FatalApiError))

#define  NA_get1D_Float64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Float64*) ) libnumarray_API[ 61 ]) : (*(int (*)  (PyArrayObject*,long,int,Float64*) ) libnumarray_FatalApiError))

#define  NA_set1D_Float64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Float64*) ) libnumarray_API[ 62 ]) : (*(int (*)  (PyArrayObject*,long,int,Float64*) ) libnumarray_FatalApiError))

#define  NA_get1D_Int64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Int64*) ) libnumarray_API[ 63 ]) : (*(int (*)  (PyArrayObject*,long,int,Int64*) ) libnumarray_FatalApiError))

#define  NA_set1D_Int64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Int64*) ) libnumarray_API[ 64 ]) : (*(int (*)  (PyArrayObject*,long,int,Int64*) ) libnumarray_FatalApiError))

#define  NA_get1D_Complex64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Complex64*) ) libnumarray_API[ 65 ]) : (*(int (*)  (PyArrayObject*,long,int,Complex64*) ) libnumarray_FatalApiError))

#define  NA_set1D_Complex64 (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,int,Complex64*) ) libnumarray_API[ 66 ]) : (*(int (*)  (PyArrayObject*,long,int,Complex64*) ) libnumarray_FatalApiError))

#define  NA_ShapeEqual (libnumarray_API ? (*(int (*)  (PyArrayObject*,PyArrayObject*) ) libnumarray_API[ 67 ]) : (*(int (*)  (PyArrayObject*,PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_ShapeLessThan (libnumarray_API ? (*(int (*)  (PyArrayObject*,PyArrayObject*) ) libnumarray_API[ 68 ]) : (*(int (*)  (PyArrayObject*,PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_ByteOrder (libnumarray_API ? (*(int (*)  (void) ) libnumarray_API[ 69 ]) : (*(int (*)  (void) ) libnumarray_FatalApiError))

#define  NA_IeeeSpecial32 (libnumarray_API ? (*(Bool (*)  (Float32*,Int32*) ) libnumarray_API[ 70 ]) : (*(Bool (*)  (Float32*,Int32*) ) libnumarray_FatalApiError))

#define  NA_IeeeSpecial64 (libnumarray_API ? (*(Bool (*)  (Float64*,Int32*) ) libnumarray_API[ 71 ]) : (*(Bool (*)  (Float64*,Int32*) ) libnumarray_FatalApiError))

#define  NA_updateDataPtr (libnumarray_API ? (*(PyArrayObject* (*)  (PyArrayObject*) ) libnumarray_API[ 72 ]) : (*(PyArrayObject* (*)  (PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_typeNoToName (libnumarray_API ? (*(char* (*)  (int) ) libnumarray_API[ 73 ]) : (*(char* (*)  (int) ) libnumarray_FatalApiError))

#define  NA_nameToTypeNo (libnumarray_API ? (*(int (*)  (char*) ) libnumarray_API[ 74 ]) : (*(int (*)  (char*) ) libnumarray_FatalApiError))

#define  NA_typeNoToTypeObject (libnumarray_API ? (*(PyObject* (*)  (int) ) libnumarray_API[ 75 ]) : (*(PyObject* (*)  (int) ) libnumarray_FatalApiError))

#define  NA_intTupleFromMaybeLongs (libnumarray_API ? (*(PyObject* (*)  (int,maybelong*) ) libnumarray_API[ 76 ]) : (*(PyObject* (*)  (int,maybelong*) ) libnumarray_FatalApiError))

#define  NA_maybeLongsFromIntTuple (libnumarray_API ? (*(long (*)  (int,maybelong*,PyObject*) ) libnumarray_API[ 77 ]) : (*(long (*)  (int,maybelong*,PyObject*) ) libnumarray_FatalApiError))

#define  NA_intTupleProduct (libnumarray_API ? (*(int (*)  (PyObject *obj, long *product) ) libnumarray_API[ 78 ]) : (*(int (*)  (PyObject *obj, long *product) ) libnumarray_FatalApiError))

#define  NA_isIntegerSequence (libnumarray_API ? (*(long (*)  (PyObject*) ) libnumarray_API[ 79 ]) : (*(long (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_setArrayFromSequence (libnumarray_API ? (*(PyObject* (*)  (PyArrayObject*,PyObject*) ) libnumarray_API[ 80 ]) : (*(PyObject* (*)  (PyArrayObject*,PyObject*) ) libnumarray_FatalApiError))

#define  NA_maxType (libnumarray_API ? (*(int (*)  (PyObject*) ) libnumarray_API[ 81 ]) : (*(int (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_isPythonScalar (libnumarray_API ? (*(int (*)  (PyObject *obj) ) libnumarray_API[ 82 ]) : (*(int (*)  (PyObject *obj) ) libnumarray_FatalApiError))

#define  NA_getPythonScalar (libnumarray_API ? (*(PyObject* (*)  (PyArrayObject*,long) ) libnumarray_API[ 83 ]) : (*(PyObject* (*)  (PyArrayObject*,long) ) libnumarray_FatalApiError))

#define  NA_setFromPythonScalar (libnumarray_API ? (*(int (*)  (PyArrayObject*,long,PyObject*) ) libnumarray_API[ 84 ]) : (*(int (*)  (PyArrayObject*,long,PyObject*) ) libnumarray_FatalApiError))

#define  NA_NDArrayCheck (libnumarray_API ? (*(int (*)  (PyObject*) ) libnumarray_API[ 85 ]) : (*(int (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_NumArrayCheck (libnumarray_API ? (*(int (*)  (PyObject*) ) libnumarray_API[ 86 ]) : (*(int (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_ComplexArrayCheck (libnumarray_API ? (*(int (*)  (PyObject*) ) libnumarray_API[ 87 ]) : (*(int (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_elements (libnumarray_API ? (*(unsigned long (*)  (PyArrayObject*) ) libnumarray_API[ 88 ]) : (*(unsigned long (*)  (PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_typeObjectToTypeNo (libnumarray_API ? (*(int (*)  (PyObject*) ) libnumarray_API[ 89 ]) : (*(int (*)  (PyObject*) ) libnumarray_FatalApiError))

#define  NA_copyArray (libnumarray_API ? (*(int (*)  (PyArrayObject* to, const PyArrayObject* from) ) libnumarray_API[ 90 ]) : (*(int (*)  (PyArrayObject* to, const PyArrayObject* from) ) libnumarray_FatalApiError))

#define  NA_copy (libnumarray_API ? (*(PyArrayObject* (*)  (PyArrayObject*) ) libnumarray_API[ 91 ]) : (*(PyArrayObject* (*)  (PyArrayObject*) ) libnumarray_FatalApiError))

#define  NA_getType (libnumarray_API ? (*(PyObject* (*)  (PyObject *typeobj_or_name) ) libnumarray_API[ 92 ]) : (*(PyObject* (*)  (PyObject *typeobj_or_name) ) libnumarray_FatalApiError))

#define  NA_callCUFuncCore (libnumarray_API ? (*(PyObject * (*)  (PyObject *cfunc, long niter, long ninargs, long noutargs, PyObject **BufferObj, long *offset) ) libnumarray_API[ 93 ]) : (*(PyObject * (*)  (PyObject *cfunc, long niter, long ninargs, long noutargs, PyObject **BufferObj, long *offset) ) libnumarray_FatalApiError))

#define  NA_callStrideConvCFuncCore (libnumarray_API ? (*(PyObject * (*)  (PyObject *cfunc, int nshape, maybelong *shape, PyObject *inbuffObj,  long inboffset, int nstrides0, maybelong *inbstrides, PyObject *outbuffObj, long outboffset, int nstrides1, maybelong *outbstrides, long nbytes) ) libnumarray_API[ 94 ]) : (*(PyObject * (*)  (PyObject *cfunc, int nshape, maybelong *shape, PyObject *inbuffObj,  long inboffset, int nstrides0, maybelong *inbstrides, PyObject *outbuffObj, long outboffset, int nstrides1, maybelong *outbstrides, long nbytes) ) libnumarray_FatalApiError))

#define  NA_stridesFromShape (libnumarray_API ? (*(void (*)  (int nshape, maybelong *shape, maybelong bytestride, maybelong *strides) ) libnumarray_API[ 95 ]) : (*(void (*)  (int nshape, maybelong *shape, maybelong bytestride, maybelong *strides) ) libnumarray_FatalApiError))

#define  NA_OperatorCheck (libnumarray_API ? (*(int (*)  (PyObject *obj) ) libnumarray_API[ 96 ]) : (*(int (*)  (PyObject *obj) ) libnumarray_FatalApiError))

#define  NA_ConverterCheck (libnumarray_API ? (*(int (*)  (PyObject *obj) ) libnumarray_API[ 97 ]) : (*(int (*)  (PyObject *obj) ) libnumarray_FatalApiError))

#define  NA_UfuncCheck (libnumarray_API ? (*(int (*)  (PyObject *obj) ) libnumarray_API[ 98 ]) : (*(int (*)  (PyObject *obj) ) libnumarray_FatalApiError))

#define  NA_CfuncCheck (libnumarray_API ? (*(int (*)  (PyObject *obj) ) libnumarray_API[ 99 ]) : (*(int (*)  (PyObject *obj) ) libnumarray_FatalApiError))

#define  NA_getByteOffset (libnumarray_API ? (*(int (*)  (PyArrayObject *array, int nindices, maybelong *indices, long *offset) ) libnumarray_API[ 100 ]) : (*(int (*)  (PyArrayObject *array, int nindices, maybelong *indices, long *offset) ) libnumarray_FatalApiError))

#define  NA_swapAxes (libnumarray_API ? (*(int (*)  (PyArrayObject *array, int x, int y) ) libnumarray_API[ 101 ]) : (*(int (*)  (PyArrayObject *array, int x, int y) ) libnumarray_FatalApiError))

#define  NA_initModuleGlobal (libnumarray_API ? (*(PyObject * (*)  (char *module, char *global) ) libnumarray_API[ 102 ]) : (*(PyObject * (*)  (char *module, char *global) ) libnumarray_FatalApiError))

#define  NA_NumarrayType (libnumarray_API ? (*(NumarrayType (*)  (PyObject *seq) ) libnumarray_API[ 103 ]) : (*(NumarrayType (*)  (PyObject *seq) ) libnumarray_FatalApiError))

#define  NA_NewAllFromBuffer (libnumarray_API ? (*(PyArrayObject * (*)  (int ndim, maybelong *shape, NumarrayType type, PyObject *bufferObject, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable) ) libnumarray_API[ 104 ]) : (*(PyArrayObject * (*)  (int ndim, maybelong *shape, NumarrayType type, PyObject *bufferObject, maybelong byteoffset, maybelong bytestride, int byteorder, int aligned, int writeable) ) libnumarray_FatalApiError))

#define  NA_alloc1D_Float64 (libnumarray_API ? (*(Float64 * (*)  (PyArrayObject *a, long offset, int cnt) ) libnumarray_API[ 105 ]) : (*(Float64 * (*)  (PyArrayObject *a, long offset, int cnt) ) libnumarray_FatalApiError))

#define  NA_alloc1D_Int64 (libnumarray_API ? (*(Int64 * (*)  (PyArrayObject *a, long offset, int cnt) ) libnumarray_API[ 106 ]) : (*(Int64 * (*)  (PyArrayObject *a, long offset, int cnt) ) libnumarray_FatalApiError))

#define  NA_updateAlignment (libnumarray_API ? (*(void (*)  (PyArrayObject *self) ) libnumarray_API[ 107 ]) : (*(void (*)  (PyArrayObject *self) ) libnumarray_FatalApiError))

#define  NA_updateContiguous (libnumarray_API ? (*(void (*)  (PyArrayObject *self) ) libnumarray_API[ 108 ]) : (*(void (*)  (PyArrayObject *self) ) libnumarray_FatalApiError))

#define  NA_updateStatus (libnumarray_API ? (*(void (*)  (PyArrayObject *self) ) libnumarray_API[ 109 ]) : (*(void (*)  (PyArrayObject *self) ) libnumarray_FatalApiError))

#define  NA_NumArrayCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 110 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_NDArrayCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 111 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_OperatorCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 112 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_ConverterCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 113 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_UfuncCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 114 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_CfuncCheckExact (libnumarray_API ? (*(int (*)  (PyObject *op) ) libnumarray_API[ 115 ]) : (*(int (*)  (PyObject *op) ) libnumarray_FatalApiError))

#define  NA_getArrayData (libnumarray_API ? (*(char * (*)  (PyArrayObject *ap) ) libnumarray_API[ 116 ]) : (*(char * (*)  (PyArrayObject *ap) ) libnumarray_FatalApiError))

#define  NA_updateByteswap (libnumarray_API ? (*(void (*)  (PyArrayObject *ap) ) libnumarray_API[ 117 ]) : (*(void (*)  (PyArrayObject *ap) ) libnumarray_FatalApiError))

#define  NA_DescrFromType (libnumarray_API ? (*(PyArray_Descr * (*)  (int type) ) libnumarray_API[ 118 ]) : (*(PyArray_Descr * (*)  (int type) ) libnumarray_FatalApiError))

#define  NA_Cast (libnumarray_API ? (*(PyObject * (*)  (PyArrayObject *a, int type) ) libnumarray_API[ 119 ]) : (*(PyObject * (*)  (PyArrayObject *a, int type) ) libnumarray_FatalApiError))

#define  NA_checkFPErrors (libnumarray_API ? (*(int (*)  (void) ) libnumarray_API[ 120 ]) : (*(int (*)  (void) ) libnumarray_FatalApiError))

#define  NA_clearFPErrors (libnumarray_API ? (*(void (*)  (void) ) libnumarray_API[ 121 ]) : (*(void (*)  (void) ) libnumarray_FatalApiError))

#define  NA_checkAndReportFPErrors (libnumarray_API ? (*(int (*)  (char *name) ) libnumarray_API[ 122 ]) : (*(int (*)  (char *name) ) libnumarray_FatalApiError))

#define  NA_IeeeMask32 (libnumarray_API ? (*(Bool (*)  (Float32,Int32) ) libnumarray_API[ 123 ]) : (*(Bool (*)  (Float32,Int32) ) libnumarray_FatalApiError))

#define  NA_IeeeMask64 (libnumarray_API ? (*(Bool (*)  (Float64,Int32) ) libnumarray_API[ 124 ]) : (*(Bool (*)  (Float64,Int32) ) libnumarray_FatalApiError))

#define  _NA_callStridingHelper (libnumarray_API ? (*(int (*)  (PyObject *aux, long dim, long nnumarray, PyArrayObject *numarray[], char *data[], CFUNC_STRIDED_FUNC f) ) libnumarray_API[ 125 ]) : (*(int (*)  (PyObject *aux, long dim, long nnumarray, PyArrayObject *numarray[], char *data[], CFUNC_STRIDED_FUNC f) ) libnumarray_FatalApiError))

#define  NA_FromDimsStridesDescrAndData (libnumarray_API ? (*(PyArrayObject * (*)  (int nd, maybelong *dims, maybelong *strides, PyArray_Descr *descr, char *data) ) libnumarray_API[ 126 ]) : (*(PyArrayObject * (*)  (int nd, maybelong *dims, maybelong *strides, PyArray_Descr *descr, char *data) ) libnumarray_FatalApiError))

#define  NA_FromDimsTypeAndData (libnumarray_API ? (*(PyArrayObject * (*)  (int nd, maybelong *dims, int type, char *data) ) libnumarray_API[ 127 ]) : (*(PyArrayObject * (*)  (int nd, maybelong *dims, int type, char *data) ) libnumarray_FatalApiError))

#define  NA_FromDimsStridesTypeAndData (libnumarray_API ? (*(PyArrayObject * (*)  (int nd, maybelong *dims, maybelong *strides, int type, char *data) ) libnumarray_API[ 128 ]) : (*(PyArrayObject * (*)  (int nd, maybelong *dims, maybelong *strides, int type, char *data) ) libnumarray_FatalApiError))

#define  NA_scipy_typestr (libnumarray_API ? (*(int (*)  (NumarrayType t, int byteorder, char *typestr) ) libnumarray_API[ 129 ]) : (*(int (*)  (NumarrayType t, int byteorder, char *typestr) ) libnumarray_FatalApiError))

#define  NA_FromArrayStruct (libnumarray_API ? (*(PyArrayObject * (*)  (PyObject *a) ) libnumarray_API[ 130 ]) : (*(PyArrayObject * (*)  (PyObject *a) ) libnumarray_FatalApiError))

#endif

  /* Total number of C API pointers */
#define libnumarray_API_pointers 131

#ifdef __cplusplus
}
#endif

#endif /* NUMPY_LIBNUMARRAY_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                  numcomplex.h                                                                                        0100644 0001750 0001750 00000032371 12222104616 043350  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             /* See numarray.h for Complex32, Complex64:

typedef struct { Float32 r, i; } Complex32;
typedef struct { Float64 r, i; } Complex64;

*/
typedef struct { Float32 a, theta; } PolarComplex32;
typedef struct { Float64 a, theta; } PolarComplex64;

#define NUM_SQ(x)         ((x)*(x))

#define NUM_CABSSQ(p)     (NUM_SQ((p).r) + NUM_SQ((p).i))

#define NUM_CABS(p)       sqrt(NUM_CABSSQ(p))

#define NUM_C_TO_P(c, p)  (p).a = NUM_CABS(c);                                \
                          (p).theta = atan2((c).i, (c).r);

#define NUM_P_TO_C(p, c)  (c).r = (p).a*cos((p).theta);                       \
                          (c).i = (p).a*sin((p).theta);

#define NUM_CASS(p, q)    (q).r = (p).r, (q).i = (p).i

#define NUM_CADD(p, q, s) (s).r = (p).r + (q).r,                              \
                          (s).i = (p).i + (q).i

#define NUM_CSUB(p, q, s) (s).r = (p).r - (q).r,                              \
                          (s).i = (p).i - (q).i

#define NUM_CMUL(p, q, s)                                                     \
          { Float64 rp = (p).r;                                               \
            Float64 rq = (q).r;                                               \
                (s).r = rp*rq - (p).i*(q).i;                                  \
                (s).i = rp*(q).i + rq*(p).i;                                  \
          }

#define NUM_CDIV(p, q, s)                                                     \
          {                                                                   \
	    Float64 rp = (p).r;                                               \
            Float64 ip = (p).i;                                               \
            Float64 rq = (q).r;                                               \
  	    if ((q).i != 0) {                                                 \
                Float64 temp = NUM_CABSSQ(q);                                 \
                (s).r = (rp*rq+(p).i*(q).i)/temp;                             \
                (s).i = (rq*(p).i-(q).i*rp)/temp;                             \
            } else {                                                          \
 	        (s).r = rp/rq;                                                \
		(s).i = ip/rq;                                                \
            }                                                                 \
          }

#define NUM_CREM(p, q, s)                                                     \
          {  Complex64 r;                                                     \
             NUM_CDIV(p, q, r);                                               \
             r.r = floor(r.r);                                                \
             r.i = 0;                                                         \
             NUM_CMUL(r, q, r);                                               \
             NUM_CSUB(p, r, s);                                               \
          }

#define NUM_CMINUS(p, s)  (s).r = -(p).r; (s).i = -(p).i;
#define NUM_CNEG NUM_CMINUS

#define NUM_CEQ(p, q)  (((p).r == (q).r) && ((p).i == (q).i))
#define NUM_CNE(p, q)  (((p).r != (q).r) || ((p).i != (q).i))
#define NUM_CLT(p, q)  ((p).r < (q).r)
#define NUM_CGT(p, q)  ((p).r > (q).r)
#define NUM_CLE(p, q)  ((p).r <= (q).r)
#define NUM_CGE(p, q)  ((p).r >= (q).r)

/* e**z = e**x * (cos(y)+ i*sin(y)) where z = x + i*y
   so e**z = e**x * cos(y) +  i * e**x * sin(y)
*/
#define NUM_CEXP(p, s)                                                        \
          { Float64 ex = exp((p).r);                                          \
            (s).r = ex * cos((p).i);                                          \
            (s).i = ex * sin((p).i);                                          \
          }

/* e**w = z;     w = u + i*v;     z = r * e**(i*theta);

e**u * e**(i*v) = r * e**(i*theta);

log(z) = w;  log(z) = log(r) + i*theta;
 */
#define NUM_CLOG(p, s)                                                      \
          { PolarComplex64 temp;   NUM_C_TO_P(p, temp);                     \
            (s).r = num_log(temp.a);                                        \
            (s).i = temp.theta;                                             \
          }

#define NUM_LOG10_E  0.43429448190325182

#define NUM_CLOG10(p, s)                                                    \
          { NUM_CLOG(p, s);                                                 \
            (s).r *= NUM_LOG10_E;                                           \
            (s).i *= NUM_LOG10_E;                                           \
          }

/* s = p ** q  */
#define NUM_CPOW(p, q, s) { if (NUM_CABSSQ(p) == 0) {                        \
	                       if ((q).r == 0 && (q).i == 0) {               \
                                   (s).r = (s).i = 1;                        \
                               } else {                                      \
                                   (s).r = (s).i = 0;                        \
                               }                                             \
                            } else {                                         \
                               NUM_CLOG(p, s);                               \
                               NUM_CMUL(s, q, s);                            \
                               NUM_CEXP(s, s);                               \
                            }                                                \
                          }

#define NUM_CSQRT(p, s)   { Complex64 temp; temp.r = 0.5; temp.i=0;           \
                            NUM_CPOW(p, temp, s);                             \
                          }

#define NUM_CSQR(p, s)   { Complex64 temp; temp.r = 2.0; temp.i=0;            \
                            NUM_CPOW(p, temp, s);                             \
                          }

#define NUM_CSIN(p, s) { Float64 sp = sin((p).r);                             \
                         Float64 cp = cos((p).r);                             \
                         (s).r = cosh((p).i) * sp;                            \
                         (s).i = sinh((p).i) * cp;                            \
                       }

#define NUM_CCOS(p, s) { Float64 sp = sin((p).r);                             \
                         Float64 cp = cos((p).r);                             \
                         (s).r = cosh((p).i) * cp;                            \
                         (s).i = -sinh((p).i) * sp;                           \
                       }

#define NUM_CTAN(p, s) { Complex64 ss, cs;                                    \
                         NUM_CSIN(p, ss);                                     \
                         NUM_CCOS(p, cs);                                     \
                         NUM_CDIV(ss, cs, s);                                 \
                       }

#define NUM_CSINH(p, s) { Float64 sp = sin((p).i);                            \
                          Float64 cp = cos((p).i);                            \
                         (s).r = sinh((p).r) * cp;                            \
                         (s).i = cosh((p).r) * sp;                            \
                       }

#define NUM_CCOSH(p, s) { Float64 sp = sin((p).i);                            \
                          Float64 cp = cos((p).i);                            \
                         (s).r = cosh((p).r) * cp;                            \
                         (s).i = sinh((p).r) * sp;                            \
                       }

#define NUM_CTANH(p, s) { Complex64 ss, cs;                                   \
                         NUM_CSINH(p, ss);                                    \
                         NUM_CCOSH(p, cs);                                    \
                         NUM_CDIV(ss, cs, s);                                 \
                       }

#define NUM_CRPOW(p, v, s) { Complex64 cr; cr.r = v; cr.i = 0;                \
                             NUM_CPOW(p,cr,s);                                \
                           }

#define NUM_CRMUL(p, v, s) (s).r = (p).r * v;  (s).i = (p).i * v;

#define NUM_CIMUL(p, s)    { Float64 temp = (s).r;                            \
                             (s).r = -(p).i;  (s).i = temp;                   \
                           }

/* asin(z) = -i * log(i*z + (1 - z**2)**0.5) */
#define NUM_CASIN(p, s) { Complex64 p1;  NUM_CASS(p, p1);                     \
                         NUM_CIMUL(p, p1);                                    \
			 NUM_CMUL(p, p, s);                                   \
                         NUM_CNEG(s, s);                                      \
                         (s).r += 1;                                          \
                         NUM_CRPOW(s, 0.5, s);                                \
                         NUM_CADD(p1, s, s);                                  \
                         NUM_CLOG(s, s);                                      \
                         NUM_CIMUL(s, s);                                     \
                         NUM_CNEG(s, s);                                      \
                       }

/* acos(z) = -i * log(z + i*(1 - z**2)**0.5) */
#define NUM_CACOS(p, s) { Complex64 p1;  NUM_CASS(p, p1);                     \
 			 NUM_CMUL(p, p, s);                                   \
                         NUM_CNEG(s, s);                                      \
                         (s).r += 1;                                          \
                         NUM_CRPOW(s, 0.5, s);                                \
                         NUM_CIMUL(s, s);                                     \
                         NUM_CADD(p1, s, s);                                  \
                         NUM_CLOG(s, s);                                      \
                         NUM_CIMUL(s, s);                                     \
                         NUM_CNEG(s, s);                                      \
                       }

/* atan(z) = i/2 * log( (i+z) / (i - z) )  */
#define NUM_CATAN(p, s) { Complex64 p1, p2;                                   \
                         NUM_CASS(p, p1); NUM_CNEG(p, p2);                    \
                         p1.i += 1;                                           \
                         p2.i += 1;                                           \
                         NUM_CDIV(p1, p2, s);                                 \
                         NUM_CLOG(s, s);                                      \
                         NUM_CIMUL(s, s);                                     \
                         NUM_CRMUL(s, 0.5, s);                                \
                       }

/* asinh(z) = log( z + (z**2 + 1)**0.5 )   */
#define NUM_CASINH(p, s) { Complex64 p1;   NUM_CASS(p, p1);                   \
                          NUM_CMUL(p, p, s);                                  \
                          (s).r += 1;                                         \
                          NUM_CRPOW(s, 0.5, s);                               \
                          NUM_CADD(p1, s, s);                                 \
                          NUM_CLOG(s, s);                                     \
                        }

/* acosh(z) = log( z + (z**2 - 1)**0.5 )   */
#define NUM_CACOSH(p, s) { Complex64 p1;   NUM_CASS(p, p1);                   \
                          NUM_CMUL(p, p, s);                                  \
                          (s).r -= 1;                                         \
                          NUM_CRPOW(s, 0.5, s);                               \
                          NUM_CADD(p1, s, s);                                 \
                          NUM_CLOG(s, s);                                     \
                        }

/* atanh(z) = 1/2 * log( (1+z)/(1-z) )   */
#define NUM_CATANH(p, s) { Complex64 p1, p2;                                  \
                          NUM_CASS(p, p1); NUM_CNEG(p, p2);                   \
                          p1.r += 1;                                          \
                          p2.r += 1;                                          \
                          NUM_CDIV(p1, p2, s);                                \
                          NUM_CLOG(s, s);                                     \
                          NUM_CRMUL(s, 0.5, s);                               \
                        }


#define NUM_CMIN(p, q) (NUM_CLE(p, q) ? p : q)
#define NUM_CMAX(p, q) (NUM_CGE(p, q) ? p : q)

#define NUM_CNZ(p)      (((p).r != 0) || ((p).i != 0))
#define NUM_CLAND(p, q) (NUM_CNZ(p) & NUM_CNZ(q))
#define NUM_CLOR(p, q)  (NUM_CNZ(p)  | NUM_CNZ(q))
#define NUM_CLXOR(p, q) (NUM_CNZ(p) ^ NUM_CNZ(q))
#define NUM_CLNOT(p)    (!NUM_CNZ(p))

#define NUM_CFLOOR(p, s) (s).r = floor((p).r); (s).i = floor((p).i);
#define NUM_CCEIL(p, s) (s).r = ceil((p).r); (s).i = ceil((p).i);

#define NUM_CFABS(p, s)  (s).r = fabs((p).r);  (s).i = fabs((p).i);
#define NUM_CROUND(p, s) (s).r = num_round((p).r); (s).i = num_round((p).i);
#define NUM_CHYPOT(p, q, s) { Complex64 t;                                    \
                              NUM_CSQR(p, s);  NUM_CSQR(q, t);                \
                              NUM_CADD(s, t, s);                              \
                              NUM_CSQRT(s, s);                                \
                            }
                                                                                                                                                                                                                                                                       nummacro.h                                                                                          0100644 0001750 0001750 00000035426 12222104616 043006  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/numarray/include/numpy                             /* Primarily for compatibility with numarray C-API */

#if !defined(_ndarraymacro)
#define _ndarraymacro

/* The structs defined here are private implementation details of numarray
which are subject to change w/o notice.
*/

#define PY_BOOL_CHAR "b"
#define PY_INT8_CHAR "b"
#define PY_INT16_CHAR "h"
#define PY_INT32_CHAR "i"
#define PY_FLOAT32_CHAR "f"
#define PY_FLOAT64_CHAR "d"
#define PY_UINT8_CHAR "h"
#define PY_UINT16_CHAR "i"
#define PY_UINT32_CHAR "i" /* Unless longer int available */
#define PY_COMPLEX64_CHAR "D"
#define PY_COMPLEX128_CHAR "D"

#define PY_LONG_CHAR "l"
#define PY_LONG_LONG_CHAR "L"

#define pyFPE_DIVIDE_BY_ZERO  1
#define pyFPE_OVERFLOW        2
#define pyFPE_UNDERFLOW       4
#define pyFPE_INVALID         8

#define isNonZERO(x) (x != 0) /* to convert values to boolean 1's or 0's */

typedef enum
{
	NUM_CONTIGUOUS=1,
	NUM_NOTSWAPPED=0x0200,
	NUM_ALIGNED=0x0100,
	NUM_WRITABLE=0x0400,
	NUM_COPY=0x0020,

	NUM_C_ARRAY  = (NUM_CONTIGUOUS | NUM_ALIGNED | NUM_NOTSWAPPED),
	NUM_UNCONVERTED = 0
} NumRequirements;

#define UNCONVERTED 0
#define C_ARRAY     (NUM_CONTIGUOUS | NUM_NOTSWAPPED | NUM_ALIGNED)

#define MUST_BE_COMPUTED 2

#define NUM_FLOORDIVIDE(a,b,out) (out) = floor((a)/(b))

#define NA_Begin() Py_Initialize(); import_libnumarray();
#define NA_End()   NA_Done(); Py_Finalize();

#define NA_OFFSETDATA(num) ((void *) PyArray_DATA(num))

/* unaligned NA_COPY functions */
#define NA_COPY1(i, o)  (*(o) = *(i))
#define NA_COPY2(i, o)  NA_COPY1(i, o), NA_COPY1(i+1, o+1)
#define NA_COPY4(i, o)  NA_COPY2(i, o), NA_COPY2(i+2, o+2)
#define NA_COPY8(i, o)  NA_COPY4(i, o), NA_COPY4(i+4, o+4)
#define NA_COPY16(i, o) NA_COPY8(i, o), NA_COPY8(i+8, o+8)

/* byteswapping macros: these fail if i==o */
#define NA_SWAP1(i, o)  NA_COPY1(i, o)
#define NA_SWAP2(i, o)  NA_SWAP1(i, o+1), NA_SWAP1(i+1, o)
#define NA_SWAP4(i, o)  NA_SWAP2(i, o+2), NA_SWAP2(i+2, o)
#define NA_SWAP8(i, o)  NA_SWAP4(i, o+4), NA_SWAP4(i+4, o)
#define NA_SWAP16(i, o) NA_SWAP8(i, o+8), NA_SWAP8(i+8, o)

/* complex byteswaps must swap each part (real, imag) independently */
#define NA_COMPLEX_SWAP8(i, o)  NA_SWAP4(i, o), NA_SWAP4(i+4, o+4)
#define NA_COMPLEX_SWAP16(i, o) NA_SWAP8(i, o), NA_SWAP8(i+8, o+8)

/* byteswapping macros:  these work even if i == o */
#define NA_TSWAP1(i, o, t) NA_COPY1(i, t), NA_SWAP1(t, o)
#define NA_TSWAP2(i, o, t) NA_COPY2(i, t), NA_SWAP2(t, o)
#define NA_TSWAP4(i, o, t) NA_COPY4(i, t), NA_SWAP4(t, o)
#define NA_TSWAP8(i, o, t) NA_COPY8(i, t), NA_SWAP8(t, o)

/* fast copy functions for %N aligned i and o */
#define NA_ACOPY1(i, o) (((Int8    *)o)[0]   = ((Int8    *)i)[0])
#define NA_ACOPY2(i, o) (((Int16   *)o)[0]   = ((Int16   *)i)[0])
#define NA_ACOPY4(i, o) (((Int32   *)o)[0]   = ((Int32   *)i)[0])
#define NA_ACOPY8(i, o) (((Float64 *)o)[0]   = ((Float64 *)i)[0])
#define NA_ACOPY16(i, o) (((Complex64 *)o)[0]   = ((Complex64 *)i)[0])

/* from here down, type("ai") is NDInfo*  */

#define NA_PTR(ai)   ((char *) NA_OFFSETDATA((ai)))
#define NA_PTR1(ai, i)       (NA_PTR(ai) + \
                              (i)*PyArray_STRIDES(ai)[0])
#define NA_PTR2(ai, i, j)    (NA_PTR(ai) + \
                              (i)*PyArray_STRIDES(ai)[0] + \
                              (j)*PyArray_STRIDES(ai)[1])
#define NA_PTR3(ai, i, j, k) (NA_PTR(ai) + \
                              (i)*PyArray_STRIDES(ai)[0] + \
                              (j)*PyArray_STRIDES(ai)[1] + \
                              (k)*PyArray_STRIDES(ai)[2])

#define NA_SET_TEMP(ai, type, v) (((type *) &__temp__)[0] = v)

#define NA_SWAPComplex64 NA_COMPLEX_SWAP16
#define NA_SWAPComplex32 NA_COMPLEX_SWAP8
#define NA_SWAPFloat64   NA_SWAP8
#define NA_SWAPFloat32   NA_SWAP4
#define NA_SWAPInt64     NA_SWAP8
#define NA_SWAPUInt64    NA_SWAP8
#define NA_SWAPInt32     NA_SWAP4
#define NA_SWAPUInt32    NA_SWAP4
#define NA_SWAPInt16     NA_SWAP2
#define NA_SWAPUInt16    NA_SWAP2
#define NA_SWAPInt8      NA_SWAP1
#define NA_SWAPUInt8     NA_SWAP1
#define NA_SWAPBool      NA_SWAP1

#define NA_COPYComplex64 NA_COPY16
#define NA_COPYComplex32 NA_COPY8
#define NA_COPYFloat64   NA_COPY8
#define NA_COPYFloat32   NA_COPY4
#define NA_COPYInt64     NA_COPY8
#define NA_COPYUInt64    NA_COPY8
#define NA_COPYInt32     NA_COPY4
#define NA_COPYUInt32    NA_COPY4
#define NA_COPYInt16     NA_COPY2
#define NA_COPYUInt16    NA_COPY2
#define NA_COPYInt8      NA_COPY1
#define NA_COPYUInt8     NA_COPY1
#define NA_COPYBool      NA_COPY1

#ifdef __cplusplus
extern "C" {
#endif

#define _makeGetPb(type)		\
static type _NA_GETPb_##type(char *ptr)	\
{						\
	type temp;				\
	NA_SWAP##type(ptr, (char *)&temp);	\
	return temp;				\
}

#define _makeGetPa(type)	             	\
static type _NA_GETPa_##type(char *ptr)         \
{						\
	type temp;				\
	NA_COPY##type(ptr, (char *)&temp);	\
	return temp;				\
}

_makeGetPb(Complex64)
_makeGetPb(Complex32)
_makeGetPb(Float64)
_makeGetPb(Float32)
_makeGetPb(Int64)
_makeGetPb(UInt64)
_makeGetPb(Int32)
_makeGetPb(UInt32)
_makeGetPb(Int16)
_makeGetPb(UInt16)
_makeGetPb(Int8)
_makeGetPb(UInt8)
_makeGetPb(Bool)

_makeGetPa(Complex64)
_makeGetPa(Complex32)
_makeGetPa(Float64)
_makeGetPa(Float32)
_makeGetPa(Int64)
_makeGetPa(UInt64)
_makeGetPa(Int32)
_makeGetPa(UInt32)
_makeGetPa(Int16)
_makeGetPa(UInt16)
_makeGetPa(Int8)
_makeGetPa(UInt8)
_makeGetPa(Bool)

#undef _makeGetPb
#undef _makeGetPa

#define _makeSetPb(type)		\
static void _NA_SETPb_##type(char *ptr, type v)	\
{						\
	NA_SWAP##type(((char *)&v), ptr);	\
	return;					\
}

#define _makeSetPa(type) \
static void _NA_SETPa_##type(char *ptr, type v)	\
{						\
	NA_COPY##type(((char *)&v), ptr);	\
	return;					\
}

_makeSetPb(Complex64)
_makeSetPb(Complex32)
_makeSetPb(Float64)
_makeSetPb(Float32)
_makeSetPb(Int64)
_makeSetPb(UInt64)
_makeSetPb(Int32)
_makeSetPb(UInt32)
_makeSetPb(Int16)
_makeSetPb(UInt16)
_makeSetPb(Int8)
_makeSetPb(UInt8)
_makeSetPb(Bool)

_makeSetPa(Complex64)
_makeSetPa(Complex32)
_makeSetPa(Float64)
_makeSetPa(Float32)
_makeSetPa(Int64)
_makeSetPa(UInt64)
_makeSetPa(Int32)
_makeSetPa(UInt32)
_makeSetPa(Int16)
_makeSetPa(UInt16)
_makeSetPa(Int8)
_makeSetPa(UInt8)
_makeSetPa(Bool)

#undef _makeSetPb
#undef _makeSetPa

#ifdef __cplusplus
	}
#endif

/* ========================== ptr get/set ================================ */

/* byteswapping */
#define NA_GETPb(ai, type, ptr) _NA_GETPb_##type(ptr)

/* aligning */
#define NA_GETPa(ai, type, ptr) _NA_GETPa_##type(ptr)

/* fast (aligned, !byteswapped) */
#define NA_GETPf(ai, type, ptr) (*((type *) (ptr)))

#define NA_GETP(ai, type, ptr) \
   (PyArray_ISCARRAY(ai) ? NA_GETPf(ai, type, ptr) \
                   : (PyArray_ISBYTESWAPPED(ai) ? \
                                      NA_GETPb(ai, type, ptr) \
                                    : NA_GETPa(ai, type, ptr)))

/* NOTE:  NA_SET* macros cannot be used as values. */

/* byteswapping */
#define NA_SETPb(ai, type, ptr, v) _NA_SETPb_##type(ptr, v)

/* aligning */
#define NA_SETPa(ai, type, ptr, v) _NA_SETPa_##type(ptr, v)

/* fast (aligned, !byteswapped) */
#define NA_SETPf(ai, type, ptr, v) ((*((type *) ptr)) = (v))

#define NA_SETP(ai, type, ptr, v) \
    if (PyArray_ISCARRAY(ai)) { \
         NA_SETPf((ai), type, (ptr), (v)); \
    } else if (PyArray_ISBYTESWAPPED(ai)) { \
	 NA_SETPb((ai), type, (ptr), (v)); \
    } else \
         NA_SETPa((ai), type, (ptr), (v))

/* ========================== 1 index get/set ============================ */

/* byteswapping */
#define NA_GET1b(ai, type, i)    NA_GETPb(ai, type, NA_PTR1(ai, i))
/* aligning */
#define NA_GET1a(ai, type, i)    NA_GETPa(ai, type, NA_PTR1(ai, i))
/* fast (aligned, !byteswapped) */
#define NA_GET1f(ai, type, i)    NA_GETPf(ai, type, NA_PTR1(ai, i))
/* testing */
#define NA_GET1(ai, type, i)     NA_GETP(ai, type, NA_PTR1(ai, i))

/* byteswapping */
#define NA_SET1b(ai, type, i, v) NA_SETPb(ai, type, NA_PTR1(ai, i), v)
/* aligning */
#define NA_SET1a(ai, type, i, v) NA_SETPa(ai, type, NA_PTR1(ai, i), v)
/* fast (aligned, !byteswapped) */
#define NA_SET1f(ai, type, i, v) NA_SETPf(ai, type, NA_PTR1(ai, i), v)
/* testing */
#define NA_SET1(ai, type, i, v)  NA_SETP(ai, type,  NA_PTR1(ai, i), v)

/* ========================== 2 index get/set ============================= */

/* byteswapping */
#define NA_GET2b(ai, type, i, j)    NA_GETPb(ai, type, NA_PTR2(ai, i, j))
/* aligning */
#define NA_GET2a(ai, type, i, j)    NA_GETPa(ai, type, NA_PTR2(ai, i, j))
/* fast (aligned, !byteswapped) */
#define NA_GET2f(ai, type, i, j)    NA_GETPf(ai, type, NA_PTR2(ai, i, j))
/* testing */
#define NA_GET2(ai, type, i, j)     NA_GETP(ai, type, NA_PTR2(ai, i, j))

/* byteswapping */
#define NA_SET2b(ai, type, i, j, v) NA_SETPb(ai, type, NA_PTR2(ai, i, j), v)
/* aligning */
#define NA_SET2a(ai, type, i, j, v) NA_SETPa(ai, type, NA_PTR2(ai, i, j), v)
/* fast (aligned, !byteswapped) */
#define NA_SET2f(ai, type, i, j, v) NA_SETPf(ai, type, NA_PTR2(ai, i, j), v)

#define NA_SET2(ai, type, i, j,  v)  NA_SETP(ai, type,  NA_PTR2(ai, i, j), v)

/* ========================== 3 index get/set ============================= */

/* byteswapping */
#define NA_GET3b(ai, type, i, j, k)    NA_GETPb(ai, type, NA_PTR3(ai, i, j, k))
/* aligning */
#define NA_GET3a(ai, type, i, j, k)    NA_GETPa(ai, type, NA_PTR3(ai, i, j, k))
/* fast (aligned, !byteswapped) */
#define NA_GET3f(ai, type, i, j, k)    NA_GETPf(ai, type, NA_PTR3(ai, i, j, k))
/* testing */
#define NA_GET3(ai, type, i, j, k)     NA_GETP(ai, type, NA_PTR3(ai, i, j, k))

/* byteswapping */
#define NA_SET3b(ai, type, i, j, k, v) \
        NA_SETPb(ai, type, NA_PTR3(ai, i, j, k), v)
/* aligning */
#define NA_SET3a(ai, type, i, j, k, v) \
        NA_SETPa(ai, type, NA_PTR3(ai, i, j, k), v)
/* fast (aligned, !byteswapped) */
#define NA_SET3f(ai, type, i, j, k, v) \
        NA_SETPf(ai, type, NA_PTR3(ai, i, j, k), v)
#define NA_SET3(ai, type, i, j, k, v) \
        NA_SETP(ai, type,  NA_PTR3(ai, i, j, k), v)

/* ========================== 1D get/set ================================== */

#define NA_GET1Db(ai, type, base, cnt, out) \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) { \
               out[i] = NA_GETPb(ai, type, base); \
               base += stride; \
           } \
        }

#define NA_GET1Da(ai, type, base, cnt, out)                                   \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) {                                             \
               out[i] = NA_GETPa(ai, type, base);                             \
               base += stride;                                                \
           }                                                                  \
        }

#define NA_GET1Df(ai, type, base, cnt, out)                                   \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) {                                             \
               out[i] = NA_GETPf(ai, type, base);                             \
               base += stride;                                                \
           }                                                                  \
        }

#define NA_GET1D(ai, type, base, cnt, out)                                    \
        if (PyArray_ISCARRAY(ai)) {                                           \
	      NA_GET1Df(ai, type, base, cnt, out);                            \
        } else if (PyArray_ISBYTESWAPPED(ai)) {                               \
              NA_GET1Db(ai, type, base, cnt, out);                            \
        } else {                                                              \
              NA_GET1Da(ai, type, base, cnt, out);                            \
	}

#define NA_SET1Db(ai, type, base, cnt, in)                                    \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) {                                             \
               NA_SETPb(ai, type, base, in[i]);                               \
               base += stride;                                                \
           }                                                                  \
        }

#define NA_SET1Da(ai, type, base, cnt, in)                                    \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) {                                             \
               NA_SETPa(ai, type, base, in[i]);                               \
               base += stride;                                                \
           }                                                                  \
        }

#define NA_SET1Df(ai, type, base, cnt, in)                                    \
        { int i, stride = PyArray_STRIDES(ai)[PyArray_NDIM(ai)-1]; \
           for(i=0; i<cnt; i++) {                                             \
               NA_SETPf(ai, type, base, in[i]);                               \
               base += stride;                                                \
           }                                                                  \
        }

#define NA_SET1D(ai, type, base, cnt, out)                                    \
        if (PyArray_ISCARRAY(ai)) {                                           \
              NA_SET1Df(ai, type, base, cnt, out);                            \
        } else if (PyArray_ISBYTESWAPPED(ai)) {                               \
              NA_SET1Db(ai, type, base, cnt, out);                            \
        } else {                                                              \
	      NA_SET1Da(ai, type, base, cnt, out);                            \
	}

/* ========================== utilities ================================== */

#if !defined(MIN)
#define MIN(x,y) (((x)<=(y)) ? (x) : (y))
#endif

#if !defined(MAX)
#define MAX(x,y) (((x)>=(y)) ? (x) : (y))
#endif

#if !defined(ABS)
#define ABS(x) (((x) >= 0) ? (x) : -(x))
#endif

#define ELEM(x)  (sizeof(x)/sizeof(x[0]))

#define BOOLEAN_BITWISE_NOT(x) ((x) ^ 1)

#define NA_NBYTES(a) (PyArray_DESCR(a)->elsize * NA_elements(a))

#if defined(NA_SMP)
#define BEGIN_THREADS Py_BEGIN_ALLOW_THREADS
#define END_THREADS Py_END_ALLOW_THREADS
#else
#define BEGIN_THREADS
#define END_THREADS
#endif

#if !defined(NA_isnan)

#define U32(u) (* (Int32 *) &(u) )
#define U64(u) (* (Int64 *) &(u) )

#define NA_isnan32(u) \
  ( (( U32(u) & 0x7f800000) == 0x7f800000)  && ((U32(u) & 0x007fffff) != 0)) ? 1:0

#if !defined(_MSC_VER)
#define NA_isnan64(u) \
  ( (( U64(u) & 0x7ff0000000000000LL) == 0x7ff0000000000000LL)  && ((U64(u) & 0x000fffffffffffffLL) != 0)) ? 1:0
#else
#define NA_isnan64(u) \
  ( (( U64(u) & 0x7ff0000000000000i64) == 0x7ff0000000000000i64)  && ((U64(u) & 0x000fffffffffffffi64) != 0)) ? 1:0
#endif

#define NA_isnanC32(u) (NA_isnan32(((Complex32 *)&(u))->r) || NA_isnan32(((Complex32 *)&(u))->i))
#define NA_isnanC64(u) (NA_isnan64(((Complex64 *)&(u))->r) || NA_isnan64(((Complex64 *)&(u))->i))

#endif /* NA_isnan */


#endif /* _ndarraymacro */
                                                                                                                                                                                                                                          random/                                                                                             0040755 0001750 0001750 00000000000 12612224744 035644  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy                                                    randomkit.h                                                                                         0100644 0001750 0001750 00000012404 11777322267 040015  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy/random                                             /* Random kit 1.3 */

/*
 * Copyright (c) 2003-2005, Jean-Sebastien Roy (js@jeannot.org)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* @(#) $Jeannot: randomkit.h,v 1.24 2005/07/21 22:14:09 js Exp $ */

/*
 * Typical use:
 *
 * {
 *  rk_state state;
 *  unsigned long seed = 1, random_value;
 *
 *  rk_seed(seed, &state); // Initialize the RNG
 *  ...
 *  random_value = rk_random(&state); // Generate random values in [0..RK_MAX]
 * }
 *
 * Instead of rk_seed, you can use rk_randomseed which will get a random seed
 * from /dev/urandom (or the clock, if /dev/urandom is unavailable):
 *
 * {
 *  rk_state state;
 *  unsigned long random_value;
 *
 *  rk_randomseed(&state); // Initialize the RNG with a random seed
 *  ...
 *  random_value = rk_random(&state); // Generate random values in [0..RK_MAX]
 * }
 */

/*
 * Useful macro:
 *  RK_DEV_RANDOM: the device used for random seeding.
 *                 defaults to "/dev/urandom"
 */

#include <stddef.h>

#ifndef _RANDOMKIT_
#define _RANDOMKIT_

#define RK_STATE_LEN 624

typedef struct rk_state_
{
    unsigned long key[RK_STATE_LEN];
    int pos;
    int has_gauss; /* !=0: gauss contains a gaussian deviate */
    double gauss;

    /* The rk_state structure has been extended to store the following
     * information for the binomial generator. If the input values of n or p
     * are different than nsave and psave, then the other parameters will be
     * recomputed. RTK 2005-09-02 */

    int has_binomial; /* !=0: following parameters initialized for
                              binomial */
    double psave;
    long nsave;
    double r;
    double q;
    double fm;
    long m;
    double p1;
    double xm;
    double xl;
    double xr;
    double c;
    double laml;
    double lamr;
    double p2;
    double p3;
    double p4;

}
rk_state;

typedef enum {
    RK_NOERR = 0, /* no error */
    RK_ENODEV = 1, /* no RK_DEV_RANDOM device */
    RK_ERR_MAX = 2
} rk_error;

/* error strings */
extern char *rk_strerror[RK_ERR_MAX];

/* Maximum generated random value */
#define RK_MAX 0xFFFFFFFFUL

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Initialize the RNG state using the given seed.
 */
extern void rk_seed(unsigned long seed, rk_state *state);

/*
 * Initialize the RNG state using a random seed.
 * Uses /dev/random or, when unavailable, the clock (see randomkit.c).
 * Returns RK_NOERR when no errors occurs.
 * Returns RK_ENODEV when the use of RK_DEV_RANDOM failed (for example because
 * there is no such device). In this case, the RNG was initialized using the
 * clock.
 */
extern rk_error rk_randomseed(rk_state *state);

/*
 * Returns a random unsigned long between 0 and RK_MAX inclusive
 */
extern unsigned long rk_random(rk_state *state);

/*
 * Returns a random long between 0 and LONG_MAX inclusive
 */
extern long rk_long(rk_state *state);

/*
 * Returns a random unsigned long between 0 and ULONG_MAX inclusive
 */
extern unsigned long rk_ulong(rk_state *state);

/*
 * Returns a random unsigned long between 0 and max inclusive.
 */
extern unsigned long rk_interval(unsigned long max, rk_state *state);

/*
 * Returns a random double between 0.0 and 1.0, 1.0 excluded.
 */
extern double rk_double(rk_state *state);

/*
 * fill the buffer with size random bytes
 */
extern void rk_fill(void *buffer, size_t size, rk_state *state);

/*
 * fill the buffer with randombytes from the random device
 * Returns RK_ENODEV if the device is unavailable, or RK_NOERR if it is
 * On Unix, if strong is defined, RK_DEV_RANDOM is used. If not, RK_DEV_URANDOM
 * is used instead. This parameter has no effect on Windows.
 * Warning: on most unixes RK_DEV_RANDOM will wait for enough entropy to answer
 * which can take a very long time on quiet systems.
 */
extern rk_error rk_devfill(void *buffer, size_t size, int strong);

/*
 * fill the buffer using rk_devfill if the random device is available and using
 * rk_fill if is is not
 * parameters have the same meaning as rk_fill and rk_devfill
 * Returns RK_ENODEV if the device is unavailable, or RK_NOERR if it is
 */
extern rk_error rk_altfill(void *buffer, size_t size, int strong,
                            rk_state *state);

/*
 * return a random gaussian deviate with variance unity and zero mean.
 */
extern double rk_gauss(rk_state *state);

#ifdef __cplusplus
}
#endif

#endif /* _RANDOMKIT_ */
                                                                                                                                                                                                                                                            scipy/                                                                                              0040755 0001750 0001750 00000000000 12612224744 034343  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python                                                          weave/                                                                                              0040755 0001750 0001750 00000000000 12612224744 035452  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy                                                    blitz/                                                                                              0040755 0001750 0001750 00000000000 12612224744 036576  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave                                              blitz/                                                                                              0040755 0001750 0001750 00000000000 12612224744 037722  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz                                        applics.h                                                                                           0100644 0001750 0001750 00000032672 12160377112 041531  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/applics.h      Applicative template classes
 *
 * $Id: applics.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org    
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_APPLICS_H
#define BZ_APPLICS_H

#ifndef BZ_BLITZ_H
 #include <blitz/blitz.h>
#endif

#ifndef BZ_PROMOTE_H
 #include <blitz/promote.h>
#endif

#ifndef BZ_NUMTRAIT_H
 #include <blitz/numtrait.h>
#endif

BZ_NAMESPACE(blitz)

// These base classes are included for no other reason than to keep
// the applicative templates clustered together in a graphical
// class browser.
class ApplicativeTemplatesBase { };
class TwoOperandApplicativeTemplatesBase : public ApplicativeTemplatesBase { };
class OneOperandApplicativeTemplatesBase : public ApplicativeTemplatesBase { };

template<typename P_numtype1, typename P_numtype2>
class _bz_Add : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote; 
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x + y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Subtract : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;
 
    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x - y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Multiply : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x * y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Divide : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x / y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Mod : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x % y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_BitwiseXOR : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x ^ y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_BitwiseAnd : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x & y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_BitwiseOr : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x | y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_ShiftRight : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x >> y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_ShiftLeft : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x << y; }
};


template<typename P_numtype1, typename P_numtype2>
class _bz_Min : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return (x < y ? x : y); }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Max : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef BZ_PROMOTE(T_numtype1,T_numtype2) T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return (x > y ? x : y); }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Greater : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x > y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Less : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x < y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_GreaterOrEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x >= y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_LessOrEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x <= y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_Equal : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x == y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_NotEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x != y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_LogicalAnd : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x && y; }
};

template<typename P_numtype1, typename P_numtype2>
class _bz_LogicalOr : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool       T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x || y; }
};


template<typename P_numtype_in, typename P_numtype_out>
class _bz_Cast : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype_in T_numtype1;
    typedef P_numtype_out T_promote;
    typedef T_promote     T_numtype;

    static inline P_numtype_out apply(P_numtype_in x)
    { return P_numtype_out(x); }
};

template<typename P_numtype>
class _bz_LogicalNot : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype T_numtype1;
    typedef bool      T_promote;
    typedef T_promote T_numtype;

    static inline P_numtype apply(P_numtype x)
    { return !x; }
};

template<typename P_numtype>
class _bz_BitwiseNot : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype     T_numtype1;
    typedef T_numtype1    T_promote;
    typedef T_promote     T_numtype;

    static inline P_numtype apply(P_numtype x)
    { return ~x; }
};



/*****************************************************************************
 * Math Functions
 *****************************************************************************/

// Applicative templates for these functions are defined in
// <blitz/mathfunc.h>, which is included below:
//
// abs(i), labs(l)                     Absolute value
// acos(d), acols(ld)                  Inverse cosine
// acosh(d)                            Inverse hyperbolic cosine
// asin(d), asinl(ld)                  Inverse sine
// asinh(d)                            Inverse hyperbolic sine
// atan(d), atanl(ld)                  Inverse tangent
// atan2(d,d), atan2l(ld,ld)           Inverse tangent
// atanh(d)                            Inverse hyperbolic tangent
// cbrt(x)                             Cube root
// ceil(d), ceill(ld)                  Smallest f-int not less than x
// int class(d)                        Classification of x (FP_XXXXX)
// cos(d), cosl(ld)                    Cosine
// cosh(d), coshl(ld)                  Hyperbolic cosine
// copysign(d,d)                       Return 1st arg with same sign as 2nd
// drem(x,x)                           IEEE remainder
// exp(d), expl(ld)                    Exponential
// expm1(d)                            Exp(x)-1     
// erf(d), erfl(ld)                    Error function
// erfc(d), erfcl(ld)                  Complementary error function
// fabs(d), fabsl(ld)                  Floating point absolute value
// int finite(d)                       Nonzero if finite
// floor(d), floor(ld)                 Largest f-int not greater than x
// fmod(d,d), fmodl(ld,ld)             Floating point remainder
// frexp(d, int* e)                    Break into mantissa/exponent  (*)
// frexpl(ld, int* e)                  Break into mantissa/exponent  (*)
// gammaFunc(d)                        Gamma function (** needs special 
//                                     implementation using lgamma)
// hypot(d,d)                          Hypotenuse: sqrt(x*x+y*y)
// int ilogb(d)                        Integer unbiased exponent
// int isnan(d)                        Nonzero if NaNS or NaNQ
// int itrunc(d)                       Truncate and convert to integer
// j0(d)                               Bessel function first kind, order 0
// j1(d)                               Bessel function first kind, order 1
// jn(int, double)                     Bessel function first kind, order i
// ldexp(d,i), ldexpl(ld,i)            Compute d * 2^i
// lgamma(d), lgammald(ld)             Log absolute gamma
// log(d), logl(ld)                    Natural logarithm
// logb(d)                             Unbiased exponent (IEEE)
// log1p(d)                            Compute log(1 + x)
// log10(d), log10l(ld)                Logarithm base 10
// modf(d, int* i), modfl(ld, int* i)  Break into integral/fractional part
// double nearest(double)              Nearest floating point integer
// nextafter(d, d)                     Next representable neighbor of 1st
//                                     in direction of 2nd
// pow(d,d), pow(ld,ld)                Computes x ^ y
// d remainder(d,d)                    IEEE remainder
// d rint(d)                           Round to f-integer (depends on mode)
// d rsqrt(d)                          Reciprocal square root
// d scalb(d,d)                        Return x * (2^y)
// sin(d), sinl(ld)                    Sine 
// sinh(d), sinhl(ld)                  Hyperbolic sine
// sqr(x)                              Return x * x
// sqrt(d), sqrtl(ld)                  Square root
// tan(d), tanl(ld)                    Tangent
// tanh(d), tanhl(ld)                  Hyperbolic tangent
// trunc(d)                            Nearest f-int in the direction of 0
// unsigned uitrunc(d)                 Truncate and convert to unsigned
// int unordered(d,d)                  Nonzero if comparison is unordered
// y0(d)                               Bessel function 2nd kind, order 0
// y1(d)                               Bessel function 2nd kind, order 1
// yn(i,d)                             Bessel function 2nd kind, order d


BZ_NAMESPACE_END

#ifndef BZ_MATHFUNC_H
 #include <blitz/mathfunc.h>
#endif

#ifndef BZ_MATHF2_H
 #include <blitz/mathf2.h>
#endif

#endif // BZ_APPLICS_H
                                                                      array/                                                                                              0040755 0001750 0001750 00000000000 12612224744 041040  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  asexpr.h                                                                                            0100644 0001750 0001750 00000005600 12160377112 042505  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/asexpr.h  Declaration of the asExpr helper functions
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/
#ifndef BZ_ARRAYASEXPR_H
#define BZ_ARRAYASEXPR_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/asexpr.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

// The traits class asExpr converts arbitrary things to
// expression templatable operands.

//  Default to scalar.

template <typename T>
struct asExpr {
    typedef _bz_ArrayExprConstant<T> T_expr;
    static T_expr getExpr(const T& x) { return T_expr(x); }
};

//  Already an expression template term

template <typename T>
struct asExpr<_bz_ArrayExpr<T> > {
    typedef _bz_ArrayExpr<T> T_expr;
    static const T_expr& getExpr(const T_expr& x) { return x; }
};

//  An array operand

template <typename T,int N>
struct asExpr<Array<T,N> > {
    typedef FastArrayIterator<T,N> T_expr;
    static T_expr getExpr(const Array<T,N>& x) { return x.beginFast(); }
};

//  Index placeholder

template <int N>
struct asExpr<IndexPlaceholder<N> > {
    typedef IndexPlaceholder<N> T_expr;
    static T_expr getExpr(T_expr x) { return x; }
};

#ifdef BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS

//  A traits class that provides the return type of a binary operation.

template <template <typename T1> class OP, typename O1>
struct BzUnaryExprResult {
    typedef _bz_ArrayExpr<_bz_ArrayExprUnaryOp<
        typename asExpr<O1>::T_expr,
        OP<typename asExpr<O1>::T_expr::T_numtype> > > T_result;
};

template <template <typename T1, typename T2> class OP,
          typename O1, typename O2>
struct BzBinaryExprResult {
    typedef _bz_ArrayExpr<_bz_ArrayExprBinaryOp<
        typename asExpr<O1>::T_expr,
        typename asExpr<O2>::T_expr,
        OP<typename asExpr<O1>::T_expr::T_numtype,
           typename asExpr<O2>::T_expr::T_numtype> > > T_result;
};

template <template <typename T1, typename T2, typename T3> class OP,
          typename O1, typename O2, typename O3>
struct BzTernaryExprResult {
    typedef _bz_ArrayExpr<_bz_ArrayExprTernaryOp<
        typename asExpr<O1>::T_expr,
        typename asExpr<O2>::T_expr,
        typename asExpr<O3>::T_expr,
        OP<typename asExpr<O1>::T_expr::T_numtype,
           typename asExpr<O2>::T_expr::T_numtype,
           typename asExpr<O3>::T_expr::T_numtype> > > T_result;
};

#endif /* BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS */

BZ_NAMESPACE_END

#endif
                                                                                                                                cartesian.h                                                                                         0100644 0001750 0001750 00000023310 12160377112 043152  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/cartesian.h  Cartesian product of indirection containers
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_CARTESIAN_H
#define BZ_ARRAY_CARTESIAN_H

BZ_NAMESPACE(blitz)

/*
 * CartesianProduct<T_tuple,T_container> is an adaptor which represents
 * the cartesian product of several containers.  
 */

// forward declaration of iterator
template<typename T_tuple, typename T_container, int N_containers>
class CartesianProductIterator;

struct _cp_end_tag { };

template<typename T_tuple, typename T_container, int N_containers>
class CartesianProduct {
public:
    typedef T_tuple value_type;
    typedef T_tuple& reference;
    typedef const T_tuple& const_reference;
    typedef CartesianProductIterator<T_tuple,T_container,N_containers> iterator;
    typedef int difference_type;
    typedef int size_type;

    iterator begin()
    { return iterator(*this); }

    iterator end()
    { return iterator(_cp_end_tag()); }

    CartesianProduct(const T_container& container0, 
        const T_container& container1)
    { 
        BZPRECONDITION(N_containers == 2);
        containers_[0] = &container0;
        containers_[1] = &container1;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2)
    { 
        BZPRECONDITION(N_containers == 3);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3)
    { 
        BZPRECONDITION(N_containers == 4);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4)
    { 
        BZPRECONDITION(N_containers == 5);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5)
    { 
        BZPRECONDITION(N_containers == 6);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5,
        const T_container& container6)
    { 
        BZPRECONDITION(N_containers == 7);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
        containers_[6] = &container6;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5,
        const T_container& container6,
        const T_container& container7)
    { 
        BZPRECONDITION(N_containers == 8);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
        containers_[6] = &container6;
        containers_[7] = &container7;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5,
        const T_container& container6,
        const T_container& container7,
        const T_container& container8)
    { 
        BZPRECONDITION(N_containers == 9);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
        containers_[6] = &container6;
        containers_[7] = &container7;
        containers_[8] = &container8;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5,
        const T_container& container6,
        const T_container& container7,
        const T_container& container8,
        const T_container& container9)
    { 
        BZPRECONDITION(N_containers == 10);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
        containers_[6] = &container6;
        containers_[7] = &container7;
        containers_[8] = &container8;
        containers_[9] = &container9;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2,
        const T_container& container3,
        const T_container& container4,
        const T_container& container5,
        const T_container& container6,
        const T_container& container7,
        const T_container& container8,
        const T_container& container9,
        const T_container& container10)
    { 
        BZPRECONDITION(N_containers == 11);
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
        containers_[3] = &container3;
        containers_[4] = &container4;
        containers_[5] = &container5;
        containers_[6] = &container6;
        containers_[7] = &container7;
        containers_[8] = &container8;
        containers_[9] = &container9;
        containers_[10] = &container10;
    }

    const T_container& operator[](int i)
    { return *(containers_[i]); }

    void debugDump();

protected:
    const T_container* containers_[N_containers]; 
};

template<typename T_tuple, typename T_container, int N_containers>
void CartesianProduct<T_tuple,T_container,N_containers>::debugDump()
{
    cout << "Dump of CartesianProduct<..,..," << N_containers << ">" << endl;
    for (int i=0; i < N_containers; ++i)
    {
        cout << "Container " << (i+1) << ": ";
        _bz_typename T_container::const_iterator iter = containers_[i]->begin(),
            end = containers_[i]->end();
        for (; iter != end; ++iter)
            cout << (*iter) << '\t'; 
    }
}

template<typename T_tuple, typename T_container, int N_containers>
class CartesianProductIterator {
public:
    typedef _bz_typename T_container::const_iterator citerator;
    typedef CartesianProductIterator<T_tuple,T_container,N_containers> iterator;
    typedef CartesianProduct<T_tuple,T_container,N_containers> T_cp;

    CartesianProductIterator(T_cp& container)
    {
        for (int i=0; i < N_containers; ++i)
        {
            firstiters_[i] = container[i].begin();
            iters_[i] = firstiters_[i];
            enditers_[i] = container[i].end();
            tuple_[i] = *iters_[i];
        }

        endflag_ = false;
    }

    void operator++();

    CartesianProductIterator(_cp_end_tag)
    {
        endflag_ = true;
    }

    bool operator==(const iterator& x) const
    {
        return (endflag_ == x.endflag_);
    }

    bool operator!=(const iterator& x) const
    {   
        return endflag_ != x.endflag_;
    }

    const T_tuple& operator*() const
    { return tuple_; }

protected:
    citerator iters_[N_containers];
    citerator firstiters_[N_containers];
    citerator enditers_[N_containers];
    T_tuple   tuple_;
    bool      endflag_;
};

template<typename T_tuple, typename T_container, int N_containers>
void CartesianProductIterator<T_tuple, T_container, 
    N_containers>::operator++()
{
    // Usual stack-style increment
    const int Nminus1 = N_containers - 1;

    int i = Nminus1;

    // Short-circuit for most common case
    // (just increment the last iterator)

    if((++iters_[i]) != enditers_[i])
    {
        tuple_[i] = *iters_[i];
        return;
    }

    // Less common cases

    for (--i; i >= 0; --i)
    {
        ++iters_[i];
        if (iters_[i] != enditers_[i])
            break;
    }

    if (i == -1)
    {
        endflag_ = true;
        return;
    }

    tuple_[i] = *iters_[i];

    for (++i; i < N_containers; ++i)  
    {
        iters_[i] = firstiters_[i];
        tuple_[i] = *iters_[i];
    }
}

BZ_NAMESPACE_END

#endif // BZ_ARRAY_CARTESIAN_H

                                                                                                                                                                                                                                                                                                                        cgsolve.h                                                                                           0100644 0001750 0001750 00000007166 12160377112 042656  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/cgsolve.h  Basic conjugate gradient solver for linear systems
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_CGSOLVE_H
#define BZ_CGSOLVE_H

BZ_NAMESPACE(blitz)

template<typename T_numtype>
void dump(const char* name, Array<T_numtype,3>& A)
{
    T_numtype normA = 0;

    for (int i=A.lbound(0); i <= A.ubound(0); ++i)
    {
      for (int j=A.lbound(1); j <= A.ubound(1); ++j)
      {
        for (int k=A.lbound(2); k <= A.ubound(2); ++k)
        {
            T_numtype tmp = A(i,j,k);
            normA += ::fabs(tmp);
        }
      }
    }

    normA /= A.numElements();
    cout << "Average magnitude of " << name << " is " << normA << endl;
}

template<typename T_stencil, typename T_numtype, int N_rank, typename T_BCs>
int conjugateGradientSolver(T_stencil stencil,
    Array<T_numtype,N_rank>& x,
    Array<T_numtype,N_rank>& rhs, double haltrho, 
    const T_BCs& boundaryConditions)
{
    // NEEDS_WORK: only apply CG updates over interior; need to handle
    // BCs separately.

    // x = unknowns being solved for (initial guess assumed)
    // r = residual
    // p = descent direction for x
    // q = descent direction for r

    RectDomain<N_rank> interior = interiorDomain(stencil, x, rhs);

cout << "Interior: " << interior.lbound() << ", " << interior.ubound()
     << endl;

    // Calculate initial residual
    Array<T_numtype,N_rank> r = rhs.copy();
    r *= -1.0;

    boundaryConditions.applyBCs(x);

    applyStencil(stencil, r, x);

 dump("r after stencil", r);
 cout << "Slice through r: " << endl << r(23,17,Range::all()) << endl;
 cout << "Slice through x: " << endl << x(23,17,Range::all()) << endl;
 cout << "Slice through rhs: " << endl << rhs(23,17,Range::all()) << endl;

    r *= -1.0;

 dump("r", r);

    // Allocate the descent direction arrays
    Array<T_numtype,N_rank> p, q;
    allocateArrays(x.shape(), p, q);

    int iteration = 0;
    int converged = 0;
    T_numtype rho = 0.;
    T_numtype oldrho = 0.;

    const int maxIterations = 1000;

    // Get views of interior of arrays (without boundaries)
    Array<T_numtype,N_rank> rint = r(interior);
    Array<T_numtype,N_rank> pint = p(interior);
    Array<T_numtype,N_rank> qint = q(interior);
    Array<T_numtype,N_rank> xint = x(interior);

    while (iteration < maxIterations)
    {
        rho = sum(r * r);

        if ((iteration % 20) == 0)
            cout << "CG: Iter " << iteration << "\t rho = " << rho << endl;

        // Check halting condition
        if (rho < haltrho)
        {
            converged = 1;
            break;
        }

        if (iteration == 0)
        {
            p = r;
        }
        else {
            T_numtype beta = rho / oldrho;
            p = beta * p + r;
        }

        q = 0.;
//        boundaryConditions.applyBCs(p);
        applyStencil(stencil, q, p);

        T_numtype pq = sum(p*q);

        T_numtype alpha = rho / pq;

        x += alpha * p;
        r -= alpha * q;

        oldrho = rho;
        ++iteration;
    }

    if (!converged)
        cout << "Warning: CG solver did not converge" << endl;

    return iteration;
}

BZ_NAMESPACE_END

#endif // BZ_CGSOLVE_H
                                                                                                                                                                                                                                                                                                                                                                                                          convolve.h                                                                                          0100644 0001750 0001750 00000001724 12160377112 043041  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/convolve.h   One-dimensional convolution
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_CONVOLVE_H
#define BZ_ARRAY_CONVOLVE_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/convolve.h> must be included after <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

template<typename T>
Array<T,1> convolve(const Array<T,1>& B, const Array<T,1>& C);

BZ_NAMESPACE_END

#include <blitz/array/convolve.cc>

#endif // BZ_ARRAY_CONVOLVE_H
                                            domain.h                                                                                            0100644 0001750 0001750 00000010553 12160377112 042455  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/domain.h  Declaration of the RectDomain class
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_DOMAIN_H
#define BZ_DOMAIN_H

#include <blitz/tinyvec.h>
#include <blitz/range.h>

/*
 * Portions of this class were inspired by the "RectDomain" class
 * provided by the Titanium language (UC Berkeley).
 */

BZ_NAMESPACE(blitz)

template<int N_rank>
class RectDomain {

    typedef TinyVector<int,N_rank> Bounds;

public:

    RectDomain() { }
    RectDomain(const Bounds& lbound,const Bounds& ubound): lbound_(lbound),ubound_(ubound) { }
    RectDomain(const TinyVector<Range,N_rank>& bounds): lbound_(),ubound_() {
        for (int i=0;i<N_rank;++i) {
            lbound_(i) = bounds(i).first();
            ubound_(i) = bounds(i).last();
        }
    }

    // NEEDS_WORK: better constructors
    // RectDomain(Range, Range, ...)
    // RectDomain with any combination of Range and int

          Bounds& lbound()       { return lbound_; }
          Bounds& ubound()       { return ubound_; }
    const Bounds& lbound() const { return lbound_; }
    const Bounds& ubound() const { return ubound_; }

    int& lbound(const int i)       { return lbound_(i); }
    int& ubound(const int i)       { return ubound_(i); }
    int  lbound(const int i) const { return lbound_(i); }
    int  ubound(const int i) const { return ubound_(i); }

    Range operator[](const int rank) const { return Range(lbound_(rank), ubound_(rank)); }

    void shrink(const int amount) {
        lbound_ += amount;
        ubound_ -= amount;
    }

    void shrink(const int dim,const int amount) {
        lbound_(dim) += amount;
        ubound_(dim) -= amount;
    }

    void expand(const int amount) {
        lbound_ -= amount;
        ubound_ += amount;
    }

    void expand(const int dim,const int amount) {
        lbound_(dim) -= amount;
        ubound_(dim) += amount;
    }

private:

    Bounds lbound_;
    Bounds ubound_;
};

/*
 * StridedDomain added by Julian Cummings
 */

template<int N_rank>
class StridedDomain {

    typedef TinyVector<int,N_rank> Bounds;
    typedef TinyVector<int,N_rank> Strides;

public:

    StridedDomain(const Bounds& lbound,const Bounds& ubound,const Strides& stride):
        lbound_(lbound),ubound_(ubound),stride_(stride) { }

    // NEEDS_WORK: better constructors
    // StridedDomain(Range, Range, ...)
    // StridedDomain with any combination of Range and int

    const Bounds&  lbound() const { return lbound_; }
    const Bounds&  ubound() const { return ubound_; }
    const Strides& stride() const { return stride_; }

    int lbound(const int i) const { return lbound_(i); }
    int ubound(const int i) const { return ubound_(i); }
    int stride(const int i) const { return stride_(i); }

    Range operator[](const int rank) const { return Range(lbound_(rank),ubound_(rank),stride_(rank)); }

    void shrink(const int amount) {
        lbound_ += amount*stride_;
        ubound_ -= amount*stride_;
    }

    void shrink(const int dim,const int amount) {
        lbound_(dim) += amount*stride_(dim);
        ubound_(dim) -= amount*stride_(dim);
    }

    void expand(const int amount) {
        lbound_ -= amount*stride_;
        ubound_ += amount*stride_;
    }

    void expand(const int dim,const int amount) {
        lbound_(dim) -= amount*stride_(dim);
        ubound_(dim) += amount*stride_(dim);
    }

private:

    Bounds  lbound_;
    Bounds  ubound_;
    Strides stride_;
};


template<int N_rank>
inline RectDomain<N_rank>
strip(const TinyVector<int,N_rank>& startPosition,const int stripDimension,const int ubound) {
    BZPRECONDITION((stripDimension >= 0) && (stripDimension < N_rank));
    BZPRECONDITION(ubound >= startPosition(stripDimension));

    TinyVector<int,N_rank> endPosition = startPosition;
    endPosition(stripDimension) = ubound;
    return RectDomain<N_rank>(startPosition, endPosition);
}

BZ_NAMESPACE_END

#endif // BZ_DOMAIN_H
                                                                                                                                                     et.h                                                                                                0100644 0001750 0001750 00000002020 12160377112 041604  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/et.h  Include expression templates implementation for arrays
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_ET_H
#define BZ_ARRAY_ET_H

#ifdef BZ_NEW_EXPRESSION_TEMPLATES
 #include <blitz/array/newet.h>     // Expression templates
#else
 #include <blitz/array/bops.cc>     // Expression templates, two operands
 #include <blitz/array/uops.cc>     // Expression templates, math functions
 #include <blitz/array/misc.cc>     // Expression templates, miscellaneous
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                expr.h                                                                                              0100644 0001750 0001750 00000056303 12160377112 042167  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/expr.h     Array<T,N> expression templates
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYEXPR_H
#define BZ_ARRAYEXPR_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/expr.h> must be included via <blitz/array.h>
#endif

#include <blitz/ops.h>
#include <blitz/prettyprint.h>
#include <blitz/shapecheck.h>
#include <blitz/numinquire.h>

/*
 * The array expression templates iterator interface is followed by
 * these classes:
 *
 * FastArrayIterator          <blitz/array/fastiter.h>
 * _bz_ArrayExpr              <blitz/array/expr.h>
 * _bz_ArrayExprUnaryOp               "
 * _bz_ArrayExprBinaryOp              "
 * _bz_ArrayExprTernaryOp             "
 * _bz_ArrayExprConstant              "
 * _bz_ArrayMap               <blitz/array/map.h>
 * _bz_ArrayExprReduce        <blitz/array/reduce.h>
 * IndexPlaceholder           <blitz/indexexpr.h>
 */

BZ_NAMESPACE(blitz)

template<typename T1, typename T2>
class _bz_ExprPair {
public:
    _bz_ExprPair(const T1& a, const T2& b)
        : first_(a), second_(b)
    { }

    const T1& first() const
    { return first_; }

    const T2& second() const
    { return second_; }

protected:
    T1 first_;
    T2 second_;
};

template<typename T1, typename T2>
inline _bz_ExprPair<T1,T2> makeExprPair(const T1& a, const T2& b)
{
    return _bz_ExprPair<T1,T2>(a,b);
}

template<typename P_expr>
class _bz_ArrayExpr 
#ifdef BZ_NEW_EXPRESSION_TEMPLATES
    : public ETBase<_bz_ArrayExpr<P_expr> >
#endif
{

public:
    typedef P_expr T_expr;
    typedef _bz_typename T_expr::T_numtype T_numtype;
    typedef T_expr T_ctorArg1;
    typedef int    T_ctorArg2;    // dummy

    static const int 
        numArrayOperands = T_expr::numArrayOperands,
        numIndexPlaceholders = T_expr::numIndexPlaceholders,
        rank = T_expr::rank;

    _bz_ArrayExpr(const _bz_ArrayExpr<T_expr>& a)
#ifdef BZ_NEW_EXPRESSION_TEMPLATES
        : ETBase< _bz_ArrayExpr<T_expr> >(a), iter_(a.iter_)
#else
        : iter_(a.iter_)
#endif
    { }

#if defined(BZ_NEW_EXPRESSION_TEMPLATES) && ! defined(__MWERKS__)
    template<typename T>
    _bz_ArrayExpr(const T& a)
        : iter_(a)
    { }
#else

    _bz_ArrayExpr(BZ_ETPARM(T_expr) a)
        : iter_(a)
    { }
#if !defined(__MWERKS__)
    _bz_ArrayExpr(BZ_ETPARM(_bz_typename T_expr::T_ctorArg1) a)
        : iter_(a)
    { }
#endif
#endif

    template<typename T1, typename T2>
    _bz_ArrayExpr(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b)
        : iter_(a, b)
    { }

    template<typename T1, typename T2, typename T3>
    _bz_ArrayExpr(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b, BZ_ETPARM(T3) c)
        : iter_(a, b, c)
    { }

    template<typename T1, typename T2, typename T3, typename T4>
    _bz_ArrayExpr(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b, BZ_ETPARM(T3) c,
        BZ_ETPARM(T4) d) : iter_(a, b, c, d)
    { }

    template<typename T1, typename T2>
    _bz_ArrayExpr(const _bz_ExprPair<T1,T2>& pair)
        : iter_(pair.first(), pair.second())
    { }

    T_numtype operator*()
    { return *iter_; }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return iter_(i); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return iter_(i); }
#endif

    int ascending(int rank)
    { return iter_.ascending(rank); }

    int ordering(int rank)
    { return iter_.ordering(rank); }

    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    void push(int position)
    { iter_.push(position); }

    void pop(int position)
    { iter_.pop(position); }

    void advance()
    { iter_.advance(); }

    void advance(int n)
    { iter_.advance(n); }

    void loadStride(int rank)
    { iter_.loadStride(rank); }

    bool isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    { iter_.advanceUnitStride(); }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        // BZ_DEBUG_MESSAGE("_bz_ArrayExpr<>::canCollapse()");
        return iter_.canCollapse(outerLoopRank, innerLoopRank); 
    }

    T_numtype operator[](int i)
    { return iter_[i]; }

    T_numtype fastRead(int i)
    { return iter_.fastRead(i); }

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(BZ_STD_SCOPE(string) &str) const
    {
        prettyPrintFormat format(true);  // Terse formatting by default
        iter_.prettyPrint(str, format);
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    { iter_.prettyPrint(str, format); }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

protected:
    _bz_ArrayExpr() { }

    T_expr iter_;
};

struct bounds {
    static int compute_ascending(int BZ_DEBUG_PARAM(rank),
                                 int ascending1, int ascending2)
    {
        // The value INT_MIN indicates that there are no arrays
        // in a subtree of the expression.  This logic returns
        // whichever ascending is available.  If there are two
        // conflicting ascending values, this is an error.

        if (ascending1 == ascending2)
            return ascending1;
        else if (ascending1 == INT_MIN)
            return ascending2;
        else if (ascending2 == INT_MIN)
            return ascending1;

        BZ_DEBUG_MESSAGE("Two array operands have different"
            << endl << "ascending flags: for rank " << rank 
            << ", the flags are " << ascending1 << " and " 
            << ascending2 << endl);
        BZ_PRE_FAIL;
        return 0;
    }

    static int compute_ordering(int BZ_DEBUG_PARAM(rank),
                                int order1, int order2)
    {
        // The value INT_MIN indicates that there are no arrays
        // in a subtree of the expression.  This logic returns
        // whichever ordering is available.  If there are two
        // conflicting ordering values, this is an error.

        if (order1 == order2)
            return order1;
        else if (order1 == INT_MIN)
            return order2;
        else if (order2 == INT_MIN)
            return order1;

        BZ_DEBUG_MESSAGE("Two array operands have different"
            << endl << "orders: for rank " << rank << ", the orders are "
            << order1 << " and " << order2 << endl);
        BZ_PRE_FAIL;
        return 0;
    }

    static int compute_lbound(int BZ_DEBUG_PARAM(rank),
                              int lbound1, int lbound2)
    {
        // The value INT_MIN indicates that there are no arrays
        // in a subtree of the expression.  This logic returns
        // whichever lbound is available.  If there are two
        // conflicting lbound values, this is an error.

        if (lbound1 == lbound2)
            return lbound1;
        else if (lbound1 == INT_MIN)
            return lbound2;
        else if (lbound2 == INT_MIN)
            return lbound1;

        BZ_DEBUG_MESSAGE("Two array operands have different"
            << endl << "lower bounds: in rank " << rank << ", the bounds are "
            << lbound1 << " and " << lbound2 << endl);
        BZ_PRE_FAIL;
        return 0;
    }

    static int compute_ubound(int BZ_DEBUG_PARAM(rank),
                              int ubound1, int ubound2)
    {
        // The value INT_MAX indicates that there are no arrays
        // in a subtree of the expression.  This logic returns
        // whichever ubound is available.  If there are two
        // conflicting ubound values, this is an error.

        if (ubound1 == ubound2)
            return ubound1;
        else if (ubound1 == INT_MAX)
            return ubound2;
        else if (ubound2 == INT_MAX)
            return ubound1;

        BZ_DEBUG_MESSAGE("Two array operands have different"
            << endl << "upper bounds: in rank " << rank << ", the bounds are "
            << ubound1 << " and " << ubound2 << endl);
        BZ_PRE_FAIL;
        return 0;
    }
};

template<typename P_expr, typename P_op>
class _bz_ArrayExprUnaryOp {
public:
    typedef P_expr T_expr;
    typedef P_op T_op;
    typedef _bz_typename T_expr::T_numtype T_numtype1;
    typedef _bz_typename T_op::T_numtype T_numtype;
    typedef T_expr T_ctorArg1;
    typedef int    T_ctorArg2;    // dummy

    static const int 
        numArrayOperands = T_expr::numArrayOperands,
        numIndexPlaceholders = T_expr::numIndexPlaceholders,
        rank = T_expr::rank;

    _bz_ArrayExprUnaryOp(const _bz_ArrayExprUnaryOp<T_expr, T_op>& a)
        : iter_(a.iter_)
    { }

    _bz_ArrayExprUnaryOp(BZ_ETPARM(T_expr) a)
        : iter_(a)
    { }

    _bz_ArrayExprUnaryOp(_bz_typename T_expr::T_ctorArg1 a)
        : iter_(a)
    { }

#if BZ_TEMPLATE_CTOR_DOESNT_CAUSE_HAVOC
    template<typename T1>
    explicit _bz_ArrayExprUnaryOp(BZ_ETPARM(T1) a)
        : iter_(a)
    { }
#endif

    int ascending(int rank)
    { return iter_.ascending(rank); }

    int ordering(int rank)
    { return iter_.ordering(rank); }

    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    T_numtype operator*()
    { return T_op::apply(*iter_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return T_op::apply(iter_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return T_op::apply(iter_(i)); }
#endif

    void push(int position)
    {
        iter_.push(position);
    }

    void pop(int position)
    {
        iter_.pop(position);
    }

    void advance()
    {
        iter_.advance();
    }

    void advance(int n)
    {
        iter_.advance(n);
    }

    void loadStride(int rank)
    {
        iter_.loadStride(rank);
    }

    bool isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    {
        iter_.advanceUnitStride();
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        // BZ_DEBUG_MESSAGE("_bz_ArrayExprUnaryOp<>::canCollapse");
        return iter_.canCollapse(outerLoopRank, innerLoopRank); 
    }

    T_numtype operator[](int i)
    { return T_op::apply(iter_[i]); }

    T_numtype fastRead(int i)
    { return T_op::apply(iter_.fastRead(i)); }

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    { T_op::prettyPrint(str, format, iter_); }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

protected:
    _bz_ArrayExprUnaryOp() { }

    T_expr iter_;
};


template<typename P_expr1, typename P_expr2, typename P_op>
class _bz_ArrayExprBinaryOp {
public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef P_op T_op;
    typedef _bz_typename T_expr1::T_numtype T_numtype1;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef _bz_typename T_op::T_numtype T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;

    static const int 
        numArrayOperands = T_expr1::numArrayOperands
                         + T_expr2::numArrayOperands,
        numIndexPlaceholders = T_expr1::numIndexPlaceholders
                             + T_expr2::numIndexPlaceholders,
        rank = (T_expr1::rank > T_expr2::rank) 
             ? T_expr1::rank : T_expr2::rank;

    _bz_ArrayExprBinaryOp(
        const _bz_ArrayExprBinaryOp<T_expr1, T_expr2, T_op>& a)
        : iter1_(a.iter1_), iter2_(a.iter2_)
    { }

    template<typename T1, typename T2>
    _bz_ArrayExprBinaryOp(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b)
        : iter1_(a), iter2_(b)
    { }

    T_numtype operator*()
    { return T_op::apply(*iter1_, *iter2_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return T_op::apply(iter1_(i), iter2_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return T_op::apply(iter1_(i), iter2_(i)); }
#endif

    int ascending(int rank)
    {
        return bounds::compute_ascending(rank, iter1_.ascending(rank),
            iter2_.ascending(rank));
    }

    int ordering(int rank)
    {
        return bounds::compute_ordering(rank, iter1_.ordering(rank),
            iter2_.ordering(rank));
    }

    int lbound(int rank)
    { 
        return bounds::compute_lbound(rank, iter1_.lbound(rank),
            iter2_.lbound(rank));
    }

    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, iter1_.ubound(rank),
            iter2_.ubound(rank));
    }

    void push(int position)
    { 
        iter1_.push(position); 
        iter2_.push(position);
    }

    void pop(int position)
    { 
        iter1_.pop(position); 
        iter2_.pop(position);
    }

    void advance()
    { 
        iter1_.advance(); 
        iter2_.advance();
    }

    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
    }

    void loadStride(int rank)
    { 
        iter1_.loadStride(rank); 
        iter2_.loadStride(rank);
    }
    
    bool isUnitStride(int rank) const
    { return iter1_.isUnitStride(rank) && iter2_.isUnitStride(rank); }

    void advanceUnitStride()
    { 
        iter1_.advanceUnitStride(); 
        iter2_.advanceUnitStride();
    }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        // BZ_DEBUG_MESSAGE("_bz_ArrayExprBinaryOp<>::canCollapse");
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank);
    } 

    T_numtype operator[](int i)
    { return T_op::apply(iter1_[i], iter2_[i]); }

    T_numtype fastRead(int i)
    { return T_op::apply(iter1_.fastRead(i), iter2_.fastRead(i)); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        return (stride1 > stride2) ? stride1 : stride2;
    }

    bool isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) && iter2_.isStride(rank,stride);
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        T_op::prettyPrint(str, format, iter1_, iter2_);
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter1_.shapeCheck(shape) && iter2_.shapeCheck(shape); }

protected:
    _bz_ArrayExprBinaryOp() { }

    T_expr1 iter1_;
    T_expr2 iter2_; 
};

template<typename P_expr1, typename P_expr2, typename P_expr3, typename P_op>
class _bz_ArrayExprTernaryOp {
public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef P_expr3 T_expr3;
    typedef P_op T_op;
    typedef _bz_typename T_expr1::T_numtype T_numtype1;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef _bz_typename T_expr3::T_numtype T_numtype3;
    typedef _bz_typename T_op::T_numtype T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;
    typedef T_expr3 T_ctorArg3;

    static const int 
        numArrayOperands = T_expr1::numArrayOperands
                         + T_expr2::numArrayOperands
                         + T_expr3::numArrayOperands,
        numIndexPlaceholders = T_expr1::numIndexPlaceholders
                             + T_expr2::numIndexPlaceholders
                             + T_expr3::numIndexPlaceholders,
        rank = (T_expr1::rank > T_expr2::rank) 
             ? ((T_expr1::rank > T_expr3::rank)
                ? T_expr1::rank : T_expr3::rank)
             : ((T_expr2::rank > T_expr3::rank) 
                ? T_expr2::rank : T_expr3::rank);

    _bz_ArrayExprTernaryOp(
        const _bz_ArrayExprTernaryOp<T_expr1, T_expr2, T_expr3, T_op>& a)
        : iter1_(a.iter1_), iter2_(a.iter2_), iter3_(a.iter3_)
    { }

    template<typename T1, typename T2, typename T3>
    _bz_ArrayExprTernaryOp(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b, BZ_ETPARM(T3) c)
        : iter1_(a), iter2_(b), iter3_(c)
    { }

    T_numtype operator*()
    { return T_op::apply(*iter1_, *iter2_, *iter3_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return T_op::apply(iter1_(i), iter2_(i), iter3_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return T_op::apply(iter1_(i), iter2_(i), iter3_(i)); }
#endif

    int ascending(int rank)
    {
        return bounds::compute_ascending(rank, bounds::compute_ascending(
            rank, iter1_.ascending(rank), iter2_.ascending(rank)),
            iter3_.ascending(rank));
    }

    int ordering(int rank)
    {
        return bounds::compute_ordering(rank, bounds::compute_ordering(
            rank, iter1_.ordering(rank), iter2_.ordering(rank)),
            iter3_.ordering(rank));
    }

    int lbound(int rank)
    { 
        return bounds::compute_lbound(rank, bounds::compute_lbound(
            rank, iter1_.lbound(rank), iter2_.lbound(rank)), 
            iter3_.lbound(rank));
    }

    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, bounds::compute_ubound(
            rank, iter1_.ubound(rank), iter2_.ubound(rank)), 
            iter3_.ubound(rank));
    }

    void push(int position)
    { 
        iter1_.push(position); 
        iter2_.push(position);
        iter3_.push(position);
    }

    void pop(int position)
    { 
        iter1_.pop(position); 
        iter2_.pop(position);
        iter3_.pop(position);
    }

    void advance()
    { 
        iter1_.advance(); 
        iter2_.advance();
        iter3_.advance();
    }

    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
        iter3_.advance(n);
    }

    void loadStride(int rank)
    { 
        iter1_.loadStride(rank); 
        iter2_.loadStride(rank);
        iter3_.loadStride(rank);
    }
    
    bool isUnitStride(int rank) const
    {
        return iter1_.isUnitStride(rank)
            && iter2_.isUnitStride(rank)
            && iter3_.isUnitStride(rank);
    }

    void advanceUnitStride()
    { 
        iter1_.advanceUnitStride(); 
        iter2_.advanceUnitStride();
        iter3_.advanceUnitStride();
    }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        // BZ_DEBUG_MESSAGE("_bz_ArrayExprTernaryOp<>::canCollapse");
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank)
            && iter3_.canCollapse(outerLoopRank, innerLoopRank);
    } 

    T_numtype operator[](int i)
    { return T_op::apply(iter1_[i], iter2_[i], iter3_[i]); }

    T_numtype fastRead(int i)
    {
        return T_op::apply(iter1_.fastRead(i),
                           iter2_.fastRead(i),
                           iter3_.fastRead(i));
    }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        int stride3 = iter3_.suggestStride(rank);
        return stride1 > ( stride2 = (stride2>stride3 ? stride2 : stride3) ) ?
            stride1 : stride2;
    }

    bool isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride)
            && iter2_.isStride(rank,stride)
            && iter3_.isStride(rank,stride);
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
        iter3_.moveTo(i);
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        T_op::prettyPrint(str, format, iter1_, iter2_, iter3_);
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    {
        return iter1_.shapeCheck(shape)
            && iter2_.shapeCheck(shape)
            && iter3_.shapeCheck(shape);
    }

protected:
    _bz_ArrayExprTernaryOp() { }

    T_expr1 iter1_;
    T_expr2 iter2_; 
    T_expr3 iter3_; 
};


template<typename P_numtype>
class _bz_ArrayExprConstant {
public:
    typedef P_numtype T_numtype;
    typedef T_numtype T_ctorArg1;
    typedef int       T_ctorArg2;    // dummy

    static const int 
        numArrayOperands = 0, 
        numIndexPlaceholders = 0, 
        rank = 0;

    _bz_ArrayExprConstant(const _bz_ArrayExprConstant<T_numtype>& a)
        : value_(a.value_)
    { }

    _bz_ArrayExprConstant(T_numtype value)
        : value_(BZ_NO_PROPAGATE(value))
    { 
    }

    // tiny() and huge() return the smallest and largest representable
    // integer values.  See <blitz/numinquire.h>
    // NEEDS_WORK: use tiny(int()) once numeric_limits<T> available on
    // all platforms

    int ascending(int)
    { return INT_MIN; }

    int ordering(int)
    { return INT_MIN; }

    int lbound(int)
    { return INT_MIN; }

    int ubound(int)
    { return INT_MAX; }
    // NEEDS_WORK: use huge(int()) once numeric_limits<T> available on
    // all platforms

    T_numtype operator*()
    { return value_; }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int,N_rank>)
    { return value_; }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int,N_rank>&)
    { return value_; }
#endif

    void push(int) { }
    void pop(int) { }
    void advance() { }
    void advance(int) { }
    void loadStride(int) { }

    bool isUnitStride(int) const
    { return true; }

    void advanceUnitStride()
    { }

    bool canCollapse(int,int) const 
    { return true; }

    T_numtype operator[](int)
    { return value_; }

    T_numtype fastRead(int)
    { return value_; }

    int suggestStride(int) const
    { return 1; }

    bool isStride(int,int) const
    { return true; }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>&)
    {
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        if (format.tersePrintingSelected())
            str += format.nextScalarOperandSymbol();
        else
            str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_numtype);
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape&)
    { return true; }

protected:
    _bz_ArrayExprConstant() { }

    T_numtype value_;
};

BZ_NAMESPACE_END

#include <blitz/array/asexpr.h>

#endif // BZ_ARRAYEXPR_H

                                                                                                                                                                                                                                                                                                                             fastiter.h                                                                                          0100644 0001750 0001750 00000014734 12160377112 043034  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/iter.h     Declaration of FastArrayIterator<P_numtype,N_rank>
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_FASTITER_H
#define BZ_ARRAY_FASTITER_H

#ifdef BZ_HAVE_STD
 #include <sstream>
#else
 #include <strstream.h>
#endif

BZ_NAMESPACE(blitz)

#ifndef BZ_ARRAY_H
 #error <blitz/array/iter.h> must be included via <blitz/array.h>
#endif

template<typename P_numtype, int N_rank>
class FastArrayIterator {
public:
    typedef P_numtype                T_numtype;
    typedef Array<T_numtype, N_rank> T_array;
    typedef FastArrayIterator<P_numtype, N_rank> T_iterator;
    typedef const T_array& T_ctorArg1;
    typedef int            T_ctorArg2;    // dummy

    static const int 
        numArrayOperands = 1, 
        numIndexPlaceholders = 0,
        rank = N_rank;

    // NB: this ctor does NOT preserve stack and stride
    // parameters.  This is for speed purposes.
    FastArrayIterator(const FastArrayIterator<P_numtype, N_rank>& x)
        : data_(x.data_), array_(x.array_)
    { }

    void operator=(const FastArrayIterator<P_numtype, N_rank>& x)
    {
        array_ = x.array_;
        data_ = x.data_;
        stack_ = x.stack_;
        stride_ = x.stride_;
    }

    FastArrayIterator(const T_array& array)
        : array_(array)
    {
        data_   = array.data();
    }

    ~FastArrayIterator()
    { }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return array_(i); }
#else
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return array_(i); }
#endif

    int ascending(int rank)
    {
        if (rank < N_rank)
            return array_.isRankStoredAscending(rank);
        else
            return INT_MIN;   // tiny(int());
    }

    int ordering(int rank)
    {
        if (rank < N_rank)
            return array_.ordering(rank);
        else
            return INT_MIN;   // tiny(int());
    }

    int lbound(int rank)
    { 
        if (rank < N_rank)
            return array_.lbound(rank); 
        else
            return INT_MIN;   // tiny(int());
    }

    int ubound(int rank)
    { 
        if (rank < N_rank)
            return array_.ubound(rank); 
        else
            return INT_MAX;   // huge(int());
    }

    T_numtype operator*()
    { return *data_; }

    T_numtype operator[](int i)
    { return data_[i * stride_]; }

    T_numtype fastRead(int i)
    { return data_[i]; }

    int suggestStride(int rank) const
    { return array_.stride(rank); }

    bool isStride(int rank, int stride) const
    { return array_.stride(rank) == stride; }

    void push(int position)
    {
        stack_[position] = data_;
    }
  
    void pop(int position)
    { 
        data_ = stack_[position];
    }

    void advance()
    {
        data_ += stride_;
    }

    void advance(int n)
    {
        data_ += n * stride_;
    }

    void loadStride(int rank)
    {
        stride_ = array_.stride(rank);
    }

    const T_numtype * restrict data() const
    { return data_; }

    void _bz_setData(const T_numtype* ptr)
    { data_ = ptr; }

    int stride() const
    { return stride_; }

    bool isUnitStride(int rank) const
    { return array_.stride(rank) == 1; }

    void advanceUnitStride()
    { ++data_; }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { return array_.canCollapse(outerLoopRank, innerLoopRank); }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        if (format.tersePrintingSelected())
            str += format.nextArrayOperandSymbol();
        else if (format.dumpArrayShapesMode())
        {
#ifdef BZ_HAVE_STD
	    BZ_STD_SCOPE(ostringstream) ostr;
#else
            ostrstream ostr;
#endif
            ostr << array_.shape();
            str += ostr.str();
        }
        else {
            str += "Array<";
            str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_numtype);
            str += ",";

            char tmpBuf[10];
            sprintf(tmpBuf, "%d", N_rank);

            str += tmpBuf;
            str += ">";
        }
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return areShapesConformable(shape, array_.length()); }


    // Experimental
    T_numtype& operator()(int i)
    {
        return (T_numtype&)data_[i*array_.stride(0)];
    }

    // Experimental
    T_numtype& operator()(int i, int j)
    {
        return (T_numtype&)data_[i*array_.stride(0) + j*array_.stride(1)];
    }

    // Experimental
    T_numtype& operator()(int i, int j, int k)
    {
        return (T_numtype&)data_[i*array_.stride(0) + j*array_.stride(1)
          + k*array_.stride(2)];
    }

    // Experimental

    void moveTo(int i, int j)
    {
        data_ = &const_cast<T_array&>(array_)(i,j);
    }

    void moveTo(int i, int j, int k)
    {
        data_ = &const_cast<T_array&>(array_)(i,j,k);
    }

    void moveTo(const TinyVector<int,N_rank>& i)
    {
        data_ = &const_cast<T_array&>(array_)(i);
    }

    // Experimental
    void operator=(T_numtype x)
    {   *const_cast<T_numtype*>(data_) = x; }

    // Experimental
    template<typename T_value>
    void operator=(T_value x)
    {   *const_cast<T_numtype*>(data_) = x; }

    // Experimental
    template<typename T_value>
    void operator+=(T_value x)
    { *const_cast<T_numtype*>(data_) += x; }

    // NEEDS_WORK: other operators

    // Experimental
    operator T_numtype() const
    { return *data_; }

    // Experimental
    T_numtype shift(int offset, int dim)
    {
        return data_[offset*array_.stride(dim)];
    }

    // Experimental
    T_numtype shift(int offset1, int dim1, int offset2, int dim2)
    {
        return data_[offset1*array_.stride(dim1) 
            + offset2*array_.stride(dim2)];
    }

private:
    const T_numtype * restrict          data_;
    const T_array&                          array_;
    ConstPointerStack<T_numtype,N_rank>     stack_;
    int                                     stride_;
};

BZ_NAMESPACE_END

#endif // BZ_ARRAY_FASTITER_H
                                    funcs.h                                                                                             0100644 0001750 0001750 00000015151 12160377112 042323  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/funcs.h   Math functions on arrays
 *
 * $Id: funcs.h 1413 2005-11-01 22:04:15Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_FUNCS_H
#define BZ_ARRAY_FUNCS_H

#include <blitz/funcs.h>
#include <blitz/array/newet-macros.h>

BZ_NAMESPACE(blitz)
    
// unary functions
    
BZ_DECLARE_ARRAY_ET_UNARY(abs,   Fn_abs)
BZ_DECLARE_ARRAY_ET_UNARY(acos,  Fn_acos)
BZ_DECLARE_ARRAY_ET_UNARY(asin,  Fn_asin)
BZ_DECLARE_ARRAY_ET_UNARY(atan,  Fn_atan)
BZ_DECLARE_ARRAY_ET_UNARY(ceil,  Fn_ceil)
BZ_DECLARE_ARRAY_ET_UNARY(cexp,  Fn_exp)
BZ_DECLARE_ARRAY_ET_UNARY(cos,   Fn_cos)
BZ_DECLARE_ARRAY_ET_UNARY(cosh,  Fn_cosh)
BZ_DECLARE_ARRAY_ET_UNARY(csqrt, Fn_sqrt)
BZ_DECLARE_ARRAY_ET_UNARY(cube,  Fn_cube)
BZ_DECLARE_ARRAY_ET_UNARY(exp,   Fn_exp)
BZ_DECLARE_ARRAY_ET_UNARY(fabs,  Fn_fabs)
BZ_DECLARE_ARRAY_ET_UNARY(floor, Fn_floor)
BZ_DECLARE_ARRAY_ET_UNARY(log,   Fn_log)
BZ_DECLARE_ARRAY_ET_UNARY(log10, Fn_log10)
BZ_DECLARE_ARRAY_ET_UNARY(pow2,  Fn_sqr)
BZ_DECLARE_ARRAY_ET_UNARY(pow3,  Fn_cube)
BZ_DECLARE_ARRAY_ET_UNARY(pow4,  Fn_pow4)
BZ_DECLARE_ARRAY_ET_UNARY(pow5,  Fn_pow5)
BZ_DECLARE_ARRAY_ET_UNARY(pow6,  Fn_pow6)
BZ_DECLARE_ARRAY_ET_UNARY(pow7,  Fn_pow7)
BZ_DECLARE_ARRAY_ET_UNARY(pow8,  Fn_pow8)
BZ_DECLARE_ARRAY_ET_UNARY(sin,   Fn_sin)
BZ_DECLARE_ARRAY_ET_UNARY(sinh,  Fn_sinh)
BZ_DECLARE_ARRAY_ET_UNARY(sqr,   Fn_sqr)
BZ_DECLARE_ARRAY_ET_UNARY(sqrt,  Fn_sqrt)
BZ_DECLARE_ARRAY_ET_UNARY(tan,   Fn_tan)
BZ_DECLARE_ARRAY_ET_UNARY(tanh,  Fn_tanh)

#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DECLARE_ARRAY_ET_UNARY(arg,   Fn_arg)
BZ_DECLARE_ARRAY_ET_UNARY(conj,  Fn_conj)
BZ_DECLARE_ARRAY_ET_UNARY(imag,  Fn_imag)
BZ_DECLARE_ARRAY_ET_UNARY(norm,  Fn_norm)
BZ_DECLARE_ARRAY_ET_UNARY(real,  Fn_real)
#endif

#ifdef BZ_HAVE_IEEE_MATH
// finite and trunc omitted: blitz-bugs/archive/0189.html
BZ_DECLARE_ARRAY_ET_UNARY(acosh,  Fn_acosh)
BZ_DECLARE_ARRAY_ET_UNARY(asinh,  Fn_asinh)
BZ_DECLARE_ARRAY_ET_UNARY(atanh,  Fn_atanh)
BZ_DECLARE_ARRAY_ET_UNARY(cbrt,   Fn_cbrt)
BZ_DECLARE_ARRAY_ET_UNARY(erf,    Fn_erf)
BZ_DECLARE_ARRAY_ET_UNARY(erfc,   Fn_erfc)
BZ_DECLARE_ARRAY_ET_UNARY(expm1,  Fn_expm1)
// BZ_DECLARE_ARRAY_ET_UNARY(finite, Fn_finite)
BZ_DECLARE_ARRAY_ET_UNARY(ilogb,   Fn_ilogb)
BZ_DECLARE_ARRAY_ET_UNARY(blitz_isnan,  Fn_isnan)
BZ_DECLARE_ARRAY_ET_UNARY(j0,     Fn_j0)
BZ_DECLARE_ARRAY_ET_UNARY(j1,     Fn_j1)
BZ_DECLARE_ARRAY_ET_UNARY(lgamma, Fn_lgamma)
BZ_DECLARE_ARRAY_ET_UNARY(logb,   Fn_logb)
BZ_DECLARE_ARRAY_ET_UNARY(log1p,  Fn_log1p)
BZ_DECLARE_ARRAY_ET_UNARY(rint,   Fn_rint)
// BZ_DECLARE_ARRAY_ET_UNARY(trunc,  Fn_trunc)
BZ_DECLARE_ARRAY_ET_UNARY(y0,     Fn_y0)
BZ_DECLARE_ARRAY_ET_UNARY(y1,     Fn_y1)
#endif

#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DECLARE_ARRAY_ET_UNARY(_class,  Fn__class)
BZ_DECLARE_ARRAY_ET_UNARY(itrunc,  Fn_itrunc)
BZ_DECLARE_ARRAY_ET_UNARY(nearest, Fn_nearest)
BZ_DECLARE_ARRAY_ET_UNARY(rsqrt,   Fn_rsqrt)
BZ_DECLARE_ARRAY_ET_UNARY(uitrunc, Fn_uitrunc)
#endif
    
// cast() function
    
template<typename T_cast, typename T1>
_bz_inline_et
_bz_ArrayExpr<_bz_ArrayExprUnaryOp<_bz_typename asExpr<T1>::T_expr,
    Cast<_bz_typename asExpr<T1>::T_expr::T_numtype, T_cast> > >
cast(const ETBase<T1>& expr)
{
    return _bz_ArrayExpr<_bz_ArrayExprUnaryOp<
        _bz_typename asExpr<T1>::T_expr,
        Cast<_bz_typename asExpr<T1>::T_expr::T_numtype,T_cast> > >
        (expr.unwrap());
}

// binary functions

BZ_DECLARE_ARRAY_ET_BINARY(atan2,     Fn_atan2)
BZ_DECLARE_ARRAY_ET_BINARY(fmod,      Fn_fmod)
BZ_DECLARE_ARRAY_ET_BINARY(pow,       Fn_pow)

#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DECLARE_ARRAY_ET_BINARY(polar,     Fn_polar)
#endif
    
#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DECLARE_ARRAY_ET_BINARY(copysign,  Fn_copysign)
BZ_DECLARE_ARRAY_ET_BINARY(drem,      Fn_drem)
BZ_DECLARE_ARRAY_ET_BINARY(hypot,     Fn_hypot)
BZ_DECLARE_ARRAY_ET_BINARY(nextafter, Fn_nextafter)
BZ_DECLARE_ARRAY_ET_BINARY(remainder, Fn_remainder)
BZ_DECLARE_ARRAY_ET_BINARY(scalb,     Fn_scalb)
BZ_DECLARE_ARRAY_ET_BINARY(unordered, Fn_unordered)
#endif

#ifdef BZ_HAVE_SYSTEM_V_MATH

#define BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(sca)                   \
                                                                \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(atan2,     Fn_atan2, sca)     \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(fmod,      Fn_fmod, sca)      \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(pow,       Fn_pow, sca)       \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(copysign,  Fn_copysign, sca)  \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(drem,      Fn_drem, sca)      \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(hypot,     Fn_hypot, sca)     \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(nextafter, Fn_nextafter, sca) \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(remainder, Fn_remainder, sca) \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(scalb,     Fn_scalb, sca)     \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(unordered, Fn_unordered, sca) \

#else
    
#define BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(sca)                   \
                                                                \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(atan2,     Fn_atan2, sca)     \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(fmod,      Fn_fmod, sca)      \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(pow,       Fn_pow, sca)       \

#endif
    
BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(int)
BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(float)
BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(double)
BZ_DECLARE_ARRAY_ET_SCALAR_FUNCS(long double)
    
#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(polar,     Fn_polar, int)
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(polar,     Fn_polar, float)
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(polar,     Fn_polar, double)
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(polar,     Fn_polar, long double)
    
template<typename T1, typename T2>
inline _bz_ArrayExprBinaryOp<
    typename asExpr<complex<T1> >::T_expr,
    typename asExpr<T2>::T_expr, 
    Fn_pow<complex<T1>,typename asExpr<T2>::T_expr::T_numtype> >
pow(const complex<T1> d1, const ETBase<T2>& d2)
{
    return _bz_ArrayExprBinaryOp<
        typename asExpr<complex<T1> >::T_expr,
        typename asExpr<T2>::T_expr,
        Fn_pow<complex<T1>,typename asExpr<T2>::T_expr::T_numtype> >
        (asExpr<complex<T1> >::getExpr(d1),
         asExpr<T2>::getExpr(d2.unwrap()));
}

#endif
    
BZ_NAMESPACE_END

#endif // BZ_ARRAY_FUNCS_H
                                                                                                                                                                                                                                                                                                                                                                                                                       functorExpr.h                                                                                       0100644 0001750 0001750 00000122537 12160377112 043533  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/functorExpr.h   User-defined functors for arrays
 *
 * $Id: functorExpr.h 1413 2005-11-01 22:04:15Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
/* This header file is designed to allow the use of Blitz++ with 
   functors (classes defining an operator()) and more general member
   functions. It works best if you have access to the class source code;
   there is limited support for classes that cannot be modified. The best
   approach in that case is usually to write an adapter class.

   This works with class methods that take one, two or three arguments.

   If you have a functor, add the following to your (public) class declaration:

   BZ_DECLARE_FUNCTOR(classname)   // for one argument functors
   BZ_DECLARE_FUNCTOR2(classname)  // for two argument functors
   BZ_DECLARE_FUNCTOR3(classname)  // for three argument functors
   
   or

   BZ_DECLARE_FUNCTOR_RET(classname, returnType)
   BZ_DECLARE_FUNCTOR2_RET(classname, returnType)
   BZ_DECLARE_FUNCTOR3_RET(classname, returnType)

   for classes whose operator() has a return type that is not what you would
   deduce from the usual C++ promotion rules (e.g., takes two doubles and
   returns a bool).

   You can then use your class in Blitz++ expressions and no temporaries will
   be generated. For example, assuming that your class is named T, and that
   A, B and C are Arrays, you can write

   T classInstance( ... );
   A = C + classInstance(B * tensor::i);
   A = C + classInstance(tensor::i, tensor::j)

   It also works for member functions:
    
   BZ_DECLARE_MEMBER_FUNCTION(classname, funcname)
   BZ_DECLARE_MEMBER_FUNCTION2(classname, funcname)
   BZ_DECLARE_MEMBER_FUNCTION3(classname, funcname)
    
   or
    
   BZ_DECLARE_MEMBER_FUNCTION_RET(classname, funcname, returnType)
   BZ_DECLARE_MEMBER_FUNCTION2_RET(classname, funcname, returnType)
   BZ_DECLARE_MEMBER_FUNCTION3_RET(classname, funcname, returnType)

   allows you to write stuff like
    
   A = C + classInstance.funcname(B * tensor::i);
   A = C + classInstance.funcname(tensor::i, tensor::j)
    
   All the member functions to be applied must be declared const.
     
   There is also some support for classes where the source code is not
   available or not to be tampered with.  For example,
     
   A = C + applyFunctor(classInstance, B * tensor::i);
   A = C + applyFunctor(classInstance, tensor::i, tensor::j);
    
   This approach does not work for arbitrary member functions.  The
   class must be a proper functor with an operator().  

*/

#ifndef BZ_ARRAY_FUNCTOREXPR_H
#define BZ_ARRAY_FUNCTOREXPR_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/functorExpr.h> must be included via <blitz/array.h>
#endif

#include <blitz/prettyprint.h>
#include <blitz/shapecheck.h>
#include <blitz/tinyvec.h>

BZ_NAMESPACE(blitz)

template<typename P_functor, typename P_expr, typename P_result>
class _bz_FunctorExpr {
public:
    typedef P_functor T_functor;
    typedef P_expr T_expr;
    typedef _bz_typename T_expr::T_numtype T_numtype1;
    typedef P_result T_numtype;
    typedef T_expr    T_ctorArg1;
    typedef int       T_ctorArg2;    // dummy
    typedef int       T_ctorArg3;    // dummy

    static const int 
        numArrayOperands = T_expr::numArrayOperands,
	numIndexPlaceholders = T_expr::numIndexPlaceholders,
	rank = T_expr::rank;
    
    _bz_FunctorExpr(const _bz_FunctorExpr<P_functor,P_expr,P_result>& a)
        : f_(a.f_), iter_(a.iter_)
    { }
    
    _bz_FunctorExpr(BZ_ETPARM(T_functor) f, BZ_ETPARM(T_expr) a)
        : f_(f), iter_(a)
    { }

    _bz_FunctorExpr(BZ_ETPARM(T_functor) f, _bz_typename T_expr::T_ctorArg1 a)
        : f_(f), iter_(a)
    { }

#if BZ_TEMPLATE_CTOR_DOESNT_CAUSE_HAVOC
    template<typename T1>
    explicit _bz_FunctorExpr(BZ_ETPARM(T_functor) f, BZ_ETPARM(T1) a)
        : f_(f), iter_(a)
    { }
#endif

    T_numtype operator*()
    { return f_(*iter_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int,N_rank> i)
    { return f_(iter_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int,N_rank>& i)
    { return f_(iter_(i)); }
#endif

    int ascending(int rank)
    { return iter_.ascending(rank); }

    int ordering(int rank)
    { return iter_.ordering(rank); }

    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }
  
    void push(int position)
    { iter_.push(position); }

    void pop(int position)
    { iter_.pop(position); }

    void advance()
    { iter_.advance(); }

    void advance(int n)
    { iter_.advance(n); }

    void loadStride(int rank)
    { iter_.loadStride(rank); }

    bool isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    { iter_.advanceUnitStride(); }
  
    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        return iter_.canCollapse(outerLoopRank, innerLoopRank); 
    }

    T_numtype operator[](int i)
    { return f_(iter_[i]); }

    T_numtype fastRead(int i)
    { return f_(iter_.fastRead(i)); }

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_functor);
        str += "(";
        iter_.prettyPrint(str, format);
        str += ")";
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

protected:
    _bz_FunctorExpr() { }

    T_functor f_;
    T_expr iter_;
};

template<typename P_functor, typename P_expr1, typename P_expr2, typename P_result>
class _bz_FunctorExpr2 
{
public:
    typedef P_functor T_functor;
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef _bz_typename T_expr1::T_numtype T_numtype1;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef P_result T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr1 T_ctorArg2;
    typedef int T_ctorArg3;  // dummy

    static const int 
        numArrayOperands = T_expr1::numArrayOperands
                         + T_expr2::numArrayOperands,
	numIndexPlaceholders = T_expr1::numIndexPlaceholders
	                     + T_expr2::numIndexPlaceholders,
	rank = T_expr1::rank > T_expr2::rank
             ? T_expr1::rank : T_expr2::rank;
  
    _bz_FunctorExpr2(const _bz_FunctorExpr2<P_functor, P_expr1, P_expr2,
        P_result>& a) 
        : f_(a.f_), iter1_(a.iter1_), iter2_(a.iter2_)
    { }

    _bz_FunctorExpr2(BZ_ETPARM(T_functor) f, BZ_ETPARM(T_expr1) a,
        BZ_ETPARM(T_expr2) b)
        : f_(f), iter1_(a), iter2_(b)
    { }

    template<typename T1, typename T2>
    _bz_FunctorExpr2(BZ_ETPARM(T_functor) f, BZ_ETPARM(T1) a, BZ_ETPARM(T2) b) 
        : f_(f), iter1_(a), iter2_(b)
    { }
  
    T_numtype operator*()
    { return f_(*iter1_, *iter2_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return f_(iter1_(i), iter2_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return f_(iter1_(i), iter2_(i)); }
#endif

    int ascending(int rank)
    {
        return bounds::compute_ascending(rank, iter1_.ascending(rank),
            iter2_.ascending(rank));
    }

    int ordering(int rank)
    {
        return bounds::compute_ordering(rank, iter1_.ordering(rank),
            iter2_.ordering(rank));
    }
  
    int lbound(int rank)
    { 
        return bounds::compute_lbound(rank, iter1_.lbound(rank),
            iter2_.lbound(rank));
    }
  
    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, iter1_.ubound(rank),
            iter2_.ubound(rank));
    }
  
    void push(int position)
    { 
        iter1_.push(position); 
        iter2_.push(position);
    }
  
    void pop(int position)
    { 
        iter1_.pop(position); 
        iter2_.pop(position);
    }
  
    void advance()
    { 
        iter1_.advance(); 
        iter2_.advance();
    }
  
    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
    }
  
    void loadStride(int rank)
    {
        iter1_.loadStride(rank); 
        iter2_.loadStride(rank);
    }
  
    bool isUnitStride(int rank) const
    { return iter1_.isUnitStride(rank) && iter2_.isUnitStride(rank); }
  
    void advanceUnitStride()
    { 
        iter1_.advanceUnitStride(); 
        iter2_.advanceUnitStride();
    }
  
    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank);
    } 

    T_numtype operator[](int i)
    { return f_(iter1_[i], iter2_[i]); }

    T_numtype fastRead(int i)
    { return f_(iter1_.fastRead(i), iter2_.fastRead(i)); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        return ( stride1>stride2 ? stride1 : stride2 );
    }
  
    bool isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) && iter2_.isStride(rank,stride);
    }
  
    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_functor);
        str += "(";
        iter1_.prettyPrint(str, format);
        str += ",";
        iter2_.prettyPrint(str, format);
        str += ")";
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
    }
  
    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter1_.shapeCheck(shape) && iter2_.shapeCheck(shape); }
  
protected:
    _bz_FunctorExpr2() { }

    T_functor f_;
    T_expr1 iter1_;
    T_expr2 iter2_;
};

template<typename P_functor, typename P_expr1, typename P_expr2, typename P_expr3,
    class P_result>
class _bz_FunctorExpr3
{
public:
    typedef P_functor T_functor;
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef P_expr3 T_expr3;
    typedef _bz_typename T_expr1::T_numtype T_numtype1;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef _bz_typename T_expr3::T_numtype T_numtype3;
    typedef P_result T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;
    typedef T_expr3 T_ctorArg3;

    static const int 
        numArrayOperands = T_expr1::numArrayOperands
                         + T_expr2::numArrayOperands
                         + T_expr3::numArrayOperands,
	numIndexPlaceholders = T_expr1::numIndexPlaceholders
	                     + T_expr2::numIndexPlaceholders
	                     + T_expr3::numIndexPlaceholders,
	rank12 = T_expr1::rank > T_expr2::rank
	       ? T_expr1::rank : T_expr2::rank,
	rank = rank12 > T_expr3::rank ? rank12 : T_expr3::rank;
  
    _bz_FunctorExpr3(const _bz_FunctorExpr3<P_functor, P_expr1, P_expr2,
        P_expr3, P_result>& a) 
        : f_(a.f_), iter1_(a.iter1_), iter2_(a.iter2_), iter3_(a.iter3_)
    { }

    _bz_FunctorExpr3(BZ_ETPARM(T_functor) f, BZ_ETPARM(T_expr1) a,
        BZ_ETPARM(T_expr2) b, BZ_ETPARM(T_expr3) c)
        : f_(f), iter1_(a), iter2_(b), iter3_(c)
    { }

    template<typename T1, typename T2, typename T3>
    _bz_FunctorExpr3(BZ_ETPARM(T_functor) f, BZ_ETPARM(T1) a, BZ_ETPARM(T2) b,
        BZ_ETPARM(T3) c) 
        : f_(f), iter1_(a), iter2_(b), iter3_(c)
    { }
  
    T_numtype operator*()
    { return f_(*iter1_, *iter2_, *iter3_); }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i)
    { return f_(iter1_(i), iter2_(i), iter3_(i)); }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return f_(iter1_(i), iter2_(i), iter3_(i)); }
#endif

    int ascending(int rank)
    {
        return bounds::compute_ascending(rank, iter1_.ascending(rank),
            bounds::compute_ascending(rank, iter2_.ascending(rank),
            iter3_.ascending(rank)));
    }

    int ordering(int rank)
    {
        return bounds::compute_ordering(rank, iter1_.ordering(rank),
            bounds::compute_ordering(rank, iter2_.ordering(rank),
	    iter3_.ordering(rank)));
    }
  
    int lbound(int rank)
    { 
        return bounds::compute_lbound(rank, iter1_.lbound(rank),
            bounds::compute_lbound(rank, iter2_.lbound(rank),
	    iter3_.lbound(rank)));
    }
  
    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, iter1_.ubound(rank),
            bounds::compute_ubound(rank, iter2_.ubound(rank),
	    iter3_.ubound(rank)));
    }
  
    void push(int position)
    { 
        iter1_.push(position); 
        iter2_.push(position);
        iter3_.push(position);
    }
  
    void pop(int position)
    { 
        iter1_.pop(position); 
        iter2_.pop(position);
        iter3_.pop(position);
    }
  
    void advance()
    { 
        iter1_.advance(); 
        iter2_.advance();
        iter3_.advance();
    }
  
    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
        iter3_.advance(n);
    }
  
    void loadStride(int rank)
    { 
        iter1_.loadStride(rank); 
        iter2_.loadStride(rank);
        iter3_.loadStride(rank);
    }
  
    bool isUnitStride(int rank) const
    {
        return iter1_.isUnitStride(rank) && iter2_.isUnitStride(rank)
            && iter3_.isUnitStride(rank);
    }
  
    void advanceUnitStride()
    { 
        iter1_.advanceUnitStride(); 
        iter2_.advanceUnitStride();
        iter3_.advanceUnitStride();
    }
  
    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank)
            && iter3_.canCollapse(outerLoopRank, innerLoopRank);
    } 

    T_numtype operator[](int i)
    { return f_(iter1_[i], iter2_[i], iter3_[i]); }

    T_numtype fastRead(int i)
    { return f_(iter1_.fastRead(i), iter2_.fastRead(i), iter3_.fastRead(i)); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        int stride3 = iter3_.suggestStride(rank);
	return ( stride1 > (stride2 = (stride2>stride3 ? stride2 : stride3)) ?
            stride1 : stride2 );
    }
  
    bool isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) && iter2_.isStride(rank,stride)
            && iter3_.isStride(rank,stride);
    }
  
    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_functor);
        str += "(";
        iter1_.prettyPrint(str, format);
        str += ",";
        iter2_.prettyPrint(str, format);
        str += ",";
        iter3_.prettyPrint(str, format);
        str += ")";
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
        iter3_.moveTo(i);
    }
  
    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    {
        return iter1_.shapeCheck(shape) && iter2_.shapeCheck(shape)
            && iter3_.shapeCheck(shape);
    }
  
protected:
    _bz_FunctorExpr3() { }

    T_functor f_;
    T_expr1 iter1_;
    T_expr2 iter2_;
    T_expr3 iter3_;
};

template<typename P_functor, typename P_expr>
_bz_inline_et
_bz_ArrayExpr<_bz_FunctorExpr<P_functor, _bz_typename asExpr<P_expr>::T_expr,
    _bz_typename asExpr<P_expr>::T_expr::T_numtype> >
applyFunctor(const P_functor& f, const ETBase<P_expr>& a)
{
    typedef _bz_FunctorExpr<P_functor,
        _bz_typename asExpr<P_expr>::T_expr,
        _bz_typename asExpr<P_expr>::T_expr::T_numtype> f1;
    return _bz_ArrayExpr<f1>(f, a.unwrap());
}

template<typename P_functor, typename P_expr1, typename P_expr2>
_bz_inline_et
_bz_ArrayExpr<_bz_FunctorExpr2<P_functor,
    _bz_typename asExpr<P_expr1>::T_expr,
    _bz_typename asExpr<P_expr2>::T_expr,
    BZ_PROMOTE(_bz_typename asExpr<P_expr1>::T_expr::T_numtype,
               _bz_typename asExpr<P_expr2>::T_expr::T_numtype)> >
applyFunctor(const P_functor& f,
    const ETBase<P_expr1>& a, const ETBase<P_expr2>& b)
{
    typedef _bz_FunctorExpr2<P_functor,
        _bz_typename asExpr<P_expr1>::T_expr,
        _bz_typename asExpr<P_expr2>::T_expr,
        BZ_PROMOTE(_bz_typename asExpr<P_expr1>::T_expr::T_numtype,
                   _bz_typename asExpr<P_expr2>::T_expr::T_numtype)> f2;
    return _bz_ArrayExpr<f2>(f, a.unwrap(), b.unwrap());
}

template<typename P_functor, typename P_expr1, typename P_expr2, typename P_expr3>
_bz_inline_et
_bz_ArrayExpr<_bz_FunctorExpr3<P_functor,
    _bz_typename asExpr<P_expr1>::T_expr,
    _bz_typename asExpr<P_expr2>::T_expr, 
    _bz_typename asExpr<P_expr3>::T_expr,
    BZ_PROMOTE(_bz_typename asExpr<P_expr1>::T_expr::T_numtype,
	       BZ_PROMOTE(_bz_typename asExpr<P_expr2>::T_expr::T_numtype,
	                  _bz_typename asExpr<P_expr3>::T_expr::T_numtype))> >
applyFunctor(const P_functor& f, const ETBase<P_expr1>& a,
    const ETBase<P_expr2>& b, const ETBase<P_expr3>& c)
{
    typedef _bz_FunctorExpr3<P_functor,
        _bz_typename asExpr<P_expr1>::T_expr,
        _bz_typename asExpr<P_expr2>::T_expr,
        _bz_typename asExpr<P_expr3>::T_expr,
        BZ_PROMOTE(_bz_typename asExpr<P_expr1>::T_expr::T_numtype,
	    BZ_PROMOTE(_bz_typename asExpr<P_expr2>::T_expr::T_numtype,
	               _bz_typename asExpr<P_expr3>::T_expr::T_numtype))> f3;
    return _bz_ArrayExpr<f3>(f, a.unwrap(), b.unwrap(), c.unwrap());
}

BZ_NAMESPACE_END // End of stuff in namespace


#define _BZ_MAKE_FUNCTOR(classname, funcname)                             \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1>                                            \
    inline T_numtype1 operator()(T_numtype1 x) const                      \
    { return c_.funcname(x); }                                            \
private:                                                                  \
    const classname& c_;                                                  \
};

#define _BZ_MAKE_FUNCTOR2(classname, funcname)                            \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1, typename T_numtype2>                          \
    inline BZ_PROMOTE(T_numtype1, T_numtype2)                             \
    operator()(T_numtype1 x, T_numtype2 y) const                          \
    { return c_.funcname(x,y); }                                          \
private:                                                                  \
    const classname& c_;                                                  \
};

#define _BZ_MAKE_FUNCTOR3(classname, funcname)                            \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1, typename T_numtype2, typename T_numtype3>        \
    inline BZ_PROMOTE(BZ_PROMOTE(T_numtype1, T_numtype2), T_numtype3)     \
    operator()(T_numtype1 x, T_numtype2 y, T_numtype3 z) const            \
    { return c_.funcname(x,y,z); }                                        \
private:                                                                  \
    const classname& c_;                                                  \
};


#define _BZ_MAKE_FUNCTOR_RET(classname, funcname, ret)                    \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1>                                            \
    inline ret operator()(T_numtype1 x) const                             \
    { return c_.funcname(x); }                                            \
private:                                                                  \
    const classname& c_;                                                  \
};

#define _BZ_MAKE_FUNCTOR2_RET(classname, funcname, ret)                   \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1, typename T_numtype2>                          \
    inline ret operator()(T_numtype1 x, T_numtype2 y) const               \
    { return c_.funcname(x,y); }                                          \
private:                                                                  \
    const classname& c_;                                                  \
};

#define _BZ_MAKE_FUNCTOR3_RET(classname, funcname, ret)                   \
class _bz_Functor ## classname ## funcname                                \
{                                                                         \
public:                                                                   \
    _bz_Functor ## classname ## funcname (const classname& c)             \
        : c_(c)                                                           \
    { }                                                                   \
    template<typename T_numtype1, typename T_numtype2, typename T_numtype3>        \
    inline ret operator()(T_numtype1 x, T_numtype2 y, T_numtype3 z) const \
    { return c_.funcname(x,y,z); }                                        \
private:                                                                  \
    const classname& c_;                                                  \
};


#define BZ_DECLARE_FUNCTOR(classname)                                     \
template<typename P_expr>                                                 \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr)<            \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,                  \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr::T_numtype> >     \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr>& a) const                 \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr)<classname,                        \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,              \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr::T_numtype> > \
        (*this, a.unwrap());                                              \
}

#define BZ_DECLARE_FUNCTOR2(classname)                                    \
template<typename P_expr1, typename P_expr2>                              \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<           \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,        \
               _bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype)> >     \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b) const                \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<classname,                       \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,    \
                   _bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype)> > \
        (*this, a.unwrap(), b.unwrap());                                  \
}

#define BZ_DECLARE_FUNCTOR3(classname)                                    \
template<typename P_expr1, typename P_expr2, typename P_expr3>            \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<           \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,                 \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,        \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype,        \
               _bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr::T_numtype))> >    \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr3>& c) const                \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<classname,                       \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,             \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,    \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype,    \
                   _bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr::T_numtype))> >\
        (*this, a.unwrap(), b.unwrap(), c.unwrap());                      \
}


#define BZ_DECLARE_FUNCTOR_RET(classname, ret)                            \
template<typename P_expr>                                                 \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr)<            \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,                  \
    ret> >                                                                \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr>& a) const                 \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr)<classname,                        \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,              \
        ret> >                                                            \
        (*this, a.unwrap());                                              \
}

#define BZ_DECLARE_FUNCTOR2_RET(classname, ret)                           \
template<typename P_expr1, typename P_expr2>                              \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<           \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    ret> >                                                                \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b) const                \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<classname,                       \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        ret> >                                                            \
        (*this, a.unwrap(), b.unwrap());                                  \
}

#define BZ_DECLARE_FUNCTOR3_RET(classname, ret)                           \
template<typename P_expr1, typename P_expr2, typename P_expr3>            \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<           \
    classname,                                                            \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,                 \
    ret> >                                                                \
operator()(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b,                      \
           const BZ_BLITZ_SCOPE(ETBase)<P_expr3>& c) const                \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<classname,                       \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,             \
        ret> >                                                            \
        (*this, a.unwrap(), b.unwrap(), c.unwrap());                      \
}


#define BZ_DECLARE_MEMBER_FUNCTION(classname, funcname)                   \
_BZ_MAKE_FUNCTOR(classname, funcname)                                     \
template<typename P_expr>                                                 \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr)<            \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,                  \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr::T_numtype> >     \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr>& a) const                   \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr)<                                  \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,              \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr::T_numtype> > \
        (*this, a.unwrap());                                              \
}

#define BZ_DECLARE_MEMBER_FUNCTION2(classname, funcname)                  \
_BZ_MAKE_FUNCTOR2(classname, funcname)                                    \
template<typename P_expr1, typename P_expr2>                              \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<           \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,        \
               _bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype)> >     \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b) const                  \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<                                 \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,    \
                   _bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype)> > \
        (*this, a.unwrap(), b.unwrap());                                  \
}

#define BZ_DECLARE_MEMBER_FUNCTION3(classname, funcname)                  \
_BZ_MAKE_FUNCTOR3(classname, funcname)                                    \
template<typename P_expr1, typename P_expr2, typename P_expr3>            \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<           \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,                 \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,        \
    BZ_PROMOTE(_bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype,        \
               _bz_typename                                               \
               BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr::T_numtype))> >    \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr3>& c) const                  \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<                                 \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,             \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr::T_numtype,    \
        BZ_PROMOTE(_bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr::T_numtype,    \
                   _bz_typename                                           \
                   BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr::T_numtype))> >\
        (*this, a.unwrap(), b.unwrap(), c.unwrap());                      \
}


#define BZ_DECLARE_MEMBER_FUNCTION_RET(classname, funcname, ret)          \
_BZ_MAKE_FUNCTOR_RET(classname, funcname, ret)                            \
template<typename P_expr>                                                 \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr)<            \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,                  \
    ret> >                                                                \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr>& a) const                   \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr)<                                  \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr>::T_expr,              \
        ret> >                                                            \
        (*this, a.unwrap());                                              \
}

#define BZ_DECLARE_MEMBER_FUNCTION2_RET(classname, funcname, ret)         \
_BZ_MAKE_FUNCTOR2_RET(classname, funcname, ret)                           \
template<typename P_expr1, typename P_expr2>                              \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<           \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    ret> >                                                                \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b) const                  \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr2)<                                 \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        ret> >                                                            \
        (*this, a.unwrap(), b.unwrap());                                  \
}

#define BZ_DECLARE_MEMBER_FUNCTION3_RET(classname, funcname, ret)         \
_BZ_MAKE_FUNCTOR3_RET(classname, funcname, ret)                           \
template<typename P_expr1, typename P_expr2, typename P_expr3>            \
BZ_BLITZ_SCOPE(_bz_ArrayExpr)<BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<           \
    _bz_Functor ## classname ## funcname,                                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,                 \
    _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,                 \
    ret> >                                                                \
funcname(const BZ_BLITZ_SCOPE(ETBase)<P_expr1>& a,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr2>& b,                        \
         const BZ_BLITZ_SCOPE(ETBase)<P_expr3>& c) const                  \
{                                                                         \
    return BZ_BLITZ_SCOPE(_bz_ArrayExpr)<                                 \
        BZ_BLITZ_SCOPE(_bz_FunctorExpr3)<                                 \
        _bz_Functor ## classname ## funcname,                             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr1>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr2>::T_expr,             \
        _bz_typename BZ_BLITZ_SCOPE(asExpr)<P_expr3>::T_expr,             \
        ret> >                                                            \
        (*this, a.unwrap(), b.unwrap(), c.unwrap());                      \
}



#endif // BZ_ARRAY_FUNCTOREXPR_H

                                                                                                                                                                 geometry.h                                                                                          0100644 0001750 0001750 00000004332 12160377112 043037  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/geometry.h  Basic mapping from Array to physical geometry,
 *                         used for some stencil operations.
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_GEOMETRY_H
#define BZ_GEOMETRY_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/geometry.h> must be included after <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

typedef double T_defaultSpatialCoordinate;

template<int N_dim, typename T = T_defaultSpatialCoordinate>
class UniformOrthoGeometry {
public:
};

template<int N_dim, typename T = T_defaultSpatialCoordinate>
class UniformCubicGeometry {
    T h_;
    T recip_h_;
    T recip2_h_;
    T recip3_h_;
    TinyVector<T,N_dim> zero_;

public:
    typedef T T_coord;

    UniformCubicGeometry()
    {
        h_ = 0.0;
        recip_h_ = 0.0;
        recip2_h_ = 0.0;
        recip3_h_ = 0.0;
        zero_ = 0.0;
    }

    UniformCubicGeometry(T spatialStep)
    {
        h_ = spatialStep;
        zero_ = T(0);
        setup();
    }

    UniformCubicGeometry(T spatialStep, TinyVector<T,N_dim> zeroCoordinates)
    {   
        h_ = spatialStep;
        zero_ = zeroCoordinates;
        setup();
    }    

    TinyVector<T,N_dim> toSpatial(TinyVector<int,N_dim> logicalCoord) const
    {
        return zero_ + h_ * logicalCoord;
    }

    T spatialStep() const
    { return h_; }

    T recipSpatialStep() const
    { return recip_h_; }

    T recipSpatialStepPow2() const
    { return recip2_h_; }

private:
    void setup()
    {
        recip_h_ = 1.0 / h_;
        recip2_h_ = 1.0 / pow2(h_);
        recip3_h_ = 1.0 / pow3(h_);
    }
};

template<int N_dim, typename T = T_defaultSpatialCoordinate>
class TensorProductGeometry {
public:
};

BZ_NAMESPACE_END

#endif // BZ_GEOMETRY_H
                                                                                                                                                                                                                                                                                                      indirect.h                                                                                          0100644 0001750 0001750 00000054527 12160377112 043020  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/indirect.h  Array indirection
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/

#ifndef BZ_ARRAY_INDIRECT_H
#define BZ_ARRAY_INDIRECT_H

#include <blitz/array/asexpr.h>
#include <blitz/array/cartesian.h>

BZ_NAMESPACE(blitz)

template<typename T_array, typename T_index>
class IndirectArray {

public:
    IndirectArray(T_array& array, T_index& index)
        : array_(array), index_(index)
    { }

    template<typename T_expr>
    void operator=(T_expr expr);

protected:
    T_array& array_;
    T_index& index_;
};

// Forward declarations
template<typename T_array, typename T_arrayiter, typename T_subdomain, typename T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter,
    T_subdomain subdomain, T_expr expr);
template<typename T_array, typename T_arrayiter, int N_rank, typename T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter,
    RectDomain<N_rank> subdomain,
    T_expr expr);

template<typename T_array, typename T_index> template<typename T_rhs>
void IndirectArray<T_array, T_index>::operator=(T_rhs rhs)
{
    typedef _bz_typename asExpr<T_rhs>::T_expr T_expr;
    T_expr expr(rhs);

    _bz_typename T_array::T_iterator arrayIter(array_);

    _bz_typename T_index::iterator iter = index_.begin(),
                       end = index_.end();

    for (; iter != end; ++iter)
    {
        _bz_typename T_index::value_type subdomain = *iter;
        applyOverSubdomain(array_, arrayIter, subdomain, expr);
    }
}

template<typename T_array, typename T_arrayiter, typename T_subdomain, typename T_expr>
inline void applyOverSubdomain(const T_array& BZ_DEBUG_PARAM(array), T_arrayiter& arrayIter, 
    T_subdomain subdomain, T_expr expr)
{
    BZPRECHECK(array.isInRange(subdomain),
        "In indirection using an STL container of TinyVector<int,"
        << array.rank() << ">, one of the" << endl << "positions is out of"
        " range: " << endl << subdomain << endl
        << "Array lower bounds: " << array.lbound() << endl
        << "Array upper bounds: " << array.ubound() << endl)

    arrayIter.moveTo(subdomain);
    expr.moveTo(subdomain);

    *const_cast<_bz_typename T_arrayiter::T_numtype*>(arrayIter.data()) = *expr;
}

// Specialization for RectDomain<N>
template<typename T_array, typename T_arrayiter, int N_rank, typename T_expr>
inline void applyOverSubdomain(const T_array& BZ_DEBUG_PARAM(array), T_arrayiter& arrayIter, 
    RectDomain<N_rank> subdomain,
    T_expr expr)
{
    typedef _bz_typename T_array::T_numtype T_numtype;

    // Assume that the RectDomain<N_rank> is a 1-D strip.
    // Find the dimension in which the strip is oriented.  This
    // variable is static so that we cache the value; likely to be
    // the same for all strips within a container.

    static int stripDim = 0;

    if (subdomain.lbound(stripDim) == subdomain.ubound(stripDim))
    {
        // Cached value was wrong, find the correct value of stripDim
        for (stripDim=0; stripDim < N_rank; ++stripDim)
          if (subdomain.lbound(stripDim) != subdomain.ubound(stripDim))
            break;

        // Handle case where the strip is just a single point
        if (stripDim == N_rank)
            stripDim = 0;
    }

#ifdef BZ_DEBUG
    // Check that this is in fact a 1D strip
    for (int i=0; i < N_rank; ++i)
      if ((i != stripDim) && (subdomain.lbound(i) != subdomain.ubound(i)))
        BZPRECHECK(0, "In indirection using an STL container of RectDomain<"
          << N_rank << ">, one of" << endl << "the RectDomain objects was not"
          " a one-dimensional strip:" << endl << "RectDomain<" << N_rank
          << ">::lbound() = " << subdomain.lbound() << endl
          << "RectDomain<" << N_rank << ">::ubound() = " << subdomain.ubound())
#endif

    // Check that the start and end position are in range
    BZPRECHECK(array.isInRange(subdomain.lbound()),
        "In indirection using an STL container of RectDomain<"
        << N_rank << ">, one of" << endl << "the RectDomain objects has a"
        " lbound which is out of range:" << endl
        << subdomain.lbound() << endl
        << "Array lower bounds: " << array.lbound() << endl
        << "Array upper bounds: " << array.ubound() << endl)

    BZPRECHECK(array.isInRange(subdomain.ubound()),
        "In indirection using an STL container of RectDomain<"
        << N_rank << ">, one of" << endl << "the RectDomain objects has a"
        " ubound which is out of range:" << endl
        << subdomain.lbound() << endl
        << "Array lower bounds: " << array.lbound() << endl
        << "Array upper bounds: " << array.ubound() << endl)

    // Position at the beginning of the strip
    arrayIter.moveTo(subdomain.lbound());
    expr.moveTo(subdomain.lbound());

    // Loop through the strip

#ifdef BZ_USE_FAST_READ_ARRAY_EXPR

    bool useUnitStride = arrayIter.isUnitStride(stripDim)
          && expr.isUnitStride(stripDim);

    int lbound = subdomain.lbound(stripDim); 
    int ubound = subdomain.ubound(stripDim);

    if (useUnitStride)
    {
        T_numtype* restrict data = const_cast<T_numtype*>(arrayIter.data());

        int length = ubound - lbound + 1;
        for (int i=0; i < length; ++i)
            *data++ = expr.fastRead(i);
    }
    else {
#endif

    arrayIter.loadStride(stripDim);
    expr.loadStride(stripDim);

    for (int i=lbound; i <= ubound; ++i)
    {
        *const_cast<_bz_typename T_arrayiter::T_numtype*>(arrayIter.data()) 
            = *expr;
        expr.advance();
        arrayIter.advance();
    }

#ifdef BZ_USE_FAST_READ_ARRAY_EXPR
    }
#endif
}

// Global functions for cartesian product of index sets
template<typename T_container>
CartesianProduct<TinyVector<int,2>,T_container,2>
indexSet(const T_container& container0, const T_container& container1)
{
    return CartesianProduct<TinyVector<int,2>,T_container,2>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1));
}

template<typename T_container>
CartesianProduct<TinyVector<int,3>,T_container,3>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2)
{
    return CartesianProduct<TinyVector<int,3>,T_container,3>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2));
}

template<typename T_container>
CartesianProduct<TinyVector<int,4>,T_container,4>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3)
{
    return CartesianProduct<TinyVector<int,4>,T_container,4>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3));
}

template<typename T_container>
CartesianProduct<TinyVector<int,5>,T_container,5>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4)
{
    return CartesianProduct<TinyVector<int,5>,T_container,5>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4));
}

template<typename T_container>
CartesianProduct<TinyVector<int,6>,T_container,6>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5)
{
    return CartesianProduct<TinyVector<int,6>,T_container,6>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5));
}

template<typename T_container>
CartesianProduct<TinyVector<int,7>,T_container,7>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5,
    const T_container& container6)
{
    return CartesianProduct<TinyVector<int,7>,T_container,7>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5),
        const_cast<T_container&>(container6));
}

template<typename T_container>
CartesianProduct<TinyVector<int,8>,T_container,8>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5,
    const T_container& container6, const T_container& container7)
{
    return CartesianProduct<TinyVector<int,8>,T_container,8>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5),
        const_cast<T_container&>(container6),
        const_cast<T_container&>(container7));
}

template<typename T_container>
CartesianProduct<TinyVector<int,9>,T_container,9>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5,
    const T_container& container6, const T_container& container7,
    const T_container& container8)
{
    return CartesianProduct<TinyVector<int,9>,T_container,9>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5),
        const_cast<T_container&>(container6),
        const_cast<T_container&>(container7),
        const_cast<T_container&>(container8));
}

template<typename T_container>
CartesianProduct<TinyVector<int,10>,T_container,10>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5,
    const T_container& container6, const T_container& container7,
    const T_container& container8, const T_container& container9)
{
    return CartesianProduct<TinyVector<int,10>,T_container,10>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5),
        const_cast<T_container&>(container6),
        const_cast<T_container&>(container7),
        const_cast<T_container&>(container8),
        const_cast<T_container&>(container9));
}

template<typename T_container>
CartesianProduct<TinyVector<int,11>,T_container,11>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2, const T_container& container3,
    const T_container& container4, const T_container& container5,
    const T_container& container6, const T_container& container7,
    const T_container& container8, const T_container& container9,
    const T_container& container10)
{
    return CartesianProduct<TinyVector<int,11>,T_container,11>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2),
        const_cast<T_container&>(container3),
        const_cast<T_container&>(container4),
        const_cast<T_container&>(container5),
        const_cast<T_container&>(container6),
        const_cast<T_container&>(container7),
        const_cast<T_container&>(container8),
        const_cast<T_container&>(container9),
        const_cast<T_container&>(container10));
}

// Mixture of singletons and containers, e.g. A[indexSet(I,3,K)]

// cp_findContainerType<T1,T2,T3,...,Tn>::T_container
// The set of parameters T1, T2, T3, ... Tn is a mixture of
// int and T_container.  This traits class finds the container
// type, and sets T_container.
//
// e.g. cp_findContainerType<int,int,list<int>,int>::T_container is list<int>
//      cp_findContainerType<int,deque<int>,deque<int>>::T_container 
//        is deque<int>

template<typename T1, typename T2, typename T3=int, typename T4=int,
         typename T5=int, typename T6=int, typename T7=int, typename T8=int,
         typename T9=int, typename T10=int, typename T11=int>
struct cp_findContainerType {
    typedef T1 T_container;
};

template<typename T2, typename T3, typename T4, typename T5, typename T6,
         typename T7, typename T8, typename T9, typename T10, typename T11>
struct cp_findContainerType<int,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11> {
    typedef _bz_typename
        cp_findContainerType<T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>::T_container
        T_container;
};


// The cp_traits class handles promotion of singleton integers to
// containers.  It takes two template parameters:
//    T = argument type
//    T2 = container type
// If T is an integer, then a container of type T2 is created and the
// integer is inserted.  This container is returned.
// Otherwise, T is assumed to be the same type as T2, and the original
// container is returned.

template<typename T, typename T2>
struct cp_traits {
    typedef T T_container;

    static const T_container& make(const T& x)
    { return x; }
};

template<typename T2>
struct cp_traits<int,T2> {
    typedef T2 T_container;

    static T2 make(int x)
    { 
        T2 singleton;
        singleton.push_back(x);
        return singleton;
    }
};

// These versions of indexSet() allow mixtures of integer
// and container arguments.  At least one integer must be
// specified.

template<typename T1, typename T2>
CartesianProduct<TinyVector<int,2>, _bz_typename 
    cp_findContainerType<T1,T2>::T_container,2> 
indexSet(const T1& c1, const T2& c2)
{
    typedef _bz_typename cp_findContainerType<T1,T2>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,2>, T_container, 2>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2));
}

template<typename T1, typename T2, typename T3>
CartesianProduct<TinyVector<int,3>, _bz_typename
    cp_findContainerType<T1,T2,T3>::T_container, 3>
indexSet(const T1& c1, const T2& c2, const T3& c3)
{
    typedef _bz_typename cp_findContainerType<T1,T2,T3>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,3>, T_container, 3>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3));
}

template<typename T1, typename T2, typename T3, typename T4>
CartesianProduct<TinyVector<int,4>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4>::T_container, 4>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4)
{
    typedef _bz_typename cp_findContainerType<T1,T2,T3,T4>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,4>, T_container, 4>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5>
CartesianProduct<TinyVector<int,5>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5>::T_container, 5>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5)
{
    typedef _bz_typename cp_findContainerType<T1,T2,T3,T4,T5>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,5>, T_container, 5>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6>
CartesianProduct<TinyVector<int,6>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6>::T_container, 6>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6)
{
    typedef _bz_typename cp_findContainerType<T1,T2,T3,T4,T5,T6>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,6>, T_container, 6>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6, typename T7>
CartesianProduct<TinyVector<int,7>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6,T7>::T_container, 7>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6, const T7& c7)
{
    typedef _bz_typename
        cp_findContainerType<T1,T2,T3,T4,T5,T6,T7>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,7>, T_container, 7>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6),
          cp_traits<T7,T_container>::make(c7));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6, typename T7, typename T8>
CartesianProduct<TinyVector<int,8>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8>::T_container, 8>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6, const T7& c7, const T8& c8)
{
    typedef _bz_typename
        cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,8>, T_container, 8>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6),
          cp_traits<T7,T_container>::make(c7),
          cp_traits<T8,T_container>::make(c8));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6, typename T7, typename T8, typename T9>
CartesianProduct<TinyVector<int,9>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9>::T_container, 9>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6, const T7& c7, const T8& c8, const T9& c9)
{
    typedef _bz_typename
        cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,9>, T_container, 9>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6),
          cp_traits<T7,T_container>::make(c7),
          cp_traits<T8,T_container>::make(c8),
          cp_traits<T9,T_container>::make(c9));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6, typename T7, typename T8, typename T9, typename T10>
CartesianProduct<TinyVector<int,10>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>::T_container, 10>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6, const T7& c7, const T8& c8, const T9& c9, const T10& c10)
{
    typedef _bz_typename
        cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,10>, T_container, 10>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6),
          cp_traits<T7,T_container>::make(c7),
          cp_traits<T8,T_container>::make(c8),
          cp_traits<T9,T_container>::make(c9),
          cp_traits<T10,T_container>::make(c10));
}

template<typename T1, typename T2, typename T3, typename T4, typename T5,
         typename T6, typename T7, typename T8, typename T9, typename T10,
         typename T11>
CartesianProduct<TinyVector<int,11>, _bz_typename
    cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>::T_container, 11>
indexSet(const T1& c1, const T2& c2, const T3& c3, const T4& c4, const T5& c5,
    const T6& c6, const T7& c7, const T8& c8, const T9& c9, const T10& c10,
    const T11& c11)
{
    typedef _bz_typename
        cp_findContainerType<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,11>, T_container, 11>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3),
          cp_traits<T4,T_container>::make(c4),
          cp_traits<T5,T_container>::make(c5),
          cp_traits<T6,T_container>::make(c6),
          cp_traits<T7,T_container>::make(c7),
          cp_traits<T8,T_container>::make(c8),
          cp_traits<T9,T_container>::make(c9),
          cp_traits<T10,T_container>::make(c10),
          cp_traits<T11,T_container>::make(c11));
}

BZ_NAMESPACE_END

#endif // BZ_ARRAY_INDIRECT_H
                                                                                                                                                                         iter.h                                                                                              0100644 0001750 0001750 00000014341 12160377112 042150  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/iter.h  Basic iterator for arrays.
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_H
 #error <blitz/array/iter.h> must be included via <blitz/array.h>
#endif

#ifndef BZ_ARRAY_ITER_H
#define BZ_ARRAY_ITER_H

#ifdef BZ_HAVE_STL
#include <iterator>
#endif

BZ_NAMESPACE(blitz)

// helper class ConstPointerStack
template<typename P_numtype, int N_rank>
class ConstPointerStack {
public:
    typedef P_numtype                T_numtype;

    void operator=(const ConstPointerStack<P_numtype,N_rank>& rhs) 
    {
        for (int i=0; i<N_rank; ++i)
            stack_[i] = rhs.stack_[i];
    }

    const T_numtype*& operator[](int position)
    {
        return stack_[position];
    }
      
private:
    const T_numtype *                stack_[N_rank];
};


template<typename T, int N>
class ConstArrayIterator {
public:
    ConstArrayIterator() : data_(0) { }

    ConstArrayIterator(const Array<T,N>& array)
    {
        // Making internal copies of these avoids keeping
        // a pointer to the array and doing indirection.
        strides_ = array.stride();
        lbound_ = array.lbound();
        extent_ = array.extent();
        order_ = array.ordering();
        data_ = const_cast<T*>(array.dataFirst());

        maxRank_ = order_(0);
        stride_ = strides_(maxRank_);

        for (int i=0; i < N; ++i)
        {
            stack_[i] = data_;
            last_[i] = data_ + extent_(order_(i)) * strides_(order_(i));
        }

        pos_ = lbound_;
    }

    bool operator==(const ConstArrayIterator<T,N>& x) const 
    { 
        return data_ == x.data_; 
    }
    
    bool operator!=(const ConstArrayIterator<T,N>& x) const 
    { 
        return data_ != x.data_; 
    }
 
    const T& operator*() const
    {
        BZPRECHECK(data_ != 0, "Attempted to dereference invalid iterator "
             << "(empty array or past end of array)");
        return *data_;
    }

    const T* restrict operator->() const
    {
        BZPRECHECK(data_ != 0, "Attempted to dereference invalid iterator "
             << "(empty array or past end of array)");
        return data_;
    }

    ConstArrayIterator<T,N>& operator++();

    ConstArrayIterator<T,N> operator++(int)
    {
        ConstArrayIterator<T,N> tmp = *this;
        ++(*this); 
        return tmp;
    }

    // get the current position of the Array iterator in index space
    const TinyVector<int,N>& position() const
    { 
        BZPRECHECK(data_ != 0, "Array<T,N>::iterator::position() called on"
             << " invalid iterator");
        return pos_; 
    }
   
private:
    TinyVector<int,N> strides_, lbound_, extent_, order_;
    ConstPointerStack<T,N> stack_;
    ConstPointerStack<T,N> last_;
    int stride_;
    int maxRank_;

protected:
    TinyVector<int,N> pos_;
    T * restrict data_;
};


template<typename T, int N>
class ArrayIterator : public ConstArrayIterator<T,N> {
private:
    typedef ConstArrayIterator<T,N> T_base;
    using T_base::data_;

public:
    ArrayIterator() { }

    ArrayIterator(Array<T,N>& x) : T_base(x) { }

    T& operator*() const
    {
        BZPRECHECK(data_ != 0, "Attempted to dereference invalid iterator "
             << "(empty array or past end of array)");
        return *data_;
    }

    T* restrict operator->() const
    {
        BZPRECHECK(data_ != 0, "Attempted to dereference invalid iterator "
             << "(empty array or past end of array)");
        return data_;
    }

    ArrayIterator<T,N>& operator++()
    {
        T_base::operator++();
        return *this;
    }

    ArrayIterator<T,N> operator++(int)
    {
        ArrayIterator<T,N> tmp = *this;
        ++(*this); 
        return tmp;
    }
};


template<typename T, int N>
ConstArrayIterator<T,N>& ConstArrayIterator<T,N>::operator++()
{
    BZPRECHECK(data_ != 0, "Attempted to iterate past the end of an array.");

    data_ += stride_;

    if (data_ != last_[0])
    {
        // We hit this case almost all the time.
        ++pos_[maxRank_];
        return *this;
    }

    // We've hit the end of a row/column/whatever.  Need to
    // increment one of the loops over another dimension.

    int j = 1;
    for (; j < N; ++j)
    {
        int r = order_(j);
        data_ = const_cast<T*>(stack_[j]);
        data_ += strides_[r];
        ++pos_(r);

        if (data_ != last_[j])
            break;
    }

    // All done?
    if (j == N)
    {
        // Setting data_ to 0 indicates the end of the array has
        // been reached, and will match the end iterator.
        data_ = 0;
        return *this;
    }

    stack_[j] = data_;

    // Now reset all the last pointers
    for (--j; j >= 0; --j)
    {
        int r2 = order_(j);
        stack_[j] = data_;
        last_[j] = data_ + extent_(r2) * strides_(r2);
        pos_(r2) = lbound_(r2);
    }

    return *this;
}


BZ_NAMESPACE_END


#ifdef BZ_HAVE_STL
// support for std::iterator_traits
BZ_NAMESPACE(std)

template <typename T, int N>
struct iterator_traits< BZ_BLITZ_SCOPE(ConstArrayIterator)<T,N> > 
{
    typedef forward_iterator_tag               iterator_category;
    typedef T                                  value_type;
    typedef ptrdiff_t                          difference_type;
    typedef const T*                           pointer;
    typedef const T&                           reference;
};

template <typename T, int N>
struct iterator_traits< BZ_BLITZ_SCOPE(ArrayIterator)<T,N> > 
{
    typedef forward_iterator_tag               iterator_category;
    typedef T                                  value_type;
    typedef ptrdiff_t                          difference_type;
    typedef T*                                 pointer;
    typedef T&                                 reference;
};

BZ_NAMESPACE_END

#endif // BZ_HAVE_STL

#endif // BZ_ARRAY_ITER_H

                                                                                                                                                                                                                                                                                               map.h                                                                                               0100644 0001750 0001750 00000035124 12160377112 041764  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/map.h      Declaration of the ArrayIndexMapping class
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/

/*
 * ArrayIndexMapping is used to implement tensor array notation.  For
 * example:
 *
 * Array<float, 2> A, B;
 * firstIndex i;
 * secondIndex j;
 * thirdIndex k;
 * Array<float, 3> C = A(i,j) * B(j,k);
 *
 * For expression templates purposes, something like B(j,k) is represented
 * by an instance of class ArrayIndexMapping.  This class maps an array onto
 * the destination array coordinate system, e.g. B(j,k) -> C(i,j,k)
 */

#ifndef BZ_ARRAYMAP_H
#define BZ_ARRAYMAP_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/map.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

/*
 * _bz_doArrayIndexMapping is a helper class.  It is specialized for
 * ranks 1, 2, 3, ..., 11.
 */

template<int N_rank>
struct _bz_doArrayIndexMapping {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, N_rank>&, 
        const TinyVector<int,N_destRank>&, int, int, int, int, int, int,
        int, int, int, int, int)
    {
        // If you try to use an array index mapping on an array with
        // rank greater than 11, then you'll get a precondition failure
        // here.
        BZPRECONDITION(0);
        return T_numtype();
    }
};

template<>
struct _bz_doArrayIndexMapping<1> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 1>& array,
        const TinyVector<int,N_destRank>& index, int i0, int, int, int, int, 
        int, int, int, int, int, int)
    {
        return array(index[i0]);
    }
};


template<>
struct _bz_doArrayIndexMapping<2> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 2>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int, 
        int, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1]);
    }
};

template<>
struct _bz_doArrayIndexMapping<3> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 3>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2]);
    }
};

template<>
struct _bz_doArrayIndexMapping<4> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 4>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3]);
    }
};

template<>
struct _bz_doArrayIndexMapping<5> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 5>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4]);
    }
};

template<>
struct _bz_doArrayIndexMapping<6> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 6>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5]);
    }
};

template<>
struct _bz_doArrayIndexMapping<7> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 7>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6]);
    }
};

template<>
struct _bz_doArrayIndexMapping<8> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 8>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7]);
    }
};

template<>
struct _bz_doArrayIndexMapping<9> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 9>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8]);
    }
};

template<>
struct _bz_doArrayIndexMapping<10> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 10>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int i9, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8], index[i9]);
    }
};

template<>
struct _bz_doArrayIndexMapping<11> {
    template<typename T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 11>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8], index[i9],
            index[i10]);
    }
};

template<typename P_numtype, int N_rank, int N_map0, int N_map1=0, int N_map2=0,
    int N_map3=0, int N_map4=0, int N_map5=0, int N_map6=0, int N_map7=0, 
    int N_map8=0, int N_map9=0, int N_map10=0>
class ArrayIndexMapping {
public:
    typedef P_numtype T_numtype;
    typedef const Array<T_numtype,N_rank>& T_ctorArg1;
    typedef int                            T_ctorArg2;    // dummy

    /*
     * This enum block finds the maximum of the N_map0, N_map1, ..., N_map10
     * parameters and stores it in maxRank10.  The rank of the expression is
     * then maxRank10 + 1, since the IndexPlaceholders start at 0 rather than
     * 1.  
     */
    static const int
        maxRank1 = (N_map0 > N_map1) ? N_map0 : N_map1,
        maxRank2 = (N_map2 > maxRank1) ? N_map2 : maxRank1,
        maxRank3 = (N_map3 > maxRank2) ? N_map3 : maxRank2,
        maxRank4 = (N_map4 > maxRank3) ? N_map4 : maxRank3,
        maxRank5 = (N_map5 > maxRank4) ? N_map5 : maxRank4,
        maxRank6 = (N_map6 > maxRank5) ? N_map6 : maxRank5,
        maxRank7 = (N_map7 > maxRank6) ? N_map7 : maxRank6,
        maxRank8 = (N_map8 > maxRank7) ? N_map8 : maxRank7,
        maxRank9 = (N_map9 > maxRank8) ? N_map9 : maxRank8,
        maxRank10 = (N_map10 > maxRank9) ? N_map10 : maxRank9;

    static const int 
        numArrayOperands = 1, 
        numIndexPlaceholders = 1,
        rank = maxRank10 + 1;

    ArrayIndexMapping(const Array<T_numtype, N_rank>& array)
        : array_(array)
    { 
    }

    ArrayIndexMapping(const ArrayIndexMapping<T_numtype,N_rank,N_map0,
        N_map1,N_map2,N_map3,N_map4,N_map5,N_map6,N_map7,N_map8,N_map9,
        N_map10>& z)
        : array_(z.array_)
    { 
    }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_destRank>
    T_numtype operator()(TinyVector<int, N_destRank> i)
    {
        return _bz_doArrayIndexMapping<N_rank>::map(array_, i,
            N_map0, N_map1, N_map2, N_map3, N_map4, N_map5, N_map6,
            N_map7, N_map8, N_map9, N_map10);
    }
#else
    template<int N_destRank>
    T_numtype operator()(const TinyVector<int, N_destRank>& i)
    {
        return _bz_doArrayIndexMapping<N_rank>::map(array_, i,
            N_map0, N_map1, N_map2, N_map3, N_map4, N_map5, N_map6,
            N_map7, N_map8, N_map9, N_map10);
    }
#endif

    int ascending(int rank)
    {
        if (N_map0 == rank)
            return array_.isRankStoredAscending(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.isRankStoredAscending(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.isRankStoredAscending(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.isRankStoredAscending(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.isRankStoredAscending(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.isRankStoredAscending(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.isRankStoredAscending(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.isRankStoredAscending(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.isRankStoredAscending(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.isRankStoredAscending(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.isRankStoredAscending(10);
        else
            return INT_MIN;   // tiny(int());
    }

    int ordering(int rank)
    {
        if (N_map0 == rank)
            return array_.ordering(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.ordering(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.ordering(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.ordering(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.ordering(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.ordering(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.ordering(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.ordering(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.ordering(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.ordering(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.ordering(10);
        else
            return INT_MIN;   // tiny(int());
    }

    int lbound(int rank)
    { 
        if (N_map0 == rank)    
            return array_.lbound(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.lbound(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.lbound(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.lbound(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.lbound(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.lbound(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.lbound(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.lbound(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.lbound(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.lbound(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.lbound(10);
        else
            return INT_MIN;   // tiny(int());
    }

    int ubound(int rank)
    {   
        if (N_map0 == rank)
            return array_.ubound(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.ubound(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.ubound(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.ubound(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.ubound(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.ubound(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.ubound(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.ubound(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.ubound(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.ubound(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.ubound(10);
        else
            return INT_MAX;   // huge(int());
    }

    // If you have a precondition failure on this routine, it means
    // you are trying to use stack iteration mode on an expression
    // which contains an index placeholder.  You must use index
    // iteration mode instead.
    int operator*()
    {
        BZPRECONDITION(0);
        return 0;
    }

    // See operator*() note
    void push(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void pop(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void advance()
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void advance(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void loadStride(int)
    {
        BZPRECONDITION(0);
    }

    bool isUnitStride(int) const
    {
        BZPRECONDITION(0);
        return false;
    }

    void advanceUnitStride()
    {
        BZPRECONDITION(0);
    }

    bool canCollapse(int,int) const
    {   BZPRECONDITION(0);  return false; }

    T_numtype operator[](int)
    {   
        BZPRECONDITION(0);
        return T_numtype();
    }

    T_numtype fastRead(int)
    {
        BZPRECONDITION(0);
        return T_numtype();
    }

    int suggestStride(int) const
    {
        BZPRECONDITION(0);
        return 0;
    }

    bool isStride(int,int) const
    {
        BZPRECONDITION(0);
        return true;
    }

    template<int N_rank2>
    void moveTo(const TinyVector<int,N_rank2>&)
    {
        BZPRECONDITION(0);
        return ;
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat&) const
    {
        // NEEDS_WORK-- do real formatting for reductions
        str += "map[NEEDS_WORK]";
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape&) const
    { 
        // NEEDS_WORK-- do a real shape check (tricky)
        return true; 
    }

private:
    ArrayIndexMapping() : array_( Array<T_numtype, N_rank>() ) { }

    const Array<T_numtype, N_rank>& array_;
};

BZ_NAMESPACE_END

#endif // BZ_ARRAYMAP_H

                                                                                                                                                                                                                                                                                                                                                                                                                                            multi.h                                                                                             0100644 0001750 0001750 00000004514 12160377112 042340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/multi.h  Support for multicomponent arrays
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYMULTI_H
#define BZ_ARRAYMULTI_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/multi.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

/*
 * The multicomponent_traits class provides a mapping from multicomponent
 * tuples to the element type they contain.  For example:
 *
 * multicomponent_traits<complex<float> >::T_numtype is float,
 * multicomponent_traits<TinyVector<int,3> >::T_numtype is int.
 *
 * This is used to support Array<T,N>::operator[], which extracts components
 * from a multicomponent array.
 */

// By default, produce a harmless component type, and zero components.
template<typename T_component>
struct multicomponent_traits {
    typedef T_component T_element;
    static const int numComponents = 0;
};

// TinyVector
template<typename T_numtype, int N_rank>
struct multicomponent_traits<TinyVector<T_numtype,N_rank> > {
    typedef T_numtype T_element;
    static const int numComponents = N_rank;
};

#ifdef BZ_HAVE_COMPLEX
// complex<T>
template<typename T>
struct multicomponent_traits<complex<T> > {
    typedef T T_element;
    static const int numComponents = 2;
};
#endif

// This macro is provided so that users can register their own
// multicomponent types.

#define BZ_DECLARE_MULTICOMPONENT_TYPE(T_tuple,T,N)          \
  BZ_NAMESPACE(blitz)                                        \
  template<>                                                 \
  struct multicomponent_traits<T_tuple > {                   \
    typedef T T_element;                                     \
    static const int numComponents = N;                      \
  };                                                         \
  BZ_NAMESPACE_END

BZ_NAMESPACE_END

#endif // BZ_ARRAYMULTI_H
                                                                                                                                                                                    newet-macros.h                                                                                      0100644 0001750 0001750 00000043462 12160377112 043617  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/newet-macros.h  Macros for new e.t. implementation
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_NEWET_MACROS_H
#define BZ_NEWET_MACROS_H

#include <blitz/array/asexpr.h>

BZ_NAMESPACE(blitz)

#ifdef BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS

/*
 * Unary functions and operators
 */

#define BZ_DECLARE_ARRAY_ET_UNARY(name,functor)                           \
                                                                          \
template <typename T1>                                                    \
_bz_inline_et                                                             \
typename BzUnaryExprResult<functor,T1>::T_result                          \
name(const ETBase<T1>& d1)                                                \
{                                                                         \
    typedef typename BzUnaryExprResult<functor,T1>::T_result result;      \
    return result(asExpr<T1>::getExpr(d1.unwrap()));                      \
}

/*
 * Array expression templates: the macro BZ_DECLARE_ARRAY_ET_BINARY(X,Y)
 * declares a function or operator which takes two operands.
 * X is the function name (or operator), and Y is the functor object
 * which implements the operation.
 */

#define BZ_DECLARE_ARRAY_ET_BINARY(name, applic)                          \
                                                                          \
template <typename T1,typename T2>                                        \
_bz_inline_et                                                             \
typename BzBinaryExprResult<applic,T1,T2>::T_result                       \
name(const ETBase<T1>& d1,const ETBase<T2>& d2)                           \
{                                                                         \
    typedef typename BzBinaryExprResult<applic,T1,T2>::T_result result;   \
    return result(asExpr<T1>::getExpr(d1.unwrap()),                       \
                  asExpr<T2>::getExpr(d2.unwrap()));                      \
}

#define BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(name, applic)                  \
                                                                          \
template <typename T1, typename T2, int N>                                \
_bz_inline_et                                                             \
typename BzBinaryExprResult<applic,TinyVector<T2,N>,T1>::T_result         \
name(const TinyVector<T2,N> d1, const ETBase<T1>& d2)                     \
{                                                                         \
    typedef typename                                                      \
        BzBinaryExprResult<applic,TinyVector<T2,N>,T1>::T_result result;  \
    return result(asExpr<TinyVector<T2,N> >::getExpr(d1),                 \
                  asExpr<T1>::getExpr(d2.unwrap()));                      \
}                                                                         \
                                                                          \
template <typename T1, typename T2, int N>                                \
_bz_inline_et                                                             \
typename BzBinaryExprResult<applic,T1,TinyVector<T2,N> >::T_result        \
name(const ETBase<T1>& d1, const TinyVector<T2,N> d2)                     \
{                                                                         \
    typedef typename                                                      \
        BzBinaryExprResult<applic,T1,TinyVector<T2,N> >::T_result result; \
    return result(asExpr<T1>::getExpr(d1.unwrap()),                       \
                  asExpr<TinyVector<T2,N> >::getExpr(d2));                \
}

#define BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(name, applic, sca)              \
                                                                          \
template<typename T>                                                      \
_bz_inline_et                                                             \
typename BzBinaryExprResult<applic,sca,T>::T_result                       \
name(const sca d1, const ETBase<T>& d2)                                   \
{                                                                         \
    typedef typename BzBinaryExprResult<applic,sca,T>::T_result result;   \
    return result(asExpr<sca >::getExpr(d1),                              \
                  asExpr<T>::getExpr(d2.unwrap()));                       \
}                                                                         \
                                                                          \
template<typename T>                                                      \
_bz_inline_et                                                             \
typename BzBinaryExprResult<applic,T,sca >::T_result                      \
name(const ETBase<T>& d1, const sca d2)                                   \
{                                                                         \
    typedef typename BzBinaryExprResult<applic,T,sca >::T_result result;  \
    return result(asExpr<T>::getExpr(d1.unwrap()),                        \
                  asExpr<sca >::getExpr(d2));                             \
}

/*
 * Array expression templates: the macro BZ_DECLARE_ARRAY_ET_TERNARY(X,Y)
 * declares a function or operator which takes three operands.
 * X is the function name (or operator), and Y is the functor object
 * which implements the operation.
 */

#define BZ_DECLARE_ARRAY_ET_TERNARY(name, applic)                             \
                                                                              \
template <typename T1, typename T2, typename T3>                              \
_bz_inline_et                                                                 \
typename BzTernaryExprResult<applic, T1, T2, T3>::T_result                    \
name(const ETBase<T1>& d1, const ETBase<T2>& d2, const ETBase<T3>& d3)        \
{                                                                             \
    typedef typename BzTernaryExprResult<applic,T1,T2,T3>::T_result result;   \
    return result(asExpr<T1>::getExpr(d1.unwrap()),                           \
                  asExpr<T2>::getExpr(d2.unwrap()),                           \
                  asExpr<T3>::getExpr(d3.unwrap()));                          \
}
    
#else /* !BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS */

/*
 * Unary functions and operators
 */

#define BZ_DECLARE_ARRAY_ET_UNARY(name, functor)                          \
                                                                          \
template<typename T1>                                                     \
_bz_inline_et                                                             \
_bz_ArrayExpr<_bz_ArrayExprUnaryOp<                                       \
    _bz_typename asExpr<T1>::T_expr,                                      \
    functor<_bz_typename asExpr<T1>::T_expr::T_numtype> > >               \
name(const ETBase<T1>& d1)                                                \
{                                                                         \
    return _bz_ArrayExpr<_bz_ArrayExprUnaryOp<                            \
        _bz_typename asExpr<T1>::T_expr,                                  \
        functor<_bz_typename asExpr<T1>::T_expr::T_numtype> > >           \
        (asExpr<T1>::getExpr(d1.unwrap()));                               \
}

/*
 * Array expression templates: the macro BZ_DECLARE_ARRAY_ET_BINARY(X,Y)
 * declares a function or operator which takes two operands.
 * X is the function name (or operator), and Y is the functor object
 * which implements the operation.
 */

#define BZ_DECLARE_ARRAY_ET_BINARY(name, applic)                          \
                                                                          \
template<typename T1, typename T2>                                        \
_bz_inline_et                                                             \
_bz_ArrayExpr<_bz_ArrayExprBinaryOp<                                      \
    _bz_typename asExpr<T1>::T_expr,                                      \
    _bz_typename asExpr<T2>::T_expr,                                      \
    applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                    \
           _bz_typename asExpr<T2>::T_expr::T_numtype> > >                \
name(const ETBase<T1>& d1, const ETBase<T2>& d2)                          \
{                                                                         \
    return _bz_ArrayExpr<_bz_ArrayExprBinaryOp<                           \
        _bz_typename asExpr<T1>::T_expr,                                  \
        _bz_typename asExpr<T2>::T_expr,                                  \
        applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                \
               _bz_typename asExpr<T2>::T_expr::T_numtype> > >            \
        (asExpr<T1>::getExpr(d1.unwrap()),                                \
         asExpr<T2>::getExpr(d2.unwrap()));                               \
}

#define BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(name, applic)                  \
                                                                          \
template <typename T1, typename T2, int N>                                \
_bz_inline_et                                                             \
_bz_ArrayExprBinaryOp<                                                    \
    _bz_typename asExpr<TinyVector<T2,N> >::T_expr,                       \
    _bz_typename asExpr<T1>::T_expr,                                      \
    applic<TinyVector<T2,N>,                                              \
    _bz_typename asExpr<T1>::T_expr::T_numtype> >                         \
name(const TinyVector<T2,N> d1, const ETBase<T1>& d2)                     \
{                                                                         \
    return _bz_ArrayExprBinaryOp<                                         \
        _bz_typename asExpr<TinyVector<T2,N> >::T_expr,                   \
        _bz_typename asExpr<T1>::T_expr,                                  \
        applic<TinyVector<T2,N>,                                          \
        _bz_typename asExpr<T1>::T_expr::T_numtype> >                     \
        (asExpr<TinyVector<T2,N> >::getExpr(d1),                          \
         asExpr<T1>::getExpr(d2.unwrap()));                               \
}                                                                         \
                                                                          \
template <typename T1, typename T2, int N>                                \
_bz_inline_et                                                             \
_bz_ArrayExprBinaryOp<                                                    \
    _bz_typename asExpr<T1>::T_expr,                                      \
    _bz_typename asExpr<TinyVector<T2,N> >::T_expr,                       \
    applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                    \
    TinyVector<T2,N> > >                                                  \
name(const ETBase<T1>& d1, const TinyVector<T2,N> d2)                     \
{                                                                         \
    return _bz_ArrayExprBinaryOp<                                         \
        _bz_typename asExpr<T1>::T_expr,                                  \
        _bz_typename asExpr<TinyVector<T2,N> >::T_expr,                   \
        applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                \
        TinyVector<T2,N> > >                                              \
        (asExpr<T1>::getExpr(d1.unwrap()),                                \
         asExpr<TinyVector<T2,N> >::getExpr(d2));                         \
}

#define BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(name, applic, sca)              \
                                                                          \
template<typename T>                                                      \
_bz_inline_et                                                             \
_bz_ArrayExprBinaryOp<                                                    \
    asExpr<sca >::T_expr,                                                 \
    _bz_typename asExpr<T>::T_expr,                                       \
    applic<sca,_bz_typename asExpr<T>::T_expr::T_numtype> >               \
name(const sca d1, const ETBase<T>& d2)                                   \
{                                                                         \
    return _bz_ArrayExprBinaryOp<                                         \
        asExpr<sca >::T_expr,                                             \
        _bz_typename asExpr<T>::T_expr,                                   \
        applic<sca,_bz_typename asExpr<T>::T_expr::T_numtype> >           \
        (asExpr<sca >::getExpr(d1),                                       \
         asExpr<T>::getExpr(d2.unwrap()));                                \
}                                                                         \
                                                                          \
template<typename T>                                                      \
_bz_inline_et                                                             \
_bz_ArrayExprBinaryOp<                                                    \
    _bz_typename asExpr<T>::T_expr,                                       \
    asExpr<sca >::T_expr,                                                 \
    applic<_bz_typename asExpr<T>::T_expr::T_numtype,sca > >              \
name(const ETBase<T>& d1, const sca d2)                                   \
{                                                                         \
    return _bz_ArrayExprBinaryOp<                                         \
        _bz_typename asExpr<T>::T_expr,                                   \
        asExpr<sca >::T_expr,                                             \
        applic<_bz_typename asExpr<T>::T_expr::T_numtype,sca > >          \
        (asExpr<T>::getExpr(d1.unwrap()),                                 \
         asExpr<sca >::getExpr(d2));                                      \
}

/*
 * Array expression templates: the macro BZ_DECLARE_ARRAY_ET_TERNARY(X,Y)
 * declares a function or operator which takes three operands.
 * X is the function name (or operator), and Y is the functor object
 * which implements the operation.
 */

#define BZ_DECLARE_ARRAY_ET_TERNARY(name, applic)                         \
                                                                          \
template<typename T1, typename T2, typename T3>                           \
_bz_inline_et                                                             \
_bz_ArrayExpr<_bz_ArrayExprTernaryOp<                                     \
    _bz_typename asExpr<T1>::T_expr,                                      \
    _bz_typename asExpr<T2>::T_expr,                                      \
    _bz_typename asExpr<T3>::T_expr,                                      \
    applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                    \
           _bz_typename asExpr<T2>::T_expr::T_numtype,                    \
           _bz_typename asExpr<T3>::T_expr::T_numtype> > >                \
name(const ETBase<T1>& d1, const ETBase<T2>& d2, const ETBase<T3>& d3)    \
{                                                                         \
    return _bz_ArrayExpr<_bz_ArrayExprTernaryOp<                          \
        _bz_typename asExpr<T1>::T_expr,                                  \
        _bz_typename asExpr<T2>::T_expr,                                  \
        _bz_typename asExpr<T3>::T_expr,                                  \
        applic<_bz_typename asExpr<T1>::T_expr::T_numtype,                \
               _bz_typename asExpr<T2>::T_expr::T_numtype,                \
               _bz_typename asExpr<T3>::T_expr::T_numtype> > >            \
        (asExpr<T1>::getExpr(d1.unwrap()),                                \
         asExpr<T2>::getExpr(d2.unwrap()),                                \
         asExpr<T3>::getExpr(d3.unwrap()));                               \
}

#endif /* BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS */

/*
 * User-defined expression template routines
 */

#define BZ_DECLARE_FUNCTION(name)                                        \
BZ_DEFINE_UNARY_FUNC(name ## _impl,name)                                 \
BZ_DECLARE_ARRAY_ET_UNARY(name,name ## _impl)

#define BZ_DECLARE_FUNCTION_RET(name,return_type)                        \
BZ_DEFINE_UNARY_FUNC_RET(name ## _impl,name,return_type)                 \
BZ_DECLARE_ARRAY_ET_UNARY(name,name ## _impl)

#define BZ_DECLARE_FUNCTION2(name)                                       \
BZ_DEFINE_BINARY_FUNC(name ## _impl,name)                                \
BZ_DECLARE_ARRAY_ET_BINARY(name, name ## _impl)

#define BZ_DECLARE_FUNCTION2_RET(name,return_type)                       \
BZ_DEFINE_BINARY_FUNC_RET(name ## _impl,name,return_type)                \
BZ_DECLARE_ARRAY_ET_BINARY(name, name ## _impl)

#define BZ_DECLARE_FUNCTION2_SCALAR(name, sca)                           \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(name, name ## _impl, sca)

#define BZ_DECLARE_FUNCTION3(name)                                       \
BZ_DEFINE_TERNARY_FUNC(name ## _impl,name)                               \
BZ_DECLARE_ARRAY_ET_TERNARY(name, name ## _impl)
    
#define BZ_DECLARE_FUNCTION3_RET(name,return_type)                       \
BZ_DEFINE_TERNARY_FUNC_RET(name ## _impl,name,return_type)               \
BZ_DECLARE_ARRAY_ET_TERNARY(name, name ## _impl)

BZ_NAMESPACE_END

#endif
                                                                                                                                                                                                              newet.h                                                                                             0100644 0001750 0001750 00000001631 12160377112 042325  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/newet.h  Gang include of new expression templates implementation
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_NEWET_H
#define BZ_ARRAY_NEWET_H

// Gang include of new expression templates implementation.

#include <blitz/array/ops.h>
#include <blitz/array/funcs.h>

// ET support for functors acting on Arrays

#include <blitz/array/functorExpr.h>

#endif
                                                                                                       ops.h                                                                                               0100644 0001750 0001750 00000012335 12160377112 042007  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/ops.h  Array operators
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_OPS_H
#define BZ_ARRAY_OPS_H

#include <blitz/ops.h>
#include <blitz/array/newet-macros.h>

BZ_NAMESPACE(blitz)
    
// unary operators
    
BZ_DECLARE_ARRAY_ET_UNARY(operator~, BitwiseNot)
BZ_DECLARE_ARRAY_ET_UNARY(operator!, LogicalNot)
BZ_DECLARE_ARRAY_ET_UNARY(operator+, UnaryPlus)
BZ_DECLARE_ARRAY_ET_UNARY(operator-, UnaryMinus)

// binary operators
    
// operator<< has been commented out because it causes ambiguity
// with statements like "cout << A".  NEEDS_WORK
// ditto operator<<

BZ_DECLARE_ARRAY_ET_BINARY(operator+,  Add)
BZ_DECLARE_ARRAY_ET_BINARY(operator-,  Subtract)
BZ_DECLARE_ARRAY_ET_BINARY(operator*,  Multiply)
BZ_DECLARE_ARRAY_ET_BINARY(operator/,  Divide)
BZ_DECLARE_ARRAY_ET_BINARY(operator%,  Modulo)
BZ_DECLARE_ARRAY_ET_BINARY(operator^,  BitwiseXor)
BZ_DECLARE_ARRAY_ET_BINARY(operator&,  BitwiseAnd)
BZ_DECLARE_ARRAY_ET_BINARY(operator|,  BitwiseOr)
// BZ_DECLARE_ARRAY_ET_BINARY(operator>>, ShiftRight)
// BZ_DECLARE_ARRAY_ET_BINARY(operator<<, ShiftLeft)
BZ_DECLARE_ARRAY_ET_BINARY(operator>,  Greater)
BZ_DECLARE_ARRAY_ET_BINARY(operator<,  Less)
BZ_DECLARE_ARRAY_ET_BINARY(operator>=, GreaterOrEqual)
BZ_DECLARE_ARRAY_ET_BINARY(operator<=, LessOrEqual)
BZ_DECLARE_ARRAY_ET_BINARY(operator==, Equal)
BZ_DECLARE_ARRAY_ET_BINARY(operator!=, NotEqual)
BZ_DECLARE_ARRAY_ET_BINARY(operator&&, LogicalAnd)
BZ_DECLARE_ARRAY_ET_BINARY(operator||, LogicalOr)

BZ_DECLARE_ARRAY_ET_BINARY(min, _bz_Min)
BZ_DECLARE_ARRAY_ET_BINARY(max, _bz_Max)


// Declare binary ops between Array and "scalar-like" TinyVector 
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator+,  Add)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator-,  Subtract)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator*,  Multiply)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator/,  Divide)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator%,  Modulo)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator^,  BitwiseXor)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator&,  BitwiseAnd)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator|,  BitwiseOr)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator>,  Greater)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator<,  Less)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator>=, GreaterOrEqual)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator<=, LessOrEqual)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator==, Equal)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator!=, NotEqual)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator&&, LogicalAnd)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(operator||, LogicalOr)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(min, _bz_Min)
BZ_DECLARE_ARRAY_ET_BINARY_TINYVEC(max, _bz_Max)


#define BZ_DECLARE_ARRAY_ET_SCALAR_OPS(sca)                            \
                                                                       \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator+,  Add, sca)                \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator-,  Subtract, sca)           \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator*,  Multiply, sca)           \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator/,  Divide, sca)             \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator%,  Modulo, sca)             \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator^,  BitwiseXor, sca)         \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator&,  BitwiseAnd, sca)         \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator|,  BitwiseOr, sca)          \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator>,  Greater, sca)            \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator<,  Less, sca)               \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator>=, GreaterOrEqual, sca)     \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator<=, LessOrEqual, sca)        \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator==, Equal, sca)              \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator!=, NotEqual, sca)           \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator&&, LogicalAnd, sca)         \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(operator||, LogicalOr, sca)          \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(min, _bz_Min, sca)                   \
BZ_DECLARE_ARRAY_ET_BINARY_SCALAR(max, _bz_Max, sca)                   \

    
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(char)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(unsigned char)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(short)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(unsigned short)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(int)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(unsigned int)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(long)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(unsigned long)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(float)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(double)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(long double)
#ifdef BZ_HAVE_COMPLEX
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(complex<float>)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(complex<double>)
BZ_DECLARE_ARRAY_ET_SCALAR_OPS(complex<long double>)
#endif


BZ_NAMESPACE_END

#endif // BZ_ARRAY_OPS_H
                                                                                                                                                                                                                                                                                                   reduce.h                                                                                            0100644 0001750 0001750 00000027560 12160377112 042463  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/reduce.h   Reductions of an array (or array expression) in a 
 *                        single rank: sum, mean, min, minIndex, max, maxIndex,
 *                        product, count, any, all
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYREDUCE_H
#define BZ_ARRAYREDUCE_H

#ifndef BZ_ARRAYEXPR_H
 #error <blitz/array/reduce.h> must be included after <blitz/array/expr.h>
#endif

#include <blitz/reduce.h>

BZ_NAMESPACE(blitz)

template<typename T_expr, int N_index, typename T_reduction>
class _bz_ArrayExprReduce {

public:   
    typedef _bz_typename T_reduction::T_numtype T_numtype;
    typedef T_expr      T_ctorArg1;
    typedef T_reduction T_ctorArg2;

    static const int 
        numArrayOperands = T_expr::numArrayOperands,
        numIndexPlaceholders = T_expr::numIndexPlaceholders + 1,
        rank = T_expr::rank - 1;

    _bz_ArrayExprReduce(const _bz_ArrayExprReduce<T_expr,N_index,T_reduction>&
        reduce)
        : reduce_(reduce.reduce_), iter_(reduce.iter_), ordering_(reduce.ordering_)
    {
    }

    _bz_ArrayExprReduce(T_expr expr)
        : iter_(expr)
    { computeOrdering(); }

    _bz_ArrayExprReduce(T_expr expr, T_reduction reduce)
        : iter_(expr), reduce_(reduce)
    { computeOrdering(); }

    int ascending(int r)
    { return iter_.ascending(r); }

    int ordering(int r)
    { return ordering_[r]; }

    int lbound(int r)
    { return iter_.lbound(r); }

    int ubound(int r)
    { return iter_.ubound(r); }

    template<int N_destRank>
    T_numtype operator()(const TinyVector<int, N_destRank>& destIndex)
    {
        BZPRECHECK(N_destRank == N_index,  
            "Array reduction performed over rank " << N_index 
            << " to produce a rank " << N_destRank << " expression." << endl
            << "You must reduce over rank " << N_destRank << " instead.");

        TinyVector<int, N_destRank + 1> index;

        // This metaprogram copies elements 0..N-1 of destIndex into index
        _bz_meta_vecAssign<N_index, 0>::assign(index, destIndex, 
            _bz_update<int,int>());

        int lbound = iter_.lbound(N_index);
        int ubound = iter_.ubound(N_index);

        // NEEDS_WORK: replace with tiny(int()) and huge(int()) once
        // <limits> widely available
        BZPRECHECK((lbound != INT_MIN) && (ubound != INT_MAX),
           "Array reduction performed over rank " << N_index
           << " is unbounded." << endl 
           << "There must be an array object in the expression being reduced"
           << endl << "which provides a bound in rank " << N_index << ".");

        reduce_.reset();

        for (index[N_index] = iter_.lbound(N_index);
            index[N_index] <= ubound; ++index[N_index])
        {
            if (!reduce_(iter_(index), index[N_index]))
                break;
        }

        return reduce_.result(ubound-lbound+1);
    }

    // If you have a precondition failure on this routine, it means
    // you are trying to use stack iteration mode on an expression
    // which contains an index placeholder.  You must use index
    // iteration mode instead.
    int operator*()
    {
        BZPRECONDITION(0);
        return 0;
    }

    // See operator*() note
    void push(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void pop(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void advance()
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void advance(int)
    {
        BZPRECONDITION(0);
    }

    // See operator*() note
    void loadStride(int)
    {
        BZPRECONDITION(0);
    }

    bool isUnitStride(int) const
    {
        BZPRECONDITION(0);
        return false;
    }

    void advanceUnitStride()
    {
        BZPRECONDITION(0);
    }

    bool canCollapse(int,int) const
    {   BZPRECONDITION(0); return false; }

    T_numtype operator[](int)
    {
        BZPRECONDITION(0);
        return T_numtype();
    }

    T_numtype fastRead(int)
    {
        BZPRECONDITION(0);
        return T_numtype();
    }

    int suggestStride(int) const
    {
        BZPRECONDITION(0);
        return 0;
    }

    bool isStride(int,int) const
    {
        BZPRECONDITION(0);
        return true;
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>&)
    {
        BZPRECONDITION(0);
        return;
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        // NEEDS_WORK-- do real formatting for reductions
        str += "reduce[NEEDS_WORK](";
        iter_.prettyPrint(str,format);
        str += ")";
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape&) const
    { 
        // NEEDS_WORK-- do a real shape check (tricky)
        return true; 
    }

private: 
    _bz_ArrayExprReduce() { }
// method for properly initializing the ordering values
    void computeOrdering()
    {
        TinyVector<bool,rank> in_ordering;
        in_ordering = false;

        int j = 0;
        for (int i=0; i<rank; ++i)
        {
            int orderingj = iter_.ordering(i);
            if (orderingj != INT_MIN && orderingj < rank &&
                !in_ordering(orderingj)) { // unique value in ordering array
                in_ordering(orderingj) = true;
                ordering_(j++) = orderingj;
            }

        }

        // It is possible that ordering is not a permutation of 0,...,rank-1.
        // In that case j will be less than rank. We fill in ordering with
        // the unused values in decreasing order.
        for (int i = rank-1; j < rank; ++j) {
            while (in_ordering(i))
                --i;
            ordering_(j) = i--;
        }
    }

    T_reduction reduce_;
    T_expr iter_;
    TinyVector<int,rank> ordering_;
};

#define BZ_DECL_ARRAY_PARTIAL_REDUCE(fn,reduction)                      \
template<typename T_expr, int N_index>                                  \
inline                                                                  \
_bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,       \
    reduction<_bz_typename T_expr::T_numtype> > >                       \
fn(_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&)        \
{                                                                       \
    return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,          \
        reduction<_bz_typename T_expr::T_numtype> >(expr);              \
}                                                                       \
                                                                        \
template<typename T_numtype, int N_rank, int N_index>                   \
inline                                                                  \
_bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>,  \
    N_index, reduction<T_numtype> > >                                   \
fn(const Array<T_numtype, N_rank>& array,                               \
    const IndexPlaceholder<N_index>&)                                   \
{                                                                       \
    return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>,     \
        N_index, reduction<T_numtype> > (array.beginFast());            \
}                        

BZ_DECL_ARRAY_PARTIAL_REDUCE(sum,      ReduceSum)
BZ_DECL_ARRAY_PARTIAL_REDUCE(mean,     ReduceMean)
BZ_DECL_ARRAY_PARTIAL_REDUCE(min,      ReduceMin)
BZ_DECL_ARRAY_PARTIAL_REDUCE(minIndex, ReduceMinIndex)
BZ_DECL_ARRAY_PARTIAL_REDUCE(max,      ReduceMax)
BZ_DECL_ARRAY_PARTIAL_REDUCE(maxIndex, ReduceMaxIndex)
BZ_DECL_ARRAY_PARTIAL_REDUCE(product,  ReduceProduct)
BZ_DECL_ARRAY_PARTIAL_REDUCE(count,    ReduceCount)
BZ_DECL_ARRAY_PARTIAL_REDUCE(any,      ReduceAny)
BZ_DECL_ARRAY_PARTIAL_REDUCE(all,      ReduceAll)
BZ_DECL_ARRAY_PARTIAL_REDUCE(first,    ReduceFirst)
BZ_DECL_ARRAY_PARTIAL_REDUCE(last,     ReduceLast)

/*
 * Complete reductions
 */

// Prototype of reduction function
template<typename T_expr, typename T_reduction>
_bz_typename T_reduction::T_resulttype
_bz_ArrayExprFullReduce(T_expr expr, T_reduction reduction);

#define BZ_DECL_ARRAY_FULL_REDUCE(fn,reduction)                         \
template<typename T_expr>                                               \
inline                                                                  \
_bz_typename reduction<_bz_typename T_expr::T_numtype>::T_resulttype    \
fn(_bz_ArrayExpr<T_expr> expr)                                          \
{                                                                       \
    return _bz_ArrayExprFullReduce(expr,                                \
        reduction<_bz_typename T_expr::T_numtype>());                   \
}                                                                       \
                                                                        \
template<typename T_numtype, int N_rank>                                \
inline                                                                  \
_bz_typename reduction<T_numtype>::T_resulttype                         \
fn(const Array<T_numtype, N_rank>& array)                               \
{                                                                       \
    return _bz_ArrayExprFullReduce(array.beginFast(),                   \
        reduction<T_numtype>());                                        \
}                                                                     

BZ_DECL_ARRAY_FULL_REDUCE(sum,      ReduceSum)
BZ_DECL_ARRAY_FULL_REDUCE(mean,     ReduceMean)
BZ_DECL_ARRAY_FULL_REDUCE(min,      ReduceMin)
BZ_DECL_ARRAY_FULL_REDUCE(max,      ReduceMax)
BZ_DECL_ARRAY_FULL_REDUCE(product,  ReduceProduct)
BZ_DECL_ARRAY_FULL_REDUCE(count,    ReduceCount)
BZ_DECL_ARRAY_FULL_REDUCE(any,      ReduceAny)
BZ_DECL_ARRAY_FULL_REDUCE(all,      ReduceAll)
BZ_DECL_ARRAY_FULL_REDUCE(first,    ReduceFirst)
BZ_DECL_ARRAY_FULL_REDUCE(last,     ReduceLast)

// Special versions of complete reductions: minIndex and
// maxIndex

#define BZ_DECL_ARRAY_FULL_REDUCE_INDEXVECTOR(fn,reduction)             \
template<typename T_expr>                                               \
inline                                                                  \
_bz_typename reduction<_bz_typename T_expr::T_numtype,                  \
    T_expr::rank>::T_resulttype                                         \
fn(_bz_ArrayExpr<T_expr> expr)                                          \
{                                                                       \
    return _bz_reduceWithIndexVectorTraversal(expr,                     \
        reduction<_bz_typename T_expr::T_numtype, T_expr::rank>());     \
}                                                                       \
                                                                        \
template<typename T_numtype, int N_rank>                                \
inline                                                                  \
_bz_typename reduction<T_numtype,N_rank>::T_resulttype                  \
fn(const Array<T_numtype, N_rank>& array)                               \
{                                                                       \
    return _bz_reduceWithIndexVectorTraversal( array.beginFast(),       \
        reduction<T_numtype,N_rank>());                                 \
}

BZ_DECL_ARRAY_FULL_REDUCE_INDEXVECTOR(minIndex, ReduceMinIndexVector)
BZ_DECL_ARRAY_FULL_REDUCE_INDEXVECTOR(maxIndex, ReduceMaxIndexVector)

BZ_NAMESPACE_END

#include <blitz/array/reduce.cc>

#endif // BZ_ARRAYREDUCE_H
                                                                                                                                                shape.h                                                                                             0100644 0001750 0001750 00000004670 12160377112 042311  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/shape.h        
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYSHAPE_H
#define BZ_ARRAYSHAPE_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/shape.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

/*
 * These routines make it easier to create shape parameters on
 * the fly: instead of having to write
 *
 * A.resize(TinyVector<int,4>(8,8,8,12));
 *
 * you can just say
 *
 * A.resize(shape(8,8,8,12));
 *
 */
inline TinyVector<int,1> shape(int n1)
{ return TinyVector<int,1>(n1); }

inline TinyVector<int,2> shape(int n1, int n2)
{ return TinyVector<int,2>(n1,n2); }

inline TinyVector<int,3> shape(int n1, int n2, int n3)
{ return TinyVector<int,3>(n1,n2,n3); }

inline TinyVector<int,4> shape(int n1, int n2, int n3, int n4)
{ return TinyVector<int,4>(n1,n2,n3,n4); }

inline TinyVector<int,5> shape(int n1, int n2, int n3, int n4,
    int n5)
{ return TinyVector<int,5>(n1,n2,n3,n4,n5); }

inline TinyVector<int,6> shape(int n1, int n2, int n3, int n4,
    int n5, int n6)
{ return TinyVector<int,6>(n1,n2,n3,n4,n5,n6); }

inline TinyVector<int,7> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7)
{ return TinyVector<int,7>(n1,n2,n3,n4,n5,n6,n7); }

inline TinyVector<int,8> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8)
{ return TinyVector<int,8>(n1,n2,n3,n4,n5,n6,n7,n8); }

inline TinyVector<int,9> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9)
{ return TinyVector<int,9>(n1,n2,n3,n4,n5,n6,n7,n8,n9); }

inline TinyVector<int,10> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9, int n10)
{ return TinyVector<int,10>(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10); }

inline TinyVector<int,11> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9, int n10, int n11)
{ return TinyVector<int,11>(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11); }

BZ_NAMESPACE_END

#endif // BZ_ARRAYSHAPE_H

                                                                        slice.h                                                                                             0100644 0001750 0001750 00000007224 12160377112 042306  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/slice.h    Helper classes for slicing arrays
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYSLICE_H
#define BZ_ARRAYSLICE_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/slice.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

// Forward declaration
template<typename T, int N>
class Array;



class nilArraySection { };

template<typename T>
class ArraySectionInfo {
public:
    static const int isValidType = 0, rank = 0, isPick = 0;
};

template<>
class ArraySectionInfo<Range> {
public:
    static const int isValidType = 1, rank = 1, isPick = 0;
};

template<>
class ArraySectionInfo<int> {
public:
    static const int isValidType = 1, rank = 0, isPick = 0;
};

template<>
class ArraySectionInfo<nilArraySection> {
public:
    static const int isValidType = 1, rank = 0, isPick = 0;
};

template<typename T_numtype, typename T1, typename T2 = nilArraySection, 
    class T3 = nilArraySection, typename T4 = nilArraySection, 
    class T5 = nilArraySection, typename T6 = nilArraySection, 
    class T7 = nilArraySection, typename T8 = nilArraySection, 
    class T9 = nilArraySection, typename T10 = nilArraySection, 
    class T11 = nilArraySection>
class SliceInfo {
public:
    static const int 
        numValidTypes = ArraySectionInfo<T1>::isValidType
                      + ArraySectionInfo<T2>::isValidType
                      + ArraySectionInfo<T3>::isValidType
                      + ArraySectionInfo<T4>::isValidType
                      + ArraySectionInfo<T5>::isValidType
                      + ArraySectionInfo<T6>::isValidType
                      + ArraySectionInfo<T7>::isValidType
                      + ArraySectionInfo<T8>::isValidType
                      + ArraySectionInfo<T9>::isValidType
                      + ArraySectionInfo<T10>::isValidType
                      + ArraySectionInfo<T11>::isValidType,

        rank          = ArraySectionInfo<T1>::rank
                      + ArraySectionInfo<T2>::rank
                      + ArraySectionInfo<T3>::rank
                      + ArraySectionInfo<T4>::rank
                      + ArraySectionInfo<T5>::rank
                      + ArraySectionInfo<T6>::rank
                      + ArraySectionInfo<T7>::rank
                      + ArraySectionInfo<T8>::rank
                      + ArraySectionInfo<T9>::rank
                      + ArraySectionInfo<T10>::rank
                      + ArraySectionInfo<T11>::rank,

        isPick        = ArraySectionInfo<T1>::isPick
                      + ArraySectionInfo<T2>::isPick
                      + ArraySectionInfo<T3>::isPick
                      + ArraySectionInfo<T4>::isPick
                      + ArraySectionInfo<T5>::isPick
                      + ArraySectionInfo<T6>::isPick
                      + ArraySectionInfo<T7>::isPick
                      + ArraySectionInfo<T8>::isPick
                      + ArraySectionInfo<T9>::isPick
                      + ArraySectionInfo<T10>::isPick
                      + ArraySectionInfo<T11>::isPick;

    typedef Array<T_numtype,numValidTypes> T_array;
    typedef Array<T_numtype,rank> T_slice;
};

BZ_NAMESPACE_END

#endif // BZ_ARRAYSLICE_H
                                                                                                                                                                                                                                                                                                                                                                            stencil-et.h                                                                                        0100644 0001750 0001750 00000020266 12160377112 043257  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/stencil-et.h  Expression-template-capabale stencils
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_STENCIL_ET_H
#define BZ_ARRAY_STENCIL_ET_H

BZ_NAMESPACE(blitz)

template<typename T_ArrayNumtype, int N_rank, typename T_result>
class StencilExpr 
{
public:
    typedef T_result T_numtype;
    typedef Array<T_ArrayNumtype,N_rank> T_array;
    typedef const T_array& T_ctorArg1;
    typedef int T_ctorArg2;

    static const int 
        numArrayOperands = 1, 
        numIndexPlaceholders = 0,
        rank = N_rank;

    StencilExpr(const T_array& array)
        : iter_(array)
    { }

    ~StencilExpr()
    { }

    // operator* must be declared by subclass
  
    int ascending(int rank)
    { return iter_.ascending(rank); }
 
    int ordering(int rank)
    { return iter_.ordering(rank); }
 
    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    void push(int position)
    { iter_.push(position); }

    void pop(int position)
    { iter_.pop(position); }

    void advance()
    { iter_.advance(); }

    void advance(int n)
    { iter_.advance(n); }

    void loadStride(int rank)
    { iter_.loadStride(rank); }

    bool isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    { iter_.advanceUnitStride(); }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    {
        // BZ_DEBUG_MESSAGE("_bz_ArrayExpr<>::canCollapse()");
        return iter_.canCollapse(outerLoopRank, innerLoopRank);
    }

    // T_numtype operator[](int i)   -- don't know how to do that.

    // T_numtype fastRead(int i)     -- ditto

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(BZ_STD_SCOPE(string) &str) const
    {
        str += "(stencil)";    // lame, needs work
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat&) const
    {   str += "(stencil)"; }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

protected:
    FastArrayIterator<T_ArrayNumtype,N_rank> iter_;
};

#define BZ_ET_STENCIL(name,result) \
template<typename P_numtype, int N_rank> \
class name ## _et : public StencilExpr<P_numtype,N_rank,result>, \
  public ETBase<name ## _et<P_numtype,N_rank> > \
 { \
private: \
    typedef StencilExpr<P_numtype,N_rank,result> T_base; \
    using T_base::iter_; \
public: \
    name ## _et(const Array<P_numtype,N_rank>& A) \
        : StencilExpr<P_numtype,N_rank,result>(A) \
    { } \
    result operator*() \
    { return name(iter_); } \
    result operator()(const TinyVector<int,N_rank>& a) \
    { iter_.moveTo(a); return name(iter_); } \
    result fastRead(int i) \
    { \
      const P_numtype* tmp = iter_.data(); \
      iter_._bz_setData(tmp + i); \
      P_numtype r = name(iter_); \
      iter_._bz_setData(tmp); \
      return r; \
    } \
}; \
template<typename P_numtype, int N_rank> \
inline _bz_ArrayExpr<name ## _et<P_numtype, N_rank> > \
name(Array<P_numtype,N_rank>& A) \
{ \
    return _bz_ArrayExpr<name ## _et<P_numtype, N_rank> >(A); \
}

#define BZ_ET_STENCILV(name,rank) \
template<typename P_numtype, int N_rank> \
class name ## _et : public StencilExpr<P_numtype,N_rank, \
    TinyVector<P_numtype,rank> >, \
  public ETBase<name ## _et<P_numtype,N_rank> > \
 { \
private: \
    typedef StencilExpr<P_numtype,N_rank,TinyVector<P_numtype,rank> > T_base; \
    using T_base::iter_; \
public: \
    typedef TinyVector<P_numtype,rank> result; \
    name ## _et(const Array<P_numtype,N_rank>& A) \
        : StencilExpr<P_numtype,N_rank,result>(A) \
    { } \
    result operator*() \
    { return name(iter_); } \
    result operator()(const TinyVector<int,N_rank>& a) \
    { iter_.moveTo(a); return name(iter_); } \
    result fastRead(int i) \
    { \
      const P_numtype* tmp = iter_.data(); \
      iter_._bz_setData(tmp + i); \
      P_numtype r = name(iter_); \
      iter_._bz_setData(tmp); \
      return r; \
    } \
}; \
template<typename P_numtype, int N_rank> \
inline _bz_ArrayExpr<name ## _et<P_numtype, N_rank> > \
name(Array<P_numtype,N_rank>& A) \
{ \
    return _bz_ArrayExpr< name ## _et<P_numtype, N_rank> >(A); \
}

#define BZ_ET_STENCIL_DIFF(name) \
template<typename P_numtype, int N_rank> \
class name ## _et : public StencilExpr<P_numtype,N_rank,P_numtype>, \
  public ETBase<name ## _et<P_numtype,N_rank> > \
 { \
private: \
    typedef StencilExpr<P_numtype,N_rank,P_numtype> T_base; \
    using T_base::iter_; \
public: \
    name ## _et(const Array<P_numtype,N_rank>& A, int dim) \
        : StencilExpr<P_numtype,N_rank,P_numtype>(A), dim_(dim) \
    { } \
    P_numtype operator*() \
    { return name(iter_); } \
    P_numtype operator()(const TinyVector<int,N_rank>& a) \
    { iter_.moveTo(a); return name(iter_,dim_); } \
    P_numtype fastRead(int i) \
    { \
      const P_numtype* tmp = iter_.data(); \
      iter_._bz_setData(tmp + i); \
      P_numtype r = name(iter_,dim_); \
      iter_._bz_setData(tmp); \
      return r; \
    } \
private: \
    int dim_; \
}; \
template<typename P_numtype, int N_rank> \
inline _bz_ArrayExpr<name ## _et<P_numtype, N_rank> > \
name(Array<P_numtype,N_rank>& A, int dim) \
{ \
    return _bz_ArrayExpr<name ## _et<P_numtype, N_rank> >(A,dim); \
}


BZ_ET_STENCIL(Laplacian2D, P_numtype)
BZ_ET_STENCIL(Laplacian3D, P_numtype)
BZ_ET_STENCIL(Laplacian2D4, P_numtype)
BZ_ET_STENCIL(Laplacian2D4n, P_numtype)
BZ_ET_STENCIL(Laplacian3D4, P_numtype)
BZ_ET_STENCIL(Laplacian3D4n, P_numtype)
BZ_ET_STENCILV(grad2D, 2)
BZ_ET_STENCILV(grad2D4, 2)
BZ_ET_STENCILV(grad3D, 3)
BZ_ET_STENCILV(grad3D4, 3)
BZ_ET_STENCILV(grad2Dn, 2)
BZ_ET_STENCILV(grad2D4n, 2)
BZ_ET_STENCILV(grad3Dn, 3)
BZ_ET_STENCILV(grad3D4n, 3)
BZ_ET_STENCILV(gradSqr2D, 2)
BZ_ET_STENCILV(gradSqr2D4, 2)
BZ_ET_STENCILV(gradSqr3D, 3)
BZ_ET_STENCILV(gradSqr3D4, 3)
BZ_ET_STENCILV(gradSqr2Dn, 2)
BZ_ET_STENCILV(gradSqr2D4n, 2)
BZ_ET_STENCILV(gradSqr3Dn, 3)
BZ_ET_STENCILV(gradSqr3D4n, 3)

// NEEDS_WORK:
// Jacobian
// Curl
// Div
// mixed

BZ_ET_STENCIL_DIFF(central12)
BZ_ET_STENCIL_DIFF(central22)
BZ_ET_STENCIL_DIFF(central32)
BZ_ET_STENCIL_DIFF(central42)
BZ_ET_STENCIL_DIFF(central14)
BZ_ET_STENCIL_DIFF(central24)
BZ_ET_STENCIL_DIFF(central34)
BZ_ET_STENCIL_DIFF(central44)
BZ_ET_STENCIL_DIFF(central12n)
BZ_ET_STENCIL_DIFF(central22n)
BZ_ET_STENCIL_DIFF(central32n)
BZ_ET_STENCIL_DIFF(central42n)
BZ_ET_STENCIL_DIFF(central14n)
BZ_ET_STENCIL_DIFF(central24n)
BZ_ET_STENCIL_DIFF(central34n)
BZ_ET_STENCIL_DIFF(central44n)

BZ_ET_STENCIL_DIFF(backward11)
BZ_ET_STENCIL_DIFF(backward21)
BZ_ET_STENCIL_DIFF(backward31)
BZ_ET_STENCIL_DIFF(backward41)
BZ_ET_STENCIL_DIFF(backward12)
BZ_ET_STENCIL_DIFF(backward22)
BZ_ET_STENCIL_DIFF(backward32)
BZ_ET_STENCIL_DIFF(backward42)
BZ_ET_STENCIL_DIFF(backward11n)
BZ_ET_STENCIL_DIFF(backward21n)
BZ_ET_STENCIL_DIFF(backward31n)
BZ_ET_STENCIL_DIFF(backward41n)
BZ_ET_STENCIL_DIFF(backward12n)
BZ_ET_STENCIL_DIFF(backward22n)
BZ_ET_STENCIL_DIFF(backward32n)
BZ_ET_STENCIL_DIFF(backward42n)

BZ_ET_STENCIL_DIFF(forward11)
BZ_ET_STENCIL_DIFF(forward21)
BZ_ET_STENCIL_DIFF(forward31)
BZ_ET_STENCIL_DIFF(forward41)
BZ_ET_STENCIL_DIFF(forward12)
BZ_ET_STENCIL_DIFF(forward22)
BZ_ET_STENCIL_DIFF(forward32)
BZ_ET_STENCIL_DIFF(forward42)
BZ_ET_STENCIL_DIFF(forward11n)
BZ_ET_STENCIL_DIFF(forward21n)
BZ_ET_STENCIL_DIFF(forward31n)
BZ_ET_STENCIL_DIFF(forward41n)
BZ_ET_STENCIL_DIFF(forward12n)
BZ_ET_STENCIL_DIFF(forward22n)
BZ_ET_STENCIL_DIFF(forward32n)
BZ_ET_STENCIL_DIFF(forward42n)


BZ_NAMESPACE_END

#endif // BZ_ARRAY_STENCIL_ET_H
                                                                                                                                                                                                                                                                                                                                          stencil.h                                                                                           0100644 0001750 0001750 00000020647 12160377112 042654  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            #ifndef BZ_ARRAYSTENCIL_H
#define BZ_ARRAYSTENCIL_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/stencil.h> must be included via <blitz/array.h>
#endif

#include <blitz/array/stencilops.h>

BZ_NAMESPACE(blitz)

// NEEDS_WORK: currently stencilExtent returns int(1).  What if the
// stencil contains calls to math functions, or divisions, etc.?
// Should at least return a number of the appropriate type.  Probably
// return a sequence of quasi-random floating point numbers.

/*
 * These macros make it easier for users to declare stencil objects.
 * The syntax is:
 *
 * BZ_DECLARE_STENCILN(stencilname, Array1, Array2, ..., ArrayN)
 *    // stencil operations go here
 * BZ_END_STENCIL
 */

#define BZ_DECLARE_STENCIL2(name,A,B)    \
  struct name {                          \
    template<class T1, class T2, class T3, class T4, class T5, class T6, \
        class T7, class T8, class T9, class T10, class T11>         \
    static inline void apply(T1& A, T2& B, T3, T4, T5, T6, T7, T8, T9, T10, T11) \
    {

#define BZ_END_STENCIL_WITH_SHAPE(MINS,MAXS) } \
    template<int N> \
    void getExtent(TinyVector<int,N>& minb, TinyVector<int,N>& maxb) const \
    { \
        minb = MINS; \
        maxb = MAXS; \
    } \
    enum { hasExtent = 1 }; \
};

#define BZ_END_STENCIL } enum { hasExtent = 0 }; };
#define BZ_STENCIL_END BZ_END_STENCIL

#define BZ_DECLARE_STENCIL3(name,A,B,C)         \
  struct name {                                 \
    template<class T1, class T2, class T3, class T4, class T5, class T6, \
        class T7, class T8, class T9, class T10, class T11>      \
    static inline void apply(T1& A, T2& B, T3& C, T4, T5, T6, T7, T8, T9,  \
        T10, T11)      \
    {

#define BZ_DECLARE_STENCIL4(name,A,B,C,D)             \
  struct name {                                       \
    template<class T1, class T2, class T3, class T4, class T5, class T6,  \
        class T7, class T8, class T9, class T10, class T11>  \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5, T6, T7, \
        T8, T9, T10, T11)     \
    {

#define BZ_DECLARE_STENCIL5(name,A,B,C,D,E) \
  struct name { \
    template<class T1, class T2, class T3, class T4, class T5, class T6, \
        class T7, class T8, class T9, class T10, class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6, T7, T8, \
        T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL6(name,A,B,C,D,E,F) \
  struct name { \
    template<class T1, class T2, class T3, class T4, class T5, class T6, \
        class T7, class T8, class T9, class T10, class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, \
        T7, T8, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL7(name,A,B,C,D,E,F,G) \
  struct name { \
    template<class T1, class T2, class T3, class T4, \
      class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
        T8, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL8(name,A,B,C,D,E,F,G,H) \
  struct name { \
    template<class T1, class T2, class T3, class T4, \
      class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL9(name,A,B,C,D,E,F,G,H,I) \
  struct name { \
    template<class T1, class T2, class T3, class T4, \
      class T5, class T6, class T7, class T8, class T9, class T10, \
      class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10, T11) \
    {

#define BZ_DECLARE_STENCIL10(name,A,B,C,D,E,F,G,H,I,J) \
  struct name { \
    template<class T1, class T2, class T3, class T4, \
      class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10& J, T11) \
    {

#define BZ_DECLARE_STENCIL11(name,A,B,C,D,E,F,G,H,I,J,K) \
  struct name { \
    template<class T1, class T2, class T3, class T4, \
      class T5, class T6, class T7, class T8, class T9, class T10, \
      class T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10& J, T11& K) \
    {



/*
 * dummyArray is used to provide "dummy" padding parameters to applyStencil(),
 * so that any number of arrays (up to 11) can be given as arguments.
 */

template<class T> class dummy;

struct dummyArray {
    typedef dummy<double> T_iterator;

    const dummyArray& shape() const { return *this; }
};

_bz_global dummyArray _dummyArray;

/*
 * This dummy class pretends to be a scalar of type T, or an array iterator
 * of type T, but really does nothing.
 */
template<class T>
class dummy {
public:
    dummy() { }

    dummy(T value)
      : value_(value)
    { }

    dummy(const dummyArray&)
    { }

    operator T() const { return value_; };

    template<class T2>
    void operator=(T2) { }

    _bz_typename multicomponent_traits<T>::T_element operator[](int i) const
    { return value_[i]; }

    void loadStride(int) { }
    void moveTo(int) { }
    void moveTo(int,int) { }
    void moveTo(int,int,int) { }
    void moveTo(int,int,int,int) { }
    void advance() { }
    T shift(int,int) { return T(); }

private:
    T value_;
};


/*
 * The stencilExtent object is passed to stencil objects to find out
 * the spatial extent of the stencil.  It pretends it's an array,
 * but really it's just recording the locations of the array reads
 * via operator().
 */

template<int N_rank, class P_numtype>
class stencilExtent {
public:
    typedef P_numtype T_numtype;

    stencilExtent()
    {
        min_ = 0;
        max_ = 0;
    }
  
    dummy<T_numtype> operator()(int i)
    {
        update(0, i);
        return dummy<T_numtype>(1);
    }
 
    dummy<T_numtype> operator()(int i, int j)
    {
        update(0, i);
        update(1, j);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> operator()(int i, int j, int k)
    {
        update(0, i);
        update(1, j);
        update(2, k);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> shift(int offset, int dim)
    {
        update(dim, offset);
        return dummy<T_numtype>(1);
    }
  
    dummy<T_numtype> shift(int offset1, int dim1, int offset2, int dim2)
    {
        update(dim1, offset1);
        update(dim2, offset2);
        return dummy<T_numtype>(1);
    }
 
    dummy<_bz_typename multicomponent_traits<T_numtype>::T_element> 
        operator[](int)
    {
        return dummy<_bz_typename multicomponent_traits<T_numtype>::T_element>
            (1);
    }
 
    void update(int rank, int offset)
    {
        if (offset < min_[rank])
            min_[rank] = offset;
        if (offset > max_[rank])
            max_[rank] = offset;
    }

    template<class T_numtype2>
    void combine(const stencilExtent<N_rank,T_numtype2>& x)
    {
        for (int i=0; i < N_rank; ++i)
        {
            min_[i] = minmax::min(min_[i], x.min(i));
            max_[i] = minmax::max(max_[i], x.max(i));
        }
    }

    template<class T_numtype2>
    void combine(const dummy<T_numtype2>&)
    { }

    int min(int i) const
    { return min_[i]; }

    int max(int i) const
    { return max_[i]; }

    const TinyVector<int,N_rank>& min() const
    { return min_; }

    const TinyVector<int,N_rank>& max() const
    { return max_; }

    template<class T>
    void operator=(T)
    { }

    // NEEDS_WORK: other operators
    template<class T> void operator+=(T) { }
    template<class T> void operator-=(T) { }
    template<class T> void operator*=(T) { }
    template<class T> void operator/=(T) { }

    operator T_numtype()
    { return T_numtype(1); }

    T_numtype operator*()
    { return T_numtype(1); }
 
private:
    _bz_mutable TinyVector<int,N_rank> min_, max_;
};


/*
 * stencilExtent_traits gives a stencilExtent<N,T> object for arrays,
 * and a dummy object for dummy arrays.
 */
template<class T>
struct stencilExtent_traits {
    typedef dummy<double> T_stencilExtent;
};

template<class T_numtype, int N_rank>
struct stencilExtent_traits<Array<T_numtype,N_rank> > {
    typedef stencilExtent<N_rank,T_numtype> T_stencilExtent;
};

/*
 * Specialization of areShapesConformable(), originally
 * defined in <blitz/shapecheck.h>
 */

template<class T_shape1>
inline _bz_bool areShapesConformable(const T_shape1&, const dummyArray&)
{
    return _bz_true;
}

BZ_NAMESPACE_END

#include <blitz/array/stencil.cc>

#endif // BZ_ARRAYSTENCIL_H

                                                                                         stencilops.h                                                                                        0100644 0001750 0001750 00000111661 12160377112 043373  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/stencilops.h  Stencil operators
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYSTENCILOPS_H
#define BZ_ARRAYSTENCILOPS_H

// NEEDS_WORK: need to factor many of the stencils in terms of the
// integer constants, e.g. 16*(A(-1,0)+A(0,-1)+A(0,1)+A(1,0))

#ifndef BZ_ARRAYSTENCILS_H
 #error <blitz/array/stencilops.h> must be included via <blitz/array/stencils.h>
#endif

#ifndef BZ_GEOMETRY_H
 #include <blitz/array/geometry.h>
#endif

#ifndef BZ_TINYMAT_H
 #include <blitz/tinymat.h>
#endif

BZ_NAMESPACE(blitz)

#define BZ_DECLARE_STENCIL_OPERATOR1(name,A)     \
  template<typename T>                              \
  inline _bz_typename T::T_numtype name(T& A)    \
  {

#define BZ_END_STENCIL_OPERATOR   }

#define BZ_DECLARE_STENCIL_OPERATOR2(name,A,B)       \
  template<typename T>                                  \
  inline _bz_typename T::T_numtype name(T& A, T& B)  \
  {

#define BZ_DECLARE_STENCIL_OPERATOR3(name,A,B,C) \
  template<typename T>                              \
  inline _bz_typename T::T_numtype name(T& A, T& B, T& C)    \
  {

// These constants are accurate to 45 decimal places = 149 bits of mantissa
const double recip_2 = .500000000000000000000000000000000000000000000;
const double recip_4 = .250000000000000000000000000000000000000000000;
const double recip_6 = .166666666666666666666666666666666666666666667;
const double recip_8 = .125000000000000000000000000000000000000000000;
const double recip_12 = .0833333333333333333333333333333333333333333333;
const double recip_144 = .00694444444444444444444444444444444444444444444;

/****************************************************************************
 * Laplacian Operators
 ****************************************************************************/

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian2D, A)
  return -4.0 * (*A)
    + A.shift(-1,0) + A.shift(1,0)
    + A.shift(-1,1) + A.shift(1,1);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian3D, A)
  return -6.0 * (*A) 
    + A.shift(-1,0) + A.shift(1,0) 
    + A.shift(-1,1) + A.shift(1,1)
    + A.shift(-1,2) + A.shift(1,2);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian2D4, A)
  return -60.0 * (*A) 
    + 16.0 * (A.shift(-1,0) + A.shift(1,0) + A.shift(-1,1) + A.shift(1,1))
    -        (A.shift(-2,0) + A.shift(2,0) + A.shift(-2,1) + A.shift(2,1));
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian2D4n, A)
  return Laplacian2D4(A) * recip_12;
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian3D4, A)
  return -90.0 * (*A) 
    + 16.0 * (A.shift(-1,0) + A.shift(1,0) + A.shift(-1,1) + A.shift(1,1) +
              A.shift(-1,2) + A.shift(1,2))
    -        (A.shift(-2,0) + A.shift(2,0) + A.shift(-2,1) + A.shift(2,1) +
              A.shift(-2,2) + A.shift(2,2));
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR1(Laplacian3D4n, A)
  return Laplacian3D4(A) * recip_12;
BZ_END_STENCIL_OPERATOR

/****************************************************************************
 * Derivatives
 ****************************************************************************/

#define BZ_DECLARE_DIFF(name)  \
  template<typename T> \
  inline _bz_typename T::T_numtype name(T& A, int dim = firstDim)

#define BZ_DECLARE_MULTIDIFF(name) \
  template<typename T> \
  inline _bz_typename multicomponent_traits<_bz_typename     \
     T::T_numtype>::T_element name(T& A, int comp, int dim)

/****************************************************************************
 * Central differences with accuracy O(h^2)
 ****************************************************************************/

BZ_DECLARE_DIFF(central12) {
  return A.shift(1,dim) - A.shift(-1,dim);
}

BZ_DECLARE_DIFF(central22) {
  return -2.0 * (*A) + A.shift(1,dim) + A.shift(-1,dim);
}

BZ_DECLARE_DIFF(central32) {
  return -2.0 * (A.shift(1,dim) - A.shift(-1,dim))
    +           (A.shift(2,dim) - A.shift(-2,dim));
}

BZ_DECLARE_DIFF(central42) {
  return 6.0 * (*A)
    - 4.0 * (A.shift(1,dim) + A.shift(-1,dim))
    +       (A.shift(2,dim) + A.shift(-2,dim));
}

/****************************************************************************
 * Central differences with accuracy O(h^2)  (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(central12) {
  return A.shift(1,dim)[comp] - A.shift(-1,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(central22) {
  return -2.0 * (*A)[comp]
    + A.shift(1,dim)[comp] + A.shift(-1,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(central32) {
  return -2.0 * (A.shift(1,dim)[comp] - A.shift(-1,dim)[comp])
    +           (A.shift(2,dim)[comp] - A.shift(-2,dim)[comp]);
}

BZ_DECLARE_MULTIDIFF(central42) {
  return 6.0 * (*A)[comp]
    -4.0 * (A.shift(1,dim)[comp] + A.shift(-1,dim)[comp])
    +      (A.shift(2,dim)[comp] + A.shift(-2,dim)[comp]);
}

/****************************************************************************
 * Central differences with accuracy O(h^2)  (normalized versions)
 ****************************************************************************/

BZ_DECLARE_DIFF(central12n) {
  return central12(A,dim) * recip_2;
}

BZ_DECLARE_DIFF(central22n) {
  return central22(A,dim);
}

BZ_DECLARE_DIFF(central32n) {
  return central32(A,dim) * recip_2;
}

BZ_DECLARE_DIFF(central42n) {
  return central42(A,dim);
}

/****************************************************************************
 * Central differences with accuracy O(h^2)  (normalized multicomponent)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(central12n) {
  return central12(A,comp,dim) * recip_2;
}

BZ_DECLARE_MULTIDIFF(central22n) {
  return central22(A,comp,dim);
}

BZ_DECLARE_MULTIDIFF(central32n) {
  return central32(A,comp,dim) * recip_2;
}

BZ_DECLARE_MULTIDIFF(central42n) {
  return central42(A,comp,dim);
}

/****************************************************************************
 * Central differences with accuracy O(h^4)  
 ****************************************************************************/

BZ_DECLARE_DIFF(central14) {
  return 8.0 * (A.shift(1,dim) - A.shift(-1,dim))
    -          (A.shift(2,dim) - A.shift(-2,dim));
}

BZ_DECLARE_DIFF(central24) {
  return -30.0 * (*A)
    + 16.0 * (A.shift(1,dim) + A.shift(-1,dim))
    -        (A.shift(2,dim) + A.shift(-2,dim));
}

BZ_DECLARE_DIFF(central34) {
  return -13.0 * (A.shift(1,dim) - A.shift(-1,dim))
    +      8.0 * (A.shift(2,dim) - A.shift(-2,dim))
    -            (A.shift(3,dim) - A.shift(-3,dim));
}

BZ_DECLARE_DIFF(central44) {
  return 56.0 * (*A)
    - 39.0 * (A.shift(1,dim) + A.shift(-1,dim))
    + 12.0 * (A.shift(2,dim) + A.shift(-2,dim))
    -        (A.shift(3,dim) + A.shift(-3,dim));
}

/****************************************************************************
 * Central differences with accuracy O(h^4)  (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(central14) {
  return 8.0 * (A.shift(1,dim)[comp] - A.shift(-1,dim)[comp])
    -          (A.shift(2,dim)[comp] - A.shift(-2,dim)[comp]);
}

BZ_DECLARE_MULTIDIFF(central24) {
  return - 30.0 * (*A)[comp]
    + 16.0 * (A.shift(1,dim)[comp] + A.shift(-1,dim)[comp])
    -        (A.shift(2,dim)[comp] + A.shift(-2,dim)[comp]);
}

BZ_DECLARE_MULTIDIFF(central34) {
  return -13.0 * (A.shift(1,dim)[comp] - A.shift(-1,dim)[comp])
    +      8.0 * (A.shift(2,dim)[comp] - A.shift(-2,dim)[comp])
    -            (A.shift(3,dim)[comp] - A.shift(-3,dim)[comp]);
}

BZ_DECLARE_MULTIDIFF(central44) {
  return 56.0 * (*A)[comp]
    - 39.0 * (A.shift(1,dim)[comp] + A.shift(-1,dim)[comp])
    + 12.0 * (A.shift(2,dim)[comp] + A.shift(-2,dim)[comp])
    -        (A.shift(3,dim)[comp] + A.shift(-3,dim)[comp]);
}

/****************************************************************************
 * Central differences with accuracy O(h^4)  (normalized)
 ****************************************************************************/

BZ_DECLARE_DIFF(central14n) {
  return central14(A,dim) * recip_12;
}

BZ_DECLARE_DIFF(central24n) {
  return central24(A,dim) * recip_12;
}

BZ_DECLARE_DIFF(central34n) {
  return central34(A,dim) * recip_8;
}

BZ_DECLARE_DIFF(central44n) {
  return central44(A,dim) * recip_6;
}

/****************************************************************************
 * Central differences with accuracy O(h^4)  (normalized, multicomponent)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(central14n) {
  return central14(A,comp,dim) * recip_12;
}

BZ_DECLARE_MULTIDIFF(central24n) {
  return central24(A,comp,dim) * recip_12;
}

BZ_DECLARE_MULTIDIFF(central34n) {
  return central34(A,comp,dim) * recip_8;
}

BZ_DECLARE_MULTIDIFF(central44n) {
  return central44(A,comp,dim) * recip_6;
}

/****************************************************************************
 * Backward differences with accuracy O(h)
 ****************************************************************************/

BZ_DECLARE_DIFF(backward11) {
  return (*A) - A.shift(-1,dim);
}

BZ_DECLARE_DIFF(backward21) {
  return (*A) - 2.0 * A.shift(-1,dim) + A.shift(-2,dim);
}

BZ_DECLARE_DIFF(backward31) {
  return (*A) - 3.0 * A.shift(-1,dim) + 3.0 * A.shift(-2,dim)
    - A.shift(-3,dim);
}

BZ_DECLARE_DIFF(backward41) {
  return (*A) - 4.0 * A.shift(-1,dim) + 6.0 * A.shift(-2,dim)
    - 4.0 * A.shift(-3,dim) + A.shift(-4,dim);
}

/****************************************************************************
 * Backward differences with accuracy O(h) (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(backward11) {
  return (*A)[comp] - A.shift(-1,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward21) {
  return (*A)[comp] - 2.0 * A.shift(-1,dim)[comp] + A.shift(-2,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward31) {
  return (*A)[comp] - 3.0 * A.shift(-1,dim)[comp] + 3.0 * A.shift(-2,dim)[comp]
    - A.shift(-3,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward41) {
  return (*A)[comp] - 4.0 * A.shift(-1,dim)[comp] + 6.0 * A.shift(-2,dim)[comp]
    - 4.0 * A.shift(-3,dim)[comp] + A.shift(-4,dim)[comp];
}

/****************************************************************************
 * Backward differences with accuracy O(h)  (normalized)
 ****************************************************************************/

BZ_DECLARE_DIFF(backward11n) { return backward11(A,dim); }
BZ_DECLARE_DIFF(backward21n) { return backward21(A,dim); }
BZ_DECLARE_DIFF(backward31n) { return backward31(A,dim); }
BZ_DECLARE_DIFF(backward41n) { return backward41(A,dim); }

/****************************************************************************
 * Backward differences with accuracy O(h)  (normalized, multicomponent)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(backward11n) { return backward11(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(backward21n) { return backward21(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(backward31n) { return backward31(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(backward41n) { return backward41(A,comp,dim); }

/****************************************************************************
 * Backward differences with accuracy O(h^2)
 ****************************************************************************/

BZ_DECLARE_DIFF(backward12) {
  return 3.0 * (*A) - 4.0 * A.shift(-1,dim) + A.shift(-2,dim);
}

BZ_DECLARE_DIFF(backward22) {
  return 2.0 * (*A) - 5.0 * A.shift(-1,dim) + 4.0 * A.shift(-2,dim)
    - A.shift(-3,dim);
}

BZ_DECLARE_DIFF(backward32) {
  return 5.0 * (*A) - 18.0 * A.shift(-1,dim) + 24.0 * A.shift(-2,dim)
    - 14.0 * A.shift(-3,dim) + 3.0 * A.shift(-4,dim);
}

BZ_DECLARE_DIFF(backward42) {
  return 3.0 * (*A) - 14.0 * A.shift(-1,dim) + 26.0 * A.shift(-2,dim)
    - 24.0 * A.shift(-3,dim) + 11.0 * A.shift(-4,dim) - 2.0 * A.shift(-5,dim);
}

/****************************************************************************
 * Backward differences with accuracy O(h^2) (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(backward12) {
  return 3.0 * (*A)[comp] - 4.0 * A.shift(-1,dim)[comp]
    + A.shift(-2,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward22) {
  return 2.0 * (*A)[comp] - 5.0 * A.shift(-1,dim)[comp]
    + 4.0 * A.shift(-2,dim)[comp] - A.shift(-3,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward32) {
  return 5.0 * (*A)[comp] - 18.0 * A.shift(-1,dim)[comp]
    + 24.0 * A.shift(-2,dim)[comp] - 14.0 * A.shift(-3,dim)[comp]
    + 3.0 * A.shift(-4,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(backward42) {
  return 3.0 * (*A)[comp] - 14.0 * A.shift(-1,dim)[comp]
    + 26.0 * A.shift(-2,dim)[comp] - 24.0 * A.shift(-3,dim)[comp]
    + 11.0 * A.shift(-4,dim)[comp] - 2.0 * A.shift(-5,dim)[comp];
}

/****************************************************************************
 * Backward differences with accuracy O(h^2)  (normalized)
 ****************************************************************************/

BZ_DECLARE_DIFF(backward12n) { return backward12(A,dim) * recip_2; }
BZ_DECLARE_DIFF(backward22n) { return backward22(A,dim); }
BZ_DECLARE_DIFF(backward32n) { return backward32(A,dim) * recip_2; }
BZ_DECLARE_DIFF(backward42n) { return backward42(A,dim); }

/****************************************************************************
 * Backward differences with accuracy O(h^2)  (normalized, multicomponent)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(backward12n) { return backward12(A,comp,dim) * recip_2; }
BZ_DECLARE_MULTIDIFF(backward22n) { return backward22(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(backward32n) { return backward32(A,comp,dim) * recip_2; }
BZ_DECLARE_MULTIDIFF(backward42n) { return backward42(A,comp,dim); }

/****************************************************************************
 * Forward differences with accuracy O(h)  
 ****************************************************************************/

BZ_DECLARE_DIFF(forward11) {
  return -(*A) + A.shift(1,dim);
}

BZ_DECLARE_DIFF(forward21) {
  return (*A) - 2.0 * A.shift(1,dim) + A.shift(2,dim);
}

BZ_DECLARE_DIFF(forward31) {
  return -(*A) + 3.0 * A.shift(1,dim) - 3.0 * A.shift(2,dim) + A.shift(3,dim);
}

BZ_DECLARE_DIFF(forward41) {
  return (*A) - 4.0 * A.shift(1,dim) + 6.0 * A.shift(2,dim)
    - 4.0 * A.shift(3,dim) + A.shift(4,dim);
}

/****************************************************************************
 * Forward differences with accuracy O(h)  (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(forward11) {
  return  -(*A)[comp] + A.shift(1,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward21) {
  return (*A)[comp] - 2.0 * A.shift(1,dim)[comp] + A.shift(2,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward31) {
  return -(*A)[comp] + 3.0 * A.shift(1,dim)[comp] - 3.0 * A.shift(2,dim)[comp]
    + A.shift(3,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward41) {
  return (*A)[comp] - 4.0 * A.shift(1,dim)[comp] + 6.0 * A.shift(2,dim)[comp]
    - 4.0 * A.shift(3,dim)[comp] + A.shift(4,dim)[comp];
}

/****************************************************************************
 * Forward differences with accuracy O(h)     (normalized)
 ****************************************************************************/

BZ_DECLARE_DIFF(forward11n) { return forward11(A,dim); }
BZ_DECLARE_DIFF(forward21n) { return forward21(A,dim); }
BZ_DECLARE_DIFF(forward31n) { return forward31(A,dim); }
BZ_DECLARE_DIFF(forward41n) { return forward41(A,dim); }

/****************************************************************************
 * Forward differences with accuracy O(h)     (multicomponent,normalized)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(forward11n) { return forward11(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(forward21n) { return forward21(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(forward31n) { return forward31(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(forward41n) { return forward41(A,comp,dim); }

/****************************************************************************
 * Forward differences with accuracy O(h^2)     
 ****************************************************************************/

BZ_DECLARE_DIFF(forward12) {
  return -3.0 * (*A) + 4.0 * A.shift(1,dim) - A.shift(2,dim);
}

BZ_DECLARE_DIFF(forward22) {
  return 2.0 * (*A) - 5.0 * A.shift(1,dim) + 4.0 * A.shift(2,dim)
    - A.shift(3,dim);
}

BZ_DECLARE_DIFF(forward32) {
  return -5.0 * (*A) + 18.0 * A.shift(1,dim) - 24.0 * A.shift(2,dim) 
    + 14.0 * A.shift(3,dim) - 3.0 * A.shift(4,dim);
}

BZ_DECLARE_DIFF(forward42) {
  return 3.0 * (*A) - 14.0 * A.shift(1,dim) + 26.0 * A.shift(2,dim)
    - 24.0 * A.shift(3,dim) + 11.0 * A.shift(4,dim) - 2.0 * A.shift(5,dim);
}

/****************************************************************************
 * Forward differences with accuracy O(h^2)   (multicomponent versions)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(forward12) {
  return -3.0 * (*A)[comp] + 4.0 * A.shift(1,dim)[comp] - A.shift(2,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward22) {
  return 2.0 * (*A)[comp] - 5.0 * A.shift(1,dim)[comp]
    + 4.0 * A.shift(2,dim)[comp] - A.shift(3,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward32) {
  return -5.0 * (*A)[comp] + 18.0 * A.shift(1,dim)[comp]
    - 24.0 * A.shift(2,dim)[comp] + 14.0 * A.shift(3,dim)[comp]
    - 3.0 * A.shift(4,dim)[comp];
}

BZ_DECLARE_MULTIDIFF(forward42) {
  return 3.0 * (*A)[comp] - 14.0 * A.shift(1,dim)[comp]
    + 26.0 * A.shift(2,dim)[comp] - 24.0 * A.shift(3,dim)[comp]
    + 11.0 * A.shift(4,dim)[comp] - 2.0 * A.shift(5,dim)[comp];
}


/****************************************************************************
 * Forward differences with accuracy O(h^2)     (normalized)
 ****************************************************************************/

BZ_DECLARE_DIFF(forward12n) { return forward12(A,dim) * recip_2; }
BZ_DECLARE_DIFF(forward22n) { return forward22(A,dim); }
BZ_DECLARE_DIFF(forward32n) { return forward32(A,dim) * recip_2; }
BZ_DECLARE_DIFF(forward42n) { return forward42(A,dim); }

/****************************************************************************
 * Forward differences with accuracy O(h^2)     (normalized)
 ****************************************************************************/

BZ_DECLARE_MULTIDIFF(forward12n) { return forward12(A,comp,dim) * recip_2; }
BZ_DECLARE_MULTIDIFF(forward22n) { return forward22(A,comp,dim); }
BZ_DECLARE_MULTIDIFF(forward32n) { return forward32(A,comp,dim) * recip_2; }
BZ_DECLARE_MULTIDIFF(forward42n) { return forward42(A,comp,dim); }

/****************************************************************************
 * Gradient operators
 ****************************************************************************/

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> grad2D(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central12(A,firstDim),
    central12(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> grad2D4(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central14(A,firstDim),
    central14(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> grad3D(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central12(A,firstDim),
    central12(A,secondDim),
    central12(A,thirdDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> grad3D4(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central14(A,firstDim),
    central14(A,secondDim),
    central14(A,thirdDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> grad2Dn(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central12n(A,firstDim),
    central12n(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> grad2D4n(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central14n(A,firstDim),
    central14n(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> grad3Dn(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central12n(A,firstDim),
    central12n(A,secondDim),
    central12n(A,thirdDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> grad3D4n(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central14n(A,firstDim),
    central14n(A,secondDim),
    central14n(A,thirdDim));
}

/****************************************************************************
 * Grad-squared operators
 ****************************************************************************/

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> gradSqr2D(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central22(A,firstDim),
    central22(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> gradSqr2D4(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central24(A,firstDim),
    central24(A,secondDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> gradSqr3D(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central22(A,firstDim),
    central22(A,secondDim),
    central22(A,thirdDim));
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> gradSqr3D4(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central24(A,firstDim),
    central24(A,secondDim),
    central24(A,thirdDim));
}

/****************************************************************************
 * Grad-squared operators (normalized)
 ****************************************************************************/

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> gradSqr2Dn(T& A) {
  return gradSqr2D(A);
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,2> gradSqr2D4n(T& A) {
  return TinyVector<_bz_typename T::T_numtype,2>(
    central24(A,firstDim) * recip_12,
    central24(A,secondDim) * recip_12);
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> gradSqr3Dn(T& A) {
  return gradSqr3D(A);
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> gradSqr3D4n(T& A) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central24(A,firstDim) * recip_12,
    central24(A,secondDim) * recip_12,
    central24(A,thirdDim) * recip_12);
}

/****************************************************************************
 * Gradient operators on a vector field
 ****************************************************************************/

template<typename T>
inline TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
    T::T_numtype>::T_element, 3, 3>
Jacobian3D(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
        T::T_numtype>::T_element, 3, 3> grad;

    grad(u,x) = central12(A,u,x);
    grad(u,y) = central12(A,u,y);
    grad(u,z) = central12(A,u,z);
    grad(v,x) = central12(A,v,x);
    grad(v,y) = central12(A,v,y);
    grad(v,z) = central12(A,v,z);
    grad(w,x) = central12(A,w,x);
    grad(w,y) = central12(A,w,y);
    grad(w,z) = central12(A,w,z);

    return grad;
}

template<typename T>
inline TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
    T::T_numtype>::T_element, 3, 3>
Jacobian3Dn(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central12n(A,u,x);
    grad(u,y) = central12n(A,u,y);
    grad(u,z) = central12n(A,u,z);
    grad(v,x) = central12n(A,v,x);
    grad(v,y) = central12n(A,v,y);
    grad(v,z) = central12n(A,v,z);
    grad(w,x) = central12n(A,w,x);
    grad(w,y) = central12n(A,w,y);
    grad(w,z) = central12n(A,w,z);

    return grad;
}

template<typename T>
inline TinyMatrix<_bz_typename multicomponent_traits<_bz_typename
    T::T_numtype>::T_element, 3, 3>
Jacobian3D4(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central14(A,u,x);
    grad(u,y) = central14(A,u,y);
    grad(u,z) = central14(A,u,z);
    grad(v,x) = central14(A,v,x);
    grad(v,y) = central14(A,v,y);
    grad(v,z) = central14(A,v,z);
    grad(w,x) = central14(A,w,x);
    grad(w,y) = central14(A,w,y);
    grad(w,z) = central14(A,w,z);

    return grad;
}

template<typename T>
inline TinyMatrix<_bz_typename multicomponent_traits<_bz_typename
    T::T_numtype>::T_element, 3, 3>
Jacobian3D4n(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix<_bz_typename multicomponent_traits<_bz_typename 
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central14n(A,u,x);
    grad(u,y) = central14n(A,u,y);
    grad(u,z) = central14n(A,u,z);
    grad(v,x) = central14n(A,v,x);
    grad(v,y) = central14n(A,v,y);
    grad(v,z) = central14n(A,v,z);
    grad(w,x) = central14n(A,w,x);
    grad(w,y) = central14n(A,w,y);
    grad(w,z) = central14n(A,w,z);

    return grad;
}

/****************************************************************************
 * Curl operators
 ****************************************************************************/

// O(h^2) curl, using central difference

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> 
curl(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector<_bz_typename T::T_numtype,3>(
    central12(vz,y)-central12(vy,z),
    central12(vx,z)-central12(vz,x),
    central12(vy,x)-central12(vx,y));
}

// Normalized O(h^2) curl, using central difference
template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3>
curln(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector<_bz_typename T::T_numtype,3>(
    (central12(vz,y)-central12(vy,z)) * recip_2,
    (central12(vx,z)-central12(vz,x)) * recip_2,
    (central12(vy,x)-central12(vx,y)) * recip_2);
}

// Multicomponent curl
template<typename T>
inline _bz_typename T::T_numtype curl(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return _bz_typename T::T_numtype(
    central12(A,z,y)-central12(A,y,z),
    central12(A,x,z)-central12(A,z,x),
    central12(A,y,x)-central12(A,x,y));
}

// Normalized multicomponent curl
template<typename T>
inline _bz_typename T::T_numtype curln(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return _bz_typename T::T_numtype(
    (central12(A,z,y)-central12(A,y,z)) * recip_2,
    (central12(A,x,z)-central12(A,z,x)) * recip_2,
    (central12(A,y,x)-central12(A,x,y)) * recip_2);
}

// O(h^4) curl, using 4th order central difference
template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3>
curl4(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector<_bz_typename T::T_numtype,3>(
    central14(vz,y)-central14(vy,z),
    central14(vx,z)-central14(vz,x),
    central14(vy,x)-central14(vx,y));
}

// O(h^4) curl, using 4th order central difference (multicomponent version)
template<typename T>
inline _bz_typename T::T_numtype
curl4(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return _bz_typename T::T_numtype(
    central14(A,z,y)-central14(A,y,z),
    central14(A,x,z)-central14(A,z,x),
    central14(A,y,x)-central14(A,x,y));
}

// Normalized O(h^4) curl, using 4th order central difference
template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3>
curl4n(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector<_bz_typename T::T_numtype,3>(
    (central14(vz,y)-central14(vy,z)) * recip_2,
    (central14(vx,z)-central14(vz,x)) * recip_2,
    (central14(vy,x)-central14(vx,y)) * recip_2);
}

// O(h^4) curl, using 4th order central difference (normalized multicomponent)
template<typename T>
inline _bz_typename T::T_numtype
curl4n(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return _bz_typename T::T_numtype(
    (central14(A,z,y)-central14(A,y,z)) * recip_2,
    (central14(A,x,z)-central14(A,z,x)) * recip_2,
    (central14(A,y,x)-central14(A,x,y)) * recip_2);
}



// Two-dimensional curl

template<typename T>
inline _bz_typename T::T_numtype
curl(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return central12(vy,x)-central12(vx,y);
}

template<typename T>
inline _bz_typename T::T_numtype
curln(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return (central12(vy,x)-central12(vx,y)) * recip_2;
}

// Multicomponent curl
template<typename T>
inline _bz_typename T::T_numtype::T_numtype curl2D(T& A) {
  const int x = firstDim, y = secondDim;
  return central12(A,y,x)-central12(A,x,y);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype curl2Dn(T& A) {
  const int x = firstDim, y = secondDim;
  return (central12(A,y,x)-central12(A,x,y)) * recip_2;
}


// 4th order versions

template<typename T>
inline _bz_typename T::T_numtype
curl4(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return central14(vy,x)-central14(vx,y);
}

template<typename T>
inline _bz_typename T::T_numtype
curl4n(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return (central14(vy,x)-central14(vx,y)) * recip_12;
}

// Multicomponent curl
template<typename T>
inline _bz_typename T::T_numtype::T_numtype curl2D4(T& A) {
  const int x = firstDim, y = secondDim;
  return central14(A,y,x)-central14(A,x,y);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype curl2D4n(T& A) {
  const int x = firstDim, y = secondDim;
  return (central14(A,y,x)-central14(A,x,y)) * recip_12;
}

/****************************************************************************
 * Divergence
 ****************************************************************************/


BZ_DECLARE_STENCIL_OPERATOR2(div,vx,vy)
  return central12(vx,firstDim) + central12(vy,secondDim);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR2(divn,vx,vy)
  return (central12(vx,firstDim) + central12(vy,secondDim))
     * recip_2;
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR2(div4,vx,vy)
  return central14(vx,firstDim) + central14(vy,secondDim);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR2(div4n,vx,vy)
  return (central14(vx,firstDim) + central14(vy,secondDim))
    * recip_12;
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR3(div,vx,vy,vz)
  return central12(vx,firstDim) + central12(vy,secondDim) 
    + central12(vz,thirdDim);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR3(divn,vx,vy,vz)
  return (central12(vx,firstDim) + central12(vy,secondDim) 
    + central12(vz,thirdDim)) * recip_2;
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR3(div4,vx,vy,vz)
  return central14(vx,firstDim) + central14(vy,secondDim) 
    + central14(vz,thirdDim);
BZ_END_STENCIL_OPERATOR

BZ_DECLARE_STENCIL_OPERATOR3(div4n,vx,vy,vz)
  return (central14(vx,firstDim) + central14(vy,secondDim)
    + central14(vz,thirdDim)) * recip_12;
BZ_END_STENCIL_OPERATOR

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div2D(T& A)
{
    const int x = firstDim, y = secondDim;
    return central12(A,x,x) + central12(A,y,y);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div2D4(T& A)
{
    const int x = firstDim, y = secondDim;
    return central14(A,x,x) + central14(A,y,y);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div2Dn(T& A)
{
    const int x = firstDim, y = secondDim;
    return (central12(A,x,x) + central12(A,y,y)) * recip_2;
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div2D4n(T& A)
{
    const int x = firstDim, y = secondDim;
    return (central14(A,x,x) + central14(A,y,y)) * recip_12;
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div3D(T& A)
{
    const int x = firstDim, y = secondDim, z = thirdDim;
    return central12(A,x,x) + central12(A,y,y) + central12(A,z,z);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div3D4(T& A)
{
    const int x = firstDim, y = secondDim, z = thirdDim;
    return central14(A,x,x) + central14(A,y,y) + central14(A,z,z);
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div3Dn(T& A)
{
    const int x = firstDim, y = secondDim, z = thirdDim;
    return (central12(A,x,x) + central12(A,y,y) + central12(A,z,z)) * recip_2;
}

template<typename T>
inline _bz_typename T::T_numtype::T_numtype
div3D4n(T& A)
{
    const int x = firstDim, y = secondDim, z = thirdDim;
    return (central14(A,x,x) + central14(A,y,y) + central14(A,z,z)) * recip_12;
}

/****************************************************************************
 * Mixed Partial derivatives
 ****************************************************************************/

template<typename T>
inline _bz_typename T::T_numtype
mixed22(T& A, int x, int y)
{
    return A.shift(-1,x,-1,y) - A.shift(-1,x,1,y)
        -  A.shift(1,x,-1,y) + A.shift(1,x,1,y);
}

template<typename T>
inline _bz_typename T::T_numtype
mixed22n(T& A, int x, int y)
{
    return mixed22(A,x,y) * recip_4;
}

template<typename T>
inline _bz_typename T::T_numtype
mixed24(T& A, int x, int y)
{
    return 64.0 * (A.shift(-1,x,-1,y) - A.shift(-1,x,1,y) -
                   A.shift(1,x,-1,y) + A.shift(1,x,1,y))
        +         (A.shift(-2,x,1,y) - A.shift(-1,x,2,y) -
                   A.shift(1,x,2,y) - A.shift(2,x,1,y) +
                   A.shift(2,x,-1,y) + A.shift(1,x,-2,y) -
                   A.shift(-1,x,-2,y) + A.shift(-2,x,-1,y))
        +   8.0 * (A.shift(-1,x,1,y) + A.shift(-1,x,2,y) -
                   A.shift(2,x,-2,y) + A.shift(2,x,2,y));
}

template<typename T>
inline _bz_typename T::T_numtype
mixed24n(T& A, int x, int y)
{
    return mixed24(A,x,y) * recip_144;
}

/****************************************************************************
 * Smoothers
 ****************************************************************************/

// NEEDS_WORK-- put other stencil operators here:
//   Average5pt2D
//   Average7pt3D
// etc.

/****************************************************************************
 * Stencil operators with geometry (experimental)
 ****************************************************************************/

template<typename T>
inline _bz_typename multicomponent_traits<_bz_typename
    T::T_numtype>::T_element div3DVec4(T& A, 
    const UniformCubicGeometry<3>& geom)
{
    const int x = 0, y = 1, z = 2;

    return (central14(A, x, firstDim) + central14(A, y, secondDim)
        + central14(A, z, thirdDim)) * recip_12 * geom.recipSpatialStep();
}

template<typename T>
inline _bz_typename T::T_numtype Laplacian3D4(T& A, 
    const UniformCubicGeometry<3>& geom)
{
    return Laplacian3D4n(A) * geom.recipSpatialStepPow2();
}

template<typename T>
inline _bz_typename T::T_numtype Laplacian3DVec4(T& A,
    const UniformCubicGeometry<3>& geom)
{
    typedef _bz_typename T::T_numtype vector3d;
    typedef _bz_typename multicomponent_traits<vector3d>::T_element 
        T_element;
    const int u = 0, v = 1, w = 2;
    const int x = 0, y = 1, z = 2;

    // central24 is a 5-point stencil
    // This is a 9*5 = 45 point stencil

    T_element t1 = (central24(A,u,x) + central24(A,u,y) + central24(A,u,z))
        * recip_12 * geom.recipSpatialStepPow2();

    T_element t2 = (central24(A,v,x) + central24(A,v,y) + central24(A,v,z))
        * recip_12 * geom.recipSpatialStepPow2();

    T_element t3 = (central24(A,w,x) + central24(A,w,y) + central24(A,w,z))
        * recip_12 * geom.recipSpatialStepPow2();

    return vector3d(t1,t2,t3);
}

template<typename T>
inline TinyMatrix<_bz_typename multicomponent_traits<_bz_typename
    T::T_numtype>::T_element, 3, 3>
grad3DVec4(T& A, const UniformCubicGeometry<3>& geom)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix<_bz_typename multicomponent_traits<_bz_typename
        T::T_numtype>::T_element, 3, 3> grad;

    // This is a 9*4 = 36 point stencil
    grad(u,x) = central14n(A,u,x) * geom.recipSpatialStep();
    grad(u,y) = central14n(A,u,y) * geom.recipSpatialStep();
    grad(u,z) = central14n(A,u,z) * geom.recipSpatialStep();
    grad(v,x) = central14n(A,v,x) * geom.recipSpatialStep();
    grad(v,y) = central14n(A,v,y) * geom.recipSpatialStep();
    grad(v,z) = central14n(A,v,z) * geom.recipSpatialStep();
    grad(w,x) = central14n(A,w,x) * geom.recipSpatialStep();
    grad(w,y) = central14n(A,w,y) * geom.recipSpatialStep();
    grad(w,z) = central14n(A,w,z) * geom.recipSpatialStep();

    return grad;
}

template<typename T>
inline TinyVector<_bz_typename T::T_numtype,3> grad3D4(T& A,
    const UniformCubicGeometry<3>& geom) {
  return TinyVector<_bz_typename T::T_numtype,3>(
    central14(A,firstDim) * recip_12 * geom.recipSpatialStep(),
    central14(A,secondDim) * recip_12 * geom.recipSpatialStep(),
    central14(A,thirdDim) * recip_12 * geom.recipSpatialStep());
}

BZ_NAMESPACE_END

#endif // BZ_ARRAYSTENCILOPS_H

                                                                               stencils.h                                                                                          0100644 0001750 0001750 00000022725 12160377112 043036  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/stencils.h  Stencils for arrays
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYSTENCILS_H
#define BZ_ARRAYSTENCILS_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/stencils.h> must be included after <blitz/array.h>
#endif

#include <blitz/array/stencilops.h>

// NEEDS_WORK: currently stencilExtent returns int(1).  What if the
// stencil contains calls to math functions, or divisions, etc.?
// Should at least return a number of the appropriate type.  Probably
// return a sequence of quasi-random floating point numbers.

/*
 * These macros make it easier for users to declare stencil objects.
 * The syntax is:
 *
 * BZ_DECLARE_STENCILN(stencilname, Array1, Array2, ..., ArrayN)
 *    // stencil operations go here
 * BZ_END_STENCIL
 */

#define BZ_DECLARE_STENCIL2(name,A,B)    \
  struct name {                          \
    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6, \
             typename T7,typename T8,typename T9,typename T10,typename T11>         \
    static inline void apply(T1& A, T2& B, T3, T4, T5, T6, T7, T8, T9, T10, T11) \
    {

#define BZ_END_STENCIL_WITH_SHAPE(MINS,MAXS) } \
    template<int N> \
    void getExtent(BZ_BLITZ_SCOPE(TinyVector)<int,N>& minb, \
                   BZ_BLITZ_SCOPE(TinyVector)<int,N>& maxb) const \
    { \
        minb = MINS; \
        maxb = MAXS; \
    } \
    static const bool hasExtent = true; \
};

#define BZ_END_STENCIL } static const bool hasExtent = false; };
#define BZ_STENCIL_END BZ_END_STENCIL

#define BZ_DECLARE_STENCIL3(name,A,B,C)         \
  struct name {                                 \
    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6, \
             typename T7,typename T8,typename T9,typename T10,typename T11>      \
    static inline void apply(T1& A, T2& B, T3& C, T4, T5, T6, T7, T8, T9,  \
        T10, T11)      \
    {

#define BZ_DECLARE_STENCIL4(name,A,B,C,D)             \
  struct name {                                       \
    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,  \
             typename T7,typename T8,typename T9,typename T10,typename T11>  \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5, T6, T7, \
        T8, T9, T10, T11)     \
    {

#define BZ_DECLARE_STENCIL5(name,A,B,C,D,E) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6, \
             typename T7,typename T8,typename T9,typename T10,typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6, T7, T8, \
        T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL6(name,A,B,C,D,E,F) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6, \
             typename T7,typename T8,typename T9,typename T10,typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, \
        T7, T8, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL7(name,A,B,C,D,E,F,G) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4, \
             typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
        T8, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL8(name,A,B,C,D,E,F,G,H) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4, \
             typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9, T10, T11) \
    {

#define BZ_DECLARE_STENCIL9(name,A,B,C,D,E,F,G,H,I) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4, \
             typename T5,typename T6,typename T7,typename T8,typename T9,typename T10, \
             typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10, T11) \
    {

#define BZ_DECLARE_STENCIL10(name,A,B,C,D,E,F,G,H,I,J) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4, \
             typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10& J, T11) \
    {

#define BZ_DECLARE_STENCIL11(name,A,B,C,D,E,F,G,H,I,J,K) \
  struct name { \
    template<typename T1,typename T2,typename T3,typename T4, \
             typename T5,typename T6,typename T7,typename T8,typename T9,typename T10, \
             typename T11> \
    static inline void apply(T1& A, T2& B, T3& C, T4& D, T5& E, T6& F, T7& G, \
      T8& H, T9& I, T10& J, T11& K) \
    {


BZ_NAMESPACE(blitz)


/*
 * dummyArray is used to provide "dummy" padding parameters to applyStencil(),
 * so that any number of arrays (up to 11) can be given as arguments.
 */

template<typename T> class dummy;

struct dummyArray {
    typedef dummy<double> T_iterator;

    const dummyArray& shape() const { return *this; }
};

_bz_global dummyArray _dummyArray;

/*
 * This dummy class pretends to be a scalar of type T, or an array iterator
 * of type T, but really does nothing.
 */
template<typename T>
class dummy {
public:
    dummy() { }

    dummy(T value)
      : value_(value)
    { }

    dummy(const dummyArray&)
    { }

    operator T() const { return value_; };

    template<typename T2>
    void operator=(T2) { }

    _bz_typename multicomponent_traits<T>::T_element operator[](int i) const
    { return value_[i]; }

    void loadStride(int) { }
    void moveTo(int) { }
    void moveTo(int,int) { }
    void moveTo(int,int,int) { }
    void moveTo(int,int,int,int) { }
    void advance() { }
    T shift(int,int) { return T(); }

private:
    T value_;
};


/*
 * The stencilExtent object is passed to stencil objects to find out
 * the spatial extent of the stencil.  It pretends it's an array,
 * but really it's just recording the locations of the array reads
 * via operator().
 */

template<int N_rank,typename P_numtype>
class stencilExtent {
public:
    typedef P_numtype T_numtype;

    stencilExtent()
    {
        min_ = 0;
        max_ = 0;
    }
  
    dummy<T_numtype> operator()(int i)
    {
        update(0, i);
        return dummy<T_numtype>(1);
    }
 
    dummy<T_numtype> operator()(int i, int j)
    {
        update(0, i);
        update(1, j);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> operator()(int i, int j, int k)
    {
        update(0, i);
        update(1, j);
        update(2, k);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> shift(int offset, int dim)
    {
        update(dim, offset);
        return dummy<T_numtype>(1);
    }
  
    dummy<T_numtype> shift(int offset1, int dim1, int offset2, int dim2)
    {
        update(dim1, offset1);
        update(dim2, offset2);
        return dummy<T_numtype>(1);
    }
 
    dummy<_bz_typename multicomponent_traits<T_numtype>::T_element> 
        operator[](int)
    {
        return dummy<_bz_typename multicomponent_traits<T_numtype>::T_element>
            (1);
    }
 
    void update(int rank, int offset)
    {
        if (offset < min_[rank])
            min_[rank] = offset;
        if (offset > max_[rank])
            max_[rank] = offset;
    }

    template<typename T_numtype2>
    void combine(const stencilExtent<N_rank,T_numtype2>& x)
    {
        for (int i=0; i < N_rank; ++i)
        {
            min_[i] = minmax::min(min_[i], x.min(i));
            max_[i] = minmax::max(max_[i], x.max(i));
        }
    }

    template<typename T_numtype2>
    void combine(const dummy<T_numtype2>&)
    { }

    int min(int i) const
    { return min_[i]; }

    int max(int i) const
    { return max_[i]; }

    const TinyVector<int,N_rank>& min() const
    { return min_; }

    const TinyVector<int,N_rank>& max() const
    { return max_; }

    template<typename T>
    void operator=(T)
    { }

    // NEEDS_WORK: other operators
    template<typename T> void operator+=(T) { }
    template<typename T> void operator-=(T) { }
    template<typename T> void operator*=(T) { }
    template<typename T> void operator/=(T) { }

    operator T_numtype()
    { return T_numtype(1); }

    T_numtype operator*()
    { return T_numtype(1); }
 
private:
    mutable TinyVector<int,N_rank> min_, max_;
};


/*
 * stencilExtent_traits gives a stencilExtent<N,T> object for arrays,
 * and a dummy object for dummy arrays.
 */
template<typename T>
struct stencilExtent_traits {
    typedef dummy<double> T_stencilExtent;
};

template<typename T_numtype, int N_rank>
struct stencilExtent_traits<Array<T_numtype,N_rank> > {
    typedef stencilExtent<N_rank,T_numtype> T_stencilExtent;
};

/*
 * Specialization of areShapesConformable(), originally
 * defined in <blitz/shapecheck.h>
 */

template<typename T_shape1>
inline bool areShapesConformable(const T_shape1&, const dummyArray&) {
    return true;
}

BZ_NAMESPACE_END

#include <blitz/array/stencils.cc>

#endif // BZ_ARRAYSTENCILS_H

                                           storage.h                                                                                           0100644 0001750 0001750 00000017041 12160377112 042651  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            /***************************************************************************
 * blitz/array/storage.h  Memory layout of Arrays.
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAY_STORAGE_H
#define BZ_ARRAY_STORAGE_H

BZ_NAMESPACE(blitz)

/*
 * Declaration of class GeneralStorage<N_rank>
 *
 * This class describes a storage format for an N-dimensional array.
 * The dimensions can be stored in an arbitrary order (for example, as
 * a C-style row major array or Fortran-style column major array, or
 * something else entirely).  Each dimension can be stored in either
 * ascending (the most common) or descending order.  Each dimension
 * can have its own base (starting index value: e.g. 0 for C-style arrays, 
 * 1 for Fortran arrays).
 *
 * GeneralArrayStorage<N> defaults to C-style arrays.  To implement
 * other storage formats, subclass and modify the constructor.  The
 * class FortranArray, below, is an example.
 *
 * Objects inheriting from GeneralArrayStorage<N> can be passed as
 * an optional constructor argument to Array objects.
 * e.g. Array<int,3> A(16,16,16, FortranArray<3>());
 * will create a 3-dimensional 16x16x16 Fortran-style array.
 */

template<int N_rank>
class GeneralArrayStorage {
public:
    class noInitializeFlag { };

    GeneralArrayStorage(noInitializeFlag)
    { }

    GeneralArrayStorage()
    {
        for (int i=0; i < N_rank; ++i)
          ordering_(i) = N_rank - 1 - i;
        ascendingFlag_ = true;
        base_ = 0;
    }

    GeneralArrayStorage(const GeneralArrayStorage<N_rank>& x)
        : ordering_(x.ordering_), ascendingFlag_(x.ascendingFlag_),
          base_(x.base_)
    { 
    }

    GeneralArrayStorage(TinyVector<int,N_rank> ordering,
        TinyVector<bool,N_rank> ascendingFlag)
      : ordering_(ordering), ascendingFlag_(ascendingFlag)
    {
        base_ = 0;
    }

    ~GeneralArrayStorage()
    { }

    GeneralArrayStorage<N_rank>& operator=(
        const GeneralArrayStorage<N_rank>& rhs)
    {
        ordering_ = rhs.ordering();
        ascendingFlag_ = rhs.ascendingFlag();
        base_ = rhs.base();
        return *this;
    }

    TinyVector<int, N_rank>& ordering()
    { return ordering_; }

    const TinyVector<int, N_rank>& ordering() const
    { return ordering_; }

    int ordering(int i) const
    { return ordering_[i]; }

    void setOrdering(int i, int order) 
    { ordering_[i] = order; }

    bool allRanksStoredAscending() const
    {
        bool result = true;
        for (int i=0; i < N_rank; ++i)
            result &= ascendingFlag_[i];
        return result;
    }

    bool isRankStoredAscending(int i) const
    { return ascendingFlag_[i]; }

    TinyVector<bool, N_rank>& ascendingFlag() 
    { return ascendingFlag_; }

    const TinyVector<bool, N_rank>& ascendingFlag() const
    { return ascendingFlag_; }

    void setAscendingFlag(int i, bool ascendingFlag) 
    { ascendingFlag_[i] = ascendingFlag; }

    TinyVector<int, N_rank>& base()
    { return base_; }

    const TinyVector<int, N_rank>& base() const
    { return base_; }

    int base(int i) const
    { return base_[i]; }

    void setBase(int i, int base)
    { base_[i] = base; }

    void setBase(const TinyVector<int, N_rank>& base)
    { base_ = base; }

protected:
    /*
     * ordering_[] specifies the order in which the array is stored in
     * memory.  For a newly allocated array, ordering_(0) will give the
     * rank with unit stride, and ordering_(N_rank-1) will be the rank
     * with largest stride.  An order like [2, 1, 0] corresponds to
     * C-style array storage; an order like [0, 1, 2] corresponds to
     * Fortran array storage.
     *
     * ascendingFlag_[] indicates whether the data in a rank is stored
     * in ascending or descending order.  Most of the time these values
     * will all be true (indicating ascending order).  Some peculiar 
     * formats (e.g. MS-Windows BMP image format) store the data in 
     * descending order.
     *  
     * base_[] gives the first valid index for each rank.  For a C-style
     * array, all the base_ elements will be zero; for a Fortran-style
     * array, they will be one.  base_[] can be set arbitrarily using
     * the Array constructor which takes a Range argument, e.g.
     * Array<float,2> A(Range(30,40),Range(23,33));
     * will create an array with base_[] = { 30, 23 }.
     */
    TinyVector<int,  N_rank> ordering_;
    TinyVector<bool, N_rank> ascendingFlag_;
    TinyVector<int,  N_rank> base_;
};

/*
 * Class FortranArray specializes GeneralArrayStorage to provide Fortran
 * style arrays (column major ordering, base of 1).  The noInitializeFlag()
 * passed to the base constructor indicates that the subclass will take
 * care of initializing the ordering_, ascendingFlag_ and base_ members.
 */

template<int N_rank>
class FortranArray : public GeneralArrayStorage<N_rank> {
private:
    typedef GeneralArrayStorage<N_rank> T_base;
    typedef _bz_typename T_base::noInitializeFlag noInitializeFlag;
    using T_base::ordering_;
    using T_base::ascendingFlag_;
    using T_base::base_;
public:
    FortranArray()
        : GeneralArrayStorage<N_rank>(noInitializeFlag())
    {
        for (int i=0; i < N_rank; ++i)
          ordering_(i) = i;
        ascendingFlag_ = true;
        base_ = 1;
    }
};


// This tag class can be used to provide a nicer notation for
// constructing Fortran-style arrays: instead of
//     Array<int,2> A(3, 3, FortranArray<2>());
// one can simply write:
//     Array<int,2> A(3, 3, fortranArray);
// where fortranArray is an object of type _bz_fortranTag.

class _bz_fortranTag {
public:
    operator GeneralArrayStorage<1>()
    { return FortranArray<1>(); }

    operator GeneralArrayStorage<2>()
    { return FortranArray<2>(); }

    operator GeneralArrayStorage<3>()
    { return FortranArray<3>(); }

    operator GeneralArrayStorage<4>()
    { return FortranArray<4>(); }

    operator GeneralArrayStorage<5>()
    { return FortranArray<5>(); }

    operator GeneralArrayStorage<6>()
    { return FortranArray<6>(); }

    operator GeneralArrayStorage<7>()
    { return FortranArray<7>(); }

    operator GeneralArrayStorage<8>()
    { return FortranArray<8>(); }

    operator GeneralArrayStorage<9>()
    { return FortranArray<9>(); }

    operator GeneralArrayStorage<10>()
    { return FortranArray<10>(); }

    operator GeneralArrayStorage<11>()
    { return FortranArray<11>(); }
};

// A global instance of this class will be placed in
// the blitz library (libblitz.a on unix machines).

_bz_global _bz_fortranTag fortranArray;


/*
 * Class ColumnMajorArray specializes GeneralArrayStorage to provide column
 * major arrays (column major ordering, base of 0).
 */

template<int N_rank>
class ColumnMajorArray : public GeneralArrayStorage<N_rank> {
private:
    typedef GeneralArrayStorage<N_rank> T_base;
    typedef _bz_typename T_base::noInitializeFlag noInitializeFlag;
    using T_base::ordering_;
    using T_base::ascendingFlag_;
    using T_base::base_;
public:
    ColumnMajorArray()
        : GeneralArrayStorage<N_rank>(noInitializeFlag())
    {
        ordering_ = Range(0, N_rank - 1);
        ascendingFlag_ = true;
        base_ = 0;
    }
};

BZ_NAMESPACE_END

#endif // BZ_ARRAY_STORAGE_H

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               where.h                                                                                             0100644 0001750 0001750 00000014327 12160377112 042323  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/where.h  where(X,Y,Z) operator for array expressions
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYWHERE_H
#define BZ_ARRAYWHERE_H

#ifndef BZ_ARRAYEXPR_H
 #error <blitz/array/where.h> must be included via <blitz/array/expr.h>
#endif

BZ_NAMESPACE(blitz)

template<typename P_expr1, typename P_expr2, typename P_expr3>
class _bz_ArrayWhere {

public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef P_expr3 T_expr3;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef _bz_typename T_expr3::T_numtype T_numtype3;
    typedef BZ_PROMOTE(T_numtype2, T_numtype3) T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;
    typedef T_expr3 T_ctorArg3;

    static const int 
        numArrayOperands = P_expr1::numArrayOperands
                         + P_expr2::numArrayOperands
                         + P_expr3::numArrayOperands,
        numIndexPlaceholders = P_expr1::numIndexPlaceholders
                             + P_expr2::numIndexPlaceholders
                             + P_expr3::numIndexPlaceholders,
        rank = _bz_meta_max<_bz_meta_max<P_expr1::rank,P_expr2::rank>::max,
                            P_expr3::rank>::max;

    _bz_ArrayWhere(const _bz_ArrayWhere<T_expr1,T_expr2,T_expr3>& a)
      : iter1_(a.iter1_), iter2_(a.iter2_), iter3_(a.iter3_)
    { }

    template<typename T1, typename T2, typename T3>
    _bz_ArrayWhere(BZ_ETPARM(T1) a, BZ_ETPARM(T2) b, BZ_ETPARM(T3) c)
      : iter1_(a), iter2_(b), iter3_(c)
    { }

    T_numtype operator*()
    { return (*iter1_) ? (*iter2_) : (*iter3_); }

    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return iter1_(i) ? iter2_(i) : iter3_(i); }

    int ascending(int rank)
    {
        return bounds::compute_ascending(rank, bounds::compute_ascending(
          rank, iter1_.ascending(rank), iter2_.ascending(rank)),
          iter3_.ascending(rank));
    }

    int ordering(int rank)
    {
        return bounds::compute_ordering(rank, bounds::compute_ordering(
          rank, iter1_.ordering(rank), iter2_.ordering(rank)),
          iter3_.ordering(rank));
    }

    int lbound(int rank)
    {
        return bounds::compute_lbound(rank, bounds::compute_lbound(
          rank, iter1_.lbound(rank), iter2_.lbound(rank)), 
          iter3_.lbound(rank));
    }
   
    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, bounds::compute_ubound(
          rank, iter1_.ubound(rank), iter2_.ubound(rank)), 
          iter3_.ubound(rank));
    } 

    void push(int position)
    {
        iter1_.push(position);
        iter2_.push(position);
        iter3_.push(position);
    }

    void pop(int position)
    {
        iter1_.pop(position);
        iter2_.pop(position);
        iter3_.pop(position);
    }

    void advance()
    {
        iter1_.advance();
        iter2_.advance();
        iter3_.advance();
    }

    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
        iter3_.advance(n);
    }

    void loadStride(int rank)
    {
        iter1_.loadStride(rank);
        iter2_.loadStride(rank);
        iter3_.loadStride(rank);
    }

    bool isUnitStride(int rank) const
    { 
        return iter1_.isUnitStride(rank) 
            && iter2_.isUnitStride(rank) 
            && iter3_.isUnitStride(rank);
    }

    void advanceUnitStride()
    {
        iter1_.advanceUnitStride();
        iter2_.advanceUnitStride();
        iter3_.advanceUnitStride();
    }

    bool canCollapse(int outerLoopRank, int innerLoopRank) const
    {
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank)
            && iter3_.canCollapse(outerLoopRank, innerLoopRank);
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
        iter3_.moveTo(i);
    }

    T_numtype operator[](int i)
    { return iter1_[i] ? iter2_[i] : iter3_[i]; }

    T_numtype fastRead(int i)
    { return iter1_.fastRead(i) ? iter2_.fastRead(i) : iter3_.fastRead(i); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        int stride3 = iter3_.suggestStride(rank);
        return stride1>(stride2=(stride2>stride3?stride2:stride3))?stride1:stride2;
        //return minmax::max(minmax::max(stride1,stride2),stride3);
    }

    bool isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) 
            && iter2_.isStride(rank,stride)
            && iter3_.isStride(rank,stride);
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, 
        prettyPrintFormat& format) const
    {
        str += "where(";
        iter1_.prettyPrint(str,format);
        str += ",";
        iter2_.prettyPrint(str,format);
        str += ",";
        iter3_.prettyPrint(str,format);
        str += ")";
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape& shape)
    { 
        int t1 = iter1_.shapeCheck(shape);
        int t2 = iter2_.shapeCheck(shape);
        int t3 = iter3_.shapeCheck(shape);

        return t1 && t2 && t3;
    }

private:
    _bz_ArrayWhere() { }

    T_expr1 iter1_;
    T_expr2 iter2_;
    T_expr3 iter3_;
};

template<typename T1, typename T2, typename T3>
inline
_bz_ArrayExpr<_bz_ArrayWhere<_bz_typename asExpr<T1>::T_expr,
    _bz_typename asExpr<T2>::T_expr, _bz_typename asExpr<T3>::T_expr> >
where(const T1& a, const T2& b, const T3& c)
{
    return _bz_ArrayExpr<_bz_ArrayWhere<_bz_typename asExpr<T1>::T_expr,
       _bz_typename asExpr<T2>::T_expr, 
       _bz_typename asExpr<T3>::T_expr> >(a,b,c);
}

BZ_NAMESPACE_END

#endif // BZ_ARRAYWHERE_H

                                                                                                                                                                                                                                                                                                         zip.h                                                                                               0100644 0001750 0001750 00000003765 12160377112 042017  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/array                            // -*- C++ -*-
/***************************************************************************
 * blitz/array/zip.h  "zip" scalar arrays into a multicomponent array expr
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ****************************************************************************/
#ifndef BZ_ARRAYZIP_H
#define BZ_ARRAYZIP_H

#ifndef BZ_ARRAY_H
 #error <blitz/array/zip.h> must be included via <blitz/array.h>
#endif

BZ_NAMESPACE(blitz)

template<typename P_component, typename T1, typename T2>
struct Zip2 {
    typedef P_component T_numtype;

    static inline T_numtype apply(T1 a, T2 b)
    { return T_numtype(a,b); }

    template<typename T_left, typename T_right>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T_left& t1,
        const T_right& t2)
    {
        str += "zip(";
        t1.prettyPrint(str, format);
        str += ",";
        t2.prettyPrint(str, format);
        str += ")";
    }
};

template<typename T_component, typename T1, typename T2>
inline _bz_ArrayExpr<_bz_ArrayExprBinaryOp<
    _bz_typename asExpr<T1>::T_expr, 
    _bz_typename asExpr<T2>::T_expr, 
    Zip2<T_component, 
         _bz_typename asExpr<T1>::T_expr::T_numtype,
         _bz_typename asExpr<T2>::T_expr::T_numtype> > >
zip(const T1& a, const T2& b, T_component)
{
    return _bz_ArrayExpr<_bz_ArrayExprBinaryOp<
        _bz_typename asExpr<T1>::T_expr,
        _bz_typename asExpr<T2>::T_expr, 
        Zip2<T_component, 
             _bz_typename asExpr<T1>::T_expr::T_numtype,
             _bz_typename asExpr<T2>::T_expr::T_numtype> > >(a,b);
}

BZ_NAMESPACE_END

#endif // BZ_ARRAYZIP_H

           array-impl.h                                                                                        0100644 0001750 0001750 00000272110 12160377112 042144  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/array-impl.h    Definition of the Array<P_numtype, N_rank> class
 *
 * $Id: array-impl.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

/*
 * Wish list for array classes.
 *  - Arrays whose dimensions are unknown at compile time.
 *  - where()/elsewhere()/elsewhere() as in Dan Quinlan's implementation
 *  - block reduction operations
 *  - conversion to/from matrix & vector
 *  - apply(T func(T))
 *  - apply(T func(const T&))
 *  - apply<T func(T)>
 */

#ifndef BZ_ARRAY_H
#define BZ_ARRAY_H

#include <blitz/blitz.h>
#include <blitz/memblock.h>
#include <blitz/range.h>
#include <blitz/tinyvec.h>

#ifdef BZ_ARRAY_SPACE_FILLING_TRAVERSAL
#include <blitz/traversal.h>
#endif

#include <blitz/indexexpr.h>
#include <blitz/prettyprint.h>

#include <blitz/array/slice.h>     // Subarrays and slicing
#include <blitz/array/map.h>       // Tensor index notation
#include <blitz/array/multi.h>     // Multicomponent arrays
#include <blitz/array/domain.h>    // RectDomain class
#include <blitz/array/storage.h>   // GeneralArrayStorage


BZ_NAMESPACE(blitz)

/*
 * Forward declarations
 */

template<typename T_numtype, int N_rank>
class ArrayIterator;

template<typename T_numtype, int N_rank>
class ConstArrayIterator;

template<typename T_numtype, int N_rank>
class FastArrayIterator;

template<typename P_expr>
class _bz_ArrayExpr;

template<typename T_array, typename T_index>
class IndirectArray;

template <typename P_numtype,int N_rank>
void swap(Array<P_numtype,N_rank>&,Array<P_numtype,N_rank>&);

template <typename P_numtype, int N_rank>
void find(Array<TinyVector<int,N_rank>,1>&,const Array<P_numtype,N_rank>&);

/*
 * Declaration of class Array
 */

// NEEDS_WORK: Array should inherit protected from MemoryBlockReference.
// To make this work, need to expose MemoryBlockReference::numReferences()
// and make Array<P,N2> a friend of Array<P,N> for slicing.

template<typename P_numtype, int N_rank>
class Array : public MemoryBlockReference<P_numtype> 
#ifdef BZ_NEW_EXPRESSION_TEMPLATES
    , public ETBase<Array<P_numtype,N_rank> >
#endif
{

private:
    typedef MemoryBlockReference<P_numtype> T_base;
    using T_base::data_;
    using T_base::changeToNullBlock;
    using T_base::numReferences;

public:
    //////////////////////////////////////////////
    // Public Types
    //////////////////////////////////////////////

    /*
     * T_numtype  is the numeric type stored in the array.
     * T_index    is a vector type which can be used to access elements
     *            of many-dimensional arrays.
     * T_array    is the array type itself -- Array<T_numtype, N_rank>
     * T_iterator is a a fast iterator for the array, used for expression
     *            templates
     * iterator   is a STL-style iterator
     * const_iterator is an STL-style const iterator
     */

    typedef P_numtype                T_numtype;
    typedef TinyVector<int, N_rank>  T_index;
    typedef Array<T_numtype, N_rank> T_array;
    typedef FastArrayIterator<T_numtype, N_rank> T_iterator;

    typedef ArrayIterator<T_numtype,N_rank> iterator;
    typedef ConstArrayIterator<T_numtype,N_rank> const_iterator;

    static const int _bz_rank = N_rank;

    //////////////////////////////////////////////
    // Constructors                             //
    //////////////////////////////////////////////

    
    /*
     * Construct an array from an array expression.
     */

    template<typename T_expr>
    explicit Array(_bz_ArrayExpr<T_expr> expr);

    /*
     * Any missing length arguments will have their value taken from the
     * last argument.  For example,
     *   Array<int,3> A(32,64);
     * will create a 32x64x64 array.  This is handled by setupStorage().
     */

    Array(GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_ = 0;
        stride_ = 0;
        zeroOffset_ = 0;
    }

    explicit Array(int length0, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_[0] = length0;
        setupStorage(0);
    }

    Array(int length0, int length1,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 2);
        TAU_TYPE_STRING(p1, "Array<T,N>::Array() [T="
            + CT(T_numtype) + ",N=" + CT(N_rank) + "]");
        TAU_PROFILE(p1, "void (int,int)", TAU_BLITZ);

        length_[0] = length0;
        length_[1] = length1;
        setupStorage(1);
    }

    Array(int length0, int length1, int length2,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 3);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        setupStorage(2);
    }

    Array(int length0, int length1, int length2, int length3,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 4);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        setupStorage(3);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 5);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        setupStorage(4);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 6);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        setupStorage(5);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 7);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        setupStorage(6);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 8);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        setupStorage(7);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 9);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        setupStorage(8);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8, int length9,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 10);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        length_[9] = length9;
        setupStorage(9);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8, int length9,
        int length10,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(N_rank >= 11);
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        length_[9] = length9;
        length_[10] = length10;
        setupStorage(10);
    }

    /*
     * Construct an array from an existing block of memory.  Ownership
     * is not acquired (this is provided for backwards compatibility).
     */
    Array(T_numtype* restrict dataFirst, TinyVector<int, N_rank> shape,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          neverDeleteData),
        storage_(storage)
    {
        BZPRECONDITION(dataFirst != 0);

        length_ = shape;
        computeStrides();
        data_ += zeroOffset_;
    }

    /*
     * Construct an array from an existing block of memory, with a
     * given set of strides.  Ownership is not acquired (i.e. the memory
     * block will not be freed by Blitz++).
     */
    Array(T_numtype* restrict dataFirst, TinyVector<int, N_rank> shape,
        TinyVector<int, N_rank> stride, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          neverDeleteData),
        storage_(storage)
    {
        BZPRECONDITION(dataFirst != 0);

        length_ = shape;
        stride_ = stride;
        calculateZeroOffset();
        data_ += zeroOffset_;
    }

    /*
     * Construct an array from an existing block of memory.
     */
    Array(T_numtype* restrict dataFirst, TinyVector<int, N_rank> shape,
        preexistingMemoryPolicy deletionPolicy,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
            deletionPolicy),
        storage_(storage)
    {
        BZPRECONDITION(dataFirst != 0);

        length_ = shape;
        computeStrides();
        data_ += zeroOffset_;

        if (deletionPolicy == duplicateData)
            reference(copy());
    }

    /*
     * Construct an array from an existing block of memory, with a
     * given set of strides.  
     */
    Array(T_numtype* restrict dataFirst, TinyVector<int, N_rank> shape,
        TinyVector<int, N_rank> stride,
        preexistingMemoryPolicy deletionPolicy,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          deletionPolicy),
        storage_(storage)
    {
        BZPRECONDITION(dataFirst != 0);

        length_ = shape;
        stride_ = stride;
        calculateZeroOffset();
        data_ += zeroOffset_;

        if (deletionPolicy == duplicateData)
            reference(copy());
    }

    /*
     * This constructor takes an extent (length) vector and storage format.
     */

    Array(const TinyVector<int, N_rank>& extent, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_ = extent;
        setupStorage(N_rank - 1);
    }

    /*
     * This construct takes a vector of bases (lbounds) and a vector of
     * extents.
     */

    Array(const TinyVector<int, N_rank>& lbounds,
        const TinyVector<int, N_rank>& extent,
        const GeneralArrayStorage<N_rank>& storage 
           = GeneralArrayStorage<N_rank>());

    /*
     * These constructors allow arbitrary bases (starting indices) to be set.
     * e.g. Array<int,2> A(Range(10,20), Range(20,30))
     * will create an 11x11 array whose indices are 10..20 and 20..30
     */
    Array(Range r0, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        setupStorage(0);
    }

    Array(Range r0, Range r1,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() && 
            r1.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());

        setupStorage(1);
    }

    Array(Range r0, Range r1, Range r2,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());

        setupStorage(2);
    }

    Array(Range r0, Range r1, Range r2, Range r3,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());

        setupStorage(3);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());

        setupStorage(4);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());

        setupStorage(5);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous() && r6.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());

        setupStorage(6);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous() && r6.isAscendingContiguous()
            && r7.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());

        setupStorage(7);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous() && r6.isAscendingContiguous()
            && r7.isAscendingContiguous() && r8.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());

        setupStorage(8);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8, Range r9,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous() && r6.isAscendingContiguous()
            && r7.isAscendingContiguous() && r8.isAscendingContiguous()
            && r9.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());
        length_[9] = r9.length();
        storage_.setBase(9, r9.first());

        setupStorage(9);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8, Range r9, Range r10,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        BZPRECONDITION(r0.isAscendingContiguous() &&
            r1.isAscendingContiguous() && r2.isAscendingContiguous()
            && r3.isAscendingContiguous() && r4.isAscendingContiguous()
            && r5.isAscendingContiguous() && r6.isAscendingContiguous()
            && r7.isAscendingContiguous() && r8.isAscendingContiguous()
            && r9.isAscendingContiguous() && r10.isAscendingContiguous());

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());
        length_[9] = r9.length();
        storage_.setBase(9, r9.first());
        length_[10] = r10.length();
        storage_.setBase(10, r10.first());

        setupStorage(10);
    }

    /*
     * Create a reference of another array
     */
    Array(const Array<T_numtype, N_rank>& array)
#ifdef BZ_NEW_EXPRESSION_TEMPLATES
        : MemoryBlockReference<T_numtype>(),
          ETBase< Array<T_numtype, N_rank> >(array)
#else
        : MemoryBlockReference<T_numtype>()
#endif
    {
        // NEEDS_WORK: this const_cast is a tad ugly.
        reference(const_cast<T_array&>(array));
    }

    /*
     * These constructors are used for creating interlaced arrays (see
     * <blitz/arrayshape.h>
     */
    Array(const TinyVector<int,N_rank-1>& shape,
        int lastExtent, const GeneralArrayStorage<N_rank>& storage);
    //Array(const TinyVector<Range,N_rank-1>& shape,
    //    int lastExtent, const GeneralArrayStorage<N_rank>& storage);

    /*
     * These constructors make the array a view of a subportion of another
     * array.  If there fewer than N_rank Range arguments provided, no
     * slicing is performed in the unspecified ranks.
     * e.g. Array<int,3> A(20,20,20);
     *      Array<int,3> B(A, Range(5,15));
     * is equivalent to:
     *      Array<int,3> B(A, Range(5,15), Range::all(), Range::all());
     */
    Array(Array<T_numtype, N_rank>& array, Range r0)
    {
        constructSubarray(array, r0);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1)
    {
        constructSubarray(array, r0, r1);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2)
    {
        constructSubarray(array, r0, r1, r2);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3)
    {
        constructSubarray(array, r0, r1, r2, r3);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4)
    {
        constructSubarray(array, r0, r1, r2, r3, r4);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8, Range r9)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8, Range r9,
        Range r10)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

    Array(Array<T_numtype, N_rank>& array, 
        const RectDomain<N_rank>& subdomain)
    {
        constructSubarray(array, subdomain);
    }

    /* Constructor added by Julian Cummings */
    Array(Array<T_numtype, N_rank>& array, 
        const StridedDomain<N_rank>& subdomain)
    {
        constructSubarray(array, subdomain);
    }

    /*
     * This constructor is invoked by the operator()'s which take
     * a combination of integer and Range arguments.  It's not intended
     * for end-user use.
     */
    template<int N_rank2, typename R0, typename R1, typename R2, typename R3, typename R4,
        typename R5, typename R6, typename R7, typename R8, typename R9, typename R10>
    Array(Array<T_numtype,N_rank2>& array, R0 r0, R1 r1, R2 r2,
        R3 r3, R4 r4, R5 r5, R6 r6, R7 r7, R8 r8, R9 r9, R10 r10)
    {
        constructSlice(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

    //////////////////////////////////////////////
    // Member functions
    //////////////////////////////////////////////

    const TinyVector<int, N_rank>&    base() const
    { return storage_.base(); }

    int                               base(int rank) const
    { return storage_.base(rank); }

    iterator                          begin() 
    { return iterator(*this); }

    const_iterator                    begin() const
    { return const_iterator(*this); }

    T_iterator                        beginFast() const
    { return T_iterator(*this); }

    // Deprecated: now extractComponent(...)
    template<typename P_numtype2>
    Array<P_numtype2,N_rank>          chopComponent(P_numtype2 a, int compNum,
                                          int numComponents) const
    { return extractComponent(a, compNum, numComponents); }

    int                               cols() const
    { return length_[1]; }

    int                               columns() const
    { return length_[1]; }

    T_array                           copy() const;

    // data_ always refers to the point (0,0,...,0) which may
    // not be in the array if the base is not zero in each rank.
    // These data() routines return a pointer to the first
    // element in the array (but note that it may not be
    // stored first in memory if some ranks are stored descending).

    int                               dataOffset() const
    {
        return dot(storage_.base(), stride_);
    }

    const T_numtype* restrict     data() const
    { return data_ + dataOffset(); }

    T_numtype* restrict           data() 
    { return data_ + dataOffset(); }

    // These dataZero() routines refer to the point (0,0,...,0)
    // which may not be in the array if the bases are nonzero.
    
    const T_numtype* restrict     dataZero() const
    { return data_; }

    T_numtype* restrict           dataZero()
    { return data_; }

    // These dataFirst() routines refer to the element in the
    // array which falls first in memory.

    int                               dataFirstOffset() const
    {
        int pos = 0;

        // Used to use tinyvector expressions:
        // return data_ + dot(storage_.base()
        //     + (1 - storage_.ascendingFlag()) * (length_ - 1), stride_);

        for (int i=0; i < N_rank; ++i)
           pos += (storage_.base(i) + (1-storage_.isRankStoredAscending(i)) *
              (length_(i)-1)) * stride_(i);

        return pos;
    }
    
    const T_numtype* restrict     dataFirst() const
    {
        return data_ + dataFirstOffset();
    }

    T_numtype* restrict           dataFirst()
    {
        return data_ + dataFirstOffset();
    }

    int                               depth() const
    { return length_[2]; }

    int                               dimensions() const
    { return N_rank; }

    RectDomain<N_rank>                domain() const
    {
        return RectDomain<N_rank>(lbound(), ubound());
    }

    void dumpStructureInformation(ostream& os = cout) const;

    iterator                          end()
    {
        return iterator();
    }

    const_iterator                    end() const
    {
        return const_iterator();
    }

    int                               extent(int rank) const
    { return length_[rank]; }

    const TinyVector<int,N_rank>&     extent() const
    { return length_; }

    template<typename P_numtype2>
    Array<P_numtype2,N_rank>          extractComponent(P_numtype2, int compNum,
                                          int numComponents) const;

    void                              free() 
    {
        changeToNullBlock();
        length_ = 0;
    }
 
    bool isMajorRank(int rank) const { return storage_.ordering(rank) == 0; }
    bool isMinorRank(int rank) const { return storage_.ordering(rank) != 0; }
    bool isRankStoredAscending(int rank) const {
        return storage_.isRankStoredAscending(rank);
    }

    bool isStorageContiguous() const;

    int                    lbound(int rank) const { return base(rank); }
    TinyVector<int,N_rank> lbound()         const { return base(); }

    int                            length(int rank) const { return length_[rank]; }
    const TinyVector<int, N_rank>& length()         const { return length_; }

    void makeUnique();

    int numElements() const { return product(length_); }

    // NEEDS_WORK -- Expose the numReferences() method
    // MemoryBlockReference<T_numtype>::numReferences;

    // The storage_.ordering_ array is a list of dimensions from
    // the most minor (stride 1) to major dimension.  Generally,
    // ordering(0) will return the dimension which has the smallest
    // stride, and ordering(N_rank-1) will return the dimension with
    // the largest stride.
    int                               ordering(int storageRankIndex) const
    { return storage_.ordering(storageRankIndex); }

    const TinyVector<int, N_rank>&    ordering() const
    { return storage_.ordering(); }

    void                              transposeSelf(int r0, int r1, int r2=0, 
        int r3=0, int r4=0, int r5=0, int r6=0, int r7=0, int r8=0, int 
        r9=0, int r10=0);
    T_array                           transpose(int r0, int r1, int r2=0,
        int r3=0, int r4=0, int r5=0, int r6=0, int r7=0, int r8=0, int
        r9=0, int r10=0);

    int                               rank() const
    { return N_rank; }

    void                              reference(const T_array&);

    // Added by Derrick Bass
    T_array                           reindex(const TinyVector<int,N_rank>&);
    void                              reindexSelf(const 
                                                TinyVector<int,N_rank>&);

    void                              resize(int extent);
    void                              resize(int extent1, int extent2);
    void                              resize(int extent1, int extent2,
                                        int extent3);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9, int extent10);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9, int extent10, 
                                        int extent11);


    void                              resize(Range r1);
    void                              resize(Range r1, Range r2);
    void                              resize(Range r1, Range r2, Range r3);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9, 
                                        Range r10);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9, 
                                        Range r10, Range r11);

    void                              resize(const TinyVector<int,N_rank>&);
 

    void                              resizeAndPreserve(const TinyVector<int,
                                                                   N_rank>&);
    void                              resizeAndPreserve(int extent);
    void                              resizeAndPreserve(int extent1, 
                                        int extent2);
    void                              resizeAndPreserve(int extent1, 
                                        int extent2, int extent3);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9, 
                                        int extent10);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9, int extent10,
                                        int extent11);

    // NEEDS_WORK -- resizeAndPreserve(Range,...)
    // NEEDS_WORK -- resizeAndPreserve(const Domain<N_rank>&);

    T_array                           reverse(int rank);
    void                              reverseSelf(int rank);

    int                               rows() const
    { return length_[0]; }
    
    void                              setStorage(GeneralArrayStorage<N_rank>);
    
    void                              slice(int rank, Range r);

    const TinyVector<int, N_rank>&    shape() const
    { return length_; }

    int                               size() const
    { return numElements(); }

    const TinyVector<int, N_rank>&    stride() const
    { return stride_; }

    int                               stride(int rank) const
    { return stride_[rank]; }

    int                               ubound(int rank) const
    { return base(rank) + length_(rank) - 1; }

    TinyVector<int, N_rank>           ubound() const
    { 
        TinyVector<int, N_rank> ub;
        for (int i=0; i < N_rank; ++i)
          ub(i) = base(i) + extent(i) - 1;
        // WAS: ub = base() + extent() - 1;
        return ub;
    }

    int                               zeroOffset() const
    { return zeroOffset_; }

    //////////////////////////////////////////////
    // Debugging routines
    //////////////////////////////////////////////

    bool isInRangeForDim(int i, int d) const {
        return i >= base(d) && (i - base(d)) < length_[d];
    }

    bool isInRange(int i0) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0];
    }

    bool isInRange(int i0, int i1) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1];
    }

    bool isInRange(int i0, int i1, int i2) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2];
    }

    bool isInRange(int i0, int i1, int i2, int i3) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4, int i5) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4, int i5, int i6) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5]
            && i6 >= base(6) && (i6 - base(6)) < length_[6];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5]
            && i6 >= base(6) && (i6 - base(6)) < length_[6]
            && i7 >= base(7) && (i7 - base(7)) < length_[7];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5]
            && i6 >= base(6) && (i6 - base(6)) < length_[6]
            && i7 >= base(7) && (i7 - base(7)) < length_[7]
            && i8 >= base(8) && (i8 - base(8)) < length_[8];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5]
            && i6 >= base(6) && (i6 - base(6)) < length_[6]
            && i7 >= base(7) && (i7 - base(7)) < length_[7]
            && i8 >= base(8) && (i8 - base(8)) < length_[8]
            && i9 >= base(9) && (i9 - base(9)) < length_[9];
    }

    bool isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9, int i10) const {
        return i0 >= base(0) && (i0 - base(0)) < length_[0]
            && i1 >= base(1) && (i1 - base(1)) < length_[1]
            && i2 >= base(2) && (i2 - base(2)) < length_[2]
            && i3 >= base(3) && (i3 - base(3)) < length_[3]
            && i4 >= base(4) && (i4 - base(4)) < length_[4]
            && i5 >= base(5) && (i5 - base(5)) < length_[5]
            && i6 >= base(6) && (i6 - base(6)) < length_[6]
            && i7 >= base(7) && (i7 - base(7)) < length_[7]
            && i8 >= base(8) && (i8 - base(8)) < length_[8]
            && i9 >= base(9) && (i9 - base(9)) < length_[9]
            && i10 >= base(10) && (i10 - base(10)) < length_[10];
    }

    bool isInRange(const T_index& index) const {
        for (int i=0; i < N_rank; ++i)
            if (index[i] < base(i) || (index[i] - base(i)) >= length_[i])
                return false;

        return true;
    }

    bool assertInRange(const T_index& BZ_DEBUG_PARAM(index)) const {
        BZPRECHECK(isInRange(index), "Array index out of range: " << index
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0)) const {
        BZPRECHECK(isInRange(i0), "Array index out of range: " << i0
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1)) const {
        BZPRECHECK(isInRange(i0,i1), "Array index out of range: (" 
            << i0 << ", " << i1 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2), "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3), "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3),
        int BZ_DEBUG_PARAM(i4)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4), "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3 
            << ", " << i4 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5), "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5), int BZ_DEBUG_PARAM(i6)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5,i6), 
            "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ", " << i6 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5), int BZ_DEBUG_PARAM(i6),
        int BZ_DEBUG_PARAM(i7)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5,i6,i7),
            "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ", " << i6 << ", " << i7 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5), int BZ_DEBUG_PARAM(i6), int BZ_DEBUG_PARAM(i7),
        int BZ_DEBUG_PARAM(i8)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5,i6,i7,i8),
            "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ", " << i6 << ", " << i7 
            << ", " << i8 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5), int BZ_DEBUG_PARAM(i6), int BZ_DEBUG_PARAM(i7),
        int BZ_DEBUG_PARAM(i8), int BZ_DEBUG_PARAM(i9)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5,i6,i7,i8,i9),
            "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ", " << i6 << ", " << i7
            << ", " << i8 << ", " << i9 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    bool assertInRange(int BZ_DEBUG_PARAM(i0), int BZ_DEBUG_PARAM(i1),
        int BZ_DEBUG_PARAM(i2), int BZ_DEBUG_PARAM(i3), int BZ_DEBUG_PARAM(i4),
        int BZ_DEBUG_PARAM(i5), int BZ_DEBUG_PARAM(i6), int BZ_DEBUG_PARAM(i7),
        int BZ_DEBUG_PARAM(i8), int BZ_DEBUG_PARAM(i9),
        int BZ_DEBUG_PARAM(i10)) const
    {
        BZPRECHECK(isInRange(i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10),
            "Array index out of range: ("
            << i0 << ", " << i1 << ", " << i2 << ", " << i3
            << ", " << i4 << ", " << i5 << ", " << i6 << ", " << i7
            << ", " << i8 << ", " << i9 << ", " << i10 << ")"
            << endl << "Lower bounds: " << storage_.base() << endl
            <<         "Length:       " << length_ << endl);
        return true;
    }

    //////////////////////////////////////////////
    // Subscripting operators
    //////////////////////////////////////////////

    template<int N_rank2>
    const T_numtype& restrict operator()(const TinyVector<int,N_rank2>& index) const
    {
        assertInRange(index);
        return data_[dot(index, stride_)];
    }

    template<int N_rank2>
    T_numtype& restrict operator()(const TinyVector<int,N_rank2>& index) 
    {
        assertInRange(index);
        return data_[dot(index, stride_)];
    }

    const T_numtype& restrict operator()(TinyVector<int,1> index) const
    {
        assertInRange(index[0]);
        return data_[index[0] * stride_[0]];
    }

    T_numtype& operator()(TinyVector<int,1> index)
    {
        assertInRange(index[0]);
        return data_[index[0] * stride_[0]];
    }

    const T_numtype& restrict operator()(TinyVector<int,2> index) const
    {
        assertInRange(index[0], index[1]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]];
    }

    T_numtype& operator()(TinyVector<int,2> index)
    {
        assertInRange(index[0], index[1]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]];
    }

    const T_numtype& restrict operator()(TinyVector<int,3> index) const
    {
        assertInRange(index[0], index[1], index[2]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2]];
    }

    T_numtype& operator()(TinyVector<int,3> index)
    {
        assertInRange(index[0], index[1], index[2]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,4>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]];
    }

    T_numtype& operator()(const TinyVector<int,4>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,5>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4]];
    }

    T_numtype& operator()(const TinyVector<int,5>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,6>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]];
    }

    T_numtype& operator()(const TinyVector<int,6>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,7>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6]];
    }

    T_numtype& operator()(const TinyVector<int,7>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,8>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]];
    }

    T_numtype& operator()(const TinyVector<int,8>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,9>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8]];
    }

    T_numtype& operator()(const TinyVector<int,9>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,10>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]];
    }

    T_numtype& operator()(const TinyVector<int,10>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]];
    }

    const T_numtype& restrict operator()(const TinyVector<int,11>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9],
            index[10]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]
            + index[10] * stride_[10]];
    }

    T_numtype& operator()(const TinyVector<int,11>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9],
            index[10]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]
            + index[10] * stride_[10]];
    }

    const T_numtype& restrict operator()(int i0) const
    { 
        assertInRange(i0);
        return data_[i0 * stride_[0]]; 
    }

    T_numtype& restrict operator()(int i0) 
    {
        assertInRange(i0);
        return data_[i0 * stride_[0]];
    }

    const T_numtype& restrict operator()(int i0, int i1) const
    { 
        assertInRange(i0, i1);
        return data_[i0 * stride_[0] + i1 * stride_[1]];
    }

    T_numtype& restrict operator()(int i0, int i1)
    {
        assertInRange(i0, i1);
        return data_[i0 * stride_[0] + i1 * stride_[1]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2) const
    {
        assertInRange(i0, i1, i2);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2) 
    {
        assertInRange(i0, i1, i2);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3) const
    {
        assertInRange(i0, i1, i2, i3);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3)
    {
        assertInRange(i0, i1, i2, i3);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4) const
    {
        assertInRange(i0, i1, i2, i3, i4);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4)
    {
        assertInRange(i0, i1, i2, i3, i4);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5)
    {
        assertInRange(i0, i1, i2, i3, i4, i5);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9]];
    }

    const T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9, int i10) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, 
            i9, i10);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9] + i10 * stride_[10]];
    }

    T_numtype& restrict operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9, int i10)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, 
            i9, i10);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9] + i10 * stride_[10]];
    }

    /*
     * Slicing to produce subarrays.  If the number of Range arguments is
     * fewer than N_rank, then missing arguments are treated like Range::all().
     */

    T_array& noConst() const
    { return const_cast<T_array&>(*this); }

    T_array operator()(const RectDomain<N_rank>& subdomain) const
    {
        return T_array(noConst(), subdomain);
    }

    /* Operator added by Julian Cummings */
    T_array operator()(const StridedDomain<N_rank>& subdomain) const
    {
        return T_array(noConst(), subdomain);
    }

    T_array operator()(Range r0) const
    {
        return T_array(noConst(), r0);
    }

    T_array operator()(Range r0, Range r1) const
    {
        return T_array(noConst(), r0, r1);
    }

    T_array operator()(Range r0, Range r1, Range r2) const
    {
        return T_array(noConst(), r0, r1, r2);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3) const
    {
        return T_array(noConst(), r0, r1, r2, r3);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8, Range r9) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8, Range r9, Range r10) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

    // Allow any mixture of Range, int and Vector<int> objects as
    // operands for operator():   A(Range(3,7), 5, Range(2,4))

    /*
     * These versions of operator() allow any combination of int
     * and Range operands to be used.  Each int operand reduces
     * the rank of the resulting array by one.  
     *
     * e.g.  Array<int,4> A(20,20,20,20);
     *       Array<int,2> B = A(Range(5,15), 3, 5, Range(8,9));
     *
     * SliceInfo is a helper class defined in <blitz/arrayslice.h>.
     * It counts the number of Range vs. int arguments and does some
     * other helpful things.
     *
     * Once partial specialization becomes widely implemented, these
     * operators may be expanded to accept Vector<int> arguments
     * and produce ArrayPick<T,N> objects.
     *
     * This operator() is not provided with a single argument because
     * the appropriate cases exist above.
     */

#ifdef BZ_HAVE_PARTIAL_ORDERING

    template<typename T1, typename T2>
    typename SliceInfo<T_numtype,T1,T2>::T_slice
    operator()(T1 r1, T2 r2) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2>::T_slice slice;
        return slice(noConst(), r1, r2, nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3>
    typename SliceInfo<T_numtype,T1,T2,T3>::T_slice 
    operator()(T1 r1, T2 r2, T3 r3) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3>::T_slice slice;
        return slice(noConst(), r1, r2, r3, nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4>
    typename SliceInfo<T_numtype,T1,T2,T3,T4>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
        typename T7>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, r7, nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
        typename T7, typename T8>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8,
            nilArraySection(), nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
        typename T7, typename T8, typename T9>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8, T9 r9) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8, r9, nilArraySection(), nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
        typename T7, typename T8, typename T9, typename T10>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8, T9 r9, T10 r10) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, nilArraySection());
    }

    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6,
        typename T7, typename T8, typename T9, typename T10, typename T11>
    typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8, T9 r9, T10 r10, T11 r11) const
    {
        typedef typename SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11>::T_slice slice;
        return slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11);
    }

#endif // BZ_HAVE_PARTIAL_ORDERING

    /*
     * These versions of operator() are provided to support tensor-style
     * array notation, e.g.
     *
     * Array<float, 2> A, B;
     * firstIndex i;
     * secondIndex j;
     * thirdIndex k;
     * Array<float, 3> C = A(i,j) * B(j,k);
     */

    template<int N0>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0> >
    operator()(IndexPlaceholder<N0>) const
    { 
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0> >
            (noConst());
    }

    template<int N0, int N1>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1> >(noConst());
    } 

    template<int N0, int N1, int N2>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2> >(noConst());
    }

    template<int N0, int N1, int N2, int N3>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3, N4> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, 
        IndexPlaceholder<N4>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3, 
        N4, N5> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, 
        IndexPlaceholder<N7>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8, int N9>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8, N9> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>, IndexPlaceholder<N9>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8, N9> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8, int N9, int N10>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8, N9, N10> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>, IndexPlaceholder<N9>, 
        IndexPlaceholder<N10>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8, N9, N10> >(noConst());
    }

    //////////////////////////////////////////////
    // Support for multicomponent arrays
    //////////////////////////////////////////////

    /*
     * See <blitz/array/multi.h> for an explanation of the traits class
     * multicomponent_traits.
     */

    Array<typename multicomponent_traits<T_numtype>::T_element,N_rank>
    operator[](const unsigned component) {
        typedef typename multicomponent_traits<T_numtype>::T_element T_compType;

        return extractComponent(T_compType(),component,
                                multicomponent_traits<T_numtype>::numComponents);
    }

    const Array<typename multicomponent_traits<T_numtype>::T_element,N_rank>
    operator[](const unsigned component) const {
        typedef typename multicomponent_traits<T_numtype>::T_element T_compType;

        return extractComponent(T_compType(),component,
                                multicomponent_traits<T_numtype>::numComponents);
    }

    Array<typename multicomponent_traits<T_numtype>::T_element,N_rank>
    operator[](const int component) {
        return operator[](static_cast<unsigned>(component));
    }

    const Array<typename multicomponent_traits<T_numtype>::T_element,N_rank>
    operator[](const int component) const {
        return operator[](static_cast<unsigned>(component));
    }

    //////////////////////////////////////////////
    // Indirection
    //////////////////////////////////////////////
 
    template<typename T_indexContainer>
    IndirectArray<T_array, T_indexContainer>
    operator[](const T_indexContainer& index)
    {
        return IndirectArray<T_array, T_indexContainer>(*this,
            const_cast<T_indexContainer&>(index));
    }
 
    //////////////////////////////////////////////
    // Assignment Operators
    //////////////////////////////////////////////

    // Scalar operand
    // NEEDS_WORK : need a precondition check on
    // isStorageContiguous when operator, is used.
    ListInitializationSwitch<T_array,T_numtype*> operator=(T_numtype x)
    {
        return ListInitializationSwitch<T_array,T_numtype*>(*this, x);
    }

    T_array& initialize(T_numtype);

    // Was:
    // T_array& operator=(T_numtype);

#ifdef BZ_NEW_EXPRESSION_TEMPLATES
    template<typename T_expr>
    T_array& operator=(const ETBase<T_expr>&);
    T_array& operator=(const Array<T_numtype,N_rank>&);

    template<typename T> T_array& operator+=(const T&);
    template<typename T> T_array& operator-=(const T&);
    template<typename T> T_array& operator*=(const T&);
    template<typename T> T_array& operator/=(const T&);
    template<typename T> T_array& operator%=(const T&);
    template<typename T> T_array& operator^=(const T&);
    template<typename T> T_array& operator&=(const T&);
    template<typename T> T_array& operator|=(const T&);
    template<typename T> T_array& operator>>=(const T&);
    template<typename T> T_array& operator<<=(const T&);

#else
    T_array& operator+=(T_numtype);
    T_array& operator-=(T_numtype);
    T_array& operator*=(T_numtype);
    T_array& operator/=(T_numtype);
    T_array& operator%=(T_numtype);
    T_array& operator^=(T_numtype);
    T_array& operator&=(T_numtype);
    T_array& operator|=(T_numtype);
    T_array& operator>>=(T_numtype);
    T_array& operator<<=(T_numtype);

    // Array operands
    T_array& operator=(const Array<T_numtype,N_rank>&);

    template<typename P_numtype2> 
    T_array& operator=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator+=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator-=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator*=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator/=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator%=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator^=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator&=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator|=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator>>=(const Array<P_numtype2,N_rank>&);
    template<typename P_numtype2>
    T_array& operator<<=(const Array<P_numtype2,N_rank>&);

    // Array expression operands
    template<typename T_expr>
    inline T_array& operator=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator+=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator-=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator*=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator/=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator%=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator^=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator&=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator|=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator>>=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);
    template<typename T_expr>
    inline T_array& operator<<=(BZ_ETPARM(_bz_ArrayExpr<T_expr>) expr);

    // NEEDS_WORK -- Index placeholder operand

    // NEEDS_WORK -- Random operand
#endif

public:
    // Undocumented implementation routines

    template<typename T_expr, typename T_update>
    inline T_array& evaluate(T_expr expr, T_update);

#ifdef BZ_HAVE_STD
#ifdef BZ_ARRAY_SPACE_FILLING_TRAVERSAL
    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithFastTraversal(
        const TraversalOrder<N_rank - 1>& order, 
        T_expr expr, T_update);
#endif // BZ_ARRAY_SPACE_FILLING_TRAVERSAL
#endif

#ifdef BZ_ARRAY_2D_STENCIL_TILING
    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithTiled2DTraversal(
        T_expr expr, T_update);
#endif

    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithIndexTraversal1(
        T_expr expr, T_update);

    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithIndexTraversalN(
        T_expr expr, T_update);

    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithStackTraversal1(
        T_expr expr, T_update);

    template<typename T_expr, typename T_update>
    inline T_array& evaluateWithStackTraversalN(
        T_expr expr, T_update);


    T_numtype* restrict getInitializationIterator() { return dataFirst(); }

    bool canCollapse(int outerRank, int innerRank) const { 
#ifdef BZ_DEBUG_TRAVERSE
        BZ_DEBUG_MESSAGE("stride(" << innerRank << ")=" << stride(innerRank)
          << ", extent()=" << extent(innerRank) << ", stride(outerRank)="
          << stride(outerRank));
#endif
        return (stride(innerRank) * extent(innerRank) == stride(outerRank)); 
    }

protected:
    //////////////////////////////////////////////
    // Implementation routines
    //////////////////////////////////////////////

    _bz_inline2 void computeStrides();
    _bz_inline2 void setupStorage(int rank);
    void constructSubarray(Array<T_numtype, N_rank>& array, 
        const RectDomain<N_rank>&);
    void constructSubarray(Array<T_numtype, N_rank>& array,
        const StridedDomain<N_rank>&);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0, Range r1);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8, Range r9);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8, Range r9, Range r10);

    void calculateZeroOffset();

    template<int N_rank2, typename R0, typename R1, typename R2, typename R3, typename R4, 
        typename R5, typename R6, typename R7, typename R8, typename R9, typename R10>
    void constructSlice(Array<T_numtype, N_rank2>& array, R0 r0, R1 r1, R2 r2, 
        R3 r3, R4 r4, R5 r5, R6 r6, R7 r7, R8 r8, R9 r9, R10 r10);

    template<int N_rank2>
    void slice(int& setRank, Range r, Array<T_numtype,N_rank2>& array,
        TinyVector<int,N_rank2>& rankMap, int sourceRank);

    template<int N_rank2>
    void slice(int& setRank, int i, Array<T_numtype,N_rank2>& array,
        TinyVector<int,N_rank2>& rankMap, int sourceRank);

    template<int N_rank2>
    void slice(int&, nilArraySection, Array<T_numtype,N_rank2>&,
        TinyVector<int,N_rank2>&, int)
    { }

    void doTranspose(int destRank, int sourceRank, T_array& array);

protected:
    //////////////////////////////////////////////
    // Data members
    //////////////////////////////////////////////

    // NB: adding new data members may require changes to ctors, reference()

    /*
     * For a description of the storage_ members, see the comments for class 
     * GeneralArrayStorage<N_rank> above.
     *
     * length_[] contains the extent of each rank.  E.g. a 10x20x30 array
     *           would have length_ = { 10, 20, 30}.
     * stride_[] contains the stride to move to the next element along each
     *           rank.
     * zeroOffset_ is the distance from the first element in the array 
     *           to the point (0,0,...,0).  If base_ is zero and all ranks are 
     *           stored ascending, then zeroOffset_ is zero.  This value
     *           is needed because to speed up indexing, the data_ member
     *           (inherited from MemoryBlockReference) always refers to
     *           (0,0,...,0).
     */
    GeneralArrayStorage<N_rank> storage_;
    TinyVector<int, N_rank> length_;
    TinyVector<int, N_rank> stride_;
    int zeroOffset_;
};

/*
 * Rank numbers start with zero, which may be confusing to users coming
 * from Fortran.  To make code more readable, the following constants
 * may help.  Example: instead of
 * 
 * int firstRankExtent = A.extent(0);
 *
 * One can write:
 *
 * int firstRankExtent = A.extent(firstRank);
 */

const int firstRank    = 0;
const int secondRank   = 1;
const int thirdRank    = 2;
const int fourthRank   = 3;
const int fifthRank    = 4;
const int sixthRank    = 5;
const int seventhRank  = 6;
const int eighthRank   = 7;
const int ninthRank    = 8;
const int tenthRank    = 9;
const int eleventhRank = 10;

const int firstDim    = 0;
const int secondDim   = 1;
const int thirdDim    = 2;
const int fourthDim   = 3;
const int fifthDim    = 4;
const int sixthDim    = 5;
const int seventhDim  = 6;
const int eighthDim   = 7;
const int ninthDim    = 8;
const int tenthDim    = 9;
const int eleventhDim = 10;

/*
 * Global Functions
 */

template<typename T_numtype>
ostream& operator<<(ostream&, const Array<T_numtype,1>&);

template<typename T_numtype>
ostream& operator<<(ostream&, const Array<T_numtype,2>&);

template<typename T_numtype, int N_rank>
ostream& operator<<(ostream&, const Array<T_numtype,N_rank>&);

template<typename T_numtype, int N_rank>
istream& operator>>(istream& is, Array<T_numtype,N_rank>& x);

template <typename P_numtype,int N_rank>
void swap(Array<P_numtype,N_rank>& a,Array<P_numtype,N_rank>& b) {
    Array<P_numtype,N_rank> c(a);
    a.reference(b);
    b.reference(c);
}

template <typename P_expr>
void find(Array<TinyVector<int,P_expr::rank>,1>& indices,
          const _bz_ArrayExpr<P_expr>& expr) {
    find(indices,
         static_cast< Array<typename P_expr::T_numtype,P_expr::rank> >(expr));
}

template <typename P_numtype, int N_rank>
void find(Array<TinyVector<int,N_rank>,1>& indices,
          const Array<P_numtype,N_rank>& exprVals) {
    indices.resize(exprVals.size());
    typename Array<P_numtype,N_rank>::const_iterator it, end = exprVals.end();
    int j=0; 
    for (it = exprVals.begin(); it != end; ++it)
        if (*it) 
            indices(j++) = it.position();
    if (j) 
        indices.resizeAndPreserve(j);
    else 
        indices.free();
    return;
}


BZ_NAMESPACE_END

/*
 * Include implementations of the member functions and some additional
 * global functions.
 */

#include <blitz/array/iter.h>       // Array iterators
#include <blitz/array/fastiter.h>   // Fast Array iterators (for et)
#include <blitz/array/expr.h>       // Array expression objects
#include <blitz/array/methods.cc>   // Member functions
#include <blitz/array/eval.cc>      // Array expression evaluation
#include <blitz/array/ops.cc>       // Assignment operators
#include <blitz/array/io.cc>        // Output formatting
#include <blitz/array/et.h>         // Expression templates
#include <blitz/array/reduce.h>     // Array reduction expression templates
#include <blitz/array/interlace.cc> // Allocation of interlaced arrays
#include <blitz/array/resize.cc>    // Array resize, resizeAndPreserve
#include <blitz/array/slicing.cc>   // Slicing and subarrays
#include <blitz/array/cycle.cc>     // Cycling arrays
#include <blitz/array/complex.cc>   // Special support for complex arrays
#include <blitz/array/zip.h>        // Zipping multicomponent types
#include <blitz/array/where.h>      // where(X,Y,Z)
#include <blitz/array/indirect.h>   // Indirection
#include <blitz/array/stencils.h>   // Stencil objects

#endif // BZ_ARRAY_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                        array-old.h                                                                                         0100644 0001750 0001750 00000003626 12160377112 041765  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/array-old.h  Maximal include version of Array<P_numtype, N_rank>
 *                    Note: see <blitz/array-impl.h> for the class def.
 *
 * $Id: array-old.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_ARRAY_OLD_H
#define BZ_ARRAY_OLD_H

/*
 * <blitz/array.h> used to include most of the Blitz++ library
 * functionality, totally ~ 120000 lines of source code.  This
 * made for extremely slow compile times; processing #include <blitz/array.h>
 * took gcc about 25 seconds on a 500 MHz pentium box.
 *
 * Much of this compile time was due to the old vector expression templates
 * implementation.  Since this is not really needed for the Array<T,N>
 * class, the headers were redesigned so that:
 *
 * #include <blitz/array-old.h>   is the old-style include, pulls in most
 *                                of Blitz++ including vector e.t. 
 * #include <blitz/array.h>       pulls in much less of the library, and
 *                                in particular excludes the vector e.t. code
 *
 * With <blitz/array-old.h>, one gets TinyVector expressions automatically.
 * With <blitz/array.h>, one must now also include <blitz/tinyvec-et.h> 
 * to get TinyVector expressions.
 *
 * The implementation of Array<T,N> has been moved to <blitz/array-impl.h>.
 */

#include <blitz/tinyvec-et.h>
#include <blitz/array-impl.h>

#endif // BZ_ARRAY_OLD_H

                                                                                                          array.h                                                                                             0100644 0001750 0001750 00000001575 12160377112 041212  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/array.h    Minimal include version of Array<T,N>
 *
 * $Id: array.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2000 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_ARRAY_ONLY_H
#define BZ_ARRAY_ONLY_H

// See comments in <blitz/array-old.h> for an explanation of the new
// headers arrangement.

#include <blitz/array-impl.h>

#endif  // BZ_ARRAY_ONLY_H

                                                                                                                                   bench.h                                                                                             0100644 0001750 0001750 00000006055 12160377112 041151  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/bench.h      Benchmark classes
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_BENCH_H
#define BZ_BENCH_H

#ifndef BZ_MATRIX_H
 #include <blitz/matrix.h>
#endif

#ifndef BZ_TIMER_H
 #include <blitz/timer.h>
#endif

#include <math.h>

BZ_NAMESPACE(blitz)

// Forward declaration
template<typename P_parameter = unsigned>
class BenchmarkImplementation;


// Declaration of class Benchmark<T>
// The template parameter T is the parameter type which is varied in
// the benchmark.  Typically T will be an unsigned, and will represent
// the length of a vector, size of an array, etc.

template<typename P_parameter = unsigned>
class Benchmark {

public:
    typedef P_parameter T_parameter;

    Benchmark(unsigned numImplementations);

    ~Benchmark();

    void addImplementation(BenchmarkImplementation<T_parameter>* 
        implementation);

    void run(ostream& log = cout);

    double getMflops(unsigned implementation, unsigned setting) const;

    double getRate(unsigned implementation, unsigned setting) const;

    void saveMatlabGraph(const char* filename) const;

public:
    // Virtual functions

    virtual const char* description() const
    { return ""; }

    virtual const char* parameterDescription() const
    { return "Vector length"; }

    virtual unsigned numParameterSettings() const
    { return 19; }

    virtual T_parameter getParameterSetting(unsigned i) const
    { return ::pow(10.0, (i+1)/4.0); }

    virtual long getIterationSetting(unsigned i) const
    { return 1000000L / getParameterSetting(i); }

private:
    Benchmark(const Benchmark<P_parameter>&) { }
    void operator=(const Benchmark<P_parameter>&) { }

    enum { uninitialized, initialized, running, done } state_;

    unsigned numImplementations_;
    unsigned numStoredImplementations_;

    BenchmarkImplementation<T_parameter>** implementations_;

    Matrix<double,RowMajor> rates_;       // Iterations per second array
    Matrix<double,RowMajor> Mflops_;
};

template<typename P_parameter>
class BenchmarkImplementation {

public:
    typedef P_parameter T_parameter;

    virtual void initialize(P_parameter parameter) { }

    virtual void done() { }

    virtual const char* implementationName() const
    { return ""; }

    virtual void run(long iterations) = 0;

    virtual void runOverhead(long iterations) 
    { 
        for (long i=0; i < iterations; ++i)
        {
        }
    };

    virtual void tickle() { }

    virtual long flopsPerIteration() const
    { return 0; }
};

BZ_NAMESPACE_END

#include <blitz/bench.cc>  

#endif // BZ_BENCH_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   benchext.h                                                                                          0100644 0001750 0001750 00000006017 12160377112 041670  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/benchext.h      BenchmarkExt classes (Benchmarks with external
 *                       control)
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_BENCHEXT_H
#define BZ_BENCHEXT_H

#ifndef BZ_MATRIX_H
 #include <blitz/matrix.h>
#endif

#ifndef BZ_TIMER_H
 #include <blitz/timer.h>
#endif

#include <math.h>

// NEEDS_WORK: replace use of const char* with <string>, once standard
// library is widely supported.

BZ_NAMESPACE(blitz)

// Declaration of class BenchmarkExt<T>
// The template parameter T is the parameter type which is varied in
// the benchmark.  Typically T will be an unsigned, and will represent
// the length of a vector, size of an array, etc.

template<typename P_parameter = unsigned>
class BenchmarkExt {

public:
    typedef P_parameter T_parameter;

    BenchmarkExt(const char* description, int numImplementations);

    ~BenchmarkExt();

    void setNumParameters(int numParameters);
    void setParameterVector(Vector<T_parameter> parms);
    void setParameterDescription(const char* string);
    void setIterations(Vector<long> iters);
    void setFlopsPerIteration(Vector<double> flopsPerIteration);
    void setRateDescription(const char* string);

    void beginBenchmarking();

    void beginImplementation(const char* description);

    bool doneImplementationBenchmark() const;

    T_parameter getParameter() const;
    long        getIterations() const;

    inline void start();
    inline void stop();

    void startOverhead();
    void stopOverhead();

    void endImplementation();

    void endBenchmarking();
 
    double getMflops(unsigned implementation, unsigned parameterNum) const;

    void saveMatlabGraph(const char* filename, const char* graphType="semilogx") const;

protected:
    BenchmarkExt(const BenchmarkExt<P_parameter>&) { }
    void operator=(const BenchmarkExt<P_parameter>&) { }

    enum { initializing, benchmarking, benchmarkingImplementation, 
       running, runningOverhead, done } state_;

    unsigned numImplementations_;
    unsigned implementationNumber_;

    const char* description_;
    Vector<const char*> implementationDescriptions_;

    Matrix<double,RowMajor> times_;       // Elapsed time

    Vector<T_parameter> parameters_;
    Vector<long> iterations_;
    Vector<double> flopsPerIteration_;

    Timer timer_;
    Timer overheadTimer_;

    const char* parameterDescription_;
    const char* rateDescription_;

    unsigned numParameters_;
    unsigned parameterNumber_;
};

BZ_NAMESPACE_END

#include <blitz/benchext.cc>  

#endif // BZ_BENCHEXT_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 blitz.h                                                                                             0100644 0001750 0001750 00000005626 12160377112 041221  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/blitz.h      Includes all the important header files
 *
 * $Id: blitz.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 * 
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org    
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_BLITZ_H
#define BZ_BLITZ_H

/*
 * These symbols allow use of the IEEE and System V math libraries
 * (libm.a and libmsaa.a) on some platforms.
 */

#ifdef BZ_ENABLE_XOPEN_SOURCE
 #ifndef _ALL_SOURCE
  #define _ALL_SOURCE
 #endif
 #ifndef _XOPEN_SOURCE
  #define _XOPEN_SOURCE
 #endif
 #ifndef _XOPEN_SOURCE_EXTENDED
  #define _XOPEN_SOURCE_EXTENDED 1
 #endif
#endif

#include <blitz/compiler.h>          // Compiler-specific directives
#include <blitz/tuning.h>            // Performance tuning
#include <blitz/tau.h>               // Profiling

#include <string>
#include <stdio.h>                   // sprintf, etc.

#ifdef BZ_HAVE_STD
  #include <iostream>
  #include <iomanip>
#else
  #include <iostream.h>
  #include <iomanip.h>
#endif

#ifdef BZ_MATH_FN_IN_NAMESPACE_STD 
  #include <cmath>
#else
  #include <math.h>
#endif

#ifdef BZ_HAVE_COMPLEX
  #include <complex>
#endif

#define BZ_THROW                     // Needed in <blitz/numinquire.h>

BZ_NAMESPACE(blitz)

#ifdef BZ_HAVE_STD
 BZ_USING_NAMESPACE(std)
#endif

#ifdef BZ_GENERATE_GLOBAL_INSTANCES
 #define _bz_global
 #define BZ_GLOBAL_INIT(X)   =X
#else
 #define _bz_global extern
 #define BZ_GLOBAL_INIT(X) 
#endif

BZ_NAMESPACE_END

/*
 * Thread safety issues.
 * Compiling with -pthread under gcc, or -mt under solaris,
 * should automatically turn on BZ_THREADSAFE.
 */
#ifdef _REENTRANT
 #ifndef BZ_THREADSAFE
  #define BZ_THREADSAFE
 #endif
#endif

/*
 * Which mutex implementation should be used for synchronizing
 * reference counts.   Currently only one option -- pthreads.
 */
#ifdef BZ_THREADSAFE
#define BZ_THREADSAFE_USE_PTHREADS
#endif

#ifdef BZ_THREADSAFE_USE_PTHREADS
 #include <pthread.h>

 #define BZ_MUTEX_DECLARE(name)   mutable pthread_mutex_t name;
 #define BZ_MUTEX_INIT(name)      pthread_mutex_init(&name,NULL);
 #define BZ_MUTEX_LOCK(name)      pthread_mutex_lock(&name);
 #define BZ_MUTEX_UNLOCK(name)    pthread_mutex_unlock(&name);
 #define BZ_MUTEX_DESTROY(name)   pthread_mutex_destroy(&name);
#else
 #define BZ_MUTEX_DECLARE(name)
 #define BZ_MUTEX_INIT(name)
 #define BZ_MUTEX_LOCK(name)
 #define BZ_MUTEX_UNLOCK(name)
 #define BZ_MUTEX_DESTROY(name)
#endif

#include <blitz/bzdebug.h>           // Debugging macros

#endif // BZ_BLITZ_H
                                                                                                          bzconfig.h                                                                                          0100644 0001750 0001750 00000002410 12160377112 041662  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /* Select the compiler-specific config.h header file */
#ifndef BZCONFIG_H
#define BZCONFIG_H

#if defined(__APPLE)
/* IBM xlc compiler for Darwin */
#include <blitz/apple/bzconfig.h>

#elif defined(__ICC)
/* Intel icc compiler */
#include <blitz/intel/bzconfig.h>

#elif defined(_MSC_VER)
/* Microsoft VS.NET compiler */
#include <blitz/ms/bzconfig.h>

#elif defined(__IBM)
/* IBM xlC compiler */
#include <blitz/ibm/bzconfig.h>

#elif defined(__DECCXX)
/* Compaq cxx compiler */
#include <blitz/compaq/bzconfig.h>

#elif defined(__HP_aCC)
/* HP aCC compiler */
#include <blitz/hp/bzconfig.h>

#elif defined(_SGI_COMPILER_VERSION)
/* SGI CC compiler */
#include <blitz/sgi/bzconfig.h>

#elif defined(__SUNPRO_CC)
/* SunPRO CC compiler */
#include <blitz/sun/bzconfig.h>

#elif defined(__GNUC__)
/* GNU gcc compiler */
#include <blitz/gnu/bzconfig.h>

#elif defined(__PGI)
/* PGI pgCC compiler */
#include <blitz/pgi/bzconfig.h>

#elif defined(__KCC)
/* KAI KCC compiler */
#include <blitz/kai/bzconfig.h>

#elif defined(__FUJITSU)
/* Fujitsu FCC compiler */
#include <blitz/fujitsu/bzconfig.h>

#elif defined(__PATHSCALE)
/* Pathscale pathCC compiler */
#include <blitz/pathscale/bzconfig.h>

/* Add other compilers here */

#else
#error Unknown compiler
#endif

#endif /* BZCONFIG_H */
                                                                                                                                                                                                                                                        bzdebug.h                                                                                           0100644 0001750 0001750 00000015361 12160377112 041514  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/bzdebug.h      Debugging macros
 *
 * $Id: bzdebug.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_DEBUG_H
#define BZ_DEBUG_H

#ifdef BZ_HAVE_STDLIB_H
 #include <stdlib.h>
#endif
#include <assert.h>

#ifdef BZ_HAVE_RTTI
 #include <typeinfo>
#endif

BZ_NAMESPACE(blitz)

/*
 * These globals are used by the Blitz++ testsuite.  The _bz_global 
 * modifier ensures that they will reside in libblitz.a, but appear
 * "extern" elsewhere.
 */

_bz_global bool assertFailMode     BZ_GLOBAL_INIT(false);
_bz_global int  assertFailCount    BZ_GLOBAL_INIT(0);
_bz_global int  assertSuccessCount BZ_GLOBAL_INIT(0);


#if defined(BZ_TESTSUITE)
  /*
   * In testsuite mode, these routines allow a test suite to check
   * that precondition checking is being done properly.  A typical
   * use looks like this:
   *
   * beginCheckAssert();
   *   // Some operation which should cause an assert to fail
   * endCheckAssert();
   *
   * The routine beginCheckAssert() sets a flag which results in
   * failed asserts being silently tallied.  If no asserts have
   * failed by the time endCheckAssert() is invoked, the program
   * halts and issues an error code.
   *
   * In normal operation (i.e. when beginCheckAssert() has not
   * been called), failed preconditions will cause the program
   * to halt and issue an error code.   -- TV 980226
   */

  inline void checkAssert(bool condition, const char* where=0, 
    int line=0)
  {
    if (assertFailMode == true)
    {
      if (condition == true)
        ++assertSuccessCount;
      else
        ++assertFailCount;
    }
    else {
      if (!condition)
      {
        cerr << "Unexpected assert failure!" << endl;
        if (where)
            cerr << where << ":" << line << endl;
        cerr.flush();
        assert(0);
      }
    }
  }

  inline void beginCheckAssert()
  {
    assertFailMode = true;
    assertSuccessCount = 0;
    assertFailCount = 0;
  }

  inline void endCheckAssert()
  {
    assert(assertFailMode == true);
    assertFailMode = false;
    if (assertFailCount == 0)
    {
      cerr << "Assert check failed!" << endl;
      assert(0);
    }
  }

    #define BZASSERT(X)        checkAssert(X, __FILE__, __LINE__)
    #define BZPRECONDITION(X)  checkAssert(X, __FILE__, __LINE__)
    #define BZPOSTCONDITION(X) checkAssert(X, __FILE__, __LINE__)
    #define BZSTATECHECK(X,Y)  checkAssert(X == Y, __FILE__, __LINE__)
    #define BZPRECHECK(X,Y)                                    \
        {                                                      \
            if ((assertFailMode == false) && (!(X)))       \
                cerr << Y << endl;                             \
            checkAssert(X, __FILE__, __LINE__);                \
        }

    #define BZ_DEBUG_MESSAGE(X)                                          \
        {                                                                \
            if (assertFailMode == false)                             \
            {                                                            \
                cout << __FILE__ << ":" << __LINE__ << " " << X << endl; \
            }                                                            \
        }

    #define BZ_DEBUG_PARAM(X) X
    #define BZ_PRE_FAIL        checkAssert(0)
    #define BZ_ASM_DEBUG_MARKER

#elif defined(BZ_DEBUG)

    #define BZASSERT(X)        assert(X)
    #define BZPRECONDITION(X)  assert(X)
    #define BZPOSTCONDITION(X) assert(X)
    #define BZSTATECHECK(X,Y)  assert(X == Y)
    #define BZPRECHECK(X,Y)                                                 \
        { if (!(X))                                                         \
          { cerr << "[Blitz++] Precondition failure: Module " << __FILE__   \
               << " line " << __LINE__ << endl                              \
               << Y << endl;                                                \
            cerr.flush();                                                   \
            assert(0);                                                      \
          }                                                                 \
        }

    #define BZ_DEBUG_MESSAGE(X) \
        { cout << __FILE__ << ":" << __LINE__ << " " << X << endl; }

    #define BZ_DEBUG_PARAM(X) X
    #define BZ_PRE_FAIL      assert(0)

// This routine doesn't exist anywhere; it's used to mark a
// position of interest in assembler (.s) files
    void _bz_debug_marker();
    #define BZ_ASM_DEBUG_MARKER   _bz_debug_marker();

#else   // !BZ_TESTSUITE && !BZ_DEBUG

    #define BZASSERT(X)
    #define BZPRECONDITION(X)
    #define BZPOSTCONDITION(X)
    #define BZSTATECHECK(X,Y)
    #define BZPRECHECK(X,Y)
    #define BZ_DEBUG_MESSAGE(X)
    #define BZ_DEBUG_PARAM(X)
    #define BZ_PRE_FAIL
    #define BZ_ASM_DEBUG_MARKER

#endif  // !BZ_TESTSUITE && !BZ_DEBUG

#define BZ_NOT_IMPLEMENTED()   { cerr << "[Blitz++] Not implemented: module " \
    << __FILE__ << " line " << __LINE__ << endl;                \
    exit(1); }

#ifdef BZ_HAVE_RTTI
#define BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(X)  typeid(X).name()
#else

template<typename T>
class _bz_stringLiteralForNumericType {
public:
    static const char* string()
    { return "unknown"; }
};

#define BZ_DECL_SLFNT(X,Y) \
 template<>                 \
 class _bz_stringLiteralForNumericType< X > {  \
 public:                                       \
     static const char* string()               \
     { return Y; }                             \
 }

#ifdef BZ_HAVE_BOOL
BZ_DECL_SLFNT(bool, "bool");
#endif

BZ_DECL_SLFNT(char, "char");
BZ_DECL_SLFNT(unsigned char, "unsigned char");
BZ_DECL_SLFNT(short int, "short int");
BZ_DECL_SLFNT(short unsigned int, "short unsigned int");
BZ_DECL_SLFNT(int, "int");
BZ_DECL_SLFNT(unsigned int, "unsigned int");
BZ_DECL_SLFNT(long, "long");
BZ_DECL_SLFNT(unsigned long, "unsigned long");
BZ_DECL_SLFNT(float, "float");
BZ_DECL_SLFNT(double, "double");
BZ_DECL_SLFNT(long double, "long double");

#ifdef BZ_HAVE_COMPLEX
BZ_DECL_SLFNT(complex<float>, "complex<float>");
BZ_DECL_SLFNT(complex<double>, "complex<double>");
BZ_DECL_SLFNT(complex<long double>, "complex<long double>");
#endif

#define BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(X) \
    _bz_stringLiteralForNumericType<X>::string()

#endif // !BZ_HAVE_RTTI

BZ_NAMESPACE_END

#endif // BZ_DEBUG_H
                                                                                                                                                                                                                                                                               compiler.h                                                                                          0100644 0001750 0001750 00000007531 12160377112 041704  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/compiler.h      Compiler specific directives and kludges
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/


#ifndef BZ_COMPILER_H
#define BZ_COMPILER_H

// The file <blitz/bzconfig.h> is used to select a compiler-specific
// config.h file that is generated automatically by configure.

#include <blitz/bzconfig.h>

/*
 * Define some kludges.
 */

#ifndef BZ_HAVE_TEMPLATES
    #error  In <blitz/config.h>: A working template implementation is required by Blitz++ (you may need to rerun the compiler/bzconfig script)
#endif

#ifndef BZ_HAVE_MEMBER_TEMPLATES
  #error  In <blitz/config.h>: Your compiler does not support member templates.  (you may need to rerun the compiler/bzconfig script)
#endif

#ifndef BZ_HAVE_FULL_SPECIALIZATION_SYNTAX
  #error In <blitz/config.h>: Your compiler does not support template<> full specialization syntax.  You may need to rerun the compiler/bzconfig script.
#endif

#ifndef BZ_HAVE_PARTIAL_ORDERING
  #error In <blitz/config.h>: Your compiler does not support partial ordering (you may need to rerun the compiler/bzconfig script)
#endif

#ifndef BZ_HAVE_PARTIAL_SPECIALIZATION
  #error In <blitz/config.h>: Your compiler does not support partial specialization (you may need to rerun the compiler/bzconfig script)
#endif

#ifdef BZ_HAVE_NAMESPACES
    #define BZ_NAMESPACE(X)        namespace X {
    #define BZ_NAMESPACE_END       }
    #define BZ_USING_NAMESPACE(X)  using namespace X;
#else
    #define BZ_NAMESPACE(X)
    #define BZ_NAMESPACE_END
    #define BZ_USING_NAMESPACE(X)
#endif

#ifdef BZ_HAVE_TEMPLATE_QUALIFIED_RETURN_TYPE
  #define BZ_USE_NUMTRAIT
#endif

#ifdef BZ_HAVE_DEFAULT_TEMPLATE_PARAMETERS
    #define BZ_TEMPLATE_DEFAULT(X)   = X
#else
    #define BZ_TEMPLATE_DEFAULT
#endif

#ifndef BZ_HAVE_EXPLICIT
    #define explicit   
#endif

#ifdef BZ_HAVE_TYPENAME
    #define _bz_typename     typename
#else
    #define _bz_typename
#endif

#ifndef BZ_HAVE_MUTABLE
    #define mutable
#endif

#ifdef BZ_DISABLE_RESTRICT
 #undef BZ_HAVE_NCEG_RESTRICT
#endif

#ifndef BZ_HAVE_NCEG_RESTRICT
    #if defined(BZ_HAVE_NCEG_RESTRICT_EGCS)
        #define restrict     __restrict__
    #else
        #define restrict
    #endif
#endif

#if !defined(BZ_HAVE_BOOL) && !defined(BZ_NO_BOOL_KLUDGE)
    #define bool    int
    #define true    1
    #define false   0
#endif

#ifdef BZ_HAVE_ENUM_COMPUTATIONS_WITH_CAST
    #define BZ_ENUM_CAST(X)   (int)X
#elif defined(BZ_HAVE_ENUM_COMPUTATIONS)
    #define BZ_ENUM_CAST(X)   X
#else
    #error In <blitz/config.h>: Your compiler does not support enum computations.  You may have to rerun compiler/bzconfig.
#endif

#if defined(BZ_MATH_FN_IN_NAMESPACE_STD)
  #define BZ_MATHFN_SCOPE(x) std::x
#elif defined(BZ_HAVE_NAMESPACES)
  #define BZ_MATHFN_SCOPE(x) ::x
#else
  #define BZ_MATHFN_SCOPE(x) x
#endif

#if defined(BZ_HAVE_COMPLEX_MATH_IN_NAMESPACE_STD)
  #define BZ_CMATHFN_SCOPE(x) std::x
#elif defined(BZ_HAVE_NAMESPACES)
  #define BZ_CMATHFN_SCOPE(x) ::x
#else
  #define BZ_CMATHFN_SCOPE(x) x
#endif

#if defined(BZ_HAVE_NAMESPACES)
  #define BZ_IEEEMATHFN_SCOPE(x) ::x
#else
  #define BZ_IEEEMATHFN_SCOPE(x) x
#endif

#if defined(BZ_HAVE_NAMESPACES)
  #define BZ_BLITZ_SCOPE(x) blitz::x
#else
  #define BZ_BLITZ_SCOPE(x) ::x
#endif

#if defined(BZ_HAVE_NAMESPACES) && defined(BZ_HAVE_STD)
  #define BZ_STD_SCOPE(x) std::x
#else
  #define BZ_STD_SCOPE(x) ::x
#endif

#endif // BZ_COMPILER_H

                                                                                                                                                                       etbase.h                                                                                            0100644 0001750 0001750 00000002027 12160377112 041330  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/etbase.h    Declaration of the ETBase<T> class
 *
 * $Id: etbase.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_ETBASE_H
#define BZ_ETBASE_H

BZ_NAMESPACE(blitz)

template<typename T>
class ETBase { 
public:
    ETBase() 
    { }

    ETBase(const ETBase<T>&)
    { }
    
    T& unwrap() { return static_cast<T&>(*this); }
    
    const T& unwrap() const { return static_cast<const T&>(*this); }
};

BZ_NAMESPACE_END

#endif // BZ_ETBASE_H

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         extremum.h                                                                                          0100644 0001750 0001750 00000003335 12160377112 041736  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/extremum.h      Declaration of the Extremum<T_numtype, T_index> class
 *
 * $Id: extremum.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_EXTREMUM_H
#define BZ_EXTREMUM_H

#ifndef BZ_BLITZ_H
 #include <blitz/blitz.h>
#endif

BZ_NAMESPACE(blitz)

// The Extremum class is used for returning extreme values and their
// locations in a numeric container.  It's a simple 2-tuple, with the
// first element being the extreme value, and the send its location.
// An object of type Extremum can be automatically converted to
// the numeric type via operator T_numtype().
template<typename P_numtype, typename P_index>
class Extremum {
public:
    typedef P_numtype T_numtype;
    typedef P_index   T_index;

    Extremum(T_numtype value, T_index index)
        : value_(value), index_(index)
    { }

    T_numtype value() const
    { return value_; }

    T_index index() const
    { return index_; }

    void setValue(T_numtype value)
    { value_ = value; }

    void setIndex(T_index index)
    { index_ = index; }

    operator T_numtype() const
    { return value_; }

protected:
    T_numtype value_;
    T_index index_;
};

BZ_NAMESPACE_END

#endif // BZ_EXTREMUM_H

                                                                                                                                                                                                                                                                                                   funcs.h                                                                                             0100644 0001750 0001750 00000067753 12160377112 041224  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/funcs.h            Function objects for math functions
 *
 * $Id: funcs.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 *************************************************************************/

#ifndef BZ_FUNCS_H
#define BZ_FUNCS_H

#include <blitz/blitz.h>
#include <blitz/promote.h>
#include <blitz/prettyprint.h>

#include <cstdlib>

BZ_NAMESPACE(blitz)

/* Helper functions */

template <typename T>
inline T blitz_sqr(T x)
{ return x*x; }

template <typename T>
inline T blitz_cube(T x)
{ return x*x*x; }

template <typename T>
inline T blitz_pow4(T x)
{ return x*x*x*x; }

template <typename T>
inline T blitz_pow5(T x)
{ return x*x*x*x*x; }

template <typename T>
inline T blitz_pow6(T x)
{ return x*x*x*x*x*x; }

template <typename T>
inline T blitz_pow7(T x)
{ return x*x*x*x*x*x*x; }

template <typename T>
inline T blitz_pow8(T x)
{ return x*x*x*x*x*x*x*x; }


/* Unary functions that return same type as argument */

#define BZ_DEFINE_UNARY_FUNC(name,fun)                         \
template<typename T_numtype1>                                  \
struct name {                                                  \
    typedef T_numtype1 T_numtype;                              \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a)                                        \
    { return fun(a); }                                         \
                                                               \
    template<typename T1>                                      \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1)               \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};

BZ_DEFINE_UNARY_FUNC(Fn_acos,BZ_MATHFN_SCOPE(acos))
BZ_DEFINE_UNARY_FUNC(Fn_asin,BZ_MATHFN_SCOPE(asin))
BZ_DEFINE_UNARY_FUNC(Fn_atan,BZ_MATHFN_SCOPE(atan))
BZ_DEFINE_UNARY_FUNC(Fn_ceil,BZ_MATHFN_SCOPE(ceil))
BZ_DEFINE_UNARY_FUNC(Fn_cos,BZ_MATHFN_SCOPE(cos))
BZ_DEFINE_UNARY_FUNC(Fn_cosh,BZ_MATHFN_SCOPE(cosh))
BZ_DEFINE_UNARY_FUNC(Fn_exp,BZ_MATHFN_SCOPE(exp))
BZ_DEFINE_UNARY_FUNC(Fn_fabs,BZ_MATHFN_SCOPE(fabs))
BZ_DEFINE_UNARY_FUNC(Fn_floor,BZ_MATHFN_SCOPE(floor))
BZ_DEFINE_UNARY_FUNC(Fn_log,BZ_MATHFN_SCOPE(log))
BZ_DEFINE_UNARY_FUNC(Fn_log10,BZ_MATHFN_SCOPE(log10))
BZ_DEFINE_UNARY_FUNC(Fn_sin,BZ_MATHFN_SCOPE(sin))
BZ_DEFINE_UNARY_FUNC(Fn_sinh,BZ_MATHFN_SCOPE(sinh))
BZ_DEFINE_UNARY_FUNC(Fn_sqrt,BZ_MATHFN_SCOPE(sqrt))
BZ_DEFINE_UNARY_FUNC(Fn_tan,BZ_MATHFN_SCOPE(tan))
BZ_DEFINE_UNARY_FUNC(Fn_tanh,BZ_MATHFN_SCOPE(tanh))

#ifdef BZ_HAVE_IEEE_MATH
BZ_DEFINE_UNARY_FUNC(Fn_acosh,BZ_IEEEMATHFN_SCOPE(acosh))
BZ_DEFINE_UNARY_FUNC(Fn_asinh,BZ_IEEEMATHFN_SCOPE(asinh))
BZ_DEFINE_UNARY_FUNC(Fn_atanh,BZ_IEEEMATHFN_SCOPE(atanh))
BZ_DEFINE_UNARY_FUNC(Fn_cbrt,BZ_IEEEMATHFN_SCOPE(cbrt))
BZ_DEFINE_UNARY_FUNC(Fn_erf,BZ_IEEEMATHFN_SCOPE(erf))
BZ_DEFINE_UNARY_FUNC(Fn_erfc,BZ_IEEEMATHFN_SCOPE(erfc))
BZ_DEFINE_UNARY_FUNC(Fn_expm1,BZ_IEEEMATHFN_SCOPE(expm1))
BZ_DEFINE_UNARY_FUNC(Fn_j0,BZ_IEEEMATHFN_SCOPE(j0))
BZ_DEFINE_UNARY_FUNC(Fn_j1,BZ_IEEEMATHFN_SCOPE(j1))
BZ_DEFINE_UNARY_FUNC(Fn_lgamma,BZ_IEEEMATHFN_SCOPE(lgamma))
BZ_DEFINE_UNARY_FUNC(Fn_logb,BZ_IEEEMATHFN_SCOPE(logb))
BZ_DEFINE_UNARY_FUNC(Fn_log1p,BZ_IEEEMATHFN_SCOPE(log1p))
BZ_DEFINE_UNARY_FUNC(Fn_rint,BZ_IEEEMATHFN_SCOPE(rint))
BZ_DEFINE_UNARY_FUNC(Fn_y0,BZ_IEEEMATHFN_SCOPE(y0))
BZ_DEFINE_UNARY_FUNC(Fn_y1,BZ_IEEEMATHFN_SCOPE(y1))
#endif

#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DEFINE_UNARY_FUNC(Fn__class,BZ_IEEEMATHFN_SCOPE(_class))
BZ_DEFINE_UNARY_FUNC(Fn_nearest,BZ_IEEEMATHFN_SCOPE(nearest))
BZ_DEFINE_UNARY_FUNC(Fn_rsqrt,BZ_IEEEMATHFN_SCOPE(rsqrt))
#endif

BZ_DEFINE_UNARY_FUNC(Fn_sqr,BZ_BLITZ_SCOPE(blitz_sqr))
BZ_DEFINE_UNARY_FUNC(Fn_cube,BZ_BLITZ_SCOPE(blitz_cube))
BZ_DEFINE_UNARY_FUNC(Fn_pow4,BZ_BLITZ_SCOPE(blitz_pow4))
BZ_DEFINE_UNARY_FUNC(Fn_pow5,BZ_BLITZ_SCOPE(blitz_pow5))
BZ_DEFINE_UNARY_FUNC(Fn_pow6,BZ_BLITZ_SCOPE(blitz_pow6))
BZ_DEFINE_UNARY_FUNC(Fn_pow7,BZ_BLITZ_SCOPE(blitz_pow7))
BZ_DEFINE_UNARY_FUNC(Fn_pow8,BZ_BLITZ_SCOPE(blitz_pow8))

/* Unary functions that return a specified type */

#define BZ_DEFINE_UNARY_FUNC_RET(name,fun,ret)                 \
template<typename T_numtype1>                                  \
struct name {                                                  \
    typedef ret T_numtype;                                     \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a)                                        \
    { return fun(a); }                                         \
                                                               \
    template<typename T1>                                      \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1)               \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};

#ifdef BZ_HAVE_IEEE_MATH
BZ_DEFINE_UNARY_FUNC_RET(Fn_ilogb,BZ_IEEEMATHFN_SCOPE(ilogb),int)
#endif

#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DEFINE_UNARY_FUNC_RET(Fn_itrunc,BZ_IEEEMATHFN_SCOPE(itrunc),int)
BZ_DEFINE_UNARY_FUNC_RET(Fn_uitrunc,BZ_IEEEMATHFN_SCOPE(uitrunc),unsigned int)
#endif


#ifdef BZ_HAVE_COMPLEX
/* Specialization of unary functor for complex type */

#define BZ_DEFINE_UNARY_CFUNC(name,fun)                        \
template<typename T>                                           \
struct name< complex<T> > {                                    \
    typedef complex<T> T_numtype1;                             \
    typedef complex<T> T_numtype;                              \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a)                                        \
    { return fun(a); }                                         \
                                                               \
    template<typename T1>                                      \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1)               \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};

#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DEFINE_UNARY_FUNC(Fn_conj,BZ_CMATHFN_SCOPE(conj))
#endif

#ifdef BZ_HAVE_COMPLEX_MATH1
BZ_DEFINE_UNARY_CFUNC(Fn_cos,BZ_CMATHFN_SCOPE(cos))
BZ_DEFINE_UNARY_CFUNC(Fn_cosh,BZ_CMATHFN_SCOPE(cosh))
BZ_DEFINE_UNARY_CFUNC(Fn_exp,BZ_CMATHFN_SCOPE(exp))
BZ_DEFINE_UNARY_CFUNC(Fn_log,BZ_CMATHFN_SCOPE(log))
BZ_DEFINE_UNARY_CFUNC(Fn_log10,BZ_CMATHFN_SCOPE(log10))
BZ_DEFINE_UNARY_CFUNC(Fn_sin,BZ_CMATHFN_SCOPE(sin))
BZ_DEFINE_UNARY_CFUNC(Fn_sinh,BZ_CMATHFN_SCOPE(sinh))
BZ_DEFINE_UNARY_CFUNC(Fn_sqrt,BZ_CMATHFN_SCOPE(sqrt))
BZ_DEFINE_UNARY_CFUNC(Fn_tan,BZ_CMATHFN_SCOPE(tan))
BZ_DEFINE_UNARY_CFUNC(Fn_tanh,BZ_CMATHFN_SCOPE(tanh))
#endif // BZ_HAVE_COMPLEX_MATH1

BZ_DEFINE_UNARY_CFUNC(Fn_sqr,BZ_BLITZ_SCOPE(blitz_sqr))
BZ_DEFINE_UNARY_CFUNC(Fn_cube,BZ_BLITZ_SCOPE(blitz_cube))
BZ_DEFINE_UNARY_CFUNC(Fn_pow4,BZ_BLITZ_SCOPE(blitz_pow4))
BZ_DEFINE_UNARY_CFUNC(Fn_pow5,BZ_BLITZ_SCOPE(blitz_pow5))
BZ_DEFINE_UNARY_CFUNC(Fn_pow6,BZ_BLITZ_SCOPE(blitz_pow6))
BZ_DEFINE_UNARY_CFUNC(Fn_pow7,BZ_BLITZ_SCOPE(blitz_pow7))
BZ_DEFINE_UNARY_CFUNC(Fn_pow8,BZ_BLITZ_SCOPE(blitz_pow8))

/* Unary functions that apply only to complex<T> and return T */

#define BZ_DEFINE_UNARY_CFUNC2(name,fun)                       \
template<typename T_numtype1>                                  \
struct name;                                                   \
                                                               \
template<typename T>                                           \
struct name< complex<T> > {                                    \
    typedef complex<T> T_numtype1;                             \
    typedef T T_numtype;                                       \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a)                                        \
    { return fun(a); }                                         \
                                                               \
    template<typename T1>                                      \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1)               \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};

#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DEFINE_UNARY_CFUNC2(Fn_arg,BZ_CMATHFN_SCOPE(arg))
BZ_DEFINE_UNARY_CFUNC2(Fn_imag,BZ_CMATHFN_SCOPE(imag))
BZ_DEFINE_UNARY_CFUNC2(Fn_norm,BZ_CMATHFN_SCOPE(norm))
BZ_DEFINE_UNARY_CFUNC2(Fn_real,BZ_CMATHFN_SCOPE(real))
#endif // BZ_HAVE_COMPLEX_FCNS

#endif // BZ_HAVE_COMPLEX

/* Binary functions that return type based on type promotion */

#define BZ_DEFINE_BINARY_FUNC(name,fun)                           \
template<typename T_numtype1, typename T_numtype2>                \
struct name {                                                     \
    typedef BZ_PROMOTE(T_numtype1, T_numtype2) T_numtype;         \
                                                                  \
    static inline T_numtype                                       \
    apply(T_numtype1 a, T_numtype2 b)                             \
    { return fun(a,b); }                                          \
                                                                  \
    template<typename T1, typename T2>                            \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,     \
        prettyPrintFormat& format, const T1& t1,                  \
        const T2& t2)                                             \
    {                                                             \
        str += #fun;                                              \
        str += "(";                                               \
        t1.prettyPrint(str, format);                              \
        str += ",";                                               \
        t2.prettyPrint(str, format);                              \
        str += ")";                                               \
    }                                                             \
};

BZ_DEFINE_BINARY_FUNC(Fn_atan2,BZ_MATHFN_SCOPE(atan2))
BZ_DEFINE_BINARY_FUNC(Fn_fmod,BZ_MATHFN_SCOPE(fmod))
BZ_DEFINE_BINARY_FUNC(Fn_pow,BZ_MATHFN_SCOPE(pow))

#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DEFINE_BINARY_FUNC(Fn_copysign,BZ_IEEEMATHFN_SCOPE(copysign))
BZ_DEFINE_BINARY_FUNC(Fn_drem,BZ_IEEEMATHFN_SCOPE(drem))
BZ_DEFINE_BINARY_FUNC(Fn_hypot,BZ_IEEEMATHFN_SCOPE(hypot))
BZ_DEFINE_BINARY_FUNC(Fn_nextafter,BZ_IEEEMATHFN_SCOPE(nextafter))
BZ_DEFINE_BINARY_FUNC(Fn_remainder,BZ_IEEEMATHFN_SCOPE(remainder))
BZ_DEFINE_BINARY_FUNC(Fn_scalb,BZ_IEEEMATHFN_SCOPE(scalb))
#endif

/* Binary functions that return a specified type */

#define BZ_DEFINE_BINARY_FUNC_RET(name,fun,ret)                   \
template<typename T_numtype1, typename T_numtype2>                \
struct name {                                                     \
    typedef ret T_numtype;                                        \
                                                                  \
    static inline T_numtype                                       \
    apply(T_numtype1 a, T_numtype2 b)                             \
    { return fun(a,b); }                                          \
                                                                  \
    template<typename T1, typename T2>                            \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,     \
        prettyPrintFormat& format, const T1& t1,                  \
        const T2& t2)                                             \
    {                                                             \
        str += #fun;                                              \
        str += "(";                                               \
        t1.prettyPrint(str, format);                              \
        str += ",";                                               \
        t2.prettyPrint(str, format);                              \
        str += ")";                                               \
    }                                                             \
};

#ifdef BZ_HAVE_SYSTEM_V_MATH
BZ_DEFINE_BINARY_FUNC_RET(Fn_unordered,BZ_IEEEMATHFN_SCOPE(unordered),int)
#endif

#ifdef BZ_HAVE_COMPLEX
/* Specialization of binary functor for complex type */

#define BZ_DEFINE_BINARY_CFUNC(name,fun)                       \
template<typename T>                                           \
struct name< complex<T>, complex<T> > {                        \
    typedef complex<T> T_numtype1;                             \
    typedef complex<T> T_numtype2;                             \
    typedef complex<T> T_numtype;                              \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a, T_numtype2 b)                          \
    { return fun(a,b); }                                       \
                                                               \
    template<typename T1, typename T2>                         \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1,               \
        const T2& t2)                                          \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ",";                                            \
        t2.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};                                                             \
                                                               \
template<typename T>                                           \
struct name< complex<T>, T > {                                 \
    typedef complex<T> T_numtype1;                             \
    typedef T T_numtype2;                                      \
    typedef complex<T> T_numtype;                              \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a, T_numtype2 b)                          \
    { return fun(a,b); }                                       \
                                                               \
    template<typename T1, typename T2>                         \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1,               \
        const T2& t2)                                          \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ",";                                            \
        t2.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};                                                             \
                                                               \
template<typename T>                                           \
struct name< T, complex<T> > {                                 \
    typedef T T_numtype1;                                      \
    typedef complex<T> T_numtype2;                             \
    typedef complex<T> T_numtype;                              \
                                                               \
    static inline T_numtype                                    \
    apply(T_numtype1 a, T_numtype2 b)                          \
    { return fun(a,b); }                                       \
                                                               \
    template<typename T1, typename T2>                         \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,  \
        prettyPrintFormat& format, const T1& t1,               \
        const T2& t2)                                          \
    {                                                          \
        str += #fun;                                           \
        str += "(";                                            \
        t1.prettyPrint(str, format);                           \
        str += ",";                                            \
        t2.prettyPrint(str, format);                           \
        str += ")";                                            \
    }                                                          \
};

#ifdef BZ_HAVE_COMPLEX_MATH1
BZ_DEFINE_BINARY_CFUNC(Fn_pow,BZ_CMATHFN_SCOPE(pow))
#endif

/* Binary functions that apply only to T and return complex<T> */

#define BZ_DEFINE_BINARY_FUNC_CRET(name,fun)                      \
template<typename T_numtype1, typename T_numtype2>                \
struct name;                                                      \
                                                                  \
template<typename T>                                              \
struct name<T, T> {                                               \
    typedef T T_numtype1;                                         \
    typedef T T_numtype2;                                         \
    typedef complex<T> T_numtype;                                 \
                                                                  \
    static inline T_numtype                                       \
    apply(T_numtype1 a, T_numtype2 b)                             \
    { return fun(a,b); }                                          \
                                                                  \
    template<typename T1, typename T2>                            \
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,     \
        prettyPrintFormat& format, const T1& t1,                  \
        const T2& t2)                                             \
    {                                                             \
        str += #fun;                                              \
        str += "(";                                               \
        t1.prettyPrint(str, format);                              \
        str += ",";                                               \
        t2.prettyPrint(str, format);                              \
        str += ")";                                               \
    }                                                             \
};

#ifdef BZ_HAVE_COMPLEX_FCNS
BZ_DEFINE_BINARY_FUNC_CRET(Fn_polar,BZ_CMATHFN_SCOPE(polar))
#endif

#endif // BZ_HAVE_COMPLEX

/* Ternary functions that return type based on type promotion */

#define BZ_DEFINE_TERNARY_FUNC(name,fun)                          \
template <typename P_numtype1, typename P_numtype2,               \
          typename P_numtype3>                                    \
struct name {                                                     \
    typedef BZ_PROMOTE(P_numtype1,                                \
            BZ_PROMOTE(P_numtype2,P_numtype3)) T_numtype;         \
                                                                  \
    static inline T_numtype                                       \
    apply(P_numtype1 x, P_numtype2 y, P_numtype3 z)               \
    { return fun(x,y,z); }                                        \
                                                                  \
    template <typename T1, typename T2, typename T3>              \
    static void prettyPrint(BZ_STD_SCOPE(string) &str,            \
        prettyPrintFormat& format,                                \
        const T1& a,const T2& b, const T3& c)                     \
    {                                                             \
        str += #fun;                                              \
        str += "(";                                               \
        a.prettyPrint(str,format);                                \
        str += ",";                                               \
        b.prettyPrint(str,format);                                \
        str += ",";                                               \
        c.prettyPrint(str,format);                                \
        str += ")";                                               \
    }                                                             \
};

/* Ternary functions that return a specified type */

#define BZ_DEFINE_TERNARY_FUNC_RET(name,fun,ret)                  \
template <typename P_numtype1, typename P_numtype2,               \
          typename P_numtype3>                                    \
struct name {                                                     \
    typedef ret T_numtype;                                        \
                                                                  \
    static inline T_numtype                                       \
    apply(P_numtype1 x, P_numtype2 y, P_numtype3 z)               \
    { return fun(x,y,z); }                                        \
                                                                  \
    template <typename T1, typename T2, typename T3>              \
    static void prettyPrint(BZ_STD_SCOPE(string) &str,            \
        prettyPrintFormat& format,                                \
        const T1& a,const T2& b, const T3& c)                     \
    {                                                             \
        str += #fun;                                              \
        str += "(";                                               \
        a.prettyPrint(str,format);                                \
        str += ",";                                               \
        b.prettyPrint(str,format);                                \
        str += ",";                                               \
        c.prettyPrint(str,format);                                \
        str += ")";                                               \
    }                                                             \
};


/* These functions don't quite fit the usual patterns */

// abs()    Absolute value
template<typename T_numtype1>
struct Fn_abs;

// abs(int)
template<>
struct Fn_abs< int > {
    typedef int T_numtype1;
    typedef int T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_MATHFN_SCOPE(abs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};

// abs(long)
template<>
struct Fn_abs< long int > {
    typedef long int T_numtype1;
    typedef long int T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_MATHFN_SCOPE(labs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};

// abs(float)
template<>
struct Fn_abs< float > {
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_MATHFN_SCOPE(fabs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};

// abs(double)
template<>
struct Fn_abs< double > {
    typedef double T_numtype1;
    typedef double T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_MATHFN_SCOPE(fabs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};

// abs(long double)
template<>
struct Fn_abs< long double > {
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_MATHFN_SCOPE(fabs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};

#ifdef BZ_HAVE_COMPLEX_FCNS
// abs(complex<T>)
template<typename T>
struct Fn_abs< complex<T> > {
    typedef complex<T> T_numtype1;
    typedef T T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return BZ_CMATHFN_SCOPE(abs)(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "abs";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};
#endif // BZ_HAVE_COMPLEX_FCNS


#ifdef BZ_HAVE_IEEE_MATH
// isnan()    Nonzero if NaNS or NaNQ
template<typename T_numtype1>
struct Fn_isnan {
    typedef int T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    {
#ifdef BZ_ISNAN_IN_NAMESPACE_STD
        return BZ_STD_SCOPE(isnan)(a);
#else
        return BZ_IEEEMATHFN_SCOPE(isnan)(a);
#endif
    }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += "isnan";
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};
#endif // BZ_HAVE_IEEE_MATH


// Blitz cast() function
template<typename T_numtype1, typename T_cast>
struct Cast {
    typedef T_cast T_numtype;

    static inline T_numtype
    apply(T_numtype1 a)
    { return T_numtype(a); }

    template<typename T1>
    static inline void prettyPrint(BZ_STD_SCOPE(string) &str,
        prettyPrintFormat& format, const T1& t1)
    {
        str += BZ_DEBUG_TEMPLATE_AS_STRING_LITERAL(T_cast);
        str += "(";
        t1.prettyPrint(str, format);
        str += ")";
    }
};


BZ_NAMESPACE_END

#endif // BZ_FUNCS_H
                     generate/                                                                                           0040755 0001750 0001750 00000000000 12612224744 041514  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  arroperands.h                                                                                       0100644 0001750 0001750 00000014514 12160377112 044203  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include <iostream>
#include <string>
#include <fstream>

class operand {
public:
    operand(const char* name, const char* templateName, const char* iterator, 
        const char* numtype, const char* initialization)
      : name_(name), template_(templateName), iterator_(iterator), 
        numtype_(numtype), initialization_(initialization)
    { }

    virtual int haveTemplate() const
    { return template_ != 0; }

    void setOperandNum(int i) 
    { operandNum_ = i; }

    virtual void printName(std::ostream& os)
    { 
        os << name_;           
        printTemplateList(os);
    }

    virtual void printTemplate(std::ostream& os, int n=0)
    {
        if (haveTemplate())
            os << template_ << operandNum_;
    }

    virtual void printTemplateType(std::ostream& os, int n=0)
    {
        if (haveTemplate())
            os << "class";
    }

    virtual int numTemplateParameters() const
    {
        if (haveTemplate())
            return 1;
        else
            return 0;
    }

    virtual int isScalar() const
    { return 0; }

    virtual int isInteger() const
    { return 0; }

    virtual int isComplex() const
    { return 0; }

    virtual int isRange() const
    { return 0; }

    virtual int passByReference() const
    { return 0; }

    virtual void printArgument(std::ostream& os)
    {
        if (passByReference())
            os << "const ";
        printName(os);
        if (passByReference())
            os << "&";

        os << " d" << operandNum_;      
    }

    virtual void printIterator(std::ostream& os)
    {
        os << iterator_;
        printTemplateList(os);
    }

    virtual void printTemplateList(std::ostream& os)
    {
        if (haveTemplate())
        {
            os << "<";
            for (int i=0; i < numTemplateParameters(); ++i)
            {
                // printTemplateType(os,i);
                // os << " ";
                printTemplate(os,i);
                if (i != numTemplateParameters() - 1)
                    os << ", ";
            }
            os << ">";
        }
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << numtype_ << operandNum_;
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "d" << operandNum_;       
        if (initialization_ != 0)
            os << initialization_;
    }

protected:
    const char* name_;
    const char* template_;
    const char* iterator_;
    const char* numtype_;
    const char* initialization_;
    int operandNum_;
};

class ArrayOperand : public operand {
public:
    ArrayOperand()
      : operand("Array", 0, "ArrayIterator", "T_numtype", ".begin()")
    { }

    virtual void printTemplate(std::ostream& os, int n)
    {
        switch(n)
        {
            case 0: os << "T_numtype" << operandNum_; break;
            case 1: os << "N_rank" << operandNum_; break;
        }
    }

    virtual int passByReference() const
    { return 1; }

    virtual void printTemplateType(std::ostream& os, int n=0)
    {
        switch(n)
        {
            case 0: os << "class"; break;
            case 1: os << "int"; break;
        }
    }

    virtual int numTemplateParameters() const
    {
        return 2;
    }

    virtual int haveTemplate() const
    { return 1; }
};

class ArrayExprOperand : public operand {
public:
    ArrayExprOperand()
      : operand("_bz_ArrayExpr", "P_expr", "_bz_ArrayExpr",
           0, 0)
    { }

    virtual void printNumtype(std::ostream& os)
    {
        os << "typename P_expr" << operandNum_ << "::T_numtype";
    }
};

class IndexOperand : public operand {
public:
    IndexOperand()
      : operand("IndexPlaceholder", "N_index", "IndexPlaceholder", 0, 0)
    { }

    virtual void printNumtype(std::ostream& os)
    {
        os << "int";
    }

    virtual void printTemplateType(std::ostream& os, int n=0)
    {
        if (haveTemplate())
            os << "int";
    }
};

class ScalarOperand : public operand {
public:
    ScalarOperand(const char* name)
      : operand(name, 0, 0, name, 0)
    { }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_ArrayExprConstant<" << name_ << ">";
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "_bz_ArrayExprConstant<" << name_ << ">(d"
           << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << name_;
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }
};

class ComplexOperand : public operand {
public:
    ComplexOperand()
      : operand("complex", "T", 0, "complex", 0)
    { }

    virtual int isComplex() const
    { return 1; }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_ArrayExprConstant<";
        printNumtype(os);
        os << "> ";
    }

    virtual void printInitialization(std::ostream& os)
    {
        printIterator(os);
        os << "(d" << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << "complex<";
        printTemplate(os);
        os << "> ";
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }
};


/**************************************************************************
 *
 * Operand Set
 *
 **************************************************************************/

#define BZ_ARREXPR_NUM_OPERANDS 8

class operandSet {
public:
    operandSet()
    {
        operands_[0] = new ArrayOperand;
        operands_[1] = new ArrayExprOperand;
        operands_[2] = new IndexOperand;
        operands_[3] = new ScalarOperand("int");
        operands_[4] = new ScalarOperand("float");
        operands_[5] = new ScalarOperand("double");
        operands_[6] = new ScalarOperand("long double");
        operands_[7] = new ComplexOperand;
    }

    ~operandSet()
    {
        for (int i=0; i < BZ_ARREXPR_NUM_OPERANDS; ++i)
            delete operands_[i];
    }

    operand& operator[](int i) 
    { return *operands_[i]; }

    int numOperands() const
    { return BZ_ARREXPR_NUM_OPERANDS; }

    void setOperandNum(int num)
    {
        for (int i=0; i < BZ_ARREXPR_NUM_OPERANDS; ++i)
            operands_[i]->setOperandNum(num);
    }

private:
    operandSet(const operandSet&);
    void operator=(const operandSet&);

    operand * operands_[BZ_ARREXPR_NUM_OPERANDS];
};


                                                                                                                                                                                    arroptuple.h                                                                                        0100644 0001750 0001750 00000010753 12160377112 044061  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include "arroperands.h"

class OperandTuple {

public:
    OperandTuple(int n)
    {
        operands_ = new operandSet[n];
        index_ = new int[n];
        numOperands_ = n;

        for (int i=0; i < numOperands_; ++i)
        {
            index_[i] = 0;
            operands_[i].setOperandNum(i+1);
        }

        done_ = 0;

        numSpecializations_ = 0;
    }

    ~OperandTuple()
    {
        delete [] operands_;
        delete [] index_;
    }

    int numSpecializations() const
    { return numSpecializations_; }
  
    int operandIndex(int i) const
    { return index_[i]; }
 
    operand& operator[](int i)
    {
        return operands_[i][index_[i]];
    }

    operator int()
    {
        return !done_;
    }

    int operator++()
    {
        // This version is like increment(), but it checks to make
        // sure the operand tuple is valid.  For example, an operand
        // tuple of all scalars is not permitted, since this
        // would interfere with built-in versions of +, -, etc.
        do {
            increment();
        } while (!done_ && !isValidTuple());

        ++numSpecializations_;

        return !done_;
    }

    int increment()
    {
        for (int j=numOperands_ - 1; j >= 0; --j)
        {
            if (++index_[j] != operands_[j].numOperands())
                break;

            if (j == 0)
            {
                done_ = 1;
                index_[j] = 0;
                break;
            }

            index_[j] = 0;
        }

        return !done_;
    }

    int isValidTuple()
    {
        // Count the number of scalar operands
        int numScalars = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            if (operands_[i][index_[i]].isScalar())
                ++numScalars;
        }

        if (numScalars == numOperands_)
            return 0;

        return 1;
    }

    int anyComplex()
    {
        for (int i=0; i < numOperands_; ++i)
            if ((*this)[i].isComplex())
                return 1;

        return 0;
    }

    void reset()
    {
        done_ = 0;

        for (int i=0; i < numOperands_; ++i)
            index_[i] = 0;
    }

    int numTemplates() 
    {
        int countTemplates = 0;
        for (int i=0; i < numOperands_; ++i)
            countTemplates += operands_[i][index_[i]].numTemplateParameters();
        return countTemplates;
    }

    void printTemplates(std::ostream& os)
    {
        if (!numTemplates())
            return;

        os << "template<";

        int templatesWritten = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            for (int j=0; j < (*this)[i].numTemplateParameters(); ++j)
            {
                if (templatesWritten)
                    os << ", ";
                (*this)[i].printTemplateType(os, j);
                os << " ";
                (*this)[i].printTemplate(os, j);
                ++templatesWritten;
            }

        }

        os << ">";
    }

    void printTypes(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printName(os);
        }
    }

    void printIterators(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printIterator(os);
        }
    }

    void printArgumentList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printArgument(os);
        }
    }

    void printInitializationList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printInitialization(os);
        }
    }
 
private:
    OperandTuple() { }
    OperandTuple(const OperandTuple&) { }
    void operator=(const OperandTuple&) { };

    operandSet* operands_;
    int* index_;
    int numOperands_;
    int done_;
    int numSpecializations_;
};

                     bzfstream.h                                                                                         0100644 0001750 0001750 00000004422 12160377112 043655  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         /***************************************************************************
 * blitz/generate/bzfstream.h    Definition of the bzofstream class
 *
 * $Id: bzfstream.h 1413 2005-11-01 22:04:15Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/


#include <fstream>
#include <iomanip>
#include <iostream>

class bzofstream : public std::ofstream {

public:
    bzofstream(const char* filename, const char* description,
        const char* sourceFile, const char* mnemonic)
        : std::ofstream(filename)
    {
        (*this) << 
"/***************************************************************************\n"
" * blitz/" << filename << "\t" << description << std::endl <<
" *\n"
" * This code was relicensed under the modified BSD license for use in SciPy\n"
" * by Todd Veldhuizen (see LICENSE.txt in the weave directory).\n"
" *\n"
" *\n"
" * Suggestions:          blitz-suggest@cybervision.com\n"
" * Bugs:                 blitz-bugs@cybervision.com\n"
" *\n"
" * For more information, please see the Blitz++ Home Page:\n"
" *    http://seurat.uwaterloo.ca/blitz/\n"
" *\n"
" ***************************************************************************\n"
" *\n"
" */ " 
       << std::endl << std::endl
       << "// Generated source file.  Do not edit. " << std::endl
       << "// " << sourceFile << " " << __DATE__ << " " << __TIME__ 
       << std::endl << std::endl
       << "#ifndef " << mnemonic << std::endl
       << "#define " << mnemonic << std::endl << std::endl;
    }

    void include(const char* filename)
    {
        (*this) << "#include <blitz/" << filename << ">" << std::endl;
    }

    void beginNamespace()
    {
        (*this) << "BZ_NAMESPACE(blitz)" << std::endl << std::endl;
    }

    ~bzofstream()
    {
        (*this) << "BZ_NAMESPACE_END" << std::endl << std::endl
                << "#endif" << std::endl;
    }

};

                                                                                                                                                                                                                                              operands.h                                                                                          0100644 0001750 0001750 00000016030 12160377112 043471  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include <iostream>
#include <string>
#include <fstream>

class operand {
public:
    operand(const char* name, const char* templateName, const char* iterator, 
        const char* numtype, const char* initialization)
      : name_(name), template_(templateName), iterator_(iterator), 
        numtype_(numtype), initialization_(initialization)
    { }

    int haveTemplate() const
    { return template_ != 0; }

    void setOperandNum(int i) 
    { operandNum_ = i; }

    virtual void printName(std::ostream& os)
    { 
        os << name_;           
        if (haveTemplate())
        {
            os << "<" << template_ << operandNum_ << ">";
        }
    }

    virtual void printTemplate(std::ostream& os, int n=0)
    {
        if (haveTemplate())
            os << template_ << operandNum_;
    }

    virtual void printTemplateType(std::ostream& os, int n=0)
    {
        if (haveTemplate())
            os << "class";
    }

    virtual int numTemplateParameters() const
    {
        if (haveTemplate())
            return 1;
        else
            return 0;
    }

    virtual int isScalar() const
    { return 0; }

    virtual int isInteger() const
    { return 0; }

    virtual int isComplex() const
    { return 0; }

    virtual int isRange() const
    { return 0; }

    virtual void printArgument(std::ostream& os)
    {
        printName(os);
        os << " d" << operandNum_;      
    }

    virtual void printIterator(std::ostream& os)
    {
        os << iterator_;

        if (haveTemplate())
            os << "<" << template_ << operandNum_ << ">";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << numtype_ << operandNum_;
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "d" << operandNum_;       
        if (initialization_ != 0)
            os << initialization_;
    }

protected:
    const char* name_;
    const char* template_;
    const char* iterator_;
    const char* numtype_;
    const char* initialization_;
    int operandNum_;
};

class VecOperand : public operand {
public:
    VecOperand()
      : operand("Vector", "P_numtype", "VectorIterConst",
           "P_numtype", ".beginFast()")
    { }

    virtual void printArgument(std::ostream& os)
    {
        os << "const ";
        printName(os);
        os << "& d" << operandNum_;
    }

};

class TinyVecOperand : public operand {
public:
    TinyVecOperand()
      : operand("TinyVector", "P_numtype", "TinyVectorIterConst",
           "P_numtype", ".beginFast()")
    { }

    virtual void printArgument(std::ostream& os)
    {
        os << "const ";
        printName(os);
        os << "& d" << operandNum_;
    }

    virtual void printName(std::ostream& os)
    {
        os << "TinyVector<P_numtype" << operandNum_
           << ", N_length" << operandNum_ << ">";
    }

    virtual void printTemplate(std::ostream& os, int n)
    {
        if (n == 0)
        {
            os << "P_numtype" << operandNum_;
        }
        else if (n == 1)
        {
            os << "N_length" << operandNum_;
        }
    }

    virtual void printTemplateType(std::ostream& os, int n)
    {
        if (n == 0)
            os << "class";
        else if (n == 1)
            os << "int";
    }

    virtual int numTemplateParameters() const
    {
        return 2;
    }

    virtual void printIterator(std::ostream& os)
    {
        os << "TinyVectorIterConst<P_numtype" << operandNum_
           << ", N_length" << operandNum_ << ">";
    }


};


class VecPickOperand : public operand  {
public:
    VecPickOperand()
      : operand("VectorPick", "P_numtype", "VectorPickIterConst",
            "P_numtype", ".beginFast()")
    { }

    virtual void printArgument(std::ostream& os)
    {
        os << "const ";
        printName(os);
        os << "& d" << operandNum_;
    }
};

class VecExprOperand : public operand {
public:
    VecExprOperand()
      : operand("_bz_VecExpr", "P_expr", "_bz_VecExpr",
           0, 0)
    { }

    virtual void printNumtype(std::ostream& os)
    {
        os << "typename P_expr" << operandNum_ << "::T_numtype";
    }
};

class RangeOperand : public operand {
public:
    RangeOperand()
      : operand("Range", 0, "Range", 0, 0)
    { }

    virtual void printNumtype(std::ostream& os)
    {
        os << "int";
    }

    virtual int isRange() const
    { return 1; }
};

class ScalarOperand : public operand {
public:
    ScalarOperand(const char* name)
      : operand(name, 0, 0, name, 0)
    { }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_VecExprConstant<" << name_ << ">";
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "_bz_VecExprConstant<" << name_ << ">(d"
           << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << name_;
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }
};

class ComplexOperand : public operand {
public:
    ComplexOperand()
      : operand("complex", "T", 0, "complex", 0)
    { }

    virtual int isComplex() const
    { return 1; }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_VecExprConstant<";
        printNumtype(os);
        os << "> ";
    }

    virtual void printInitialization(std::ostream& os)
    {
        printIterator(os);
        os << "(d" << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << "complex<";
        printTemplate(os);
        os << "> ";
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }
};


/**************************************************************************
 *
 * Operand Set
 *
 **************************************************************************/

#define BZ_VECEXPR_NUM_OPERANDS 10

class operandSet {
public:
    operandSet()
    {
        operands_[0] = new VecOperand;
        operands_[1] = new VecExprOperand;
        operands_[2] = new VecPickOperand;
        operands_[3] = new RangeOperand;
        operands_[4] = new TinyVecOperand;
        operands_[5] = new ScalarOperand("int");
        operands_[6] = new ScalarOperand("float");
        operands_[7] = new ScalarOperand("double");
        operands_[8] = new ScalarOperand("long double");
        operands_[9] = new ComplexOperand;

//        operands_[8] = new ScalarOperand("complex<float> ");
//        operands_[9] = new ScalarOperand("complex<double> ");
//        operands_[10] = new ScalarOperand("complex<long double> ");
    }

    ~operandSet()
    {
        for (int i=0; i < BZ_VECEXPR_NUM_OPERANDS; ++i)
            delete operands_[i];
    }

    operand& operator[](int i) 
    { return *operands_[i]; }

    int numOperands() const
    { return BZ_VECEXPR_NUM_OPERANDS; }

    void setOperandNum(int num)
    {
        for (int i=0; i < BZ_VECEXPR_NUM_OPERANDS; ++i)
            operands_[i]->setOperandNum(num);
    }

private:
    operandSet(const operandSet&);
    void operator=(const operandSet&);

    operand * operands_[BZ_VECEXPR_NUM_OPERANDS];
};


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        operands2.h                                                                                         0100644 0001750 0001750 00000013161 12160377112 043555  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include <iostream>
#include <string>

class operand2 {
public:
    operand2(const char* name, const char* templateName1, 
        const char* templateName2, const char* iterator, const char* numtype, 
        const char* initialization)
      : name_(name), template1_(templateName1), template2_(templateName2),
        iterator_(iterator), numtype_(numtype), initialization_(initialization)
    { }

    int haveTemplate1() const
    { return template1_ != 0; }

    int haveTemplate2() const
    { return template2_ != 0; }

    void setOperandNum(int i) 
    { operandNum_ = i; }

    virtual void printName(std::ostream& os)
    { 
        os << name_;           
        printTemplates(os);
    }

    virtual void printTemplates(std::ostream& os)
    {
        if (haveTemplate1())
        {
            os << "<" << template1_ << operandNum_;
            if (haveTemplate2())
            {
                os << ", " << template2_ << operandNum_;
            }
            os << ">";
        }
    }

    virtual void printTemplate1(std::ostream& os)
    {
        if (haveTemplate1())
            os << template1_ << operandNum_;
    }

    virtual void printTemplate2(std::ostream& os)
    {
        if (haveTemplate2())
            os << template2_ << operandNum_;
    }

    virtual void printTemplateType1(std::ostream& os)
    {
        if (haveTemplate1())
            os << "class";
    }

    virtual void printTemplateType2(std::ostream& os)
    {
        if (haveTemplate2())
            os << "class";
    }

    virtual int numTemplateParameters() const
    {
        if (haveTemplate1() && haveTemplate2())
            return 2;
        else if (haveTemplate1())
            return 1;
        else
            return 0;
    }

    virtual int isScalar() const
    { return 0; }

    virtual int isInteger() const
    { return 0; }

    virtual int isComplex() const
    { return 0; }

    virtual void printArgument(std::ostream& os)
    {
        printName(os);
        os << " d" << operandNum_;      
    }

    virtual void printIterator(std::ostream& os)
    {
        os << iterator_;
        printTemplates(os);
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << numtype_ << operandNum_;
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "d" << operandNum_;       
        if (initialization_ != 0)
            os << initialization_;
    }

protected:
    const char* name_;
    const char* template1_;
    const char* template2_;
    const char* iterator_;
    const char* numtype_;
    const char* initialization_;
    int operandNum_;
};

class MatOperand : public operand2 {
public:
    MatOperand()
      : operand2("Matrix", "P_numtype", "P_struct", "_bz_MatrixRef",
           "P_numtype", "._bz_getRef()")
    { }

    virtual void printArgument(std::ostream& os)
    {
        os << "const ";
        printName(os);
        os << "& d" << operandNum_;
    }

};

class MatExprOperand : public operand2 {
public:
    MatExprOperand()
      : operand2("_bz_MatExpr", "P_expr", 0, "_bz_MatExpr",
           0, 0)
    { }

    virtual void printNumtype(std::ostream& os)
    {
        os << "typename P_expr" << operandNum_ << "::T_numtype";
    }
};

class ScalarOperand2 : public operand2 {
public:
    ScalarOperand2(const char* name)
      : operand2(name, 0, 0, 0, name, 0)
    { }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_MatExprConstant<" << name_ << ">";
    }

    virtual void printInitialization(std::ostream& os)
    {
        os << "_bz_MatExprConstant<" << name_ << ">(d"
           << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << name_;
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }

};

class ComplexOperand2 : public operand2 {
public:
    ComplexOperand2()
      : operand2("complex", "T", 0, 0, "complex", 0)
    { }

    virtual int isComplex() const
    { return 1; }

    virtual void printIterator(std::ostream& os)
    {
        os << "_bz_MatExprConstant<";
        printNumtype(os);
        os << "> ";
    }

    virtual void printInitialization(std::ostream& os)
    {
        printIterator(os);
        os << "(d" << operandNum_ << ")";
    }

    virtual void printNumtype(std::ostream& os)
    {
        os << "complex<";
        printTemplate1(os);
        os << "> ";
    }

    virtual int isScalar() const
    { return 1; }

    virtual int isInteger() const
    { return !strcmp(name_, "int"); }
};

/**************************************************************************
 *
 * Operand Set
 *
 **************************************************************************/

#define BZ_MATEXPR_NUM_OPERANDS 7

class operandSet2 {
public:
    operandSet2()
    {
        operands_[0] = new MatOperand;
        operands_[1] = new MatExprOperand;
        operands_[2] = new ScalarOperand2("int");
        operands_[3] = new ScalarOperand2("float");
        operands_[4] = new ScalarOperand2("double");
        operands_[5] = new ScalarOperand2("long double");
        operands_[6] = new ComplexOperand2;
    }

    ~operandSet2()
    {
        for (int i=0; i < BZ_MATEXPR_NUM_OPERANDS; ++i)
            delete operands_[i];
    }

    operand2& operator[](int i) 
    { return *operands_[i]; }

    int numOperands() const
    { return BZ_MATEXPR_NUM_OPERANDS; }

    void setOperandNum(int num)
    {
        for (int i=0; i < BZ_MATEXPR_NUM_OPERANDS; ++i)
            operands_[i]->setOperandNum(num);
    }

private:
    operandSet2(const operandSet2&);
    void operator=(const operandSet2&);

    operand2 * operands_[BZ_MATEXPR_NUM_OPERANDS];
};
                                                                                                                                                                                                                                                                                                                                                                                                               optuple.h                                                                                           0100644 0001750 0001750 00000010750 12160377112 043351  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include "operands.h"

class OperandTuple {

public:
    OperandTuple(int n)
    {
        operands_ = new operandSet[n];
        index_ = new int[n];
        numOperands_ = n;

        for (int i=0; i < numOperands_; ++i)
        {
            index_[i] = 0;
            operands_[i].setOperandNum(i+1);
        }

        done_ = 0;

        numSpecializations_ = 0;
    }

    ~OperandTuple()
    {
        delete [] operands_;
        delete [] index_;
    }

    int numSpecializations() const
    { return numSpecializations_; }
  
    int operandIndex(int i) const
    { return index_[i]; }
 
    operand& operator[](int i)
    {
        return operands_[i][index_[i]];
    }

    operator int()
    {
        return !done_;
    }

    int operator++()
    {
        // This version is like increment(), but it checks to make
        // sure the operand tuple is valid.  For example, an operand
        // tuple of all scalars is not permitted, since this
        // would interfere with built-in versions of +, -, etc.
        do {
            increment();
        } while (!done_ && !isValidTuple());

        ++numSpecializations_;

        return !done_;
    }

    int increment()
    {
        for (int j=numOperands_ - 1; j >= 0; --j)
        {
            if (++index_[j] != operands_[j].numOperands())
                break;

            if (j == 0)
            {
                done_ = 1;
                index_[j] = 0;
                break;
            }

            index_[j] = 0;
        }

        return !done_;
    }

    int isValidTuple()
    {
        // Count the number of scalar operands
        int numScalars = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            if (operands_[i][index_[i]].isScalar())
                ++numScalars;
        }

        if (numScalars == numOperands_)
            return 0;

        return 1;
    }

    int anyComplex()
    {
        for (int i=0; i < numOperands_; ++i)
            if ((*this)[i].isComplex())
                return 1;

        return 0;
    }

    void reset()
    {
        done_ = 0;

        for (int i=0; i < numOperands_; ++i)
            index_[i] = 0;
    }

    int numTemplates() 
    {
        int countTemplates = 0;
        for (int i=0; i < numOperands_; ++i)
            countTemplates += operands_[i][index_[i]].numTemplateParameters();
        return countTemplates;
    }

    void printTemplates(std::ostream& os)
    {
        if (!numTemplates())
            return;

        os << "template<";

        int templatesWritten = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            for (int j=0; j < (*this)[i].numTemplateParameters(); ++j)
            {
                if (templatesWritten)
                    os << ", ";
                (*this)[i].printTemplateType(os, j);
                os << " ";
                (*this)[i].printTemplate(os, j);
                ++templatesWritten;
            }

        }

        os << ">";
    }

    void printTypes(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printName(os);
        }
    }

    void printIterators(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printIterator(os);
        }
    }

    void printArgumentList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printArgument(os);
        }
    }

    void printInitializationList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printInitialization(os);
        }
    }
 
private:
    OperandTuple() { }
    OperandTuple(const OperandTuple&) { }
    void operator=(const OperandTuple&) { };

    operandSet* operands_;
    int* index_;
    int numOperands_;
    int done_;
    int numSpecializations_;
};

                        optuple2.h                                                                                          0100644 0001750 0001750 00000011402 12160377112 043426  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/generate                         #include "operands2.h"

class OperandTuple2 {

public:
    OperandTuple2(int n)
    {
        operands_ = new operandSet2[n];
        index_ = new int[n];
        numOperands_ = n;

        for (int i=0; i < numOperands_; ++i)
        {
            index_[i] = 0;
            operands_[i].setOperandNum(i+1);
        }

        done_ = 0;

        numSpecializations_ = 0;
    }

    ~OperandTuple2()
    {
        delete [] operands_;
        delete [] index_;
    }

    int numSpecializations() const
    { return numSpecializations_; }
  
    int operandIndex(int i) const
    { return index_[i]; }
 
    operand2& operator[](int i)
    {
        return operands_[i][index_[i]];
    }

    operator int()
    {
        return !done_;
    }

    int operator++()
    {
        // This version is like increment(), but it checks to make
        // sure the operand tuple is valid.  For example, an operand
        // tuple of all scalars is not permitted, since this
        // would interfere with built-in versions of +, -, etc.
        do {
            increment();
        } while (!done_ && !isValidTuple());

        ++numSpecializations_;

        return !done_;
    }

    int increment()
    {
        for (int j=numOperands_ - 1; j >= 0; --j)
        {
            if (++index_[j] != operands_[j].numOperands())
                break;

            if (j == 0)
            {
                done_ = 1;
                index_[j] = 0;
                break;
            }

            index_[j] = 0;
        }

        return !done_;
    }

    int isValidTuple()
    {
        // Count the number of scalar operands
        int numScalars = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            if (operands_[i][index_[i]].isScalar())
                ++numScalars;
        }

        if (numScalars == numOperands_)
            return 0;

        return 1;
    }

    int anyComplex()
    {
        for (int i=0; i < numOperands_; ++i)
            if ((*this)[i].isComplex())
                return 1;

        return 0;
    }

    void reset()
    {
        done_ = 0;

        for (int i=0; i < numOperands_; ++i)
            index_[i] = 0;
    }

    int numTemplates() 
    {
        int countTemplates = 0;
        for (int i=0; i < numOperands_; ++i)
            countTemplates += operands_[i][index_[i]].numTemplateParameters();
        return countTemplates;
    }

    void printTemplates(std::ostream& os)
    {
        if (!numTemplates())
            return;

        os << "template<";

        int templatesWritten = 0;

        for (int i=0; i < numOperands_; ++i)
        {
            if ((*this)[i].haveTemplate1())
            {
                if (templatesWritten)
                    os << ", ";
                (*this)[i].printTemplateType1(os);
                os << " ";
                (*this)[i].printTemplate1(os);
                ++templatesWritten;
            }
            if ((*this)[i].haveTemplate2())
            {
                if (templatesWritten)
                    os << ", ";
                (*this)[i].printTemplateType2(os);
                os << " ";
                (*this)[i].printTemplate2(os);
                ++templatesWritten;
            }
        }

        os << ">";
    }

    void printTypes(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printName(os);
        }
    }

    void printIterators(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printIterator(os);
        }
    }

    void printArgumentList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printArgument(os);
        }
    }

    void printInitializationList(std::ostream& os, int feedFlag = 0)
    {
        for (int i=0; i < numOperands_; ++i)
        {
            if (i > 0)
            {
                os << ", ";
                if (feedFlag)
                    os << std::endl << "      ";
            }

            (*this)[i].printInitialization(os);
        }
    }
 
private:
    OperandTuple2() { }
    OperandTuple2(const OperandTuple2&) { }
    void operator=(const OperandTuple2&) { };

    operandSet2* operands_;
    int* index_;
    int numOperands_;
    int done_;
    int numSpecializations_;
};

                                                                                                                                                                                                                                                              gnu/                                                                                                0040755 0001750 0001750 00000000000 12612224744 040513  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  bzconfig.h                                                                                          0100644 0001750 0001750 00000023527 12160377112 042467  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz/gnu                              #ifndef _BLITZ_GNU_BZCONFIG_H
#define _BLITZ_GNU_BZCONFIG_H 1
 
/* blitz/gnu/bzconfig.h. Generated automatically at end of configure. */
/* blitz/config.h.  Generated by configure.  */
/* blitz/config.h.in.  Generated from configure.ac by autoheader.  */


/******************************************************************************
 * config.h           Compiler language support flags
 *
 * This file was generated automatically when running the configure script.
 * You should rerun configure each time you switch compilers, install new
 * standard libraries, or change compiler versions.
 *
 */



/* define if bool is a built-in type */
#ifndef BZ_HAVE_BOOL 
#define BZ_HAVE_BOOL   
#endif

/* define if the compiler has <climits> header */
#ifndef BZ_HAVE_CLIMITS 
#define BZ_HAVE_CLIMITS   
#endif

/* define if the compiler has complex<T> */
#ifndef BZ_HAVE_COMPLEX 
#define BZ_HAVE_COMPLEX   
#endif

/* define if the compiler has standard complex<T> functions */
#ifndef BZ_HAVE_COMPLEX_FCNS 
#define BZ_HAVE_COMPLEX_FCNS   
#endif

/* define if the compiler has complex math functions */
#ifndef BZ_HAVE_COMPLEX_MATH1 
#define BZ_HAVE_COMPLEX_MATH1   
#endif

/* define if the compiler has more complex math functions */
/* #undef BZ_HAVE_COMPLEX_MATH2 */

/* define if complex math functions are in namespace std */
#ifndef BZ_HAVE_COMPLEX_MATH_IN_NAMESPACE_STD 
#define BZ_HAVE_COMPLEX_MATH_IN_NAMESPACE_STD   
#endif

/* define if the compiler supports const_cast<> */
#ifndef BZ_HAVE_CONST_CAST 
#define BZ_HAVE_CONST_CAST   
#endif

/* define if the compiler supports default template parameters */
#ifndef BZ_HAVE_DEFAULT_TEMPLATE_PARAMETERS 
#define BZ_HAVE_DEFAULT_TEMPLATE_PARAMETERS   
#endif

/* Define to 1 if you have the <dlfcn.h> header file. */
#ifndef BZ_HAVE_DLFCN_H 
#define BZ_HAVE_DLFCN_H  1 
#endif

/* define if the compiler supports dynamic_cast<> */
#ifndef BZ_HAVE_DYNAMIC_CAST 
#define BZ_HAVE_DYNAMIC_CAST   
#endif

/* define if the compiler handle computations inside an enum */
#ifndef BZ_HAVE_ENUM_COMPUTATIONS 
#define BZ_HAVE_ENUM_COMPUTATIONS   
#endif

/* define if the compiler handles (int) casts in enum computations */
#ifndef BZ_HAVE_ENUM_COMPUTATIONS_WITH_CAST 
#define BZ_HAVE_ENUM_COMPUTATIONS_WITH_CAST   
#endif

/* define if the compiler supports exceptions */
#ifndef BZ_HAVE_EXCEPTIONS 
#define BZ_HAVE_EXCEPTIONS   
#endif

/* define if the compiler supports the explicit keyword */
#ifndef BZ_HAVE_EXPLICIT 
#define BZ_HAVE_EXPLICIT   
#endif

/* define if the compiler supports explicit template function qualification */
#ifndef BZ_HAVE_EXPLICIT_TEMPLATE_FUNCTION_QUALIFICATION 
#define BZ_HAVE_EXPLICIT_TEMPLATE_FUNCTION_QUALIFICATION   
#endif

/* define if the compiler recognizes the full specialization syntax */
#ifndef BZ_HAVE_FULL_SPECIALIZATION_SYNTAX 
#define BZ_HAVE_FULL_SPECIALIZATION_SYNTAX   
#endif

/* define if the compiler supports function templates with non-type parameters
   */
#ifndef BZ_HAVE_FUNCTION_NONTYPE_PARAMETERS 
#define BZ_HAVE_FUNCTION_NONTYPE_PARAMETERS   
#endif

/* define if the compiler supports IEEE math library */
#ifndef BZ_HAVE_IEEE_MATH 
#define BZ_HAVE_IEEE_MATH   
#endif

/* Define to 1 if you have the <inttypes.h> header file. */
#ifndef BZ_HAVE_INTTYPES_H 
#define BZ_HAVE_INTTYPES_H  1 
#endif

/* Define to 1 if you have the `m' library (-lm). */
/* #undef BZ_HAVE_LIBM */

/* define if the compiler supports member constants */
#ifndef BZ_HAVE_MEMBER_CONSTANTS 
#define BZ_HAVE_MEMBER_CONSTANTS   
#endif

/* define if the compiler supports member templates */
#ifndef BZ_HAVE_MEMBER_TEMPLATES 
#define BZ_HAVE_MEMBER_TEMPLATES   
#endif

/* define if the compiler supports member templates outside the class
   declaration */
#ifndef BZ_HAVE_MEMBER_TEMPLATES_OUTSIDE_CLASS 
#define BZ_HAVE_MEMBER_TEMPLATES_OUTSIDE_CLASS   
#endif

/* Define to 1 if you have the <memory.h> header file. */
#ifndef BZ_HAVE_MEMORY_H 
#define BZ_HAVE_MEMORY_H  1 
#endif

/* define if the compiler supports the mutable keyword */
#ifndef BZ_HAVE_MUTABLE 
#define BZ_HAVE_MUTABLE   
#endif

/* define if the compiler implements namespaces */
#ifndef BZ_HAVE_NAMESPACES 
#define BZ_HAVE_NAMESPACES   
#endif

/* define if the compiler supports the Numerical C Extensions Group restrict
   keyword */
/* #undef BZ_HAVE_NCEG_RESTRICT */

/* define if the compiler supports the __restrict__ keyword */
#ifndef BZ_HAVE_NCEG_RESTRICT_EGCS 
#define BZ_HAVE_NCEG_RESTRICT_EGCS   
#endif

/* define if the compiler has numeric_limits<T> */
#ifndef BZ_HAVE_NUMERIC_LIMITS 
#define BZ_HAVE_NUMERIC_LIMITS   
#endif

/* define if the compiler accepts the old for scoping rules */
/* #undef BZ_HAVE_OLD_FOR_SCOPING */

/* define if the compiler supports partial ordering */
#ifndef BZ_HAVE_PARTIAL_ORDERING 
#define BZ_HAVE_PARTIAL_ORDERING   
#endif

/* define if the compiler supports partial specialization */
#ifndef BZ_HAVE_PARTIAL_SPECIALIZATION 
#define BZ_HAVE_PARTIAL_SPECIALIZATION   
#endif

/* define if the compiler supports reinterpret_cast<> */
#ifndef BZ_HAVE_REINTERPRET_CAST 
#define BZ_HAVE_REINTERPRET_CAST   
#endif

/* define if the compiler supports Run-Time Type Identification */
#ifndef BZ_HAVE_RTTI 
#define BZ_HAVE_RTTI   
#endif

/* define if the compiler has getrusage() function */
#ifndef BZ_HAVE_RUSAGE 
#define BZ_HAVE_RUSAGE   
#endif

/* define if the compiler supports static_cast<> */
#ifndef BZ_HAVE_STATIC_CAST 
#define BZ_HAVE_STATIC_CAST   
#endif

/* define if the compiler supports ISO C++ standard library */
#ifndef BZ_HAVE_STD 
#define BZ_HAVE_STD   
#endif

/* Define to 1 if you have the <stdint.h> header file. */
#ifndef BZ_HAVE_STDINT_H 
#define BZ_HAVE_STDINT_H  1 
#endif

/* Define to 1 if you have the <stdlib.h> header file. */
#ifndef BZ_HAVE_STDLIB_H 
#define BZ_HAVE_STDLIB_H  1 
#endif

/* define if the compiler supports Standard Template Library */
#ifndef BZ_HAVE_STL 
#define BZ_HAVE_STL   
#endif

/* Define to 1 if you have the <strings.h> header file. */
#ifndef BZ_HAVE_STRINGS_H 
#define BZ_HAVE_STRINGS_H  1 
#endif

/* Define to 1 if you have the <string.h> header file. */
#ifndef BZ_HAVE_STRING_H 
#define BZ_HAVE_STRING_H  1 
#endif

/* define if the compiler supports System V math library */
/* #undef BZ_HAVE_SYSTEM_V_MATH */

/* Define to 1 if you have the <sys/stat.h> header file. */
#ifndef BZ_HAVE_SYS_STAT_H 
#define BZ_HAVE_SYS_STAT_H  1 
#endif

/* Define to 1 if you have the <sys/types.h> header file. */
#ifndef BZ_HAVE_SYS_TYPES_H 
#define BZ_HAVE_SYS_TYPES_H  1 
#endif

/* define if the compiler supports basic templates */
#ifndef BZ_HAVE_TEMPLATES 
#define BZ_HAVE_TEMPLATES   
#endif

/* define if the compiler supports templates as template arguments */
#ifndef BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS 
#define BZ_HAVE_TEMPLATES_AS_TEMPLATE_ARGUMENTS   
#endif

/* define if the compiler supports use of the template keyword as a qualifier
   */
#ifndef BZ_HAVE_TEMPLATE_KEYWORD_QUALIFIER 
#define BZ_HAVE_TEMPLATE_KEYWORD_QUALIFIER   
#endif

/* define if the compiler supports template-qualified base class specifiers */
#ifndef BZ_HAVE_TEMPLATE_QUALIFIED_BASE_CLASS 
#define BZ_HAVE_TEMPLATE_QUALIFIED_BASE_CLASS   
#endif

/* define if the compiler supports template-qualified return types */
#ifndef BZ_HAVE_TEMPLATE_QUALIFIED_RETURN_TYPE 
#define BZ_HAVE_TEMPLATE_QUALIFIED_RETURN_TYPE   
#endif

/* define if the compiler supports function matching with argument types which
   are template scope-qualified */
#ifndef BZ_HAVE_TEMPLATE_SCOPED_ARGUMENT_MATCHING 
#define BZ_HAVE_TEMPLATE_SCOPED_ARGUMENT_MATCHING   
#endif

/* define if the compiler recognizes typename */
#ifndef BZ_HAVE_TYPENAME 
#define BZ_HAVE_TYPENAME   
#endif

/* define if the compiler supports the vector type promotion mechanism */
#ifndef BZ_HAVE_TYPE_PROMOTION 
#define BZ_HAVE_TYPE_PROMOTION   
#endif

/* Define to 1 if you have the <unistd.h> header file. */
#ifndef BZ_HAVE_UNISTD_H 
#define BZ_HAVE_UNISTD_H  1 
#endif

/* define if the compiler supports numeric traits promotions */
#ifndef BZ_HAVE_USE_NUMTRAIT 
#define BZ_HAVE_USE_NUMTRAIT   
#endif

/* define if the compiler has valarray<T> */
#ifndef BZ_HAVE_VALARRAY 
#define BZ_HAVE_VALARRAY   
#endif

/* define if the compiler has isnan function in namespace std */
#ifndef BZ_ISNAN_IN_NAMESPACE_STD 
#define BZ_ISNAN_IN_NAMESPACE_STD   
#endif

/* define if the compiler has C math functions in namespace std */
#ifndef BZ_MATH_FN_IN_NAMESPACE_STD 
#define BZ_MATH_FN_IN_NAMESPACE_STD   
#endif

/* Name of package */
#ifndef BZ_PACKAGE 
#define BZ_PACKAGE  "blitz" 
#endif

/* Define to the address where bug reports for this package should be sent. */
#ifndef BZ_PACKAGE_BUGREPORT 
#define BZ_PACKAGE_BUGREPORT  "blitz-bugs@oonumerics.org" 
#endif

/* Define to the full name of this package. */
#ifndef BZ_PACKAGE_NAME 
#define BZ_PACKAGE_NAME  "blitz" 
#endif

/* Define to the full name and version of this package. */
#ifndef BZ_PACKAGE_STRING 
#define BZ_PACKAGE_STRING  "blitz 0.8cvs20050804" 
#endif

/* Define to the one symbol short name of this package. */
#ifndef BZ_PACKAGE_TARNAME 
#define BZ_PACKAGE_TARNAME  "blitz" 
#endif

/* Define to the version of this package. */
#ifndef BZ_PACKAGE_VERSION 
#define BZ_PACKAGE_VERSION  "0.8cvs20050804" 
#endif

/* Define to 1 if you have the ANSI C header files. */
#ifndef BZ_STDC_HEADERS 
#define BZ_STDC_HEADERS  1 
#endif

/* Version number of package */
#ifndef BZ_VERSION 
#define BZ_VERSION  "0.8cvs20050804" 
#endif

/* CXX */
#ifndef BZ__compiler_name 
#define BZ__compiler_name  "c++" 
#endif

/* CXXFLAGS */
#ifndef BZ__compiler_options 
#define BZ__compiler_options  "" 
#endif

/* date */
#ifndef BZ__config_date 
#define BZ__config_date  "Thu Aug  4 17:07:44 EDT 2005" 
#endif

/* uname -a */
#ifndef BZ__os_name 
#define BZ__os_name  "Linux arbutus 2.6.10-9-amd64-k8 #1 Tue Mar 15 01:45:16 CET 2005 x86_64 GNU/Linux" 
#endif

/* target */
#ifndef BZ__platform 
#define BZ__platform  "x86_64-unknown-linux-gnu" 
#endif
 
/* once: _BLITZ_GNU_BZCONFIG_H */
#endif
                                                                                                                                                                         indexexpr.h                                                                                         0100644 0001750 0001750 00000011041 12160377112 042067  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/indexexpr.h     Declaration of the IndexPlaceholder<N> class
 *
 * $Id: indexexpr.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    p://seurat.uhttwaterloo.ca/blitz/
 *
 ***************************************************************************/

#ifndef BZ_INDEXEXPR_H
#define BZ_INDEXEXPR_H

#include <blitz/tinyvec.h>
#include <blitz/prettyprint.h>
#include <blitz/etbase.h>

BZ_NAMESPACE(blitz)

template<int N>
class IndexPlaceholder 
#ifdef BZ_NEW_EXPRESSION_TEMPLATES
  : public ETBase<IndexPlaceholder<N> > 
#endif
{
public:
    IndexPlaceholder()
    { }

#ifdef BZ_NEW_EXPRESSION_TEMPLATES
    IndexPlaceholder(const IndexPlaceholder<N>& x)
        : ETBase< IndexPlaceholder<N> >(x)
    { }
#else
    IndexPlaceholder(const IndexPlaceholder<N>&)
    { }
#endif

    ~IndexPlaceholder()
    { }

    void operator=(const IndexPlaceholder<N>&)
    { }

    typedef int T_numtype;
    typedef int T_ctorArg1;     // Dummy; not used
    typedef int T_ctorArg2;     // Ditto

    static const int 
        numArrayOperands = 0, 
        numIndexPlaceholders = 1,
        rank = N+1;

    // If you have a precondition failure on this routine, it means
    // you are trying to use stack iteration mode on an expression
    // which contains an index placeholder.  You must use index 
    // iteration mode instead.
    int operator*() { 
        BZPRECONDITION(0); 
        return 0;
    }

#ifdef BZ_ARRAY_EXPR_PASS_INDEX_BY_VALUE
    template<int N_rank>
    T_numtype operator()(TinyVector<int, N_rank> i) { return i[N]; }
#else
    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i) { return i[N]; }
#endif

    int ascending(int) const { return INT_MIN; }
    int ordering(int)  const { return INT_MIN; }
    int lbound(int)    const { return INT_MIN; }  // tiny(int());
    int ubound(int)    const { return INT_MAX; }  // huge(int()); 

    // See operator*() note

    void push(int)       { BZPRECONDITION(0); }
    void pop(int)        { BZPRECONDITION(0); }
    void advance()       { BZPRECONDITION(0); }
    void advance(int)    { BZPRECONDITION(0); }
    void loadStride(int) { BZPRECONDITION(0); }

    bool isUnitStride(int) const { 
        BZPRECONDITION(0);
        return false;
    }

    void advanceUnitStride() { BZPRECONDITION(0); }

    bool canCollapse(int,int) const {   
        BZPRECONDITION(0); 
        return false; 
    }

    T_numtype operator[](int) {
        BZPRECONDITION(0);
        return T_numtype();
    }

    T_numtype fastRead(int) {
        BZPRECONDITION(0);
        return T_numtype();
    }

    int suggestStride(int) const {
        BZPRECONDITION(0);
        return 0;
    }

    bool isStride(int,int) const {
        BZPRECONDITION(0);
        return true;
    }

    void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat&) const {
        // NEEDS_WORK-- do real formatting for reductions
        str += "index-expr[NEEDS_WORK]";
    }

    template<typename T_shape>
    bool shapeCheck(const T_shape&) const { return true; }
};

typedef IndexPlaceholder<0> firstIndex;
typedef IndexPlaceholder<1> secondIndex;
typedef IndexPlaceholder<2> thirdIndex;
typedef IndexPlaceholder<3> fourthIndex;
typedef IndexPlaceholder<4> fifthIndex;
typedef IndexPlaceholder<5> sixthIndex;
typedef IndexPlaceholder<6> seventhIndex;
typedef IndexPlaceholder<7> eighthIndex;
typedef IndexPlaceholder<8> ninthIndex;
typedef IndexPlaceholder<9> tenthIndex;
typedef IndexPlaceholder<10> eleventhIndex;

#ifndef BZ_NO_TENSOR_INDEX_OBJECTS

BZ_NAMESPACE(tensor)
    _bz_global blitz::IndexPlaceholder<0> i;
    _bz_global blitz::IndexPlaceholder<1> j;
    _bz_global blitz::IndexPlaceholder<2> k;
    _bz_global blitz::IndexPlaceholder<3> l;
    _bz_global blitz::IndexPlaceholder<4> m;
    _bz_global blitz::IndexPlaceholder<5> n;
    _bz_global blitz::IndexPlaceholder<6> o;
    _bz_global blitz::IndexPlaceholder<7> p;
    _bz_global blitz::IndexPlaceholder<8> q;
    _bz_global blitz::IndexPlaceholder<9> r;
    _bz_global blitz::IndexPlaceholder<10> s;
    _bz_global blitz::IndexPlaceholder<11> t;
BZ_NAMESPACE_END // tensor

#endif

BZ_NAMESPACE_END

#endif // BZ_INDEXEXPR_H

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               limits-hack.h                                                                                       0100644 0001750 0001750 00000033525 12160377112 042301  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /*
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/* NOTE: This is not portable code.  Parts of numeric_limits<> are
 * inherently machine-dependent, and this file is written for the MIPS
 * architecture and the SGI MIPSpro C++ compiler.  Parts of it (in
 * particular, some of the characteristics of floating-point types)
 * are almost certainly incorrect for any other platform.
 */

#include <blitz/wrap-climits.h> 
#include <float.h>

BZ_NAMESPACE(std)

enum float_round_style {
  round_indeterminate       = -1,
  round_toward_zero         =  0,
  round_to_nearest          =  1,
  round_toward_infinity     =  2,
  round_toward_neg_infinity =  3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent        =  0,
  denorm_present       =  1
};

// Base class for all specializations of numeric_limits.

template <typename __number>
class _Numeric_limits_base {
public:
  static const bool is_specialized = false;

  static __number min()  { return __number(); }
  static __number max()  { return __number(); }

  static const int digits   = 0;
  static const int digits10 = 0;

  static const bool is_signed  = false;
  static const bool is_integer = false;
  static const bool is_exact   = false;

  static const int radix = 0;

  static __number epsilon()      { return __number(); }
  static __number round_error()  { return __number(); }

  static const int min_exponent   = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent   = 0;
  static const int max_exponent10 = 0;

  static const bool has_infinity      = false;
  static const bool has_quiet_NaN     = false;
  static const bool has_signaling_NaN = false;
  static const float_denorm_style has_denorm = denorm_absent;
  static const bool has_denorm_loss   = false;

  static __number infinity()       { return __number(); }
  static __number quiet_NaN()      { return __number(); }
  static __number signaling_NaN()  { return __number(); }
  static __number denorm_min()     { return __number(); }

  static const bool is_iec559  = false;
  static const bool is_bounded = false;
  static const bool is_modulo  = false;

  static const bool traps           = false;
  static const bool tinyness_before = false;
  static const float_round_style round_style = round_toward_zero;
};

#define __declare_numeric_base_member(__type, __mem) \
template <typename __number> \
  const __type _Numeric_limits_base<__number>:: __mem

__declare_numeric_base_member(bool, is_specialized);
__declare_numeric_base_member(int, digits);
__declare_numeric_base_member(int, digits10);
__declare_numeric_base_member(bool, is_signed);
__declare_numeric_base_member(bool, is_integer);
__declare_numeric_base_member(bool, is_exact);
__declare_numeric_base_member(int, radix);
__declare_numeric_base_member(int, min_exponent);
__declare_numeric_base_member(int, max_exponent);
__declare_numeric_base_member(int, min_exponent10);
__declare_numeric_base_member(int, max_exponent10);
__declare_numeric_base_member(bool, has_infinity);
__declare_numeric_base_member(bool, has_quiet_NaN);
__declare_numeric_base_member(bool, has_signaling_NaN);
__declare_numeric_base_member(float_denorm_style, has_denorm);
__declare_numeric_base_member(bool, has_denorm_loss);
__declare_numeric_base_member(bool, is_iec559);
__declare_numeric_base_member(bool, is_bounded);
__declare_numeric_base_member(bool, is_modulo);
__declare_numeric_base_member(bool, traps);
__declare_numeric_base_member(bool, tinyness_before);
__declare_numeric_base_member(float_round_style, round_style);

#undef __declare_numeric_base_member

// Base class for integers.

template <typename _Int,
          _Int __imin,
          _Int __imax,
          int __idigits = -1>
class _Integer_limits : public _Numeric_limits_base<_Int> {
public:
  static const bool is_specialized = true;

  static _Int min()  { return __imin; }
  static _Int max()  { return __imax; }

  static const int digits = 
    (__idigits < 0) ? sizeof(_Int) * CHAR_BIT - (__imin == 0 ? 0 : 1) 
                    : __idigits;
  static const int digits10 = (digits * 301) / 1000; 
                                // log 2 = 0.301029995664...

  static const bool is_signed = __imin != 0;
  static const bool is_integer = true;
  static const bool is_exact = true;
  static const int radix = 2;


  static const bool is_bounded = true;
  static const bool is_modulo = true;
};

#define __declare_integer_limits_member(__type, __mem) \
template <typename _Int, _Int __imin, _Int __imax, int __idigits> \
  const __type _Integer_limits<_Int, __imin, __imax, __idigits>:: __mem

__declare_integer_limits_member(bool, is_specialized);
__declare_integer_limits_member(int, digits);
__declare_integer_limits_member(int, digits10);
__declare_integer_limits_member(bool, is_signed);
__declare_integer_limits_member(bool, is_integer);
__declare_integer_limits_member(bool, is_exact);
__declare_integer_limits_member(int, radix);
__declare_integer_limits_member(bool, is_bounded);
__declare_integer_limits_member(bool, is_modulo);

#undef __declare_integer_limits_member

// Base class for floating-point numbers.
template <typename __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         unsigned int __InfinityWord,
         unsigned int __QNaNWord, unsigned int __SNaNWord,
         bool __IsIEC559,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number>
{
public:
  static const bool is_specialized = true;

  static const int digits   = __Digits;
  static const int digits10 = __Digits10;

  static const bool is_signed = true;

  static const int radix = 2;

  static const int min_exponent   = __MinExp;
  static const int max_exponent   = __MaxExp;
  static const int min_exponent10 = __MinExp10;
  static const int max_exponent10 = __MaxExp10;

  static const bool has_infinity      = true;
  static const bool has_quiet_NaN     = true;
  static const bool has_signaling_NaN = true;
  static const float_denorm_style has_denorm = denorm_indeterminate;
  static const bool has_denorm_loss   = false;

  static __number infinity()  {
    static unsigned int _S_inf[sizeof(__number) / sizeof(int)] = 
      { __InfinityWord };
    return *reinterpret_cast<__number*>(&_S_inf);
  }
  static __number quiet_NaN()  {
    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = 
      { __QNaNWord };
    return *reinterpret_cast<__number*>(&_S_nan);
  }
  static __number signaling_NaN()  {
    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = 
      { __SNaNWord };
    return *reinterpret_cast<__number*>(&_S_nan);
  }

  static const bool is_iec559       = __IsIEC559;
  static const bool is_bounded      = true;
  static const bool traps           = true;
  static const bool tinyness_before = false;

  static const float_round_style round_style = __RoundStyle;
};

#define __declare_float_limits_member(__type, __mem) \
template <typename __Num, int __Dig, int __Dig10, \
          int __MnX, int __MxX, int __MnX10, int __MxX10, \
          unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, \
          bool __IsIEEE, float_round_style __Sty> \
const __type _Floating_limits<__Num, __Dig, __Dig10, \
                              __MnX, __MxX, __MnX10, __MxX10, \
                              __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>:: __mem

__declare_float_limits_member(bool, is_specialized);  
__declare_float_limits_member(int, digits);  
__declare_float_limits_member(int, digits10);  
__declare_float_limits_member(bool, is_signed);  
__declare_float_limits_member(int, radix);  
__declare_float_limits_member(int, min_exponent);  
__declare_float_limits_member(int, max_exponent);  
__declare_float_limits_member(int, min_exponent10);  
__declare_float_limits_member(int, max_exponent10);  
__declare_float_limits_member(bool, has_infinity);
__declare_float_limits_member(bool, has_quiet_NaN);
__declare_float_limits_member(bool, has_signaling_NaN);
__declare_float_limits_member(float_denorm_style, has_denorm);
__declare_float_limits_member(bool, has_denorm_loss);
__declare_float_limits_member(bool, is_iec559);
__declare_float_limits_member(bool, is_bounded);
__declare_float_limits_member(bool, traps);
__declare_float_limits_member(bool, tinyness_before);
__declare_float_limits_member(float_round_style, round_style);

#undef __declare_float_limits_member

// Class numeric_limits

// The unspecialized class.

template<typename T> 
class numeric_limits : public _Numeric_limits_base<T> {};

// Specializations for all built-in integral types.

#ifndef __STL_NO_BOOL

template<>
class numeric_limits<bool>
  : public _Integer_limits<bool, false, true, 0> {};

#endif /* __STL_NO_BOOL */

template<>
class numeric_limits<char>
  : public _Integer_limits<char, CHAR_MIN, CHAR_MAX> {};

template<>
class numeric_limits<signed char>
  : public _Integer_limits<signed char, SCHAR_MIN, SCHAR_MAX> {};

template<>
class numeric_limits<unsigned char>
  : public _Integer_limits<unsigned char, 0, UCHAR_MAX> {};

#ifdef __STL_HAS_WCHAR_T

template<>
class numeric_limits<wchar_t>
  : public _Integer_limits<wchar_t, INT_MIN, INT_MAX> {};

#endif

template<>
class numeric_limits<short>
  : public _Integer_limits<short, SHRT_MIN, SHRT_MAX> {};

template<>
class numeric_limits<unsigned short>
  : public _Integer_limits<unsigned short, 0, USHRT_MAX> {};

template<>
class numeric_limits<int>
  : public _Integer_limits<int, INT_MIN, INT_MAX> {};

template<>
class numeric_limits<unsigned int>
  : public _Integer_limits<unsigned int, 0, UINT_MAX> {};

template<>
class numeric_limits<long>
  : public _Integer_limits<long, LONG_MIN, LONG_MAX> {};

template<>
class numeric_limits<unsigned long>
  : public _Integer_limits<unsigned long, 0, ULONG_MAX> {};

#ifdef __STL_LONG_LONG
#ifdef LONG_LONG_MIN

// CYGNUS LOCAL 9/4/1998
// fixed LONGLONG to be LONG_LONG
template<>
class numeric_limits<long long>
  : public _Integer_limits<long long, LONG_LONG_MIN, LONG_LONG_MAX> {};

// CYGNUS LOCAL 9/4/1998
// fixed LONGLONG to be LONG_LONG
template<>
class numeric_limits<unsigned long long>
  : public _Integer_limits<unsigned long long, 0, ULONG_LONG_MAX> {};

#endif
#endif /* __STL_LONG_LONG */

// Specializations for all built-in floating-point type.

template<> class numeric_limits<float>
  : public _Floating_limits<float, 
                            FLT_MANT_DIG,   // Binary digits of precision
                            FLT_DIG,        // Decimal digits of precision
                            FLT_MIN_EXP,    // Minimum exponent
                            FLT_MAX_EXP,    // Maximum exponent
                            FLT_MIN_10_EXP, // Minimum base 10 exponent
                            FLT_MAX_10_EXP, // Maximum base 10 exponent
                            0x7f800000u,    // First word of +infinity
                            0x7f810000u,    // First word of quiet NaN
                            0x7fc10000u,    // First word of signaling NaN
                            true,           // conforms to iec559
                            round_to_nearest>
{
public:
  static float min()  { return FLT_MIN; }
  static float denorm_min()  { return FLT_MIN; }
  static float max()  { return FLT_MAX; }
  static float epsilon()  { return FLT_EPSILON; }
  static float round_error()  { return 0.5f; } // Units: ulps.
};

template<> class numeric_limits<double>
  : public _Floating_limits<double, 
                            DBL_MANT_DIG,   // Binary digits of precision
                            DBL_DIG,        // Decimal digits of precision
                            DBL_MIN_EXP,    // Minimum exponent
                            DBL_MAX_EXP,    // Maximum exponent
                            DBL_MIN_10_EXP, // Minimum base 10 exponent
                            DBL_MAX_10_EXP, // Maximum base 10 exponent
                            0x7ff00000u,    // First word of +infinity
                            0x7ff10000u,    // First word of quiet NaN
                            0x7ff90000u,    // First word of signaling NaN
                            true,           // conforms to iec559
                            round_to_nearest>
{
public:
  static double min()  { return DBL_MIN; }
  static double denorm_min()  { return DBL_MIN; }
  static double max()  { return DBL_MAX; }
  static double epsilon()  { return DBL_EPSILON; }
  static double round_error()  { return 0.5; } // Units: ulps.
};

template<> class numeric_limits<long double>
  : public _Floating_limits<long double, 
                            LDBL_MANT_DIG,  // Binary digits of precision
                            LDBL_DIG,       // Decimal digits of precision
                            LDBL_MIN_EXP,   // Minimum exponent
                            LDBL_MAX_EXP,   // Maximum exponent
                            LDBL_MIN_10_EXP,// Minimum base 10 exponent
                            LDBL_MAX_10_EXP,// Maximum base 10 exponent
                            0x7ff00000u,    // First word of +infinity
                            0x7ff10000u,    // First word of quiet NaN
                            0x7ff90000u,    // First word of signaling NaN
                            false,          // Doesn't conform to iec559
                            round_to_nearest>
{
public:
  static long double min()  { return LDBL_MIN; }
  static long double denorm_min()  { return LDBL_MIN; }
  static long double max()  { return LDBL_MAX; }
  static long double epsilon()  { return LDBL_EPSILON; }
  static long double round_error()  { return 4; } // Units: ulps.
};

BZ_NAMESPACE_END

                                                                                                                                                                           listinit.h                                                                                          0100644 0001750 0001750 00000004732 12160377112 041731  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/listinit.h      Classes for initialization lists
 *
 * $Id: listinit.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

/*
 * Initialization lists provide a convenient way to set the elements
 * of an array.  For example,
 *
 * Array<int,2> A(3,3);
 * A = 1, 0, 0,
 *     0, 1, 0,
 *     0, 0, 1;
 */

#ifndef BZ_LISTINIT_H
#define BZ_LISTINIT_H

BZ_NAMESPACE(blitz)

template<typename T_numtype, typename T_iterator>
class ListInitializer {

public:
    ListInitializer(T_iterator iter)
        : iter_(iter)
    {
    }

    ListInitializer<T_numtype, T_iterator> operator,(T_numtype x)
    {
        *iter_ = x;
        return ListInitializer<T_numtype, T_iterator>(iter_ + 1);
    }

private:
    ListInitializer();

protected:
    T_iterator iter_;
};

template<typename T_array, typename T_iterator = _bz_typename T_array::T_numtype*>
class ListInitializationSwitch {

public:
    typedef _bz_typename T_array::T_numtype T_numtype;

    ListInitializationSwitch(const ListInitializationSwitch<T_array>& lis)
        : array_(lis.array_), value_(lis.value_), 
          wipeOnDestruct_(true)
    {
        lis.disable();
    }

    ListInitializationSwitch(T_array& array, T_numtype value)
        : array_(array), value_(value), wipeOnDestruct_(true)
    { }

    ~ListInitializationSwitch()
    {
        if (wipeOnDestruct_)
            array_.initialize(value_);
    }

    ListInitializer<T_numtype, T_iterator> operator,(T_numtype x)
    {
        wipeOnDestruct_ = false;
        T_iterator iter = array_.getInitializationIterator();
        *iter = value_;
        T_iterator iter2 = iter + 1;
        *iter2 = x;
        return ListInitializer<T_numtype, T_iterator>(iter2 + 1);
    }

    void disable() const
    {
        wipeOnDestruct_ = false;
    }

private:
    ListInitializationSwitch();

protected:
    T_array& array_;
    T_numtype value_;
    mutable bool wipeOnDestruct_;
};

BZ_NAMESPACE_END

#endif // BZ_LISTINIT_H

                                      matbops.h                                                                                           0100644 0001750 0001750 00000545075 12160377112 041551  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // Generated source file.  Do not edit.
// Created by: genmatbops.cpp Dec 10 2003 17:58:20

#ifndef BZ_MATBOPS_H
#define BZ_MATBOPS_H

BZ_NAMESPACE(blitz)

#ifndef BZ_MATEXPR_H
 #error <blitz/matbops.h> must be included via <blitz/matexpr.h>
#endif

/****************************************************************************
 * Addition Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> + Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> + _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<P_numtype1, typename P_expr2::T_numtype > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> + int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Add<P_numtype1, int > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> + float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Add<P_numtype1, float > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Add<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> + double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Add<P_numtype1, double > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Add<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> + long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Add<P_numtype1, long double > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Add<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> + complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Add<P_numtype1, complex<T2>  > > >
operator+(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Add<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> + Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<typename P_expr1::T_numtype, P_numtype2 > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> + _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> + int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Add<typename P_expr1::T_numtype, int > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Add<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> + float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Add<typename P_expr1::T_numtype, float > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Add<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> + double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Add<typename P_expr1::T_numtype, double > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Add<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> + long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Add<typename P_expr1::T_numtype, long double > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Add<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> + complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Add<typename P_expr1::T_numtype, complex<T2>  > > >
operator+(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Add<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int + Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<int, P_numtype2 > > >
operator+(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int + _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<int, typename P_expr2::T_numtype > > >
operator+(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float + Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<float, P_numtype2 > > >
operator+(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float + _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<float, typename P_expr2::T_numtype > > >
operator+(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double + Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<double, P_numtype2 > > >
operator+(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double + _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<double, typename P_expr2::T_numtype > > >
operator+(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double + Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<long double, P_numtype2 > > >
operator+(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double + _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Add<long double, typename P_expr2::T_numtype > > >
operator+(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> + Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Add<complex<T1> , P_numtype2 > > >
operator+(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Add<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> + _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Add<complex<T1> , typename P_expr2::T_numtype > > >
operator+(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Add<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Subtraction Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> - Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> - _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<P_numtype1, typename P_expr2::T_numtype > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> - int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Subtract<P_numtype1, int > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> - float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Subtract<P_numtype1, float > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Subtract<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> - double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Subtract<P_numtype1, double > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Subtract<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> - long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Subtract<P_numtype1, long double > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Subtract<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> - complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Subtract<P_numtype1, complex<T2>  > > >
operator-(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Subtract<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> - Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<typename P_expr1::T_numtype, P_numtype2 > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> - _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> - int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Subtract<typename P_expr1::T_numtype, int > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Subtract<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> - float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Subtract<typename P_expr1::T_numtype, float > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Subtract<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> - double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Subtract<typename P_expr1::T_numtype, double > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Subtract<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> - long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Subtract<typename P_expr1::T_numtype, long double > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Subtract<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> - complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Subtract<typename P_expr1::T_numtype, complex<T2>  > > >
operator-(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Subtract<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int - Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int - _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<int, typename P_expr2::T_numtype > > >
operator-(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float - Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<float, P_numtype2 > > >
operator-(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float - _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<float, typename P_expr2::T_numtype > > >
operator-(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double - Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<double, P_numtype2 > > >
operator-(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double - _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<double, typename P_expr2::T_numtype > > >
operator-(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double - Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<long double, P_numtype2 > > >
operator-(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double - _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<long double, typename P_expr2::T_numtype > > >
operator-(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> - Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Subtract<complex<T1> , P_numtype2 > > >
operator-(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Subtract<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> - _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Subtract<complex<T1> , typename P_expr2::T_numtype > > >
operator-(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Subtract<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Multiplication Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> * Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> * _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<P_numtype1, typename P_expr2::T_numtype > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> * int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Multiply<P_numtype1, int > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> * float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Multiply<P_numtype1, float > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Multiply<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> * double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Multiply<P_numtype1, double > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Multiply<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> * long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Multiply<P_numtype1, long double > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Multiply<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> * complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Multiply<P_numtype1, complex<T2>  > > >
operator*(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Multiply<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> * Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<typename P_expr1::T_numtype, P_numtype2 > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> * _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> * int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Multiply<typename P_expr1::T_numtype, int > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Multiply<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> * float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Multiply<typename P_expr1::T_numtype, float > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Multiply<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> * double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Multiply<typename P_expr1::T_numtype, double > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Multiply<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> * long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Multiply<typename P_expr1::T_numtype, long double > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Multiply<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> * complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Multiply<typename P_expr1::T_numtype, complex<T2>  > > >
operator*(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Multiply<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int * Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int * _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<int, typename P_expr2::T_numtype > > >
operator*(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float * Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<float, P_numtype2 > > >
operator*(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float * _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<float, typename P_expr2::T_numtype > > >
operator*(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double * Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<double, P_numtype2 > > >
operator*(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double * _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<double, typename P_expr2::T_numtype > > >
operator*(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double * Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<long double, P_numtype2 > > >
operator*(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double * _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<long double, typename P_expr2::T_numtype > > >
operator*(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> * Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Multiply<complex<T1> , P_numtype2 > > >
operator*(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Multiply<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> * _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Multiply<complex<T1> , typename P_expr2::T_numtype > > >
operator*(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Multiply<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Division Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> / Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> / _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<P_numtype1, typename P_expr2::T_numtype > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> / int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Divide<P_numtype1, int > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> / float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Divide<P_numtype1, float > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Divide<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> / double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Divide<P_numtype1, double > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Divide<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> / long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Divide<P_numtype1, long double > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Divide<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> / complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Divide<P_numtype1, complex<T2>  > > >
operator/(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Divide<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> / Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<typename P_expr1::T_numtype, P_numtype2 > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> / _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> / int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Divide<typename P_expr1::T_numtype, int > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Divide<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> / float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Divide<typename P_expr1::T_numtype, float > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Divide<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> / double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Divide<typename P_expr1::T_numtype, double > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Divide<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> / long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Divide<typename P_expr1::T_numtype, long double > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Divide<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> / complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Divide<typename P_expr1::T_numtype, complex<T2>  > > >
operator/(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Divide<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int / Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int / _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<int, typename P_expr2::T_numtype > > >
operator/(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float / Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<float, P_numtype2 > > >
operator/(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float / _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<float, typename P_expr2::T_numtype > > >
operator/(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double / Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<double, P_numtype2 > > >
operator/(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double / _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<double, typename P_expr2::T_numtype > > >
operator/(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double / Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<long double, P_numtype2 > > >
operator/(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double / _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<long double, typename P_expr2::T_numtype > > >
operator/(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> / Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Divide<complex<T1> , P_numtype2 > > >
operator/(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Divide<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> / _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Divide<complex<T1> , typename P_expr2::T_numtype > > >
operator/(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Divide<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Modulus Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> % Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> % _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Mod<P_numtype1, typename P_expr2::T_numtype > > >
operator%(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Mod<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> % int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Mod<P_numtype1, int > > >
operator%(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> % Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Mod<typename P_expr1::T_numtype, P_numtype2 > > >
operator%(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Mod<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> % _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Mod<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator%(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Mod<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> % int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Mod<typename P_expr1::T_numtype, int > > >
operator%(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Mod<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int % Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int % _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Mod<int, typename P_expr2::T_numtype > > >
operator%(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Mod<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Bitwise XOR Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> ^ Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> ^ _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseXOR<P_numtype1, typename P_expr2::T_numtype > > >
operator^(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseXOR<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> ^ int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> ^ Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseXOR<typename P_expr1::T_numtype, P_numtype2 > > >
operator^(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseXOR<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> ^ _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseXOR<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator^(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseXOR<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> ^ int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseXOR<typename P_expr1::T_numtype, int > > >
operator^(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseXOR<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int ^ Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int ^ _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseXOR<int, typename P_expr2::T_numtype > > >
operator^(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseXOR<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Bitwise And Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> & Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> & _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseAnd<P_numtype1, typename P_expr2::T_numtype > > >
operator&(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseAnd<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> & int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> & Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseAnd<typename P_expr1::T_numtype, P_numtype2 > > >
operator&(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseAnd<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> & _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseAnd<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator&(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseAnd<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> & int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseAnd<typename P_expr1::T_numtype, int > > >
operator&(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseAnd<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int & Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int & _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseAnd<int, typename P_expr2::T_numtype > > >
operator&(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseAnd<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Bitwise Or Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> | Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> | _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseOr<P_numtype1, typename P_expr2::T_numtype > > >
operator|(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseOr<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> | int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> | Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseOr<typename P_expr1::T_numtype, P_numtype2 > > >
operator|(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseOr<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> | _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseOr<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator|(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseOr<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> | int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_BitwiseOr<typename P_expr1::T_numtype, int > > >
operator|(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_BitwiseOr<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int | Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int | _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_BitwiseOr<int, typename P_expr2::T_numtype > > >
operator|(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_BitwiseOr<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Shift right Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> >> Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> >> _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftRight<P_numtype1, typename P_expr2::T_numtype > > >
operator>>(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftRight<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> >> int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> >> Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftRight<typename P_expr1::T_numtype, P_numtype2 > > >
operator>>(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftRight<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> >> _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftRight<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator>>(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftRight<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> >> int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_ShiftRight<typename P_expr1::T_numtype, int > > >
operator>>(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_ShiftRight<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int >> Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int >> _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftRight<int, typename P_expr2::T_numtype > > >
operator>>(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftRight<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Shift left Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> << Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> << _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftLeft<P_numtype1, typename P_expr2::T_numtype > > >
operator<<(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftLeft<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> << int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> << Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftLeft<typename P_expr1::T_numtype, P_numtype2 > > >
operator<<(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftLeft<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> << _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftLeft<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator<<(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftLeft<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> << int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_ShiftLeft<typename P_expr1::T_numtype, int > > >
operator<<(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_ShiftLeft<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int << Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int << _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_ShiftLeft<int, typename P_expr2::T_numtype > > >
operator<<(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_ShiftLeft<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Greater-than Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> > Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> > _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<P_numtype1, typename P_expr2::T_numtype > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> > int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Greater<P_numtype1, int > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> > float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Greater<P_numtype1, float > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Greater<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> > double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Greater<P_numtype1, double > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Greater<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> > long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Greater<P_numtype1, long double > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Greater<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> > complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Greater<P_numtype1, complex<T2>  > > >
operator>(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Greater<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> > Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<typename P_expr1::T_numtype, P_numtype2 > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> > _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> > int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Greater<typename P_expr1::T_numtype, int > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Greater<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> > float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Greater<typename P_expr1::T_numtype, float > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Greater<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> > double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Greater<typename P_expr1::T_numtype, double > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Greater<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> > long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Greater<typename P_expr1::T_numtype, long double > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Greater<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> > complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Greater<typename P_expr1::T_numtype, complex<T2>  > > >
operator>(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Greater<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int > Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int > _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<int, typename P_expr2::T_numtype > > >
operator>(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float > Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<float, P_numtype2 > > >
operator>(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float > _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<float, typename P_expr2::T_numtype > > >
operator>(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double > Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<double, P_numtype2 > > >
operator>(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double > _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<double, typename P_expr2::T_numtype > > >
operator>(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double > Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<long double, P_numtype2 > > >
operator>(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double > _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<long double, typename P_expr2::T_numtype > > >
operator>(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> > Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Greater<complex<T1> , P_numtype2 > > >
operator>(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Greater<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> > _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Greater<complex<T1> , typename P_expr2::T_numtype > > >
operator>(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Greater<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Less-than Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> < Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> < _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<P_numtype1, typename P_expr2::T_numtype > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> < int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Less<P_numtype1, int > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> < float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Less<P_numtype1, float > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Less<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> < double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Less<P_numtype1, double > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Less<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> < long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Less<P_numtype1, long double > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Less<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> < complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Less<P_numtype1, complex<T2>  > > >
operator<(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Less<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> < Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<typename P_expr1::T_numtype, P_numtype2 > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> < _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> < int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Less<typename P_expr1::T_numtype, int > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Less<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> < float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Less<typename P_expr1::T_numtype, float > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Less<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> < double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Less<typename P_expr1::T_numtype, double > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Less<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> < long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Less<typename P_expr1::T_numtype, long double > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Less<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> < complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Less<typename P_expr1::T_numtype, complex<T2>  > > >
operator<(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Less<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int < Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<int, P_numtype2 > > >
operator<(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int < _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<int, typename P_expr2::T_numtype > > >
operator<(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float < Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<float, P_numtype2 > > >
operator<(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float < _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<float, typename P_expr2::T_numtype > > >
operator<(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double < Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<double, P_numtype2 > > >
operator<(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double < _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<double, typename P_expr2::T_numtype > > >
operator<(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double < Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<long double, P_numtype2 > > >
operator<(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double < _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Less<long double, typename P_expr2::T_numtype > > >
operator<(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> < Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Less<complex<T1> , P_numtype2 > > >
operator<(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Less<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> < _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Less<complex<T1> , typename P_expr2::T_numtype > > >
operator<(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Less<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Greater or equal (>=) operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> >= Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> >= _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<P_numtype1, typename P_expr2::T_numtype > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> >= int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> >= float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_GreaterOrEqual<P_numtype1, float > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_GreaterOrEqual<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> >= double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_GreaterOrEqual<P_numtype1, double > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_GreaterOrEqual<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> >= long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_GreaterOrEqual<P_numtype1, long double > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_GreaterOrEqual<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> >= complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<P_numtype1, complex<T2>  > > >
operator>=(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> >= Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, P_numtype2 > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> >= _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> >= int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, int > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> >= float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, float > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> >= double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, double > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> >= long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, long double > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> >= complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, complex<T2>  > > >
operator>=(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int >= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int >= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<int, typename P_expr2::T_numtype > > >
operator>=(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float >= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<float, P_numtype2 > > >
operator>=(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float >= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<float, typename P_expr2::T_numtype > > >
operator>=(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double >= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<double, P_numtype2 > > >
operator>=(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double >= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<double, typename P_expr2::T_numtype > > >
operator>=(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double >= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<long double, P_numtype2 > > >
operator>=(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double >= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<long double, typename P_expr2::T_numtype > > >
operator>=(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> >= Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_GreaterOrEqual<complex<T1> , P_numtype2 > > >
operator>=(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_GreaterOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> >= _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_GreaterOrEqual<complex<T1> , typename P_expr2::T_numtype > > >
operator>=(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_GreaterOrEqual<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Less or equal (<=) operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> <= Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> <= _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<P_numtype1, typename P_expr2::T_numtype > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> <= int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> <= float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_LessOrEqual<P_numtype1, float > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_LessOrEqual<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> <= double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_LessOrEqual<P_numtype1, double > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_LessOrEqual<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> <= long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_LessOrEqual<P_numtype1, long double > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_LessOrEqual<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> <= complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_LessOrEqual<P_numtype1, complex<T2>  > > >
operator<=(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_LessOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> <= Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, P_numtype2 > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> <= _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> <= int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, int > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> <= float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, float > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> <= double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, double > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> <= long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_LessOrEqual<typename P_expr1::T_numtype, long double > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_LessOrEqual<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> <= complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_LessOrEqual<typename P_expr1::T_numtype, complex<T2>  > > >
operator<=(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_LessOrEqual<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int <= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int <= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<int, typename P_expr2::T_numtype > > >
operator<=(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float <= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<float, P_numtype2 > > >
operator<=(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float <= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<float, typename P_expr2::T_numtype > > >
operator<=(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double <= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<double, P_numtype2 > > >
operator<=(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double <= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<double, typename P_expr2::T_numtype > > >
operator<=(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double <= Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<long double, P_numtype2 > > >
operator<=(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double <= _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<long double, typename P_expr2::T_numtype > > >
operator<=(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> <= Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LessOrEqual<complex<T1> , P_numtype2 > > >
operator<=(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LessOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> <= _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_LessOrEqual<complex<T1> , typename P_expr2::T_numtype > > >
operator<=(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_LessOrEqual<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Equality operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> == Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> == _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<P_numtype1, typename P_expr2::T_numtype > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> == int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Equal<P_numtype1, int > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> == float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_Equal<P_numtype1, float > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_Equal<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> == double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_Equal<P_numtype1, double > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_Equal<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> == long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_Equal<P_numtype1, long double > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Equal<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> == complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Equal<P_numtype1, complex<T2>  > > >
operator==(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Equal<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> == Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<typename P_expr1::T_numtype, P_numtype2 > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> == _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> == int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Equal<typename P_expr1::T_numtype, int > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Equal<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> == float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_Equal<typename P_expr1::T_numtype, float > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_Equal<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> == double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_Equal<typename P_expr1::T_numtype, double > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_Equal<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> == long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_Equal<typename P_expr1::T_numtype, long double > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_Equal<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> == complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_Equal<typename P_expr1::T_numtype, complex<T2>  > > >
operator==(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_Equal<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int == Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int == _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<int, typename P_expr2::T_numtype > > >
operator==(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float == Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<float, P_numtype2 > > >
operator==(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float == _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<float, typename P_expr2::T_numtype > > >
operator==(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double == Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<double, P_numtype2 > > >
operator==(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double == _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<double, typename P_expr2::T_numtype > > >
operator==(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double == Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<long double, P_numtype2 > > >
operator==(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double == _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<long double, typename P_expr2::T_numtype > > >
operator==(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> == Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Equal<complex<T1> , P_numtype2 > > >
operator==(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Equal<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> == _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_Equal<complex<T1> , typename P_expr2::T_numtype > > >
operator==(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_Equal<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Not-equal operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> != Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> != _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<P_numtype1, typename P_expr2::T_numtype > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> != int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// Matrix<P_numtype1, P_struct1> != float
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>,
      _bz_NotEqual<P_numtype1, float > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<float>, 
      _bz_NotEqual<P_numtype1, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<float>(d2)));
}

// Matrix<P_numtype1, P_struct1> != double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>,
      _bz_NotEqual<P_numtype1, double > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<double>, 
      _bz_NotEqual<P_numtype1, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<double>(d2)));
}

// Matrix<P_numtype1, P_struct1> != long double
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>,
      _bz_NotEqual<P_numtype1, long double > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<long double>, 
      _bz_NotEqual<P_numtype1, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// Matrix<P_numtype1, P_struct1> != complex<T2>
template<class P_numtype1, class P_struct1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_NotEqual<P_numtype1, complex<T2>  > > >
operator!=(const Matrix<P_numtype1, P_struct1>& d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_NotEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// _bz_MatExpr<P_expr1> != Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<typename P_expr1::T_numtype, P_numtype2 > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> != _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> != int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_NotEqual<typename P_expr1::T_numtype, int > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_NotEqual<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> != float
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>,
      _bz_NotEqual<typename P_expr1::T_numtype, float > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<float>, 
      _bz_NotEqual<typename P_expr1::T_numtype, float> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<float>(d2)));
}

// _bz_MatExpr<P_expr1> != double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>,
      _bz_NotEqual<typename P_expr1::T_numtype, double > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<double>, 
      _bz_NotEqual<typename P_expr1::T_numtype, double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<double>(d2)));
}

// _bz_MatExpr<P_expr1> != long double
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>,
      _bz_NotEqual<typename P_expr1::T_numtype, long double > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<long double>, 
      _bz_NotEqual<typename P_expr1::T_numtype, long double> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<long double>(d2)));
}
#ifdef BZ_HAVE_COMPLEX

// _bz_MatExpr<P_expr1> != complex<T2>
template<class P_expr1, class T2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > ,
      _bz_NotEqual<typename P_expr1::T_numtype, complex<T2>  > > >
operator!=(_bz_MatExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<complex<T2> > , 
      _bz_NotEqual<typename P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<complex<T2> > (d2)));
}
#endif // BZ_HAVE_COMPLEX


// int != Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int != _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<int, typename P_expr2::T_numtype > > >
operator!=(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

// float != Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<float, P_numtype2 > > >
operator!=(float d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<float, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2._bz_getRef()));
}

// float != _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<float, typename P_expr2::T_numtype > > >
operator!=(float d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<float>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<float, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<float>(d1), 
      d2));
}

// double != Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<double, P_numtype2 > > >
operator!=(double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2._bz_getRef()));
}

// double != _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<double, typename P_expr2::T_numtype > > >
operator!=(double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<double>(d1), 
      d2));
}

// long double != Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<long double, P_numtype2 > > >
operator!=(long double d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<long double, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2._bz_getRef()));
}

// long double != _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<long double, typename P_expr2::T_numtype > > >
operator!=(long double d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<long double>, 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<long double, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<long double>(d1), 
      d2));
}
#ifdef BZ_HAVE_COMPLEX

// complex<T1> != Matrix<P_numtype2, P_struct2>
template<class T1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_NotEqual<complex<T1> , P_numtype2 > > >
operator!=(complex<T1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_NotEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2._bz_getRef()));
}
#endif // BZ_HAVE_COMPLEX

#ifdef BZ_HAVE_COMPLEX

// complex<T1> != _bz_MatExpr<P_expr2>
template<class T1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>,
      _bz_NotEqual<complex<T1> , typename P_expr2::T_numtype > > >
operator!=(complex<T1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<complex<T1> > , 
      _bz_MatExpr<P_expr2>, 
      _bz_NotEqual<complex<T1> , typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<complex<T1> > (d1), 
      d2));
}
#endif // BZ_HAVE_COMPLEX

/****************************************************************************
 * Logical AND operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> && Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> && _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalAnd<P_numtype1, typename P_expr2::T_numtype > > >
operator&&(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalAnd<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> && int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> && Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalAnd<typename P_expr1::T_numtype, P_numtype2 > > >
operator&&(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalAnd<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> && _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalAnd<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator&&(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalAnd<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> && int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_LogicalAnd<typename P_expr1::T_numtype, int > > >
operator&&(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_LogicalAnd<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int && Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int && _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalAnd<int, typename P_expr2::T_numtype > > >
operator&&(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalAnd<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Logical OR operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> || Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> || _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalOr<P_numtype1, typename P_expr2::T_numtype > > >
operator||(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalOr<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> || int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> || Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalOr<typename P_expr1::T_numtype, P_numtype2 > > >
operator||(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalOr<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> || _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalOr<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
operator||(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalOr<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> || int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_LogicalOr<typename P_expr1::T_numtype, int > > >
operator||(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_LogicalOr<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int || Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int || _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_LogicalOr<int, typename P_expr2::T_numtype > > >
operator||(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_LogicalOr<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Minimum Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> min Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Min<P_numtype1, P_numtype2 > > >
min(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Min<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> min _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Min<P_numtype1, typename P_expr2::T_numtype > > >
min(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Min<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> min int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Min<P_numtype1, int > > >
min(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Min<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> min Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Min<typename P_expr1::T_numtype, P_numtype2 > > >
min(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Min<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> min _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Min<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
min(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Min<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> min int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Min<typename P_expr1::T_numtype, int > > >
min(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Min<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int min Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Min<int, P_numtype2 > > >
min(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Min<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int min _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Min<int, typename P_expr2::T_numtype > > >
min(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Min<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}
/****************************************************************************
 * Maximum Operators
 ****************************************************************************/

// Matrix<P_numtype1, P_struct1> max Matrix<P_numtype2, P_struct2>
template<class P_numtype1, class P_struct1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Max<P_numtype1, P_numtype2 > > >
max(const Matrix<P_numtype1, P_struct1>& d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Max<P_numtype1, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2._bz_getRef()));
}

// Matrix<P_numtype1, P_struct1> max _bz_MatExpr<P_expr2>
template<class P_numtype1, class P_struct1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Max<P_numtype1, typename P_expr2::T_numtype > > >
max(const Matrix<P_numtype1, P_struct1>& d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Max<P_numtype1, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      d2));
}

// Matrix<P_numtype1, P_struct1> max int
template<class P_numtype1, class P_struct1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>,
      _bz_Max<P_numtype1, int > > >
max(const Matrix<P_numtype1, P_struct1>& d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatrixRef<P_numtype1, P_struct1>, 
      _bz_MatExprConstant<int>, 
      _bz_Max<P_numtype1, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1._bz_getRef(), 
      _bz_MatExprConstant<int>(d2)));
}

// _bz_MatExpr<P_expr1> max Matrix<P_numtype2, P_struct2>
template<class P_expr1, class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Max<typename P_expr1::T_numtype, P_numtype2 > > >
max(_bz_MatExpr<P_expr1> d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Max<typename P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2._bz_getRef()));
}

// _bz_MatExpr<P_expr1> max _bz_MatExpr<P_expr2>
template<class P_expr1, class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>,
      _bz_Max<typename P_expr1::T_numtype, typename P_expr2::T_numtype > > >
max(_bz_MatExpr<P_expr1> d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Max<typename P_expr1::T_numtype, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      d2));
}

// _bz_MatExpr<P_expr1> max int
template<class P_expr1>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>,
      _bz_Max<typename P_expr1::T_numtype, int > > >
max(_bz_MatExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_MatExprOp<_bz_MatExpr<P_expr1>, 
      _bz_MatExprConstant<int>, 
      _bz_Max<typename P_expr1::T_numtype, int> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(d1, 
      _bz_MatExprConstant<int>(d2)));
}

// int max Matrix<P_numtype2, P_struct2>
template<class P_numtype2, class P_struct2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>,
      _bz_Max<int, P_numtype2 > > >
max(int d1, 
      const Matrix<P_numtype2, P_struct2>& d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatrixRef<P_numtype2, P_struct2>, 
      _bz_Max<int, P_numtype2> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2._bz_getRef()));
}

// int max _bz_MatExpr<P_expr2>
template<class P_expr2>
inline
_bz_MatExpr<_bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>,
      _bz_Max<int, typename P_expr2::T_numtype > > >
max(int d1, 
      _bz_MatExpr<P_expr2> d2)
{
    typedef _bz_MatExprOp<_bz_MatExprConstant<int>, 
      _bz_MatExpr<P_expr2>, 
      _bz_Max<int, typename P_expr2::T_numtype> > T_expr;

    return _bz_MatExpr<T_expr>(T_expr(_bz_MatExprConstant<int>(d1), 
      d2));
}

BZ_NAMESPACE_END

#endif // BZ_MATBOPS_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   matdiag.h                                                                                           0100644 0001750 0001750 00000006021 12160377112 041471  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matdiag.h      Declarations for Diagonal matrices 
 *
 * $Id: matdiag.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATDIAG_H
#define BZ_MATDIAG_H

#ifndef BZ_MSTRUCT_H
 #error <blitz/matdiag.h> must be included via <blitz/mstruct.h>
#endif

BZ_NAMESPACE(blitz)

// Diagonal matrix
// [ 0 . . . ]
// [ . 1 . . ]
// [ . . 2 . ]
// [ . . . 3 ]

class DiagonalIterator {
public:
    DiagonalIterator(const unsigned rows,const unsigned cols) {
        BZPRECONDITION(rows==cols);
        size_ = rows;
        i_ = 0;
    }

    operator bool() const { return i_ < size_; }

    void operator++() { ++i_; }

    unsigned row()    const { return i_; }
    unsigned col()    const { return i_; }
    unsigned offset() const { return i_; }

protected:
    unsigned i_, size_;
};

class Diagonal : public MatrixStructure {
public:
    typedef DiagonalIterator T_iterator;

    Diagonal(): size_(0) { }

    Diagonal(const unsigned size): size_(size) { }

    Diagonal(const unsigned rows,const unsigned cols): size_(rows) {
        BZPRECONDITION(rows == cols);
    }

    unsigned columns() const { return size_; }

    unsigned coordToOffset(const unsigned i,const unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        BZPRECONDITION(i == j);
        return i;
    }

    unsigned firstInRow(const unsigned i) const { return i; }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,const unsigned i,const unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return (i==j) ? data[coordToOffset(i,j)] : ZeroElement<T_numtype>::zero();
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data,const unsigned i,const unsigned j) {
        BZPRECONDITION(inRange(i,j));
        return (i==j) ? data[coordToOffset(i,j)] : ZeroElement<T_numtype>::zero();
    }

    unsigned lastInRow(const unsigned i)  const { return i; }
    unsigned firstInCol(const unsigned j) const { return j; }
    unsigned lastInCol(const unsigned j)  const { return j; }

    bool inRange(const unsigned i,const unsigned j) const {
        return (i < size_) && (j < size_);
    }

    unsigned numElements() const { return size_; }
    unsigned rows()        const { return size_; }

    void resize(const unsigned size) { size_ = size; }

    void resize(const unsigned rows,const unsigned cols) {
        BZPRECONDITION(rows == cols);
        size_  = rows;
    }

private:
    unsigned size_;
};

BZ_NAMESPACE_END

#endif // BZ_MATSYMM_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               matexpr.h                                                                                           0100644 0001750 0001750 00000010144 12160377112 041544  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matexpr.h      Matrix<P_numtype, P_structure> expression templates
 *
 * $Id: matexpr.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATEXPR_H
#define BZ_MATEXPR_H

#ifndef BZ_MATRIX_H
 #error <blitz/matexpr.h> must be included via <blitz/matrix.h>
#endif

#include <blitz/applics.h>

BZ_NAMESPACE(blitz)

// BlitzMatrixExpressionsBase is a dummy class provided for users of
// graphical class browsers.  
class BlitzMatrixExpressionsBase { };

template<typename P_expr>
class _bz_MatExpr : public BlitzMatrixExpressionsBase {

public:
    typedef P_expr T_expr;
    typedef _bz_typename T_expr::T_numtype T_numtype;

#ifdef BZ_PASS_EXPR_BY_VALUE
    _bz_MatExpr(T_expr a)
        : iter_(a)
    { }
#else
    _bz_MatExpr(const T_expr& a)
        : iter_(a)
    { }
#endif

    T_numtype operator()(unsigned i, unsigned j) const
    { return iter_(i,j); }

    unsigned rows(unsigned recommendedRows) const
    { return iter_.rows(recommendedRows); }

    unsigned cols(unsigned recommendedCols) const
    { return iter_.cols(recommendedCols); }

private:
    T_expr iter_;
};

template<typename P_expr1, typename P_expr2, typename P_op>
class _bz_MatExprOp : public BlitzMatrixExpressionsBase {

public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef _bz_typename T_expr1::T_numtype T_numtype1;
    typedef _bz_typename T_expr2::T_numtype T_numtype2;
    typedef BZ_PROMOTE(T_numtype1, T_numtype2) T_numtype;
    typedef P_op    T_op;

#ifdef BZ_PASS_EXPR_BY_VALUE
    _bz_MatExprOp(T_expr1 a, T_expr2 b)
        : iter1_(a), iter2_(b)
    { }
#else
    _bz_MatExprOp(const T_expr1& a, const T_expr2& b)
        : iter1_(a), iter2_(b)
    { }
#endif

    T_numtype operator()(unsigned i, unsigned j) const
    { return T_op::apply(iter1_(i,j), iter2_(i,j)); }

    unsigned rows(unsigned recommendedRows) const
    {
        BZPRECONDITION(iter2_.rows(recommendedRows) == 
            iter1_.rows(recommendedRows));
        return iter1_.rows(recommendedRows);
    }

    unsigned cols(unsigned recommendedCols) const
    {
        BZPRECONDITION(iter2_.cols(recommendedCols) == 
            iter1_.cols(recommendedCols));
        return iter1_.cols(recommendedCols);
    }

private:
    T_expr1 iter1_;
    T_expr2 iter2_;
};

template<typename P_expr, typename P_unaryOp>
class _bz_MatExprUnaryOp : public BlitzMatrixExpressionsBase {

public:
    typedef P_expr T_expr;
    typedef P_unaryOp T_unaryOp;
    typedef _bz_typename T_unaryOp::T_numtype T_numtype;

#ifdef BZ_PASS_EXPR_BY_VALUE
    _bz_MatExprUnaryOp(T_expr iter)
        : iter_(iter)
    { }
#else
    _bz_MatExprUnaryOp(const T_expr& iter)
        : iter_(iter)
    { }
#endif

    T_numtype operator()(unsigned i, unsigned j) const
    { return T_unaryOp::apply(iter_(i,j)); }

    unsigned rows(unsigned recommendedRows) const
    { return iter_.rows(recommendedRows); }

    unsigned cols(unsigned recommendedCols) const
    { return iter_.cols(recommendedCols); }

private:
    T_expr iter_;    
};

template<typename P_numtype>
class _bz_MatExprConstant : public BlitzMatrixExpressionsBase {
public:
    typedef P_numtype T_numtype;

    _bz_MatExprConstant(P_numtype value)
        : value_(value)
    { }

    T_numtype operator()(unsigned i, unsigned j) const
    { return value_; }

    unsigned rows(unsigned recommendedRows) const
    { return recommendedRows; }

    unsigned cols(unsigned recommendedCols) const
    { return recommendedCols; }

private:
    T_numtype value_;
};

BZ_NAMESPACE_END

#include <blitz/matref.h>
#include <blitz/matbops.h>
#include <blitz/matuops.h>

#endif // BZ_MATEXPR_H
                                                                                                                                                                                                                                                                                                                                                                                                                            matgen.h                                                                                            0100644 0001750 0001750 00000007752 12160377112 041352  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matgen.h       Declarations for RowMajor and ColumnMajor matrices
 *
 * $Id: matgen.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATGEN_H
#define BZ_MATGEN_H

#ifndef BZ_MSTRUCT_H
 #error <blitz/matgen.h> must be included via <blitz/mstruct.h>
#endif // BZ_MSTRUCT_H

BZ_NAMESPACE(blitz)

class GeneralMatrix : public AsymmetricMatrix {

public:
    GeneralMatrix()
    { }

    GeneralMatrix(unsigned rows, unsigned cols)
        : AsymmetricMatrix(rows, cols)
    {
    }

    unsigned firstInRow(unsigned i) const
    { return 0; }

    unsigned lastInRow(unsigned i) const
    { return cols_ - 1; }

    unsigned firstInCol(unsigned j) const
    { return 0; }

    unsigned lastInCol(unsigned j) const
    { return rows_ - 1; }

    unsigned numElements() const
    { return rows_ * cols_; }
};

class GeneralIterator {
public:
    GeneralIterator(unsigned rows, unsigned cols)
    {
        rows_ = rows;
        cols_ = cols;
        i_ = 0;
        j_ = 0;
        offset_ = 0;
        good_ = true;
    }

    unsigned offset() const { return offset_; }
    operator bool()   const { return good_; }
    unsigned row()    const { return i_; }
    unsigned col()    const { return j_; }
 
protected:
    unsigned rows_, cols_;
    unsigned offset_;
    unsigned i_, j_;
    bool     good_;
};

class RowMajorIterator : public GeneralIterator {
public:
    RowMajorIterator(unsigned rows, unsigned cols)
        : GeneralIterator(rows, cols)
    { }

    void operator++()
    {
        ++offset_;
        ++j_;
        if (j_ == cols_)
        {
            j_ = 0;
            ++i_;
            if (i_ == rows_)
                good_ = false;
        }
    }
};

class RowMajor : public GeneralMatrix {

public:
    typedef RowMajorIterator T_iterator;

    RowMajor()
    { }

    RowMajor(unsigned rows, unsigned cols)
        : GeneralMatrix(rows, cols)
    { }

    unsigned coordToOffset(unsigned i, unsigned j) const
    {
        return i*cols_+j;
    }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,
        unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data, unsigned i, unsigned j)
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }
};

class ColumnMajorIterator : public GeneralIterator {
public:
    ColumnMajorIterator(unsigned rows, unsigned cols)
        : GeneralIterator(rows, cols)
    {
    }

    void operator++()
    {
        ++offset_;
        ++i_;
        if (i_ == rows_)
        {
            i_ = 0;
            ++j_;
            if (j_ == cols_)
                good_ = false;
        }
    }
};

class ColumnMajor : public GeneralMatrix {

public:
    ColumnMajor()
    { }

    ColumnMajor(unsigned rows, unsigned cols)
        : GeneralMatrix(rows, cols)
    { }

    unsigned coordToOffset(unsigned i, unsigned j) const
    {
        return j*rows_ + i;
    }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,
        unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data, unsigned i, unsigned j)
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }
};

BZ_NAMESPACE_END

#endif // BZ_MATGEN_H

                      mathf2.h                                                                                            0100644 0001750 0001750 00000016047 12160377112 041255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // -*- C++ -*-
/***************************************************************************
 * blitz/mathf2.h  Declaration of additional math functions
 *
 * $Id: mathf2.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATHF2_H
#define BZ_MATHF2_H

#ifndef BZ_APPLICS_H
 #error <blitz/mathf2.h> should be included via <blitz/applics.h>
#endif

#include <blitz/prettyprint.h>

BZ_NAMESPACE(blitz)

// cexp(z)     Complex exponential
template<typename P_numtype1>
class _bz_cexp : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return _bz_exp<T_numtype1>::apply(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cexp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// csqrt(z)    Complex square root
template<typename P_numtype1>
class _bz_csqrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return _bz_sqrt<T_numtype1>::apply(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "csqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow2        Square
template<typename P_numtype1>
class _bz_pow2 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        return BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow2(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow3        Cube
template<typename P_numtype1>
class _bz_pow3 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        return BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x) *
          BZ_NO_PROPAGATE(x);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow3(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow4        Fourth power
template<typename P_numtype1>
class _bz_pow4 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        T_numtype t1 = BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x);
        return BZ_NO_PROPAGATE(t1) * BZ_NO_PROPAGATE(t1);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow4(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow5        Fifth power
template<typename P_numtype1>
class _bz_pow5 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 = BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x);
        return BZ_NO_PROPAGATE(t1) * BZ_NO_PROPAGATE(t1)
            * BZ_NO_PROPAGATE(t1);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow5(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow6        Sixth power
template<typename P_numtype1>
class _bz_pow6 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 = BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x) 
            * BZ_NO_PROPAGATE(x);
        return BZ_NO_PROPAGATE(t1) * BZ_NO_PROPAGATE(t1);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow6(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


// pow7        Seventh power
template<typename P_numtype1>
class _bz_pow7 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 = BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x) 
            * BZ_NO_PROPAGATE(x);
        return BZ_NO_PROPAGATE(t1) * BZ_NO_PROPAGATE(t1)
            * BZ_NO_PROPAGATE(x);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow7(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// pow8        Eighth power
template<typename P_numtype1>
class _bz_pow8 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 = BZ_NO_PROPAGATE(x) * BZ_NO_PROPAGATE(x);
        T_numtype t2 = BZ_NO_PROPAGATE(t1) * BZ_NO_PROPAGATE(t1);
        return BZ_NO_PROPAGATE(t2) * BZ_NO_PROPAGATE(t2);
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow8(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

/*
 * These scalar versions of pow2, pow3, ..., pow8 are provided for
 * convenience.
 *
 * NEEDS_WORK -- include BZ_NO_PROPAGATE for these scalar versions.
 */

// NEEDS_WORK -- make these templates.  Rely on specialization to
// handle expression template versions.

#define BZ_DECLARE_POW(T)  \
 inline T pow2(T x) { return x*x; }                  \
 inline T pow3(T x) { return x*x*x; }                \
 inline T pow4(T x) { T t1 = x*x; return t1*t1; }    \
 inline T pow5(T x) { T t1 = x*x; return t1*t1*x; }  \
 inline T pow6(T x) { T t1 = x*x*x; return t1*t1; }  \
 inline T pow7(T x) { T t1 = x*x; return t1*t1*t1*x; } \
 inline T pow8(T x) { T t1 = x*x, t2=t1*t1; return t2*t2; }  

BZ_DECLARE_POW(int)
BZ_DECLARE_POW(float)
BZ_DECLARE_POW(double)
BZ_DECLARE_POW(long double)

#ifdef BZ_HAVE_COMPLEX
BZ_DECLARE_POW(complex<float>)
BZ_DECLARE_POW(complex<double>)
BZ_DECLARE_POW(complex<long double>)
#endif

BZ_NAMESPACE_END

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         mathfunc.h                                                                                          0100644 0001750 0001750 00000235375 12160377112 041710  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  // Generated: genmathfunc.cpp Jan 28 2005 12:04:32

#ifndef BZ_MATHFUNC_H
#define BZ_MATHFUNC_H

#ifndef BZ_APPLICS_H
 #error <blitz/mathfunc.h> should be included via <blitz/applics.h>
#endif


#ifndef BZ_PRETTYPRINT_H
 #include <blitz/prettyprint.h>
#endif

#include <cstdlib>

BZ_NAMESPACE(blitz)

// abs(P_numtype1)    Absolute value
template<typename P_numtype1>
class _bz_abs : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(abs)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "abs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// abs(long)
template<>
class _bz_abs<long> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long T_numtype1;
    typedef long T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(labs)((long)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "labs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// abs(float)
template<>
class _bz_abs<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(fabs)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// abs(double)
template<>
class _bz_abs<double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef double T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(fabs)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// abs(long double)
template<>
class _bz_abs<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(fabs)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// abs(complex<float> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_abs<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(abs)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "abs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// abs(complex<double> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_abs<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(abs)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "abs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// abs(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_abs<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(abs)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "abs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// acos(P_numtype1)    Inverse cosine
template<typename P_numtype1>
class _bz_acos : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(acos)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// acos(float)
template<>
class _bz_acos<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(acos)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// acos(long double)
template<>
class _bz_acos<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(acos)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// acos(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_acos<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(acos)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// acos(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_acos<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(acos)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// acos(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_acos<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(acos)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// acosh(P_numtype1)    Inverse hyperbolic cosine
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_acosh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(acosh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// asin(P_numtype1)    Inverse sine
template<typename P_numtype1>
class _bz_asin : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(asin)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// asin(float)
template<>
class _bz_asin<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(asin)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// asin(long double)
template<>
class _bz_asin<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(asin)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// asin(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_asin<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(asin)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// asin(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_asin<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(asin)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// asin(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_asin<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(asin)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// asinh(P_numtype1)    Inverse hyperbolic sine
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_asinh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(asinh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// arg(P_numtype1)
#ifdef BZ_HAVE_COMPLEX_FCNS
template<typename P_numtype1>
class _bz_arg : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return 0; }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "0(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// arg(complex<float> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_arg<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(arg)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "arg(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// arg(complex<double> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_arg<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(arg)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "arg(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// arg(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_FCNS
template<>
class _bz_arg<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(arg)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "arg(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// atan(P_numtype1)    Inverse tangent
template<typename P_numtype1>
class _bz_atan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(atan)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// atan(float)
template<>
class _bz_atan<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(atan)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// atan(long double)
template<>
class _bz_atan<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(atan)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// atan(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_atan<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(atan)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// atan(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_atan<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(atan)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// atan(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_atan<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(atan)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// atanh(P_numtype1)    Inverse hyperbolic tangent
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_atanh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(atanh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// atan2(P_numtype1, P_numtype2)    Inverse tangent
template<typename P_numtype1, typename P_numtype2>
class _bz_atan2 : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(atan2)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

// atan2(float, float)
template<>
class _bz_atan2<float, float > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype2;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(atan2)((float)x,(float)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

// atan2(long double, long double)
template<>
class _bz_atan2<long double, long double > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype2;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(atan2)((long double)x,(long double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

// _class(P_numtype1)    Classification of float-point value (FP_xxx)
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1>
class _bz__class : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(_class)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "_class(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// cbrt(P_numtype1)    Cube root
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_cbrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(cbrt)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cbrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// ceil(P_numtype1)    Ceiling
template<typename P_numtype1>
class _bz_ceil : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(ceil)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// ceil(float)
template<>
class _bz_ceil<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(ceil)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// ceil(long double)
template<>
class _bz_ceil<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(ceil)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// conj(P_numtype1)
#ifdef BZ_HAVE_COMPLEX_FCNS
template<typename P_numtype1>
class _bz_conj : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(conj)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "conj(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// cos(P_numtype1)    Cosine
template<typename P_numtype1>
class _bz_cos : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cos)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cos(float)
template<>
class _bz_cos<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cos)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cos(long double)
template<>
class _bz_cos<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cos)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cos(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cos<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cos)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// cos(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cos<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cos)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// cos(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cos<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cos)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// copysign(P_numtype1, P_numtype2)
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_copysign : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(copysign)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "copysign(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// cosh(P_numtype1)    Hyperbolic cosine
template<typename P_numtype1>
class _bz_cosh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cosh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cosh(float)
template<>
class _bz_cosh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cosh)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cosh(long double)
template<>
class _bz_cosh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(cosh)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// cosh(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cosh<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cosh)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// cosh(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cosh<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cosh)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// cosh(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_cosh<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(cosh)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// drem(P_numtype1, P_numtype2)    Remainder
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_drem : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(drem)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "drem(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// exp(P_numtype1)    Exponential
template<typename P_numtype1>
class _bz_exp : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(exp)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// exp(float)
template<>
class _bz_exp<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(exp)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// exp(long double)
template<>
class _bz_exp<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(exp)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// exp(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_exp<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(exp)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// exp(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_exp<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(exp)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// exp(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_exp<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(exp)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// expm1(P_numtype1)    Exp(x)-1
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_expm1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(expm1)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "expm1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// erf(P_numtype1)    Error function
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_erf : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(erf)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "erf(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// erfc(P_numtype1)    Complementary error function
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_erfc : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(erfc)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "erfc(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// floor(P_numtype1)    Floor function
template<typename P_numtype1>
class _bz_floor : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(floor)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// floor(float)
template<>
class _bz_floor<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(floor)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// floor(long double)
template<>
class _bz_floor<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(floor)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// fmod(P_numtype1, P_numtype2)    Modulo remainder
template<typename P_numtype1, typename P_numtype2>
class _bz_fmod : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(fmod)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "fmod(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

// hypot(P_numtype1, P_numtype2)    sqrt(x*x+y*y)
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_hypot : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(hypot)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "hypot(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// ilogb(P_numtype1)    Integer unbiased exponent
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_ilogb : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(ilogb)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ilogb(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// blitz_isnan(P_numtype1)    Nonzero if NaNS or NaNQ
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_blitz_isnan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
#ifdef BZ_ISNAN_IN_NAMESPACE_STD
        return BZ_STD_SCOPE(isnan)(x);
#else
        return BZ_IEEEMATHFN_SCOPE(isnan)(x);
#endif
    }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "blitz_isnan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// itrunc(P_numtype1)    Truncate and convert to integer
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1>
class _bz_itrunc : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(itrunc)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "itrunc(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// j0(P_numtype1)    Bessel function first kind, order 0
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_j0 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(j0)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "j0(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// j1(P_numtype1)    Bessel function first kind, order 1
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_j1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(j1)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "j1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// lgamma(P_numtype1)    Log absolute gamma
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_lgamma : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(lgamma)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "lgamma(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log(P_numtype1)    Natural logarithm
template<typename P_numtype1>
class _bz_log : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log(float)
template<>
class _bz_log<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log(long double)
template<>
class _bz_log<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_log<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_log<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// log(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_log<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// logb(P_numtype1)    Unbiased exponent (IEEE)
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_logb : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(logb)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "logb(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log1p(P_numtype1)    Compute log(1 + x)
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_log1p : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(log1p)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log1p(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log10(P_numtype1)    Logarithm base 10
template<typename P_numtype1>
class _bz_log10 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log10)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log10(float)
template<>
class _bz_log10<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log10)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log10(long double)
template<>
class _bz_log10<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(log10)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// log10(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_log10<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log10)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log10(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_log10<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log10)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// log10(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH2
template<>
class _bz_log10<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(log10)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// nearest(P_numtype1)    Nearest floating point integer
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1>
class _bz_nearest : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(nearest)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "nearest(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// nextafter(P_numtype1, P_numtype2)    Next representable number after x towards y
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_nextafter : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(nextafter)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "nextafter(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

template<typename P_numtype>
class _bz_negate : public OneOperandApplicativeTemplatesBase {
public:
    typedef BZ_SIGNEDTYPE(P_numtype) T_numtype;

    static inline T_numtype apply(T_numtype x)
    { return -x; }

        template<typename T1>
        static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format, const T1& a)
        {
                str += "-(";
                       a.prettyPrint(str,format);
                       str += ")";
        }
};

// norm(P_numtype1)
#ifdef BZ_HAVE_COMPLEX_FCNS
template<typename P_numtype1>
class _bz_norm : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(norm)(x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "norm(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// polar(P_numtype1, P_numtype2)
#ifdef BZ_HAVE_COMPLEX_FCNS
template<typename P_numtype1, typename P_numtype2>
class _bz_polar : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef complex<T_numtype1> T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_CMATHFN_SCOPE(polar)(x,y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "polar(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// pow(P_numtype1, P_numtype2)    Power
template<typename P_numtype1, typename P_numtype2>
class _bz_pow : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(pow)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

#ifndef __PGI
// pow(float, float)
template<>
class _bz_pow<float, float > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype2;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(pow)((float)x,(float)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

#endif
// pow(long double, long double)
template<>
class _bz_pow<long double, long double > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype2;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_MATHFN_SCOPE(pow)((long double)x,(long double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

// pow(complex<float>, complex<float>)
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_pow<complex<float>, complex<float> > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef complex<float> T_numtype1;
    typedef complex<float> T_numtype2;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_CMATHFN_SCOPE(pow)((complex<float>)x,(complex<float>)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// pow(complex<double>, complex<double>)
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_pow<complex<double>, complex<double> > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef complex<double> T_numtype1;
    typedef complex<double> T_numtype2;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_CMATHFN_SCOPE(pow)((complex<double>)x,(complex<double>)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// pow(complex<long double>, complex<long double>)
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_pow<complex<long double>, complex<long double> > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef complex<long double> T_numtype1;
    typedef complex<long double> T_numtype2;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_CMATHFN_SCOPE(pow)((complex<long double>)x,(complex<long double>)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// remainder(P_numtype1, P_numtype2)    Remainder
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_remainder : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(remainder)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "remainder(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// rint(P_numtype1)    Round to floating point integer
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_rint : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(rint)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "rint(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// rsqrt(P_numtype1)    Reciprocal square root
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1>
class _bz_rsqrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(rsqrt)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "rsqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// scalb(P_numtype1, P_numtype2)    x * (2**y)
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_scalb : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(scalb)((double)x,(double)y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "scalb(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// sin(P_numtype1)    Sine
template<typename P_numtype1>
class _bz_sin : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sin)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sin(float)
template<>
class _bz_sin<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sin)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sin(long double)
template<>
class _bz_sin<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sin)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sin(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sin<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sin)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// sin(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sin<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sin)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// sin(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sin<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sin)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// sinh(P_numtype1)    Hyperbolic sine
template<typename P_numtype1>
class _bz_sinh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sinh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sinh(float)
template<>
class _bz_sinh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sinh)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sinh(long double)
template<>
class _bz_sinh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sinh)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sinh(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sinh<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sinh)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// sinh(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sinh<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sinh)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// sinh(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sinh<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sinh)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
template<typename P_numtype>
class _bz_sqr : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype T_numtype;

    static inline T_numtype apply(T_numtype x)
    { return x*x; }
    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqr(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

#ifdef BZ_HAVE_COMPLEX
// Specialization of _bz_sqr for complex<T>
template<typename T>
class _bz_sqr<complex<T> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<T> T_numtype;

    static inline T_numtype apply(T_numtype x)
    {
        T r = x.real();  T i = x.imag();
        return T_numtype(r*r-i*i, 2*r*i);
    }
    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqr(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// sqrt(P_numtype1)    Square root
template<typename P_numtype1>
class _bz_sqrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sqrt)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sqrt(float)
template<>
class _bz_sqrt<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sqrt)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sqrt(long double)
template<>
class _bz_sqrt<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(sqrt)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// sqrt(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sqrt<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sqrt)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// sqrt(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sqrt<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sqrt)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// sqrt(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_sqrt<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(sqrt)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// tan(P_numtype1)    Tangent
template<typename P_numtype1>
class _bz_tan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tan)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tan(float)
template<>
class _bz_tan<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tan)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tan(long double)
template<>
class _bz_tan<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tan)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tan(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tan<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tan)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// tan(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tan<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tan)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// tan(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tan<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tan)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// tanh(P_numtype1)    Hyperbolic tangent
template<typename P_numtype1>
class _bz_tanh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tanh)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tanh(float)
template<>
class _bz_tanh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tanh)((float)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tanh(long double)
template<>
class _bz_tanh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_MATHFN_SCOPE(tanh)((long double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

// tanh(complex<float> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tanh<complex<float> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<float>  T_numtype1;
    typedef complex<float> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tanh)((complex<float> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// tanh(complex<double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tanh<complex<double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<double>  T_numtype1;
    typedef complex<double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tanh)((complex<double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#ifndef __PGI
// tanh(complex<long double> )
#ifdef BZ_HAVE_COMPLEX_MATH1
template<>
class _bz_tanh<complex<long double> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<long double>  T_numtype1;
    typedef complex<long double> T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_CMATHFN_SCOPE(tanh)((complex<long double> )x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

#endif
// uitrunc(P_numtype1)    Truncate and convert to unsigned
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1>
class _bz_uitrunc : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef unsigned T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(uitrunc)((unsigned)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "uitrunc(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// unordered(P_numtype1, P_numtype2)    True if a comparison of x and y would be unordered
#ifdef BZ_HAVE_SYSTEM_V_MATH
template<typename P_numtype1, typename P_numtype2>
class _bz_unordered : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return BZ_IEEEMATHFN_SCOPE(unordered)(x,y); }

    template<typename T1, typename T2>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "unordered(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// y0(P_numtype1)    Bessel function of the second kind, order zero
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_y0 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(y0)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "y0(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif

// y1(P_numtype1)    Bessel function of the second kind, order one
#ifdef BZ_HAVE_IEEE_MATH
template<typename P_numtype1>
class _bz_y1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return BZ_IEEEMATHFN_SCOPE(y1)((double)x); }

    template<typename T1>
    static void prettyPrint(BZ_STD_SCOPE(string) &str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "y1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};
#endif



BZ_NAMESPACE_END

#endif // BZ_MATHFUNC_H
                                                                                                                                                                                                                                                                   matltri.h                                                                                           0100644 0001750 0001750 00000007044 12160377112 041545  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matltri.h      Declarations for LowerTriangular matrices
 *
 * $Id: matltri.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/


#ifndef BZ_MATLTRI_H
#define BZ_MATLTRI_H

#ifndef BZ_MSTRUCT_H
 #error <blitz/matltri.h> must be included via <blitz/mstruct.h>
#endif

BZ_NAMESPACE(blitz)

// Lower triangular, row major ordering
// [ 0 . . . ]
// [ 1 2 . . ]
// [ 3 4 5 . ]
// [ 6 7 8 9 ]

class LowerTriangularIterator {
public:
    LowerTriangularIterator(unsigned rows, unsigned cols)
    {
        BZPRECONDITION(rows == cols);
        size_ = rows;
        good_ = true;
        offset_ = 0;
        i_ = 0;
        j_ = 0;
    }
   
    operator bool() const { return good_; }

    void operator++()
    {
        BZPRECONDITION(good_);
        ++offset_;
        ++j_;
        if (j_ > i_)
        {
            j_ = 0;
            ++i_;
            if (i_ == size_)
                good_ = false;
        }
    }

    unsigned row() const
    { return i_; }

    unsigned col() const
    { return j_; }

    unsigned offset() const
    { return offset_; }

protected:
    unsigned size_;
    bool good_;
    unsigned offset_;
    unsigned i_, j_;
};

class LowerTriangular : public MatrixStructure {

public:
    typedef LowerTriangularIterator T_iterator;

    LowerTriangular()
        : size_(0)
    { }

    LowerTriangular(unsigned size)
        : size_(size)
    { }

    LowerTriangular(unsigned rows, unsigned cols)
        : size_(rows)
    {
        BZPRECONDITION(rows == cols);
    }

    unsigned columns() const
    { return size_; }

    unsigned coordToOffset(unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        BZPRECONDITION(i >= j);
        return i*(i+1)/2 + j;
    }

    unsigned firstInRow(unsigned i) const
    { return 0; }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,
        unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        if (i >= j)
            return data[coordToOffset(i,j)];
        else
            return ZeroElement<T_numtype>::zero();
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data, unsigned i, unsigned j)
    {
        BZPRECONDITION(inRange(i,j));
        if (i >= j)
            return data[coordToOffset(i,j)];
        else
            return ZeroElement<T_numtype>::zero();
    }

    unsigned lastInRow(unsigned i) const
    { return i; }

    unsigned firstInCol(unsigned j) const
    { return j; }

    unsigned lastInCol(unsigned j) const
    { return size_ - 1; }

    bool inRange(unsigned i, unsigned j) const
    {
        return (i < size_) && (j < size_);
    }

    unsigned numElements() const
    { return size_ * (size_ + 1) / 2; }

    unsigned rows() const
    { return size_; }

    void resize(unsigned size)
    {
        size_ = size;
    }

    void resize(unsigned rows, unsigned cols)
    {
        BZPRECONDITION(rows == cols);
        size_  = rows;
    }

private:
    unsigned size_;
};

BZ_NAMESPACE_END

#endif // BZ_MATLTRI_H

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            matref.h                                                                                            0100644 0001750 0001750 00000002701 12160377112 041342  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matref.h      Declaration of the _bz_MatrixRef<P_numtype, P_structure>
 *                     class.
 *
 * $Id: matref.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATREF_H
#define BZ_MATREF_H

#ifndef BZ_MATEXPR_H
 #error <blitz/matref.h> must be included via <blitz/matexpr.h>
#endif // BZ_MATEXPR_H

BZ_NAMESPACE(blitz)

template<typename P_numtype, typename P_structure>
class _bz_MatrixRef {

public:
    typedef P_numtype T_numtype;

    _bz_MatrixRef(const Matrix<P_numtype, P_structure>& m)
        : matrix_(&m)
    { }

    T_numtype operator()(unsigned i, unsigned j) const
    { return (*matrix_)(i,j); }

    unsigned rows(unsigned) const
    { return matrix_->rows(); }

    unsigned cols(unsigned) const
    { return matrix_->cols(); }

private:
    _bz_MatrixRef() { } 

    const Matrix<P_numtype, P_structure>* matrix_;
};

BZ_NAMESPACE_END

#endif // BZ_MATREF_H
                                                               matrix.h                                                                                            0100644 0001750 0001750 00000014112 12160377112 041367  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matrix.h      Declaration of the Matrix<T_type, T_structure> class
 *
 * $Id: matrix.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATRIX_H
#define BZ_MATRIX_H

#ifndef BZ_BLITZ_H
 #include <blitz/blitz.h>
#endif

#ifndef BZ_MEMBLOCK_H
 #include <blitz/memblock.h>
#endif

#ifndef BZ_MSTRUCT_H
 #include <blitz/mstruct.h>
#endif

BZ_NAMESPACE(blitz)

// Forward declarations
template<typename P_numtype, typename P_structure>
class _bz_MatrixRef;

template<typename P_expr>
class _bz_MatExpr;

// Declaration of class Matrix
template<typename P_numtype, typename P_structure BZ_TEMPLATE_DEFAULT(RowMajor)>
class Matrix : protected MemoryBlockReference<P_numtype> {

private:
    typedef MemoryBlockReference<P_numtype> T_base;
    using T_base::data_;

public:

    //////////////////////////////////////////////
    // Public Types
    //////////////////////////////////////////////

    typedef P_numtype        T_numtype;
    typedef P_structure      T_structure;
    typedef Matrix<P_numtype, P_structure>   T_matrix;

    //////////////////////////////////////////////
    // Constructors                             //
    //////////////////////////////////////////////

    Matrix()
    { }

    Matrix(int rows, int cols, T_structure structure = T_structure())
        : structure_(structure) 
    {
        structure_.resize(rows, cols);
        MemoryBlockReference<T_numtype>::newBlock(structure_.numElements());
    }

    // Matrix(int rows, int cols, T_numtype initValue,
    //    T_structure structure = T_structure(rows, cols));
    // Matrix(int rows, int cols, Random);
    // Matrix(int rows, int cols, matrix-expression);
    // Matrix(int rows, int cols, T_numtype* data, int rowStride, int colStride);
    // explicit Matrix(Vector<T_numtype>& matrix);
    // explicit Matrix(unsigned length);

    // Create a vector view of an already allocated block of memory.
    // Note that the memory will not be freed when this vector is
    // destroyed.
    // Matrix(unsigned length, T_numtype* data, int stride = 1);

    //////////////////////////////////////////////
    // Member functions
    //////////////////////////////////////////////

    //T_iterator      begin()  const;
    //T_constIterator begin()  const;
    //T_vector        copy()   const;
    //T_iterator      end()    const;
    //T_constIterator end()    const;

    unsigned        cols()        const
    { return structure_.columns(); }

    unsigned        columns()     const
    { return structure_.columns(); }

    void            makeUnique()  const;

    unsigned        numElements() const
    { return structure_.numElements(); }

    void            reference(T_matrix&);

    void            resize(unsigned rows, unsigned cols)
    {
        structure_.resize(rows, cols);
        MemoryBlockReference<T_numtype>::newBlock(structure_.numElements());
    }

//    void            resizeAndPreserve(unsigned newLength);

    unsigned        rows()   const
    { return structure_.rows(); }

    _bz_MatrixRef<T_numtype, T_structure> _bz_getRef() const
    { return _bz_MatrixRef<T_numtype, T_structure>(*this); }

    //////////////////////////////////////////////
    // Subscripting operators
    //////////////////////////////////////////////

    T_numtype           operator()(unsigned i, unsigned j) const
    {
        return structure_.get(data_, i, j);
    }

    T_numtype& restrict operator()(unsigned i, unsigned j)
    {
        return structure_.get(data_, i, j);
    }

    // T_matrix      operator()(Range,Range);

    // T_matrixIndirect operator()(Vector<int>,Vector<int>);
    // T_matrixIndirect operator()(integer-placeholder-expression, Range);
    // T_matrix         operator()(difference-equation-expression)

    //////////////////////////////////////////////
    // Assignment operators
    //////////////////////////////////////////////

    // Scalar operand
    T_matrix& operator=(T_numtype);
    T_matrix& operator+=(T_numtype);
    T_matrix& operator-=(T_numtype);
    T_matrix& operator*=(T_numtype);
    T_matrix& operator/=(T_numtype);

    // Matrix operand

    template<typename P_numtype2, typename P_structure2> 
    T_matrix& operator=(const Matrix<P_numtype2, P_structure2> &);
    template<typename P_numtype2, typename P_structure2> 
    T_matrix& operator+=(const Matrix<P_numtype2, P_structure2>&);
    template<typename P_numtype2, typename P_structure2> 
    T_matrix& operator-=(const Matrix<P_numtype2, P_structure2> &);
    template<typename P_numtype2, typename P_structure2> 
    T_matrix& operator*=(const Matrix<P_numtype2, P_structure2> &);
    template<typename P_numtype2, typename P_structure2> 
    T_matrix& operator/=(const Matrix<P_numtype2, P_structure2> &);

    // Matrix expression operand
    template<typename P_expr>
    T_matrix& operator=(_bz_MatExpr<P_expr>);

    // Integer placeholder expression operand
    // MatrixPick operand

    //////////////////////////////////////////////
    // Unary operators
    //////////////////////////////////////////////

    T_matrix& operator++();
    void operator++(int);
    T_matrix& operator--();
    void operator--(int);
    
private:
    T_structure structure_;
};

template<typename P_numtype, typename P_structure>
ostream& operator<<(ostream& os, const Matrix<P_numtype, P_structure>& matrix);

// Global operators
// +,-,*,/ with all possible combinations of:
//    - scalar
//    - matrix
//    - matrix pick
//    - matrix expression
// Pointwise Math functions: sin, cos, etc.
// Global functions

BZ_NAMESPACE_END

#include <blitz/matrix.cc>
#include <blitz/matexpr.h>

#endif // BZ_MATRIX_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                      matsymm.h                                                                                           0100644 0001750 0001750 00000006564 12160377112 041566  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/matsymm.h      Declarations for Symmetric matrices
 *
 * $Id: matsymm.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATSYMM_H
#define BZ_MATSYMM_H

#ifndef BZ_MSTRUCT_H
 #error <blitz/matsymm.h> must be included via <blitz/mstruct.h>
#endif

BZ_NAMESPACE(blitz)

// Symmetric, lower triangular row major ordering
// [ 0 1 3 6 ]
// [ 1 2 4 7 ]
// [ 3 4 5 8 ]
// [ 6 7 8 9 ]

class SymmetricIterator {
public:
    SymmetricIterator(unsigned rows, unsigned cols)
    {
        BZPRECONDITION(rows == cols);
        size_ = rows;
        good_ = true;
        offset_ = 0;
        i_ = 0;
        j_ = 0;
    }
   
    operator bool() const { return good_; }

    void operator++()
    {
        BZPRECONDITION(good_);
        ++offset_;
        ++j_;
        if (j_ > i_)
        {
            j_ = 0;
            ++i_;
            if (i_ == size_)
                good_ = false;
        }
    }

    unsigned row() const
    { return i_; }

    unsigned col() const
    { return j_; }

    unsigned offset() const
    { return offset_; }

protected:
    unsigned size_;
    bool     good_;
    unsigned offset_;
    unsigned i_, j_;
};

class Symmetric : public MatrixStructure {

public:
    typedef SymmetricIterator T_iterator;

    Symmetric()
        : size_(0)
    { }

    Symmetric(unsigned size)
        : size_(size)
    { }

    Symmetric(unsigned rows, unsigned cols)
        : size_(rows)
    {
        BZPRECONDITION(rows == cols);
    }

    unsigned columns() const
    { return size_; }

    unsigned coordToOffset(unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        if (i >= j)
            return i*(i+1)/2 + j;
        else
            return j*(j+1)/2 + i;
    }

    unsigned firstInRow(unsigned i) const
    { return 0; }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,
        unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data, unsigned i, unsigned j)
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    unsigned lastInRow(unsigned i) const
    { return i; }

    unsigned firstInCol(unsigned j) const
    { return j; }

    unsigned lastInCol(unsigned j) const
    { return size_ - 1; }

    bool inRange(unsigned i, unsigned j) const {
        return (i < size_) && (j < size_);
    }

    unsigned numElements() const
    { return size_ * (size_ + 1) / 2; }

    unsigned rows() const
    { return size_; }

    void resize(unsigned size)
    {
        size_ = size;
    }

    void resize(unsigned rows, unsigned cols)
    {
        BZPRECONDITION(rows == cols);
        size_  = rows;
    }

private:
    unsigned size_;
};

BZ_NAMESPACE_END

#endif // BZ_MATSYMM_H

                                                                                                                                            mattoep.h                                                                                           0100644 0001750 0001750 00000006043 12160377112 041540  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy/weave/blitz/blitz                                  /***************************************************************************
 * blitz/mattoep.h      Declarations for Toeplitz matrices
 *
 * $Id: mattoep.h 1414 2005-11-01 22:04:59Z cookedm $
 *
 * Copyright (C) 1997-2001 Todd Veldhuizen <tveldhui@oonumerics.org>
 *
 * This code was relicensed under the modified BSD license for use in SciPy
 * by Todd Veldhuizen (see LICENSE.txt in the weave directory).
 *
 *
 * Suggestions:          blitz-dev@oonumerics.org
 * Bugs:                 blitz-bugs@oonumerics.org
 *
 * For more information, please see the Blitz++ Home Page:
 *    http://oonumerics.org/blitz/
 *
 ***************************************************************************/

#ifndef BZ_MATTOEP_H
#define BZ_MATTOEP_H

#ifndef BZ_MSTRUCT_H
 #error <blitz/mattoep.h> must be included via <blitz/mstruct.h>
#endif

BZ_NAMESPACE(blitz)

// Toeplitz matrix
// [ 0 1 2 3 ]
// [ 1 2 3 4 ]
// [ 2 3 4 5 ]
// [ 3 4 5 6 ]

class ToeplitzIterator {
public:
    ToeplitzIterator(unsigned rows, unsigned cols)
    {
        rows_ = rows;
        cols_ = cols;
        i_ = 0;
        j_ = 0;
        good_ = true;
        offset_ = 0;
    }

    operator bool() const { return good_; }

    void operator++()
    {
        ++offset_;
        if (i_ < rows_ - 1)
            ++i_;
        else if (j_ < cols_ - 1)
            ++j_;
        else
            good_ = false;
    }

    unsigned row() const
    { return i_; }

    unsigned col() const
    { return j_; }

    unsigned offset() const
    { return offset_; }

protected:
    unsigned offset_;
    unsigned i_, j_;
    unsigned rows_, cols_;
    bool     good_;
};

class Toeplitz : public GeneralMatrix {

public:
    typedef ToeplitzIterator T_iterator;

    Toeplitz()
        : rows_(0), cols_(0)
    { }

    Toeplitz(unsigned rows, unsigned cols)
        : rows_(rows), cols_(cols)
    { }

    unsigned columns() const
    { return cols_; }

    unsigned coordToOffset(unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return i + j;
    }

    unsigned firstInRow(unsigned i) const
    { return 0; }

    template<typename T_numtype>
    T_numtype get(const T_numtype * restrict data,
        unsigned i, unsigned j) const
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    template<typename T_numtype>
    T_numtype& get(T_numtype * restrict data, unsigned i, unsigned j)
    {
        BZPRECONDITION(inRange(i,j));
        return data[coordToOffset(i,j)];
    }

    unsigned lastInRow(const unsigned)  const { return cols_ - 1; }
    unsigned firstInCol(const unsigned) const { return 0; }
    unsigned lastInCol(const unsigned)  const { return rows_ - 1; }

    bool inRange(const unsigned i,const unsigned j) const { return (i<rows_) && (j<cols_); }

    unsigned numElements() const { return rows_ + cols_ - 1; }

    unsigned rows() const { return rows_; }

    void resize(const unsigned rows,const unsigned cols) {
        rows_ = rows;
        cols_ = cols;
    }

private:
    unsigned rows_, cols_;
};

BZ_NAME