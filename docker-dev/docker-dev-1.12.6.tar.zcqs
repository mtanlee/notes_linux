alue indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`passed\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`actual_passed\*(C'\fR.  The latter method is deprecated
and will issue a warning.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 1
\&  if ( $test\->is_unplanned ) { ... }
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR (see
TAP::Parser::Result::Test for more information about this).
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1TODO\s0
directive.
.PP
Note that \s-1TODO\s0 tests \fIalways\fR pass.  If you need to know whether or not
they really passed, check the \f(CW\*(C`is_actual_ok\*(C'\fR method.
.PP
\fI\f(CI\*(C`in_todo\*(C'\fI\fR
.IX Subsection "in_todo"
.PP
.Vb 1
\&  if ( $parser\->in_todo ) { ... }
.Ve
.PP
True while the most recent result was a \s-1TODO.\s0 Becomes true before the
\&\s-1TODO\s0 result is returned and stays true until just before the next non\-
\&\s-1TODO\s0 test is returned.
.SH "TOTAL RESULTS"
.IX Header "TOTAL RESULTS"
After parsing the \s-1TAP,\s0 there are many methods available to let you dig through
the results and determine what is meaningful to you.
.SS "Individual Results"
.IX Subsection "Individual Results"
These results refer to individual tests which are run.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
.Vb 2
\& my @passed = $parser\->passed; # the test numbers which passed
\& my $passed = $parser\->passed; # the number of tests which passed
.Ve
.PP
This method lets you know which (or how many) tests passed.  If a test failed
but had a \s-1TODO\s0 directive, it will be counted as a passed test.
.PP
\fI\f(CI\*(C`failed\*(C'\fI\fR
.IX Subsection "failed"
.PP
.Vb 2
\& my @failed = $parser\->failed; # the test numbers which failed
\& my $failed = $parser\->failed; # the number of tests which failed
.Ve
.PP
This method lets you know which (or how many) tests failed.  If a test passed
but had a \s-1TODO\s0 directive, it will \fB\s-1NOT\s0\fR be counted as a failed test.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
.Vb 2
\& # the test numbers which actually passed
\& my @actual_passed = $parser\->actual_passed;
\&
\& # the number of tests which actually passed
\& my $actual_passed = $parser\->actual_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`actual_ok\*(C'\fI\fR
.IX Subsection "actual_ok"
.PP
This method is a synonym for \f(CW\*(C`actual_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`actual_failed\*(C'\fI\fR
.IX Subsection "actual_failed"
.PP
.Vb 2
\& # the test numbers which actually failed
\& my @actual_failed = $parser\->actual_failed;
\&
\& # the number of tests which actually failed
\& my $actual_failed = $parser\->actual_failed;
.Ve
.PP
This method lets you know which (or how many) tests actually failed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`todo\*(C'\fI\fR
.IX Subsection "todo"
.PP
.Vb 2
\& my @todo = $parser\->todo; # the test numbers with todo directives
\& my $todo = $parser\->todo; # the number of tests with todo directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1TODO\s0 directives.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 2
\& # the test numbers which unexpectedly succeeded
\& my @todo_passed = $parser\->todo_passed;
\&
\& # the number of tests which unexpectedly succeeded
\& my $todo_passed = $parser\->todo_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed but were
declared as \*(L"\s-1TODO\*(R"\s0 tests.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`skipped\*(C'\fI\fR
.IX Subsection "skipped"
.PP
.Vb 2
\& my @skipped = $parser\->skipped; # the test numbers with SKIP directives
\& my $skipped = $parser\->skipped; # the number of tests with SKIP directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1SKIP\s0 directives.
.SS "Pragmas"
.IX Subsection "Pragmas"
\fI\f(CI\*(C`pragma\*(C'\fI\fR
.IX Subsection "pragma"
.PP
Get or set a pragma. To get the state of a pragma:
.PP
.Vb 3
\&  if ( $p\->pragma(\*(Aqstrict\*(Aq) ) {
\&      # be strict
\&  }
.Ve
.PP
To set the state of a pragma:
.PP
.Vb 1
\&  $p\->pragma(\*(Aqstrict\*(Aq, 1); # enable strict mode
.Ve
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Get a list of all the currently enabled pragmas:
.PP
.Vb 1
\&  my @pragmas_enabled = $p\->pragmas;
.Ve
.SS "Summary Results"
.IX Subsection "Summary Results"
These results are \*(L"meta\*(R" information about the total results of an individual
test program.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 1
\& my $plan = $parser\->plan;
.Ve
.PP
Returns the test plan, if found.
.PP
\fI\f(CI\*(C`good_plan\*(C'\fI\fR
.IX Subsection "good_plan"
.PP
Deprecated.  Use \f(CW\*(C`is_good_plan\*(C'\fR instead.
.PP
\fI\f(CI\*(C`is_good_plan\*(C'\fI\fR
.IX Subsection "is_good_plan"
.PP
.Vb 1
\&  if ( $parser\->is_good_plan ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the number of tests planned
matches the number of tests run.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`good_plan\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
And since we're on that subject ...
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  print $parser\->tests_planned;
.Ve
.PP
Returns the number of tests planned, according to the plan.  For example, a
plan of '1..17' will mean that 17 tests were planned.
.PP
\fI\f(CI\*(C`tests_run\*(C'\fI\fR
.IX Subsection "tests_run"
.PP
.Vb 1
\&  print $parser\->tests_run;
.Ve
.PP
Returns the number of tests which actually were run.  Hopefully this will
match the number of \f(CW\*(C`$parser\->tests_planned\*(C'\fR.
.PP
\fI\f(CI\*(C`skip_all\*(C'\fI\fR
.IX Subsection "skip_all"
.PP
Returns a true value (actually the reason for skipping) if all tests
were skipped.
.PP
\fI\f(CI\*(C`start_time\*(C'\fI\fR
.IX Subsection "start_time"
.PP
Returns the time when the Parser was created.
.PP
\fI\f(CI\*(C`end_time\*(C'\fI\fR
.IX Subsection "end_time"
.PP
Returns the time when the end of \s-1TAP\s0 input was seen.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
This is a 'catch\-all' method which returns true if any tests have currently
failed, any \s-1TODO\s0 tests unexpectedly succeeded, or any parse errors occurred.
.PP
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 1
\&  $parser\->version;
.Ve
.PP
Once the parser is done, this will return the version number for the
parsed \s-1TAP.\s0 Version numbers were introduced with \s-1TAP\s0 version 13 so if no
version number is found version 12 is assumed.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
.Vb 1
\&  $parser\->exit;
.Ve
.PP
Once the parser is done, this will return the exit status.  If the parser ran
an executable, it returns the exit status of the executable.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
.Vb 1
\&  $parser\->wait;
.Ve
.PP
Once the parser is done, this will return the wait status.  If the parser ran
an executable, it returns the wait status of the executable.  Otherwise, this
merely returns the \f(CW\*(C`exit\*(C'\fR status.
.ie n .SS """ignore_exit"""
.el .SS "\f(CWignore_exit\fP"
.IX Subsection "ignore_exit"
.Vb 1
\&  $parser\->ignore_exit(1);
.Ve
.PP
Tell the parser to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit status are
considered to have failed even if all individual tests passed. In cases
where it is not possible to control the exit value of the test script
use this option to ignore it.
.PP
\fI\f(CI\*(C`parse_errors\*(C'\fI\fR
.IX Subsection "parse_errors"
.PP
.Vb 2
\& my @errors = $parser\->parse_errors; # the parser errors
\& my $errors = $parser\->parse_errors; # the number of parser_errors
.Ve
.PP
Fortunately, all \s-1TAP\s0 output is perfect.  In the event that it is not, this
method will return parser errors.  Note that a junk line which the parser does
not recognize is \f(CW\*(C`not\*(C'\fR an error.  This allows this parser to handle future
versions of \s-1TAP. \s0 The following are all \s-1TAP\s0 errors reported by the parser:
.IP "\(bu" 4
Misplaced plan
.Sp
The plan (for example, '1..5'), must only come at the beginning or end of the
\&\s-1TAP\s0 output.
.IP "\(bu" 4
No plan
.Sp
Gotta have a plan!
.IP "\(bu" 4
More than one plan
.Sp
.Vb 5
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
\& 1..3
.Ve
.Sp
Right.  Very funny.  Don't do that.
.IP "\(bu" 4
Test numbers out of sequence
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
That last test line above should have the number '3' instead of '2'.
.Sp
Note that it's perfectly acceptable for some lines to have test numbers and
others to not have them.  However, when a test number is found, it must be in
sequence.  The following is also an error:
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
But this is not:
.Sp
.Vb 4
\& 1..3
\& ok  \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
.Ve
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Get an a list of file handles which can be passed to \f(CW\*(C`select\*(C'\fR to
determine the readiness of this parser.
.PP
\fI\f(CI\*(C`delete_spool\*(C'\fI\fR
.IX Subsection "delete_spool"
.PP
Delete and return the spool.
.PP
.Vb 1
\&  my $fh = $parser\->delete_spool;
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
As mentioned earlier, a \*(L"callback\*(R" key may be added to the
\&\f(CW\*(C`TAP::Parser\*(C'\fR constructor. If present, each callback corresponding to a
given result type will be called with the result as the argument if the
\&\f(CW\*(C`run\*(C'\fR method is used. The callback is expected to be a subroutine
reference (or anonymous subroutine) which is invoked with the parser
result as its argument.
.PP
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& my $aggregator = TAP::Parser::Aggregator\->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.PP
Callbacks may also be added like this:
.PP
.Vb 2
\& $parser\->callback( test => \e&test_callback );
\& $parser\->callback( plan => \e&plan_callback );
.Ve
.PP
The following keys allowed for callbacks. These keys are case-sensitive.
.IP "\(bu" 4
\&\f(CW\*(C`test\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_test\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`version\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_version\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`plan\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_plan\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`comment\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_comment\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`bailout\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`yaml\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_yaml\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`unknown\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`ELSE\*(C'\fR
.Sp
If a result does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are specified as
callbacks, this callback will \fInever\fR be invoked.
.IP "\(bu" 4
\&\f(CW\*(C`ALL\*(C'\fR
.Sp
This callback will always be invoked and this will happen for each
result after one of the above callbacks is invoked.  For example, if
Term::ANSIColor is loaded, you could use the following to color your
test output:
.Sp
.Vb 12
\& my %callbacks = (
\&     test => sub {
\&         my $test = shift;
\&         if ( $test\->is_ok && not $test\->directive ) {
\&             # normal passing test
\&             print color \*(Aqgreen\*(Aq;
\&         }
\&         elsif ( !$test\->is_ok ) {    # even if it\*(Aqs TODO
\&             print color \*(Aqwhite on_red\*(Aq;
\&         }
\&         elsif ( $test\->has_skip ) {
\&             print color \*(Aqwhite on_blue\*(Aq;
\&
\&         }
\&         elsif ( $test\->has_todo ) {
\&             print color \*(Aqwhite\*(Aq;
\&         }
\&     },
\&     ELSE => sub {
\&         # plan, comment, and so on (anything which isn\*(Aqt a test line)
\&         print color \*(Aqblack on_white\*(Aq;
\&     },
\&     ALL => sub {
\&         # now print them
\&         print shift\->as_string;
\&         print color \*(Aqreset\*(Aq;
\&         print "\en";
\&     },
\& );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`EOF\*(C'\fR
.Sp
Invoked when there are no more lines to be parsed. Since there is no
accompanying TAP::Parser::Result object the \f(CW\*(C`TAP::Parser\*(C'\fR object is
passed instead.
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
If you're looking for an \s-1EBNF\s0 grammar, see TAP::Parser::Grammar.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
The Perl-QA list attempted to ensure backwards compatibility with
Test::Harness.  However, there are some minor differences.
.SS "Differences"
.IX Subsection "Differences"
.IP "\(bu" 4
\&\s-1TODO\s0 plans
.Sp
A little-known feature of Test::Harness is that it supported \s-1TODO\s0
lists in the plan:
.Sp
.Vb 3
\& 1..2 todo 2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated
.Ve
.Sp
Under Test::Harness, test number 2 would \fIpass\fR because it was
listed as a \s-1TODO\s0 test on the plan line. However, we are not aware of
anyone actually using this feature and hard-coding test numbers is
discouraged because it's very easy to add a test and break the test
number sequence. This makes test suites very fragile. Instead, the
following should be used:
.Sp
.Vb 3
\& 1..2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated # TODO
.Ve
.IP "\(bu" 4
\&'Missing' tests
.Sp
It rarely happens, but sometimes a harness might encounter
\&'missing tests:
.Sp
.Vb 5
\& ok 1
\& ok 2
\& ok 15
\& ok 16
\& ok 17
.Ve
.Sp
Test::Harness would report tests 3\-14 as having failed. For the
\&\f(CW\*(C`TAP::Parser\*(C'\fR, these tests are not considered failed because they've
never run. They're reported as parse failures (tests out of sequence).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you find you need to provide custom functionality (as you would have using
Test::Harness::Straps), you're in luck: \f(CW\*(C`TAP::Parser\*(C'\fR and friends are
designed to be easily plugged-into and/or subclassed.
.PP
Before you start, it's important to know a few things:
.IP "1." 2
All \f(CW\*(C`TAP::*\*(C'\fR objects inherit from TAP::Object.
.IP "2." 2
Many \f(CW\*(C`TAP::*\*(C'\fR classes have a \fI\s-1SUBCLASSING\s0\fR section to guide you.
.IP "3." 2
Note that \f(CW\*(C`TAP::Parser\*(C'\fR is designed to be the central \*(L"maker\*(R" \- ie: it is
responsible for creating most new objects in the \f(CW\*(C`TAP::Parser::*\*(C'\fR namespace.
.Sp
This makes it possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases you'll find
you only need to sub-class one of the parser's components.
.Sp
The exception to this rule are \fISourceHandlers\fR & \fIIterators\fR, but those are
both created with customizable \fIIteratorFactory\fR.
.IP "4." 2
By subclassing, you may end up overriding undocumented methods.  That's not
a bad thing per se, but be forewarned that undocumented methods may change
without warning from one release to the next \- we cannot guarantee backwards
compatibility.  If any \fIdocumented\fR method needs changing, it will be
deprecated first, and changed in a later release.
.SS "Parser Components"
.IX Subsection "Parser Components"
\fISources\fR
.IX Subsection "Sources"
.PP
A \s-1TAP\s0 parser consumes input from a single \fIraw source\fR of \s-1TAP,\s0 which could come
from anywhere (a file, an executable, a database, an \s-1IO\s0 handle, a \s-1URI,\s0 etc..).
The source gets bundled up in a TAP::Parser::Source object which gathers some
meta data about it.  The parser then uses a TAP::Parser::IteratorFactory to
determine which TAP::Parser::SourceHandler to use to turn the raw source
into a stream of \s-1TAP\s0 by way of \*(L"Iterators\*(R".
.PP
If you simply want \f(CW\*(C`TAP::Parser\*(C'\fR to handle a new source of \s-1TAP\s0 you probably
don't need to subclass \f(CW\*(C`TAP::Parser\*(C'\fR itself.  Rather, you'll need to create a
new TAP::Parser::SourceHandler class, and just plug it into the parser using
the \fIsources\fR param to \*(L"new\*(R".  Before you start writing one, read through
TAP::Parser::IteratorFactory to get a feel for how the system works first.
.PP
If you find you really need to use your own iterator factory you can still do
so without sub-classing \f(CW\*(C`TAP::Parser\*(C'\fR by setting \*(L"iterator_factory_class\*(R".
.PP
If you just need to customize the objects on creation, subclass TAP::Parser
and override \*(L"make_iterator_factory\*(R".
.PP
Note that \*(L"make_source\*(R" & \*(L"make_perl_source\*(R" have been \fI\s-1DEPRECATED\s0\fR and
are now removed.
.PP
\fIIterators\fR
.IX Subsection "Iterators"
.PP
A \s-1TAP\s0 parser uses \fIiterators\fR to loop through the \fIstream\fR of \s-1TAP\s0 read in
from the \fIsource\fR it was given.  There are a few types of Iterators available
by default, all sub-classes of TAP::Parser::Iterator.  Choosing which
iterator to use is the responsibility of the \fIiterator factory\fR, though it
simply delegates to the \fISource Handler\fR it uses.
.PP
If you're writing your own TAP::Parser::SourceHandler, you may need to
create your own iterators too.  If so you'll need to subclass
TAP::Parser::Iterator.
.PP
Note that \*(L"make_iterator\*(R" has been \fI\s-1DEPRECATED\s0\fR and is now removed.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
A \s-1TAP\s0 parser creates TAP::Parser::Results as it iterates through the
input \fIstream\fR.  There are quite a few result types available; choosing
which class to use is the responsibility of the \fIresult factory\fR.
.PP
To create your own result types you have two options:
.IP "option 1" 2
.IX Item "option 1"
Subclass TAP::Parser::Result and register your new result type/class with
the default TAP::Parser::ResultFactory.
.IP "option 2" 2
.IX Item "option 2"
Subclass TAP::Parser::ResultFactory itself and implement your own
TAP::Parser::Result creation logic.  Then you'll need to customize the
class used by your parser by setting the \f(CW\*(C`result_factory_class\*(C'\fR parameter.
See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_result\*(R".
.PP
\fIGrammar\fR
.IX Subsection "Grammar"
.PP
TAP::Parser::Grammar is the heart of the parser.  It tokenizes the \s-1TAP\s0
input \fIstream\fR and produces results.  If you need to customize its behaviour
you should probably familiarize yourself with the source first.  Enough
lecturing.
.PP
Subclass TAP::Parser::Grammar and customize your parser by setting the
\&\f(CW\*(C`grammar_class\*(C'\fR parameter.  See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_grammar\*(R"
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
All of the following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been forthcoming.
.IP "\(bu" 4
Michael Schwern
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
chromatic
.IP "\(bu" 4
\&\s-1GEOFFR\s0
.IP "\(bu" 4
Shlomi Fish
.IP "\(bu" 4
Torsten Schoenfeld
.IP "\(bu" 4
Jerry Gay
.IP "\(bu" 4
Aristotle
.IP "\(bu" 4
Adam Kennedy
.IP "\(bu" 4
Yves Orton
.IP "\(bu" 4
Adrian Howard
.IP "\(bu" 4
Sean & Lil
.IP "\(bu" 4
Andreas J. Koenig
.IP "\(bu" 4
Florian Ragwitz
.IP "\(bu" 4
Corion
.IP "\(bu" 4
Mark Stosberg
.IP "\(bu" 4
Matt Kraai
.IP "\(bu" 4
David Wheeler
.IP "\(bu" 4
Alex Vandiver
.IP "\(bu" 4
Cosimo Streppone
.IP "\(bu" 4
Ville Skytta\*:
.SH "AUTHORS"
.IX Header "AUTHORS"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.PP
Andy Armstong <andy@hexten.net>
.PP
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
Michael Peters <mpeters at plusthree dot com>
.PP
Leif Eriksen <leif dot eriksen at bigpond dot com>
.PP
Steve Purkis <spurkis@cpan.org>
.PP
Nicholas Clark <nick@ccl4.org>
.PP
Lee Johnson <notfadeaway at btinternet dot com>
.PP
Philippe Bruhat <book@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-harness@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Harness>.
We will be notified, and then you'll automatically be notified of
progress on your bug as we make changes.
.PP
Obviously, bugs which include patches are best. If you prefer, you can
patch against bleed by via anonymous checkout of the latest version:
.PP
.Vb 1
\& git clone git://github.com/Perl\-Toolchain\-Gang/Test\-Harness.git
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2008 Curtis \*(L"Ovid\*(R" Poe, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1852:" 4
.IX Item "Around line 1852:"
Non-ASCII character seen before =encoding in 'Skytta\*:'. Assuming \s-1UTF\-8\s0
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser5.16.3pm                          0100644 0001750 0001750 00000124707 12566207441 023612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser 3pm"
.TH TAP::Parser 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser \- Parse TAP output
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser;
\&
\&    my $parser = TAP::Parser\->new( { source => $source } );
\&
\&    while ( my $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser\*(C'\fR is designed to produce a proper parse of \s-1TAP\s0 output. For
an example of how to run tests through this module, see the simple
harnesses \f(CW\*(C`examples/\*(C'\fR.
.PP
There's a wiki dedicated to the Test Anything Protocol:
.PP
<http://testanything.org>
.PP
It includes the TAP::Parser Cookbook:
.PP
<http://testanything.org/wiki/index.php/TAP::Parser_Cookbook>
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $parser = TAP::Parser\->new(\e%args);
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser\*(C'\fR object.
.PP
The arguments should be a hashref with \fIone\fR of the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`source\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This is the preferred method of passing input to the constructor.
.Sp
The \f(CW\*(C`source\*(C'\fR is used to create a TAP::Parser::Source that is passed to the
\&\*(L"iterator_factory_class\*(R" which in turn figures out how to handle the source and
creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`tap\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
The value should be the complete \s-1TAP\s0 output.
.Sp
The \fItap\fR is used to create a TAP::Parser::Source that is passed to the
\&\*(L"iterator_factory_class\*(R" which in turn figures out how to handle the source and
creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`exec\*(C'\fR
.Sp
Must be passed an array reference.
.Sp
The \fIexec\fR array ref is used to create a TAP::Parser::Source that is passed
to the \*(L"iterator_factory_class\*(R" which in turn figures out how to handle the
source and creates a <TAP::Parser::Iterator> for it.  The iterator is used by
the parser to read in the \s-1TAP\s0 stream.
.Sp
By default the TAP::Parser::SourceHandler::Executable class will create a
TAP::Parser::Iterator::Process object to handle the source.  This passes the
array reference strings as command arguments to IPC::Open3::open3:
.Sp
.Vb 1
\& exec => [ \*(Aq/usr/bin/ruby\*(Aq, \*(Aqt/my_test.rb\*(Aq ]
.Ve
.Sp
If any \f(CW\*(C`test_args\*(C'\fR are given they will be appended to the end of the command
argument list.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.PP
The following keys are optional.
.IP "\(bu" 4
\&\f(CW\*(C`sources\*(C'\fR
.Sp
\&\fI\s-1NEW\s0 to 3.18\fR.
.Sp
If set, \f(CW\*(C`sources\*(C'\fR must be a hashref containing the names of the
TAP::Parser::SourceHandlers to load and/or configure.  The values are a
hash of configuration that will be accessible to to the source handlers via
\&\*(L"config_for\*(R" in TAP::Parser::Source.
.Sp
For example:
.Sp
.Vb 5
\&  sources => {
\&    Perl => { exec => \*(Aq/path/to/custom/perl\*(Aq },
\&    File => { extensions => [ \*(Aq.tap\*(Aq, \*(Aq.txt\*(Aq ] },
\&    MyCustom => { some => \*(Aqconfig\*(Aq },
\&  }
.Ve
.Sp
This will cause \f(CW\*(C`TAP::Parser\*(C'\fR to pass custom configuration to two of the built\-
in source handlers \- TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File \- and attempt to load the \f(CW\*(C`MyCustom\*(C'\fR
class.  See \*(L"load_handlers\*(R" in TAP::Parser::IteratorFactory for more detail.
.Sp
The \f(CW\*(C`sources\*(C'\fR parameter affects how \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR parameters
are handled.
.Sp
See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and subclasses for
more details.
.IP "\(bu" 4
\&\f(CW\*(C`callback\*(C'\fR
.Sp
If present, each callback corresponding to a given result type will be called
with the result as the argument if the \f(CW\*(C`run\*(C'\fR method is used:
.Sp
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& my $aggregator = TAP::Parser::Aggregator\->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`switches\*(C'\fR
.Sp
If using a Perl file as a source, optional switches may be passed which will
be used when invoking the perl executable.
.Sp
.Vb 4
\& my $parser = TAP::Parser\->new( {
\&     source   => $test_file,
\&     switches => [ \*(Aq\-Ilib\*(Aq ],
\& } );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`test_args\*(C'\fR
.Sp
Used in conjunction with the \f(CW\*(C`source\*(C'\fR and \f(CW\*(C`exec\*(C'\fR option to supply a reference
to an \f(CW@ARGV\fR style array of arguments to pass to the test program.
.IP "\(bu" 4
\&\f(CW\*(C`spool\*(C'\fR
.Sp
If passed a filehandle will write a copy of all parsed \s-1TAP\s0 to that handle.
.IP "\(bu" 4
\&\f(CW\*(C`merge\*(C'\fR
.Sp
If false, \s-1STDERR\s0 is not captured (though it is 'relayed' to keep it
somewhat synchronized with \s-1STDOUT\s0.)
.Sp
If true, \s-1STDERR\s0 and \s-1STDOUT\s0 are the same filehandle.  This may cause
breakage if \s-1STDERR\s0 contains anything resembling \s-1TAP\s0 format, but does
allow exact synchronization.
.Sp
Subtleties of this behavior may be platform-dependent and may change in
the future.
.IP "\(bu" 4
\&\f(CW\*(C`grammar_class\*(C'\fR
.Sp
This option was introduced to let you easily customize which \fIgrammar\fR class
the parser should use.  It defaults to TAP::Parser::Grammar.
.Sp
See also \*(L"make_grammar\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`result_factory_class\*(C'\fR
.Sp
This option was introduced to let you easily customize which \fIresult\fR
factory class the parser should use.  It defaults to
TAP::Parser::ResultFactory.
.Sp
See also \*(L"make_result\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`iterator_factory_class\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This option was introduced to let you easily customize which \fIiterator\fR
factory class the parser should use.  It defaults to
TAP::Parser::IteratorFactory.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 4
\&  my $parser = TAP::Parser\->new( { source => $file } );
\&  while ( my $result = $parser\->next ) {
\&      print $result\->as_string, "\en";
\&  }
.Ve
.PP
This method returns the results of the parsing, one result at a time.  Note
that it is destructive.  You can't rewind and examine previous results.
.PP
If callbacks are used, they will be issued before this call returns.
.PP
Each result returned is a subclass of TAP::Parser::Result.  See that
module and related classes for more information on how to use them.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $parser\->run;
.Ve
.PP
This method merely runs the parser and parses all of the \s-1TAP\s0.
.PP
\fI\f(CI\*(C`make_grammar\*(C'\fI\fR
.IX Subsection "make_grammar"
.PP
Make a new TAP::Parser::Grammar object and return it.  Passes through any
arguments given.
.PP
The \f(CW\*(C`grammar_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Make a new TAP::Parser::Result object using the parser's
TAP::Parser::ResultFactory, and return it.  Passes through any arguments
given.
.PP
The \f(CW\*(C`result_factory_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_iterator_factory\*(C'\fI\fR
.IX Subsection "make_iterator_factory"
.PP
\&\fI\s-1NEW\s0 to 3.18\fR.
.PP
Make a new TAP::Parser::IteratorFactory object and return it.  Passes through
any arguments given.
.PP
\&\f(CW\*(C`iterator_factory_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.SH "INDIVIDUAL RESULTS"
.IX Header "INDIVIDUAL RESULTS"
If you've read this far in the docs, you've seen this:
.PP
.Vb 3
\&    while ( my $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.PP
Each result returned is a TAP::Parser::Result subclass, referred to as
\&\fIresult types\fR.
.SS "Result types"
.IX Subsection "Result types"
Basically, you fetch individual results from the \s-1TAP\s0.  The six types, with
examples of each, are as follows:
.IP "\(bu" 4
Version
.Sp
.Vb 1
\& TAP version 12
.Ve
.IP "\(bu" 4
Plan
.Sp
.Vb 1
\& 1..42
.Ve
.IP "\(bu" 4
Pragma
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
Test
.Sp
.Vb 1
\& ok 3 \- We should start with some foobar!
.Ve
.IP "\(bu" 4
Comment
.Sp
.Vb 1
\& # Hope we don\*(Aqt use up the foobar.
.Ve
.IP "\(bu" 4
Bailout
.Sp
.Vb 1
\& Bail out!  We ran out of foobar!
.Ve
.IP "\(bu" 4
Unknown
.Sp
.Vb 1
\& ... yo, this ain\*(Aqt TAP! ...
.Ve
.PP
Each result fetched is a result object of a different type.  There are common
methods to each result object and different types may have methods unique to
their type.  Sometimes a type method may be overridden in a subclass, but its
use is guaranteed to be identical.
.SS "Common type methods"
.IX Subsection "Common type methods"
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
Returns the type of result, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
Returns the original line of text which was parsed.
.PP
\fI\f(CI\*(C`is_plan\*(C'\fI\fR
.IX Subsection "is_plan"
.PP
Indicates whether or not this is the test plan line.
.PP
\fI\f(CI\*(C`is_test\*(C'\fI\fR
.IX Subsection "is_test"
.PP
Indicates whether or not this is a test line.
.PP
\fI\f(CI\*(C`is_comment\*(C'\fI\fR
.IX Subsection "is_comment"
.PP
Indicates whether or not this is a comment. Comments will generally only
appear in the \s-1TAP\s0 stream if \s-1STDERR\s0 is merged to \s-1STDOUT\s0. See the
\&\f(CW\*(C`merge\*(C'\fR option.
.PP
\fI\f(CI\*(C`is_bailout\*(C'\fI\fR
.IX Subsection "is_bailout"
.PP
Indicates whether or not this is bailout line.
.PP
\fI\f(CI\*(C`is_yaml\*(C'\fI\fR
.IX Subsection "is_yaml"
.PP
Indicates whether or not the current item is a \s-1YAML\s0 block.
.PP
\fI\f(CI\*(C`is_unknown\*(C'\fI\fR
.IX Subsection "is_unknown"
.PP
Indicates whether or not the current line could be parsed.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut
which allows you to do this:
.PP
.Vb 5
\& my $parser = TAP::Parser\->new( { source => $source } );
\& while ( my $result = $parser\->next ) {
\&     # only print failing results
\&     print $result\->as_string unless $result\->is_ok;
\& }
.Ve
.ie n .SS """plan"" methods"
.el .SS "\f(CWplan\fP methods"
.IX Subsection "plan methods"
.Vb 1
\& if ( $result\->is_plan ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $result\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $result\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.ie n .SS """pragma"" methods"
.el .SS "\f(CWpragma\fP methods"
.IX Subsection "pragma methods"
.Vb 1
\& if ( $result\->is_pragma ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Returns a list of pragmas each of which is a + or \- followed by the
pragma name.
.ie n .SS """comment"" methods"
.el .SS "\f(CWcomment\fP methods"
.IX Subsection "comment methods"
.Vb 1
\& if ( $result\->is_comment ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      my $comment = $result\->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
.ie n .SS """bailout"" methods"
.el .SS "\f(CWbailout\fP methods"
.IX Subsection "bailout methods"
.Vb 1
\& if ( $result\->is_bailout ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      my $explanation = $result\->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
.PP
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
.ie n .SS """unknown"" methods"
.el .SS "\f(CWunknown\fP methods"
.IX Subsection "unknown methods"
.Vb 1
\& if ( $result\->is_unknown ) { ... }
.Ve
.PP
There are no unique methods for unknown results.
.ie n .SS """test"" methods"
.el .SS "\f(CWtest\fP methods"
.IX Subsection "test methods"
.Vb 1
\& if ( $result\->is_test ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result\->ok;
.Ve
.PP
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result\->number;
.Ve
.PP
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result\->description;
.Ve
.PP
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For the above line, the explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`passed\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`actual_passed\*(C'\fR.  The latter method is deprecated
and will issue a warning.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 1
\&  if ( $test\->is_unplanned ) { ... }
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR (see
TAP::Parser::Result::Test for more information about this).
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1TODO\s0
directive.
.PP
Note that \s-1TODO\s0 tests \fIalways\fR pass.  If you need to know whether or not
they really passed, check the \f(CW\*(C`is_actual_ok\*(C'\fR method.
.PP
\fI\f(CI\*(C`in_todo\*(C'\fI\fR
.IX Subsection "in_todo"
.PP
.Vb 1
\&  if ( $parser\->in_todo ) { ... }
.Ve
.PP
True while the most recent result was a \s-1TODO\s0. Becomes true before the
\&\s-1TODO\s0 result is returned and stays true until just before the next non\-
\&\s-1TODO\s0 test is returned.
.SH "TOTAL RESULTS"
.IX Header "TOTAL RESULTS"
After parsing the \s-1TAP\s0, there are many methods available to let you dig through
the results and determine what is meaningful to you.
.SS "Individual Results"
.IX Subsection "Individual Results"
These results refer to individual tests which are run.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
.Vb 2
\& my @passed = $parser\->passed; # the test numbers which passed
\& my $passed = $parser\->passed; # the number of tests which passed
.Ve
.PP
This method lets you know which (or how many) tests passed.  If a test failed
but had a \s-1TODO\s0 directive, it will be counted as a passed test.
.PP
\fI\f(CI\*(C`failed\*(C'\fI\fR
.IX Subsection "failed"
.PP
.Vb 2
\& my @failed = $parser\->failed; # the test numbers which failed
\& my $failed = $parser\->failed; # the number of tests which failed
.Ve
.PP
This method lets you know which (or how many) tests failed.  If a test passed
but had a \s-1TODO\s0 directive, it will \fB\s-1NOT\s0\fR be counted as a failed test.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
.Vb 2
\& # the test numbers which actually passed
\& my @actual_passed = $parser\->actual_passed;
\&
\& # the number of tests which actually passed
\& my $actual_passed = $parser\->actual_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`actual_ok\*(C'\fI\fR
.IX Subsection "actual_ok"
.PP
This method is a synonym for \f(CW\*(C`actual_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`actual_failed\*(C'\fI\fR
.IX Subsection "actual_failed"
.PP
.Vb 2
\& # the test numbers which actually failed
\& my @actual_failed = $parser\->actual_failed;
\&
\& # the number of tests which actually failed
\& my $actual_failed = $parser\->actual_failed;
.Ve
.PP
This method lets you know which (or how many) tests actually failed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`todo\*(C'\fI\fR
.IX Subsection "todo"
.PP
.Vb 2
\& my @todo = $parser\->todo; # the test numbers with todo directives
\& my $todo = $parser\->todo; # the number of tests with todo directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1TODO\s0 directives.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 2
\& # the test numbers which unexpectedly succeeded
\& my @todo_passed = $parser\->todo_passed;
\&
\& # the number of tests which unexpectedly succeeded
\& my $todo_passed = $parser\->todo_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed but were
declared as \*(L"\s-1TODO\s0\*(R" tests.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`skipped\*(C'\fI\fR
.IX Subsection "skipped"
.PP
.Vb 2
\& my @skipped = $parser\->skipped; # the test numbers with SKIP directives
\& my $skipped = $parser\->skipped; # the number of tests with SKIP directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1SKIP\s0 directives.
.SS "Pragmas"
.IX Subsection "Pragmas"
\fI\f(CI\*(C`pragma\*(C'\fI\fR
.IX Subsection "pragma"
.PP
Get or set a pragma. To get the state of a pragma:
.PP
.Vb 3
\&  if ( $p\->pragma(\*(Aqstrict\*(Aq) ) {
\&      # be strict
\&  }
.Ve
.PP
To set the state of a pragma:
.PP
.Vb 1
\&  $p\->pragma(\*(Aqstrict\*(Aq, 1); # enable strict mode
.Ve
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Get a list of all the currently enabled pragmas:
.PP
.Vb 1
\&  my @pragmas_enabled = $p\->pragmas;
.Ve
.SS "Summary Results"
.IX Subsection "Summary Results"
These results are \*(L"meta\*(R" information about the total results of an individual
test program.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 1
\& my $plan = $parser\->plan;
.Ve
.PP
Returns the test plan, if found.
.PP
\fI\f(CI\*(C`good_plan\*(C'\fI\fR
.IX Subsection "good_plan"
.PP
Deprecated.  Use \f(CW\*(C`is_good_plan\*(C'\fR instead.
.PP
\fI\f(CI\*(C`is_good_plan\*(C'\fI\fR
.IX Subsection "is_good_plan"
.PP
.Vb 1
\&  if ( $parser\->is_good_plan ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the number of tests planned
matches the number of tests run.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`good_plan\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
And since we're on that subject ...
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  print $parser\->tests_planned;
.Ve
.PP
Returns the number of tests planned, according to the plan.  For example, a
plan of '1..17' will mean that 17 tests were planned.
.PP
\fI\f(CI\*(C`tests_run\*(C'\fI\fR
.IX Subsection "tests_run"
.PP
.Vb 1
\&  print $parser\->tests_run;
.Ve
.PP
Returns the number of tests which actually were run.  Hopefully this will
match the number of \f(CW\*(C`$parser\->tests_planned\*(C'\fR.
.PP
\fI\f(CI\*(C`skip_all\*(C'\fI\fR
.IX Subsection "skip_all"
.PP
Returns a true value (actually the reason for skipping) if all tests
were skipped.
.PP
\fI\f(CI\*(C`start_time\*(C'\fI\fR
.IX Subsection "start_time"
.PP
Returns the time when the Parser was created.
.PP
\fI\f(CI\*(C`end_time\*(C'\fI\fR
.IX Subsection "end_time"
.PP
Returns the time when the end of \s-1TAP\s0 input was seen.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
This is a 'catch\-all' method which returns true if any tests have currently
failed, any \s-1TODO\s0 tests unexpectedly succeeded, or any parse errors occurred.
.PP
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 1
\&  $parser\->version;
.Ve
.PP
Once the parser is done, this will return the version number for the
parsed \s-1TAP\s0. Version numbers were introduced with \s-1TAP\s0 version 13 so if no
version number is found version 12 is assumed.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
.Vb 1
\&  $parser\->exit;
.Ve
.PP
Once the parser is done, this will return the exit status.  If the parser ran
an executable, it returns the exit status of the executable.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
.Vb 1
\&  $parser\->wait;
.Ve
.PP
Once the parser is done, this will return the wait status.  If the parser ran
an executable, it returns the wait status of the executable.  Otherwise, this
merely returns the \f(CW\*(C`exit\*(C'\fR status.
.ie n .SS """ignore_exit"""
.el .SS "\f(CWignore_exit\fP"
.IX Subsection "ignore_exit"
.Vb 1
\&  $parser\->ignore_exit(1);
.Ve
.PP
Tell the parser to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit status are
considered to have failed even if all individual tests passed. In cases
where it is not possible to control the exit value of the test script
use this option to ignore it.
.PP
\fI\f(CI\*(C`parse_errors\*(C'\fI\fR
.IX Subsection "parse_errors"
.PP
.Vb 2
\& my @errors = $parser\->parse_errors; # the parser errors
\& my $errors = $parser\->parse_errors; # the number of parser_errors
.Ve
.PP
Fortunately, all \s-1TAP\s0 output is perfect.  In the event that it is not, this
method will return parser errors.  Note that a junk line which the parser does
not recognize is \f(CW\*(C`not\*(C'\fR an error.  This allows this parser to handle future
versions of \s-1TAP\s0.  The following are all \s-1TAP\s0 errors reported by the parser:
.IP "\(bu" 4
Misplaced plan
.Sp
The plan (for example, '1..5'), must only come at the beginning or end of the
\&\s-1TAP\s0 output.
.IP "\(bu" 4
No plan
.Sp
Gotta have a plan!
.IP "\(bu" 4
More than one plan
.Sp
.Vb 5
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
\& 1..3
.Ve
.Sp
Right.  Very funny.  Don't do that.
.IP "\(bu" 4
Test numbers out of sequence
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
That last test line above should have the number '3' instead of '2'.
.Sp
Note that it's perfectly acceptable for some lines to have test numbers and
others to not have them.  However, when a test number is found, it must be in
sequence.  The following is also an error:
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
But this is not:
.Sp
.Vb 4
\& 1..3
\& ok  \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
.Ve
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Get an a list of file handles which can be passed to \f(CW\*(C`select\*(C'\fR to
determine the readiness of this parser.
.PP
\fI\f(CI\*(C`delete_spool\*(C'\fI\fR
.IX Subsection "delete_spool"
.PP
Delete and return the spool.
.PP
.Vb 1
\&  my $fh = $parser\->delete_spool;
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
As mentioned earlier, a \*(L"callback\*(R" key may be added to the
\&\f(CW\*(C`TAP::Parser\*(C'\fR constructor. If present, each callback corresponding to a
given result type will be called with the result as the argument if the
\&\f(CW\*(C`run\*(C'\fR method is used. The callback is expected to be a subroutine
reference (or anonymous subroutine) which is invoked with the parser
result as its argument.
.PP
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& my $aggregator = TAP::Parser::Aggregator\->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.PP
Callbacks may also be added like this:
.PP
.Vb 2
\& $parser\->callback( test => \e&test_callback );
\& $parser\->callback( plan => \e&plan_callback );
.Ve
.PP
The following keys allowed for callbacks. These keys are case-sensitive.
.IP "\(bu" 4
\&\f(CW\*(C`test\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_test\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`version\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_version\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`plan\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_plan\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`comment\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_comment\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`bailout\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`yaml\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_yaml\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`unknown\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`ELSE\*(C'\fR
.Sp
If a result does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are specified as
callbacks, this callback will \fInever\fR be invoked.
.IP "\(bu" 4
\&\f(CW\*(C`ALL\*(C'\fR
.Sp
This callback will always be invoked and this will happen for each
result after one of the above callbacks is invoked.  For example, if
Term::ANSIColor is loaded, you could use the following to color your
test output:
.Sp
.Vb 12
\& my %callbacks = (
\&     test => sub {
\&         my $test = shift;
\&         if ( $test\->is_ok && not $test\->directive ) {
\&             # normal passing test
\&             print color \*(Aqgreen\*(Aq;
\&         }
\&         elsif ( !$test\->is_ok ) {    # even if it\*(Aqs TODO
\&             print color \*(Aqwhite on_red\*(Aq;
\&         }
\&         elsif ( $test\->has_skip ) {
\&             print color \*(Aqwhite on_blue\*(Aq;
\&
\&         }
\&         elsif ( $test\->has_todo ) {
\&             print color \*(Aqwhite\*(Aq;
\&         }
\&     },
\&     ELSE => sub {
\&         # plan, comment, and so on (anything which isn\*(Aqt a test line)
\&         print color \*(Aqblack on_white\*(Aq;
\&     },
\&     ALL => sub {
\&         # now print them
\&         print shift\->as_string;
\&         print color \*(Aqreset\*(Aq;
\&         print "\en";
\&     },
\& );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`EOF\*(C'\fR
.Sp
Invoked when there are no more lines to be parsed. Since there is no
accompanying TAP::Parser::Result object the \f(CW\*(C`TAP::Parser\*(C'\fR object is
passed instead.
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
If you're looking for an \s-1EBNF\s0 grammar, see TAP::Parser::Grammar.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
The Perl-QA list attempted to ensure backwards compatibility with
Test::Harness.  However, there are some minor differences.
.SS "Differences"
.IX Subsection "Differences"
.IP "\(bu" 4
\&\s-1TODO\s0 plans
.Sp
A little-known feature of Test::Harness is that it supported \s-1TODO\s0
lists in the plan:
.Sp
.Vb 3
\& 1..2 todo 2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated
.Ve
.Sp
Under Test::Harness, test number 2 would \fIpass\fR because it was
listed as a \s-1TODO\s0 test on the plan line. However, we are not aware of
anyone actually using this feature and hard-coding test numbers is
discouraged because it's very easy to add a test and break the test
number sequence. This makes test suites very fragile. Instead, the
following should be used:
.Sp
.Vb 3
\& 1..2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated # TODO
.Ve
.IP "\(bu" 4
\&'Missing' tests
.Sp
It rarely happens, but sometimes a harness might encounter
\&'missing tests:
.Sp
.Vb 5
\& ok 1
\& ok 2
\& ok 15
\& ok 16
\& ok 17
.Ve
.Sp
Test::Harness would report tests 3\-14 as having failed. For the
\&\f(CW\*(C`TAP::Parser\*(C'\fR, these tests are not considered failed because they've
never run. They're reported as parse failures (tests out of sequence).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you find you need to provide custom functionality (as you would have using
Test::Harness::Straps), you're in luck: \f(CW\*(C`TAP::Parser\*(C'\fR and friends are
designed to be easily plugged-into and/or subclassed.
.PP
Before you start, it's important to know a few things:
.IP "1." 2
All \f(CW\*(C`TAP::*\*(C'\fR objects inherit from TAP::Object.
.IP "2." 2
Many \f(CW\*(C`TAP::*\*(C'\fR classes have a \fI\s-1SUBCLASSING\s0\fR section to guide you.
.IP "3." 2
Note that \f(CW\*(C`TAP::Parser\*(C'\fR is designed to be the central \*(L"maker\*(R" \- ie: it is
responsible for creating most new objects in the \f(CW\*(C`TAP::Parser::*\*(C'\fR namespace.
.Sp
This makes it possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases you'll find
you only need to sub-class one of the parser's components.
.Sp
The exception to this rule are \fISourceHandlers\fR & \fIIterators\fR, but those are
both created with customizable \fIIteratorFactory\fR.
.IP "4." 2
By subclassing, you may end up overriding undocumented methods.  That's not
a bad thing per se, but be forewarned that undocumented methods may change
without warning from one release to the next \- we cannot guarantee backwards
compatibility.  If any \fIdocumented\fR method needs changing, it will be
deprecated first, and changed in a later release.
.SS "Parser Components"
.IX Subsection "Parser Components"
\fISources\fR
.IX Subsection "Sources"
.PP
A \s-1TAP\s0 parser consumes input from a single \fIraw source\fR of \s-1TAP\s0, which could come
from anywhere (a file, an executable, a database, an \s-1IO\s0 handle, a \s-1URI\s0, etc..).
The source gets bundled up in a TAP::Parser::Source object which gathers some
meta data about it.  The parser then uses a TAP::Parser::IteratorFactory to
determine which TAP::Parser::SourceHandler to use to turn the raw source
into a stream of \s-1TAP\s0 by way of \*(L"Iterators\*(R".
.PP
If you simply want \f(CW\*(C`TAP::Parser\*(C'\fR to handle a new source of \s-1TAP\s0 you probably
don't need to subclass \f(CW\*(C`TAP::Parser\*(C'\fR itself.  Rather, you'll need to create a
new TAP::Parser::SourceHandler class, and just plug it into the parser using
the \fIsources\fR param to \*(L"new\*(R".  Before you start writing one, read through
TAP::Parser::IteratorFactory to get a feel for how the system works first.
.PP
If you find you really need to use your own iterator factory you can still do
so without sub-classing \f(CW\*(C`TAP::Parser\*(C'\fR by setting \*(L"iterator_factory_class\*(R".
.PP
If you just need to customize the objects on creation, subclass TAP::Parser
and override \*(L"make_iterator_factory\*(R".
.PP
Note that \*(L"make_source\*(R" & \*(L"make_perl_source\*(R" have been \fI\s-1DEPRECATED\s0\fR and
are now removed.
.PP
\fIIterators\fR
.IX Subsection "Iterators"
.PP
A \s-1TAP\s0 parser uses \fIiterators\fR to loop through the \fIstream\fR of \s-1TAP\s0 read in
from the \fIsource\fR it was given.  There are a few types of Iterators available
by default, all sub-classes of TAP::Parser::Iterator.  Choosing which
iterator to use is the responsibility of the \fIiterator factory\fR, though it
simply delegates to the \fISource Handler\fR it uses.
.PP
If you're writing your own TAP::Parser::SourceHandler, you may need to
create your own iterators too.  If so you'll need to subclass
TAP::Parser::Iterator.
.PP
Note that \*(L"make_iterator\*(R" has been \fI\s-1DEPRECATED\s0\fR and is now removed.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
A \s-1TAP\s0 parser creates TAP::Parser::Results as it iterates through the
input \fIstream\fR.  There are quite a few result types available; choosing
which class to use is the responsibility of the \fIresult factory\fR.
.PP
To create your own result types you have two options:
.IP "option 1" 2
.IX Item "option 1"
Subclass TAP::Parser::Result and register your new result type/class with
the default TAP::Parser::ResultFactory.
.IP "option 2" 2
.IX Item "option 2"
Subclass TAP::Parser::ResultFactory itself and implement your own
TAP::Parser::Result creation logic.  Then you'll need to customize the
class used by your parser by setting the \f(CW\*(C`result_factory_class\*(C'\fR parameter.
See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_result\*(R".
.PP
\fIGrammar\fR
.IX Subsection "Grammar"
.PP
TAP::Parser::Grammar is the heart of the parser.  It tokenizes the \s-1TAP\s0
input \fIstream\fR and produces results.  If you need to customize its behaviour
you should probably familiarize yourself with the source first.  Enough
lecturing.
.PP
Subclass TAP::Parser::Grammar and customize your parser by setting the
\&\f(CW\*(C`grammar_class\*(C'\fR parameter.  See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_grammar\*(R"
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
All of the following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been forthcoming.
.IP "\(bu" 4
Michael Schwern
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
chromatic
.IP "\(bu" 4
\&\s-1GEOFFR\s0
.IP "\(bu" 4
Shlomi Fish
.IP "\(bu" 4
Torsten Schoenfeld
.IP "\(bu" 4
Jerry Gay
.IP "\(bu" 4
Aristotle
.IP "\(bu" 4
Adam Kennedy
.IP "\(bu" 4
Yves Orton
.IP "\(bu" 4
Adrian Howard
.IP "\(bu" 4
Sean & Lil
.IP "\(bu" 4
Andreas J. Koenig
.IP "\(bu" 4
Florian Ragwitz
.IP "\(bu" 4
Corion
.IP "\(bu" 4
Mark Stosberg
.IP "\(bu" 4
Matt Kraai
.IP "\(bu" 4
David Wheeler
.IP "\(bu" 4
Alex Vandiver
.IP "\(bu" 4
Cosimo Streppone
.IP "\(bu" 4
Ville SkyttA\*~X
.SH "AUTHORS"
.IX Header "AUTHORS"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.PP
Andy Armstong <andy@hexten.net>
.PP
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
Michael Peters <mpeters at plusthree dot com>
.PP
Leif Eriksen <leif dot eriksen at bigpond dot com>
.PP
Steve Purkis <spurkis@cpan.org>
.PP
Nicholas Clark <nick@ccl4.org>
.PP
Lee Johnson <notfadeaway at btinternet dot com>
.PP
Philippe Bruhat <book@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-harness@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Harness <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness>.
We will be notified, and then you'll automatically be notified of
progress on your bug as we make changes.
.PP
Obviously, bugs which include patches are best. If you prefer, you can
patch against bleed by via anonymous checkout of the latest version:
.PP
.Vb 1
\& git clone git://github.com/AndyA/Test\-Harness.git
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2008 Curtis \*(L"Ovid\*(R" Poe, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser5.18.3pm                          0100644 0001750 0001750 00000125555 12566207463 023622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser 3pm"
.TH TAP::Parser 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser \- Parse TAP output
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser;
\&
\&    my $parser = TAP::Parser\->new( { source => $source } );
\&
\&    while ( my $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser\*(C'\fR is designed to produce a proper parse of \s-1TAP\s0 output. For
an example of how to run tests through this module, see the simple
harnesses \f(CW\*(C`examples/\*(C'\fR.
.PP
There's a wiki dedicated to the Test Anything Protocol:
.PP
<http://testanything.org>
.PP
It includes the TAP::Parser Cookbook:
.PP
<http://testanything.org/wiki/index.php/TAP::Parser_Cookbook>
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $parser = TAP::Parser\->new(\e%args);
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser\*(C'\fR object.
.PP
The arguments should be a hashref with \fIone\fR of the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`source\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This is the preferred method of passing input to the constructor.
.Sp
The \f(CW\*(C`source\*(C'\fR is used to create a TAP::Parser::Source that is passed to the
\&\*(L"iterator_factory_class\*(R" which in turn figures out how to handle the source and
creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`tap\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
The value should be the complete \s-1TAP\s0 output.
.Sp
The \fItap\fR is used to create a TAP::Parser::Source that is passed to the
\&\*(L"iterator_factory_class\*(R" which in turn figures out how to handle the source and
creates a <TAP::Parser::Iterator> for it.  The iterator is used by the parser to
read in the \s-1TAP\s0 stream.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`exec\*(C'\fR
.Sp
Must be passed an array reference.
.Sp
The \fIexec\fR array ref is used to create a TAP::Parser::Source that is passed
to the \*(L"iterator_factory_class\*(R" which in turn figures out how to handle the
source and creates a <TAP::Parser::Iterator> for it.  The iterator is used by
the parser to read in the \s-1TAP\s0 stream.
.Sp
By default the TAP::Parser::SourceHandler::Executable class will create a
TAP::Parser::Iterator::Process object to handle the source.  This passes the
array reference strings as command arguments to IPC::Open3::open3:
.Sp
.Vb 1
\& exec => [ \*(Aq/usr/bin/ruby\*(Aq, \*(Aqt/my_test.rb\*(Aq ]
.Ve
.Sp
If any \f(CW\*(C`test_args\*(C'\fR are given they will be appended to the end of the command
argument list.
.Sp
To configure the \fIIteratorFactory\fR use the \f(CW\*(C`sources\*(C'\fR parameter below.
.Sp
Note that \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR are \fImutually exclusive\fR.
.PP
The following keys are optional.
.IP "\(bu" 4
\&\f(CW\*(C`sources\*(C'\fR
.Sp
\&\fI\s-1NEW\s0 to 3.18\fR.
.Sp
If set, \f(CW\*(C`sources\*(C'\fR must be a hashref containing the names of the
TAP::Parser::SourceHandlers to load and/or configure.  The values are a
hash of configuration that will be accessible to to the source handlers via
\&\*(L"config_for\*(R" in TAP::Parser::Source.
.Sp
For example:
.Sp
.Vb 5
\&  sources => {
\&    Perl => { exec => \*(Aq/path/to/custom/perl\*(Aq },
\&    File => { extensions => [ \*(Aq.tap\*(Aq, \*(Aq.txt\*(Aq ] },
\&    MyCustom => { some => \*(Aqconfig\*(Aq },
\&  }
.Ve
.Sp
This will cause \f(CW\*(C`TAP::Parser\*(C'\fR to pass custom configuration to two of the built\-
in source handlers \- TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File \- and attempt to load the \f(CW\*(C`MyCustom\*(C'\fR
class.  See \*(L"load_handlers\*(R" in TAP::Parser::IteratorFactory for more detail.
.Sp
The \f(CW\*(C`sources\*(C'\fR parameter affects how \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR and \f(CW\*(C`exec\*(C'\fR parameters
are handled.
.Sp
See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and subclasses for
more details.
.IP "\(bu" 4
\&\f(CW\*(C`callback\*(C'\fR
.Sp
If present, each callback corresponding to a given result type will be called
with the result as the argument if the \f(CW\*(C`run\*(C'\fR method is used:
.Sp
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& my $aggregator = TAP::Parser::Aggregator\->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`switches\*(C'\fR
.Sp
If using a Perl file as a source, optional switches may be passed which will
be used when invoking the perl executable.
.Sp
.Vb 4
\& my $parser = TAP::Parser\->new( {
\&     source   => $test_file,
\&     switches => [ \*(Aq\-Ilib\*(Aq ],
\& } );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`test_args\*(C'\fR
.Sp
Used in conjunction with the \f(CW\*(C`source\*(C'\fR and \f(CW\*(C`exec\*(C'\fR option to supply a reference
to an \f(CW@ARGV\fR style array of arguments to pass to the test program.
.IP "\(bu" 4
\&\f(CW\*(C`spool\*(C'\fR
.Sp
If passed a filehandle will write a copy of all parsed \s-1TAP\s0 to that handle.
.IP "\(bu" 4
\&\f(CW\*(C`merge\*(C'\fR
.Sp
If false, \s-1STDERR\s0 is not captured (though it is 'relayed' to keep it
somewhat synchronized with \s-1STDOUT.\s0)
.Sp
If true, \s-1STDERR\s0 and \s-1STDOUT\s0 are the same filehandle.  This may cause
breakage if \s-1STDERR\s0 contains anything resembling \s-1TAP\s0 format, but does
allow exact synchronization.
.Sp
Subtleties of this behavior may be platform-dependent and may change in
the future.
.IP "\(bu" 4
\&\f(CW\*(C`grammar_class\*(C'\fR
.Sp
This option was introduced to let you easily customize which \fIgrammar\fR class
the parser should use.  It defaults to TAP::Parser::Grammar.
.Sp
See also \*(L"make_grammar\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`result_factory_class\*(C'\fR
.Sp
This option was introduced to let you easily customize which \fIresult\fR
factory class the parser should use.  It defaults to
TAP::Parser::ResultFactory.
.Sp
See also \*(L"make_result\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`iterator_factory_class\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 in 3.18\fR
.Sp
This option was introduced to let you easily customize which \fIiterator\fR
factory class the parser should use.  It defaults to
TAP::Parser::IteratorFactory.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 4
\&  my $parser = TAP::Parser\->new( { source => $file } );
\&  while ( my $result = $parser\->next ) {
\&      print $result\->as_string, "\en";
\&  }
.Ve
.PP
This method returns the results of the parsing, one result at a time.  Note
that it is destructive.  You can't rewind and examine previous results.
.PP
If callbacks are used, they will be issued before this call returns.
.PP
Each result returned is a subclass of TAP::Parser::Result.  See that
module and related classes for more information on how to use them.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $parser\->run;
.Ve
.PP
This method merely runs the parser and parses all of the \s-1TAP.\s0
.PP
\fI\f(CI\*(C`make_grammar\*(C'\fI\fR
.IX Subsection "make_grammar"
.PP
Make a new TAP::Parser::Grammar object and return it.  Passes through any
arguments given.
.PP
The \f(CW\*(C`grammar_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Make a new TAP::Parser::Result object using the parser's
TAP::Parser::ResultFactory, and return it.  Passes through any arguments
given.
.PP
The \f(CW\*(C`result_factory_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_iterator_factory\*(C'\fI\fR
.IX Subsection "make_iterator_factory"
.PP
\&\fI\s-1NEW\s0 to 3.18\fR.
.PP
Make a new TAP::Parser::IteratorFactory object and return it.  Passes through
any arguments given.
.PP
\&\f(CW\*(C`iterator_factory_class\*(C'\fR can be customized, as described in \*(L"new\*(R".
.SH "INDIVIDUAL RESULTS"
.IX Header "INDIVIDUAL RESULTS"
If you've read this far in the docs, you've seen this:
.PP
.Vb 3
\&    while ( my $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.PP
Each result returned is a TAP::Parser::Result subclass, referred to as
\&\fIresult types\fR.
.SS "Result types"
.IX Subsection "Result types"
Basically, you fetch individual results from the \s-1TAP. \s0 The six types, with
examples of each, are as follows:
.IP "\(bu" 4
Version
.Sp
.Vb 1
\& TAP version 12
.Ve
.IP "\(bu" 4
Plan
.Sp
.Vb 1
\& 1..42
.Ve
.IP "\(bu" 4
Pragma
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
Test
.Sp
.Vb 1
\& ok 3 \- We should start with some foobar!
.Ve
.IP "\(bu" 4
Comment
.Sp
.Vb 1
\& # Hope we don\*(Aqt use up the foobar.
.Ve
.IP "\(bu" 4
Bailout
.Sp
.Vb 1
\& Bail out!  We ran out of foobar!
.Ve
.IP "\(bu" 4
Unknown
.Sp
.Vb 1
\& ... yo, this ain\*(Aqt TAP! ...
.Ve
.PP
Each result fetched is a result object of a different type.  There are common
methods to each result object and different types may have methods unique to
their type.  Sometimes a type method may be overridden in a subclass, but its
use is guaranteed to be identical.
.SS "Common type methods"
.IX Subsection "Common type methods"
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
Returns the type of result, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
Returns the original line of text which was parsed.
.PP
\fI\f(CI\*(C`is_plan\*(C'\fI\fR
.IX Subsection "is_plan"
.PP
Indicates whether or not this is the test plan line.
.PP
\fI\f(CI\*(C`is_test\*(C'\fI\fR
.IX Subsection "is_test"
.PP
Indicates whether or not this is a test line.
.PP
\fI\f(CI\*(C`is_comment\*(C'\fI\fR
.IX Subsection "is_comment"
.PP
Indicates whether or not this is a comment. Comments will generally only
appear in the \s-1TAP\s0 stream if \s-1STDERR\s0 is merged to \s-1STDOUT.\s0 See the
\&\f(CW\*(C`merge\*(C'\fR option.
.PP
\fI\f(CI\*(C`is_bailout\*(C'\fI\fR
.IX Subsection "is_bailout"
.PP
Indicates whether or not this is bailout line.
.PP
\fI\f(CI\*(C`is_yaml\*(C'\fI\fR
.IX Subsection "is_yaml"
.PP
Indicates whether or not the current item is a \s-1YAML\s0 block.
.PP
\fI\f(CI\*(C`is_unknown\*(C'\fI\fR
.IX Subsection "is_unknown"
.PP
Indicates whether or not the current line could be parsed.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut
which allows you to do this:
.PP
.Vb 5
\& my $parser = TAP::Parser\->new( { source => $source } );
\& while ( my $result = $parser\->next ) {
\&     # only print failing results
\&     print $result\->as_string unless $result\->is_ok;
\& }
.Ve
.ie n .SS """plan"" methods"
.el .SS "\f(CWplan\fP methods"
.IX Subsection "plan methods"
.Vb 1
\& if ( $result\->is_plan ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $result\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $result\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.ie n .SS """pragma"" methods"
.el .SS "\f(CWpragma\fP methods"
.IX Subsection "pragma methods"
.Vb 1
\& if ( $result\->is_pragma ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Returns a list of pragmas each of which is a + or \- followed by the
pragma name.
.ie n .SS """comment"" methods"
.el .SS "\f(CWcomment\fP methods"
.IX Subsection "comment methods"
.Vb 1
\& if ( $result\->is_comment ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      my $comment = $result\->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
.ie n .SS """bailout"" methods"
.el .SS "\f(CWbailout\fP methods"
.IX Subsection "bailout methods"
.Vb 1
\& if ( $result\->is_bailout ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      my $explanation = $result\->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
.PP
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
.ie n .SS """unknown"" methods"
.el .SS "\f(CWunknown\fP methods"
.IX Subsection "unknown methods"
.Vb 1
\& if ( $result\->is_unknown ) { ... }
.Ve
.PP
There are no unique methods for unknown results.
.ie n .SS """test"" methods"
.el .SS "\f(CWtest\fP methods"
.IX Subsection "test methods"
.Vb 1
\& if ( $result\->is_test ) { ... }
.Ve
.PP
If the above evaluates as true, the following methods will be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result\->ok;
.Ve
.PP
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result\->number;
.Ve
.PP
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result\->description;
.Ve
.PP
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For the above line, the explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`passed\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`actual_passed\*(C'\fR.  The latter method is deprecated
and will issue a warning.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 1
\&  if ( $test\->is_unplanned ) { ... }
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR (see
TAP::Parser::Result::Test for more information about this).
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test had a \s-1TODO\s0
directive.
.PP
Note that \s-1TODO\s0 tests \fIalways\fR pass.  If you need to know whether or not
they really passed, check the \f(CW\*(C`is_actual_ok\*(C'\fR method.
.PP
\fI\f(CI\*(C`in_todo\*(C'\fI\fR
.IX Subsection "in_todo"
.PP
.Vb 1
\&  if ( $parser\->in_todo ) { ... }
.Ve
.PP
True while the most recent result was a \s-1TODO.\s0 Becomes true before the
\&\s-1TODO\s0 result is returned and stays true until just before the next non\-
\&\s-1TODO\s0 test is returned.
.SH "TOTAL RESULTS"
.IX Header "TOTAL RESULTS"
After parsing the \s-1TAP,\s0 there are many methods available to let you dig through
the results and determine what is meaningful to you.
.SS "Individual Results"
.IX Subsection "Individual Results"
These results refer to individual tests which are run.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
.Vb 2
\& my @passed = $parser\->passed; # the test numbers which passed
\& my $passed = $parser\->passed; # the number of tests which passed
.Ve
.PP
This method lets you know which (or how many) tests passed.  If a test failed
but had a \s-1TODO\s0 directive, it will be counted as a passed test.
.PP
\fI\f(CI\*(C`failed\*(C'\fI\fR
.IX Subsection "failed"
.PP
.Vb 2
\& my @failed = $parser\->failed; # the test numbers which failed
\& my $failed = $parser\->failed; # the number of tests which failed
.Ve
.PP
This method lets you know which (or how many) tests failed.  If a test passed
but had a \s-1TODO\s0 directive, it will \fB\s-1NOT\s0\fR be counted as a failed test.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
.Vb 2
\& # the test numbers which actually passed
\& my @actual_passed = $parser\->actual_passed;
\&
\& # the number of tests which actually passed
\& my $actual_passed = $parser\->actual_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`actual_ok\*(C'\fI\fR
.IX Subsection "actual_ok"
.PP
This method is a synonym for \f(CW\*(C`actual_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`actual_failed\*(C'\fI\fR
.IX Subsection "actual_failed"
.PP
.Vb 2
\& # the test numbers which actually failed
\& my @actual_failed = $parser\->actual_failed;
\&
\& # the number of tests which actually failed
\& my $actual_failed = $parser\->actual_failed;
.Ve
.PP
This method lets you know which (or how many) tests actually failed,
regardless of whether or not a \s-1TODO\s0 directive was found.
.PP
\fI\f(CI\*(C`todo\*(C'\fI\fR
.IX Subsection "todo"
.PP
.Vb 2
\& my @todo = $parser\->todo; # the test numbers with todo directives
\& my $todo = $parser\->todo; # the number of tests with todo directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1TODO\s0 directives.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 2
\& # the test numbers which unexpectedly succeeded
\& my @todo_passed = $parser\->todo_passed;
\&
\& # the number of tests which unexpectedly succeeded
\& my $todo_passed = $parser\->todo_passed;
.Ve
.PP
This method lets you know which (or how many) tests actually passed but were
declared as \*(L"\s-1TODO\*(R"\s0 tests.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`skipped\*(C'\fI\fR
.IX Subsection "skipped"
.PP
.Vb 2
\& my @skipped = $parser\->skipped; # the test numbers with SKIP directives
\& my $skipped = $parser\->skipped; # the number of tests with SKIP directives
.Ve
.PP
This method lets you know which (or how many) tests had \s-1SKIP\s0 directives.
.SS "Pragmas"
.IX Subsection "Pragmas"
\fI\f(CI\*(C`pragma\*(C'\fI\fR
.IX Subsection "pragma"
.PP
Get or set a pragma. To get the state of a pragma:
.PP
.Vb 3
\&  if ( $p\->pragma(\*(Aqstrict\*(Aq) ) {
\&      # be strict
\&  }
.Ve
.PP
To set the state of a pragma:
.PP
.Vb 1
\&  $p\->pragma(\*(Aqstrict\*(Aq, 1); # enable strict mode
.Ve
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Get a list of all the currently enabled pragmas:
.PP
.Vb 1
\&  my @pragmas_enabled = $p\->pragmas;
.Ve
.SS "Summary Results"
.IX Subsection "Summary Results"
These results are \*(L"meta\*(R" information about the total results of an individual
test program.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 1
\& my $plan = $parser\->plan;
.Ve
.PP
Returns the test plan, if found.
.PP
\fI\f(CI\*(C`good_plan\*(C'\fI\fR
.IX Subsection "good_plan"
.PP
Deprecated.  Use \f(CW\*(C`is_good_plan\*(C'\fR instead.
.PP
\fI\f(CI\*(C`is_good_plan\*(C'\fI\fR
.IX Subsection "is_good_plan"
.PP
.Vb 1
\&  if ( $parser\->is_good_plan ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the number of tests planned
matches the number of tests run.
.PP
\&\fBNote:\fR  this was formerly \f(CW\*(C`good_plan\*(C'\fR.  The latter method is deprecated and
will issue a warning.
.PP
And since we're on that subject ...
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  print $parser\->tests_planned;
.Ve
.PP
Returns the number of tests planned, according to the plan.  For example, a
plan of '1..17' will mean that 17 tests were planned.
.PP
\fI\f(CI\*(C`tests_run\*(C'\fI\fR
.IX Subsection "tests_run"
.PP
.Vb 1
\&  print $parser\->tests_run;
.Ve
.PP
Returns the number of tests which actually were run.  Hopefully this will
match the number of \f(CW\*(C`$parser\->tests_planned\*(C'\fR.
.PP
\fI\f(CI\*(C`skip_all\*(C'\fI\fR
.IX Subsection "skip_all"
.PP
Returns a true value (actually the reason for skipping) if all tests
were skipped.
.PP
\fI\f(CI\*(C`start_time\*(C'\fI\fR
.IX Subsection "start_time"
.PP
Returns the time when the Parser was created.
.PP
\fI\f(CI\*(C`end_time\*(C'\fI\fR
.IX Subsection "end_time"
.PP
Returns the time when the end of \s-1TAP\s0 input was seen.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
This is a 'catch\-all' method which returns true if any tests have currently
failed, any \s-1TODO\s0 tests unexpectedly succeeded, or any parse errors occurred.
.PP
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 1
\&  $parser\->version;
.Ve
.PP
Once the parser is done, this will return the version number for the
parsed \s-1TAP.\s0 Version numbers were introduced with \s-1TAP\s0 version 13 so if no
version number is found version 12 is assumed.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
.Vb 1
\&  $parser\->exit;
.Ve
.PP
Once the parser is done, this will return the exit status.  If the parser ran
an executable, it returns the exit status of the executable.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
.Vb 1
\&  $parser\->wait;
.Ve
.PP
Once the parser is done, this will return the wait status.  If the parser ran
an executable, it returns the wait status of the executable.  Otherwise, this
merely returns the \f(CW\*(C`exit\*(C'\fR status.
.ie n .SS """ignore_exit"""
.el .SS "\f(CWignore_exit\fP"
.IX Subsection "ignore_exit"
.Vb 1
\&  $parser\->ignore_exit(1);
.Ve
.PP
Tell the parser to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit status are
considered to have failed even if all individual tests passed. In cases
where it is not possible to control the exit value of the test script
use this option to ignore it.
.PP
\fI\f(CI\*(C`parse_errors\*(C'\fI\fR
.IX Subsection "parse_errors"
.PP
.Vb 2
\& my @errors = $parser\->parse_errors; # the parser errors
\& my $errors = $parser\->parse_errors; # the number of parser_errors
.Ve
.PP
Fortunately, all \s-1TAP\s0 output is perfect.  In the event that it is not, this
method will return parser errors.  Note that a junk line which the parser does
not recognize is \f(CW\*(C`not\*(C'\fR an error.  This allows this parser to handle future
versions of \s-1TAP. \s0 The following are all \s-1TAP\s0 errors reported by the parser:
.IP "\(bu" 4
Misplaced plan
.Sp
The plan (for example, '1..5'), must only come at the beginning or end of the
\&\s-1TAP\s0 output.
.IP "\(bu" 4
No plan
.Sp
Gotta have a plan!
.IP "\(bu" 4
More than one plan
.Sp
.Vb 5
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
\& 1..3
.Ve
.Sp
Right.  Very funny.  Don't do that.
.IP "\(bu" 4
Test numbers out of sequence
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok 2 \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
That last test line above should have the number '3' instead of '2'.
.Sp
Note that it's perfectly acceptable for some lines to have test numbers and
others to not have them.  However, when a test number is found, it must be in
sequence.  The following is also an error:
.Sp
.Vb 4
\& 1..3
\& ok 1 \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 2 read the rest of the file
.Ve
.Sp
But this is not:
.Sp
.Vb 4
\& 1..3
\& ok  \- input file opened
\& not ok \- first line of the input valid # todo some data
\& ok 3 read the rest of the file
.Ve
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Get an a list of file handles which can be passed to \f(CW\*(C`select\*(C'\fR to
determine the readiness of this parser.
.PP
\fI\f(CI\*(C`delete_spool\*(C'\fI\fR
.IX Subsection "delete_spool"
.PP
Delete and return the spool.
.PP
.Vb 1
\&  my $fh = $parser\->delete_spool;
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
As mentioned earlier, a \*(L"callback\*(R" key may be added to the
\&\f(CW\*(C`TAP::Parser\*(C'\fR constructor. If present, each callback corresponding to a
given result type will be called with the result as the argument if the
\&\f(CW\*(C`run\*(C'\fR method is used. The callback is expected to be a subroutine
reference (or anonymous subroutine) which is invoked with the parser
result as its argument.
.PP
.Vb 7
\& my %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& my $aggregator = TAP::Parser::Aggregator\->new;
\& for my $file ( @test_files ) {
\&     my $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.PP
Callbacks may also be added like this:
.PP
.Vb 2
\& $parser\->callback( test => \e&test_callback );
\& $parser\->callback( plan => \e&plan_callback );
.Ve
.PP
The following keys allowed for callbacks. These keys are case-sensitive.
.IP "\(bu" 4
\&\f(CW\*(C`test\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_test\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`version\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_version\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`plan\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_plan\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`comment\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_comment\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`bailout\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`yaml\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_yaml\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`unknown\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`ELSE\*(C'\fR
.Sp
If a result does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are specified as
callbacks, this callback will \fInever\fR be invoked.
.IP "\(bu" 4
\&\f(CW\*(C`ALL\*(C'\fR
.Sp
This callback will always be invoked and this will happen for each
result after one of the above callbacks is invoked.  For example, if
Term::ANSIColor is loaded, you could use the following to color your
test output:
.Sp
.Vb 12
\& my %callbacks = (
\&     test => sub {
\&         my $test = shift;
\&         if ( $test\->is_ok && not $test\->directive ) {
\&             # normal passing test
\&             print color \*(Aqgreen\*(Aq;
\&         }
\&         elsif ( !$test\->is_ok ) {    # even if it\*(Aqs TODO
\&             print color \*(Aqwhite on_red\*(Aq;
\&         }
\&         elsif ( $test\->has_skip ) {
\&             print color \*(Aqwhite on_blue\*(Aq;
\&
\&         }
\&         elsif ( $test\->has_todo ) {
\&             print color \*(Aqwhite\*(Aq;
\&         }
\&     },
\&     ELSE => sub {
\&         # plan, comment, and so on (anything which isn\*(Aqt a test line)
\&         print color \*(Aqblack on_white\*(Aq;
\&     },
\&     ALL => sub {
\&         # now print them
\&         print shift\->as_string;
\&         print color \*(Aqreset\*(Aq;
\&         print "\en";
\&     },
\& );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`EOF\*(C'\fR
.Sp
Invoked when there are no more lines to be parsed. Since there is no
accompanying TAP::Parser::Result object the \f(CW\*(C`TAP::Parser\*(C'\fR object is
passed instead.
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
If you're looking for an \s-1EBNF\s0 grammar, see TAP::Parser::Grammar.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
The Perl-QA list attempted to ensure backwards compatibility with
Test::Harness.  However, there are some minor differences.
.SS "Differences"
.IX Subsection "Differences"
.IP "\(bu" 4
\&\s-1TODO\s0 plans
.Sp
A little-known feature of Test::Harness is that it supported \s-1TODO\s0
lists in the plan:
.Sp
.Vb 3
\& 1..2 todo 2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated
.Ve
.Sp
Under Test::Harness, test number 2 would \fIpass\fR because it was
listed as a \s-1TODO\s0 test on the plan line. However, we are not aware of
anyone actually using this feature and hard-coding test numbers is
discouraged because it's very easy to add a test and break the test
number sequence. This makes test suites very fragile. Instead, the
following should be used:
.Sp
.Vb 3
\& 1..2
\& ok 1 \- We have liftoff
\& not ok 2 \- Anti\-gravity device activated # TODO
.Ve
.IP "\(bu" 4
\&'Missing' tests
.Sp
It rarely happens, but sometimes a harness might encounter
\&'missing tests:
.Sp
.Vb 5
\& ok 1
\& ok 2
\& ok 15
\& ok 16
\& ok 17
.Ve
.Sp
Test::Harness would report tests 3\-14 as having failed. For the
\&\f(CW\*(C`TAP::Parser\*(C'\fR, these tests are not considered failed because they've
never run. They're reported as parse failures (tests out of sequence).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you find you need to provide custom functionality (as you would have using
Test::Harness::Straps), you're in luck: \f(CW\*(C`TAP::Parser\*(C'\fR and friends are
designed to be easily plugged-into and/or subclassed.
.PP
Before you start, it's important to know a few things:
.IP "1." 2
All \f(CW\*(C`TAP::*\*(C'\fR objects inherit from TAP::Object.
.IP "2." 2
Many \f(CW\*(C`TAP::*\*(C'\fR classes have a \fI\s-1SUBCLASSING\s0\fR section to guide you.
.IP "3." 2
Note that \f(CW\*(C`TAP::Parser\*(C'\fR is designed to be the central \*(L"maker\*(R" \- ie: it is
responsible for creating most new objects in the \f(CW\*(C`TAP::Parser::*\*(C'\fR namespace.
.Sp
This makes it possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases you'll find
you only need to sub-class one of the parser's components.
.Sp
The exception to this rule are \fISourceHandlers\fR & \fIIterators\fR, but those are
both created with customizable \fIIteratorFactory\fR.
.IP "4." 2
By subclassing, you may end up overriding undocumented methods.  That's not
a bad thing per se, but be forewarned that undocumented methods may change
without warning from one release to the next \- we cannot guarantee backwards
compatibility.  If any \fIdocumented\fR method needs changing, it will be
deprecated first, and changed in a later release.
.SS "Parser Components"
.IX Subsection "Parser Components"
\fISources\fR
.IX Subsection "Sources"
.PP
A \s-1TAP\s0 parser consumes input from a single \fIraw source\fR of \s-1TAP,\s0 which could come
from anywhere (a file, an executable, a database, an \s-1IO\s0 handle, a \s-1URI,\s0 etc..).
The source gets bundled up in a TAP::Parser::Source object which gathers some
meta data about it.  The parser then uses a TAP::Parser::IteratorFactory to
determine which TAP::Parser::SourceHandler to use to turn the raw source
into a stream of \s-1TAP\s0 by way of \*(L"Iterators\*(R".
.PP
If you simply want \f(CW\*(C`TAP::Parser\*(C'\fR to handle a new source of \s-1TAP\s0 you probably
don't need to subclass \f(CW\*(C`TAP::Parser\*(C'\fR itself.  Rather, you'll need to create a
new TAP::Parser::SourceHandler class, and just plug it into the parser using
the \fIsources\fR param to \*(L"new\*(R".  Before you start writing one, read through
TAP::Parser::IteratorFactory to get a feel for how the system works first.
.PP
If you find you really need to use your own iterator factory you can still do
so without sub-classing \f(CW\*(C`TAP::Parser\*(C'\fR by setting \*(L"iterator_factory_class\*(R".
.PP
If you just need to customize the objects on creation, subclass TAP::Parser
and override \*(L"make_iterator_factory\*(R".
.PP
Note that \*(L"make_source\*(R" & \*(L"make_perl_source\*(R" have been \fI\s-1DEPRECATED\s0\fR and
are now removed.
.PP
\fIIterators\fR
.IX Subsection "Iterators"
.PP
A \s-1TAP\s0 parser uses \fIiterators\fR to loop through the \fIstream\fR of \s-1TAP\s0 read in
from the \fIsource\fR it was given.  There are a few types of Iterators available
by default, all sub-classes of TAP::Parser::Iterator.  Choosing which
iterator to use is the responsibility of the \fIiterator factory\fR, though it
simply delegates to the \fISource Handler\fR it uses.
.PP
If you're writing your own TAP::Parser::SourceHandler, you may need to
create your own iterators too.  If so you'll need to subclass
TAP::Parser::Iterator.
.PP
Note that \*(L"make_iterator\*(R" has been \fI\s-1DEPRECATED\s0\fR and is now removed.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
A \s-1TAP\s0 parser creates TAP::Parser::Results as it iterates through the
input \fIstream\fR.  There are quite a few result types available; choosing
which class to use is the responsibility of the \fIresult factory\fR.
.PP
To create your own result types you have two options:
.IP "option 1" 2
.IX Item "option 1"
Subclass TAP::Parser::Result and register your new result type/class with
the default TAP::Parser::ResultFactory.
.IP "option 2" 2
.IX Item "option 2"
Subclass TAP::Parser::ResultFactory itself and implement your own
TAP::Parser::Result creation logic.  Then you'll need to customize the
class used by your parser by setting the \f(CW\*(C`result_factory_class\*(C'\fR parameter.
See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_result\*(R".
.PP
\fIGrammar\fR
.IX Subsection "Grammar"
.PP
TAP::Parser::Grammar is the heart of the parser.  It tokenizes the \s-1TAP\s0
input \fIstream\fR and produces results.  If you need to customize its behaviour
you should probably familiarize yourself with the source first.  Enough
lecturing.
.PP
Subclass TAP::Parser::Grammar and customize your parser by setting the
\&\f(CW\*(C`grammar_class\*(C'\fR parameter.  See \*(L"new\*(R" for more details.
.PP
If you need to customize the objects on creation, subclass TAP::Parser and
override \*(L"make_grammar\*(R"
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
All of the following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been forthcoming.
.IP "\(bu" 4
Michael Schwern
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
chromatic
.IP "\(bu" 4
\&\s-1GEOFFR\s0
.IP "\(bu" 4
Shlomi Fish
.IP "\(bu" 4
Torsten Schoenfeld
.IP "\(bu" 4
Jerry Gay
.IP "\(bu" 4
Aristotle
.IP "\(bu" 4
Adam Kennedy
.IP "\(bu" 4
Yves Orton
.IP "\(bu" 4
Adrian Howard
.IP "\(bu" 4
Sean & Lil
.IP "\(bu" 4
Andreas J. Koenig
.IP "\(bu" 4
Florian Ragwitz
.IP "\(bu" 4
Corion
.IP "\(bu" 4
Mark Stosberg
.IP "\(bu" 4
Matt Kraai
.IP "\(bu" 4
David Wheeler
.IP "\(bu" 4
Alex Vandiver
.IP "\(bu" 4
Cosimo Streppone
.IP "\(bu" 4
Ville Skytta\*:
.SH "AUTHORS"
.IX Header "AUTHORS"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.PP
Andy Armstong <andy@hexten.net>
.PP
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
Michael Peters <mpeters at plusthree dot com>
.PP
Leif Eriksen <leif dot eriksen at bigpond dot com>
.PP
Steve Purkis <spurkis@cpan.org>
.PP
Nicholas Clark <nick@ccl4.org>
.PP
Lee Johnson <notfadeaway at btinternet dot com>
.PP
Philippe Bruhat <book@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-harness@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Harness>.
We will be notified, and then you'll automatically be notified of
progress on your bug as we make changes.
.PP
Obviously, bugs which include patches are best. If you prefer, you can
patch against bleed by via anonymous checkout of the latest version:
.PP
.Vb 1
\& git clone git://github.com/Perl\-Toolchain\-Gang/Test\-Harness.git
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2008 Curtis \*(L"Ovid\*(R" Poe, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1852:" 4
.IX Item "Around line 1852:"
Non-ASCII character seen before =encoding in 'Skytta\*:'. Assuming \s-1UTF\-8\s0
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Aggregator.3pm                  0100644 0001750 0001750 00000023144 12566207463 025464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Aggregator 3pm"
.TH TAP::Parser::Aggregator 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Aggregator \- Aggregate TAP::Parser results
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Aggregator;
\&
\&    my $aggregate = TAP::Parser::Aggregator\->new;
\&    $aggregate\->add( \*(Aqt/00\-load.t\*(Aq, $load_parser );
\&    $aggregate\->add( \*(Aqt/10\-lex.t\*(Aq,  $lex_parser  );
\&
\&    my $summary = <<\*(AqEND_SUMMARY\*(Aq;
\&    Passed:  %s
\&    Failed:  %s
\&    Unexpectedly succeeded: %s
\&    END_SUMMARY
\&    printf $summary,
\&           scalar $aggregate\->passed,
\&           scalar $aggregate\->failed,
\&           scalar $aggregate\->todo_passed;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR collects parser objects and allows
reporting/querying their aggregate results.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $aggregate = TAP::Parser::Aggregator\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $aggregate\->add( $description => $parser );
.Ve
.PP
The \f(CW$description\fR is usually a test file name (but only by
convention.)  It is used as a unique identifier (see e.g.
\&\*(L"parsers\*(R".)  Reusing a description is a fatal error.
.PP
The \f(CW$parser\fR is a TAP::Parser object.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 3
\&  my $count   = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers(@descriptions);
.Ve
.PP
In scalar context without arguments, this method returns the number of parsers
aggregated.  In list context without arguments, returns the parsers in the
order they were added.
.PP
If \f(CW@descriptions\fR is given, these correspond to the keys used in each
call to the \fIadd()\fR method.  Returns an array of the requested parsers (in
the requested order) in list context or an array reference in scalar
context.
.PP
Requesting an unknown identifier is a fatal error.
.PP
\fI\f(CI\*(C`descriptions\*(C'\fI\fR
.IX Subsection "descriptions"
.PP
Get an array of descriptions in the order in which they were added to
the aggregator.
.PP
\fI\f(CI\*(C`start\*(C'\fI\fR
.IX Subsection "start"
.PP
Call \f(CW\*(C`start\*(C'\fR immediately before adding any results to the aggregator.
Among other times it records the start time for the test run.
.PP
\fI\f(CI\*(C`stop\*(C'\fI\fR
.IX Subsection "stop"
.PP
Call \f(CW\*(C`stop\*(C'\fR immediately after adding all test results to the aggregator.
.PP
\fI\f(CI\*(C`elapsed\*(C'\fI\fR
.IX Subsection "elapsed"
.PP
Elapsed returns a Benchmark object that represents the running time
of the aggregated tests. In order for \f(CW\*(C`elapsed\*(C'\fR to be valid you must
call \f(CW\*(C`start\*(C'\fR before running the tests and \f(CW\*(C`stop\*(C'\fR immediately
afterwards.
.PP
\fI\f(CI\*(C`elapsed_timestr\*(C'\fI\fR
.IX Subsection "elapsed_timestr"
.PP
Returns a formatted string representing the runtime returned by
\&\f(CW\*(C`elapsed()\*(C'\fR.  This lets the caller not worry about Benchmark.
.PP
\fI\f(CI\*(C`all_passed\*(C'\fI\fR
.IX Subsection "all_passed"
.PP
Return true if all the tests passed and no parse errors were detected.
.PP
\fI\f(CI\*(C`get_status\*(C'\fI\fR
.IX Subsection "get_status"
.PP
Get a single word describing the status of the aggregated tests.
Depending on the outcome of the tests returns '\s-1PASS\s0', '\s-1FAIL\s0' or
\&'\s-1NOTESTS\s0'. This token is understood by CPAN::Reporter.
.SS "Summary methods"
.IX Subsection "Summary methods"
Each of the following methods will return the total number of corresponding
tests if called in scalar context.  If called in list context, returns the
descriptions of the parsers which contain the corresponding tests (see \f(CW\*(C`add\*(C'\fR
for an explanation of description.
.IP "\(bu" 4
failed
.IP "\(bu" 4
parse_errors
.IP "\(bu" 4
passed
.IP "\(bu" 4
planned
.IP "\(bu" 4
skipped
.IP "\(bu" 4
todo
.IP "\(bu" 4
todo_passed
.IP "\(bu" 4
wait
.IP "\(bu" 4
exit
.PP
For example, to find out how many tests unexpectedly succeeded (\s-1TODO\s0 tests
which passed when they shouldn't):
.PP
.Vb 2
\& my $count        = $aggregate\->todo_passed;
\& my @descriptions = $aggregate\->todo_passed;
.Ve
.PP
Note that \f(CW\*(C`wait\*(C'\fR and \f(CW\*(C`exit\*(C'\fR are the totals of the wait and exit
statuses of each of the tests. These values are totalled only to provide
a true value if any of them are non-zero.
.PP
\fI\f(CI\*(C`total\*(C'\fI\fR
.IX Subsection "total"
.PP
.Vb 1
\&  my $tests_run = $aggregate\->total;
.Ve
.PP
Returns the total number of tests run.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
Identical to \f(CW\*(C`has_errors\*(C'\fR, but also returns true if any \s-1TODO\s0 tests
unexpectedly succeeded.  This is more akin to \*(L"warnings\*(R".
.PP
\fI\f(CI\*(C`has_errors\*(C'\fI\fR
.IX Subsection "has_errors"
.PP
.Vb 3
\&  if ( $parser\->has_errors ) {
\&      ...
\&  }
.Ve
.PP
Returns true if \fIany\fR of the parsers failed.  This includes:
.IP "\(bu" 4
Failed tests
.IP "\(bu" 4
Parse errors
.IP "\(bu" 4
Bad exit or wait status
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Aggregator5.16.3pm              0100644 0001750 0001750 00000022623 12566207441 025773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Aggregator 3pm"
.TH TAP::Parser::Aggregator 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Aggregator \- Aggregate TAP::Parser results
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Aggregator;
\&
\&    my $aggregate = TAP::Parser::Aggregator\->new;
\&    $aggregate\->add( \*(Aqt/00\-load.t\*(Aq, $load_parser );
\&    $aggregate\->add( \*(Aqt/10\-lex.t\*(Aq,  $lex_parser  );
\&
\&    my $summary = <<\*(AqEND_SUMMARY\*(Aq;
\&    Passed:  %s
\&    Failed:  %s
\&    Unexpectedly succeeded: %s
\&    END_SUMMARY
\&    printf $summary,
\&           scalar $aggregate\->passed,
\&           scalar $aggregate\->failed,
\&           scalar $aggregate\->todo_passed;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR collects parser objects and allows
reporting/querying their aggregate results.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $aggregate = TAP::Parser::Aggregator\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $aggregate\->add( $description => $parser );
.Ve
.PP
The \f(CW$description\fR is usually a test file name (but only by
convention.)  It is used as a unique identifier (see e.g.
\&\*(L"parsers\*(R".)  Reusing a description is a fatal error.
.PP
The \f(CW$parser\fR is a TAP::Parser object.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 3
\&  my $count   = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers(@descriptions);
.Ve
.PP
In scalar context without arguments, this method returns the number of parsers
aggregated.  In list context without arguments, returns the parsers in the
order they were added.
.PP
If \f(CW@descriptions\fR is given, these correspond to the keys used in each
call to the \fIadd()\fR method.  Returns an array of the requested parsers (in
the requested order) in list context or an array reference in scalar
context.
.PP
Requesting an unknown identifier is a fatal error.
.PP
\fI\f(CI\*(C`descriptions\*(C'\fI\fR
.IX Subsection "descriptions"
.PP
Get an array of descriptions in the order in which they were added to
the aggregator.
.PP
\fI\f(CI\*(C`start\*(C'\fI\fR
.IX Subsection "start"
.PP
Call \f(CW\*(C`start\*(C'\fR immediately before adding any results to the aggregator.
Among other times it records the start time for the test run.
.PP
\fI\f(CI\*(C`stop\*(C'\fI\fR
.IX Subsection "stop"
.PP
Call \f(CW\*(C`stop\*(C'\fR immediately after adding all test results to the aggregator.
.PP
\fI\f(CI\*(C`elapsed\*(C'\fI\fR
.IX Subsection "elapsed"
.PP
Elapsed returns a Benchmark object that represents the running time
of the aggregated tests. In order for \f(CW\*(C`elapsed\*(C'\fR to be valid you must
call \f(CW\*(C`start\*(C'\fR before running the tests and \f(CW\*(C`stop\*(C'\fR immediately
afterwards.
.PP
\fI\f(CI\*(C`elapsed_timestr\*(C'\fI\fR
.IX Subsection "elapsed_timestr"
.PP
Returns a formatted string representing the runtime returned by
\&\f(CW\*(C`elapsed()\*(C'\fR.  This lets the caller not worry about Benchmark.
.PP
\fI\f(CI\*(C`all_passed\*(C'\fI\fR
.IX Subsection "all_passed"
.PP
Return true if all the tests passed and no parse errors were detected.
.PP
\fI\f(CI\*(C`get_status\*(C'\fI\fR
.IX Subsection "get_status"
.PP
Get a single word describing the status of the aggregated tests.
Depending on the outcome of the tests returns '\s-1PASS\s0', '\s-1FAIL\s0' or
\&'\s-1NOTESTS\s0'. This token is understood by CPAN::Reporter.
.SS "Summary methods"
.IX Subsection "Summary methods"
Each of the following methods will return the total number of corresponding
tests if called in scalar context.  If called in list context, returns the
descriptions of the parsers which contain the corresponding tests (see \f(CW\*(C`add\*(C'\fR
for an explanation of description.
.IP "\(bu" 4
failed
.IP "\(bu" 4
parse_errors
.IP "\(bu" 4
passed
.IP "\(bu" 4
planned
.IP "\(bu" 4
skipped
.IP "\(bu" 4
todo
.IP "\(bu" 4
todo_passed
.IP "\(bu" 4
wait
.IP "\(bu" 4
exit
.PP
For example, to find out how many tests unexpectedly succeeded (\s-1TODO\s0 tests
which passed when they shouldn't):
.PP
.Vb 2
\& my $count        = $aggregate\->todo_passed;
\& my @descriptions = $aggregate\->todo_passed;
.Ve
.PP
Note that \f(CW\*(C`wait\*(C'\fR and \f(CW\*(C`exit\*(C'\fR are the totals of the wait and exit
statuses of each of the tests. These values are totalled only to provide
a true value if any of them are non-zero.
.PP
\fI\f(CI\*(C`total\*(C'\fI\fR
.IX Subsection "total"
.PP
.Vb 1
\&  my $tests_run = $aggregate\->total;
.Ve
.PP
Returns the total number of tests run.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
Identical to \f(CW\*(C`has_errors\*(C'\fR, but also returns true if any \s-1TODO\s0 tests
unexpectedly succeeded.  This is more akin to \*(L"warnings\*(R".
.PP
\fI\f(CI\*(C`has_errors\*(C'\fI\fR
.IX Subsection "has_errors"
.PP
.Vb 3
\&  if ( $parser\->has_errors ) {
\&      ...
\&  }
.Ve
.PP
Returns true if \fIany\fR of the parsers failed.  This includes:
.IP "\(bu" 4
Failed tests
.IP "\(bu" 4
Parse errors
.IP "\(bu" 4
Bad exit or wait status
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Aggregator5.18.3pm              0100644 0001750 0001750 00000023144 12566207463 026000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Aggregator 3pm"
.TH TAP::Parser::Aggregator 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Aggregator \- Aggregate TAP::Parser results
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Aggregator;
\&
\&    my $aggregate = TAP::Parser::Aggregator\->new;
\&    $aggregate\->add( \*(Aqt/00\-load.t\*(Aq, $load_parser );
\&    $aggregate\->add( \*(Aqt/10\-lex.t\*(Aq,  $lex_parser  );
\&
\&    my $summary = <<\*(AqEND_SUMMARY\*(Aq;
\&    Passed:  %s
\&    Failed:  %s
\&    Unexpectedly succeeded: %s
\&    END_SUMMARY
\&    printf $summary,
\&           scalar $aggregate\->passed,
\&           scalar $aggregate\->failed,
\&           scalar $aggregate\->todo_passed;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR collects parser objects and allows
reporting/querying their aggregate results.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $aggregate = TAP::Parser::Aggregator\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $aggregate\->add( $description => $parser );
.Ve
.PP
The \f(CW$description\fR is usually a test file name (but only by
convention.)  It is used as a unique identifier (see e.g.
\&\*(L"parsers\*(R".)  Reusing a description is a fatal error.
.PP
The \f(CW$parser\fR is a TAP::Parser object.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 3
\&  my $count   = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers;
\&  my @parsers = $aggregate\->parsers(@descriptions);
.Ve
.PP
In scalar context without arguments, this method returns the number of parsers
aggregated.  In list context without arguments, returns the parsers in the
order they were added.
.PP
If \f(CW@descriptions\fR is given, these correspond to the keys used in each
call to the \fIadd()\fR method.  Returns an array of the requested parsers (in
the requested order) in list context or an array reference in scalar
context.
.PP
Requesting an unknown identifier is a fatal error.
.PP
\fI\f(CI\*(C`descriptions\*(C'\fI\fR
.IX Subsection "descriptions"
.PP
Get an array of descriptions in the order in which they were added to
the aggregator.
.PP
\fI\f(CI\*(C`start\*(C'\fI\fR
.IX Subsection "start"
.PP
Call \f(CW\*(C`start\*(C'\fR immediately before adding any results to the aggregator.
Among other times it records the start time for the test run.
.PP
\fI\f(CI\*(C`stop\*(C'\fI\fR
.IX Subsection "stop"
.PP
Call \f(CW\*(C`stop\*(C'\fR immediately after adding all test results to the aggregator.
.PP
\fI\f(CI\*(C`elapsed\*(C'\fI\fR
.IX Subsection "elapsed"
.PP
Elapsed returns a Benchmark object that represents the running time
of the aggregated tests. In order for \f(CW\*(C`elapsed\*(C'\fR to be valid you must
call \f(CW\*(C`start\*(C'\fR before running the tests and \f(CW\*(C`stop\*(C'\fR immediately
afterwards.
.PP
\fI\f(CI\*(C`elapsed_timestr\*(C'\fI\fR
.IX Subsection "elapsed_timestr"
.PP
Returns a formatted string representing the runtime returned by
\&\f(CW\*(C`elapsed()\*(C'\fR.  This lets the caller not worry about Benchmark.
.PP
\fI\f(CI\*(C`all_passed\*(C'\fI\fR
.IX Subsection "all_passed"
.PP
Return true if all the tests passed and no parse errors were detected.
.PP
\fI\f(CI\*(C`get_status\*(C'\fI\fR
.IX Subsection "get_status"
.PP
Get a single word describing the status of the aggregated tests.
Depending on the outcome of the tests returns '\s-1PASS\s0', '\s-1FAIL\s0' or
\&'\s-1NOTESTS\s0'. This token is understood by CPAN::Reporter.
.SS "Summary methods"
.IX Subsection "Summary methods"
Each of the following methods will return the total number of corresponding
tests if called in scalar context.  If called in list context, returns the
descriptions of the parsers which contain the corresponding tests (see \f(CW\*(C`add\*(C'\fR
for an explanation of description.
.IP "\(bu" 4
failed
.IP "\(bu" 4
parse_errors
.IP "\(bu" 4
passed
.IP "\(bu" 4
planned
.IP "\(bu" 4
skipped
.IP "\(bu" 4
todo
.IP "\(bu" 4
todo_passed
.IP "\(bu" 4
wait
.IP "\(bu" 4
exit
.PP
For example, to find out how many tests unexpectedly succeeded (\s-1TODO\s0 tests
which passed when they shouldn't):
.PP
.Vb 2
\& my $count        = $aggregate\->todo_passed;
\& my @descriptions = $aggregate\->todo_passed;
.Ve
.PP
Note that \f(CW\*(C`wait\*(C'\fR and \f(CW\*(C`exit\*(C'\fR are the totals of the wait and exit
statuses of each of the tests. These values are totalled only to provide
a true value if any of them are non-zero.
.PP
\fI\f(CI\*(C`total\*(C'\fI\fR
.IX Subsection "total"
.PP
.Vb 1
\&  my $tests_run = $aggregate\->total;
.Ve
.PP
Returns the total number of tests run.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
Identical to \f(CW\*(C`has_errors\*(C'\fR, but also returns true if any \s-1TODO\s0 tests
unexpectedly succeeded.  This is more akin to \*(L"warnings\*(R".
.PP
\fI\f(CI\*(C`has_errors\*(C'\fI\fR
.IX Subsection "has_errors"
.PP
.Vb 3
\&  if ( $parser\->has_errors ) {
\&      ...
\&  }
.Ve
.PP
Returns true if \fIany\fR of the parsers failed.  This includes:
.IP "\(bu" 4
Failed tests
.IP "\(bu" 4
Parse errors
.IP "\(bu" 4
Bad exit or wait status
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Grammar.3pm                     0100644 0001750 0001750 00000024324 12566207463 024771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Grammar 3pm"
.TH TAP::Parser::Grammar 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Grammar \- A grammar for the Test Anything Protocol.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use TAP::Parser::Grammar;
\&  my $grammar = $self\->make_grammar({
\&    iterator => $tap_parser_iterator,
\&    parser   => $tap_parser,
\&    version  => 12,
\&  });
\&
\&  my $result = $grammar\->tokenize;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Grammar\*(C'\fR tokenizes lines from a TAP::Parser::Iterator and
constructs TAP::Parser::Result subclasses to represent the tokens.
.PP
Do not attempt to use this class directly.  It won't make sense.  It's mainly
here to ensure that we will be able to have pluggable grammars when \s-1TAP\s0 is
expanded at some future date (plus, this stuff was really cluttering the
parser).
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\&  my $grammar = TAP::Parser::Grammar\->new({
\&      iterator => $iterator,
\&      parser   => $parser,
\&      version  => $version,
\&  });
.Ve
.PP
Returns TAP::Parser grammar object that will parse the \s-1TAP\s0 stream from the
specified iterator.  Both \f(CW\*(C`iterator\*(C'\fR and \f(CW\*(C`parser\*(C'\fR are required arguments.
If \f(CW\*(C`version\*(C'\fR is not set it defaults to \f(CW12\fR (see \*(L"set_version\*(R" for more
details).
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`set_version\*(C'\fI\fR
.IX Subsection "set_version"
.PP
.Vb 1
\&  $grammar\->set_version(13);
.Ve
.PP
Tell the grammar which \s-1TAP\s0 syntax version to support. The lowest
supported version is 12. Although '\s-1TAP\s0 version' isn't valid version 12
syntax it is accepted so that higher version numbers may be parsed.
.PP
\fI\f(CI\*(C`tokenize\*(C'\fI\fR
.IX Subsection "tokenize"
.PP
.Vb 1
\&  my $token = $grammar\->tokenize;
.Ve
.PP
This method will return a TAP::Parser::Result object representing the
current line of \s-1TAP.\s0
.PP
\fI\f(CI\*(C`token_types\*(C'\fI\fR
.IX Subsection "token_types"
.PP
.Vb 1
\&  my @types = $grammar\->token_types;
.Ve
.PP
Returns the different types of tokens which this grammar can parse.
.PP
\fI\f(CI\*(C`syntax_for\*(C'\fI\fR
.IX Subsection "syntax_for"
.PP
.Vb 1
\&  my $syntax = $grammar\->syntax_for($token_type);
.Ve
.PP
Returns a pre-compiled regular expression which will match a chunk of \s-1TAP\s0
corresponding to the token type.  For example (not that you should really pay
attention to this, \f(CW\*(C`$grammar\->syntax_for(\*(Aqcomment\*(Aq)\*(C'\fR will return
\&\f(CW\*(C`qr/^#(.*)/\*(C'\fR.
.PP
\fI\f(CI\*(C`handler_for\*(C'\fI\fR
.IX Subsection "handler_for"
.PP
.Vb 1
\&  my $handler = $grammar\->handler_for($token_type);
.Ve
.PP
Returns a code reference which, when passed an appropriate line of \s-1TAP,\s0
returns the lexed token corresponding to that line.  As a result, the basic
\&\s-1TAP\s0 parsing loop looks similar to the following:
.PP
.Vb 10
\& my @tokens;
\& my $grammar = TAP::Grammar\->new;
\& LINE: while ( defined( my $line = $parser\->_next_chunk_of_tap ) ) {
\&     for my $type ( $grammar\->token_types ) {
\&         my $syntax  = $grammar\->syntax_for($type);
\&         if ( $line =~ $syntax ) {
\&             my $handler = $grammar\->handler_for($type);
\&             push @tokens => $grammar\->$handler($line);
\&             next LINE;
\&         }
\&     }
\&     push @tokens => $grammar\->_make_unknown_token($line);
\& }
.Ve
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
\&\fB\s-1NOTE:\s0\fR  This grammar is slightly out of date.  There's still some discussion
about it and a new one will be provided when we have things better defined.
.PP
The TAP::Parser does not use a formal grammar because \s-1TAP\s0 is essentially a
stream-based protocol.  In fact, it's quite legal to have an infinite stream.
For the same reason that we don't apply regexes to streams, we're not using a
formal grammar here.  Instead, we parse the \s-1TAP\s0 in lines.
.PP
For purposes for forward compatibility, any result which does not match the
following grammar is currently referred to as
TAP::Parser::Result::Unknown.  It is \fInot\fR a parse error.
.PP
A formal grammar would look similar to the following:
.PP
.Vb 4
\& (*
\&     For the time being, I\*(Aqm cheating on the EBNF by allowing
\&     certain terms to be defined by POSIX character classes by
\&     using the following syntax:
\&
\&       digit ::= [:digit:]
\&
\&     As far as I am aware, that\*(Aqs not valid EBNF.  Sue me.  I
\&     didn\*(Aqt know how to write "char" otherwise (Unicode issues).
\&     Suggestions welcome.
\& *)
\&
\& tap            ::= version? { comment | unknown } leading_plan lines
\&                    |
\&                    lines trailing_plan {comment}
\&
\& version        ::= \*(AqTAP version \*(Aq positiveInteger {positiveInteger} "\en"
\&
\& leading_plan   ::= plan skip_directive? "\en"
\&
\& trailing_plan  ::= plan "\en"
\&
\& plan           ::= \*(Aq1..\*(Aq nonNegativeInteger
\&
\& lines          ::= line {line}
\&
\& line           ::= (comment | test | unknown | bailout ) "\en"
\&
\& test           ::= status positiveInteger? description? directive?
\&
\& status         ::= \*(Aqnot \*(Aq? \*(Aqok \*(Aq
\&
\& description    ::= (character \- (digit | \*(Aq#\*(Aq)) {character \- \*(Aq#\*(Aq}
\&
\& directive      ::= todo_directive | skip_directive
\&
\& todo_directive ::= hash_mark \*(AqTODO\*(Aq \*(Aq \*(Aq {character}
\&
\& skip_directive ::= hash_mark \*(AqSKIP\*(Aq \*(Aq \*(Aq {character}
\&
\& comment        ::= hash_mark {character}
\&
\& hash_mark      ::= \*(Aq#\*(Aq {\*(Aq \*(Aq}
\&
\& bailout        ::= \*(AqBail out!\*(Aq {character}
\&
\& unknown        ::= { (character \- "\en") }
\&
\& (* POSIX character classes and other terminals *)
\&
\& digit              ::= [:digit:]
\& character          ::= ([:print:] \- "\en")
\& positiveInteger    ::= ( digit \- \*(Aq0\*(Aq ) {digit}
\& nonNegativeInteger ::= digit {digit}
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
If you \fIreally\fR want to subclass TAP::Parser's grammar the best thing to
do is read through the code.  There's no easy way of summarizing it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Result,
                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Grammar5.16.3pm                 0100644 0001750 0001750 00000024003 12566207441 025271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Grammar 3pm"
.TH TAP::Parser::Grammar 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Grammar \- A grammar for the Test Anything Protocol.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use TAP::Parser::Grammar;
\&  my $grammar = $self\->make_grammar({
\&    iterator => $tap_parser_iterator,
\&    parser   => $tap_parser,
\&    version  => 12,
\&  });
\&
\&  my $result = $grammar\->tokenize;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Grammar\*(C'\fR tokenizes lines from a TAP::Parser::Iterator and
constructs TAP::Parser::Result subclasses to represent the tokens.
.PP
Do not attempt to use this class directly.  It won't make sense.  It's mainly
here to ensure that we will be able to have pluggable grammars when \s-1TAP\s0 is
expanded at some future date (plus, this stuff was really cluttering the
parser).
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\&  my $grammar = TAP::Parser::Grammar\->new({
\&      iterator => $iterator,
\&      parser   => $parser,
\&      version  => $version,
\&  });
.Ve
.PP
Returns TAP::Parser grammar object that will parse the \s-1TAP\s0 stream from the
specified iterator.  Both \f(CW\*(C`iterator\*(C'\fR and \f(CW\*(C`parser\*(C'\fR are required arguments.
If \f(CW\*(C`version\*(C'\fR is not set it defaults to \f(CW12\fR (see \*(L"set_version\*(R" for more
details).
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`set_version\*(C'\fI\fR
.IX Subsection "set_version"
.PP
.Vb 1
\&  $grammar\->set_version(13);
.Ve
.PP
Tell the grammar which \s-1TAP\s0 syntax version to support. The lowest
supported version is 12. Although '\s-1TAP\s0 version' isn't valid version 12
syntax it is accepted so that higher version numbers may be parsed.
.PP
\fI\f(CI\*(C`tokenize\*(C'\fI\fR
.IX Subsection "tokenize"
.PP
.Vb 1
\&  my $token = $grammar\->tokenize;
.Ve
.PP
This method will return a TAP::Parser::Result object representing the
current line of \s-1TAP\s0.
.PP
\fI\f(CI\*(C`token_types\*(C'\fI\fR
.IX Subsection "token_types"
.PP
.Vb 1
\&  my @types = $grammar\->token_types;
.Ve
.PP
Returns the different types of tokens which this grammar can parse.
.PP
\fI\f(CI\*(C`syntax_for\*(C'\fI\fR
.IX Subsection "syntax_for"
.PP
.Vb 1
\&  my $syntax = $grammar\->syntax_for($token_type);
.Ve
.PP
Returns a pre-compiled regular expression which will match a chunk of \s-1TAP\s0
corresponding to the token type.  For example (not that you should really pay
attention to this, \f(CW\*(C`$grammar\->syntax_for(\*(Aqcomment\*(Aq)\*(C'\fR will return
\&\f(CW\*(C`qr/^#(.*)/\*(C'\fR.
.PP
\fI\f(CI\*(C`handler_for\*(C'\fI\fR
.IX Subsection "handler_for"
.PP
.Vb 1
\&  my $handler = $grammar\->handler_for($token_type);
.Ve
.PP
Returns a code reference which, when passed an appropriate line of \s-1TAP\s0,
returns the lexed token corresponding to that line.  As a result, the basic
\&\s-1TAP\s0 parsing loop looks similar to the following:
.PP
.Vb 10
\& my @tokens;
\& my $grammar = TAP::Grammar\->new;
\& LINE: while ( defined( my $line = $parser\->_next_chunk_of_tap ) ) {
\&     for my $type ( $grammar\->token_types ) {
\&         my $syntax  = $grammar\->syntax_for($type);
\&         if ( $line =~ $syntax ) {
\&             my $handler = $grammar\->handler_for($type);
\&             push @tokens => $grammar\->$handler($line);
\&             next LINE;
\&         }
\&     }
\&     push @tokens => $grammar\->_make_unknown_token($line);
\& }
.Ve
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
\&\fB\s-1NOTE:\s0\fR  This grammar is slightly out of date.  There's still some discussion
about it and a new one will be provided when we have things better defined.
.PP
The TAP::Parser does not use a formal grammar because \s-1TAP\s0 is essentially a
stream-based protocol.  In fact, it's quite legal to have an infinite stream.
For the same reason that we don't apply regexes to streams, we're not using a
formal grammar here.  Instead, we parse the \s-1TAP\s0 in lines.
.PP
For purposes for forward compatibility, any result which does not match the
following grammar is currently referred to as
TAP::Parser::Result::Unknown.  It is \fInot\fR a parse error.
.PP
A formal grammar would look similar to the following:
.PP
.Vb 4
\& (*
\&     For the time being, I\*(Aqm cheating on the EBNF by allowing
\&     certain terms to be defined by POSIX character classes by
\&     using the following syntax:
\&
\&       digit ::= [:digit:]
\&
\&     As far as I am aware, that\*(Aqs not valid EBNF.  Sue me.  I
\&     didn\*(Aqt know how to write "char" otherwise (Unicode issues).
\&     Suggestions welcome.
\& *)
\&
\& tap            ::= version? { comment | unknown } leading_plan lines
\&                    |
\&                    lines trailing_plan {comment}
\&
\& version        ::= \*(AqTAP version \*(Aq positiveInteger {positiveInteger} "\en"
\&
\& leading_plan   ::= plan skip_directive? "\en"
\&
\& trailing_plan  ::= plan "\en"
\&
\& plan           ::= \*(Aq1..\*(Aq nonNegativeInteger
\&
\& lines          ::= line {line}
\&
\& line           ::= (comment | test | unknown | bailout ) "\en"
\&
\& test           ::= status positiveInteger? description? directive?
\&
\& status         ::= \*(Aqnot \*(Aq? \*(Aqok \*(Aq
\&
\& description    ::= (character \- (digit | \*(Aq#\*(Aq)) {character \- \*(Aq#\*(Aq}
\&
\& directive      ::= todo_directive | skip_directive
\&
\& todo_directive ::= hash_mark \*(AqTODO\*(Aq \*(Aq \*(Aq {character}
\&
\& skip_directive ::= hash_mark \*(AqSKIP\*(Aq \*(Aq \*(Aq {character}
\&
\& comment        ::= hash_mark {character}
\&
\& hash_mark      ::= \*(Aq#\*(Aq {\*(Aq \*(Aq}
\&
\& bailout        ::= \*(AqBail out!\*(Aq {character}
\&
\& unknown        ::= { (character \- "\en") }
\&
\& (* POSIX character classes and other terminals *)
\&
\& digit              ::= [:digit:]
\& character          ::= ([:print:] \- "\en")
\& positiveInteger    ::= ( digit \- \*(Aq0\*(Aq ) {digit}
\& nonNegativeInteger ::= digit {digit}
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.PP
If you \fIreally\fR want to subclass TAP::Parser's grammar the best thing to
do is read through the code.  There's no easy way of summarizing it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Result,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Grammar5.18.3pm                 0100644 0001750 0001750 00000024324 12566207463 025305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Grammar 3pm"
.TH TAP::Parser::Grammar 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Grammar \- A grammar for the Test Anything Protocol.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use TAP::Parser::Grammar;
\&  my $grammar = $self\->make_grammar({
\&    iterator => $tap_parser_iterator,
\&    parser   => $tap_parser,
\&    version  => 12,
\&  });
\&
\&  my $result = $grammar\->tokenize;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Grammar\*(C'\fR tokenizes lines from a TAP::Parser::Iterator and
constructs TAP::Parser::Result subclasses to represent the tokens.
.PP
Do not attempt to use this class directly.  It won't make sense.  It's mainly
here to ensure that we will be able to have pluggable grammars when \s-1TAP\s0 is
expanded at some future date (plus, this stuff was really cluttering the
parser).
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\&  my $grammar = TAP::Parser::Grammar\->new({
\&      iterator => $iterator,
\&      parser   => $parser,
\&      version  => $version,
\&  });
.Ve
.PP
Returns TAP::Parser grammar object that will parse the \s-1TAP\s0 stream from the
specified iterator.  Both \f(CW\*(C`iterator\*(C'\fR and \f(CW\*(C`parser\*(C'\fR are required arguments.
If \f(CW\*(C`version\*(C'\fR is not set it defaults to \f(CW12\fR (see \*(L"set_version\*(R" for more
details).
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`set_version\*(C'\fI\fR
.IX Subsection "set_version"
.PP
.Vb 1
\&  $grammar\->set_version(13);
.Ve
.PP
Tell the grammar which \s-1TAP\s0 syntax version to support. The lowest
supported version is 12. Although '\s-1TAP\s0 version' isn't valid version 12
syntax it is accepted so that higher version numbers may be parsed.
.PP
\fI\f(CI\*(C`tokenize\*(C'\fI\fR
.IX Subsection "tokenize"
.PP
.Vb 1
\&  my $token = $grammar\->tokenize;
.Ve
.PP
This method will return a TAP::Parser::Result object representing the
current line of \s-1TAP.\s0
.PP
\fI\f(CI\*(C`token_types\*(C'\fI\fR
.IX Subsection "token_types"
.PP
.Vb 1
\&  my @types = $grammar\->token_types;
.Ve
.PP
Returns the different types of tokens which this grammar can parse.
.PP
\fI\f(CI\*(C`syntax_for\*(C'\fI\fR
.IX Subsection "syntax_for"
.PP
.Vb 1
\&  my $syntax = $grammar\->syntax_for($token_type);
.Ve
.PP
Returns a pre-compiled regular expression which will match a chunk of \s-1TAP\s0
corresponding to the token type.  For example (not that you should really pay
attention to this, \f(CW\*(C`$grammar\->syntax_for(\*(Aqcomment\*(Aq)\*(C'\fR will return
\&\f(CW\*(C`qr/^#(.*)/\*(C'\fR.
.PP
\fI\f(CI\*(C`handler_for\*(C'\fI\fR
.IX Subsection "handler_for"
.PP
.Vb 1
\&  my $handler = $grammar\->handler_for($token_type);
.Ve
.PP
Returns a code reference which, when passed an appropriate line of \s-1TAP,\s0
returns the lexed token corresponding to that line.  As a result, the basic
\&\s-1TAP\s0 parsing loop looks similar to the following:
.PP
.Vb 10
\& my @tokens;
\& my $grammar = TAP::Grammar\->new;
\& LINE: while ( defined( my $line = $parser\->_next_chunk_of_tap ) ) {
\&     for my $type ( $grammar\->token_types ) {
\&         my $syntax  = $grammar\->syntax_for($type);
\&         if ( $line =~ $syntax ) {
\&             my $handler = $grammar\->handler_for($type);
\&             push @tokens => $grammar\->$handler($line);
\&             next LINE;
\&         }
\&     }
\&     push @tokens => $grammar\->_make_unknown_token($line);
\& }
.Ve
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
\&\fB\s-1NOTE:\s0\fR  This grammar is slightly out of date.  There's still some discussion
about it and a new one will be provided when we have things better defined.
.PP
The TAP::Parser does not use a formal grammar because \s-1TAP\s0 is essentially a
stream-based protocol.  In fact, it's quite legal to have an infinite stream.
For the same reason that we don't apply regexes to streams, we're not using a
formal grammar here.  Instead, we parse the \s-1TAP\s0 in lines.
.PP
For purposes for forward compatibility, any result which does not match the
following grammar is currently referred to as
TAP::Parser::Result::Unknown.  It is \fInot\fR a parse error.
.PP
A formal grammar would look similar to the following:
.PP
.Vb 4
\& (*
\&     For the time being, I\*(Aqm cheating on the EBNF by allowing
\&     certain terms to be defined by POSIX character classes by
\&     using the following syntax:
\&
\&       digit ::= [:digit:]
\&
\&     As far as I am aware, that\*(Aqs not valid EBNF.  Sue me.  I
\&     didn\*(Aqt know how to write "char" otherwise (Unicode issues).
\&     Suggestions welcome.
\& *)
\&
\& tap            ::= version? { comment | unknown } leading_plan lines
\&                    |
\&                    lines trailing_plan {comment}
\&
\& version        ::= \*(AqTAP version \*(Aq positiveInteger {positiveInteger} "\en"
\&
\& leading_plan   ::= plan skip_directive? "\en"
\&
\& trailing_plan  ::= plan "\en"
\&
\& plan           ::= \*(Aq1..\*(Aq nonNegativeInteger
\&
\& lines          ::= line {line}
\&
\& line           ::= (comment | test | unknown | bailout ) "\en"
\&
\& test           ::= status positiveInteger? description? directive?
\&
\& status         ::= \*(Aqnot \*(Aq? \*(Aqok \*(Aq
\&
\& description    ::= (character \- (digit | \*(Aq#\*(Aq)) {character \- \*(Aq#\*(Aq}
\&
\& directive      ::= todo_directive | skip_directive
\&
\& todo_directive ::= hash_mark \*(AqTODO\*(Aq \*(Aq \*(Aq {character}
\&
\& skip_directive ::= hash_mark \*(AqSKIP\*(Aq \*(Aq \*(Aq {character}
\&
\& comment        ::= hash_mark {character}
\&
\& hash_mark      ::= \*(Aq#\*(Aq {\*(Aq \*(Aq}
\&
\& bailout        ::= \*(AqBail out!\*(Aq {character}
\&
\& unknown        ::= { (character \- "\en") }
\&
\& (* POSIX character classes and other terminals *)
\&
\& digit              ::= [:digit:]
\& character          ::= ([:print:] \- "\en")
\& positiveInteger    ::= ( digit \- \*(Aq0\*(Aq ) {digit}
\& nonNegativeInteger ::= digit {digit}
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
If you \fIreally\fR want to subclass TAP::Parser's grammar the best thing to
do is read through the code.  There's no easy way of summarizing it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Result,
                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator.3pm                    0100644 0001750 0001750 00000015235 12566207463 025175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator 3pm"
.TH TAP::Parser::Iterator 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator \- Base class for TAP source iterators
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # to subclass:
\&  use vars qw(@ISA);
\&  use TAP::Parser::Iterator ();
\&  @ISA = qw(TAP::Parser::Iterator);
\&  sub _initialize {
\&    # see TAP::Object...
\&  }
\&
\&  sub next_raw { ... }
\&  sub wait     { ... }
\&  sub exit     { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator base class that defines TAP::Parser's iterator
\&\s-1API. \s0 Iterators are typically created from TAP::Parser::SourceHandlers.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Provided by TAP::Object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 1
\& while ( my $item = $iter\->next ) { ... }
.Ve
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& while ( my $item = $iter\->next_raw ) { ... }
.Ve
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
If necessary switch the input stream to handle unicode. This only has
any effect for I/O handle based streams.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle-based should return an empty list.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->wait;
.Ve
.PP
Return the \f(CW\*(C`wait\*(C'\fR status for this iterator.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->exit;
.Ve
.PP
Return the \f(CW\*(C`exit\*(C'\fR status for this iterator.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
You must override the abstract methods as noted above.
.SS "Example"
.IX Subsection "Example"
TAP::Parser::Iterator::Array is probably the easiest example to follow.
There's not much point repeating it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator::Array,
TAP::Parser::Iterator::Stream,
TAP::Parser::Iterator::Process,
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator5.16.3pm                0100644 0001750 0001750 00000014714 12566207441 025504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator 3pm"
.TH TAP::Parser::Iterator 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator \- Base class for TAP source iterators
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # to subclass:
\&  use vars qw(@ISA);
\&  use TAP::Parser::Iterator ();
\&  @ISA = qw(TAP::Parser::Iterator);
\&  sub _initialize {
\&    # see TAP::Object...
\&  }
\&
\&  sub next_raw { ... }
\&  sub wait     { ... }
\&  sub exit     { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator base class that defines TAP::Parser's iterator
\&\s-1API\s0.  Iterators are typically created from TAP::Parser::SourceHandlers.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Provided by TAP::Object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 1
\& while ( my $item = $iter\->next ) { ... }
.Ve
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& while ( my $item = $iter\->next_raw ) { ... }
.Ve
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
If necessary switch the input stream to handle unicode. This only has
any effect for I/O handle based streams.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle-based should return an empty list.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->wait;
.Ve
.PP
Return the \f(CW\*(C`wait\*(C'\fR status for this iterator.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->exit;
.Ve
.PP
Return the \f(CW\*(C`exit\*(C'\fR status for this iterator.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.PP
You must override the abstract methods as noted above.
.SS "Example"
.IX Subsection "Example"
TAP::Parser::Iterator::Array is probably the easiest example to follow.
There's not much point repeating it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator::Array,
TAP::Parser::Iterator::Stream,
TAP::Parser::Iterator::Process,
                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator5.18.3pm                0100644 0001750 0001750 00000015235 12566207463 025511  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator 3pm"
.TH TAP::Parser::Iterator 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator \- Base class for TAP source iterators
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # to subclass:
\&  use vars qw(@ISA);
\&  use TAP::Parser::Iterator ();
\&  @ISA = qw(TAP::Parser::Iterator);
\&  sub _initialize {
\&    # see TAP::Object...
\&  }
\&
\&  sub next_raw { ... }
\&  sub wait     { ... }
\&  sub exit     { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator base class that defines TAP::Parser's iterator
\&\s-1API. \s0 Iterators are typically created from TAP::Parser::SourceHandlers.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Provided by TAP::Object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 1
\& while ( my $item = $iter\->next ) { ... }
.Ve
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& while ( my $item = $iter\->next_raw ) { ... }
.Ve
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
If necessary switch the input stream to handle unicode. This only has
any effect for I/O handle based streams.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle-based should return an empty list.
.PP
The default implementation does nothing.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->wait;
.Ve
.PP
Return the \f(CW\*(C`wait\*(C'\fR status for this iterator.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
\&\fBNote:\fR this method is abstract and should be overridden.
.PP
.Vb 1
\& my $wait_status = $iter\->exit;
.Ve
.PP
Return the \f(CW\*(C`exit\*(C'\fR status for this iterator.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
You must override the abstract methods as noted above.
.SS "Example"
.IX Subsection "Example"
TAP::Parser::Iterator::Array is probably the easiest example to follow.
There's not much point repeating it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator::Array,
TAP::Parser::Iterator::Stream,
TAP::Parser::Iterator::Process,
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Array.3pm             0100644 0001750 0001750 00000012710 12566207463 026353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Array 3pm"
.TH TAP::Parser::Iterator::Array 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Array \- Iterator for array\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Array;
\&  my @data = (\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, baz\*(Aq);
\&  my $it   = TAP::Parser::Iterator::Array\->new(\e@data);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for arrays of scalar content, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Takes one argument: an \f(CW$array_ref\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. For an array iterator this will always
be zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. For an array iterator this will always
be zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Array5.16.3pm         0100644 0001750 0001750 00000012367 12566207441 026671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Array 3pm"
.TH TAP::Parser::Iterator::Array 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Array \- Iterator for array\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Array;
\&  my @data = (\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, baz\*(Aq);
\&  my $it   = TAP::Parser::Iterator::Array\->new(\e@data);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for arrays of scalar content, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Takes one argument: an \f(CW$array_ref\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. For an array iterator this will always
be zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. For an array iterator this will always
be zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Array5.18.3pm         0100644 0001750 0001750 00000012710 12566207463 026667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Array 3pm"
.TH TAP::Parser::Iterator::Array 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Array \- Iterator for array\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Array;
\&  my @data = (\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, baz\*(Aq);
\&  my $it   = TAP::Parser::Iterator::Array\->new(\e@data);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for arrays of scalar content, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Takes one argument: an \f(CW$array_ref\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. For an array iterator this will always
be zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. For an array iterator this will always
be zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Process.3pm           0100644 0001750 0001750 00000014406 12566207463 026717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Process 3pm"
.TH TAP::Parser::Iterator::Process 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Process \- Iterator for process\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  use TAP::Parser::Iterator::Process;
\&  my %args = (
\&   command  => [\*(Aqpython\*(Aq, \*(Aqsetup.py\*(Aq, \*(Aqtest\*(Aq],
\&   merge    => 1,
\&   setup    => sub { ... },
\&   teardown => sub { ... },
\&  );
\&  my $it   = TAP::Parser::Iterator::Process\->new(\e%args);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for executing external processes, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a hashref of the form:
.PP
.Vb 4
\&   command  => \e@command_to_execute
\&   merge    => $attempt_merge_stderr_and_stdout?
\&   setup    => $callback_to_setup_command
\&   teardown => $callback_to_teardown_command
.Ve
.PP
Tries to uses IPC::Open3 & IO::Select to communicate with the spawned
process if they are available.  Falls back onto \f(CW\*(C`open()\*(C'\fR.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through the process output, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator's process.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator's process.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
Upgrade the input stream to handle \s-1UTF8.\s0
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle based should return an empty list.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Process5.16.3pm       0100644 0001750 0001750 00000014065 12566207441 027226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Process 3pm"
.TH TAP::Parser::Iterator::Process 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Process \- Iterator for process\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  use TAP::Parser::Iterator::Process;
\&  my %args = (
\&   command  => [\*(Aqpython\*(Aq, \*(Aqsetup.py\*(Aq, \*(Aqtest\*(Aq],
\&   merge    => 1,
\&   setup    => sub { ... },
\&   teardown => sub { ... },
\&  );
\&  my $it   = TAP::Parser::Iterator::Process\->new(\e%args);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for executing external processes, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a hashref of the form:
.PP
.Vb 4
\&   command  => \e@command_to_execute
\&   merge    => $attempt_merge_stderr_and_stdout?
\&   setup    => $callback_to_setup_command
\&   teardown => $callback_to_teardown_command
.Ve
.PP
Tries to uses IPC::Open3 & IO::Select to communicate with the spawned
process if they are available.  Falls back onto \f(CW\*(C`open()\*(C'\fR.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through the process output, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator's process.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator's process.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
Upgrade the input stream to handle \s-1UTF8\s0.
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle based should return an empty list.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Process5.18.3pm       0100644 0001750 0001750 00000014406 12566207463 027233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Process 3pm"
.TH TAP::Parser::Iterator::Process 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Process \- Iterator for process\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  use TAP::Parser::Iterator::Process;
\&  my %args = (
\&   command  => [\*(Aqpython\*(Aq, \*(Aqsetup.py\*(Aq, \*(Aqtest\*(Aq],
\&   merge    => 1,
\&   setup    => sub { ... },
\&   teardown => sub { ... },
\&  );
\&  my $it   = TAP::Parser::Iterator::Process\->new(\e%args);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for executing external processes, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a hashref of the form:
.PP
.Vb 4
\&   command  => \e@command_to_execute
\&   merge    => $attempt_merge_stderr_and_stdout?
\&   setup    => $callback_to_setup_command
\&   teardown => $callback_to_teardown_command
.Ve
.PP
Tries to uses IPC::Open3 & IO::Select to communicate with the spawned
process if they are available.  Falls back onto \f(CW\*(C`open()\*(C'\fR.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through the process output, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator's process.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator's process.
.PP
\fI\f(CI\*(C`handle_unicode\*(C'\fI\fR
.IX Subsection "handle_unicode"
.PP
Upgrade the input stream to handle \s-1UTF8.\s0
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Return a list of filehandles that may be used upstream in a \fIselect()\fR
call to signal that this Iterator is ready. Iterators that are not
handle based should return an empty list.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Stream.3pm            0100644 0001750 0001750 00000012615 12566207463 026534  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Stream 3pm"
.TH TAP::Parser::Iterator::Stream 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Stream \- Iterator for filehandle\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Stream;
\&  open( TEST, \*(Aqtest.tap\*(Aq );
\&  my $it   = TAP::Parser::Iterator::Stream\->new(\e*TEST);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for reading from filehandles, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a filehandle.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. Always returns zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. Always returns zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Stream5.16.3pm        0100644 0001750 0001750 00000012274 12566207441 027043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Stream 3pm"
.TH TAP::Parser::Iterator::Stream 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Stream \- Iterator for filehandle\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Stream;
\&  open( TEST, \*(Aqtest.tap\*(Aq );
\&  my $it   = TAP::Parser::Iterator::Stream\->new(\e*TEST);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for reading from filehandles, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a filehandle.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. Always returns zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. Always returns zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Iterator::Stream5.18.3pm        0100644 0001750 0001750 00000012615 12566207463 027050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Iterator::Stream 3pm"
.TH TAP::Parser::Iterator::Stream 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Iterator::Stream \- Iterator for filehandle\-based TAP sources
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::Iterator::Stream;
\&  open( TEST, \*(Aqtest.tap\*(Aq );
\&  my $it   = TAP::Parser::Iterator::Stream\->new(\e*TEST);
\&  my $line = $it\->next;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple iterator wrapper for reading from filehandles, used by
TAP::Parser.  Unless you're writing a plugin or subclassing, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Create an iterator.  Expects one argument containing a filehandle.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Iterate through it, of course.
.PP
\fI\f(CI\*(C`next_raw\*(C'\fI\fR
.IX Subsection "next_raw"
.PP
Iterate raw input without applying any fixes for quirky input syntax.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
Get the wait status for this iterator. Always returns zero.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
Get the exit status for this iterator. Always returns zero.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::IteratorFactory.3pm             0100644 0001750 0001750 00000021105 12566207463 026516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::IteratorFactory 3pm"
.TH TAP::Parser::IteratorFactory 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::IteratorFactory \- Figures out which SourceHandler objects to use for a given Source
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use TAP::Parser::IteratorFactory;
\&  my $factory = TAP::Parser::IteratorFactory\->new({ %config });
\&  my $iterator  = $factory\->make_iterator( $filename );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a factory class that takes a TAP::Parser::Source and runs it through all the
registered TAP::Parser::SourceHandlers to see which one should handle the source.
.PP
If you're a plugin author, you'll be interested in how to \*(L"register_handler\*(R"s,
how \*(L"detect_source\*(R" works.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class:
.PP
.Vb 1
\&  my $sf = TAP::Parser::IteratorFactory\->new( $config );
.Ve
.PP
\&\f(CW$config\fR is optional.  If given, sets \*(L"config\*(R" and calls \*(L"load_handlers\*(R".
.PP
\fI\f(CI\*(C`register_handler\*(C'\fI\fR
.IX Subsection "register_handler"
.PP
Registers a new TAP::Parser::SourceHandler with this factory.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->register_handler( $handler_class );
.Ve
.PP
\fI\f(CI\*(C`handlers\*(C'\fI\fR
.IX Subsection "handlers"
.PP
List of handlers that have been registered.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\& my $cfg = $sf\->config;
\& $sf\->config({ Perl => { %config } });
.Ve
.PP
Chaining getter/setter for the configuration of the available source handlers.
This is a hashref keyed on handler class whose values contain config to be passed
onto the handlers during detection & creation.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $sf\->config({ \*(AqTAP::Parser::SourceHandler::Perl\*(Aq => { %config } });
\&  $sf\->config({ \*(AqPerl\*(Aq => { %config } });
.Ve
.PP
\fI\f(CI\*(C`load_handlers\*(C'\fI\fR
.IX Subsection "load_handlers"
.PP
.Vb 1
\& $sf\->load_handlers;
.Ve
.PP
Loads the handler classes defined in \*(L"config\*(R".  For example, given a config:
.PP
.Vb 3
\&  $sf\->config({
\&    MySourceHandler => { some => \*(Aqconfig\*(Aq },
\&  });
.Ve
.PP
\&\f(CW\*(C`load_handlers\*(C'\fR will attempt to load the \f(CW\*(C`MySourceHandler\*(C'\fR class by looking in
\&\f(CW@INC\fR for it in this order:
.PP
.Vb 2
\&  TAP::Parser::SourceHandler::MySourceHandler
\&  MySourceHandler
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $src_factory\->make_iterator( $source );
.Ve
.PP
Given a TAP::Parser::Source, finds the most suitable TAP::Parser::SourceHandler
to use to create a TAP::Parser::Iterator (see \*(L"detect_source\*(R").  Dies on error.
.PP
\fI\f(CI\*(C`detect_source\*(C'\fI\fR
.IX Subsection "detect_source"
.PP
Given a TAP::Parser::Source, detects what kind of source it is and
returns \fIone\fR TAP::Parser::SourceHandler (the most confident one).  Dies
on error.
.PP
The detection algorithm works something like this:
.PP
.Vb 5
\&  for (@registered_handlers) {
\&    # ask them how confident they are about handling this source
\&    $confidence{$handler} = $handler\->can_handle( $source )
\&  }
\&  # choose the most confident handler
.Ve
.PP
Ties are handled by choosing the first handler.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
If we've done things right, you'll probably want to write a new source,
rather than sub-classing this (see TAP::Parser::SourceHandler for that).
.PP
But in case you find the need to...
.PP
.Vb 1
\&  package MyIteratorFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::IteratorFactory );
\&
\&  # override source detection algorithm
\&  sub detect_source {
\&    my ($self, $raw_source_ref, $meta) = @_;
\&    # do detective work, using $meta and whatever else...
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.PP
Moved out of TAP::Parser & converted to a factory class to support
extensible \s-1TAP\s0 source detective work by Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::RawTAP,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::Executable
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::IteratorFactory5.16.3pm         0100644 0001750 0001750 00000020564 12566207441 027034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::IteratorFactory 3pm"
.TH TAP::Parser::IteratorFactory 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::IteratorFactory \- Figures out which SourceHandler objects to use for a given Source
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use TAP::Parser::IteratorFactory;
\&  my $factory = TAP::Parser::IteratorFactory\->new({ %config });
\&  my $iterator  = $factory\->make_iterator( $filename );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a factory class that takes a TAP::Parser::Source and runs it through all the
registered TAP::Parser::SourceHandlers to see which one should handle the source.
.PP
If you're a plugin author, you'll be interested in how to \*(L"register_handler\*(R"s,
how \*(L"detect_source\*(R" works.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class:
.PP
.Vb 1
\&  my $sf = TAP::Parser::IteratorFactory\->new( $config );
.Ve
.PP
\&\f(CW$config\fR is optional.  If given, sets \*(L"config\*(R" and calls \*(L"load_handlers\*(R".
.PP
\fI\f(CI\*(C`register_handler\*(C'\fI\fR
.IX Subsection "register_handler"
.PP
Registers a new TAP::Parser::SourceHandler with this factory.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->register_handler( $handler_class );
.Ve
.PP
\fI\f(CI\*(C`handlers\*(C'\fI\fR
.IX Subsection "handlers"
.PP
List of handlers that have been registered.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\& my $cfg = $sf\->config;
\& $sf\->config({ Perl => { %config } });
.Ve
.PP
Chaining getter/setter for the configuration of the available source handlers.
This is a hashref keyed on handler class whose values contain config to be passed
onto the handlers during detection & creation.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $sf\->config({ \*(AqTAP::Parser::SourceHandler::Perl\*(Aq => { %config } });
\&  $sf\->config({ \*(AqPerl\*(Aq => { %config } });
.Ve
.PP
\fI\f(CI\*(C`load_handlers\*(C'\fI\fR
.IX Subsection "load_handlers"
.PP
.Vb 1
\& $sf\->load_handlers;
.Ve
.PP
Loads the handler classes defined in \*(L"config\*(R".  For example, given a config:
.PP
.Vb 3
\&  $sf\->config({
\&    MySourceHandler => { some => \*(Aqconfig\*(Aq },
\&  });
.Ve
.PP
\&\f(CW\*(C`load_handlers\*(C'\fR will attempt to load the \f(CW\*(C`MySourceHandler\*(C'\fR class by looking in
\&\f(CW@INC\fR for it in this order:
.PP
.Vb 2
\&  TAP::Parser::SourceHandler::MySourceHandler
\&  MySourceHandler
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $src_factory\->make_iterator( $source );
.Ve
.PP
Given a TAP::Parser::Source, finds the most suitable TAP::Parser::SourceHandler
to use to create a TAP::Parser::Iterator (see \*(L"detect_source\*(R").  Dies on error.
.PP
\fI\f(CI\*(C`detect_source\*(C'\fI\fR
.IX Subsection "detect_source"
.PP
Given a TAP::Parser::Source, detects what kind of source it is and
returns \fIone\fR TAP::Parser::SourceHandler (the most confident one).  Dies
on error.
.PP
The detection algorithm works something like this:
.PP
.Vb 5
\&  for (@registered_handlers) {
\&    # ask them how confident they are about handling this source
\&    $confidence{$handler} = $handler\->can_handle( $source )
\&  }
\&  # choose the most confident handler
.Ve
.PP
Ties are handled by choosing the first handler.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
If we've done things right, you'll probably want to write a new source,
rather than sub-classing this (see TAP::Parser::SourceHandler for that).
.PP
But in case you find the need to...
.PP
.Vb 1
\&  package MyIteratorFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::IteratorFactory );
\&
\&  # override source detection algorithm
\&  sub detect_source {
\&    my ($self, $raw_source_ref, $meta) = @_;
\&    # do detective work, using $meta and whatever else...
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.PP
Moved out of TAP::Parser & converted to a factory class to support
extensible \s-1TAP\s0 source detective work by Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::RawTAP,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::Executable
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::IteratorFactory5.18.3pm         0100644 0001750 0001750 00000021105 12566207463 027032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::IteratorFactory 3pm"
.TH TAP::Parser::IteratorFactory 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::IteratorFactory \- Figures out which SourceHandler objects to use for a given Source
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use TAP::Parser::IteratorFactory;
\&  my $factory = TAP::Parser::IteratorFactory\->new({ %config });
\&  my $iterator  = $factory\->make_iterator( $filename );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a factory class that takes a TAP::Parser::Source and runs it through all the
registered TAP::Parser::SourceHandlers to see which one should handle the source.
.PP
If you're a plugin author, you'll be interested in how to \*(L"register_handler\*(R"s,
how \*(L"detect_source\*(R" works.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class:
.PP
.Vb 1
\&  my $sf = TAP::Parser::IteratorFactory\->new( $config );
.Ve
.PP
\&\f(CW$config\fR is optional.  If given, sets \*(L"config\*(R" and calls \*(L"load_handlers\*(R".
.PP
\fI\f(CI\*(C`register_handler\*(C'\fI\fR
.IX Subsection "register_handler"
.PP
Registers a new TAP::Parser::SourceHandler with this factory.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->register_handler( $handler_class );
.Ve
.PP
\fI\f(CI\*(C`handlers\*(C'\fI\fR
.IX Subsection "handlers"
.PP
List of handlers that have been registered.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\& my $cfg = $sf\->config;
\& $sf\->config({ Perl => { %config } });
.Ve
.PP
Chaining getter/setter for the configuration of the available source handlers.
This is a hashref keyed on handler class whose values contain config to be passed
onto the handlers during detection & creation.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $sf\->config({ \*(AqTAP::Parser::SourceHandler::Perl\*(Aq => { %config } });
\&  $sf\->config({ \*(AqPerl\*(Aq => { %config } });
.Ve
.PP
\fI\f(CI\*(C`load_handlers\*(C'\fI\fR
.IX Subsection "load_handlers"
.PP
.Vb 1
\& $sf\->load_handlers;
.Ve
.PP
Loads the handler classes defined in \*(L"config\*(R".  For example, given a config:
.PP
.Vb 3
\&  $sf\->config({
\&    MySourceHandler => { some => \*(Aqconfig\*(Aq },
\&  });
.Ve
.PP
\&\f(CW\*(C`load_handlers\*(C'\fR will attempt to load the \f(CW\*(C`MySourceHandler\*(C'\fR class by looking in
\&\f(CW@INC\fR for it in this order:
.PP
.Vb 2
\&  TAP::Parser::SourceHandler::MySourceHandler
\&  MySourceHandler
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $src_factory\->make_iterator( $source );
.Ve
.PP
Given a TAP::Parser::Source, finds the most suitable TAP::Parser::SourceHandler
to use to create a TAP::Parser::Iterator (see \*(L"detect_source\*(R").  Dies on error.
.PP
\fI\f(CI\*(C`detect_source\*(C'\fI\fR
.IX Subsection "detect_source"
.PP
Given a TAP::Parser::Source, detects what kind of source it is and
returns \fIone\fR TAP::Parser::SourceHandler (the most confident one).  Dies
on error.
.PP
The detection algorithm works something like this:
.PP
.Vb 5
\&  for (@registered_handlers) {
\&    # ask them how confident they are about handling this source
\&    $confidence{$handler} = $handler\->can_handle( $source )
\&  }
\&  # choose the most confident handler
.Ve
.PP
Ties are handled by choosing the first handler.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
If we've done things right, you'll probably want to write a new source,
rather than sub-classing this (see TAP::Parser::SourceHandler for that).
.PP
But in case you find the need to...
.PP
.Vb 1
\&  package MyIteratorFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::IteratorFactory );
\&
\&  # override source detection algorithm
\&  sub detect_source {
\&    my ($self, $raw_source_ref, $meta) = @_;
\&    # do detective work, using $meta and whatever else...
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
Originally ripped off from Test::Harness.
.PP
Moved out of TAP::Parser & converted to a factory class to support
extensible \s-1TAP\s0 source detective work by Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::RawTAP,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::Executable
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Multiplexer.3pm                 0100644 0001750 0001750 00000014463 12566207463 025720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Multiplexer 3pm"
.TH TAP::Parser::Multiplexer 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Multiplexer \- Multiplex multiple TAP::Parsers
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Multiplexer;
\&
\&    my $mux = TAP::Parser::Multiplexer\->new;
\&    $mux\->add( $parser1, $stash1 );
\&    $mux\->add( $parser2, $stash2 );
\&    while ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        # do stuff
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR gathers input from multiple TAP::Parsers.
Internally it calls select on the input file handles for those parsers
to wait for one or more of them to have input available.
.PP
See TAP::Harness for an example of its use.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $mux = TAP::Parser::Multiplexer\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $mux\->add( $parser, $stash );
.Ve
.PP
Add a TAP::Parser to the multiplexer. \f(CW$stash\fR is an optional opaque
reference that will be returned from \f(CW\*(C`next\*(C'\fR along with the parser and
the next result.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 1
\&  my $count   = $mux\->parsers;
.Ve
.PP
Returns the number of parsers. Parsers are removed from the multiplexer
when their input is exhausted.
.PP
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Return a result from the next available parser. Returns a list
containing the parser from which the result came, the stash that
corresponds with that parser and the result.
.PP
.Vb 1
\&    my ( $parser, $stash, $result ) = $mux\->next;
.Ve
.PP
If \f(CW$result\fR is undefined the corresponding parser has reached the end
of its input (and will automatically be removed from the multiplexer).
.PP
When all parsers are exhausted an empty list will be returned.
.PP
.Vb 11
\&    if ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        if ( ! defined $result ) {
\&            # End of this parser
\&        }
\&        else {
\&            # Process result
\&        }
\&    }
\&    else {
\&        # All parsers finished
\&    }
.Ve
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Multiplexer5.16.3pm             0100644 0001750 0001750 00000014142 12566207441 026220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Multiplexer 3pm"
.TH TAP::Parser::Multiplexer 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Multiplexer \- Multiplex multiple TAP::Parsers
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Multiplexer;
\&
\&    my $mux = TAP::Parser::Multiplexer\->new;
\&    $mux\->add( $parser1, $stash1 );
\&    $mux\->add( $parser2, $stash2 );
\&    while ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        # do stuff
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR gathers input from multiple TAP::Parsers.
Internally it calls select on the input file handles for those parsers
to wait for one or more of them to have input available.
.PP
See TAP::Harness for an example of its use.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $mux = TAP::Parser::Multiplexer\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $mux\->add( $parser, $stash );
.Ve
.PP
Add a TAP::Parser to the multiplexer. \f(CW$stash\fR is an optional opaque
reference that will be returned from \f(CW\*(C`next\*(C'\fR along with the parser and
the next result.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 1
\&  my $count   = $mux\->parsers;
.Ve
.PP
Returns the number of parsers. Parsers are removed from the multiplexer
when their input is exhausted.
.PP
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Return a result from the next available parser. Returns a list
containing the parser from which the result came, the stash that
corresponds with that parser and the result.
.PP
.Vb 1
\&    my ( $parser, $stash, $result ) = $mux\->next;
.Ve
.PP
If \f(CW$result\fR is undefined the corresponding parser has reached the end
of its input (and will automatically be removed from the multiplexer).
.PP
When all parsers are exhausted an empty list will be returned.
.PP
.Vb 11
\&    if ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        if ( ! defined $result ) {
\&            # End of this parser
\&        }
\&        else {
\&            # Process result
\&        }
\&    }
\&    else {
\&        # All parsers finished
\&    }
.Ve
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Multiplexer5.18.3pm             0100644 0001750 0001750 00000014463 12566207463 026234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Multiplexer 3pm"
.TH TAP::Parser::Multiplexer 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Multiplexer \- Multiplex multiple TAP::Parsers
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Multiplexer;
\&
\&    my $mux = TAP::Parser::Multiplexer\->new;
\&    $mux\->add( $parser1, $stash1 );
\&    $mux\->add( $parser2, $stash2 );
\&    while ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        # do stuff
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR gathers input from multiple TAP::Parsers.
Internally it calls select on the input file handles for those parsers
to wait for one or more of them to have input available.
.PP
See TAP::Harness for an example of its use.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $mux = TAP::Parser::Multiplexer\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Multiplexer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $mux\->add( $parser, $stash );
.Ve
.PP
Add a TAP::Parser to the multiplexer. \f(CW$stash\fR is an optional opaque
reference that will be returned from \f(CW\*(C`next\*(C'\fR along with the parser and
the next result.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 1
\&  my $count   = $mux\->parsers;
.Ve
.PP
Returns the number of parsers. Parsers are removed from the multiplexer
when their input is exhausted.
.PP
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
Return a result from the next available parser. Returns a list
containing the parser from which the result came, the stash that
corresponds with that parser and the result.
.PP
.Vb 1
\&    my ( $parser, $stash, $result ) = $mux\->next;
.Ve
.PP
If \f(CW$result\fR is undefined the corresponding parser has reached the end
of its input (and will automatically be removed from the multiplexer).
.PP
When all parsers are exhausted an empty list will be returned.
.PP
.Vb 11
\&    if ( my ( $parser, $stash, $result ) = $mux\->next ) {
\&        if ( ! defined $result ) {
\&            # End of this parser
\&        }
\&        else {
\&            # Process result
\&        }
\&    }
\&    else {
\&        # All parsers finished
\&    }
.Ve
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result.3pm                      0100644 0001750 0001750 00000022200 12566207463 024650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result 3pm"
.TH TAP::Parser::Result 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result \- Base class for TAP::Parser output objects
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- not meant to be used directly
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # directly:
\&  use TAP::Parser::Result;
\&  my $token  = {...};
\&  my $result = TAP::Parser::Result\->new( $token );
.Ve
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple base class used by TAP::Parser to store objects that
represent the current bit of test output data from \s-1TAP \s0(usually a single
line).  Unless you're subclassing, you probably won't need to use this module
directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # to use directly:
\&  my $result = TAP::Parser::Result\->new($token);
.Ve
.PP
Returns an instance the appropriate class for the test token passed in.
.SS "Boolean methods"
.IX Subsection "Boolean methods"
The following methods all return a boolean value and are to be overridden in
the appropriate subclass.
.IP "\(bu" 4
\&\f(CW\*(C`is_plan\*(C'\fR
.Sp
Indicates whether or not this is the test plan line.
.Sp
.Vb 1
\& 1..3
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_pragma\*(C'\fR
.Sp
Indicates whether or not this is a pragma line.
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_test\*(C'\fR
.Sp
Indicates whether or not this is a test line.
.Sp
.Vb 1
\& ok 1 Is OK!
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_comment\*(C'\fR
.Sp
Indicates whether or not this is a comment.
.Sp
.Vb 1
\& # this is a comment
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_bailout\*(C'\fR
.Sp
Indicates whether or not this is bailout line.
.Sp
.Vb 1
\& Bail out! We\*(Aqre out of dilithium crystals.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_version\*(C'\fR
.Sp
Indicates whether or not this is a \s-1TAP\s0 version line.
.Sp
.Vb 1
\& TAP version 4
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_unknown\*(C'\fR
.Sp
Indicates whether or not the current line could be parsed.
.Sp
.Vb 1
\& ... this line is junk ...
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_yaml\*(C'\fR
.Sp
Indicates whether or not this is a \s-1YAML\s0 chunk.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 1
\&  print $result\->raw;
.Ve
.PP
Returns the original line of text which was parsed.
.PP
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
.Vb 1
\&  my $type = $result\->type;
.Ve
.PP
Returns the \*(L"type\*(R" of a token, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`has_directive\*(C'\fI\fR
.IX Subsection "has_directive"
.PP
.Vb 3
\&  if ( $result\->has_directive ) {
\&     ...
\&  }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 or \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 3
\& if ( $result\->has_todo ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 directive.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 3
\& if ( $result\->has_skip ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`set_directive\*(C'\fI\fR
.IX Subsection "set_directive"
.PP
Set the directive associated with this token. Used internally to fake
\&\s-1TODO\s0 tests.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
Remember: if you want your subclass to be automatically used by the parser,
you'll have to register it with \*(L"register_type\*(R" in TAP::Parser::ResultFactory.
.PP
If you're creating a completely new result \fItype\fR, you'll probably need to
subclass TAP::Parser::Grammar too, or else it'll never get used.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResult;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  sub as_string { \*(AqMy results all look the same\*(Aq }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::ResultFactory,
TAP::Parser::Result::Bailout,
TAP::Parser::Result::Comment,
TAP::Parser::Result::Plan,
TAP::Parser::Result::Pragma,
TAP::Parser::Result::Test,
TAP::Parser::Result::Unknown,
TAP::Parser::Result::Version,
TAP::Parser::Result::YAML,
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result5.16.3pm                  0100644 0001750 0001750 00000021657 12566207441 025175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result 3pm"
.TH TAP::Parser::Result 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result \- Base class for TAP::Parser output objects
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- not meant to be used directly
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # directly:
\&  use TAP::Parser::Result;
\&  my $token  = {...};
\&  my $result = TAP::Parser::Result\->new( $token );
.Ve
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple base class used by TAP::Parser to store objects that
represent the current bit of test output data from \s-1TAP\s0 (usually a single
line).  Unless you're subclassing, you probably won't need to use this module
directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # to use directly:
\&  my $result = TAP::Parser::Result\->new($token);
.Ve
.PP
Returns an instance the appropriate class for the test token passed in.
.SS "Boolean methods"
.IX Subsection "Boolean methods"
The following methods all return a boolean value and are to be overridden in
the appropriate subclass.
.IP "\(bu" 4
\&\f(CW\*(C`is_plan\*(C'\fR
.Sp
Indicates whether or not this is the test plan line.
.Sp
.Vb 1
\& 1..3
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_pragma\*(C'\fR
.Sp
Indicates whether or not this is a pragma line.
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_test\*(C'\fR
.Sp
Indicates whether or not this is a test line.
.Sp
.Vb 1
\& ok 1 Is OK!
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_comment\*(C'\fR
.Sp
Indicates whether or not this is a comment.
.Sp
.Vb 1
\& # this is a comment
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_bailout\*(C'\fR
.Sp
Indicates whether or not this is bailout line.
.Sp
.Vb 1
\& Bail out! We\*(Aqre out of dilithium crystals.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_version\*(C'\fR
.Sp
Indicates whether or not this is a \s-1TAP\s0 version line.
.Sp
.Vb 1
\& TAP version 4
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_unknown\*(C'\fR
.Sp
Indicates whether or not the current line could be parsed.
.Sp
.Vb 1
\& ... this line is junk ...
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_yaml\*(C'\fR
.Sp
Indicates whether or not this is a \s-1YAML\s0 chunk.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 1
\&  print $result\->raw;
.Ve
.PP
Returns the original line of text which was parsed.
.PP
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
.Vb 1
\&  my $type = $result\->type;
.Ve
.PP
Returns the \*(L"type\*(R" of a token, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`has_directive\*(C'\fI\fR
.IX Subsection "has_directive"
.PP
.Vb 3
\&  if ( $result\->has_directive ) {
\&     ...
\&  }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 or \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 3
\& if ( $result\->has_todo ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 directive.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 3
\& if ( $result\->has_skip ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`set_directive\*(C'\fI\fR
.IX Subsection "set_directive"
.PP
Set the directive associated with this token. Used internally to fake
\&\s-1TODO\s0 tests.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.PP
Remember: if you want your subclass to be automatically used by the parser,
you'll have to register it with \*(L"register_type\*(R" in TAP::Parser::ResultFactory.
.PP
If you're creating a completely new result \fItype\fR, you'll probably need to
subclass TAP::Parser::Grammar too, or else it'll never get used.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResult;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  sub as_string { \*(AqMy results all look the same\*(Aq }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::ResultFactory,
TAP::Parser::Result::Bailout,
TAP::Parser::Result::Comment,
TAP::Parser::Result::Plan,
TAP::Parser::Result::Pragma,
TAP::Parser::Result::Test,
TAP::Parser::Result::Unknown,
TAP::Parser::Result::Version,
TAP::Parser::Result::YAML,
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result5.18.3pm                  0100644 0001750 0001750 00000022200 12566207463 025164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result 3pm"
.TH TAP::Parser::Result 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result \- Base class for TAP::Parser output objects
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- not meant to be used directly
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # directly:
\&  use TAP::Parser::Result;
\&  my $token  = {...};
\&  my $result = TAP::Parser::Result\->new( $token );
.Ve
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple base class used by TAP::Parser to store objects that
represent the current bit of test output data from \s-1TAP \s0(usually a single
line).  Unless you're subclassing, you probably won't need to use this module
directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  # see TAP::Parser::ResultFactory for preferred usage
\&
\&  # to use directly:
\&  my $result = TAP::Parser::Result\->new($token);
.Ve
.PP
Returns an instance the appropriate class for the test token passed in.
.SS "Boolean methods"
.IX Subsection "Boolean methods"
The following methods all return a boolean value and are to be overridden in
the appropriate subclass.
.IP "\(bu" 4
\&\f(CW\*(C`is_plan\*(C'\fR
.Sp
Indicates whether or not this is the test plan line.
.Sp
.Vb 1
\& 1..3
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_pragma\*(C'\fR
.Sp
Indicates whether or not this is a pragma line.
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_test\*(C'\fR
.Sp
Indicates whether or not this is a test line.
.Sp
.Vb 1
\& ok 1 Is OK!
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_comment\*(C'\fR
.Sp
Indicates whether or not this is a comment.
.Sp
.Vb 1
\& # this is a comment
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_bailout\*(C'\fR
.Sp
Indicates whether or not this is bailout line.
.Sp
.Vb 1
\& Bail out! We\*(Aqre out of dilithium crystals.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_version\*(C'\fR
.Sp
Indicates whether or not this is a \s-1TAP\s0 version line.
.Sp
.Vb 1
\& TAP version 4
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_unknown\*(C'\fR
.Sp
Indicates whether or not the current line could be parsed.
.Sp
.Vb 1
\& ... this line is junk ...
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`is_yaml\*(C'\fR
.Sp
Indicates whether or not this is a \s-1YAML\s0 chunk.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 1
\&  print $result\->raw;
.Ve
.PP
Returns the original line of text which was parsed.
.PP
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
.Vb 1
\&  my $type = $result\->type;
.Ve
.PP
Returns the \*(L"type\*(R" of a token, such as \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
Prints a string representation of the token.  This might not be the exact
output, however.  Tests will have test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives will be capitalized and, in general, things will be cleaned
up.  If you need the original text for the token, see the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed.  Anything which is \fBnot\fR a
test result returns true.  This is merely provided as a convenient shortcut.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`has_directive\*(C'\fI\fR
.IX Subsection "has_directive"
.PP
.Vb 3
\&  if ( $result\->has_directive ) {
\&     ...
\&  }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 or \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 3
\& if ( $result\->has_todo ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1TODO\s0 directive.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 3
\& if ( $result\->has_skip ) {
\&     ...
\& }
.Ve
.PP
Indicates whether or not the given result has a \s-1SKIP\s0 directive.
.PP
\fI\f(CI\*(C`set_directive\*(C'\fI\fR
.IX Subsection "set_directive"
.PP
Set the directive associated with this token. Used internally to fake
\&\s-1TODO\s0 tests.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
Remember: if you want your subclass to be automatically used by the parser,
you'll have to register it with \*(L"register_type\*(R" in TAP::Parser::ResultFactory.
.PP
If you're creating a completely new result \fItype\fR, you'll probably need to
subclass TAP::Parser::Grammar too, or else it'll never get used.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResult;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  sub as_string { \*(AqMy results all look the same\*(Aq }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::ResultFactory,
TAP::Parser::Result::Bailout,
TAP::Parser::Result::Comment,
TAP::Parser::Result::Plan,
TAP::Parser::Result::Pragma,
TAP::Parser::Result::Test,
TAP::Parser::Result::Unknown,
TAP::Parser::Result::Version,
TAP::Parser::Result::YAML,
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Bailout.3pm             0100644 0001750 0001750 00000011752 12566207463 026366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Bailout 3pm"
.TH TAP::Parser::Result::Bailout 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Bailout \- Bailout result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a bail out line is encountered.
.PP
.Vb 3
\& 1..5
\& ok 1 \- woo hooo!
\& Bail out! Well, so much for "woo hooo!"
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      my $explanation = $result\->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
.PP
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Bailout5.16.3pm         0100644 0001750 0001750 00000011431 12566207441 026666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Bailout 3pm"
.TH TAP::Parser::Result::Bailout 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Bailout \- Bailout result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a bail out line is encountered.
.PP
.Vb 3
\& 1..5
\& ok 1 \- woo hooo!
\& Bail out! Well, so much for "woo hooo!"
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      my $explanation = $result\->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
.PP
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Bailout5.18.3pm         0100644 0001750 0001750 00000011752 12566207463 026702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Bailout 3pm"
.TH TAP::Parser::Result::Bailout 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Bailout \- Bailout result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a bail out line is encountered.
.PP
.Vb 3
\& 1..5
\& ok 1 \- woo hooo!
\& Bail out! Well, so much for "woo hooo!"
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      my $explanation = $result\->explanation;
\&      print "We bailed out because ($explanation)";
\&  }
.Ve
.PP
If, and only if, a token is a bailout token, you can get an \*(L"explanation\*(R" via
this method.  The explanation is the text after the mystical \*(L"Bail out!\*(R" words
which appear in the tap output.
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Comment.3pm             0100644 0001750 0001750 00000011473 12566207463 026371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Comment 3pm"
.TH TAP::Parser::Result::Comment 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Comment \- Comment result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a comment line is encountered.
.PP
.Vb 3
\& 1..1
\& ok 1 \- woo hooo!
\& # this is a comment
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.Sp
Note that this method merely returns the comment preceded by a '# '.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      my $comment = $result\->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Comment5.16.3pm         0100644 0001750 0001750 00000011152 12566207441 026671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Comment 3pm"
.TH TAP::Parser::Result::Comment 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Comment \- Comment result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a comment line is encountered.
.PP
.Vb 3
\& 1..1
\& ok 1 \- woo hooo!
\& # this is a comment
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.Sp
Note that this method merely returns the comment preceded by a '# '.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      my $comment = $result\->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Comment5.18.3pm         0100644 0001750 0001750 00000011473 12566207463 026705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Comment 3pm"
.TH TAP::Parser::Result::Comment 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Comment \- Comment result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a comment line is encountered.
.PP
.Vb 3
\& 1..1
\& ok 1 \- woo hooo!
\& # this is a comment
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.Sp
Note that this method merely returns the comment preceded by a '# '.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      my $comment = $result\->comment;
\&      print "I have something to say:  $comment";
\&  }
.Ve
                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Plan.3pm                0100644 0001750 0001750 00000013532 12566207463 025657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Plan 3pm"
.TH TAP::Parser::Result::Plan 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Plan \- Plan result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a plan line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  my $planned = $result\->tests_planned;
.Ve
.PP
Returns the number of tests planned.  For example, a plan of \f(CW1..17\fR will
cause this method to return '17'.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $plan\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $plan\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.PP
\fI\f(CI\*(C`todo_list\*(C'\fI\fR
.IX Subsection "todo_list"
.PP
.Vb 4
\&  my $todo = $result\->todo_list;
\&  for ( @$todo ) {
\&      ...
\&  }
.Ve
                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Plan5.16.3pm            0100644 0001750 0001750 00000013211 12566207441 026157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Plan 3pm"
.TH TAP::Parser::Result::Plan 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Plan \- Plan result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a plan line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  my $planned = $result\->tests_planned;
.Ve
.PP
Returns the number of tests planned.  For example, a plan of \f(CW1..17\fR will
cause this method to return '17'.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $plan\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $plan\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.PP
\fI\f(CI\*(C`todo_list\*(C'\fI\fR
.IX Subsection "todo_list"
.PP
.Vb 4
\&  my $todo = $result\->todo_list;
\&  for ( @$todo ) {
\&      ...
\&  }
.Ve
                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Plan5.18.3pm            0100644 0001750 0001750 00000013532 12566207463 026173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Plan 3pm"
.TH TAP::Parser::Result::Plan 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Plan \- Plan result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a plan line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  my $planned = $result\->tests_planned;
.Ve
.PP
Returns the number of tests planned.  For example, a plan of \f(CW1..17\fR will
cause this method to return '17'.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& my $directive = $plan\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directive is included with the plan, this method will return it.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& my $explanation = $plan\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directive was included with the plan, this method will return the
explanation, if any.
.PP
\fI\f(CI\*(C`todo_list\*(C'\fI\fR
.IX Subsection "todo_list"
.PP
.Vb 4
\&  my $todo = $result\->todo_list;
\&  for ( @$todo ) {
\&      ...
\&  }
.Ve
                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Pragma.3pm              0100644 0001750 0001750 00000011416 12566207463 026173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Pragma 3pm"
.TH TAP::Parser::Result::Pragma 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Pragma \- TAP pragma token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a pragma is encountered.
.PP
.Vb 2
\& TAP version 13
\& pragma +strict, \-foo
.Ve
.PP
Pragmas are only supported from \s-1TAP\s0 version 13 onwards.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
if ( \f(CW$result\fR\->is_pragma ) {
    \f(CW@pragmas\fR = \f(CW$result\fR\->pragmas;
}
                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Pragma5.16.3pm          0100644 0001750 0001750 00000011075 12566207441 026502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Pragma 3pm"
.TH TAP::Parser::Result::Pragma 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Pragma \- TAP pragma token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a pragma is encountered.
.PP
.Vb 2
\& TAP version 13
\& pragma +strict, \-foo
.Ve
.PP
Pragmas are only supported from \s-1TAP\s0 version 13 onwards.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
if ( \f(CW$result\fR\->is_pragma ) {
    \f(CW@pragmas\fR = \f(CW$result\fR\->pragmas;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Pragma5.18.3pm          0100644 0001750 0001750 00000011416 12566207463 026507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Pragma 3pm"
.TH TAP::Parser::Result::Pragma 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Pragma \- TAP pragma token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a pragma is encountered.
.PP
.Vb 2
\& TAP version 13
\& pragma +strict, \-foo
.Ve
.PP
Pragmas are only supported from \s-1TAP\s0 version 13 onwards.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
if ( \f(CW$result\fR\->is_pragma ) {
    \f(CW@pragmas\fR = \f(CW$result\fR\->pragmas;
}
                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Test.3pm                0100644 0001750 0001750 00000021327 12566207463 025705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Test 3pm"
.TH TAP::Parser::Result::Test 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Test \- Test result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a test line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
This class is the workhorse of the TAP::Parser system.  Most \s-1TAP\s0 lines will
be test lines and if \f(CW\*(C`$result\->is_test\*(C'\fR, then you have a bunch of methods
at your disposal.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result\->ok;
.Ve
.PP
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result\->number;
.Ve
.PP
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result\->description;
.Ve
.PP
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For the above line, the explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
If the test is unplanned, this method will always return false.  See
\&\f(CW\*(C`is_unplanned\*(C'\fR.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_actual_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 3
\&  if ( $test\->todo_passed ) {
\&     # test unexpectedly succeeded
\&  }
.Ve
.PP
If this is a \s-1TODO\s0 test and an 'ok' line, this method returns true.
Otherwise, it will always return false (regardless of passing status on
non-todo tests).
.PP
This is used to track which tests unexpectedly succeeded.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1TODO\s0
directive.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
This method prints the test as a string.  It will probably be similar, but
not necessarily identical, to the original test line.  Directives are
capitalized, some whitespace may be trimmed and a test number will be added if
it was not present in the original line.  If you need the original text of the
test line, use the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 2
\&  if ( $test\->is_unplanned ) { ... }
\&  $test\->is_unplanned(1);
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR.
.PP
Note that if tests have a trailing plan, it is not possible to set this
property for unplanned tests as we do not know it's unplanned until the plan
is reached:
.PP
.Vb 5
\&  print <<\*(AqEND\*(Aq;
\&  ok 1
\&  ok 2
\&  1..1
\&  END
.Ve
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Test5.16.3pm            0100644 0001750 0001750 00000021006 12566207441 026205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Test 3pm"
.TH TAP::Parser::Result::Test 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Test \- Test result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a test line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
This class is the workhorse of the TAP::Parser system.  Most \s-1TAP\s0 lines will
be test lines and if \f(CW\*(C`$result\->is_test\*(C'\fR, then you have a bunch of methods
at your disposal.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result\->ok;
.Ve
.PP
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result\->number;
.Ve
.PP
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result\->description;
.Ve
.PP
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For the above line, the explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
If the test is unplanned, this method will always return false.  See
\&\f(CW\*(C`is_unplanned\*(C'\fR.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_actual_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 3
\&  if ( $test\->todo_passed ) {
\&     # test unexpectedly succeeded
\&  }
.Ve
.PP
If this is a \s-1TODO\s0 test and an 'ok' line, this method returns true.
Otherwise, it will always return false (regardless of passing status on
non-todo tests).
.PP
This is used to track which tests unexpectedly succeeded.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1TODO\s0
directive.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
This method prints the test as a string.  It will probably be similar, but
not necessarily identical, to the original test line.  Directives are
capitalized, some whitespace may be trimmed and a test number will be added if
it was not present in the original line.  If you need the original text of the
test line, use the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 2
\&  if ( $test\->is_unplanned ) { ... }
\&  $test\->is_unplanned(1);
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR.
.PP
Note that if tests have a trailing plan, it is not possible to set this
property for unplanned tests as we do not know it's unplanned until the plan
is reached:
.PP
.Vb 5
\&  print <<\*(AqEND\*(Aq;
\&  ok 1
\&  ok 2
\&  1..1
\&  END
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Test5.18.3pm            0100644 0001750 0001750 00000021327 12566207463 026221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Test 3pm"
.TH TAP::Parser::Result::Test 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Test \- Test result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a test line is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
This class is the workhorse of the TAP::Parser system.  Most \s-1TAP\s0 lines will
be test lines and if \f(CW\*(C`$result\->is_test\*(C'\fR, then you have a bunch of methods
at your disposal.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  my $ok = $result\->ok;
.Ve
.PP
Returns the literal text of the \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  my $test_number = $result\->number;
.Ve
.PP
Returns the number of the test, even if the original \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  my $description = $result\->description;
.Ve
.PP
Returns the description of the test, if any.  This is the portion after the
test number but before the directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  my $directive = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directive was present for a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  my $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, this method will return
the accompanying explanation, if present.
.PP
.Vb 1
\&  not ok 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For the above line, the explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed.  Remember
that for \s-1TODO\s0 tests, the test always passes.
.PP
If the test is unplanned, this method will always return false.  See
\&\f(CW\*(C`is_unplanned\*(C'\fR.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not the test passed, regardless
of its \s-1TODO\s0 status.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
Deprecated.  Please use \f(CW\*(C`is_actual_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 3
\&  if ( $test\->todo_passed ) {
\&     # test unexpectedly succeeded
\&  }
.Ve
.PP
If this is a \s-1TODO\s0 test and an 'ok' line, this method returns true.
Otherwise, it will always return false (regardless of passing status on
non-todo tests).
.PP
This is used to track which tests unexpectedly succeeded.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a boolean value indicating whether or not this test has a \s-1TODO\s0
directive.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
This method prints the test as a string.  It will probably be similar, but
not necessarily identical, to the original test line.  Directives are
capitalized, some whitespace may be trimmed and a test number will be added if
it was not present in the original line.  If you need the original text of the
test line, use the \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 2
\&  if ( $test\->is_unplanned ) { ... }
\&  $test\->is_unplanned(1);
.Ve
.PP
If a test number is greater than the number of planned tests, this method will
return true.  Unplanned tests will \fIalways\fR return false for \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not the test \f(CW\*(C`has_todo\*(C'\fR.
.PP
Note that if tests have a trailing plan, it is not possible to set this
property for unplanned tests as we do not know it's unplanned until the plan
is reached:
.PP
.Vb 5
\&  print <<\*(AqEND\*(Aq;
\&  ok 1
\&  ok 2
\&  1..1
\&  END
.Ve
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Unknown.3pm             0100644 0001750 0001750 00000011252 12566207463 026421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Unknown 3pm"
.TH TAP::Parser::Result::Unknown 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Unknown \- Unknown result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if the parser does not recognize the token line.  For example:
.PP
.Vb 4
\& 1..5
\& VERSION 7
\& ok 1 \- woo hooo!
\& ... woo hooo! is cool!
.Ve
.PP
In the above \*(L"\s-1TAP\*(R",\s0 the second and fourth lines will generate \*(L"Unknown\*(R"
tokens.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Unknown5.16.3pm         0100644 0001750 0001750 00000010731 12566207441 026730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Unknown 3pm"
.TH TAP::Parser::Result::Unknown 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Unknown \- Unknown result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if the parser does not recognize the token line.  For example:
.PP
.Vb 4
\& 1..5
\& VERSION 7
\& ok 1 \- woo hooo!
\& ... woo hooo! is cool!
.Ve
.PP
In the above \*(L"\s-1TAP\s0\*(R", the second and fourth lines will generate \*(L"Unknown\*(R"
tokens.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Unknown5.18.3pm         0100644 0001750 0001750 00000011252 12566207463 026735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Unknown 3pm"
.TH TAP::Parser::Result::Unknown 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Unknown \- Unknown result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if the parser does not recognize the token line.  For example:
.PP
.Vb 4
\& 1..5
\& VERSION 7
\& ok 1 \- woo hooo!
\& ... woo hooo! is cool!
.Ve
.PP
In the above \*(L"\s-1TAP\*(R",\s0 the second and fourth lines will generate \*(L"Unknown\*(R"
tokens.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Version.3pm             0100644 0001750 0001750 00000011537 12566207463 026415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Version 3pm"
.TH TAP::Parser::Result::Version 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Version \- TAP syntax version token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a version line is encountered.
.PP
.Vb 3
\& TAP version 13
\& ok 1
\& not ok 2
.Ve
.PP
The first version of \s-1TAP\s0 to include an explicit version number is 13.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 3
\&  if ( $result\->is_version ) {
\&     print $result\->version;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Version5.16.3pm         0100644 0001750 0001750 00000011216 12566207441 026715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Version 3pm"
.TH TAP::Parser::Result::Version 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Version \- TAP syntax version token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a version line is encountered.
.PP
.Vb 3
\& TAP version 13
\& ok 1
\& not ok 2
.Ve
.PP
The first version of \s-1TAP\s0 to include an explicit version number is 13.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 3
\&  if ( $result\->is_version ) {
\&     print $result\->version;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::Version5.18.3pm         0100644 0001750 0001750 00000011537 12566207463 026731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Version 3pm"
.TH TAP::Parser::Result::Version 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Version \- TAP syntax version token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a version line is encountered.
.PP
.Vb 3
\& TAP version 13
\& ok 1
\& not ok 2
.Ve
.PP
The first version of \s-1TAP\s0 to include an explicit version number is 13.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 3
\&  if ( $result\->is_version ) {
\&     print $result\->version;
\&  }
.Ve
.PP
This is merely a synonym for \f(CW\*(C`as_string\*(C'\fR.
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::YAML.3pm                0100644 0001750 0001750 00000011433 12566207463 025525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::YAML 3pm"
.TH TAP::Parser::Result::YAML 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::YAML \- YAML result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a \s-1YAML\s0 block is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`data\*(C'\fI\fR
.IX Subsection "data"
.PP
.Vb 3
\&  if ( $result\->is_yaml ) {
\&     print $result\->data;
\&  }
.Ve
.PP
Return the parsed \s-1YAML\s0 data for this result
                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::YAML5.16.3pm            0100644 0001750 0001750 00000011112 12566207441 026025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::YAML 3pm"
.TH TAP::Parser::Result::YAML 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::YAML \- YAML result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a \s-1YAML\s0 block is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`data\*(C'\fI\fR
.IX Subsection "data"
.PP
.Vb 3
\&  if ( $result\->is_yaml ) {
\&     print $result\->data;
\&  }
.Ve
.PP
Return the parsed \s-1YAML\s0 data for this result
                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Result::YAML5.18.3pm            0100644 0001750 0001750 00000011433 12566207463 026041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::YAML 3pm"
.TH TAP::Parser::Result::YAML 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::YAML \- YAML result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of TAP::Parser::Result.  A token of this class will be
returned if a \s-1YAML\s0 block is encountered.
.PP
.Vb 2
\& 1..1
\& ok 1 \- woo hooo!
.Ve
.PP
\&\f(CW1..1\fR is the plan.  Gotta have a plan.
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
Mainly listed here to shut up the pitiful screams of the pod coverage tests.
They keep me awake at night.
.IP "\(bu" 4
\&\f(CW\*(C`as_string\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`raw\*(C'\fR
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`data\*(C'\fI\fR
.IX Subsection "data"
.PP
.Vb 3
\&  if ( $result\->is_yaml ) {
\&     print $result\->data;
\&  }
.Ve
.PP
Return the parsed \s-1YAML\s0 data for this result
                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::ResultFactory.3pm               0100644 0001750 0001750 00000016360 12566207463 026212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::ResultFactory 3pm"
.TH TAP::Parser::ResultFactory 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::ResultFactory \- Factory for creating TAP::Parser output objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::ResultFactory;
\&  my $token   = {...};
\&  my $factory = TAP::Parser::ResultFactory\->new;
\&  my $result  = $factory\->make_result( $token );
.Ve
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple factory class which returns a TAP::Parser::Result subclass
representing the current bit of test data from \s-1TAP \s0(usually a single line).
It is used primarily by TAP::Parser::Grammar.  Unless you're subclassing,
you probably won't need to use this module directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class.
\&\fINote:\fR You currently don't need to instantiate a factory in order to use it.
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Returns an instance the appropriate class for the test token passed in.
.PP
.Vb 1
\&  my $result = TAP::Parser::ResultFactory\->make_result($token);
.Ve
.PP
Can also be called as an instance method.
.PP
\fI\f(CI\*(C`class_for\*(C'\fI\fR
.IX Subsection "class_for"
.PP
Takes one argument: \f(CW$type\fR.  Returns the class for this \f(CW$type\fR, or \f(CW\*(C`croak\*(C'\fRs
with an error.
.PP
\fI\f(CI\*(C`register_type\*(C'\fI\fR
.IX Subsection "register_type"
.PP
Takes two arguments: \f(CW$type\fR, \f(CW$class\fR
.PP
This lets you override an existing type with your own custom type, or register
a completely new type, eg:
.PP
.Vb 5
\&  # create a custom result type:
\&  package MyResult;
\&  use strict;
\&  use vars qw(@ISA);
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  # use it:
\&  my $r = TAP::Parser::ResultFactory\->( { type => \*(Aqmy_type\*(Aq } );
.Ve
.PP
Your custom type should then be picked up automatically by the TAP::Parser.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
There are a few things to bear in mind when creating your own
\&\f(CW\*(C`ResultFactory\*(C'\fR:
.IP "1." 4
The factory itself is never instantiated (this \fImay\fR change in the future).
This means that \f(CW\*(C`_initialize\*(C'\fR is never called.
.IP "2." 4
\&\f(CW\*(C`TAP::Parser::Result\->new\*(C'\fR is never called, \f(CW$tokens\fR are reblessed.
This \fIwill\fR change in a future version!
.IP "3." 4
TAP::Parser::Result subclasses will register themselves with
TAP::Parser::ResultFactory directly:
.Sp
.Vb 2
\&  package MyFooResult;
\&  TAP::Parser::ResultFactory\->register_type( foo => _\|_PACKAGE_\|_ );
.Ve
.Sp
Of course, it's up to you to decide whether or not to ignore them.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResultFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use MyResult;
\&  use TAP::Parser::ResultFactory;
\&
\&  @ISA = qw( TAP::Parser::ResultFactory );
\&
\&  # force all results to be \*(AqMyResult\*(Aq
\&  sub class_for {
\&    return \*(AqMyResult\*(Aq;
\&  }
\&
\&  1;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Parser,
TAP::Parser::Result,
TAP::Parser::Grammar
                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::ResultFactory5.16.3pm           0100644 0001750 0001750 00000016037 12566207441 026521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::ResultFactory 3pm"
.TH TAP::Parser::ResultFactory 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::ResultFactory \- Factory for creating TAP::Parser output objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::ResultFactory;
\&  my $token   = {...};
\&  my $factory = TAP::Parser::ResultFactory\->new;
\&  my $result  = $factory\->make_result( $token );
.Ve
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple factory class which returns a TAP::Parser::Result subclass
representing the current bit of test data from \s-1TAP\s0 (usually a single line).
It is used primarily by TAP::Parser::Grammar.  Unless you're subclassing,
you probably won't need to use this module directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class.
\&\fINote:\fR You currently don't need to instantiate a factory in order to use it.
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Returns an instance the appropriate class for the test token passed in.
.PP
.Vb 1
\&  my $result = TAP::Parser::ResultFactory\->make_result($token);
.Ve
.PP
Can also be called as an instance method.
.PP
\fI\f(CI\*(C`class_for\*(C'\fI\fR
.IX Subsection "class_for"
.PP
Takes one argument: \f(CW$type\fR.  Returns the class for this \f(CW$type\fR, or \f(CW\*(C`croak\*(C'\fRs
with an error.
.PP
\fI\f(CI\*(C`register_type\*(C'\fI\fR
.IX Subsection "register_type"
.PP
Takes two arguments: \f(CW$type\fR, \f(CW$class\fR
.PP
This lets you override an existing type with your own custom type, or register
a completely new type, eg:
.PP
.Vb 5
\&  # create a custom result type:
\&  package MyResult;
\&  use strict;
\&  use vars qw(@ISA);
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  # use it:
\&  my $r = TAP::Parser::ResultFactory\->( { type => \*(Aqmy_type\*(Aq } );
.Ve
.PP
Your custom type should then be picked up automatically by the TAP::Parser.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.PP
There are a few things to bear in mind when creating your own
\&\f(CW\*(C`ResultFactory\*(C'\fR:
.IP "1." 4
The factory itself is never instantiated (this \fImay\fR change in the future).
This means that \f(CW\*(C`_initialize\*(C'\fR is never called.
.IP "2." 4
\&\f(CW\*(C`TAP::Parser::Result\->new\*(C'\fR is never called, \f(CW$tokens\fR are reblessed.
This \fIwill\fR change in a future version!
.IP "3." 4
TAP::Parser::Result subclasses will register themselves with
TAP::Parser::ResultFactory directly:
.Sp
.Vb 2
\&  package MyFooResult;
\&  TAP::Parser::ResultFactory\->register_type( foo => _\|_PACKAGE_\|_ );
.Ve
.Sp
Of course, it's up to you to decide whether or not to ignore them.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResultFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use MyResult;
\&  use TAP::Parser::ResultFactory;
\&
\&  @ISA = qw( TAP::Parser::ResultFactory );
\&
\&  # force all results to be \*(AqMyResult\*(Aq
\&  sub class_for {
\&    return \*(AqMyResult\*(Aq;
\&  }
\&
\&  1;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Parser,
TAP::Parser::Result,
TAP::Parser::Grammar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::ResultFactory5.18.3pm           0100644 0001750 0001750 00000016360 12566207463 026526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::ResultFactory 3pm"
.TH TAP::Parser::ResultFactory 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::ResultFactory \- Factory for creating TAP::Parser output objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use TAP::Parser::ResultFactory;
\&  my $token   = {...};
\&  my $factory = TAP::Parser::ResultFactory\->new;
\&  my $result  = $factory\->make_result( $token );
.Ve
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
This is a simple factory class which returns a TAP::Parser::Result subclass
representing the current bit of test data from \s-1TAP \s0(usually a single line).
It is used primarily by TAP::Parser::Grammar.  Unless you're subclassing,
you probably won't need to use this module directly.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Creates a new factory class.
\&\fINote:\fR You currently don't need to instantiate a factory in order to use it.
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Returns an instance the appropriate class for the test token passed in.
.PP
.Vb 1
\&  my $result = TAP::Parser::ResultFactory\->make_result($token);
.Ve
.PP
Can also be called as an instance method.
.PP
\fI\f(CI\*(C`class_for\*(C'\fI\fR
.IX Subsection "class_for"
.PP
Takes one argument: \f(CW$type\fR.  Returns the class for this \f(CW$type\fR, or \f(CW\*(C`croak\*(C'\fRs
with an error.
.PP
\fI\f(CI\*(C`register_type\*(C'\fI\fR
.IX Subsection "register_type"
.PP
Takes two arguments: \f(CW$type\fR, \f(CW$class\fR
.PP
This lets you override an existing type with your own custom type, or register
a completely new type, eg:
.PP
.Vb 5
\&  # create a custom result type:
\&  package MyResult;
\&  use strict;
\&  use vars qw(@ISA);
\&  @ISA = \*(AqTAP::Parser::Result\*(Aq;
\&
\&  # register with the factory:
\&  TAP::Parser::ResultFactory\->register_type( \*(Aqmy_type\*(Aq => _\|_PACKAGE_\|_ );
\&
\&  # use it:
\&  my $r = TAP::Parser::ResultFactory\->( { type => \*(Aqmy_type\*(Aq } );
.Ve
.PP
Your custom type should then be picked up automatically by the TAP::Parser.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.PP
There are a few things to bear in mind when creating your own
\&\f(CW\*(C`ResultFactory\*(C'\fR:
.IP "1." 4
The factory itself is never instantiated (this \fImay\fR change in the future).
This means that \f(CW\*(C`_initialize\*(C'\fR is never called.
.IP "2." 4
\&\f(CW\*(C`TAP::Parser::Result\->new\*(C'\fR is never called, \f(CW$tokens\fR are reblessed.
This \fIwill\fR change in a future version!
.IP "3." 4
TAP::Parser::Result subclasses will register themselves with
TAP::Parser::ResultFactory directly:
.Sp
.Vb 2
\&  package MyFooResult;
\&  TAP::Parser::ResultFactory\->register_type( foo => _\|_PACKAGE_\|_ );
.Ve
.Sp
Of course, it's up to you to decide whether or not to ignore them.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyResultFactory;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use MyResult;
\&  use TAP::Parser::ResultFactory;
\&
\&  @ISA = qw( TAP::Parser::ResultFactory );
\&
\&  # force all results to be \*(AqMyResult\*(Aq
\&  sub class_for {
\&    return \*(AqMyResult\*(Aq;
\&  }
\&
\&  1;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Parser,
TAP::Parser::Result,
TAP::Parser::Grammar
                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler.3pm                   0100644 0001750 0001750 00000011706 12566207463 025321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler 3pm"
.TH TAP::Parser::Scheduler 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler \- Schedule tests during parallel testing
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $sched = TAP::Parser::Scheduler\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR object.
.PP
\fI\f(CI\*(C`get_all\*(C'\fI\fR
.IX Subsection "get_all"
.PP
Get a list of all remaining tests.
.PP
\fI\f(CI\*(C`get_job\*(C'\fI\fR
.IX Subsection "get_job"
.PP
Return the next available job or \f(CW\*(C`undef\*(C'\fR if none are available. Returns
a \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR if the scheduler still has pending
jobs but none are available to run right now.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Return a human readable representation of the scheduling tree.
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler5.16.3pm               0100644 0001750 0001750 00000011365 12566207441 025630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler 3pm"
.TH TAP::Parser::Scheduler 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler \- Schedule tests during parallel testing
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $sched = TAP::Parser::Scheduler\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR object.
.PP
\fI\f(CI\*(C`get_all\*(C'\fI\fR
.IX Subsection "get_all"
.PP
Get a list of all remaining tests.
.PP
\fI\f(CI\*(C`get_job\*(C'\fI\fR
.IX Subsection "get_job"
.PP
Return the next available job or \f(CW\*(C`undef\*(C'\fR if none are available. Returns
a \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR if the scheduler still has pending
jobs but none are available to run right now.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Return a human readable representation of the scheduling tree.
                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler5.18.3pm               0100644 0001750 0001750 00000011706 12566207463 025635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler 3pm"
.TH TAP::Parser::Scheduler 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler \- Schedule tests during parallel testing
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $sched = TAP::Parser::Scheduler\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR object.
.PP
\fI\f(CI\*(C`get_all\*(C'\fI\fR
.IX Subsection "get_all"
.PP
Get a list of all remaining tests.
.PP
\fI\f(CI\*(C`get_job\*(C'\fI\fR
.IX Subsection "get_job"
.PP
Return the next available job or \f(CW\*(C`undef\*(C'\fR if none are available. Returns
a \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR if the scheduler still has pending
jobs but none are available to run right now.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Return a human readable representation of the scheduling tree.
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Job.3pm              0100644 0001750 0001750 00000012466 12566207463 026144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Job 3pm"
.TH TAP::Parser::Scheduler::Job 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Job \- A single testing job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Job;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents a single test 'job'.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 3
\&    my $job = TAP::Parser::Scheduler::Job\->new(
\&        $name, $desc 
\&    );
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Job\*(C'\fR object.
.PP
\fI\f(CI\*(C`on_finish\*(C'\fI\fR
.IX Subsection "on_finish"
.PP
Register a closure to be called when this job is destroyed.
.PP
\fI\f(CI\*(C`finish\*(C'\fI\fR
.IX Subsection "finish"
.PP
Called when a job is complete to unlock it.
.PP
\fI\f(CI\*(C`filename\*(C'\fI\fR
.IX Subsection "filename"
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
\fI\f(CI\*(C`context\*(C'\fI\fR
.IX Subsection "context"
.PP
\fI\f(CI\*(C`as_array_ref\*(C'\fI\fR
.IX Subsection "as_array_ref"
.PP
For backwards compatibility in callbacks.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns false indicating that this is a real job rather than a
\&'spinner'. Spinners are returned when the scheduler still has pending
jobs but can't (because of locking) return one right now.
                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Job5.16.3pm          0100644 0001750 0001750 00000012145 12566207441 026444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Job 3pm"
.TH TAP::Parser::Scheduler::Job 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Job \- A single testing job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Job;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents a single test 'job'.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 3
\&    my $job = TAP::Parser::Scheduler::Job\->new(
\&        $name, $desc 
\&    );
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Job\*(C'\fR object.
.PP
\fI\f(CI\*(C`on_finish\*(C'\fI\fR
.IX Subsection "on_finish"
.PP
Register a closure to be called when this job is destroyed.
.PP
\fI\f(CI\*(C`finish\*(C'\fI\fR
.IX Subsection "finish"
.PP
Called when a job is complete to unlock it.
.PP
\fI\f(CI\*(C`filename\*(C'\fI\fR
.IX Subsection "filename"
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
\fI\f(CI\*(C`context\*(C'\fI\fR
.IX Subsection "context"
.PP
\fI\f(CI\*(C`as_array_ref\*(C'\fI\fR
.IX Subsection "as_array_ref"
.PP
For backwards compatibility in callbacks.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns false indicating that this is a real job rather than a
\&'spinner'. Spinners are returned when the scheduler still has pending
jobs but can't (because of locking) return one right now.
                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Job5.18.3pm          0100644 0001750 0001750 00000012466 12566207463 026460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Job 3pm"
.TH TAP::Parser::Scheduler::Job 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Job \- A single testing job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Job;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents a single test 'job'.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 3
\&    my $job = TAP::Parser::Scheduler::Job\->new(
\&        $name, $desc 
\&    );
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Job\*(C'\fR object.
.PP
\fI\f(CI\*(C`on_finish\*(C'\fI\fR
.IX Subsection "on_finish"
.PP
Register a closure to be called when this job is destroyed.
.PP
\fI\f(CI\*(C`finish\*(C'\fI\fR
.IX Subsection "finish"
.PP
Called when a job is complete to unlock it.
.PP
\fI\f(CI\*(C`filename\*(C'\fI\fR
.IX Subsection "filename"
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
\fI\f(CI\*(C`context\*(C'\fI\fR
.IX Subsection "context"
.PP
\fI\f(CI\*(C`as_array_ref\*(C'\fI\fR
.IX Subsection "as_array_ref"
.PP
For backwards compatibility in callbacks.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns false indicating that this is a real job rather than a
\&'spinner'. Spinners are returned when the scheduler still has pending
jobs but can't (because of locking) return one right now.
                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Spinner.3pm          0100644 0001750 0001750 00000011567 12566207463 027051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Spinner 3pm"
.TH TAP::Parser::Scheduler::Spinner 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Spinner \- A no\-op job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Spinner;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A no-op job. Returned by \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR as an instruction to
the harness to spin (keep executing tests) while the scheduler can't
return a real job.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $job = TAP::Parser::Scheduler::Spinner\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR object.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns true indicating that is a 'spinner' job. Spinners are returned
when the scheduler still has pending jobs but can't (because of locking)
return one right now.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Spinner5.16.3pm      0100644 0001750 0001750 00000011246 12566207441 027351  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Spinner 3pm"
.TH TAP::Parser::Scheduler::Spinner 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Spinner \- A no\-op job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Spinner;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A no-op job. Returned by \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR as an instruction to
the harness to spin (keep executing tests) while the scheduler can't
return a real job.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $job = TAP::Parser::Scheduler::Spinner\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR object.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns true indicating that is a 'spinner' job. Spinners are returned
when the scheduler still has pending jobs but can't (because of locking)
return one right now.
                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Scheduler::Spinner5.18.3pm      0100644 0001750 0001750 00000011567 12566207463 027365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Scheduler::Spinner 3pm"
.TH TAP::Parser::Scheduler::Spinner 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Scheduler::Spinner \- A no\-op job.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler::Spinner;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A no-op job. Returned by \f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR as an instruction to
the harness to spin (keep executing tests) while the scheduler can't
return a real job.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $job = TAP::Parser::Scheduler::Spinner\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Scheduler::Spinner\*(C'\fR object.
.PP
\fI\f(CI\*(C`is_spinner\*(C'\fI\fR
.IX Subsection "is_spinner"
.PP
Returns true indicating that is a 'spinner' job. Spinners are returned
when the scheduler still has pending jobs but can't (because of locking)
return one right now.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Source.3pm                      0100644 0001750 0001750 00000023367 12566207463 024651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Source 3pm"
.TH TAP::Parser::Source 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Source \- a TAP source & meta data about it
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use TAP::Parser::Source;
\&  my $source = TAP::Parser::Source\->new;
\&  $source\->raw( \e\*(Aqreference to raw TAP source\*(Aq )
\&         \->config( \e%config )
\&         \->merge( $boolean )
\&         \->switches( \e@switches )
\&         \->test_args( \e@args )
\&         \->assemble_meta;
\&
\&  do { ... } if $source\->meta\->{is_file};
\&  # see assemble_meta for a full list of data available
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \s-1TAP \s0\fIsource\fR is something that produces a stream of \s-1TAP\s0 for the parser to
consume, such as an executable file, a text file, an archive, an \s-1IO\s0 handle, a
database, etc.  \f(CW\*(C`TAP::Parser::Source\*(C'\fRs encapsulate these \fIraw\fR sources, and
provide some useful meta data about them.  They are used by
TAP::Parser::SourceHandlers, which do whatever is required to produce &
capture a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $source = TAP::Parser::Source\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Source\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 2
\&  my $raw = $source\->raw;
\&  $source\->raw( $some_value );
.Ve
.PP
Chaining getter/setter for the raw \s-1TAP\s0 source.  This is a reference, as it may
contain large amounts of data (eg: raw \s-1TAP\s0).
.PP
\fI\f(CI\*(C`meta\*(C'\fI\fR
.IX Subsection "meta"
.PP
.Vb 2
\&  my $meta = $source\->meta;
\&  $source\->meta({ %some_value });
.Ve
.PP
Chaining getter/setter for meta data about the source.  This defaults to an
empty hashref.  See \*(L"assemble_meta\*(R" for more info.
.PP
\fI\f(CI\*(C`has_meta\*(C'\fI\fR
.IX Subsection "has_meta"
.PP
True if the source has meta data.
.PP
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\&  my $config = $source\->config;
\&  $source\->config({ %some_value });
.Ve
.PP
Chaining getter/setter for the source's configuration, if any has been provided
by the user.  How it's used is up to you.  This defaults to an empty hashref.
See \*(L"config_for\*(R" for more info.
.PP
\fI\f(CI\*(C`merge\*(C'\fI\fR
.IX Subsection "merge"
.PP
.Vb 2
\&  my $merge = $source\->merge;
\&  $source\->config( $bool );
.Ve
.PP
Chaining getter/setter for the flag that dictates whether \s-1STDOUT\s0 and \s-1STDERR\s0
should be merged (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`switches\*(C'\fI\fR
.IX Subsection "switches"
.PP
.Vb 2
\&  my $switches = $source\->switches;
\&  $source\->config([ @switches ]);
.Ve
.PP
Chaining getter/setter for the list of command-line switches that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`test_args\*(C'\fI\fR
.IX Subsection "test_args"
.PP
.Vb 2
\&  my $test_args = $source\->test_args;
\&  $source\->config([ @test_args ]);
.Ve
.PP
Chaining getter/setter for the list of command-line arguments that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`assemble_meta\*(C'\fI\fR
.IX Subsection "assemble_meta"
.PP
.Vb 1
\&  my $meta = $source\->assemble_meta;
.Ve
.PP
Gathers meta data about the \*(L"raw\*(R" source, stashes it in \*(L"meta\*(R" and returns
it as a hashref.  This is done so that the TAP::Parser::SourceHandlers don't
have to repeat common checks.  Currently this includes:
.PP
.Vb 3
\&    is_scalar => $bool,
\&    is_hash   => $bool,
\&    is_array  => $bool,
\&
\&    # for scalars:
\&    length => $n
\&    has_newlines => $bool
\&
\&    # only done if the scalar looks like a filename
\&    is_file => $bool,
\&    is_dir  => $bool,
\&    is_symlink => $bool,
\&    file => {
\&        # only done if the scalar looks like a filename
\&        basename => $string, # including ext
\&        dir      => $string,
\&        ext      => $string,
\&        lc_ext   => $string,
\&        # system checks
\&        exists  => $bool,
\&        stat    => [ ... ], # perldoc \-f stat
\&        empty   => $bool,
\&        size    => $n,
\&        text    => $bool,
\&        binary  => $bool,
\&        read    => $bool,
\&        write   => $bool,
\&        execute => $bool,
\&        setuid  => $bool,
\&        setgid  => $bool,
\&        sticky  => $bool,
\&        is_file => $bool,
\&        is_dir  => $bool,
\&        is_symlink => $bool,
\&        # only done if the file\*(Aqs a symlink
\&        lstat      => [ ... ], # perldoc \-f lstat
\&        # only done if the file\*(Aqs a readable text file
\&        shebang => $first_line,
\&    }
\&
\&  # for arrays:
\&  size => $n,
.Ve
.PP
\fI\f(CI\*(C`shebang\*(C'\fI\fR
.IX Subsection "shebang"
.PP
Get the shebang line for a script file.
.PP
.Vb 1
\&  my $shebang = TAP::Parser::Source\->shebang( $some_script );
.Ve
.PP
May be called as a class method
.PP
\fI\f(CI\*(C`config_for\*(C'\fI\fR
.IX Subsection "config_for"
.PP
.Vb 1
\&  my $config = $source\->config_for( $class );
.Ve
.PP
Returns \*(L"config\*(R" for the \f(CW$class\fR given.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $source\->config_for( \*(AqPerl\*(Aq );
\&  $source\->config_for( \*(AqTAP::Parser::SourceHandler::Perl\*(Aq );
.Ve
.PP
If a fully qualified \f(CW$class\fR is given, its abbreviated version is checked first.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler
                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Source5.16.3pm                  0100644 0001750 0001750 00000023046 12566207441 025151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Source 3pm"
.TH TAP::Parser::Source 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Source \- a TAP source & meta data about it
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use TAP::Parser::Source;
\&  my $source = TAP::Parser::Source\->new;
\&  $source\->raw( \e\*(Aqreference to raw TAP source\*(Aq )
\&         \->config( \e%config )
\&         \->merge( $boolean )
\&         \->switches( \e@switches )
\&         \->test_args( \e@args )
\&         \->assemble_meta;
\&
\&  do { ... } if $source\->meta\->{is_file};
\&  # see assemble_meta for a full list of data available
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \s-1TAP\s0 \fIsource\fR is something that produces a stream of \s-1TAP\s0 for the parser to
consume, such as an executable file, a text file, an archive, an \s-1IO\s0 handle, a
database, etc.  \f(CW\*(C`TAP::Parser::Source\*(C'\fRs encapsulate these \fIraw\fR sources, and
provide some useful meta data about them.  They are used by
TAP::Parser::SourceHandlers, which do whatever is required to produce &
capture a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $source = TAP::Parser::Source\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Source\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 2
\&  my $raw = $source\->raw;
\&  $source\->raw( $some_value );
.Ve
.PP
Chaining getter/setter for the raw \s-1TAP\s0 source.  This is a reference, as it may
contain large amounts of data (eg: raw \s-1TAP\s0).
.PP
\fI\f(CI\*(C`meta\*(C'\fI\fR
.IX Subsection "meta"
.PP
.Vb 2
\&  my $meta = $source\->meta;
\&  $source\->meta({ %some_value });
.Ve
.PP
Chaining getter/setter for meta data about the source.  This defaults to an
empty hashref.  See \*(L"assemble_meta\*(R" for more info.
.PP
\fI\f(CI\*(C`has_meta\*(C'\fI\fR
.IX Subsection "has_meta"
.PP
True if the source has meta data.
.PP
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\&  my $config = $source\->config;
\&  $source\->config({ %some_value });
.Ve
.PP
Chaining getter/setter for the source's configuration, if any has been provided
by the user.  How it's used is up to you.  This defaults to an empty hashref.
See \*(L"config_for\*(R" for more info.
.PP
\fI\f(CI\*(C`merge\*(C'\fI\fR
.IX Subsection "merge"
.PP
.Vb 2
\&  my $merge = $source\->merge;
\&  $source\->config( $bool );
.Ve
.PP
Chaining getter/setter for the flag that dictates whether \s-1STDOUT\s0 and \s-1STDERR\s0
should be merged (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`switches\*(C'\fI\fR
.IX Subsection "switches"
.PP
.Vb 2
\&  my $switches = $source\->switches;
\&  $source\->config([ @switches ]);
.Ve
.PP
Chaining getter/setter for the list of command-line switches that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`test_args\*(C'\fI\fR
.IX Subsection "test_args"
.PP
.Vb 2
\&  my $test_args = $source\->test_args;
\&  $source\->config([ @test_args ]);
.Ve
.PP
Chaining getter/setter for the list of command-line arguments that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`assemble_meta\*(C'\fI\fR
.IX Subsection "assemble_meta"
.PP
.Vb 1
\&  my $meta = $source\->assemble_meta;
.Ve
.PP
Gathers meta data about the \*(L"raw\*(R" source, stashes it in \*(L"meta\*(R" and returns
it as a hashref.  This is done so that the TAP::Parser::SourceHandlers don't
have to repeat common checks.  Currently this includes:
.PP
.Vb 3
\&    is_scalar => $bool,
\&    is_hash   => $bool,
\&    is_array  => $bool,
\&
\&    # for scalars:
\&    length => $n
\&    has_newlines => $bool
\&
\&    # only done if the scalar looks like a filename
\&    is_file => $bool,
\&    is_dir  => $bool,
\&    is_symlink => $bool,
\&    file => {
\&        # only done if the scalar looks like a filename
\&        basename => $string, # including ext
\&        dir      => $string,
\&        ext      => $string,
\&        lc_ext   => $string,
\&        # system checks
\&        exists  => $bool,
\&        stat    => [ ... ], # perldoc \-f stat
\&        empty   => $bool,
\&        size    => $n,
\&        text    => $bool,
\&        binary  => $bool,
\&        read    => $bool,
\&        write   => $bool,
\&        execute => $bool,
\&        setuid  => $bool,
\&        setgid  => $bool,
\&        sticky  => $bool,
\&        is_file => $bool,
\&        is_dir  => $bool,
\&        is_symlink => $bool,
\&        # only done if the file\*(Aqs a symlink
\&        lstat      => [ ... ], # perldoc \-f lstat
\&        # only done if the file\*(Aqs a readable text file
\&        shebang => $first_line,
\&    }
\&
\&  # for arrays:
\&  size => $n,
.Ve
.PP
\fI\f(CI\*(C`shebang\*(C'\fI\fR
.IX Subsection "shebang"
.PP
Get the shebang line for a script file.
.PP
.Vb 1
\&  my $shebang = TAP::Parser::Source\->shebang( $some_script );
.Ve
.PP
May be called as a class method
.PP
\fI\f(CI\*(C`config_for\*(C'\fI\fR
.IX Subsection "config_for"
.PP
.Vb 1
\&  my $config = $source\->config_for( $class );
.Ve
.PP
Returns \*(L"config\*(R" for the \f(CW$class\fR given.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $source\->config_for( \*(AqPerl\*(Aq );
\&  $source\->config_for( \*(AqTAP::Parser::SourceHandler::Perl\*(Aq );
.Ve
.PP
If a fully qualified \f(CW$class\fR is given, its abbreviated version is checked first.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Source5.18.3pm                  0100644 0001750 0001750 00000023367 12566207463 025165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Source 3pm"
.TH TAP::Parser::Source 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Source \- a TAP source & meta data about it
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use TAP::Parser::Source;
\&  my $source = TAP::Parser::Source\->new;
\&  $source\->raw( \e\*(Aqreference to raw TAP source\*(Aq )
\&         \->config( \e%config )
\&         \->merge( $boolean )
\&         \->switches( \e@switches )
\&         \->test_args( \e@args )
\&         \->assemble_meta;
\&
\&  do { ... } if $source\->meta\->{is_file};
\&  # see assemble_meta for a full list of data available
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \s-1TAP \s0\fIsource\fR is something that produces a stream of \s-1TAP\s0 for the parser to
consume, such as an executable file, a text file, an archive, an \s-1IO\s0 handle, a
database, etc.  \f(CW\*(C`TAP::Parser::Source\*(C'\fRs encapsulate these \fIraw\fR sources, and
provide some useful meta data about them.  They are used by
TAP::Parser::SourceHandlers, which do whatever is required to produce &
capture a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $source = TAP::Parser::Source\->new;
.Ve
.PP
Returns a new \f(CW\*(C`TAP::Parser::Source\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
.Vb 2
\&  my $raw = $source\->raw;
\&  $source\->raw( $some_value );
.Ve
.PP
Chaining getter/setter for the raw \s-1TAP\s0 source.  This is a reference, as it may
contain large amounts of data (eg: raw \s-1TAP\s0).
.PP
\fI\f(CI\*(C`meta\*(C'\fI\fR
.IX Subsection "meta"
.PP
.Vb 2
\&  my $meta = $source\->meta;
\&  $source\->meta({ %some_value });
.Ve
.PP
Chaining getter/setter for meta data about the source.  This defaults to an
empty hashref.  See \*(L"assemble_meta\*(R" for more info.
.PP
\fI\f(CI\*(C`has_meta\*(C'\fI\fR
.IX Subsection "has_meta"
.PP
True if the source has meta data.
.PP
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 2
\&  my $config = $source\->config;
\&  $source\->config({ %some_value });
.Ve
.PP
Chaining getter/setter for the source's configuration, if any has been provided
by the user.  How it's used is up to you.  This defaults to an empty hashref.
See \*(L"config_for\*(R" for more info.
.PP
\fI\f(CI\*(C`merge\*(C'\fI\fR
.IX Subsection "merge"
.PP
.Vb 2
\&  my $merge = $source\->merge;
\&  $source\->config( $bool );
.Ve
.PP
Chaining getter/setter for the flag that dictates whether \s-1STDOUT\s0 and \s-1STDERR\s0
should be merged (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`switches\*(C'\fI\fR
.IX Subsection "switches"
.PP
.Vb 2
\&  my $switches = $source\->switches;
\&  $source\->config([ @switches ]);
.Ve
.PP
Chaining getter/setter for the list of command-line switches that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`test_args\*(C'\fI\fR
.IX Subsection "test_args"
.PP
.Vb 2
\&  my $test_args = $source\->test_args;
\&  $source\->config([ @test_args ]);
.Ve
.PP
Chaining getter/setter for the list of command-line arguments that should be
passed to the source (where appropriate).  Defaults to undef.
.PP
\fI\f(CI\*(C`assemble_meta\*(C'\fI\fR
.IX Subsection "assemble_meta"
.PP
.Vb 1
\&  my $meta = $source\->assemble_meta;
.Ve
.PP
Gathers meta data about the \*(L"raw\*(R" source, stashes it in \*(L"meta\*(R" and returns
it as a hashref.  This is done so that the TAP::Parser::SourceHandlers don't
have to repeat common checks.  Currently this includes:
.PP
.Vb 3
\&    is_scalar => $bool,
\&    is_hash   => $bool,
\&    is_array  => $bool,
\&
\&    # for scalars:
\&    length => $n
\&    has_newlines => $bool
\&
\&    # only done if the scalar looks like a filename
\&    is_file => $bool,
\&    is_dir  => $bool,
\&    is_symlink => $bool,
\&    file => {
\&        # only done if the scalar looks like a filename
\&        basename => $string, # including ext
\&        dir      => $string,
\&        ext      => $string,
\&        lc_ext   => $string,
\&        # system checks
\&        exists  => $bool,
\&        stat    => [ ... ], # perldoc \-f stat
\&        empty   => $bool,
\&        size    => $n,
\&        text    => $bool,
\&        binary  => $bool,
\&        read    => $bool,
\&        write   => $bool,
\&        execute => $bool,
\&        setuid  => $bool,
\&        setgid  => $bool,
\&        sticky  => $bool,
\&        is_file => $bool,
\&        is_dir  => $bool,
\&        is_symlink => $bool,
\&        # only done if the file\*(Aqs a symlink
\&        lstat      => [ ... ], # perldoc \-f lstat
\&        # only done if the file\*(Aqs a readable text file
\&        shebang => $first_line,
\&    }
\&
\&  # for arrays:
\&  size => $n,
.Ve
.PP
\fI\f(CI\*(C`shebang\*(C'\fI\fR
.IX Subsection "shebang"
.PP
Get the shebang line for a script file.
.PP
.Vb 1
\&  my $shebang = TAP::Parser::Source\->shebang( $some_script );
.Ve
.PP
May be called as a class method
.PP
\fI\f(CI\*(C`config_for\*(C'\fI\fR
.IX Subsection "config_for"
.PP
.Vb 1
\&  my $config = $source\->config_for( $class );
.Ve
.PP
Returns \*(L"config\*(R" for the \f(CW$class\fR given.  Class names may be fully qualified
or abbreviated, eg:
.PP
.Vb 3
\&  # these are equivalent
\&  $source\->config_for( \*(AqPerl\*(Aq );
\&  $source\->config_for( \*(AqTAP::Parser::SourceHandler::Perl\*(Aq );
.Ve
.PP
If a fully qualified \f(CW$class\fR is given, its abbreviated version is checked first.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steve Purkis.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler
                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler.3pm               0100644 0001750 0001750 00000022301 12566207463 026132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler 3pm"
.TH TAP::Parser::SourceHandler 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler \- Base class for different TAP source handlers
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- don\*(Aqt use directly!
\&  # see TAP::Parser::IteratorFactory for general usage
\&
\&  # must be sub\-classed for use
\&  package MySourceHandler;
\&  use base qw( TAP::Parser::SourceHandler );
\&  sub can_handle    { return $confidence_level }
\&  sub make_iterator { return $iterator }
\&
\&  # see example below for more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an abstract base class for TAP::Parser::Source handlers / handlers.
.PP
A \f(CW\*(C`TAP::Parser::SourceHandler\*(C'\fR does whatever is necessary to produce & capture
a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
\&\f(CW\*(C`SourceHandlers\*(C'\fR must implement the \fIsource detection & handling\fR interface
used by TAP::Parser::IteratorFactory.  At 2 methods, the interface is pretty
simple: \*(L"can_handle\*(R" and \*(L"make_source\*(R".
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin, or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a number between \f(CW0\fR & \f(CW1\fR reflecting how confidently the raw source
can be handled.  For example, \f(CW0\fR means the source cannot handle it, \f(CW0.5\fR
means it may be able to, and \f(CW1\fR means it definitely can.  See
\&\*(L"detect_source\*(R" in TAP::Parser::IteratorFactory for details on how this is used.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a new TAP::Parser::Iterator object for use by the TAP::Parser.
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview, and any
of the subclasses that ship with this module as an example.  What follows is
a quick overview.
.PP
Start by familiarizing yourself with TAP::Parser::Source and
TAP::Parser::IteratorFactory.  TAP::Parser::SourceHandler::RawTAP is
the easiest sub-class to use an an example.
.PP
It's important to point out that if you want your subclass to be automatically
used by TAP::Parser you'll have to and make sure it gets loaded somehow.
If you're using prove you can write an App::Prove plugin.  If you're
using TAP::Parser or TAP::Harness directly (e.g. through a custom script,
ExtUtils::MakeMaker, or Module::Build) you can use the \f(CW\*(C`config\*(C'\fR option
which will cause \*(L"load_sources\*(R" in TAP::Parser::IteratorFactory to load your
subclass).
.PP
Don't forget to register your class with
\&\*(L"register_handler\*(R" in TAP::Parser::IteratorFactory.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq; # compat with older perls
\&
\&  use MySourceHandler; # see TAP::Parser::SourceHandler
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler );
\&
\&  TAP::Parser::IteratorFactory\->register_handler( _\|_PACKAGE_\|_ );
\&
\&  sub can_handle {
\&      my ( $class, $src ) = @_;
\&      my $meta   = $src\->meta;
\&      my $config = $src\->config_for( $class );
\&
\&      if ($config\->{accept_all}) {
\&          return 1.0;
\&      } elsif (my $file = $meta\->{file}) {
\&          return 0.0 unless $file\->{exists};
\&          return 1.0 if $file\->{lc_ext} eq \*(Aq.tap\*(Aq;
\&          return 0.9 if $file\->{shebang} && $file\->{shebang} =~ /^#!.+tap/;
\&          return 0.5 if $file\->{text};
\&          return 0.1 if $file\->{binary};
\&      } elsif ($meta\->{scalar}) {
\&          return 0.8 if $$raw_source_ref =~ /\ed\e.\e.\ed/;
\&          return 0.6 if $meta\->{has_newlines};
\&      } elsif ($meta\->{array}) {
\&          return 0.8 if $meta\->{size} < 5;
\&          return 0.6 if $raw_source_ref\->[0] =~ /foo/;
\&          return 0.5;
\&      } elsif ($meta\->{hash}) {
\&          return 0.6 if $raw_source_ref\->{foo};
\&          return 0.2;
\&      }
\&
\&      return 0;
\&  }
\&
\&  sub make_iterator {
\&      my ($class, $source) = @_;
\&      # this is where you manipulate the source and
\&      # capture the stream of TAP in an iterator
\&      # either pick a TAP::Parser::Iterator::* or write your own...
\&      my $iterator = TAP::Parser::Iterator::Array\->new([ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
\&      return $iterator;
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
TAPx Developers.
.PP
Source detection stuff added by Steve Purkis
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Source,
TAP::Parser::Iterator,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler5.16.3pm           0100644 0001750 0001750 00000021760 12566207441 026450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler 3pm"
.TH TAP::Parser::SourceHandler 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler \- Base class for different TAP source handlers
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- don\*(Aqt use directly!
\&  # see TAP::Parser::IteratorFactory for general usage
\&
\&  # must be sub\-classed for use
\&  package MySourceHandler;
\&  use base qw( TAP::Parser::SourceHandler );
\&  sub can_handle    { return $confidence_level }
\&  sub make_iterator { return $iterator }
\&
\&  # see example below for more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an abstract base class for TAP::Parser::Source handlers / handlers.
.PP
A \f(CW\*(C`TAP::Parser::SourceHandler\*(C'\fR does whatever is necessary to produce & capture
a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
\&\f(CW\*(C`SourceHandlers\*(C'\fR must implement the \fIsource detection & handling\fR interface
used by TAP::Parser::IteratorFactory.  At 2 methods, the interface is pretty
simple: \*(L"can_handle\*(R" and \*(L"make_source\*(R".
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin, or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a number between \f(CW0\fR & \f(CW1\fR reflecting how confidently the raw source
can be handled.  For example, \f(CW0\fR means the source cannot handle it, \f(CW0.5\fR
means it may be able to, and \f(CW1\fR means it definitely can.  See
\&\*(L"detect_source\*(R" in TAP::Parser::IteratorFactory for details on how this is used.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a new TAP::Parser::Iterator object for use by the TAP::Parser.
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview, and any
of the subclasses that ship with this module as an example.  What follows is
a quick overview.
.PP
Start by familiarizing yourself with TAP::Parser::Source and
TAP::Parser::IteratorFactory.  TAP::Parser::SourceHandler::RawTAP is
the easiest sub-class to use an an example.
.PP
It's important to point out that if you want your subclass to be automatically
used by TAP::Parser you'll have to and make sure it gets loaded somehow.
If you're using prove you can write an App::Prove plugin.  If you're
using TAP::Parser or TAP::Harness directly (e.g. through a custom script,
ExtUtils::MakeMaker, or Module::Build) you can use the \f(CW\*(C`config\*(C'\fR option
which will cause \*(L"load_sources\*(R" in TAP::Parser::IteratorFactory to load your
subclass).
.PP
Don't forget to register your class with
\&\*(L"register_handler\*(R" in TAP::Parser::IteratorFactory.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq; # compat with older perls
\&
\&  use MySourceHandler; # see TAP::Parser::SourceHandler
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler );
\&
\&  TAP::Parser::IteratorFactory\->register_handler( _\|_PACKAGE_\|_ );
\&
\&  sub can_handle {
\&      my ( $class, $src ) = @_;
\&      my $meta   = $src\->meta;
\&      my $config = $src\->config_for( $class );
\&
\&      if ($config\->{accept_all}) {
\&          return 1.0;
\&      } elsif (my $file = $meta\->{file}) {
\&          return 0.0 unless $file\->{exists};
\&          return 1.0 if $file\->{lc_ext} eq \*(Aq.tap\*(Aq;
\&          return 0.9 if $file\->{shebang} && $file\->{shebang} =~ /^#!.+tap/;
\&          return 0.5 if $file\->{text};
\&          return 0.1 if $file\->{binary};
\&      } elsif ($meta\->{scalar}) {
\&          return 0.8 if $$raw_source_ref =~ /\ed\e.\e.\ed/;
\&          return 0.6 if $meta\->{has_newlines};
\&      } elsif ($meta\->{array}) {
\&          return 0.8 if $meta\->{size} < 5;
\&          return 0.6 if $raw_source_ref\->[0] =~ /foo/;
\&          return 0.5;
\&      } elsif ($meta\->{hash}) {
\&          return 0.6 if $raw_source_ref\->{foo};
\&          return 0.2;
\&      }
\&
\&      return 0;
\&  }
\&
\&  sub make_iterator {
\&      my ($class, $source) = @_;
\&      # this is where you manipulate the source and
\&      # capture the stream of TAP in an iterator
\&      # either pick a TAP::Parser::Iterator::* or write your own...
\&      my $iterator = TAP::Parser::Iterator::Array\->new([ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
\&      return $iterator;
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
TAPx Developers.
.PP
Source detection stuff added by Steve Purkis
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Source,
TAP::Parser::Iterator,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler5.18.3pm           0100644 0001750 0001750 00000022301 12566207463 026446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler 3pm"
.TH TAP::Parser::SourceHandler 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler \- Base class for different TAP source handlers
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- don\*(Aqt use directly!
\&  # see TAP::Parser::IteratorFactory for general usage
\&
\&  # must be sub\-classed for use
\&  package MySourceHandler;
\&  use base qw( TAP::Parser::SourceHandler );
\&  sub can_handle    { return $confidence_level }
\&  sub make_iterator { return $iterator }
\&
\&  # see example below for more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an abstract base class for TAP::Parser::Source handlers / handlers.
.PP
A \f(CW\*(C`TAP::Parser::SourceHandler\*(C'\fR does whatever is necessary to produce & capture
a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
TAP::Parser::Iterator for the parser to consume.
.PP
\&\f(CW\*(C`SourceHandlers\*(C'\fR must implement the \fIsource detection & handling\fR interface
used by TAP::Parser::IteratorFactory.  At 2 methods, the interface is pretty
simple: \*(L"can_handle\*(R" and \*(L"make_source\*(R".
.PP
Unless you're writing a new TAP::Parser::SourceHandler, a plugin, or
subclassing TAP::Parser, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a number between \f(CW0\fR & \f(CW1\fR reflecting how confidently the raw source
can be handled.  For example, \f(CW0\fR means the source cannot handle it, \f(CW0.5\fR
means it may be able to, and \f(CW1\fR means it definitely can.  See
\&\*(L"detect_source\*(R" in TAP::Parser::IteratorFactory for details on how this is used.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
\&\f(CW$source\fR is a TAP::Parser::Source.
.PP
Returns a new TAP::Parser::Iterator object for use by the TAP::Parser.
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview, and any
of the subclasses that ship with this module as an example.  What follows is
a quick overview.
.PP
Start by familiarizing yourself with TAP::Parser::Source and
TAP::Parser::IteratorFactory.  TAP::Parser::SourceHandler::RawTAP is
the easiest sub-class to use an an example.
.PP
It's important to point out that if you want your subclass to be automatically
used by TAP::Parser you'll have to and make sure it gets loaded somehow.
If you're using prove you can write an App::Prove plugin.  If you're
using TAP::Parser or TAP::Harness directly (e.g. through a custom script,
ExtUtils::MakeMaker, or Module::Build) you can use the \f(CW\*(C`config\*(C'\fR option
which will cause \*(L"load_sources\*(R" in TAP::Parser::IteratorFactory to load your
subclass).
.PP
Don't forget to register your class with
\&\*(L"register_handler\*(R" in TAP::Parser::IteratorFactory.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq; # compat with older perls
\&
\&  use MySourceHandler; # see TAP::Parser::SourceHandler
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler );
\&
\&  TAP::Parser::IteratorFactory\->register_handler( _\|_PACKAGE_\|_ );
\&
\&  sub can_handle {
\&      my ( $class, $src ) = @_;
\&      my $meta   = $src\->meta;
\&      my $config = $src\->config_for( $class );
\&
\&      if ($config\->{accept_all}) {
\&          return 1.0;
\&      } elsif (my $file = $meta\->{file}) {
\&          return 0.0 unless $file\->{exists};
\&          return 1.0 if $file\->{lc_ext} eq \*(Aq.tap\*(Aq;
\&          return 0.9 if $file\->{shebang} && $file\->{shebang} =~ /^#!.+tap/;
\&          return 0.5 if $file\->{text};
\&          return 0.1 if $file\->{binary};
\&      } elsif ($meta\->{scalar}) {
\&          return 0.8 if $$raw_source_ref =~ /\ed\e.\e.\ed/;
\&          return 0.6 if $meta\->{has_newlines};
\&      } elsif ($meta\->{array}) {
\&          return 0.8 if $meta\->{size} < 5;
\&          return 0.6 if $raw_source_ref\->[0] =~ /foo/;
\&          return 0.5;
\&      } elsif ($meta\->{hash}) {
\&          return 0.6 if $raw_source_ref\->{foo};
\&          return 0.2;
\&      }
\&
\&      return 0;
\&  }
\&
\&  sub make_iterator {
\&      my ($class, $source) = @_;
\&      # this is where you manipulate the source and
\&      # capture the stream of TAP in an iterator
\&      # either pick a TAP::Parser::Iterator::* or write your own...
\&      my $iterator = TAP::Parser::Iterator::Array\->new([ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
\&      return $iterator;
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
TAPx Developers.
.PP
Source detection stuff added by Steve Purkis
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Source,
TAP::Parser::Iterator,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Executable.3pm   0100644 0001750 0001750 00000015725 12566207463 030334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Executable 3pm"
.TH TAP::Parser::SourceHandler::Executable 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Executable \- Stream output from an executable TAP source
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw([\*(Aq/usr/bin/ruby\*(Aq, \*(Aqmytest.rb\*(Aq]);
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Executable\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an \fIexecutable\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an executable
   command (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for executable commands (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you
probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like an executable file. Casts the
following votes:
.PP
.Vb 3
\&  0.9  if it\*(Aqs a hash with an \*(Aqexec\*(Aq key
\&  0.8  if it\*(Aqs a .bat file
\&  0.75 if it\*(Aqs got an execute bit set
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Process for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be in one of the following forms:
.PP
.Vb 1
\&  { exec => [ @exec ] }
\&
\&  [ @exec ]
\&
\&  $file
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Process.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyRubySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use Carp qw( croak );
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Executable );
\&
\&  # expect $handler\->([\*(Aqmytest.rb\*(Aq, \*(Aqcmdline\*(Aq, \*(Aqargs\*(Aq]);
\&  sub make_iterator {
\&    my ($self, $source) = @_;
\&    my @test_args = @{ $source\->test_args };
\&    my $rb_file   = $test_args[0];
\&    croak("error: Ruby file \*(Aq$rb_file\*(Aq not found!") unless (\-f $rb_file);
\&    return $self\->SUPER::raw_source([\*(Aq/usr/bin/ruby\*(Aq, @test_args]);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                           TAP::Parser::SourceHandler::Executable5.16.3pm                                                      0100644 0001750 0001750 00000015404 12566207441 030555  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Executable 3pm"
.TH TAP::Parser::SourceHandler::Executable 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Executable \- Stream output from an executable TAP source
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw([\*(Aq/usr/bin/ruby\*(Aq, \*(Aqmytest.rb\*(Aq]);
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Executable\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an \fIexecutable\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an executable
   command (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for executable commands (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you
probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like an executable file. Casts the
following votes:
.PP
.Vb 3
\&  0.9  if it\*(Aqs a hash with an \*(Aqexec\*(Aq key
\&  0.8  if it\*(Aqs a .bat file
\&  0.75 if it\*(Aqs got an execute bit set
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Process for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be in one of the following forms:
.PP
.Vb 1
\&  { exec => [ @exec ] }
\&
\&  [ @exec ]
\&
\&  $file
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Process.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyRubySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use Carp qw( croak );
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Executable );
\&
\&  # expect $handler\->([\*(Aqmytest.rb\*(Aq, \*(Aqcmdline\*(Aq, \*(Aqargs\*(Aq]);
\&  sub make_iterator {
\&    my ($self, $source) = @_;
\&    my @test_args = @{ $source\->test_args };
\&    my $rb_file   = $test_args[0];
\&    croak("error: Ruby file \*(Aq$rb_file\*(Aq not found!") unless (\-f $rb_file);
\&    return $self\->SUPER::raw_source([\*(Aq/usr/bin/ruby\*(Aq, @test_args]);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                            TAP::Parser::SourceHandler::Executable5.18.3pm                                                      0100644 0001750 0001750 00000015725 12566207463 030571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Executable 3pm"
.TH TAP::Parser::SourceHandler::Executable 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Executable \- Stream output from an executable TAP source
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw([\*(Aq/usr/bin/ruby\*(Aq, \*(Aqmytest.rb\*(Aq]);
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Executable\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an \fIexecutable\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an executable
   command (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for executable commands (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you
probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like an executable file. Casts the
following votes:
.PP
.Vb 3
\&  0.9  if it\*(Aqs a hash with an \*(Aqexec\*(Aq key
\&  0.8  if it\*(Aqs a .bat file
\&  0.75 if it\*(Aqs got an execute bit set
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Process for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be in one of the following forms:
.PP
.Vb 1
\&  { exec => [ @exec ] }
\&
\&  [ @exec ]
\&
\&  $file
.Ve
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Process.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyRubySourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use Carp qw( croak );
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Executable );
\&
\&  # expect $handler\->([\*(Aqmytest.rb\*(Aq, \*(Aqcmdline\*(Aq, \*(Aqargs\*(Aq]);
\&  sub make_iterator {
\&    my ($self, $source) = @_;
\&    my @test_args = @{ $source\->test_args };
\&    my $rb_file   = $test_args[0];
\&    croak("error: Ruby file \*(Aq$rb_file\*(Aq not found!") unless (\-f $rb_file);
\&    return $self\->SUPER::raw_source([\*(Aq/usr/bin/ruby\*(Aq, @test_args]);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::File.3pm         0100644 0001750 0001750 00000014344 12566207463 027126  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::File 3pm"
.TH TAP::Parser::SourceHandler::File 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::File \- Stream TAP from a text file.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::File;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqfile.tap\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::File\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in a file\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the \fIraw\fR source it's given is a file containing raw \s-1TAP\s0
output.  See TAP::Parser::IteratorFactory for more details.
.PP
2. Takes raw \s-1TAP\s0 from the text file given, and converts into an iterator.
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a regular file.  Casts the following votes:
.PP
.Vb 2
\&  0.9 if it\*(Aqs a .tap file
\&  0.9 if it has an extension matching any given in user config.
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.  \f(CW\*(C`croak\*(C'\fRs
on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.Vb 3
\&  {
\&   extensions => [ @case_insensitive_exts_to_match ]
\&  }
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::File5.16.3pm     0100644 0001750 0001750 00000014023 12566207441 027426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::File 3pm"
.TH TAP::Parser::SourceHandler::File 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::File \- Stream TAP from a text file.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::File;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqfile.tap\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::File\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in a file\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the \fIraw\fR source it's given is a file containing raw \s-1TAP\s0
output.  See TAP::Parser::IteratorFactory for more details.
.PP
2. Takes raw \s-1TAP\s0 from the text file given, and converts into an iterator.
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a regular file.  Casts the following votes:
.PP
.Vb 2
\&  0.9 if it\*(Aqs a .tap file
\&  0.9 if it has an extension matching any given in user config.
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.  \f(CW\*(C`croak\*(C'\fRs
on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.Vb 3
\&  {
\&   extensions => [ @case_insensitive_exts_to_match ]
\&  }
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::File5.18.3pm     0100644 0001750 0001750 00000014344 12566207463 027442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::File 3pm"
.TH TAP::Parser::SourceHandler::File 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::File \- Stream TAP from a text file.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::File;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqfile.tap\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::File\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in a file\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the \fIraw\fR source it's given is a file containing raw \s-1TAP\s0
output.  See TAP::Parser::IteratorFactory for more details.
.PP
2. Takes raw \s-1TAP\s0 from the text file given, and converts into an iterator.
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a regular file.  Casts the following votes:
.PP
.Vb 2
\&  0.9 if it\*(Aqs a .tap file
\&  0.9 if it has an extension matching any given in user config.
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.  \f(CW\*(C`croak\*(C'\fRs
on error.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.Vb 3
\&  {
\&   extensions => [ @case_insensitive_exts_to_match ]
\&  }
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Handle.3pm       0100644 0001750 0001750 00000014126 12566207463 027440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Handle 3pm"
.TH TAP::Parser::SourceHandler::Handle 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Handle \- Stream TAP from an IO::Handle or a GLOB.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e*TAP_FILE );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Handle\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in an \s-1IO\s0 Handle\fR TAP::Parser::SourceHandler class.  It
has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an IO::Handle or
\&\s-1GLOB\s0 containing raw \s-1TAP\s0 output (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for IO::Handle's & globs (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Casts the following votes:
.PP
.Vb 2
\&  0.9 if $source is an IO::Handle
\&  0.8 if $source is a glob
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Iterator::Stream,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Handle5.16.3pm   0100644 0001750 0001750 00000013605 12566207441 027747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Handle 3pm"
.TH TAP::Parser::SourceHandler::Handle 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Handle \- Stream TAP from an IO::Handle or a GLOB.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e*TAP_FILE );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Handle\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in an \s-1IO\s0 Handle\fR TAP::Parser::SourceHandler class.  It
has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an IO::Handle or
\&\s-1GLOB\s0 containing raw \s-1TAP\s0 output (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for IO::Handle's & globs (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Casts the following votes:
.PP
.Vb 2
\&  0.9 if $source is an IO::Handle
\&  0.8 if $source is a glob
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Iterator::Stream,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Handle5.18.3pm   0100644 0001750 0001750 00000014126 12566207463 027754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Handle 3pm"
.TH TAP::Parser::SourceHandler::Handle 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Handle \- Stream TAP from an IO::Handle or a GLOB.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Executable;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e*TAP_FILE );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Handle\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 stored in an \s-1IO\s0 Handle\fR TAP::Parser::SourceHandler class.  It
has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is an IO::Handle or
\&\s-1GLOB\s0 containing raw \s-1TAP\s0 output (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for IO::Handle's & globs (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Casts the following votes:
.PP
.Vb 2
\&  0.9 if $source is an IO::Handle
\&  0.8 if $source is a glob
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Stream for the source.
.PP
\fI\f(CI\*(C`iterator_class\*(C'\fI\fR
.IX Subsection "iterator_class"
.PP
The class of iterator to use, override if you're sub-classing.  Defaults
to TAP::Parser::Iterator::Stream.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Iterator::Stream,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Perl.3pm         0100644 0001750 0001750 00000017632 12566207463 027154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Perl 3pm"
.TH TAP::Parser::SourceHandler::Perl 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Perl \- Stream TAP from a Perl executable
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqscript.pl\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Perl\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIPerl\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is actually a Perl
script (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for Perl sources (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a file.  Casts the following votes:
.PP
.Vb 6
\&  0.9  if it has a shebang ala "#!...perl"
\&  0.75 if it has any shebang
\&  0.8  if it\*(Aqs a .t file
\&  0.9  if it\*(Aqs a .pl file
\&  0.75 if it\*(Aqs in a \*(Aqt\*(Aq directory
\&  0.25 by default (backwards compat)
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Constructs & returns a new TAP::Parser::Iterator::Process for the source.
Assumes \f(CW\*(C`$source\->raw\*(C'\fR contains a reference to the perl script.  \f(CW\*(C`croak\*(C'\fRs
if the file could not be found.
.PP
The command to run is built as follows:
.PP
.Vb 1
\&  $perl @switches $perl_script @test_args
.Ve
.PP
The perl command to use is determined by \*(L"get_perl\*(R".  The command generated
is guaranteed to preserve:
.PP
.Vb 3
\&  PERL5LIB
\&  PERL5OPT
\&  Taint Mode, if set in the script\*(Aqs shebang
.Ve
.PP
\&\fINote:\fR the command generated will \fInot\fR respect any shebang line defined in
your Perl script.  This is only a problem if you have compiled a custom version
of Perl or if you want to use a specific version of Perl for one test and a
different version for another, for example:
.PP
.Vb 2
\&  #!/path/to/a/custom_perl \-\-some \-\-args
\&  #!/usr/local/perl\-5.6/bin/perl \-w
.Ve
.PP
Currently you need to write a plugin to get around this.
.PP
\fI\f(CI\*(C`get_taint\*(C'\fI\fR
.IX Subsection "get_taint"
.PP
Decode any taint switches from a Perl shebang line.
.PP
.Vb 2
\&  # $taint will be \*(Aqt\*(Aq
\&  my $taint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl \-t\*(Aq );
\&
\&  # $untaint will be undefined
\&  my $untaint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl\*(Aq );
.Ve
.PP
\fI\f(CI\*(C`get_perl\*(C'\fI\fR
.IX Subsection "get_perl"
.PP
Gets the version of Perl currently running the test suite.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyPerlSourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Perl );
\&
\&  # use the version of perl from the shebang line in the test file
\&  sub get_perl {
\&      my $self = shift;
\&      if (my $shebang = $self\->shebang( $self\->{file} )) {
\&          $shebang =~ /^#!(.*\ebperl.*?)(?:(?:\es)|(?:$))/;
\&          return $1 if $1;
\&      }
\&      return $self\->SUPER::get_perl(@_);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Perl5.16.3pm     0100644 0001750 0001750 00000017311 12566207441 027454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Perl 3pm"
.TH TAP::Parser::SourceHandler::Perl 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Perl \- Stream TAP from a Perl executable
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqscript.pl\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Perl\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIPerl\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is actually a Perl
script (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for Perl sources (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a file.  Casts the following votes:
.PP
.Vb 6
\&  0.9  if it has a shebang ala "#!...perl"
\&  0.75 if it has any shebang
\&  0.8  if it\*(Aqs a .t file
\&  0.9  if it\*(Aqs a .pl file
\&  0.75 if it\*(Aqs in a \*(Aqt\*(Aq directory
\&  0.25 by default (backwards compat)
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Constructs & returns a new TAP::Parser::Iterator::Process for the source.
Assumes \f(CW\*(C`$source\->raw\*(C'\fR contains a reference to the perl script.  \f(CW\*(C`croak\*(C'\fRs
if the file could not be found.
.PP
The command to run is built as follows:
.PP
.Vb 1
\&  $perl @switches $perl_script @test_args
.Ve
.PP
The perl command to use is determined by \*(L"get_perl\*(R".  The command generated
is guaranteed to preserve:
.PP
.Vb 3
\&  PERL5LIB
\&  PERL5OPT
\&  Taint Mode, if set in the script\*(Aqs shebang
.Ve
.PP
\&\fINote:\fR the command generated will \fInot\fR respect any shebang line defined in
your Perl script.  This is only a problem if you have compiled a custom version
of Perl or if you want to use a specific version of Perl for one test and a
different version for another, for example:
.PP
.Vb 2
\&  #!/path/to/a/custom_perl \-\-some \-\-args
\&  #!/usr/local/perl\-5.6/bin/perl \-w
.Ve
.PP
Currently you need to write a plugin to get around this.
.PP
\fI\f(CI\*(C`get_taint\*(C'\fI\fR
.IX Subsection "get_taint"
.PP
Decode any taint switches from a Perl shebang line.
.PP
.Vb 2
\&  # $taint will be \*(Aqt\*(Aq
\&  my $taint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl \-t\*(Aq );
\&
\&  # $untaint will be undefined
\&  my $untaint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl\*(Aq );
.Ve
.PP
\fI\f(CI\*(C`get_perl\*(C'\fI\fR
.IX Subsection "get_perl"
.PP
Gets the version of Perl currently running the test suite.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyPerlSourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Perl );
\&
\&  # use the version of perl from the shebang line in the test file
\&  sub get_perl {
\&      my $self = shift;
\&      if (my $shebang = $self\->shebang( $self\->{file} )) {
\&          $shebang =~ /^#!(.*\ebperl.*?)(?:(?:\es)|(?:$))/;
\&          return $1 if $1;
\&      }
\&      return $self\->SUPER::get_perl(@_);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::Perl5.18.3pm     0100644 0001750 0001750 00000017632 12566207463 027470  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::Perl 3pm"
.TH TAP::Parser::SourceHandler::Perl 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::Perl \- Stream TAP from a Perl executable
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e\*(Aqscript.pl\*(Aq );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::Perl\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIPerl\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is actually a Perl
script (\*(L"can_handle\*(R").
.PP
2. Creates an iterator for Perl sources (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR looks like a file.  Casts the following votes:
.PP
.Vb 6
\&  0.9  if it has a shebang ala "#!...perl"
\&  0.75 if it has any shebang
\&  0.8  if it\*(Aqs a .t file
\&  0.9  if it\*(Aqs a .pl file
\&  0.75 if it\*(Aqs in a \*(Aqt\*(Aq directory
\&  0.25 by default (backwards compat)
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Constructs & returns a new TAP::Parser::Iterator::Process for the source.
Assumes \f(CW\*(C`$source\->raw\*(C'\fR contains a reference to the perl script.  \f(CW\*(C`croak\*(C'\fRs
if the file could not be found.
.PP
The command to run is built as follows:
.PP
.Vb 1
\&  $perl @switches $perl_script @test_args
.Ve
.PP
The perl command to use is determined by \*(L"get_perl\*(R".  The command generated
is guaranteed to preserve:
.PP
.Vb 3
\&  PERL5LIB
\&  PERL5OPT
\&  Taint Mode, if set in the script\*(Aqs shebang
.Ve
.PP
\&\fINote:\fR the command generated will \fInot\fR respect any shebang line defined in
your Perl script.  This is only a problem if you have compiled a custom version
of Perl or if you want to use a specific version of Perl for one test and a
different version for another, for example:
.PP
.Vb 2
\&  #!/path/to/a/custom_perl \-\-some \-\-args
\&  #!/usr/local/perl\-5.6/bin/perl \-w
.Ve
.PP
Currently you need to write a plugin to get around this.
.PP
\fI\f(CI\*(C`get_taint\*(C'\fI\fR
.IX Subsection "get_taint"
.PP
Decode any taint switches from a Perl shebang line.
.PP
.Vb 2
\&  # $taint will be \*(Aqt\*(Aq
\&  my $taint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl \-t\*(Aq );
\&
\&  # $untaint will be undefined
\&  my $untaint = TAP::Parser::SourceHandler::Perl\->get_taint( \*(Aq#!/usr/bin/perl\*(Aq );
.Ve
.PP
\fI\f(CI\*(C`get_perl\*(C'\fI\fR
.IX Subsection "get_perl"
.PP
Gets the version of Perl currently running the test suite.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MyPerlSourceHandler;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq;
\&
\&  use TAP::Parser::SourceHandler::Perl;
\&
\&  @ISA = qw( TAP::Parser::SourceHandler::Perl );
\&
\&  # use the version of perl from the shebang line in the test file
\&  sub get_perl {
\&      my $self = shift;
\&      if (my $shebang = $self\->shebang( $self\->{file} )) {
\&          $shebang =~ /^#!(.*\ebperl.*?)(?:(?:\es)|(?:$))/;
\&          return $1 if $1;
\&      }
\&      return $self\->SUPER::get_perl(@_);
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle,
TAP::Parser::SourceHandler::RawTAP
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::RawTAP.3pm       0100644 0001750 0001750 00000014137 12566207463 027345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::RawTAP 3pm"
.TH TAP::Parser::SourceHandler::RawTAP 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::RawTAP \- Stream output from raw TAP in a scalar/array ref.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::RawTAP;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e"1..1\enok 1\en" );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::RawTAP\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 output\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is raw \s-1TAP\s0 output
(\*(L"can_handle\*(R").
.PP
2. Creates an iterator for raw \s-1TAP\s0 output (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR is an array, or a scalar with newlines.  Casts the
following votes:
.PP
.Vb 4
\&  0.9  if it\*(Aqs a scalar with \*(Aq..\*(Aq in it
\&  0.7  if it\*(Aqs a scalar with \*(Aqok\*(Aq in it
\&  0.3  if it\*(Aqs just a scalar with newlines
\&  0.5  if it\*(Aqs an array
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Array for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be an array ref, or a scalar ref.
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::RawTAP5.16.3pm   0100644 0001750 0001750 00000013616 12566207441 027654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::RawTAP 3pm"
.TH TAP::Parser::SourceHandler::RawTAP 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::RawTAP \- Stream output from raw TAP in a scalar/array ref.
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::RawTAP;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e"1..1\enok 1\en" );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::RawTAP\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 output\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is raw \s-1TAP\s0 output
(\*(L"can_handle\*(R").
.PP
2. Creates an iterator for raw \s-1TAP\s0 output (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR is an array, or a scalar with newlines.  Casts the
following votes:
.PP
.Vb 4
\&  0.9  if it\*(Aqs a scalar with \*(Aq..\*(Aq in it
\&  0.7  if it\*(Aqs a scalar with \*(Aqok\*(Aq in it
\&  0.3  if it\*(Aqs just a scalar with newlines
\&  0.5  if it\*(Aqs an array
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Array for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be an array ref, or a scalar ref.
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\s0\*(R" in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::SourceHandler::RawTAP5.18.3pm   0100644 0001750 0001750 00000014137 12566207463 027661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandler::RawTAP 3pm"
.TH TAP::Parser::SourceHandler::RawTAP 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandler::RawTAP \- Stream output from raw TAP in a scalar/array ref.
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Source;
\&  use TAP::Parser::SourceHandler::RawTAP;
\&
\&  my $source = TAP::Parser::Source\->new\->raw( \e"1..1\enok 1\en" );
\&  $source\->assemble_meta;
\&
\&  my $class = \*(AqTAP::Parser::SourceHandler::RawTAP\*(Aq;
\&  my $vote  = $class\->can_handle( $source );
\&  my $iter  = $class\->make_iterator( $source );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIraw \s-1TAP\s0 output\fR TAP::Parser::SourceHandler \- it has 2 jobs:
.PP
1. Figure out if the TAP::Parser::Source it's given is raw \s-1TAP\s0 output
(\*(L"can_handle\*(R").
.PP
2. Creates an iterator for raw \s-1TAP\s0 output (\*(L"make_iterator\*(R").
.PP
Unless you're writing a plugin or subclassing TAP::Parser, you probably
won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
.Vb 1
\&  my $vote = $class\->can_handle( $source );
.Ve
.PP
Only votes if \f(CW$source\fR is an array, or a scalar with newlines.  Casts the
following votes:
.PP
.Vb 4
\&  0.9  if it\*(Aqs a scalar with \*(Aq..\*(Aq in it
\&  0.7  if it\*(Aqs a scalar with \*(Aqok\*(Aq in it
\&  0.3  if it\*(Aqs just a scalar with newlines
\&  0.5  if it\*(Aqs an array
.Ve
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
.Vb 1
\&  my $iterator = $class\->make_iterator( $source );
.Ve
.PP
Returns a new TAP::Parser::Iterator::Array for the source.
\&\f(CW\*(C`$source\->raw\*(C'\fR must be an array ref, or a scalar ref.
.PP
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see \*(L"\s-1SUBCLASSING\*(R"\s0 in TAP::Parser for a subclassing overview.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandler,
TAP::Parser::SourceHandler::Executable,
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File,
TAP::Parser::SourceHandler::Handle
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Utils.3pm                       0100644 0001750 0001750 00000011754 12566207463 024506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Utils 3pm"
.TH TAP::Parser::Utils 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Utils \- Internal TAP::Parser utilities
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Utils qw( split_shell )
\&  my @switches = split_shell( $arg );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1FOR INTERNAL USE ONLY\s0!\fR
.SS "\s-1INTERFACE\s0"
.IX Subsection "INTERFACE"
\fI\f(CI\*(C`split_shell\*(C'\fI\fR
.IX Subsection "split_shell"
.PP
Shell style argument parsing. Handles backslash escaping, single and
double quoted strings but not shell substitutions.
.PP
Pass one or more strings containing shell escaped arguments. The return
value is an array of arguments parsed from the input strings according
to (approximate) shell parsing rules. It's legal to pass \f(CW\*(C`undef\*(C'\fR in
which case an empty array will be returned. That makes it possible to
.PP
.Vb 1
\&    my @args = split_shell( $ENV{SOME_ENV_VAR} );
.Ve
.PP
without worrying about whether the environment variable exists.
.PP
This is used to split \s-1HARNESS_PERL_ARGS\s0 into individual switches.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Utils5.16.3pm                   0100644 0001750 0001750 00000011460 12566207441 025006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Utils 3pm"
.TH TAP::Parser::Utils 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Utils \- Internal TAP::Parser utilities
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Utils qw( split_shell )
\&  my @switches = split_shell( $arg );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1FOR\s0 \s-1INTERNAL\s0 \s-1USE\s0 \s-1ONLY\s0!\fR
.SS "\s-1INTERFACE\s0"
.IX Subsection "INTERFACE"
\fI\f(CI\*(C`split_shell\*(C'\fI\fR
.IX Subsection "split_shell"
.PP
Shell style argument parsing. Handles backslash escaping, single and
double quoted strings but not shell substitutions.
.PP
Pass one or more strings containing shell escaped arguments. The return
value is an array of arguments parsed from the input strings according
to (approximate) shell parsing rules. It's legal to pass \f(CW\*(C`undef\*(C'\fR in
which case an empty array will be returned. That makes it possible to
.PP
.Vb 1
\&    my @args = split_shell( $ENV{SOME_ENV_VAR} );
.Ve
.PP
without worrying about whether the environment variable exists.
.PP
This is used to split \s-1HARNESS_PERL_ARGS\s0 into individual switches.
                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::Utils5.18.3pm                   0100644 0001750 0001750 00000011754 12566207463 025022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Utils 3pm"
.TH TAP::Parser::Utils 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Utils \- Internal TAP::Parser utilities
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use TAP::Parser::Utils qw( split_shell )
\&  my @switches = split_shell( $arg );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1FOR INTERNAL USE ONLY\s0!\fR
.SS "\s-1INTERFACE\s0"
.IX Subsection "INTERFACE"
\fI\f(CI\*(C`split_shell\*(C'\fI\fR
.IX Subsection "split_shell"
.PP
Shell style argument parsing. Handles backslash escaping, single and
double quoted strings but not shell substitutions.
.PP
Pass one or more strings containing shell escaped arguments. The return
value is an array of arguments parsed from the input strings according
to (approximate) shell parsing rules. It's legal to pass \f(CW\*(C`undef\*(C'\fR in
which case an empty array will be returned. That makes it possible to
.PP
.Vb 1
\&    my @args = split_shell( $ENV{SOME_ENV_VAR} );
.Ve
.PP
without worrying about whether the environment variable exists.
.PP
This is used to split \s-1HARNESS_PERL_ARGS\s0 into individual switches.
                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Reader.3pm             0100644 0001750 0001750 00000013250 12566207463 026154  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Reader 3pm"
.TH TAP::Parser::YAMLish::Reader 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Reader \- Read YAMLish data from iterator
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Note that parts of this code were derived from YAML::Tiny with the
permission of Adam Kennedy.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Reader\*(C'\fR object.
.PP
.Vb 1
\& my $reader = TAP::Parser::YAMLish::Reader\->new;
.Ve
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`read\*(C'\fI\fR
.IX Subsection "read"
.PP
.Vb 1
\& my $got = $reader\->read($iterator);
.Ve
.PP
Read YAMLish from a TAP::Parser::Iterator and return the data structure it
represents.
.PP
\fI\f(CI\*(C`get_raw\*(C'\fI\fR
.IX Subsection "get_raw"
.PP
.Vb 1
\& my $source = $reader\->get_source;
.Ve
.PP
Return the raw YAMLish source from the most recent \f(CW\*(C`read\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.PP
Adam Kennedy wrote YAML::Tiny which provided the template and many of
the \s-1YAML\s0 matching regular expressions for this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
Portions copyright 2006\-2008 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Reader5.16.3pm         0100644 0001750 0001750 00000012727 12566207441 026472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Reader 3pm"
.TH TAP::Parser::YAMLish::Reader 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Reader \- Read YAMLish data from iterator
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Note that parts of this code were derived from YAML::Tiny with the
permission of Adam Kennedy.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Reader\*(C'\fR object.
.PP
.Vb 1
\& my $reader = TAP::Parser::YAMLish::Reader\->new;
.Ve
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`read\*(C'\fI\fR
.IX Subsection "read"
.PP
.Vb 1
\& my $got = $reader\->read($iterator);
.Ve
.PP
Read YAMLish from a TAP::Parser::Iterator and return the data structure it
represents.
.PP
\fI\f(CI\*(C`get_raw\*(C'\fI\fR
.IX Subsection "get_raw"
.PP
.Vb 1
\& my $source = $reader\->get_source;
.Ve
.PP
Return the raw YAMLish source from the most recent \f(CW\*(C`read\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.PP
Adam Kennedy wrote YAML::Tiny which provided the template and many of
the \s-1YAML\s0 matching regular expressions for this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
Portions copyright 2006\-2008 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Reader5.18.3pm         0100644 0001750 0001750 00000013250 12566207463 026470  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Reader 3pm"
.TH TAP::Parser::YAMLish::Reader 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Reader \- Read YAMLish data from iterator
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Note that parts of this code were derived from YAML::Tiny with the
permission of Adam Kennedy.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Reader\*(C'\fR object.
.PP
.Vb 1
\& my $reader = TAP::Parser::YAMLish::Reader\->new;
.Ve
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`read\*(C'\fI\fR
.IX Subsection "read"
.PP
.Vb 1
\& my $got = $reader\->read($iterator);
.Ve
.PP
Read YAMLish from a TAP::Parser::Iterator and return the data structure it
represents.
.PP
\fI\f(CI\*(C`get_raw\*(C'\fI\fR
.IX Subsection "get_raw"
.PP
.Vb 1
\& my $source = $reader\->get_source;
.Ve
.PP
Return the raw YAMLish source from the most recent \f(CW\*(C`read\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.PP
Adam Kennedy wrote YAML::Tiny which provided the template and many of
the \s-1YAML\s0 matching regular expressions for this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
Portions copyright 2006\-2008 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Writer.3pm             0100644 0001750 0001750 00000015034 12566207463 026230  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Writer 3pm"
.TH TAP::Parser::YAMLish::Writer 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Writer \- Write YAMLish data
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::YAMLish::Writer;
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    
\&    # Write to an array...
\&    $yw\->write( $data, \e@some_array );
\&    
\&    # ...an open file handle...
\&    $yw\->write( $data, $some_file_handle );
\&    
\&    # ...a string ...
\&    $yw\->write( $data, \e$some_string );
\&    
\&    # ...or a closure
\&    $yw\->write( $data, sub {
\&        my $line = shift;
\&        print "$line\en";
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Encodes a scalar, hash reference or array reference as YAMLish.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $writer = TAP::Parser::YAMLish::Writer\->new;
.Ve
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Writer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`write\*(C'\fI\fR
.IX Subsection "write"
.PP
.Vb 1
\& $writer\->write($obj, $output );
.Ve
.PP
Encode a scalar, hash reference or array reference as \s-1YAML.\s0
.PP
.Vb 4
\&    my $writer = sub {
\&        my $line = shift;
\&        print SOMEFILE "$line\en";
\&    };
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    $yw\->write( $data, $writer );
.Ve
.PP
The \f(CW $output \fR argument may be:
.IP "\(bu" 4
a reference to a scalar to append \s-1YAML\s0 to
.IP "\(bu" 4
the handle of an open file
.IP "\(bu" 4
a reference to an array into which \s-1YAML\s0 will be pushed
.IP "\(bu" 4
a code reference
.PP
If you supply a code reference the subroutine will be called once for
each line of output with the line as its only argument. Passed lines
will have no trailing newline.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Writer5.16.3pm         0100644 0001750 0001750 00000014513 12566207441 026537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Writer 3pm"
.TH TAP::Parser::YAMLish::Writer 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Writer \- Write YAMLish data
.SH "VERSION"
.IX Header "VERSION"
Version 3.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::YAMLish::Writer;
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    
\&    # Write to an array...
\&    $yw\->write( $data, \e@some_array );
\&    
\&    # ...an open file handle...
\&    $yw\->write( $data, $some_file_handle );
\&    
\&    # ...a string ...
\&    $yw\->write( $data, \e$some_string );
\&    
\&    # ...or a closure
\&    $yw\->write( $data, sub {
\&        my $line = shift;
\&        print "$line\en";
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Encodes a scalar, hash reference or array reference as YAMLish.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $writer = TAP::Parser::YAMLish::Writer\->new;
.Ve
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Writer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`write\*(C'\fI\fR
.IX Subsection "write"
.PP
.Vb 1
\& $writer\->write($obj, $output );
.Ve
.PP
Encode a scalar, hash reference or array reference as \s-1YAML\s0.
.PP
.Vb 4
\&    my $writer = sub {
\&        my $line = shift;
\&        print SOMEFILE "$line\en";
\&    };
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    $yw\->write( $data, $writer );
.Ve
.PP
The \f(CW $output \fR argument may be:
.IP "\(bu" 4
a reference to a scalar to append \s-1YAML\s0 to
.IP "\(bu" 4
the handle of an open file
.IP "\(bu" 4
a reference to an array into which \s-1YAML\s0 will be pushed
.IP "\(bu" 4
a code reference
.PP
If you supply a code reference the subroutine will be called once for
each line of output with the line as its only argument. Passed lines
will have no trailing newline.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TAP::Parser::YAMLish::Writer5.18.3pm         0100644 0001750 0001750 00000015034 12566207463 026544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::YAMLish::Writer 3pm"
.TH TAP::Parser::YAMLish::Writer 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::YAMLish::Writer \- Write YAMLish data
.SH "VERSION"
.IX Header "VERSION"
Version 3.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::YAMLish::Writer;
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    
\&    # Write to an array...
\&    $yw\->write( $data, \e@some_array );
\&    
\&    # ...an open file handle...
\&    $yw\->write( $data, $some_file_handle );
\&    
\&    # ...a string ...
\&    $yw\->write( $data, \e$some_string );
\&    
\&    # ...or a closure
\&    $yw\->write( $data, sub {
\&        my $line = shift;
\&        print "$line\en";
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Encodes a scalar, hash reference or array reference as YAMLish.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $writer = TAP::Parser::YAMLish::Writer\->new;
.Ve
.PP
The constructor \f(CW\*(C`new\*(C'\fR creates and returns an empty
\&\f(CW\*(C`TAP::Parser::YAMLish::Writer\*(C'\fR object.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`write\*(C'\fI\fR
.IX Subsection "write"
.PP
.Vb 1
\& $writer\->write($obj, $output );
.Ve
.PP
Encode a scalar, hash reference or array reference as \s-1YAML.\s0
.PP
.Vb 4
\&    my $writer = sub {
\&        my $line = shift;
\&        print SOMEFILE "$line\en";
\&    };
\&    
\&    my $data = {
\&        one => 1,
\&        two => 2,
\&        three => [ 1, 2, 3 ],
\&    };
\&    
\&    my $yw = TAP::Parser::YAMLish::Writer\->new;
\&    $yw\->write( $data, $writer );
.Ve
.PP
The \f(CW $output \fR argument may be:
.IP "\(bu" 4
a reference to a scalar to append \s-1YAML\s0 to
.IP "\(bu" 4
the handle of an open file
.IP "\(bu" 4
a reference to an array into which \s-1YAML\s0 will be pushed
.IP "\(bu" 4
a code reference
.PP
If you supply a code reference the subroutine will be called once for
each line of output with the line as its only argument. Passed lines
will have no trailing newline.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong, <andy@hexten.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
YAML::Tiny, \s-1YAML\s0, YAML::Syck, Config::Tiny, CSS::Tiny,
<http://use.perl.org/~Alias/journal/29427>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2007\-2011 Andy Armstrong.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/TCL_MEM_DEBUG.3tcl                           0100644 0001750 0001750 00000022666 12566232351 023506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\" 
'\" Copyright (c) 1992-1999 Karl Lehenbauer and Mark Diekhans.
'\" Copyright (c) 2000 by Scriptics Corporation.
'\" All rights reserved.
'\" 
'\" RCS: @(#) $Id: TCL_MEM_DEBUG.3,v 1.11 2007/12/13 15:22:32 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH TCL_MEM_DEBUG 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
TCL_MEM_DEBUG \- Compile-time flag to enable Tcl memory debugging
.BE
.SH DESCRIPTION
When Tcl is compiled with \fBTCL_MEM_DEBUG\fR defined, a powerful set
of memory debugging aids is included in the compiled binary.  This
includes C and Tcl functions which can aid with debugging
memory leaks, memory allocation overruns, and other memory related
errors.
.SH "ENABLING MEMORY DEBUGGING"
.PP
To enable memory debugging, Tcl should be recompiled from scratch with
\fBTCL_MEM_DEBUG\fR defined (e.g. by passing the
\fI\-\-enable\-symbols=mem\fR flag to the \fIconfigure\fR script when
building).  This will also compile in a non-stub
version of \fBTcl_InitMemory\fR to add the \fBmemory\fR command to Tcl.
.PP
\fBTCL_MEM_DEBUG\fR must be either left defined for all modules or undefined
for all modules that are going to be linked together.  If they are not, link
errors will occur, with either \fBTcl_DbCkfree\fR and \fBTcl_DbCkalloc\fR or
\fBTcl_Ckalloc\fR and \fBTcl_Ckfree\fR being undefined.
.PP
Once memory debugging support has been compiled into Tcl, the C
functions \fBTcl_ValidateAllMemory\fR, and \fBTcl_DumpActiveMemory\fR,
and the Tcl \fBmemory\fR command can be used to validate and examine
memory usage.
.SH "GUARD ZONES"
.PP
When memory debugging is enabled, whenever a call to \fBckalloc\fR is
made, slightly more memory than requested is allocated so the memory
debugging code can keep track of the allocated memory, and eight-byte
.QW "guard zones"
are placed in front of and behind the space that will be
returned to the caller.  (The sizes of the guard zones are defined by the
C #define \fBLOW_GUARD_SIZE\fR and #define \fBHIGH_GUARD_SIZE\fR
in the file \fIgeneric/tclCkalloc.c\fR \(em it can
be extended if you suspect large overwrite problems, at some cost in
performance.)  A known pattern is written into the guard zones and, on
a call to \fBckfree\fR, the guard zones of the space being freed are
checked to see if either zone has been modified in any way.  If one
has been, the guard bytes and their new contents are identified, and a
.QW "low guard failed"
or
.QW "high guard failed"
message is issued.  The
.QW "guard failed"
message includes the address of the memory packet and
the file name and line number of the code that called \fBckfree\fR.
This allows you to detect the common sorts of one-off problems, where
not enough space was allocated to contain the data written, for
example.
.SH "DEBUGGING DIFFICULT MEMORY CORRUPTION PROBLEMS"
.PP
Normally, Tcl compiled with memory debugging enabled will make it easy
to isolate a corruption problem.  Turning on memory validation with
the memory command can help isolate difficult problems.  If you
suspect (or know) that corruption is occurring before the Tcl
interpreter comes up far enough for you to issue commands, you can set
\fBMEM_VALIDATE\fR define, recompile tclCkalloc.c and rebuild Tcl.
This will enable memory validation from the first call to
\fBckalloc\fR, again, at a large performance impact.
.PP
If you are desperate and validating memory on every call to
\fBckalloc\fR and \fBckfree\fR is not enough, you can explicitly call
\fBTcl_ValidateAllMemory\fR directly at any point.  It takes a \fIchar
*\fR and an \fIint\fR which are normally the filename and line number
of the caller, but they can actually be anything you want.  Remember
to remove the calls after you find the problem.
.SH "SEE ALSO"
ckalloc, memory, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory
.SH KEYWORDS
memory, debug
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Task::Weaken.3pm                             0100644 0001750 0001750 00000015276 12566242110 023524  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Task::Weaken 3"
.TH Task::Weaken 3 "2011-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Task::Weaken \- Ensure that a platform has weaken support
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One recurring problem in modules that use Scalar::Util's \f(CW\*(C`weaken\*(C'\fR
function is that it is not present in the pure-perl variant.
.PP
While this isn't necesarily always a problem in a straight CPAN-based
Perl environment, some operating system distributions only include the
pure-Perl versions, don't include the \s-1XS\s0 version, and so weaken is
then \*(L"missing\*(R" from the platform, \fBdespite\fR passing a dependency on
Scalar::Util successfully.
.PP
Most notably this is RedHat Linux at time of writing, but other come
and go and do the same thing, hence \*(L"recurring problem\*(R".
.PP
The normal solution is to manually write tests in each distribution
to ensure that \f(CW\*(C`weaken\*(C'\fR is available.
.PP
This restores the functionality testing to a dependency you do once
in your \fIMakefile.PL\fR, rather than something you have to write extra
tests for each time you write a module.
.PP
It should also help make the package auto-generators for the various
operating systems play more nicely, because it introduces a dependency
that they \fBhave\fR to have a proper weaken in order to work.
.SS "How this Task works"
.IX Subsection "How this Task works"
Part of the problem seems to stem from the fact that some distributions
continue to include modules even if they fail some of their tests.
.PP
To get around that for this module, it will do a few dirty tricks.
.PP
If Scalar::Util is not available at all, it will issue a normal
dependency on the module. However, if Scalar::Util is relatively
new ( it is >= 1.19 ) and the module does \fBnot\fR have weaken, the
install will bail out altogether with a long error encouraging the
user to seek support from their vendor (this problem happens most
often in vendor-packaged Perl versions).
.PP
This distribution also contains tests to ensure that weaken is
available using more normal methods.
.PP
So if your module uses \f(CW\*(C`weaken\*(C'\fR, you can just add the following to
your Module::Install\-based \fIMakefile.PL\fR (or equivalent).
.PP
.Vb 1
\&  requires \*(AqTask::Weaken\*(Aq => 0;
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be always be reported via the \s-1CPAN\s0 bug tracker at
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Task\-Weaken>
.PP
For other issues,contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Task, Scalar::Util, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2006 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Task::Weaken5.16.3pm                         0100644 0001750 0001750 00000015050 12566242122 024027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Task::Weaken 3"
.TH Task::Weaken 3 "2011-03-08" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Task::Weaken \- Ensure that a platform has weaken support
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One recurring problem in modules that use Scalar::Util's \f(CW\*(C`weaken\*(C'\fR
function is that it is not present in the pure-perl variant.
.PP
While this isn't necesarily always a problem in a straight CPAN-based
Perl environment, some operating system distributions only include the
pure-Perl versions, don't include the \s-1XS\s0 version, and so weaken is
then \*(L"missing\*(R" from the platform, \fBdespite\fR passing a dependency on
Scalar::Util successfully.
.PP
Most notably this is RedHat Linux at time of writing, but other come
and go and do the same thing, hence \*(L"recurring problem\*(R".
.PP
The normal solution is to manually write tests in each distribution
to ensure that \f(CW\*(C`weaken\*(C'\fR is available.
.PP
This restores the functionality testing to a dependency you do once
in your \fIMakefile.PL\fR, rather than something you have to write extra
tests for each time you write a module.
.PP
It should also help make the package auto-generators for the various
operating systems play more nicely, because it introduces a dependency
that they \fBhave\fR to have a proper weaken in order to work.
.SS "How this Task works"
.IX Subsection "How this Task works"
Part of the problem seems to stem from the fact that some distributions
continue to include modules even if they fail some of their tests.
.PP
To get around that for this module, it will do a few dirty tricks.
.PP
If Scalar::Util is not available at all, it will issue a normal
dependency on the module. However, if Scalar::Util is relatively
new ( it is >= 1.19 ) and the module does \fBnot\fR have weaken, the
install will bail out altogether with a long error encouraging the
user to seek support from their vendor (this problem happens most
often in vendor-packaged Perl versions).
.PP
This distribution also contains tests to ensure that weaken is
available using more normal methods.
.PP
So if your module uses \f(CW\*(C`weaken\*(C'\fR, you can just add the following to
your Module::Install\-based \fIMakefile.PL\fR (or equivalent).
.PP
.Vb 1
\&  requires \*(AqTask::Weaken\*(Aq => 0;
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be always be reported via the \s-1CPAN\s0 bug tracker at
.PP
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Task\-Weaken <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Task-Weaken>
.PP
For other issues,contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Task, Scalar::Util, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2006 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Task::Weaken5.18.3pm                         0100644 0001750 0001750 00000015276 12566242110 024040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Task::Weaken 3"
.TH Task::Weaken 3 "2011-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Task::Weaken \- Ensure that a platform has weaken support
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One recurring problem in modules that use Scalar::Util's \f(CW\*(C`weaken\*(C'\fR
function is that it is not present in the pure-perl variant.
.PP
While this isn't necesarily always a problem in a straight CPAN-based
Perl environment, some operating system distributions only include the
pure-Perl versions, don't include the \s-1XS\s0 version, and so weaken is
then \*(L"missing\*(R" from the platform, \fBdespite\fR passing a dependency on
Scalar::Util successfully.
.PP
Most notably this is RedHat Linux at time of writing, but other come
and go and do the same thing, hence \*(L"recurring problem\*(R".
.PP
The normal solution is to manually write tests in each distribution
to ensure that \f(CW\*(C`weaken\*(C'\fR is available.
.PP
This restores the functionality testing to a dependency you do once
in your \fIMakefile.PL\fR, rather than something you have to write extra
tests for each time you write a module.
.PP
It should also help make the package auto-generators for the various
operating systems play more nicely, because it introduces a dependency
that they \fBhave\fR to have a proper weaken in order to work.
.SS "How this Task works"
.IX Subsection "How this Task works"
Part of the problem seems to stem from the fact that some distributions
continue to include modules even if they fail some of their tests.
.PP
To get around that for this module, it will do a few dirty tricks.
.PP
If Scalar::Util is not available at all, it will issue a normal
dependency on the module. However, if Scalar::Util is relatively
new ( it is >= 1.19 ) and the module does \fBnot\fR have weaken, the
install will bail out altogether with a long error encouraging the
user to seek support from their vendor (this problem happens most
often in vendor-packaged Perl versions).
.PP
This distribution also contains tests to ensure that weaken is
available using more normal methods.
.PP
So if your module uses \f(CW\*(C`weaken\*(C'\fR, you can just add the following to
your Module::Install\-based \fIMakefile.PL\fR (or equivalent).
.PP
.Vb 1
\&  requires \*(AqTask::Weaken\*(Aq => 0;
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be always be reported via the \s-1CPAN\s0 bug tracker at
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Task\-Weaken>
.PP
For other issues,contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Task, Scalar::Util, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2006 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_Access.3tcl                              0100644 0001750 0001750 00000021031 12566232322 023442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1998-1999 Scriptics Corporation
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Access.3,v 1.9 2004/10/07 14:44:31 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Access 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Access, Tcl_Stat \- check file permissions and other attributes
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_Access\fR(\fIpath\fR, \fImode\fR)
.sp
int
\fBTcl_Stat\fR(\fIpath\fR, \fIstatPtr\fR)
.SH ARGUMENTS
.AS "struct stat" *statPtr out
.AP char *path in
Native name of the file to check the attributes of.
.AP int mode in
Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.  R_OK,
W_OK and X_OK request checking whether the file exists and  has  read,
write and  execute  permissions, respectively.  F_OK just requests
checking for the existence of the file.
.AP "struct stat" *statPtr out
The structure that contains the result.
.BE

.SH DESCRIPTION
.PP
As of Tcl 8.4, the object-based APIs \fBTcl_FSAccess\fR and
\fBTcl_FSStat\fR should be used in preference to \fBTcl_Access\fR and
\fBTcl_Stat\fR, wherever possible.
.PP
There are two reasons for calling \fBTcl_Access\fR and \fBTcl_Stat\fR
rather than calling system level functions \fBaccess\fR and \fBstat\fR
directly.  First, the Windows implementation of both functions fixes
some bugs in the system level calls.  Second, both \fBTcl_Access\fR
and \fBTcl_Stat\fR (as well as \fBTcl_OpenFileChannelProc\fR) hook
into a linked list of functions.  This allows the possibility to reroute
file access to alternative media or access methods.
.PP
\fBTcl_Access\fR checks whether the process would be allowed to read,
write or test for existence of the file (or other file system object)
whose name is pathname.   If pathname is a symbolic link on Unix,
then permissions of the file referred by this symbolic link are
tested.
.PP
On success (all requested permissions granted), zero is returned.  On
error (at least one bit in mode asked for a permission that is denied,
or some other  error occurred), -1 is returned.
.PP
\fBTcl_Stat\fR fills the stat structure \fIstatPtr\fR with information
about the specified file.  You do not need any access rights to the
file to get this information but you need search rights to all
directories named in the path leading to the file.  The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.
.PP
If \fIpath\fR exists, \fBTcl_Stat\fR returns 0 and the stat structure
is filled with data.  Otherwise, -1 is returned, and no stat info is
given.

.SH KEYWORDS
stat, access

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AddErrorInfo.3tcl                        0100644 0001750 0001750 00000044431 12566232322 024570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: AddErrInfo.3,v 1.20 2007/12/13 15:22:30 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_AddErrorInfo 3 8.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetReturnOptions, Tcl_SetReturnOptions, Tcl_AddErrorInfo, Tcl_AppendObjToErrorInfo, Tcl_AddObjErrorInfo, Tcl_SetObjErrorCode, Tcl_SetErrorCode, Tcl_SetErrorCodeVA, Tcl_PosixError, Tcl_LogCommandInfo \- retrieve or record information about errors and other return options
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.VS 8.5
.sp
Tcl_Obj *
\fBTcl_GetReturnOptions\fR(\fIinterp, code\fR)
.sp
int 
\fBTcl_SetReturnOptions\fR(\fIinterp, options\fR)
.VE 8.5
.sp
\fBTcl_AddErrorInfo\fR(\fIinterp, message\fR)
.VS 8.5
.sp
\fBTcl_AppendObjToErrorInfo\fR(\fIinterp, objPtr\fR)
.VE 8.5
.sp
\fBTcl_AddObjErrorInfo\fR(\fIinterp, message, length\fR)
.sp
\fBTcl_SetObjErrorCode\fR(\fIinterp, errorObjPtr\fR)
.sp
\fBTcl_SetErrorCode\fR(\fIinterp, element, element, ... \fB(char *) NULL\fR)
.sp
\fBTcl_SetErrorCodeVA\fR(\fIinterp, argList\fR)
.sp
const char *
\fBTcl_PosixError\fR(\fIinterp\fR)
.sp
void
\fBTcl_LogCommandInfo\fR(\fIinterp, script, command, commandLength\fR)
.SH ARGUMENTS
.AS Tcl_Interp commandLength
.AP Tcl_Interp *interp in
Interpreter in which to record information.
.AP int code 
The code returned from script evaluation.
.AP Tcl_Obj *options
A dictionary of return options.
.AP char *message in
For \fBTcl_AddErrorInfo\fR,
this is a conventional C string to append to the \fB\-errorinfo\fR return option.
For \fBTcl_AddObjErrorInfo\fR,
this points to the first byte of an array of \fIlength\fR bytes
containing a string to append to the \fB\-errorinfo\fR return option.
This byte array may contain embedded null bytes
unless \fIlength\fR is negative.
.VS 8.5
.AP Tcl_Obj *objPtr in
A message to be appended to the \fB\-errorinfo\fR return option
in the form of a Tcl_Obj value.
.VE 8.5
.AP int length in
The number of bytes to copy from \fImessage\fR when
appending to the \fB\-errorinfo\fR return option.
If negative, all bytes up to the first null byte are used.
.AP Tcl_Obj *errorObjPtr in
The \fB\-errorcode\fR return option will be set to this value.
.AP char *element in
String to record as one element of the \fB\-errorcode\fR return option.
Last \fIelement\fR argument must be NULL.
.AP va_list argList in
An argument list which must have been initialized using
\fBva_start\fR, and cleared using \fBva_end\fR.
.AP "const char" *script in
Pointer to first character in script containing command (must be <= command)
.AP "const char" *command in
Pointer to first character in command that generated the error
.AP int commandLength in
Number of bytes in command; -1 means use all bytes up to first null byte
.BE

.SH DESCRIPTION
.PP
.VS 8.5
The \fBTcl_SetReturnOptions\fR and \fBTcl_GetReturnOptions\fR
routines expose the same capabilities as the \fBreturn\fR and
\fBcatch\fR commands, respectively, in the form of a C interface.
.PP
\fBTcl_GetReturnOptions\fR retrieves the dictionary of return options
from an interpreter following a script evaluation.
Routines such as \fBTcl_Eval\fR are called to evaluate a
script in an interpreter.  These routines return an integer
completion code.  These routines also leave in the interpreter
both a result and a dictionary of return options generated
by script evaluation.  Just as \fBTcl_GetObjResult\fR retrieves
the result, \fBTcl_GetReturnOptions\fR retrieves the dictionary
of return options.  The integer completion code should be
passed as the \fIcode\fR argument to \fBTcl_GetReturnOptions\fR
so that all required options will be present in the dictionary.
Specifically, a \fIcode\fR value of \fBTCL_ERROR\fR will
ensure that entries for the keys \fB\-errorinfo\fR,
\fB\-errorcode\fR, and \fB\-errorline\fR will appear in the
dictionary.  Also, the entries for the keys \fB\-code\fR
and \fB\-level\fR will be adjusted if necessary to agree
with the value of \fIcode\fR.  The \fB(Tcl_Obj *)\fR returned
by \fBTcl_GetReturnOptions\fR points to an unshared
\fBTcl_Obj\fR with reference count of zero.  The dictionary
may be written to, either adding, removing, or overwriting
any entries in it, with the need to check for a shared object.
.PP
A typical usage for \fBTcl_GetReturnOptions\fR is to
retrieve the stack trace when script evaluation returns
\fBTCL_ERROR\fR, like so:
.CS
int code = Tcl_Eval(interp, script);
if (code == TCL_ERROR) {
    Tcl_Obj *options = Tcl_GetReturnOptions(interp, code);  
    Tcl_Obj *key = Tcl_NewStringObj("-errorinfo", -1);
    Tcl_Obj *stackTrace;
    Tcl_IncrRefCount(key);
    Tcl_DictObjGet(NULL, options, key, &stackTrace);
    Tcl_DecrRefCount(key);
    /* Do something with stackTrace */
}
.CE
.PP
\fBTcl_SetReturnOptions\fR sets the return options
of \fIinterp\fR to be \fIoptions\fR.  If \fIoptions\fR
contains any invalid value for any key, TCL_ERROR will
be returned, and the interp result will be set to an
appropriate error message.  Otherwise, a completion code
in agreement with the \fB\-code\fR and \fB\-level\fR
keys in \fIoptions\fR will be returned.
.PP
As an example, Tcl's \fBreturn\fR command itself could
be implemented in terms of \fBTcl_SetReturnOptions\fR
like so:
.CS
if ((objc % 2) == 0) { /* explicit result argument */
    objc--;
    Tcl_SetObjResult(interp, objv[objc]);
}
return Tcl_SetReturnOptions(interp, Tcl_NewListObj(objc-1, objv+1));
.CE
(It is not really implemented that way.  Internal access
privileges allow for a more efficient alternative that meshes
better with the bytecode compiler.)
.PP
Note that a newly created \fBTcl_Obj\fR may be passed
in as the \fIoptions\fR argument without the need to tend
to any reference counting.  This is analogous to
\fBTcl_SetObjResult\fR.
.PP
While \fBTcl_SetReturnOptions\fR provides a general interface
to set any collection of return options, there are a handful
of return options that are very frequently used.  Most 
notably the \fB\-errorinfo\fR and \fB\-errorcode\fR return
options should be set properly when the command procedure
of a command returns \fBTCL_ERROR\fR.  Tcl provides several
simpler interfaces to more directly set these return options.
.VE 8.5
.PP
The \fB\-errorinfo\fR option holds a stack trace of the
operations that were in progress when an error occurred,
and is intended to be human-readable.
The \fB\-errorcode\fR option holds a list of items that
are intended to be machine-readable.
The first item in the \fB\-errorcode\fR value identifies the class of
error that occurred
(e.g. POSIX means an error occurred in a POSIX system call)
and additional elements hold additional pieces
of information that depend on the class.
See the tclvars manual entry for details on the various
formats for the \fB\-errorcode\fR option used by
Tcl's built-in commands.
.PP
The \fB\-errorinfo\fR option value is gradually built up as an
error unwinds through the nested operations.
Each time an error code is returned to \fBTcl_Eval\fR, or
any of the routines that performs script evaluation,
the procedure \fBTcl_AddErrorInfo\fR is called to add
additional text to the \fB\-errorinfo\fR value describing the
command that was being executed when the error occurred.
By the time the error has been passed all the way back
to the application, it will contain a complete trace
of the activity in progress when the error occurred.
.PP
It is sometimes useful to add additional information to
the \fB\-errorinfo\fR value beyond what can be supplied automatically
by the script evaluation routines.
\fBTcl_AddErrorInfo\fR may be used for this purpose:
its \fImessage\fR argument is an additional
string to be appended to the \fB\-errorinfo\fR option.
For example, when an error arises during the \fBsource\fR command,
the procedure \fBTcl_AddErrorInfo\fR is called to
record the name of the file being processed and the
line number on which the error occurred.
Likewise, when an error arises during evaluation of a
Tcl procedures, the procedure name and line number
within the procedure are recorded, and so on.
The best time to call \fBTcl_AddErrorInfo\fR is just after
a script evaluation routine has returned \fBTCL_ERROR\fR.
The value of the \fB\-errorline\fR return option (retrieved
via a call to \fBTcl_GetReturnOptions\fR) often makes up
a useful part of the \fImessage\fR passed to \fBTcl_AddErrorInfo\fR.
.PP
.VS 8.5
\fBTcl_AppendObjToErrorInfo\fR is an alternative interface to the
same functionality as \fBTcl_AddErrorInfo\fR.  \fBTcl_AppendObjToErrorInfo\fR
is called when the string value to be appended to the \fB\-errorinfo\fR option
is available as a \fBTcl_Obj\fR instead of as a \fBchar\fR array.
.VE 8.5
.PP
\fBTcl_AddObjErrorInfo\fR is nearly identical
to \fBTcl_AddErrorInfo\fR, except that it has an additional \fIlength\fR
argument.  This allows the \fImessage\fR string to contain 
embedded null bytes.  This is essentially never a good idea.
If the \fImessage\fR needs to contain the null character \fBU+0000\fR,
Tcl's usual internal encoding rules should be used to avoid
the need for a null byte.  If the \fBTcl_AddObjErrorInfo\fR
interface is used at all, it should be with a negative \fIlength\fR value.
.PP
The procedure \fBTcl_SetObjErrorCode\fR is used to set the
\fB\-errorcode\fR return option to the list object \fIerrorObjPtr\fR 
built up by the caller. 
\fBTcl_SetObjErrorCode\fR is typically invoked just 
before returning an error. If an error is
returned without calling \fBTcl_SetObjErrorCode\fR or
\fBTcl_SetErrorCode\fR the Tcl interpreter automatically sets
the \fB\-errorcode\fR return option to \fBNONE\fR.
.PP
The procedure \fBTcl_SetErrorCode\fR is also used to set the
\fB\-errorcode\fR return option. However, it takes one or more strings to
record instead of an object. Otherwise, it is similar to
\fBTcl_SetObjErrorCode\fR in behavior.
.PP
\fBTcl_SetErrorCodeVA\fR is the same as \fBTcl_SetErrorCode\fR except that
instead of taking a variable number of arguments it takes an argument list.
.PP
\fBTcl_PosixError\fR
sets the \fB\-errorcode\fR variable after an error in a POSIX kernel call.
It reads the value of the \fBerrno\fR C variable and calls
\fBTcl_SetErrorCode\fR to set the \fB\-errorcode\fR return
option in the \fBPOSIX\fR format.
The caller must previously have called \fBTcl_SetErrno\fR to set
\fBerrno\fR; this is necessary on some platforms (e.g. Windows) where Tcl
is linked into an application as a shared library, or when the error
occurs in a dynamically loaded extension. See the manual entry for
\fBTcl_SetErrno\fR for more information.
.PP
\fBTcl_PosixError\fR returns a human-readable diagnostic message
for the error
(this is the same value that will appear as the third element
in the \fB\-errorcode\fR value).
It may be convenient to include this string as part of the
error message returned to the application in
the interpreter's result.
.PP
\fBTcl_LogCommandInfo\fR is invoked after an error occurs in an
interpreter.  It adds information about the command that was being
executed when the error occurred to the \fB\-errorinfo\fR value, and
the line number stored internally in the interpreter is set.  
.PP
In older releases of Tcl, there was no \fBTcl_GetReturnOptions\fR
routine.  In its place, the global Tcl variables \fBerrorInfo\fR
and \fBerrorCode\fR were the only place to retrieve the error
information.  Much existing code written for older Tcl releases
still access this information via those global variables.
.PP
It is important to realize that while reading from those
global variables remains a supported way to access these
return option values, it is important not to assume that
writing to those global variables will properly set the
corresponding return options.  It has long been emphasized
in this manual page that it is important to 
call the procedures described here rather than
setting \fBerrorInfo\fR or \fBerrorCode\fR directly with
\fBTcl_ObjSetVar2\fR.
.PP
If the procedure \fBTcl_ResetResult\fR is called,
it clears all of the state of the interpreter associated with
script evaluation, including the entire return options dictionary.
In particular, the \fB\-errorinfo\fR and \fB\-errorcode\fR options
are reset.  
If an error had occurred, the \fBTcl_ResetResult\fR call will
clear the error state to make it appear as if no error had
occurred after all.
The global variables \fBerrorInfo\fR and
\fBerrorCode\fR are not modified by \fBTcl_ResetResult\fR
so they continue to hold a record of information about the
most recent error seen in an interpreter.

.SH "SEE ALSO"
Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_Interp, Tcl_ResetResult, Tcl_SetErrno

.SH KEYWORDS
error, object, object result, stack, trace, variable
                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AddObjErrorInfo.3tcl                     0100644 0001750 0001750 00000044431 12566232322 025223  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: AddErrInfo.3,v 1.20 2007/12/13 15:22:30 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_AddErrorInfo 3 8.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_GetReturnOptions, Tcl_SetReturnOptions, Tcl_AddErrorInfo, Tcl_AppendObjToErrorInfo, Tcl_AddObjErrorInfo, Tcl_SetObjErrorCode, Tcl_SetErrorCode, Tcl_SetErrorCodeVA, Tcl_PosixError, Tcl_LogCommandInfo \- retrieve or record information about errors and other return options
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.VS 8.5
.sp
Tcl_Obj *
\fBTcl_GetReturnOptions\fR(\fIinterp, code\fR)
.sp
int 
\fBTcl_SetReturnOptions\fR(\fIinterp, options\fR)
.VE 8.5
.sp
\fBTcl_AddErrorInfo\fR(\fIinterp, message\fR)
.VS 8.5
.sp
\fBTcl_AppendObjToErrorInfo\fR(\fIinterp, objPtr\fR)
.VE 8.5
.sp
\fBTcl_AddObjErrorInfo\fR(\fIinterp, message, length\fR)
.sp
\fBTcl_SetObjErrorCode\fR(\fIinterp, errorObjPtr\fR)
.sp
\fBTcl_SetErrorCode\fR(\fIinterp, element, element, ... \fB(char *) NULL\fR)
.sp
\fBTcl_SetErrorCodeVA\fR(\fIinterp, argList\fR)
.sp
const char *
\fBTcl_PosixError\fR(\fIinterp\fR)
.sp
void
\fBTcl_LogCommandInfo\fR(\fIinterp, script, command, commandLength\fR)
.SH ARGUMENTS
.AS Tcl_Interp commandLength
.AP Tcl_Interp *interp in
Interpreter in which to record information.
.AP int code 
The code returned from script evaluation.
.AP Tcl_Obj *options
A dictionary of return options.
.AP char *message in
For \fBTcl_AddErrorInfo\fR,
this is a conventional C string to append to the \fB\-errorinfo\fR return option.
For \fBTcl_AddObjErrorInfo\fR,
this points to the first byte of an array of \fIlength\fR bytes
containing a string to append to the \fB\-errorinfo\fR return option.
This byte array may contain embedded null bytes
unless \fIlength\fR is negative.
.VS 8.5
.AP Tcl_Obj *objPtr in
A message to be appended to the \fB\-errorinfo\fR return option
in the form of a Tcl_Obj value.
.VE 8.5
.AP int length in
The number of bytes to copy from \fImessage\fR when
appending to the \fB\-errorinfo\fR return option.
If negative, all bytes up to the first null byte are used.
.AP Tcl_Obj *errorObjPtr in
The \fB\-errorcode\fR return option will be set to this value.
.AP char *element in
String to record as one element of the \fB\-errorcode\fR return option.
Last \fIelement\fR argument must be NULL.
.AP va_list argList in
An argument list which must have been initialized using
\fBva_start\fR, and cleared using \fBva_end\fR.
.AP "const char" *script in
Pointer to first character in script containing command (must be <= command)
.AP "const char" *command in
Pointer to first character in command that generated the error
.AP int commandLength in
Number of bytes in command; -1 means use all bytes up to first null byte
.BE

.SH DESCRIPTION
.PP
.VS 8.5
The \fBTcl_SetReturnOptions\fR and \fBTcl_GetReturnOptions\fR
routines expose the same capabilities as the \fBreturn\fR and
\fBcatch\fR commands, respectively, in the form of a C interface.
.PP
\fBTcl_GetReturnOptions\fR retrieves the dictionary of return options
from an interpreter following a script evaluation.
Routines such as \fBTcl_Eval\fR are called to evaluate a
script in an interpreter.  These routines return an integer
completion code.  These routines also leave in the interpreter
both a result and a dictionary of return options generated
by script evaluation.  Just as \fBTcl_GetObjResult\fR retrieves
the result, \fBTcl_GetReturnOptions\fR retrieves the dictionary
of return options.  The integer completion code should be
passed as the \fIcode\fR argument to \fBTcl_GetReturnOptions\fR
so that all required options will be present in the dictionary.
Specifically, a \fIcode\fR value of \fBTCL_ERROR\fR will
ensure that entries for the keys \fB\-errorinfo\fR,
\fB\-errorcode\fR, and \fB\-errorline\fR will appear in the
dictionary.  Also, the entries for the keys \fB\-code\fR
and \fB\-level\fR will be adjusted if necessary to agree
with the value of \fIcode\fR.  The \fB(Tcl_Obj *)\fR returned
by \fBTcl_GetReturnOptions\fR points to an unshared
\fBTcl_Obj\fR with reference count of zero.  The dictionary
may be written to, either adding, removing, or overwriting
any entries in it, with the need to check for a shared object.
.PP
A typical usage for \fBTcl_GetReturnOptions\fR is to
retrieve the stack trace when script evaluation returns
\fBTCL_ERROR\fR, like so:
.CS
int code = Tcl_Eval(interp, script);
if (code == TCL_ERROR) {
    Tcl_Obj *options = Tcl_GetReturnOptions(interp, code);  
    Tcl_Obj *key = Tcl_NewStringObj("-errorinfo", -1);
    Tcl_Obj *stackTrace;
    Tcl_IncrRefCount(key);
    Tcl_DictObjGet(NULL, options, key, &stackTrace);
    Tcl_DecrRefCount(key);
    /* Do something with stackTrace */
}
.CE
.PP
\fBTcl_SetReturnOptions\fR sets the return options
of \fIinterp\fR to be \fIoptions\fR.  If \fIoptions\fR
contains any invalid value for any key, TCL_ERROR will
be returned, and the interp result will be set to an
appropriate error message.  Otherwise, a completion code
in agreement with the \fB\-code\fR and \fB\-level\fR
keys in \fIoptions\fR will be returned.
.PP
As an example, Tcl's \fBreturn\fR command itself could
be implemented in terms of \fBTcl_SetReturnOptions\fR
like so:
.CS
if ((objc % 2) == 0) { /* explicit result argument */
    objc--;
    Tcl_SetObjResult(interp, objv[objc]);
}
return Tcl_SetReturnOptions(interp, Tcl_NewListObj(objc-1, objv+1));
.CE
(It is not really implemented that way.  Internal access
privileges allow for a more efficient alternative that meshes
better with the bytecode compiler.)
.PP
Note that a newly created \fBTcl_Obj\fR may be passed
in as the \fIoptions\fR argument without the need to tend
to any reference counting.  This is analogous to
\fBTcl_SetObjResult\fR.
.PP
While \fBTcl_SetReturnOptions\fR provides a general interface
to set any collection of return options, there are a handful
of return options that are very frequently used.  Most 
notably the \fB\-errorinfo\fR and \fB\-errorcode\fR return
options should be set properly when the command procedure
of a command returns \fBTCL_ERROR\fR.  Tcl provides several
simpler interfaces to more directly set these return options.
.VE 8.5
.PP
The \fB\-errorinfo\fR option holds a stack trace of the
operations that were in progress when an error occurred,
and is intended to be human-readable.
The \fB\-errorcode\fR option holds a list of items that
are intended to be machine-readable.
The first item in the \fB\-errorcode\fR value identifies the class of
error that occurred
(e.g. POSIX means an error occurred in a POSIX system call)
and additional elements hold additional pieces
of information that depend on the class.
See the tclvars manual entry for details on the various
formats for the \fB\-errorcode\fR option used by
Tcl's built-in commands.
.PP
The \fB\-errorinfo\fR option value is gradually built up as an
error unwinds through the nested operations.
Each time an error code is returned to \fBTcl_Eval\fR, or
any of the routines that performs script evaluation,
the procedure \fBTcl_AddErrorInfo\fR is called to add
additional text to the \fB\-errorinfo\fR value describing the
command that was being executed when the error occurred.
By the time the error has been passed all the way back
to the application, it will contain a complete trace
of the activity in progress when the error occurred.
.PP
It is sometimes useful to add additional information to
the \fB\-errorinfo\fR value beyond what can be supplied automatically
by the script evaluation routines.
\fBTcl_AddErrorInfo\fR may be used for this purpose:
its \fImessage\fR argument is an additional
string to be appended to the \fB\-errorinfo\fR option.
For example, when an error arises during the \fBsource\fR command,
the procedure \fBTcl_AddErrorInfo\fR is called to
record the name of the file being processed and the
line number on which the error occurred.
Likewise, when an error arises during evaluation of a
Tcl procedures, the procedure name and line number
within the procedure are recorded, and so on.
The best time to call \fBTcl_AddErrorInfo\fR is just after
a script evaluation routine has returned \fBTCL_ERROR\fR.
The value of the \fB\-errorline\fR return option (retrieved
via a call to \fBTcl_GetReturnOptions\fR) often makes up
a useful part of the \fImessage\fR passed to \fBTcl_AddErrorInfo\fR.
.PP
.VS 8.5
\fBTcl_AppendObjToErrorInfo\fR is an alternative interface to the
same functionality as \fBTcl_AddErrorInfo\fR.  \fBTcl_AppendObjToErrorInfo\fR
is called when the string value to be appended to the \fB\-errorinfo\fR option
is available as a \fBTcl_Obj\fR instead of as a \fBchar\fR array.
.VE 8.5
.PP
\fBTcl_AddObjErrorInfo\fR is nearly identical
to \fBTcl_AddErrorInfo\fR, except that it has an additional \fIlength\fR
argument.  This allows the \fImessage\fR string to contain 
embedded null bytes.  This is essentially never a good idea.
If the \fImessage\fR needs to contain the null character \fBU+0000\fR,
Tcl's usual internal encoding rules should be used to avoid
the need for a null byte.  If the \fBTcl_AddObjErrorInfo\fR
interface is used at all, it should be with a negative \fIlength\fR value.
.PP
The procedure \fBTcl_SetObjErrorCode\fR is used to set the
\fB\-errorcode\fR return option to the list object \fIerrorObjPtr\fR 
built up by the caller. 
\fBTcl_SetObjErrorCode\fR is typically invoked just 
before returning an error. If an error is
returned without calling \fBTcl_SetObjErrorCode\fR or
\fBTcl_SetErrorCode\fR the Tcl interpreter automatically sets
the \fB\-errorcode\fR return option to \fBNONE\fR.
.PP
The procedure \fBTcl_SetErrorCode\fR is also used to set the
\fB\-errorcode\fR return option. However, it takes one or more strings to
record instead of an object. Otherwise, it is similar to
\fBTcl_SetObjErrorCode\fR in behavior.
.PP
\fBTcl_SetErrorCodeVA\fR is the same as \fBTcl_SetErrorCode\fR except that
instead of taking a variable number of arguments it takes an argument list.
.PP
\fBTcl_PosixError\fR
sets the \fB\-errorcode\fR variable after an error in a POSIX kernel call.
It reads the value of the \fBerrno\fR C variable and calls
\fBTcl_SetErrorCode\fR to set the \fB\-errorcode\fR return
option in the \fBPOSIX\fR format.
The caller must previously have called \fBTcl_SetErrno\fR to set
\fBerrno\fR; this is necessary on some platforms (e.g. Windows) where Tcl
is linked into an application as a shared library, or when the error
occurs in a dynamically loaded extension. See the manual entry for
\fBTcl_SetErrno\fR for more information.
.PP
\fBTcl_PosixError\fR returns a human-readable diagnostic message
for the error
(this is the same value that will appear as the third element
in the \fB\-errorcode\fR value).
It may be convenient to include this string as part of the
error message returned to the application in
the interpreter's result.
.PP
\fBTcl_LogCommandInfo\fR is invoked after an error occurs in an
interpreter.  It adds information about the command that was being
executed when the error occurred to the \fB\-errorinfo\fR value, and
the line number stored internally in the interpreter is set.  
.PP
In older releases of Tcl, there was no \fBTcl_GetReturnOptions\fR
routine.  In its place, the global Tcl variables \fBerrorInfo\fR
and \fBerrorCode\fR were the only place to retrieve the error
information.  Much existing code written for older Tcl releases
still access this information via those global variables.
.PP
It is important to realize that while reading from those
global variables remains a supported way to access these
return option values, it is important not to assume that
writing to those global variables will properly set the
corresponding return options.  It has long been emphasized
in this manual page that it is important to 
call the procedures described here rather than
setting \fBerrorInfo\fR or \fBerrorCode\fR directly with
\fBTcl_ObjSetVar2\fR.
.PP
If the procedure \fBTcl_ResetResult\fR is called,
it clears all of the state of the interpreter associated with
script evaluation, including the entire return options dictionary.
In particular, the \fB\-errorinfo\fR and \fB\-errorcode\fR options
are reset.  
If an error had occurred, the \fBTcl_ResetResult\fR call will
clear the error state to make it appear as if no error had
occurred after all.
The global variables \fBerrorInfo\fR and
\fBerrorCode\fR are not modified by \fBTcl_ResetResult\fR
so they continue to hold a record of information about the
most recent error seen in an interpreter.

.SH "SEE ALSO"
Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_Interp, Tcl_ResetResult, Tcl_SetErrno

.SH KEYWORDS
error, object, object result, stack, trace, variable
                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AlertNotifier.3tcl                       0100644 0001750 0001750 00000105436 12566232341 025025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1998-1999 Scriptics Corporation
'\" Copyright (c) 1995-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Notifier.3,v 1.21 2007/12/13 15:22:31 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Notifier 3 8.1 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_CreateEventSource, Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent, Tcl_ThreadAlert, Tcl_GetCurrentThread, Tcl_DeleteEvents, Tcl_InitNotifier, Tcl_FinalizeNotifier, Tcl_WaitForEvent, Tcl_AlertNotifier, Tcl_SetTimer, Tcl_ServiceAll, Tcl_ServiceEvent, Tcl_GetServiceMode, Tcl_SetServiceMode \- the event queue and notifier interfaces
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
void
\fBTcl_CreateEventSource\fR(\fIsetupProc, checkProc, clientData\fR)
.sp
void
\fBTcl_DeleteEventSource\fR(\fIsetupProc, checkProc, clientData\fR)
.sp
void
\fBTcl_SetMaxBlockTime\fR(\fItimePtr\fR)
.sp
void
\fBTcl_QueueEvent\fR(\fIevPtr, position\fR)
.sp
void
\fBTcl_ThreadQueueEvent\fR(\fIthreadId, evPtr, position\fR)
.sp
void
\fBTcl_ThreadAlert\fR(\fIthreadId\fR)
.sp
Tcl_ThreadId
\fBTcl_GetCurrentThread\fR()
.sp
void
\fBTcl_DeleteEvents\fR(\fIdeleteProc, clientData\fR)
.sp
ClientData
\fBTcl_InitNotifier\fR()
.sp
void
\fBTcl_FinalizeNotifier\fR(\fIclientData\fR)
.sp
int
\fBTcl_WaitForEvent\fR(\fItimePtr\fR)
.sp
void
\fBTcl_AlertNotifier\fR(\fIclientData\fR)
.sp
void
\fBTcl_SetTimer\fR(\fItimePtr\fR)
.sp
int
\fBTcl_ServiceAll\fR()
.sp
int
\fBTcl_ServiceEvent\fR(\fIflags\fR)
.sp
int
\fBTcl_GetServiceMode\fR()
.sp
int
\fBTcl_SetServiceMode\fR(\fImode\fR)
.sp
void
\fBTcl_ServiceModeHook\fR(\fImode\fR)
.sp
void
\fBTcl_SetNotifier\fR(\fInotifierProcPtr\fR)
.SH ARGUMENTS
.AS Tcl_EventDeleteProc *notifierProcPtr
.AP Tcl_EventSetupProc *setupProc in
Procedure to invoke to prepare for event wait in \fBTcl_DoOneEvent\fR.
.AP Tcl_EventCheckProc *checkProc in
Procedure for \fBTcl_DoOneEvent\fR to invoke after waiting for
events.  Checks to see if any events have occurred and, if so,
queues them.
.AP ClientData clientData in
Arbitrary one-word value to pass to \fIsetupProc\fR, \fIcheckProc\fR, or
\fIdeleteProc\fR.
.AP Tcl_Time *timePtr in
Indicates the maximum amount of time to wait for an event.  This
is specified as an interval (how long to wait), not an absolute
time (when to wakeup).  If the pointer passed to \fBTcl_WaitForEvent\fR
is NULL, it means there is no maximum wait time:  wait forever if
necessary.
.AP Tcl_Event *evPtr in
An event to add to the event queue.  The storage for the event must
have been allocated by the caller using \fBTcl_Alloc\fR or \fBckalloc\fR.
.AP Tcl_QueuePosition position in
Where to add the new event in the queue:  \fBTCL_QUEUE_TAIL\fR,
\fBTCL_QUEUE_HEAD\fR, or \fBTCL_QUEUE_MARK\fR.
.AP Tcl_ThreadId threadId in
A unique identifier for a thread.
.AP Tcl_EventDeleteProc *deleteProc in
Procedure to invoke for each queued event in \fBTcl_DeleteEvents\fR.
.AP int flags in
What types of events to service.  These flags are the same as those
passed to \fBTcl_DoOneEvent\fR.
.AP int mode in
Indicates whether events should be serviced by \fBTcl_ServiceAll\fR.
Must be one of \fBTCL_SERVICE_NONE\fR or \fBTCL_SERVICE_ALL\fR.
.AP Tcl_NotifierProcs* notifierProcPtr in
Structure of function pointers describing notifier procedures that are
to replace the ones installed in the executable.  See
\fBREPLACING THE NOTIFIER\fR for details.
.BE

.SH INTRODUCTION
.PP
The interfaces described here are used to customize the Tcl event
loop.  The two most common customizations are to add new sources of
events and to merge Tcl's event loop with some other event loop, such
as one provided by an application in which Tcl is embedded.  Each of
these tasks is described in a separate section below.
.PP
The procedures in this manual entry are the building blocks out of which
the Tcl event notifier is constructed.  The event notifier is the lowest
layer in the Tcl event mechanism.  It consists of three things:
.IP [1]
Event sources: these represent the ways in which events can be
generated.  For example, there is a timer event source that implements
the \fBTcl_CreateTimerHandler\fR procedure and the \fBafter\fR
command, and there is a file event source that implements the
\fBTcl_CreateFileHandler\fR procedure on Unix systems.  An event
source must work with the notifier to detect events at the right
times, record them on the event queue, and eventually notify
higher-level software that they have occurred.  The procedures
\fBTcl_CreateEventSource\fR, \fBTcl_DeleteEventSource\fR,
and \fBTcl_SetMaxBlockTime\fR, \fBTcl_QueueEvent\fR, and
\fBTcl_DeleteEvents\fR are used primarily by event sources.
.IP [2]
The event queue: for non-threaded applications,
there is a single queue for the whole application,
containing events that have been detected but not yet serviced.  Event
sources place events onto the queue so that they may be processed in
order at appropriate times during the event loop. The event queue
guarantees a fair discipline of event handling, so that no event
source can starve the others.  It also allows events to be saved for
servicing at a future time.  Threaded applications work in a
similar manner, except that there is a separate event queue for
each thread containing a Tcl interpreter.
\fBTcl_QueueEvent\fR is used (primarily
by event sources) to add events to the event queue and 
\fBTcl_DeleteEvents\fR is used to remove events from the queue without
processing them.  In a threaded application, \fBTcl_QueueEvent\fR adds
an event to the current thread's queue, and \fBTcl_ThreadQueueEvent\fR
adds an event to a queue in a specific thread.
.IP [3]
The event loop: in order to detect and process events, the application
enters a loop that waits for events to occur, places them on the event
queue, and then processes them.  Most applications will do this by
calling the procedure \fBTcl_DoOneEvent\fR, which is described in a
separate manual entry.
.PP
Most Tcl applications need not worry about any of the internals of
the Tcl notifier.  However, the notifier now has enough flexibility
to be retargeted either for a new platform or to use an external event
loop (such as the Motif event loop, when Tcl is embedded in a Motif
application).  The procedures \fBTcl_WaitForEvent\fR and
\fBTcl_SetTimer\fR are normally implemented by Tcl, but may be
replaced with new versions to retarget the notifier (the
\fBTcl_InitNotifier\fR, \fBTcl_AlertNotifier\fR,
\fBTcl_FinalizeNotifier\fR, \fBTcl_Sleep\fR,
\fBTcl_CreateFileHandler\fR, and \fBTcl_DeleteFileHandler\fR must
also be replaced; see CREATING A NEW NOTIFIER below for details).
The procedures \fBTcl_ServiceAll\fR, \fBTcl_ServiceEvent\fR,
\fBTcl_GetServiceMode\fR, and \fBTcl_SetServiceMode\fR are provided
to help connect Tcl's event loop to an external event loop such as
Motif's.
.SH "NOTIFIER BASICS"
.PP
The easiest way to understand how the notifier works is to consider
what happens when \fBTcl_DoOneEvent\fR is called.
\fBTcl_DoOneEvent\fR is passed a \fIflags\fR argument that indicates
what sort of events it is OK to process and also whether or not to
block if no events are ready.  \fBTcl_DoOneEvent\fR does the following
things:
.IP [1]
Check the event queue to see if it contains any events that can
be serviced.  If so, service the first possible event, remove it
from the queue, and return.  It does this by calling
\fBTcl_ServiceEvent\fR and passing in the \fIflags\fR argument.
.IP [2]
Prepare to block for an event.  To do this, \fBTcl_DoOneEvent\fR
invokes a \fIsetup procedure\fR in each event source.
The event source will perform event-source specific initialization and
possibly call \fBTcl_SetMaxBlockTime\fR to limit how long
\fBTcl_WaitForEvent\fR will block if no new events occur.
.IP [3]
Call \fBTcl_WaitForEvent\fR.  This procedure is implemented differently
on different platforms;  it waits for an event to occur, based on the
information provided by the event sources.
It may cause the application to block if \fItimePtr\fR specifies
an interval other than 0.
\fBTcl_WaitForEvent\fR returns when something has happened,
such as a file becoming readable or the interval given by \fItimePtr\fR
expiring.  If there are no events for \fBTcl_WaitForEvent\fR to
wait for, so that it would block forever, then it returns immediately
and \fBTcl_DoOneEvent\fR returns 0.
.IP [4]
Call a \fIcheck procedure\fR in each event source.  The check
procedure determines whether any events of interest to this source
occurred.  If so, the events are added to the event queue.
.IP [5]
Check the event queue to see if it contains any events that can
be serviced.  If so, service the first possible event, remove it
from the queue, and return.
.IP [6]
See if there are idle callbacks pending. If so, invoke all of them and
return.
.IP [7]
Either return 0 to indicate that no events were ready, or go back to
step [2] if blocking was requested by the caller.

.SH "CREATING A NEW EVENT SOURCE"
.PP
An event source consists of three procedures invoked by the notifier,
plus additional C procedures that are invoked by higher-level code
to arrange for event-driven callbacks.  The three procedures called
by the notifier consist of the setup and check procedures described
above, plus an additional procedure that is invoked when an event
is removed from the event queue for servicing.
.PP
The procedure \fBTcl_CreateEventSource\fR creates a new event source.
Its arguments specify the setup procedure and check procedure for
the event source.
\fISetupProc\fR should match the following prototype:
.CS
typedef void Tcl_EventSetupProc(
        ClientData \fIclientData\fR,
        int \fIflags\fR);
.CE
The \fIclientData\fR argument will be the same as the \fIclientData\fR
argument to \fBTcl_CreateEventSource\fR;  it is typically used to
point to private information managed by the event source.
The \fIflags\fR argument will be the same as the \fIflags\fR
argument passed to \fBTcl_DoOneEvent\fR except that it will never
be 0 (\fBTcl_DoOneEvent\fR replaces 0 with \fBTCL_ALL_EVENTS\fR).
\fIFlags\fR indicates what kinds of events should be considered;
if the bit corresponding to this event source is not set, the event
source should return immediately without doing anything.  For
example, the file event source checks for the \fBTCL_FILE_EVENTS\fR
bit.
.PP
\fISetupProc\fR's job is to make sure that the application wakes up
when events of the desired type occur.  This is typically done in a
platform-dependent fashion.  For example, under Unix an event source
might call \fBTcl_CreateFileHandler\fR; under Windows it might
request notification with a Windows event.  For timer-driven event
sources such as timer events or any polled event, the event source
can call \fBTcl_SetMaxBlockTime\fR to force the application to wake
up after a specified time even if no events have occurred.
If no event source calls \fBTcl_SetMaxBlockTime\fR
then \fBTcl_WaitForEvent\fR will wait as long as necessary for an
event to occur; otherwise, it will only wait as long as the shortest
interval passed to \fBTcl_SetMaxBlockTime\fR by one of the event
sources.  If an event source knows that it already has events ready to
report, it can request a zero maximum block time.  For example, the
setup procedure for the X event source looks to see if there are
events already queued.  If there are, it calls
\fBTcl_SetMaxBlockTime\fR with a 0 block time so that
\fBTcl_WaitForEvent\fR does not block if there is no new data on the X
connection.
The \fItimePtr\fR argument to \fBTcl_WaitForEvent\fR points to
a structure that describes a time interval in seconds and
microseconds:
.CS
typedef struct Tcl_Time {
        long \fIsec\fR;
        long \fIusec\fR;
} Tcl_Time;
.CE
The \fIusec\fR field should be less than 1000000.
.PP
Information provided to \fBTcl_SetMaxBlockTime\fR
is only used for the next call to \fBTcl_WaitForEvent\fR; it is
discarded after \fBTcl_WaitForEvent\fR returns.
The next time an event wait is done each of the event sources'
setup procedures will be called again, and they can specify new
information for that event wait.
.PP
If the application uses an external event loop rather than
\fBTcl_DoOneEvent\fR, the event sources may need to call
\fBTcl_SetMaxBlockTime\fR at other times.  For example, if a new event
handler is registered that needs to poll for events, the event source
may call \fBTcl_SetMaxBlockTime\fR to set the block time to zero to
force the external event loop to call Tcl.  In this case,
\fBTcl_SetMaxBlockTime\fR invokes \fBTcl_SetTimer\fR with the shortest
interval seen since the last call to \fBTcl_DoOneEvent\fR or
\fBTcl_ServiceAll\fR.
.PP
In addition to the generic procedure \fBTcl_SetMaxBlockTime\fR, other
platform-specific procedures may also be available for
\fIsetupProc\fR, if there is additional information needed by
\fBTcl_WaitForEvent\fR on that platform.  For example, on Unix systems
the \fBTcl_CreateFileHandler\fR interface can be used to wait for file events.
.PP
The second procedure provided by each event source is its check
procedure, indicated by the \fIcheckProc\fR argument to
\fBTcl_CreateEventSource\fR.  \fICheckProc\fR must match the
following prototype:
.CS
typedef void Tcl_EventCheckProc(
        ClientData \fIclientData\fR,
        int \fIflags\fR);
.CE
The arguments to this procedure are the same as those for \fIsetupProc\fR.
\fBCheckProc\fR is invoked by \fBTcl_DoOneEvent\fR after it has waited
for events.  Presumably at least one event source is now prepared to
queue an event.  \fBTcl_DoOneEvent\fR calls each of the event sources
in turn, so they all have a chance to queue any events that are ready.
The check procedure does two things.  First, it must see if any events
have triggered.  Different event sources do this in different ways.
.PP
If an event source's check procedure detects an interesting event, it
must add the event to Tcl's event queue.  To do this, the event source
calls \fBTcl_QueueEvent\fR.  The \fIevPtr\fR argument is a pointer to
a dynamically allocated structure containing the event (see below for
more information on memory management issues).  Each event source can
define its own event structure with whatever information is relevant
to that event source.  However, the first element of the structure
must be a structure of type \fBTcl_Event\fR, and the address of this
structure is used when communicating between the event source and the
rest of the notifier.  A \fBTcl_Event\fR has the following definition:
.CS
typedef struct {
    Tcl_EventProc *\fIproc\fR;
    struct Tcl_Event *\fInextPtr\fR;
} Tcl_Event;
.CE
The event source must fill in the \fIproc\fR field of
the event before calling \fBTcl_QueueEvent\fR.
The \fInextPtr\fR is used to link together the events in the queue
and should not be modified by the event source.
.PP
An event may be added to the queue at any of three positions, depending
on the \fIposition\fR argument to \fBTcl_QueueEvent\fR:
.IP \fBTCL_QUEUE_TAIL\fR 24
Add the event at the back of the queue, so that all other pending
events will be serviced first.  This is almost always the right
place for new events.
.IP \fBTCL_QUEUE_HEAD\fR 24
Add the event at the front of the queue, so that it will be serviced
before all other queued events.
.IP \fBTCL_QUEUE_MARK\fR 24
Add the event at the front of the queue, unless there are other
events at the front whose position is \fBTCL_QUEUE_MARK\fR;  if so,
add the new event just after all other \fBTCL_QUEUE_MARK\fR events.
This value of \fIposition\fR is used to insert an ordered sequence of
events at the front of the queue, such as a series of
Enter and Leave events synthesized during a grab or ungrab operation
in Tk.
.PP
When it is time to handle an event from the queue (steps 1 and 4
above) \fBTcl_ServiceEvent\fR will invoke the \fIproc\fR specified
in the first queued \fBTcl_Event\fR structure.
\fIProc\fR must match the following prototype:
.CS
typedef int Tcl_EventProc(
        Tcl_Event *\fIevPtr\fR,
        int \fIflags\fR);
.CE
The first argument to \fIproc\fR is a pointer to the event, which will
be the same as the first argument to the \fBTcl_QueueEvent\fR call that
added the event to the queue.
The second argument to \fIproc\fR is the \fIflags\fR argument for the
current call to \fBTcl_ServiceEvent\fR;  this is used by the event source
to return immediately if its events are not relevant.
.PP
It is up to \fIproc\fR to handle the event, typically by invoking
one or more Tcl commands or C-level callbacks.
Once the event source has finished handling the event it returns 1
to indicate that the event can be removed from the queue.
If for some reason the event source decides that the event cannot
be handled at this time, it may return 0 to indicate that the event
should be deferred for processing later;  in this case \fBTcl_ServiceEvent\fR
will go on to the next event in the queue and attempt to service it.
There are several reasons why an event source might defer an event.
One possibility is that events of this type are excluded by the
\fIflags\fR argument.
For example, the file event source will always return 0 if the
\fBTCL_FILE_EVENTS\fR bit is not set in \fIflags\fR.
Another example of deferring events happens in Tk if
\fBTk_RestrictEvents\fR has been invoked to defer certain kinds
of window events.
.PP
When \fIproc\fR returns 1, \fBTcl_ServiceEvent\fR will remove the
event from the event queue and free its storage.
Note that the storage for an event must be allocated by
the event source (using \fBTcl_Alloc\fR or the Tcl macro \fBckalloc\fR)
before calling \fBTcl_QueueEvent\fR, but it
will be freed by \fBTcl_ServiceEvent\fR, not by the event source.
.PP
Threaded applications work in a
similar manner, except that there is a separate event queue for
each thread containing a Tcl interpreter.
Calling \fBTcl_QueueEvent\fR in a multithreaded application adds
an event to the current thread's queue.
To add an event to another thread's queue, use \fBTcl_ThreadQueueEvent\fR.
\fBTcl_ThreadQueueEvent\fR accepts as an argument a Tcl_ThreadId argument,
which uniquely identifies a thread in a Tcl application.  To obtain the
Tcl_ThreadID for the current thread, use the \fBTcl_GetCurrentThread\fR
procedure.  (A thread would then need to pass this identifier to other
threads for those threads to be able to add events to its queue.)
After adding an event to another thread's queue, you then typically
need to call \fBTcl_ThreadAlert\fR to
.QW "wake up"
that thread's notifier to alert it to the new event.
.PP
\fBTcl_DeleteEvents\fR can be used to explicitly remove one or more
events from the event queue.  \fBTcl_DeleteEvents\fR calls \fIproc\fR
for each event in the queue, deleting those for with the procedure
returns 1.  Events for which the procedure returns 0 are left in the
queue.  \fIProc\fR should match the following prototype:
.CS
typedef int Tcl_EventDeleteProc(
        Tcl_Event *\fIevPtr\fR,
        ClientData \fIclientData\fR);
.CE
The \fIclientData\fR argument will be the same as the \fIclientData\fR
argument to \fBTcl_DeleteEvents\fR; it is typically used to point to
private information managed by the event source.  The \fIevPtr\fR will
point to the next event in the queue.
.PP
\fBTcl_DeleteEventSource\fR deletes an event source.  The \fIsetupProc\fR,
\fIcheckProc\fR, and \fIclientData\fR arguments must exactly match those
provided to the \fBTcl_CreateEventSource\fR for the event source to be deleted.
If no such source exists, \fBTcl_DeleteEventSource\fR has no effect.

.SH "CREATING A NEW NOTIFIER"
.PP
The notifier consists of all the procedures described in this manual
entry, plus \fBTcl_DoOneEvent\fR and \fBTcl_Sleep\fR, which are
available on all platforms, and \fBTcl_CreateFileHandler\fR and
\fBTcl_DeleteFileHandler\fR, which are Unix-specific.  Most of these
procedures are generic, in that they are the same for all notifiers.
However, none of the procedures are notifier-dependent:
\fBTcl_InitNotifier\fR, \fBTcl_AlertNotifier\fR,
\fBTcl_FinalizeNotifier\fR, \fBTcl_SetTimer\fR, \fBTcl_Sleep\fR,
\fBTcl_WaitForEvent\fR, \fBTcl_CreateFileHandler\fR,
\fBTcl_DeleteFileHandler\fR and \fBTcl_ServiceModeHook\fR.  To support a
new platform or to integrate Tcl with an application-specific event loop,
you must write new versions of these procedures.
.PP
\fBTcl_InitNotifier\fR initializes the notifier state and returns
a handle to the notifier state.  Tcl calls this
procedure when initializing a Tcl interpreter.  Similarly,
\fBTcl_FinalizeNotifier\fR shuts down the notifier, and is
called by \fBTcl_Finalize\fR when shutting down a Tcl interpreter.
.PP
\fBTcl_WaitForEvent\fR is the lowest-level procedure in the notifier;
it is responsible for waiting for an
.QW interesting
event to occur or
for a given time to elapse.  Before \fBTcl_WaitForEvent\fR is invoked,
each of the event sources' setup procedure will have been invoked.
The \fItimePtr\fR argument to
\fBTcl_WaitForEvent\fR gives the maximum time to block for an event,
based on calls to \fBTcl_SetMaxBlockTime\fR made by setup procedures
and on other information (such as the \fBTCL_DONT_WAIT\fR bit in
\fIflags\fR).
.PP
Ideally, \fBTcl_WaitForEvent\fR should only wait for an event
to occur; it should not actually process the event in any way.
Later on, the
event sources will process the raw events and create Tcl_Events on
the event queue in their \fIcheckProc\fR procedures.
However, on some platforms (such as Windows) this is not possible;
events may be processed in \fBTcl_WaitForEvent\fR, including queuing
Tcl_Events and more (for example, callbacks for native widgets may be
invoked).  The return value from \fBTcl_WaitForEvent\fR must be either
0, 1, or \-1.  On platforms such as Windows where events get processed in
\fBTcl_WaitForEvent\fR, a return value of 1 means that there may be more
events still pending that have not been processed.  This is a sign to the
caller that it must call \fBTcl_WaitForEvent\fR again if it wants all
pending events to be processed. A 0 return value means that calling
\fBTcl_WaitForEvent\fR again will not have any effect: either this is a
platform where \fBTcl_WaitForEvent\fR only waits without doing any event
processing, or \fBTcl_WaitForEvent\fR knows for sure that there are no
additional events to process (e.g. it returned because the time
elapsed).  Finally, a return value of \-1 means that the event loop is
no longer operational and the application should probably unwind and
terminate.  Under Windows this happens when a WM_QUIT message is received;
under Unix it happens when \fBTcl_WaitForEvent\fR would have waited
forever because there were no active event sources and the timeout was
infinite.
.PP
\fBTcl_AlertNotifier\fR is used in multithreaded applications to allow
any thread to
.QW "wake up"
the notifier to alert it to new events on its
queue.  \fBTcl_AlertNotifier\fR requires as an argument the notifier
handle returned by \fBTcl_InitNotifier\fR.
.PP
If the notifier will be used with an external event loop, then it must
also support the \fBTcl_SetTimer\fR interface.  \fBTcl_SetTimer\fR is
invoked by \fBTcl_SetMaxBlockTime\fR whenever the maximum blocking
time has been reduced.  \fBTcl_SetTimer\fR should arrange for the
external event loop to invoke \fBTcl_ServiceAll\fR after the specified
interval even if no events have occurred.  This interface is needed
because \fBTcl_WaitForEvent\fR is not invoked when there is an external
event loop.  If the
notifier will only be used from \fBTcl_DoOneEvent\fR, then
\fBTcl_SetTimer\fR need not do anything.
.PP
\fBTcl_ServiceModeHook\fR is called by the platform-independent portion
of the notifier when client code makes a call to
\fBTcl_SetServiceMode\fR. This hook is provided to support operating
systems that require special event handling when the application is in
a modal loop (the Windows notifier, for instance, uses this hook to
create a communication window).
.PP
On Unix systems, the file event source also needs support from the
notifier.  The file event source consists of the
\fBTcl_CreateFileHandler\fR and \fBTcl_DeleteFileHandler\fR
procedures, which are described in the \fBTcl_CreateFileHandler\fR
manual page.
.PP
The \fBTcl_Sleep\fR and \fBTcl_DoOneEvent\fR interfaces are described
in their respective manual pages.
.PP
The easiest way to create a new notifier is to look at the code
for an existing notifier, such as the files \fBunix/tclUnixNotfy.c\fR
or \fBwin/tclWinNotify.c\fR in the Tcl source distribution.

.SH "REPLACING THE NOTIFIER"
.PP
A notifier that has been written according to the conventions above
can also be installed in a running process in place of the standard
notifier.  This mechanism is used so that a single executable can be
used (with the standard notifier) as a stand-alone program and reused
(with a replacement notifier in a loadable extension) as an extension
to another program, such as a Web browser plugin.
.PP
To do this, the extension makes a call to \fBTcl_SetNotifier\fR
passing a pointer to a \fBTcl_NotifierProcs\fR data structure.  The
structure has the following layout:
.CS
typedef struct Tcl_NotifierProcs {
    Tcl_SetTimerProc *setTimerProc;
    Tcl_WaitForEventProc *waitForEventProc;
    Tcl_CreateFileHandlerProc *createFileHandlerProc;
    Tcl_DeleteFileHandlerProc *deleteFileHandlerProc;
    Tcl_InitNotifierProc *initNotifierProc;
    Tcl_FinalizeNotifierProc *finalizeNotifierProc;
    Tcl_AlertNotifierProc *alertNotifierProc;
    Tcl_ServiceModeHookProc *serviceModeHookProc;
} Tcl_NotifierProcs;
.CE
Following the call to \fBTcl_SetNotifier\fR, the pointers given in
the \fBTcl_NotifierProcs\fR structure replace whatever notifier had
been installed in the process.
.PP
It is extraordinarily unwise to replace a running notifier. Normally,
\fBTcl_SetNotifier\fR should be called at process initialization time
before the first call to \fBTcl_InitNotifier\fR.

.SH "EXTERNAL EVENT LOOPS"
.PP
The notifier interfaces are designed so that Tcl can be embedded into
applications that have their own private event loops.  In this case,
the application does not call \fBTcl_DoOneEvent\fR except in the case
of recursive event loops such as calls to the Tcl commands \fBupdate\fR
or \fBvwait\fR.  Most of the time is spent in the external event loop
of the application.  In this case the notifier must arrange for the
external event loop to call back into Tcl when something
happens on the various Tcl event sources.  These callbacks should
arrange for appropriate Tcl events to be placed on the Tcl event queue.
.PP
Because the external event loop is not calling \fBTcl_DoOneEvent\fR on
a regular basis, it is up to the notifier to arrange for
\fBTcl_ServiceEvent\fR to be called whenever events are pending on the
Tcl event queue.  The easiest way to do this is to invoke
\fBTcl_ServiceAll\fR at the end of each callback from the external
event loop.  This will ensure that all of the event sources are
polled, any queued events are serviced, and any pending idle handlers
are processed before returning control to the application.  In
addition, event sources that need to poll for events can call
\fBTcl_SetMaxBlockTime\fR to force the external event loop to call
Tcl even if no events are available on the system event queue.
.PP
As a side effect of processing events detected in the main external
event loop, Tcl may invoke \fBTcl_DoOneEvent\fR to start a recursive event
loop in commands like \fBvwait\fR.  \fBTcl_DoOneEvent\fR will invoke
the external event loop, which will result in callbacks as described
in the preceding paragraph, which will result in calls to
\fBTcl_ServiceAll\fR.  However, in these cases it is undesirable to
service events in \fBTcl_ServiceAll\fR.  Servicing events there is
unnecessary because control will immediately return to the
external event loop and hence to \fBTcl_DoOneEvent\fR, which can
service the events itself.  Furthermore, \fBTcl_DoOneEvent\fR is
supposed to service only a single event, whereas \fBTcl_ServiceAll\fR
normally services all pending events.  To handle this situation,
\fBTcl_DoOneEvent\fR sets a flag for \fBTcl_ServiceAll\fR
that causes it to return without servicing any events.
This flag is called the \fIservice mode\fR;
\fBTcl_DoOneEvent\fR restores it to its previous value before it returns.
.PP
In some cases, however, it may be necessary for \fBTcl_ServiceAll\fR
to service events
even when it has been invoked from \fBTcl_DoOneEvent\fR.  This happens
when there is yet another recursive event loop invoked via an
event handler called by \fBTcl_DoOneEvent\fR (such as one that is
part of a native widget).  In this case, \fBTcl_DoOneEvent\fR may not
have a chance to service events so \fBTcl_ServiceAll\fR must service
them all.  Any recursive event loop that calls an external event
loop rather than \fBTcl_DoOneEvent\fR must reset the service mode so
that all events get processed in \fBTcl_ServiceAll\fR.  This is done
by invoking the \fBTcl_SetServiceMode\fR procedure.  If
\fBTcl_SetServiceMode\fR is passed \fBTCL_SERVICE_NONE\fR, then calls
to \fBTcl_ServiceAll\fR will return immediately without processing any
events.  If \fBTcl_SetServiceMode\fR is passed \fBTCL_SERVICE_ALL\fR,
then calls to \fBTcl_ServiceAll\fR will behave normally.
\fBTcl_SetServiceMode\fR returns the previous value of the service
mode, which should be restored when the recursive loop exits.
\fBTcl_GetServiceMode\fR returns the current value of the service
mode.

.SH "SEE ALSO"
\fBTcl_CreateFileHandler\fR, \fBTcl_DeleteFileHandler\fR, \fBTcl_Sleep\fR,
\fBTcl_DoOneEvent\fR, \fBThread(3)\fR
.SH KEYWORDS
event, notifier, event queue, event sources, file events, timer, idle, service mode, threads
                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_Alloc.3tcl                               0100644 0001750 0001750 00000021434 12566232323 023303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1995-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Alloc.3,v 1.10.8.1 2009/03/30 18:48:18 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Alloc 3 7.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, ckalloc, ckfree, ckrealloc, attemptckalloc, attemptckrealloc \- allocate or free heap memory
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
char *
\fBTcl_Alloc\fR(\fIsize\fR)
.sp
void
\fBTcl_Free\fR(\fIptr\fR)
.sp
char *
\fBTcl_Realloc\fR(\fIptr, size\fR)
.sp
char *
\fBTcl_AttemptAlloc\fR(\fIsize\fR)
.sp
char *
\fBTcl_AttemptRealloc\fR(\fIptr, size\fR)
.sp
char *
\fBckalloc\fR(\fIsize\fR)
.sp
void
\fBckfree\fR(\fIptr\fR)
.sp
char *
\fBckrealloc\fR(\fIptr, size\fR)
.sp
char *
\fBattemptckalloc\fR(\fIsize\fR)
.sp
char *
\fBattemptckrealloc\fR(\fIptr, size\fR)
.SH ARGUMENTS
.AS char *size
.AP "unsigned int" size in
Size in bytes of the memory block to allocate.
.AP char *ptr in
Pointer to memory block to free or realloc.
.BE

.SH DESCRIPTION
.PP
These procedures provide a platform and compiler independent interface
for memory allocation.  Programs that need to transfer ownership of
memory blocks between Tcl and other modules should use these routines
rather than the native \fBmalloc()\fR and \fBfree()\fR routines
provided by the C run-time library.
.PP
\fBTcl_Alloc\fR returns a pointer to a block of at least \fIsize\fR
bytes suitably aligned for any use.
.PP
\fBTcl_Free\fR makes the space referred to by \fIptr\fR available for
further allocation.
.PP
\fBTcl_Realloc\fR changes the size of the block pointed to by
\fIptr\fR to \fIsize\fR bytes and returns a pointer to the new block.
The contents will be unchanged up to the lesser of the new and old
sizes.  The returned location may be different from \fIptr\fR.  If
\fIptr\fR is NULL, this is equivalent to calling \fBTcl_Alloc\fR with
just the \fIsize\fR argument.
.PP
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR are identical in
function to \fBTcl_Alloc\fR and \fBTcl_Realloc\fR, except that
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR will not cause the Tcl
interpreter to \fBpanic\fR if the memory allocation fails.  If the
allocation fails, these functions will return NULL.  Note that on some
platforms, but not all, attempting to allocate a zero-sized block of
memory will also cause these functions to return NULL.
.PP
The procedures \fBckalloc\fR, \fBckfree\fR, \fBckrealloc\fR,
\fBattemptckalloc\fR, and \fBattemptckrealloc\fR are implemented
as macros.  Normally, they are synonyms for the corresponding
procedures documented on this page.  When Tcl and all modules
calling Tcl are compiled with \fBTCL_MEM_DEBUG\fR defined, however,
these macros are redefined to be special debugging versions
of these procedures.  To support Tcl's memory debugging within a
module, use the macros rather than direct calls to \fBTcl_Alloc\fR, etc.

.SH KEYWORDS
alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AllocStatBuf.3tcl                        0100644 0001750 0001750 00000213245 12566232334 024601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 2001 Vincent Darley
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: FileSystem.3,v 1.62.2.1 2009/11/27 14:53:54 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Filesystem 3 8.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_AllocStatBuf \- procedures to interact with any filesystem
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_FSRegister\fR(\fIclientData, fsPtr\fR)
.sp
int
\fBTcl_FSUnregister\fR(\fIfsPtr\fR)
.sp
ClientData
\fBTcl_FSData\fR(\fIfsPtr\fR)
.sp
void
\fBTcl_FSMountsChanged\fR(\fIfsPtr\fR)
.sp
Tcl_Filesystem*
\fBTcl_FSGetFileSystemForPath\fR(\fIpathPtr\fR)
.sp
Tcl_PathType
\fBTcl_FSGetPathType\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSCopyFile\fR(\fIsrcPathPtr, destPathPtr\fR)
.sp
int
\fBTcl_FSCopyDirectory\fR(\fIsrcPathPtr, destPathPtr, errorPtr\fR)
.sp
int
\fBTcl_FSCreateDirectory\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSDeleteFile\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSRemoveDirectory\fR(\fIpathPtr, int recursive, errorPtr\fR)
.sp
int
\fBTcl_FSRenameFile\fR(\fIsrcPathPtr, destPathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSListVolumes\fR(\fIvoid\fR)
.sp
.VS 8.5
int
\fBTcl_FSEvalFileEx\fR(\fIinterp, pathPtr, encodingName\fR)
.VE 8.5
.sp
int
\fBTcl_FSEvalFile\fR(\fIinterp, pathPtr\fR)
.sp
int
\fBTcl_FSLoadFile\fR(\fIinterp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr,
               handlePtr, unloadProcPtr\fR)
.sp
int
\fBTcl_FSMatchInDirectory\fR(\fIinterp, resultPtr, pathPtr, pattern, types\fR)
.sp
Tcl_Obj*
\fBTcl_FSLink\fR(\fIlinkNamePtr, toPtr, linkAction\fR)
.sp
int
\fBTcl_FSLstat\fR(\fIpathPtr, statPtr\fR)
.sp
int
\fBTcl_FSUtime\fR(\fIpathPtr, tval\fR)
.sp
int
\fBTcl_FSFileAttrsGet\fR(\fIinterp, int index, pathPtr, objPtrRef\fR)
.sp
int
\fBTcl_FSFileAttrsSet\fR(\fIinterp, int index, pathPtr, Tcl_Obj *objPtr\fR)
.sp
const char**
\fBTcl_FSFileAttrStrings\fR(\fIpathPtr, objPtrRef\fR)
.sp
int
\fBTcl_FSStat\fR(\fIpathPtr, statPtr\fR)
.sp
int
\fBTcl_FSAccess\fR(\fIpathPtr, mode\fR)
.sp
Tcl_Channel
\fBTcl_FSOpenFileChannel\fR(\fIinterp, pathPtr, modeString, permissions\fR)
.sp
Tcl_Obj*
\fBTcl_FSGetCwd\fR(\fIinterp\fR)
.sp
int
\fBTcl_FSChdir\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSPathSeparator\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSJoinPath\fR(\fIlistObj, elements\fR)
.sp
Tcl_Obj*
\fBTcl_FSSplitPath\fR(\fIpathPtr, lenPtr\fR)
.sp
int
\fBTcl_FSEqualPaths\fR(\fIfirstPtr, secondPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSGetNormalizedPath\fR(\fIinterp, pathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSJoinToPath\fR(\fIbasePtr, objc, objv\fR)
.sp
int
\fBTcl_FSConvertToPathType\fR(\fIinterp, pathPtr\fR)
.sp
ClientData
\fBTcl_FSGetInternalRep\fR(\fIpathPtr, fsPtr\fR)
.sp
Tcl_Obj *
\fBTcl_FSGetTranslatedPath\fR(\fIinterp, pathPtr\fR)
.sp
const char *
\fBTcl_FSGetTranslatedStringPath\fR(\fIinterp, pathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSNewNativePath\fR(\fIfsPtr, clientData\fR)
.sp
const char *
\fBTcl_FSGetNativePath\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSFileSystemInfo\fR(\fIpathPtr\fR)
.sp
Tcl_StatBuf*
\fBTcl_AllocStatBuf\fR()
.SH ARGUMENTS
.AS Tcl_FSUnloadFileProc **unloadProcPtr out
.AP Tcl_Filesystem *fsPtr in
Points to a structure containing the addresses of procedures that
can be called to perform the various filesystem operations.
.AP Tcl_Obj *pathPtr in
The path represented by this object is used for the operation in
question.  If the object does not already have an internal \fBpath\fR
representation, it will be converted to have one.
.AP Tcl_Obj *srcPathPtr in
As for \fIpathPtr\fR, but used for the source file for a copy or
rename operation.
.AP Tcl_Obj *destPathPtr in
As for \fIpathPtr\fR, but used for the destination filename for a copy or
rename operation.
.AP "const char" *encodingName in
The encoding of the data stored in the
file identified by \fIpathPtr\fR and to be evaluated.
.AP "const char" *pattern in
Only files or directories matching this pattern will be returned.
.AP Tcl_GlobTypeData *types in
Only files or directories matching the type descriptions contained in
this structure will be returned.  This parameter may be NULL.
.AP Tcl_Interp *interp in
Interpreter to use either for results, evaluation, or reporting error
messages.
.AP ClientData clientData in
The native description of the path object to create.
.AP Tcl_Obj *firstPtr in
The first of two path objects to compare.  The object may be converted
to \fBpath\fR type.
.AP Tcl_Obj *secondPtr in
The second of two path objects to compare.  The object may be converted
to \fBpath\fR type.
.AP Tcl_Obj *listObj in
The list of path elements to operate on with a \fBjoin\fR operation.
.AP int elements in
If non-negative, the number of elements in the \fIlistObj\fR which should
be joined together.  If negative, then all elements are joined.
.AP Tcl_Obj **errorPtr out
In the case of an error, filled with an object containing the name of
the file which caused an error in the various copy/rename operations.
.AP Tcl_Obj **objPtrRef out
Filled with an object containing the result of the operation.
.AP Tcl_Obj *resultPtr out
Pre-allocated object in which to store (using
\fBTcl_ListObjAppendElement\fR) the list of
files or directories which are successfully matched.
.AP int mode in
Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.  R_OK,
W_OK and X_OK request checking whether the file exists and  has  read,
write and  execute  permissions, respectively.  F_OK just requests
checking for the existence of the file.
.AP Tcl_StatBuf *statPtr out
The structure that contains the result of a stat or lstat operation.
.AP "const char" *sym1 in
Name of a procedure to look up in the file's symbol table
.AP "const char" *sym2 in
Name of a procedure to look up in the file's symbol table
.AP Tcl_PackageInitProc **proc1Ptr out
Filled with the init function for this code.
.AP Tcl_PackageInitProc **proc2Ptr out
Filled with the safe-init function for this code.
.AP ClientData *clientDataPtr out
Filled with the clientData value to pass to this code's unload
function when it is called.
.AP Tcl_LoadHandle *handlePtr out
Filled with an abstract token representing the loaded file.
.AP Tcl_FSUnloadFileProc **unloadProcPtr out
Filled with the function to use to unload this piece of code.
.AP utimbuf *tval in
The access and modification times in this structure are read and
used to set those values for a given file.
.AP "const char" *modeString in
Specifies how the file is to be accessed.  May have any of the values
allowed for the \fImode\fR argument to the Tcl \fBopen\fR command.
.AP int permissions in
POSIX-style permission flags such as 0644.  If a new file is created, these
permissions will be set on the created file.
.AP int *lenPtr out
If non-NULL, filled with the number of elements in the split path.
.AP Tcl_Obj *basePtr in
The base path on to which to join the given elements.  May be NULL.
.AP int objc in
The number of elements in \fIobjv\fR.
.AP "Tcl_Obj *const" objv[] in
The elements to join to the given base path.
.AP Tcl_Obj *linkNamePtr in
The name of the link to be created or read.
.AP Tcl_Obj *toPtr in
What the link called \fIlinkNamePtr\fR should be linked to, or NULL if
the symbolic link specified by \fIlinkNamePtr\fR is to be read.
.AP int linkAction in
OR-ed combination of flags indicating what kind of link should be
created (will be ignored if \fItoPtr\fR is NULL). Valid bits to set
are \fBTCL_CREATE_SYMBOLIC_LINK\fR and \fBTCL_CREATE_HARD_LINK\fR.
When both flags are set and the underlying filesystem can do either,
symbolic links are preferred.
.BE

.SH DESCRIPTION
.PP
There are several reasons for calling the \fBTcl_FS\fR API functions
(e.g. \fBTcl_FSAccess\fR and \fBTcl_FSStat\fR)
rather than calling system level functions like \fBaccess\fR and
\fBstat\fR directly.  First, they will work cross-platform, so an
extension which calls them should work unmodified on Unix and
Windows.  Second, the Windows implementation of some of these functions
fixes some bugs in the system level calls.  Third, these function calls
deal with any
.QW "Utf to platform-native"
path conversions which may be
required (and may cache the results of such conversions for greater
efficiency on subsequent calls).  Fourth, and perhaps most importantly,
all of these functions are
.QW "virtual filesystem aware" .
Any virtual filesystem (VFS for short) which has been registered (through
\fBTcl_FSRegister\fR) may reroute file access to alternative
media or access methods.  This means that all of these functions (and
therefore the corresponding \fBfile\fR, \fBglob\fR, \fBpwd\fR, \fBcd\fR,
\fBopen\fR, etc.  Tcl commands) may be operate on
.QW files
which are not
native files in the native filesystem.  This also means that any Tcl
extension which accesses the filesystem (FS for short) through this API is
automatically
.QW "virtual filesystem aware" .
Of course, if an extension
accesses the native filesystem directly (through platform-specific
APIs, for example), then Tcl cannot intercept such calls.
.PP
If appropriate VFSes have been registered, the
.QW files
may, to give two
examples, be remote (e.g. situated on a remote ftp server) or archived
(e.g. lying inside a .zip archive).  Such registered filesystems provide
a lookup table of functions to implement all or some of the functionality
listed here.  Finally, the \fBTcl_FSStat\fR and \fBTcl_FSLstat\fR calls
abstract away from what the
.QW "struct stat"
buffer is actually
declared to be, allowing the same code to be used both on systems with
and systems without support for files larger than 2GB in size.
.PP
The \fBTcl_FS\fR API is objectified and may cache internal
representations and other path-related strings (e.g. the current working
directory).  One side-effect of this is that one must not pass in objects
with a reference count of zero to any of these functions.  If such calls were
handled, they might result
in memory leaks (under some circumstances, the filesystem code may wish
to retain a reference to the passed in object, and so one must not assume
that after any of these calls return, the object still has a reference count of
zero - it may have been incremented) or in a direct segmentation fault
(or other memory access error)
due to the object being freed part way through the complex object
manipulation required to ensure that the path is fully normalized and
absolute for filesystem determination.  The practical lesson to learn
from this is that
.CS
Tcl_Obj *path = Tcl_NewStringObj(...);
Tcl_FS\fIWhatever\fR(path);
Tcl_DecrRefCount(path);
.CE
is wrong, and may cause memory errors. The \fIpath\fR must have its
reference count incremented before passing it in, or
decrementing it.  For this reason, objects with a reference count of zero are
considered not to be valid filesystem paths and calling any Tcl_FS API
function with such an object will result in no action being taken.
.SS "FS API FUNCTIONS"
\fBTcl_FSCopyFile\fR attempts to copy the file given by \fIsrcPathPtr\fR to the
path name given by \fIdestPathPtr\fR.  If the two paths given lie in the same
filesystem (according to \fBTcl_FSGetFileSystemForPath\fR) then that
filesystem's
.QW "copy file"
function is called (if it is non-NULL).
Otherwise the function returns -1 and sets the \fBerrno\fR global C
variable to the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSCopyDirectory\fR attempts to copy the directory given by \fIsrcPathPtr\fR to the
path name given by \fIdestPathPtr\fR.  If the two paths given lie in the same
filesystem (according to \fBTcl_FSGetFileSystemForPath\fR) then that
filesystem's
.QW "copy file"
function is called (if it is non-NULL).
Otherwise the function returns -1 and sets the \fBerrno\fR global C
variable to the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSCreateDirectory\fR attempts to create the directory given by
\fIpathPtr\fR by calling the owning filesystem's
.QW "create directory"
function.
.PP
\fBTcl_FSDeleteFile\fR attempts to delete the file given by
\fIpathPtr\fR by calling the owning filesystem's
.QW "delete file"
function.
.PP
\fBTcl_FSRemoveDirectory\fR attempts to remove the directory given by
\fIpathPtr\fR by calling the owning filesystem's
.QW "remove directory"
function.
.PP
\fBTcl_FSRenameFile\fR attempts to rename the file or directory given by
\fIsrcPathPtr\fR to the path name given by \fIdestPathPtr\fR.  If the two paths
given lie in the same filesystem (according to
\fBTcl_FSGetFileSystemForPath\fR) then that filesystem's
.QW "rename file"
function is called (if it is non-NULL).  Otherwise the function returns -1
and sets the \fBerrno\fR global C variable to the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSListVolumes\fR calls each filesystem which has a non-NULL
.QW "list volumes"
function and asks them to return their list of root volumes.  It
accumulates the return values in a list which is returned to the
caller (with a reference count of 0).
.PP
.VS 8.5
\fBTcl_FSEvalFileEx\fR reads the file given by \fIpathPtr\fR using
the encoding identified by \fIencodingName\fR and evaluates
its contents as a Tcl script.  It returns the same information as
\fBTcl_EvalObjEx\fR.
If \fIencodingName\fR is NULL, the system encoding is used for
reading the file contents.
If the file could not be read then a Tcl error is returned to describe
why the file could not be read.
The eofchar for files is
.QW \e32
(^Z) for all platforms.
If you require a
.QW ^Z
in code for string comparison, you can use
.QW \e032
or
.QW \eu001a ,
which will be safely substituted by the Tcl interpreter into
.QW ^Z .
\fBTcl_FSEvalFile\fR is a simpler version of
\fBTcl_FSEvalFileEx\fR that always uses the system encoding
when reading the file.
.VE 8.5
.PP
\fBTcl_FSLoadFile\fR dynamically loads a binary code file into memory and
returns the addresses of two procedures within that file, if they are
defined.  The appropriate function for the filesystem to which \fIpathPtr\fR
belongs will be called.  If that filesystem does not implement this
function (most virtual filesystems will not, because of OS limitations
in dynamically loading binary code), Tcl will attempt to copy the file
to a temporary directory and load that temporary file.
.PP
Returns a standard Tcl completion code.  If an error occurs, an error
message is left in the \fIinterp\fR's result.
.PP
\fBTcl_FSMatchInDirectory\fR is used by the globbing code to search a
directory for all files which match a given pattern.  The appropriate
function for the filesystem to which \fIpathPtr\fR belongs will be called.
.PP
The return value is a standard Tcl result indicating whether an error
occurred in globbing.  Error messages are placed in interp (unless 
interp is NULL, which is allowed), but good results are placed in the 
resultPtr given.
.PP
Note that the \fBglob\fR code implements recursive patterns internally, so
this function will only ever be passed simple patterns, which can be
matched using the logic of \fBstring match\fR.  To handle recursion, Tcl
will call this function frequently asking only for directories to be
returned.  A special case of being called with a NULL pattern indicates
that the path needs to be checked only for the correct type.
.PP
\fBTcl_FSLink\fR replaces the library version of \fBreadlink\fR, and
extends it to support the creation of links.  The appropriate function
for the filesystem to which \fIlinkNamePtr\fR belongs will be called.
.PP
If the \fItoPtr\fR is NULL, a
.QW "read link"
action is performed.  The result
is a Tcl_Obj specifying the contents of the symbolic link given by
\fIlinkNamePtr\fR, or NULL if the link could not be read.  The result is owned
by the caller, which should call Tcl_DecrRefCount when the result is no
longer needed.  If the \fItoPtr\fR is not NULL, Tcl should create a link
of one of the types passed in in the \fIlinkAction\fR flag.  This flag is
an ORed combination of \fBTCL_CREATE_SYMBOLIC_LINK\fR and \fBTCL_CREATE_HARD_LINK\fR.
Where a choice exists (i.e. more than one flag is passed in), the Tcl
convention is to prefer symbolic links.  When a link is successfully
created, the return value should be \fItoPtr\fR (which is therefore
already owned by the caller).  If unsuccessful, NULL is returned.
.PP
\fBTcl_FSLstat\fR fills the stat structure \fIstatPtr\fR with information
about the specified file.  You do not need any access rights to the
file to get this information but you need search rights to all
directories named in the path leading to the file.  The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.
.PP
If \fIpath\fR exists, \fBTcl_FSLstat\fR returns 0 and the stat structure
is filled with data.  Otherwise, -1 is returned, and no stat info is
given.
.PP
\fBTcl_FSUtime\fR replaces the library version of utime.
.PP
This returns 0 on success and -1 on error (as per the \fButime\fR
documentation).  If successful, the function
will update the
.QW atime
and
.QW mtime
values of the file given.
.PP
\fBTcl_FSFileAttrsGet\fR implements read access for the hookable \fBfile
attributes\fR subcommand.  The appropriate function for the filesystem to
which \fIpathPtr\fR belongs will be called.
.PP
If the result is \fBTCL_OK\fR, then an object was placed in
\fIobjPtrRef\fR, which
will only be temporarily valid (unless \fBTcl_IncrRefCount\fR is called).
.PP
\fBTcl_FSFileAttrsSet\fR implements write access for the hookable \fBfile
attributes\fR subcommand.  The appropriate function for the filesystem to
which \fIpathPtr\fR belongs will be called.
.PP
\fBTcl_FSFileAttrStrings\fR implements part of the hookable \fBfile
attributes\fR subcommand.  The appropriate function for the filesystem
to which \fIpathPtr\fR belongs will be called.
.PP
The called procedure may either return an array of strings, or may
instead return NULL and place a Tcl list into the given \fIobjPtrRef\fR.  Tcl
will take that list and first increment its reference count before using it.
On completion of that use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, and if the list should not be disposed of, the
filesystem should ensure it retains a reference count to the object.
.PP
\fBTcl_FSAccess\fR checks whether the process would be allowed to read,
write or test for existence of the file (or other filesystem object)
whose name is \fIpathname\fR.   If \fIpathname\fR is a symbolic link on Unix,
then permissions of the file referred by this symbolic link are
tested.
.PP
On success (all requested permissions granted), zero is returned.  On
error (at least one bit in mode asked for a permission that is denied,
or some other error occurred), -1 is returned.
.PP
\fBTcl_FSStat\fR fills the stat structure \fIstatPtr\fR with information
about the specified file.  You do not need any access rights to the
file to get this information but you need search rights to all
directories named in the path leading to the file.  The stat structure
includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.
.PP
If \fIpath\fR exists, \fBTcl_FSStat\fR returns 0 and the stat structure
is filled with data.  Otherwise, -1 is returned, and no stat info is
given.
.PP
\fBTcl_FSOpenFileChannel\fR opens a file specified by \fIpathPtr\fR and
returns a channel handle that can be used to perform input and output on
the file. This API is modeled after the \fBfopen\fR procedure of
the Unix standard I/O library.
The syntax and meaning of all arguments is similar to those
given in the Tcl \fBopen\fR command when opening a file.
If an error occurs while opening the channel, \fBTcl_FSOpenFileChannel\fR
returns NULL and records a POSIX error code that can be
retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_FSOpenFileChannel\fR
leaves an error message in \fIinterp\fR's result after any error.
.PP
The newly created channel is not registered in the supplied interpreter; to
register it, use \fBTcl_RegisterChannel\fR, described below.
If one of the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it as a
replacement for the standard channel.
.PP
\fBTcl_FSGetCwd\fR replaces the library version of \fBgetcwd\fR.
.PP
It returns the Tcl library's current working directory.  This may be
different to the native platform's working directory, which happens when
the current working directory is not in the native filesystem.
.PP
The result is a pointer to a Tcl_Obj specifying the current directory,
or NULL if the current directory could not be determined.  If NULL is
returned, an error message is left in the \fIinterp\fR's result.
.PP
The result already has its reference count incremented for the caller.  When
it is no longer needed, that reference count should be decremented.  This is
needed for thread-safety purposes, to allow multiple threads to access
this and related functions, while ensuring the results are always
valid.
.PP
\fBTcl_FSChdir\fR replaces the library version of \fBchdir\fR.  The path is
normalized and then passed to the filesystem which claims it.  If that
filesystem does not implement this function, Tcl will fallback to a
combination of \fBstat\fR and \fBaccess\fR to check whether the directory
exists and has appropriate permissions.
.PP
For results, see \fBchdir\fR documentation.  If successful, we keep a
record of the successful path in \fIcwdPathPtr\fR for subsequent calls to
\fBTcl_FSGetCwd\fR.
.PP
\fBTcl_FSPathSeparator\fR returns the separator character to be used for
most specific element of the path specified by \fIpathPtr\fR (i.e. the last
part of the path).
.PP
The separator is returned as a Tcl_Obj containing a string of length
1.  If the path is invalid, NULL is returned.
.PP
\fBTcl_FSJoinPath\fR takes the given Tcl_Obj, which must be a valid
list (which is allowed to have a reference count of zero), and returns the path
object given by considering the first \fIelements\fR elements as valid path
segments (each path segment may be a complete path, a partial path or
just a single possible directory or file name).  If any path segment is
actually an absolute path, then all prior path segments are discarded.
If \fIelements\fR is less than 0, we use the entire list.
.PP
It is possible that the returned object is actually an element
of the given list, so the caller should be careful to increment the
reference count of the result before freeing the list.
.PP
The returned object, typically with a reference count of zero (but it
could be shared
under some conditions), contains the joined path.  The caller must
add a reference count to the object before using it.  In particular, the
returned object could be an element of the given list, so freeing the
list might free the object prematurely if no reference count has been taken.
If the number of elements is zero, then the returned object will be
an empty-string Tcl_Obj.
.PP
\fBTcl_FSSplitPath\fR takes the given Tcl_Obj, which should be a valid path,
and returns a Tcl list object containing each segment of that path as
an element.
It returns a list object with a reference count of zero.  If the
passed in \fIlenPtr\fR is non-NULL, the variable it points to will be
updated to contain the number of elements in the returned list.
.PP
\fBTcl_FSEqualPaths\fR tests whether the two paths given represent the same
filesystem object
.PP
It returns 1 if the paths are equal, and 0 if they are different.  If
either path is NULL, 0 is always returned.
.PP
\fBTcl_FSGetNormalizedPath\fR this important function attempts to extract
from the given Tcl_Obj a unique normalized path representation, whose
string value can be used as a unique identifier for the file.
.PP
It returns the normalized path object, owned by Tcl, or NULL if the path
was invalid or could otherwise not be successfully converted.
Extraction of absolute, normalized paths is very efficient (because the
filesystem operates on these representations internally), although the
result when the filesystem contains numerous symbolic links may not be
the most user-friendly version of a path.  The return value is owned by
Tcl and has a lifetime equivalent to that of the \fIpathPtr\fR passed in
(unless that is a relative path, in which case the normalized path
object may be freed any time the cwd changes) - the caller can of
course increment the refCount if it wishes to maintain a copy for longer.
.PP
\fBTcl_FSJoinToPath\fR takes the given object, which should usually be a
valid path or NULL, and joins onto it the array of paths segments
given.
.PP
Returns object, typically with refCount of zero (but it could be shared
under some conditions), containing the joined path.  The caller must
add a refCount to the object before using it.  If any of the objects
passed into this function (pathPtr or path elements) have a refCount
of zero, they will be freed when this function returns.
.PP
\fBTcl_FSConvertToPathType\fR tries to convert the given Tcl_Obj to a valid
Tcl path type, taking account of the fact that the cwd may have changed
even if this object is already supposedly of the correct type.
The filename may begin with
.QW ~
(to indicate current user's home directory) or
.QW ~<user>
(to indicate any user's home directory).
.PP
If the conversion succeeds (i.e. the object is a valid path in one of
the current filesystems), then \fBTCL_OK\fR is returned.  Otherwise
\fBTCL_ERROR\fR is returned, and an error message may
be left in the interpreter.
.PP
\fBTcl_FSGetInternalRep\fR extracts the internal representation of a given
path object, in the given filesystem.  If the path object belongs to a
different filesystem, we return NULL. If the internal representation is
currently NULL, we attempt to generate it, by calling the filesystem's
\fBTcl_FSCreateInternalRepProc\fR.
.PP
Returns NULL or a valid internal path representation.  This internal
representation is cached, so that repeated calls to this function will
not require additional conversions.
.PP
\fBTcl_FSGetTranslatedPath\fR attempts to extract the translated path
from the given Tcl_Obj.
.PP
If the translation succeeds (i.e. the object is a valid path), then it is
returned.  Otherwise NULL will be returned, and an error message may be
left in the interpreter.  A
.QW translated
path is one which contains no
.QW ~
or
.QW ~user
sequences (these have been expanded to their current
representation in the filesystem).  The object returned is owned by the
caller, which must store it or call Tcl_DecrRefCount to ensure memory is
freed.  This function is of little practical use, and
\fBTcl_FSGetNormalizedPath\fR or \fBTcl_GetNativePath\fR are usually
better functions to use for most purposes.
.PP
\fBTcl_FSGetTranslatedStringPath\fR does the same as
\fBTcl_FSGetTranslatedPath\fR, but returns a character string or NULL.
The string returned is dynamically allocated and owned by the caller,
which must store it or call \fBckfree\fR to ensure it is freed.  Again,
\fBTcl_FSGetNormalizedPath\fR or \fBTcl_GetNativePath\fR are usually
better functions to use for most purposes.
.PP
\fBTcl_FSNewNativePath\fR performs something like the reverse of the
usual obj->path->nativerep conversions.  If some code retrieves a path
in native form (from, e.g. \fBreadlink\fR or a native dialog), and that path
is to be used at the Tcl level, then calling this function is an
efficient way of creating the appropriate path object type.
.PP
The resulting object is a pure
.QW path
object, which will only receive
a UTF-8 string representation if that is required by some Tcl code.
.PP
\fBTcl_FSGetNativePath\fR is for use by the Win/Unix native
filesystems, so that they can easily retrieve the native (char* or
TCHAR*) representation of a path.  This function is a convenience
wrapper around \fBTcl_FSGetInternalRep\fR, and assumes the native
representation is string-based.  It may be desirable in the future to
have non-string-based native representations (for example, on MacOSX, a
representation using a fileSpec of FSRef structure would probably be
more efficient).  On Windows a full Unicode representation would allow
for paths of unlimited length.  Currently the representation is simply a
character string which may contain either the relative path or a
complete, absolute normalized path in the native encoding (complex
conditions dictate which of these will be provided, so neither can be
relied upon, unless the path is known to be absolute).  If you need a
native path which must be absolute, then you should ask for the native
version of a normalized path.  If for some reason a non-absolute,
non-normalized version of the path is needed, that must be constructed
separately (e.g. using \fBTcl_FSGetTranslatedPath\fR).
.PP
The native representation is cached so that repeated calls to this
function will not require additional conversions.  The return value is
owned by Tcl and has a lifetime equivalent to that of the \fIpathPtr\fR
passed in (unless that is a relative path, in which case the native
representation may be freed any time the cwd changes).
.PP
\fBTcl_FSFileSystemInfo\fR returns a list of two elements.  The first
element is the name of the filesystem (e.g.
.QW native ,
.QW vfs ,
.QW zip ,
or
.QW prowrap ,
perhaps), and the second is the particular type of the
given path within that filesystem (which is filesystem dependent).  The
second element may be empty if the filesystem does not provide a
further categorization of files.
.PP
A valid list object is returned, unless the path object is not
recognized, when NULL will be returned.
.PP
\fBTcl_FSGetFileSystemForPath\fR returns the a pointer to the
\fBTcl_Filesystem\fR which accepts this path as valid.
.PP
If no filesystem will accept the path, NULL is returned.
.PP
\fBTcl_FSGetPathType\fR determines whether the given path is relative
to the current directory, relative to the current volume, or
absolute.
.PP
It returns one of \fBTCL_PATH_ABSOLUTE\fR, \fBTCL_PATH_RELATIVE\fR, or
\fBTCL_PATH_VOLUME_RELATIVE\fR
.PP
\fBTcl_AllocStatBuf\fR allocates a \fITcl_StatBuf\fR on the system
heap (which may be deallocated by being passed to \fBckfree\fR.)  This
allows extensions to invoke \fBTcl_FSStat\fR and \fBTcl_FSLStat\fR
without being dependent on the size of the buffer.  That in turn
depends on the flags used to build Tcl.
.SH "THE VIRTUAL FILESYSTEM API"
.PP
A filesystem provides a \fBTcl_Filesystem\fR structure that contains
pointers to functions that implement the various operations on a
filesystem; these operations are invoked as needed by the generic
layer, which generally occurs through the functions listed above.
.PP
The \fBTcl_Filesystem\fR structures are manipulated using the following
methods.
.PP
\fBTcl_FSRegister\fR takes a pointer to a filesystem structure and an
optional piece of data to associated with that filesystem.  On calling
this function, Tcl will attach the filesystem to the list of known
filesystems, and it will become fully functional immediately.  Tcl does
not check if the same filesystem is registered multiple times (and in
general that is not a good thing to do).  \fBTCL_OK\fR will be returned.
.PP
\fBTcl_FSUnregister\fR removes the given filesystem structure from
the list of known filesystems, if it is known, and returns \fBTCL_OK\fR.  If
the filesystem is not currently registered, \fBTCL_ERROR\fR is returned.
.PP
\fBTcl_FSData\fR will return the ClientData associated with the given
filesystem, if that filesystem is registered.  Otherwise it will
return NULL.
.PP
\fBTcl_FSMountsChanged\fR is used to inform the Tcl's core that
the set of mount points for the given (already registered) filesystem
have changed, and that cached file representations may therefore no
longer be correct.
.SS "THE TCL_FILESYSTEM STRUCTURE"
.PP
The \fBTcl_Filesystem\fR structure contains the following fields:
.CS
typedef struct Tcl_Filesystem {
    const char *\fItypeName\fR;
    int \fIstructureLength\fR;
    Tcl_FSVersion \fIversion\fR;
    Tcl_FSPathInFilesystemProc *\fIpathInFilesystemProc\fR;
    Tcl_FSDupInternalRepProc *\fIdupInternalRepProc\fR;
    Tcl_FSFreeInternalRepProc *\fIfreeInternalRepProc\fR;
    Tcl_FSInternalToNormalizedProc *\fIinternalToNormalizedProc\fR;
    Tcl_FSCreateInternalRepProc *\fIcreateInternalRepProc\fR;
    Tcl_FSNormalizePathProc *\fInormalizePathProc\fR;
    Tcl_FSFilesystemPathTypeProc *\fIfilesystemPathTypeProc\fR;
    Tcl_FSFilesystemSeparatorProc *\fIfilesystemSeparatorProc\fR;
    Tcl_FSStatProc *\fIstatProc\fR;
    Tcl_FSAccessProc *\fIaccessProc\fR;
    Tcl_FSOpenFileChannelProc *\fIopenFileChannelProc\fR;
    Tcl_FSMatchInDirectoryProc *\fImatchInDirectoryProc\fR;
    Tcl_FSUtimeProc *\fIutimeProc\fR;
    Tcl_FSLinkProc *\fIlinkProc\fR;
    Tcl_FSListVolumesProc *\fIlistVolumesProc\fR;
    Tcl_FSFileAttrStringsProc *\fIfileAttrStringsProc\fR;
    Tcl_FSFileAttrsGetProc *\fIfileAttrsGetProc\fR;
    Tcl_FSFileAttrsSetProc *\fIfileAttrsSetProc\fR;
    Tcl_FSCreateDirectoryProc *\fIcreateDirectoryProc\fR;
    Tcl_FSRemoveDirectoryProc *\fIremoveDirectoryProc\fR;
    Tcl_FSDeleteFileProc *\fIdeleteFileProc\fR;
    Tcl_FSCopyFileProc *\fIcopyFileProc\fR;
    Tcl_FSRenameFileProc *\fIrenameFileProc\fR;
    Tcl_FSCopyDirectoryProc *\fIcopyDirectoryProc\fR;
    Tcl_FSLstatProc *\fIlstatProc\fR;
    Tcl_FSLoadFileProc *\fIloadFileProc\fR;
    Tcl_FSGetCwdProc *\fIgetCwdProc\fR;
    Tcl_FSChdirProc *\fIchdirProc\fR;
} Tcl_Filesystem;
.CE
.PP
Except for the first three fields in this structure which contain
simple data elements, all entries contain addresses of functions called
by the generic filesystem layer to perform the complete range of
filesystem related actions.
.PP
The many functions in this structure are broken down into three
categories: infrastructure functions (almost all of which must be
implemented), operational functions (which must be implemented if a
complete filesystem is provided), and efficiency functions (which need
only be implemented if they can be done so efficiently, or if they have
side-effects which are required by the filesystem; Tcl has less
efficient emulations it can fall back on).  It is important to note
that, in the current version of Tcl, most of these fallbacks are only
used to handle commands initiated in Tcl, not in C. What this means is,
that if a \fBfile rename\fR command is issued in Tcl, and the relevant
filesystem(s) do not implement their \fITcl_FSRenameFileProc\fR, Tcl's
core will instead fallback on a combination of other filesystem
functions (it will use \fITcl_FSCopyFileProc\fR followed by
\fITcl_FSDeleteFileProc\fR, and if \fITcl_FSCopyFileProc\fR is not
implemented there is a further fallback).  However, if a
\fITcl_FSRenameFileProc\fR command is issued at the C level, no such
fallbacks occur.  This is true except for the last four entries in the
filesystem table (\fBlstat\fR, \fBload\fR, \fBgetcwd\fR and \fBchdir\fR)
for which fallbacks do in fact occur at the C level.
.PP
Any functions which take path names in Tcl_Obj form take
those names in UTF\-8 form.  The filesystem infrastructure API is
designed to support efficient, cached conversion of these UTF\-8 paths
to other native representations.
.SS "EXAMPLE FILESYSTEM DEFINITION"
.PP
Here is the filesystem lookup table used by the
.QW vfs
extension which allows filesystem actions to be implemented in Tcl.
.CS
static Tcl_Filesystem vfsFilesystem = {
    "tclvfs",
    sizeof(Tcl_Filesystem),
    TCL_FILESYSTEM_VERSION_1,
    &VfsPathInFilesystem,
    &VfsDupInternalRep,
    &VfsFreeInternalRep,
    /* No internal to normalized, since we don't create
     * any pure 'internal' Tcl_Obj path representations */
    NULL,
    /* No create native rep function, since we don't use
     * it and don't choose to support uses of
     * Tcl_FSNewNativePath */
    NULL,
    /* Normalize path isn't needed - we assume paths only
     * have one representation */
    NULL,
    &VfsFilesystemPathType,
    &VfsFilesystemSeparator,
    &VfsStat,
    &VfsAccess,
    &VfsOpenFileChannel,
    &VfsMatchInDirectory,
    &VfsUtime,
    /* We choose not to support symbolic links inside our
     * VFS's */
    NULL,
    &VfsListVolumes,
    &VfsFileAttrStrings,
    &VfsFileAttrsGet,
    &VfsFileAttrsSet,
    &VfsCreateDirectory,
    &VfsRemoveDirectory,
    &VfsDeleteFile,
    /* No copy file; use the core fallback mechanism */
    NULL,
    /* No rename file; use the core fallback mechanism */
    NULL,
    /* No copy directory; use the core fallback mechanism */
    NULL,
    /* Core will use stat for lstat */
    NULL,
    /* No load; use the core fallback mechanism */
    NULL,
    /* We don't need a getcwd or chdir; the core's own
     * internal value is suitable */
    NULL,
    NULL
};
.CE
.SH "FILESYSTEM INFRASTRUCTURE"
.PP
These fields contain basic information about the filesystem structure
and addresses of functions which are used to associate
a particular filesystem with a file path, and deal with the internal
handling of path representations, for example copying and freeing such
representations.
.SS TYPENAME
.PP
The \fItypeName\fR field contains a null-terminated string that
identifies the type of the filesystem implemented, e.g.
.QW native ,
.QW zip
or
.QW vfs .
.SS "STRUCTURE LENGTH"
.PP
The \fIstructureLength\fR field is generally implemented as
\fIsizeof(Tcl_Filesystem)\fR, and is there to allow easier
binary backwards compatibility if the size of the structure
changes in a future Tcl release.
.SS VERSION
.PP
The \fIversion\fR field should be set to \fBTCL_FILESYSTEM_VERSION_1\fR.
.SS PATHINFILESYSTEMPROC
.PP
The \fIpathInFilesystemProc\fR field contains the address of a function
which is called to determine whether a given path object belongs to this
filesystem or not.  Tcl will only call the rest of the filesystem
functions with a path for which this function has returned \fBTCL_OK\fR.
If the path does not belong, -1 should be returned (the behaviour of Tcl
for any other return value is not defined).  If \fBTCL_OK\fR is returned,
then the optional \fIclientDataPtr\fR output parameter can be used to
return an internal (filesystem specific) representation of the path,
which will be cached inside the path object, and may be retrieved
efficiently by the other filesystem functions.  Tcl will simultaneously
cache the fact that this path belongs to this filesystem.  Such caches
are invalidated when filesystem structures are added or removed from
Tcl's internal list of known filesystems.
.PP
.CS
typedef int Tcl_FSPathInFilesystemProc(
        Tcl_Obj *\fIpathPtr\fR,
        ClientData *\fIclientDataPtr\fR);
.CE
.SS DUPINTERNALREPPROC
.PP
This function makes a copy of a path's internal representation, and is
called when Tcl needs to duplicate a path object.  If NULL, Tcl will
simply not copy the internal representation, which may then need to be
regenerated later.
.PP
.CS
typedef ClientData Tcl_FSDupInternalRepProc(
        ClientData \fIclientData\fR);
.CE
.SS FREEINTERNALREPPROC
Free the internal representation.  This must be implemented if internal
representations need freeing (i.e. if some memory is allocated when an
internal representation is generated), but may otherwise be NULL.
.PP
.CS
typedef void Tcl_FSFreeInternalRepProc(
        ClientData \fIclientData\fR);
.CE
.SS INTERNALTONORMALIZEDPROC
.PP
Function to convert internal representation to a normalized path.  Only
required if the filesystem creates pure path objects with no string/path
representation.  The return value is a Tcl object whose string
representation is the normalized path.
.PP
.CS
typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(
        ClientData \fIclientData\fR);
.CE
.SS CREATEINTERNALREPPROC
.PP
Function to take a path object, and calculate an internal
representation for it, and store that native representation in the
object.  May be NULL if paths have no internal representation, or if
the \fITcl_FSPathInFilesystemProc\fR for this filesystem always
immediately creates an internal representation for paths it accepts.
.PP
.CS
typedef ClientData Tcl_FSCreateInternalRepProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS NORMALIZEPATHPROC
.PP
Function to normalize a path.  Should be implemented for all
filesystems which can have multiple string representations for the same
path object.  In Tcl, every
.QW path
must have a single unique
.QW normalized
string representation.  Depending on the filesystem,
there may be more than one unnormalized string representation which
refers to that path (e.g. a relative path, a path with different
character case if the filesystem is case insensitive, a path contain a
reference to a home directory such as
.QW ~ ,
a path containing symbolic
links, etc).  If the very last component in the path is a symbolic
link, it should not be converted into the object it points to (but
its case or other aspects should be made unique).  All other path
components should be converted from symbolic links.  This one
exception is required to agree with Tcl's semantics with \fBfile
delete\fR, \fBfile rename\fR, \fBfile copy\fR operating on symbolic links.
This function may be called with \fInextCheckpoint\fR either
at the beginning of the path (i.e. zero), at the end of the path, or
at any intermediate file separator in the path.  It will never
point to any other arbitrary position in the path. In the last of
the three valid cases, the implementation can assume that the path
up to and including the file separator is known and normalized.
.PP
.CS
typedef int Tcl_FSNormalizePathProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        int \fInextCheckpoint\fR);
.CE
.SH "FILESYSTEM OPERATIONS"
.PP
The fields in this section of the structure contain addresses of
functions which are called to carry out the basic filesystem
operations.  A filesystem which expects to be used with the complete
standard Tcl command set must implement all of these.  If some of
them are not implemented, then certain Tcl commands may fail when
operating on paths within that filesystem.  However, in some instances
this may be desirable (for example, a read-only filesystem should not
implement the last four functions, and a filesystem which does not
support symbolic links need not implement the \fBreadlink\fR function,
etc.  The Tcl core expects filesystems to behave in this way).
.SS FILESYSTEMPATHTYPEPROC
.PP
Function to determine the type of a path in this filesystem.  May be
NULL, in which case no type information will be available to users of
the filesystem.  The
.QW type
is used only for informational purposes,
and should be returned as the string representation of the Tcl_Obj
which is returned.  A typical return value might be
.QW networked ,
.QW zip
or
.QW ftp .
The Tcl_Obj result is owned by the filesystem and so Tcl will
increment the refCount of that object if it wishes to retain a reference
to it.
.PP
.CS
typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS FILESYSTEMSEPARATORPROC
.PP
Function to return the separator character(s) for this filesystem.
This need only be implemented if the filesystem wishes to use a
different separator than the standard string
.QW / .
Amongst other
uses, it is returned by the \fBfile separator\fR command.  The
return value should be an object with refCount of zero.
.PP
.CS
typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS STATPROC
.PP
Function to process a \fBTcl_FSStat\fR call.  Must be implemented for any
reasonable filesystem, since many Tcl level commands depend crucially
upon it (e.g. \fBfile atime\fR, \fBfile isdirectory\fR, \fBfile size\fR,
\fBglob\fR).
.PP
.CS
typedef int Tcl_FSStatProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_StatBuf *\fIstatPtr\fR);
.CE
.PP
The \fBTcl_FSStatProc\fR fills the stat structure \fIstatPtr\fR with
information about the specified file.  You do not need any access
rights to the file to get this information but you need search rights
to all directories named in the path leading to the file.  The stat
structure includes info regarding device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), group id (always 0 on Windows), rdev (same as device on
Windows), size, last access time, last modification time, and creation
time.
.PP
If the file represented by \fIpathPtr\fR exists, the
\fBTcl_FSStatProc\fR returns 0 and the stat structure is filled with
data.  Otherwise, -1 is returned, and no stat info is given.
.SS ACCESSPROC
.PP
Function to process a \fBTcl_FSAccess\fR call.  Must be implemented for
any reasonable filesystem, since many Tcl level commands depend crucially
upon it (e.g. \fBfile exists\fR, \fBfile readable\fR).
.PP
.CS
typedef int Tcl_FSAccessProc(
        Tcl_Obj *\fIpathPtr\fR,
        int \fImode\fR);
.CE
.PP
The \fBTcl_FSAccessProc\fR checks whether the process would be allowed
to read, write or test for existence of the file (or other filesystem
object) whose name is in \fIpathPtr\fR.  If the pathname refers to a
symbolic link, then the
permissions of the file referred by this symbolic link should be tested.
.PP
On success (all requested permissions granted), zero is returned.  On
error (at least one bit in mode asked for a permission that is denied,
or some other  error occurred), -1 is returned.
.SS OPENFILECHANNELPROC
.PP
Function to process a \fBTcl_FSOpenFileChannel\fR call.  Must be
implemented for any reasonable filesystem, since any operations
which require open or accessing a file's contents will use it
(e.g. \fBopen\fR, \fBencoding\fR, and many Tk commands).
.PP
.CS
typedef Tcl_Channel Tcl_FSOpenFileChannelProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        int \fImode\fR,
        int \fIpermissions\fR);
.CE
.PP
The \fBTcl_FSOpenFileChannelProc\fR opens a file specified by
\fIpathPtr\fR and returns a channel handle that can be used to perform
input and output on the file.  This API is modeled after the \fBfopen\fR
procedure of the Unix standard I/O library.  The syntax and meaning of
all arguments is similar to those given in the Tcl \fBopen\fR command
when opening a file, where the \fImode\fR argument is a combination of
the POSIX flags O_RDONLY, O_WRONLY, etc.  If an error occurs while
opening the channel, the \fBTcl_FSOpenFileChannelProc\fR returns NULL and
records a POSIX error code that can be retrieved with \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, the
\fBTcl_FSOpenFileChannelProc\fR leaves an error message in \fIinterp\fR's
result after any error.
.PP
The newly created channel is not registered in the supplied
interpreter; to register it, use \fBTcl_RegisterChannel\fR. If one of
the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, the act of creating the new channel also assigns it
as a replacement for the standard channel.
.SS MATCHINDIRECTORYPROC
.PP
Function to process a \fBTcl_FSMatchInDirectory\fR call.  If not
implemented, then glob and recursive copy functionality will be lacking
in the filesystem (and this may impact commands like \fBencoding names\fR
which use glob functionality internally).
.PP
.CS
typedef int Tcl_FSMatchInDirectoryProc(
        Tcl_Interp* \fIinterp\fR,
        Tcl_Obj *\fIresultPtr\fR,
        Tcl_Obj *\fIpathPtr\fR,
        const char *\fIpattern\fR,
        Tcl_GlobTypeData *\fItypes\fR);
.CE
.PP
The function should return all files or directories (or other filesystem
objects) which match the given pattern and accord with the \fItypes\fR
specification given.  There are two ways in which this function may be
called.  If \fIpattern\fR is NULL, then \fIpathPtr\fR is a full path
specification of a single file or directory which should be checked for
existence and correct type.  Otherwise, \fIpathPtr\fR is a directory, the
contents of which the function should search for files or directories
which have the correct type.  In either case, \fIpathPtr\fR can be
assumed to be both non-NULL and non-empty.  It is not currently
documented whether \fIpathPtr\fR will have a file separator at its end of
not, so code should be flexible to both possibilities.
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the matching process.  Error messages are placed in
\fIinterp\fR, unless \fIinterp\fR in NULL in which case no error
message need be generated; on a \fBTCL_OK\fR result, results should be 
added to the \fIresultPtr\fR object given (which can be assumed to be a 
valid unshared Tcl list).  The matches added
to \fIresultPtr\fR should include any path prefix given in \fIpathPtr\fR
(this usually means they will be absolute path specifications).
Note that if no matches are found, that simply leads to an empty
result; errors are only signaled for actual file or filesystem
problems which may occur during the matching process.
.PP
The \fBTcl_GlobTypeData\fR structure passed in the \fItypes\fR 
parameter contains the following fields:
.CS
typedef struct Tcl_GlobTypeData {
        /* Corresponds to bcdpfls as in 'find -t' */
        int \fItype\fR;
        /* Corresponds to file permissions */
        int \fIperm\fR;
        /* Acceptable mac type */
        Tcl_Obj *\fImacType\fR;
        /* Acceptable mac creator */
        Tcl_Obj *\fImacCreator\fR;
} Tcl_GlobTypeData;
.CE
.PP
There are two specific cases which it is important to handle correctly,
both when \fItypes\fR is non-NULL. The two cases are when \fItypes->types
& TCL_GLOB_TYPE_DIR\fR or \fItypes->types & TCL_GLOB_TYPE_MOUNT\fR are
true (and in particular when the other flags are false).  In the first of
these cases, the function must list the contained directories.  Tcl uses
this to implement recursive globbing, so it is critical that filesystems
implement directory matching correctly.  In the second of these cases,
with \fBTCL_GLOB_TYPE_MOUNT\fR, the filesystem must list the mount points
which lie within the given \fIpathPtr\fR (and in this case, \fIpathPtr\fR
need not lie within the same filesystem - different to all other cases in
which this function is called).  Support for this is critical if Tcl is
to have seamless transitions between from one filesystem to another.
.SS UTIMEPROC
.PP
Function to process a \fBTcl_FSUtime\fR call.  Required to allow setting
(not reading) of times with \fBfile mtime\fR, \fBfile atime\fR and the
open-r/open-w/fcopy implementation of \fBfile copy\fR.
.PP
.CS
typedef int Tcl_FSUtimeProc(
        Tcl_Obj *\fIpathPtr\fR,
        struct utimbuf *\fItval\fR);
.CE
.PP
The access and modification times of the file specified by \fIpathPtr\fR
should be changed to the values given in the \fItval\fR structure.
.PP
The return value should be 0 on success and -1 on an error, as
with the system \fButime\fR.
.SS LINKPROC
.PP
Function to process a \fBTcl_FSLink\fR call.  Should be implemented
only if the filesystem supports links, and may otherwise be NULL.
.PP
.CS
typedef Tcl_Obj* Tcl_FSLinkProc(
        Tcl_Obj *\fIlinkNamePtr\fR,
        Tcl_Obj *\fItoPtr\fR,
        int \fIlinkAction\fR);
.CE
.PP
If \fItoPtr\fR is NULL, the function is being asked to read the
contents of a link.  The result is a Tcl_Obj specifying the contents of
the link given by \fIlinkNamePtr\fR, or NULL if the link could
not be read.  The result is owned by the caller (and should therefore
have its ref count incremented before being returned).  Any callers
should call Tcl_DecrRefCount on this result when it is no longer needed.
If \fItoPtr\fR is not NULL, the function should attempt to create a link.
The result in this case should be \fItoPtr\fR if the link was successful
and NULL otherwise.  In this case the result is not owned by the caller
(i.e. no ref count manipulation on either end is needed). See
the documentation for \fBTcl_FSLink\fR for the correct interpretation
of the \fIlinkAction\fR flags.
.SS LISTVOLUMESPROC
.PP
Function to list any filesystem volumes added by this filesystem.
Should be implemented only if the filesystem adds volumes at the head
of the filesystem, so that they can be returned by \fBfile volumes\fR.
.PP
.CS
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);
.CE
.PP
The result should be a list of volumes added by this filesystem, or
NULL (or an empty list) if no volumes are provided.  The result object
is considered to be owned by the filesystem (not by Tcl's core), but
should be given a refCount for Tcl.  Tcl will use the contents of the
list and then decrement that refCount.  This allows filesystems to
choose whether they actually want to retain a
.QW "master list"
of volumes
or not (if not, they generate the list on the fly and pass it to Tcl
with a refCount of 1 and then forget about the list, if yes, then
they simply increment the refCount of their master list and pass it
to Tcl which will copy the contents and then decrement the count back
to where it was).
.PP
Therefore, Tcl considers return values from this proc to be read-only.
.SS FILEATTRSTRINGSPROC
.PP
Function to list all attribute strings which are valid for this
filesystem.  If not implemented the filesystem will not support
the \fBfile attributes\fR command.  This allows arbitrary additional
information to be attached to files in the filesystem.  If it is
not implemented, there is no need to implement the \fBget\fR and \fBset\fR
methods.
.PP
.CS
typedef const char** Tcl_FSFileAttrStringsProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj** \fIobjPtrRef\fR);
.CE
.PP
The called function may either return an array of strings, or may
instead return NULL and place a Tcl list into the given \fIobjPtrRef\fR.  Tcl
will take that list and first increment its reference count before using it.
On completion of that use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, and if the list should not be disposed of, the
filesystem should ensure it returns an object with a reference count
of at least one.
.SS FILEATTRSGETPROC
.PP
Function to process a \fBTcl_FSFileAttrsGet\fR call, used by \fBfile
attributes\fR.
.PP
.CS
typedef int Tcl_FSFileAttrsGetProc(
        Tcl_Interp *\fIinterp\fR,
        int \fIindex\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj **\fIobjPtrRef\fR);
.CE
.PP
Returns a standard Tcl return code.  The attribute value retrieved,
which corresponds to the \fIindex\fR'th element in the list returned by
the \fBTcl_FSFileAttrStringsProc\fR, is a Tcl_Obj placed in \fIobjPtrRef\fR (if
\fBTCL_OK\fR was returned) and is likely to have a reference count of zero.  Either
way we must either store it somewhere (e.g. the Tcl result), or
Incr/Decr its reference count to ensure it is properly freed.
.SS FILEATTRSSETPROC
.PP
Function to process a \fBTcl_FSFileAttrsSet\fR call, used by \fBfile
attributes\fR.  If the filesystem is read-only, there is no need
to implement this.
.PP
.CS
typedef int Tcl_FSFileAttrsSetProc(
        Tcl_Interp *\fIinterp\fR,
        int \fIindex\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj *\fIobjPtr\fR);
.CE
.PP
The attribute value of the \fIindex\fR'th element in the list returned by
the Tcl_FSFileAttrStringsProc should be set to the \fIobjPtr\fR given.
.SS CREATEDIRECTORYPROC
.PP
Function to process a \fBTcl_FSCreateDirectory\fR call.  Should be
implemented unless the FS is read-only.
.PP
.CS
typedef int Tcl_FSCreateDirectoryProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, a new directory should have
been added to the filesystem in the location specified by
\fIpathPtr\fR.
.SS REMOVEDIRECTORYPROC
.PP
Function to process a \fBTcl_FSRemoveDirectory\fR call.  Should be
implemented unless the FS is read-only.
.PP
.CS
typedef int Tcl_FSRemoveDirectoryProc(
        Tcl_Obj *\fIpathPtr\fR,
        int \fIrecursive\fR,
        Tcl_Obj **\fIerrorPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, the directory specified by
\fIpathPtr\fR should have been removed from the filesystem.  If the
\fIrecursive\fR flag is given, then a non-empty directory should be
deleted without error.  If this flag is not given, then and the
directory is non-empty a POSIX
.QW EEXIST
error should be signaled.  If an
error does occur, the name of the file or directory which caused the
error should be placed in \fIerrorPtr\fR.
.SS DELETEFILEPROC
.PP
Function to process a \fBTcl_FSDeleteFile\fR call.  Should be implemented
unless the FS is read-only.
.PP
.CS
typedef int Tcl_FSDeleteFileProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the process.  If successful, the file specified by
\fIpathPtr\fR should have been removed from the filesystem.  Note that,
if the filesystem supports symbolic links, Tcl will always call this
function and not Tcl_FSRemoveDirectoryProc when needed to delete them
(even if they are symbolic links to directories).
.SH "FILESYSTEM EFFICIENCY"
.PP
These functions need not be implemented for a particular filesystem
because the core has a fallback implementation available. See each
individual description for the consequences of leaving the field NULL.
.SS LSTATPROC
.PP
Function to process a \fBTcl_FSLstat\fR call.  If not implemented, Tcl
will attempt to use the \fIstatProc\fR defined above instead.  Therefore
it need only be implemented if a filesystem can differentiate between
\fBstat\fR and \fBlstat\fR calls.
.PP
.CS
typedef int Tcl_FSLstatProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_StatBuf *\fIstatPtr\fR);
.CE
.PP
The behavior of this function is very similar to that of the
\fBTcl_FSStatProc\fR defined above, except that if it is applied
to a symbolic link, it returns information about the link, not
about the target file.
.SS COPYFILEPROC
.PP
Function to process a \fBTcl_FSCopyFile\fR call.  If not implemented Tcl
will fall back on \fBopen\fR-r, \fBopen\fR-w and \fBfcopy\fR as a
copying mechanism.
Therefore it need only be implemented if the filesystem can perform
that action more efficiently.
.PP
.CS
typedef int Tcl_FSCopyFileProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the copying process.  Note that, \fIdestPathPtr\fR is the
name of the file which should become the copy of \fIsrcPathPtr\fR. It
is never the name of a directory into which \fIsrcPathPtr\fR could be
copied (i.e. the function is much simpler than the Tcl level \fBfile
copy\fR subcommand).  Note that,
if the filesystem supports symbolic links, Tcl will always call this
function and not \fIcopyDirectoryProc\fR when needed to copy them
(even if they are symbolic links to directories).  Finally, if the
filesystem determines it cannot support the \fBfile copy\fR action,
calling \fBTcl_SetErrno(EXDEV)\fR and returning a non-\fBTCL_OK\fR
result will tell Tcl to use its standard fallback mechanisms.
.SS RENAMEFILEPROC
.PP
Function to process a \fBTcl_FSRenameFile\fR call.  If not implemented,
Tcl will fall back on a copy and delete mechanism.  Therefore it need
only be implemented if the filesystem can perform that action more
efficiently.
.PP
.CS
typedef int Tcl_FSRenameFileProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the renaming process.  If the
filesystem determines it cannot support the \fBfile rename\fR action,
calling \fBTcl_SetErrno(EXDEV)\fR and returning a non-\fBTCL_OK\fR
result will tell Tcl to use its standard fallback mechanisms.
.SS COPYDIRECTORYPROC
.PP
Function to process a \fBTcl_FSCopyDirectory\fR call.  If not
implemented, Tcl will fall back on a recursive \fBfile mkdir\fR, \fBfile copy\fR
mechanism.  Therefore it need only be implemented if the filesystem can
perform that action more efficiently.
.PP
.CS
typedef int Tcl_FSCopyDirectoryProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR,
        Tcl_Obj **\fIerrorPtr\fR);
.CE
.PP
The return value is a standard Tcl result indicating whether an error
occurred in the copying process.  If an error does occur, the name of
the file or directory which caused the error should be placed in
\fIerrorPtr\fR. Note that, \fIdestPathPtr\fR is the name of the
directory-name which should become the mirror-image of
\fIsrcPathPtr\fR. It is not the name of a directory into which
\fIsrcPathPtr\fR should be copied (i.e. the function is much simpler
than the Tcl level \fBfile copy\fR subcommand).  Finally, if the
filesystem determines it cannot support the directory copy action,
calling \fBTcl_SetErrno(EXDEV)\fR and returning a non-\fBTCL_OK\fR
result will tell Tcl to use its standard fallback mechanisms.
.SS LOADFILEPROC
.PP
Function to process a \fBTcl_FSLoadFile\fR call.  If not implemented, Tcl
will fall back on a copy to native-temp followed by a \fBTcl_FSLoadFile\fR on
that temporary copy.  Therefore it need only be implemented if the
filesystem can load code directly, or it can be implemented simply to
return \fBTCL_ERROR\fR to disable load functionality in this filesystem
entirely.
.PP
.CS
typedef int Tcl_FSLoadFileProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_LoadHandle *\fIhandlePtr\fR,
        Tcl_FSUnloadFileProc *\fIunloadProcPtr\fR);
.CE
.PP
Returns a standard Tcl completion code.  If an error occurs, an error
message is left in the \fIinterp\fR's result.  The function dynamically loads a
binary code file into memory.  On a successful load, the \fIhandlePtr\fR
should be filled with a token for the dynamically loaded file, and the
\fIunloadProcPtr\fR should be filled in with the address of a procedure.
The unload procedure will be called with the given \fBTcl_LoadHandle\fR as its
only parameter when Tcl needs to unload the file.  For example, for the
native filesystem, the \fBTcl_LoadHandle\fR returned is currently a token
which can be used in the private \fBTclpFindSymbol\fR to access functions
in the new code.  Each filesystem is free to define the
\fBTcl_LoadHandle\fR as it requires.  Finally, if the
filesystem determines it cannot support the file load action,
calling \fBTcl_SetErrno(EXDEV)\fR and returning a non-\fBTCL_OK\fR
result will tell Tcl to use its standard fallback mechanisms.
.SS UNLOADFILEPROC
.PP
Function to unload a previously successfully loaded file.  If load was
implemented, then this should also be implemented, if there is any
cleanup action required.
.PP
.CS
typedef void Tcl_FSUnloadFileProc(
        Tcl_LoadHandle \fIloadHandle\fR);
.CE
.SS GETCWDPROC     
.PP
Function to process a \fBTcl_FSGetCwd\fR call.  Most filesystems need not
implement this.  It will usually only be called once, if \fBgetcwd\fR is
called before \fBchdir\fR.  May be NULL.
.PP
.CS
typedef Tcl_Obj* Tcl_FSGetCwdProc(
        Tcl_Interp *\fIinterp\fR);
.CE
.PP
If the filesystem supports a native notion of a current working
directory (which might perhaps change independent of Tcl), this
function should return that cwd as the result, or NULL if the current
directory could not be determined (e.g. the user does not have
appropriate permissions on the cwd directory).  If NULL is returned, an
error message is left in the \fIinterp\fR's result.
.SS CHDIRPROC
.PP
Function to process a \fBTcl_FSChdir\fR call.  If filesystems do not
implement this, it will be emulated by a series of directory access
checks.  Otherwise, virtual filesystems which do implement it need only
respond with a positive return result if the \fIpathPtr\fR is a valid,
accessible directory in their filesystem.  They need not remember the
result, since that will be automatically remembered for use by
\fBTcl_FSGetCwd\fR.
Real filesystems should carry out the correct action (i.e. call the
correct system \fBchdir\fR API).
.PP
.CS
typedef int Tcl_FSChdirProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
The \fBTcl_FSChdirProc\fR changes the applications current working
directory to the value specified in \fIpathPtr\fR. The function returns
-1 on error or 0 on success.
.SH "SEE ALSO"
cd(n), file(n), load(n), open(n), pwd(n), unload(n)
.SH KEYWORDS
stat, access, filesystem, vfs, virtual
                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AllowExceptions.3tcl                     0100644 0001750 0001750 00000016574 12566232323 025402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: AllowExc.3,v 1.5 2004/10/07 14:44:31 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_AllowExceptions 3 7.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_AllowExceptions \- allow all exceptions in next script evaluation
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_AllowExceptions\fR(\fIinterp\fR)
.SH ARGUMENTS
.AS Tcl_Interp *interp
.AP Tcl_Interp *interp in
Interpreter in which script will be evaluated.
.BE

.SH DESCRIPTION
.PP
If a script is evaluated at top-level (i.e. no other scripts are
pending evaluation when the script is invoked), and if the script
terminates with a completion code other than \fBTCL_OK\fR, \fBTCL_ERROR\fR
or \fBTCL_RETURN\fR, then Tcl normally converts this into a \fBTCL_ERROR\fR
return with an appropriate message.  The particular script
evaluation procedures of Tcl that act in the manner are
\fBTcl_EvalObjEx\fR, \fBTcl_EvalObjv\fR, \fBTcl_Eval\fR, \fBTcl_EvalEx\fR,
\fBTcl_GlobalEval\fR, \fBTcl_GlobalEvalObj\fR, \fBTcl_VarEval\fR and
\fBTcl_VarEvalVA\fR. 
.PP
However, if \fBTcl_AllowExceptions\fR is invoked immediately before
calling one of those a procedures, then arbitrary completion
codes are permitted from the script, and they are returned without
modification.
This is useful in cases where the caller can deal with exceptions
such as \fBTCL_BREAK\fR or \fBTCL_CONTINUE\fR in a meaningful way.

.SH KEYWORDS
continue, break, exception, interpreter
                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AppInit.3tcl                             0100644 0001750 0001750 00000020765 12566232323 023623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: AppInit.3,v 1.9 2007/12/13 15:22:30 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_AppInit 3 7.0 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_AppInit \- perform application-specific initialization
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_AppInit\fR(\fIinterp\fR)
.SH ARGUMENTS
.AS Tcl_Interp *interp
.AP Tcl_Interp *interp in
Interpreter for the application.
.BE

.SH DESCRIPTION
.PP
\fBTcl_AppInit\fR is a
.QW hook
procedure that is invoked by
the main programs for Tcl applications such as \fBtclsh\fR and \fBwish\fR.
Its purpose is to allow new Tcl applications to be created without
modifying the main programs provided as part of Tcl and Tk.
To create a new application you write a new version of
\fBTcl_AppInit\fR to replace the default version provided by Tcl,
then link your new \fBTcl_AppInit\fR with the Tcl library.
.PP
\fBTcl_AppInit\fR is invoked by \fBTcl_Main\fR and \fBTk_Main\fR
after their own initialization and before entering the main loop
to process commands.
Here are some examples of things that \fBTcl_AppInit\fR might do:
.IP [1]
Call initialization procedures for various packages used by
the application.
Each initialization procedure adds new commands to \fIinterp\fR
for its package and performs other package-specific initialization.
.IP [2]
Process command-line arguments, which can be accessed from the
Tcl variables \fBargv\fR and \fBargv0\fR in \fIinterp\fR.
.IP [3]
Invoke a startup script to initialize the application.
.LP
\fBTcl_AppInit\fR returns \fBTCL_OK\fR or \fBTCL_ERROR\fR.
If it returns \fBTCL_ERROR\fR then it must leave an error message in
for the interpreter's result;  otherwise the result is ignored.
.PP
In addition to \fBTcl_AppInit\fR, your application should also contain
a procedure \fBmain\fR that calls \fBTcl_Main\fR as follows:
.CS
Tcl_Main(argc, argv, Tcl_AppInit);
.CE
The third argument to \fBTcl_Main\fR gives the address of the
application-specific initialization procedure to invoke.
This means that you do not have to use the name \fBTcl_AppInit\fR
for the procedure, but in practice the name is nearly always
\fBTcl_AppInit\fR (in versions before Tcl 7.4 the name \fBTcl_AppInit\fR
was implicit;  there was no way to specify the procedure explicitly).
The best way to get started is to make a copy of the file
\fBtclAppInit.c\fR from the Tcl library or source directory.
It already contains a \fBmain\fR procedure and a template for
\fBTcl_AppInit\fR that you can modify for your application.

.SH KEYWORDS
application, argument, command, initialization, interpreter
           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AppendAllObjTypes.3tcl                   0100644 0001750 0001750 00000037577 12566232342 025611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: ObjectType.3,v 1.16.2.3 2009/11/27 14:53:54 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_ObjType 3 8.0 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_RegisterObjType, Tcl_GetObjType, Tcl_AppendAllObjTypes, Tcl_ConvertToType  \- manipulate Tcl object types
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_RegisterObjType\fR(\fItypePtr\fR)
.sp
Tcl_ObjType *
\fBTcl_GetObjType\fR(\fItypeName\fR)
.sp
int
\fBTcl_AppendAllObjTypes\fR(\fIinterp, objPtr\fR)
.sp
int
\fBTcl_ConvertToType\fR(\fIinterp, objPtr, typePtr\fR)
.SH ARGUMENTS
.AS "const char" *typeName
.AP Tcl_ObjType *typePtr in
Points to the structure containing information about the Tcl object type.
This storage must live forever,
typically by being statically allocated.
.AP "const char" *typeName in
The name of a Tcl object type that \fBTcl_GetObjType\fR should look up.
.AP Tcl_Interp *interp in
Interpreter to use for error reporting.
.AP Tcl_Obj *objPtr in
For \fBTcl_AppendAllObjTypes\fR, this points to the object onto which
it appends the name of each object type as a list element.
For \fBTcl_ConvertToType\fR, this points to an object that
must have been the result of a previous call to \fBTcl_NewObj\fR.
.BE

.SH DESCRIPTION
.PP
The procedures in this man page manage Tcl object types.
They are used to register new object types, look up types,
and force conversions from one type to another.
.PP
\fBTcl_RegisterObjType\fR registers a new Tcl object type
in the table of all object types that \fBTcl_GetObjType\fR
can look up by name.  There are other object types supported by Tcl
as well, which Tcl chooses not to register.  Extensions can likewise
choose to register the object types they create or not.
The argument \fItypePtr\fR points to a Tcl_ObjType structure that
describes the new type by giving its name
and by supplying pointers to four procedures
that implement the type.
If the type table already contains a type
with the same name as in \fItypePtr\fR,
it is replaced with the new type.
The Tcl_ObjType structure is described
in the section \fBTHE TCL_OBJTYPE STRUCTURE\fR below.
.PP
\fBTcl_GetObjType\fR returns a pointer to the registered Tcl_ObjType
with name \fItypeName\fR.
It returns NULL if no type with that name is registered.
.PP
\fBTcl_AppendAllObjTypes\fR appends the name of each registered object type
as a list element onto the Tcl object referenced by \fIobjPtr\fR.
The return value is \fBTCL_OK\fR unless there was an error
converting \fIobjPtr\fR to a list object;
in that case \fBTCL_ERROR\fR is returned.
.PP
\fBTcl_ConvertToType\fR converts an object from one type to another
if possible.
It creates a new internal representation for \fIobjPtr\fR
appropriate for the target type \fItypePtr\fR
and sets its \fItypePtr\fR member as determined by calling the 
\fItypePtr->setFromAnyProc\fR routine.  
Any internal representation for \fIobjPtr\fR's old type is freed.
If an error occurs during conversion, it returns \fBTCL_ERROR\fR
and leaves an error message in the result object for \fIinterp\fR
unless \fIinterp\fR is NULL.
Otherwise, it returns \fBTCL_OK\fR.
Passing a NULL \fIinterp\fR allows this procedure to be used
as a test whether the conversion can be done (and in fact was done).
.VS 8.5
.PP
In many cases, the \fItypePtr->setFromAnyProc\fR routine will
set \fIobjPtr->typePtr\fR to the argument value \fItypePtr\fR,
but that is no longer guaranteed.  The \fIsetFromAnyProc\fR is
free to set the internal representation for \fIobjPtr\fR to make
use of another related Tcl_ObjType, if it sees fit.
.VE 8.5
.SH "THE TCL_OBJTYPE STRUCTURE"
.PP
Extension writers can define new object types by defining four
procedures and
initializing a Tcl_ObjType structure to describe the type.
Extension writers may also pass a pointer to their Tcl_ObjType
structure to \fBTcl_RegisterObjType\fR if they wish to permit
other extensions to look up their Tcl_ObjType by name with
the \fBTcl_GetObjType\fR routine.
The \fBTcl_ObjType\fR structure is defined as follows:
.PP
.CS
typedef struct Tcl_ObjType {
    char *\fIname\fR;
    Tcl_FreeInternalRepProc *\fIfreeIntRepProc\fR;
    Tcl_DupInternalRepProc *\fIdupIntRepProc\fR;
    Tcl_UpdateStringProc *\fIupdateStringProc\fR;
    Tcl_SetFromAnyProc *\fIsetFromAnyProc\fR;
} Tcl_ObjType;
.CE
.SS "THE NAME FIELD"
.PP
The \fIname\fR member describes the name of the type, e.g. \fBint\fR.
When a type is registered, this is the name used by callers
of \fBTcl_GetObjType\fR to lookup the type.  For unregistered
types, the \fIname\fR field is primarily of value for debugging.
The remaining four members are pointers to procedures
called by the generic Tcl object code:
.SS "THE SETFROMANYPROC FIELD"
.PP
The \fIsetFromAnyProc\fR member contains the address of a function
called to create a valid internal representation
from an object's string representation.
.PP
.CS
typedef int (Tcl_SetFromAnyProc) (Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIobjPtr\fR);
.CE
.PP
If an internal representation cannot be created from the string,
it returns \fBTCL_ERROR\fR and puts a message
describing the error in the result object for \fIinterp\fR
unless \fIinterp\fR is NULL.
If \fIsetFromAnyProc\fR is successful,
it stores the new internal representation,
sets \fIobjPtr\fR's \fItypePtr\fR member to point to
the \fBTcl_ObjType\fR struct corresponding to the new
internal representation, and returns \fBTCL_OK\fR.
Before setting the new internal representation,
the \fIsetFromAnyProc\fR must free any internal representation
of \fIobjPtr\fR's old type;
it does this by calling the old type's \fIfreeIntRepProc\fR
if it is not NULL.
.PP
As an example, the \fIsetFromAnyProc\fR for the built-in Tcl list type
gets an up-to-date string representation for \fIobjPtr\fR
by calling \fBTcl_GetStringFromObj\fR.
It parses the string to verify it is in a valid list format and
to obtain each element value in the list, and, if this succeeds,
stores the list elements in \fIobjPtr\fR's internal representation
and sets \fIobjPtr\fR's \fItypePtr\fR member to point to the list type's
Tcl_ObjType structure.
.PP
Do not release \fIobjPtr\fR's old internal representation unless you
replace it with a new one or reset the \fItypePtr\fR member to NULL.
.PP
The \fIsetFromAnyProc\fR member may be set to NULL, if the routines
making use of the internal representation have no need to derive that
internal representation from an arbitrary string value.  However, in
this case, passing a pointer to the type to Tcl_ConvertToType() will
lead to a panic, so to avoid this possibility, the type
should \fInot\fR be registered.
.SS "THE UPDATESTRINGPROC FIELD"
.PP
The \fIupdateStringProc\fR member contains the address of a function
called to create a valid string representation
from an object's internal representation.
.PP
.CS
typedef void (Tcl_UpdateStringProc) (Tcl_Obj *\fIobjPtr\fR);
.CE
.PP
\fIobjPtr\fR's \fIbytes\fR member is always NULL when it is called.
It must always set \fIbytes\fR non-NULL before returning.
We require the string representation's byte array
to have a null after the last byte, at offset \fIlength\fR,
and to have no null bytes before that; this allows string representations 
to be treated as conventional null character-terminated C strings.
These restrictions are easily met by using Tcl's internal UTF encoding
for the string representation, same as one would do for other
Tcl routines accepting string values as arguments.
Storage for the byte array must be allocated in the heap by \fBTcl_Alloc\fR
or \fBckalloc\fR.  Note that \fIupdateStringProc\fRs must allocate
enough storage for the string's bytes and the terminating null byte.
.PP
The \fIupdateStringProc\fR for Tcl's built-in double type, for example,
calls Tcl_PrintDouble to write to a buffer of size TCL_DOUBLE_SPACE,
then allocates and copies the string representation to just enough
space to hold it.  A pointer to the allocated space is stored in
the \fIbytes\fR member.
.PP
The \fIupdateStringProc\fR member may be set to NULL, if the routines
making use of the internal representation are written so that the
string representation is never invalidated.  Failure to meet this
obligation will lead to panics or crashes when \fBTcl_GetStringFromObj\fR
or other similar routines ask for the string representation.
.SS "THE DUPINTREPPROC FIELD"
.PP
The \fIdupIntRepProc\fR member contains the address of a function
called to copy an internal representation from one object to another.
.PP
.CS
typedef void (Tcl_DupInternalRepProc) (Tcl_Obj *\fIsrcPtr\fR,
        Tcl_Obj *\fIdupPtr\fR);
.CE
.PP
\fIdupPtr\fR's internal representation is made a copy of \fIsrcPtr\fR's
internal representation.
Before the call,
\fIsrcPtr\fR's internal representation is valid and \fIdupPtr\fR's is not.
\fIsrcPtr\fR's object type determines what
copying its internal representation means.
.PP
For example, the \fIdupIntRepProc\fR for the Tcl integer type
simply copies an integer.
The built-in list type's \fIdupIntRepProc\fR uses a far more
sophisticated scheme to continue sharing storage as much as it
reasonably can.
.SS "THE FREEINTREPPROC FIELD"
.PP
The \fIfreeIntRepProc\fR member contains the address of a function
that is called when an object is freed.
.PP
.CS
typedef void (Tcl_FreeInternalRepProc) (Tcl_Obj *\fIobjPtr\fR);
.CE
.PP
The \fIfreeIntRepProc\fR function can deallocate the storage
for the object's internal representation
and do other type-specific processing necessary when an object is freed.
.PP
For example, the list type's \fIfreeIntRepProc\fR respects
the storage sharing scheme established by the \fIdupIntRepProc\fR
so that it only frees storage when the last object sharing it
is being freed.
.PP
The \fIfreeIntRepProc\fR member can be set to NULL
to indicate that the internal representation does not require freeing.
The \fIfreeIntRepProc\fR implementation must not access the
\fIbytes\fR member of the object, since Tcl makes its own internal
uses of that field during object deletion.  The defined tasks for
the \fIfreeIntRepProc\fR have no need to consult the \fIbytes\fR
member.
.SH "SEE ALSO"
Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount
.SH KEYWORDS
internal representation, object, object type, string representation, type conversion
                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Tcl_AppendElement.3tcl                       0100644 0001750 0001750 00000036604 12566232346 025004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: SetResult.3,v 1.18.2.1 2009/11/27 14:53:54 dkf Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_SetResult 3 8.0 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_SetObjResult, Tcl_GetObjResult, Tcl_SetResult, Tcl_GetStringResult, Tcl_AppendResult, Tcl_AppendResultVA, Tcl_AppendElement, Tcl_ResetResult, Tcl_FreeResult \- manipulate Tcl result
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_SetObjResult\fR(\fIinterp, objPtr\fR)
.sp
Tcl_Obj *
\fBTcl_GetObjResult\fR(\fIinterp\fR)
.sp
\fBTcl_SetResult\fR(\fIinterp, result, freeProc\fR)
.sp
const char *
\fBTcl_GetStringResult\fR(\fIinterp\fR)
.sp
\fBTcl_AppendResult\fR(\fIinterp, result, result, ... , \fB(char *) NULL\fR)
.sp
\fBTcl_AppendResultVA\fR(\fIinterp, argList\fR)
.sp
\fBTcl_AppendElement\fR(\fIinterp, element\fR)
.sp
\fBTcl_ResetResult\fR(\fIinterp\fR)
.sp
\fBTcl_FreeResult\fR(\fIinterp\fR)
.SH ARGUMENTS
.AS Tcl_FreeProc freeProc out
.AP Tcl_Interp *interp out
Interpreter whose result is to be modified or read.
.AP Tcl_Obj *objPtr in
Object value to become result for \fIinterp\fR.
.AP char *result in
String value to become result for \fIinterp\fR or to be
appended to the existing result.
.AP char *element in
String value to append as a list element
to the existing result of \fIinterp\fR.
.AP Tcl_FreeProc *freeProc in
Address of procedure to call to release storage at
\fIresult\fR, or \fBTCL_STATIC\fR, \fBTCL_DYNAMIC\fR, or
\fBTCL_VOLATILE\fR.
.AP va_list argList in
An argument list which must have been initialized using
\fBva_start\fR, and cleared using \fBva_end\fR.
.BE
.SH DESCRIPTION
.PP
The procedures described here are utilities for manipulating the
result value in a Tcl interpreter.
The interpreter result may be either a Tcl object or a string.
For example, \fBTcl_SetObjResult\fR and \fBTcl_SetResult\fR
set the interpreter result to, respectively, an object and a string.
Similarly, \fBTcl_GetObjResult\fR and \fBTcl_GetStringResult\fR
return the interpreter result as an object and as a string.
The procedures always keep the string and object forms
of the interpreter result consistent.
For example, if \fBTcl_SetObjResult\fR is called to set
the result to an object,
then \fBTcl_GetStringResult\fR is called,
it will return the object's string value.
.PP
\fBTcl_SetObjResult\fR
arranges for \fIobjPtr\fR to be the result for \fIinterp\fR,
replacing any existing result.
The result is left pointing to the object
referenced by \fIobjPtr\fR.
\fIobjPtr\fR's reference count is incremented
since there is now a new reference to it from \fIinterp\fR.
The reference count for any old result object
is decremented and the old result object is freed if no
references to it remain.
.PP
\fBTcl_GetObjResult\fR returns the result for \fIinterp\fR as an object.
The object's reference count is not incremented;
if the caller needs to retain a long-term pointer to the object
they should use \fBTcl_IncrRefCount\fR to increment its reference count
in order to keep it from being freed too early or accidentally changed.
.PP
\fBTcl_SetResult\fR
arranges for \fIresult\fR to be the result for the current Tcl
command in \fIinterp\fR, replacing any existing result.
The \fIfreeProc\fR argument specifies how to manage the storage
for the \fIresult\fR argument;
it is discussed in the section
\fBTHE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT\fR below.
If \fIresult\fR is \fBNULL\fR, then \fIfreeProc\fR is ignored
and \fBTcl_SetResult\fR
re-initializes \fIinterp\fR's result to point to an empty string.
.PP
\fBTcl_GetStringResult\fR returns the result for \fIinterp\fR as a string.
If the result was set to an object by a \fBTcl_SetObjResult\fR call,
the object form will be converted to a string and returned.
If the object's string representation contains null bytes,
this conversion will lose information.
For this reason, programmers are encouraged to
write their code to use the new object API procedures
and to call \fBTcl_GetObjResult\fR instead.
.PP
\fBTcl_ResetResult\fR clears the result for \fIinterp\fR
and leaves the result in its normal empty initialized state.
If the result is an object,
its reference count is decremented and the result is left
pointing to an unshared object representing an empty string.
If the result is a dynamically allocated string, its memory is free*d
and the result is left as a empty string.
\fBTcl_ResetResult\fR also clears the error state managed by
\fBTcl_AddErrorInfo\fR, \fBTcl_AddObjErrorInfo\fR,
and \fBTcl_SetErrorCode\fR.
.PP
\fBTcl_AppendResult\fR makes it easy to build up Tcl results in pieces.
It takes each of its \fIresult\fR arguments and appends them in order
to the current result associated with \fIinterp\fR.
If the result is in its initialized empty state (e.g. a command procedure
was just invoked or \fBTcl_ResetResult\fR was just called),
then \fBTcl_AppendResult\fR sets the result to the concatenation of
its \fIresult\fR arguments.
\fBTcl_AppendResult\fR may be called repeatedly as additional pieces
of the result are produced.
\fBTcl_AppendResult\fR takes care of all the
storage management issues associated with managing \fIinterp\fR's
result, such as allocating a larger result area if necessary.
It also manages conversion to and from the \fIresult\fR field of the
\fIinterp\fR so as to handle backward-compatibility with old-style
extensions.
Any number of \fIresult\fR arguments may be passed in a single
call; the last argument in the list must be a NULL pointer.
.PP
\fBTcl_AppendResultVA\fR is the same as \fBTcl_AppendResult\fR except that
instead of taking a variable number of arguments it takes an argument list.
.SH "OLD STRING PROCEDURES"
.PP
Use of the following procedures (is deprecated
since they manipulate the Tcl result as a string.
Procedures such as \fBTcl_SetObjResult\fR
that manipulate the result as an object
can be significantly more efficient.
.PP
\fBTcl_AppendElement\fR is similar to \fBTcl_AppendResult\fR in
that it allows results to be built up in pieces.
However, \fBTcl_AppendElement\fR takes only a single \fIelement\fR
argument and it appends that argument to the current result
as a proper Tcl list element.
\fBTcl_AppendElement\fR adds backslashes or braces if necessary
to ensure that \fIinterp\fR's result can be parsed as a list and that
\fIelement\fR will be extracted as a single element.
Under normal conditions, \fBTcl_AppendElement\fR will add a space
character to \fIinterp\fR's result just before adding the new
list element, so that the list elements in the result are properly
separated.
However if the new list element is the first in a list or sub-list
(i.e. \fIinterp\fR's current result is empty, or consists of the
single character
.QW { ,
or ends in the characters
.QW " {" )
then no space is added.
.PP
\fBTcl_FreeResult\fR performs part of the work
of \fBTcl_ResetResult\fR.
It frees up the memory associated with \fIinterp\fR's result.
It also sets \fIinterp->freeProc\fR to zero, but does not
change \fIinterp->result\fR or clear error state.
\fBTcl_FreeResult\fR is most commonly used when a procedure
is about to replace one result value with another.
.SH "DIRECT ACCESS TO INTERP->RESULT IS DEPRECATED"
.PP
It used to be legal for programs to
directly read and write \fIinterp->result\fR
to manipulate the interpreter result.
Direct access to \fIinterp->result\fR is now strongly deprecated
because it can make the result's string and object forms inconsistent.
Programs should always read the result
using the procedures \fBTcl_GetObjResult\fR or \fBTcl_GetStringResult\fR,
and write the result using \fBTcl_SetObjResult\fR or \fBTcl_SetResult\fR.
.SH "THE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT"
.PP
\fBTcl_SetResult\fR's \fIfreeProc\fR argument specifies how 
the Tcl