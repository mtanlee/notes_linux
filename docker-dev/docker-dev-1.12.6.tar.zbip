> '3.15_15',
            'Term::UI'              => '0.30',
            'Tie::File'             => '0.98',
            'Unicode::UCD'          => '0.39',
            'Version::Requirements' => '0.101021',
            'XS::APItest'           => '0.35',
            '_charnames'            => '1.28',
            'arybase'               => '0.03',
            'autouse'               => '1.07',
            'charnames'             => '1.28',
            'diagnostics'           => '1.27',
            'feature'               => '1.25',
            'overload'              => '1.17',
            'overloading'           => '0.02',
            'perlfaq'               => '5.0150038',
        },
        removed => {
        }
    },
    5.015008 => {
        delta_from => 5.015007,
        changed => {
            'B'                     => '1.34',
            'B::Deparse'            => '1.12',
            'CPAN::Meta'            => '2.120351',
            'CPAN::Meta::Converter' => '2.120351',
            'CPAN::Meta::Feature'   => '2.120351',
            'CPAN::Meta::History'   => '2.120351',
            'CPAN::Meta::Prereqs'   => '2.120351',
            'CPAN::Meta::Requirements'=> '2.120351',
            'CPAN::Meta::Spec'      => '2.120351',
            'CPAN::Meta::Validator' => '2.120351',
            'CPAN::Meta::YAML'      => '0.007',
            'CPANPLUS'              => '0.9118',
            'CPANPLUS::Dist::Build' => '0.62',
            'CPANPLUS::Dist::Build::Constants'=> '0.62',
            'CPANPLUS::Internals'   => '0.9118',
            'CPANPLUS::Shell::Default'=> '0.9118',
            'Carp'                  => '1.25',
            'Carp::Heavy'           => '1.25',
            'Compress::Raw::Bzip2'  => '2.048',
            'Compress::Raw::Zlib'   => '2.048',
            'Compress::Zlib'        => '2.048',
            'Cwd'                   => '3.39_02',
            'DB_File'               => '1.826',
            'Data::Dumper'          => '2.135_05',
            'English'               => '1.05',
            'ExtUtils::Install'     => '1.58',
            'ExtUtils::ParseXS'     => '3.16',
            'ExtUtils::ParseXS::Constants'=> '3.16',
            'ExtUtils::ParseXS::CountLines'=> '3.16',
            'ExtUtils::ParseXS::Utilities'=> '3.16',
            'ExtUtils::Typemaps'    => '3.16',
            'ExtUtils::Typemaps::Cmd'=> '3.16',
            'ExtUtils::Typemaps::InputMap'=> '3.16',
            'ExtUtils::Typemaps::OutputMap'=> '3.16',
            'ExtUtils::Typemaps::Type'=> '3.16',
            'File::Copy'            => '2.23',
            'File::Glob'            => '1.17',
            'File::Spec'            => '3.39_02',
            'File::Spec::Cygwin'    => '3.39_02',
            'File::Spec::Epoc'      => '3.39_02',
            'File::Spec::Functions' => '3.39_02',
            'File::Spec::Mac'       => '3.39_02',
            'File::Spec::OS2'       => '3.39_02',
            'File::Spec::Unix'      => '3.39_02',
            'File::Spec::VMS'       => '3.39_02',
            'File::Spec::Win32'     => '3.39_02',
            'Filter::Util::Call'    => '1.40',
            'IO::Compress::Adapter::Bzip2'=> '2.048',
            'IO::Compress::Adapter::Deflate'=> '2.048',
            'IO::Compress::Adapter::Identity'=> '2.048',
            'IO::Compress::Base'    => '2.048',
            'IO::Compress::Base::Common'=> '2.048',
            'IO::Compress::Bzip2'   => '2.048',
            'IO::Compress::Deflate' => '2.048',
            'IO::Compress::Gzip'    => '2.048',
            'IO::Compress::Gzip::Constants'=> '2.048',
            'IO::Compress::RawDeflate'=> '2.048',
            'IO::Compress::Zip'     => '2.048',
            'IO::Compress::Zip::Constants'=> '2.048',
            'IO::Compress::Zlib::Constants'=> '2.048',
            'IO::Compress::Zlib::Extra'=> '2.048',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.048',
            'IO::Uncompress::Adapter::Identity'=> '2.048',
            'IO::Uncompress::Adapter::Inflate'=> '2.048',
            'IO::Uncompress::AnyInflate'=> '2.048',
            'IO::Uncompress::AnyUncompress'=> '2.048',
            'IO::Uncompress::Base'  => '2.048',
            'IO::Uncompress::Bunzip2'=> '2.048',
            'IO::Uncompress::Gunzip'=> '2.048',
            'IO::Uncompress::Inflate'=> '2.048',
            'IO::Uncompress::RawInflate'=> '2.048',
            'IO::Uncompress::Unzip' => '2.048',
            'IPC::Cmd'              => '0.76',
            'Math::Complex'         => '1.59',
            'Math::Trig'            => '1.23',
            'Module::Metadata'      => '1.000009',
            'Opcode'                => '1.23',
            'POSIX'                 => '1.30',
            'Parse::CPAN::Meta'     => '1.4402',
            'PerlIO::mmap'          => '0.010',
            'Pod::Checker'          => '1.51',
            'Pod::Find'             => '1.51',
            'Pod::Functions'        => '1.05',
            'Pod::Html'             => '1.14',
            'Pod::InputObjects'     => '1.51',
            'Pod::ParseUtils'       => '1.51',
            'Pod::Parser'           => '1.51',
            'Pod::PlainText'        => '2.05',
            'Pod::Select'           => '1.51',
            'Pod::Usage'            => '1.51',
            'Safe'                  => '2.31',
            'Socket'                => '1.98',
            'Term::Cap'             => '1.13',
            'Term::ReadLine'        => '1.08',
            'Time::HiRes'           => '1.9725',
            'Unicode'               => '6.1.0',
            'Unicode::UCD'          => '0.41',
            'Version::Requirements' => '0.101022',
            'XS::APItest'           => '0.36',
            'XS::Typemap'           => '0.08',
            '_charnames'            => '1.29',
            'arybase'               => '0.04',
            'charnames'             => '1.29',
            'diagnostics'           => '1.28',
            'feature'               => '1.26',
            'locale'                => '1.01',
            'overload'              => '1.18',
            'perlfaq'               => '5.0150039',
            're'                    => '0.19',
            'subs'                  => '1.01',
            'warnings'              => '1.13',
        },
        removed => {
        }
    },
    5.015009 => {
        delta_from => 5.015008,
        changed => {
            'B::Deparse'            => '1.13',
            'B::Lint'               => '1.14',
            'B::Lint::Debug'        => '1.14',
            'CPAN::Meta'            => '2.120630',
            'CPAN::Meta::Converter' => '2.120630',
            'CPAN::Meta::Feature'   => '2.120630',
            'CPAN::Meta::History'   => '2.120630',
            'CPAN::Meta::Prereqs'   => '2.120630',
            'CPAN::Meta::Requirements'=> '2.120630',
            'CPAN::Meta::Spec'      => '2.120630',
            'CPAN::Meta::Validator' => '2.120630',
            'CPANPLUS'              => '0.9121',
            'CPANPLUS::Internals'   => '0.9121',
            'CPANPLUS::Shell::Default'=> '0.9121',
            'Data::Dumper'          => '2.135_06',
            'Digest::SHA'           => '5.71',
            'ExtUtils::CBuilder'    => '0.280206',
            'ExtUtils::CBuilder::Base'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280206',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280206',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280206',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280206',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280206',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280206',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280206',
            'HTTP::Tiny'            => '0.017',
            'Locale::Codes'         => '3.21',
            'Locale::Codes::Constants'=> '3.21',
            'Locale::Codes::Country'=> '3.21',
            'Locale::Codes::Country_Codes'=> '3.21',
            'Locale::Codes::Country_Retired'=> '3.21',
            'Locale::Codes::Currency'=> '3.21',
            'Locale::Codes::Currency_Codes'=> '3.21',
            'Locale::Codes::Currency_Retired'=> '3.21',
            'Locale::Codes::LangExt'=> '3.21',
            'Locale::Codes::LangExt_Codes'=> '3.21',
            'Locale::Codes::LangExt_Retired'=> '3.21',
            'Locale::Codes::LangFam'=> '3.21',
            'Locale::Codes::LangFam_Codes'=> '3.21',
            'Locale::Codes::LangFam_Retired'=> '3.21',
            'Locale::Codes::LangVar'=> '3.21',
            'Locale::Codes::LangVar_Codes'=> '3.21',
            'Locale::Codes::LangVar_Retired'=> '3.21',
            'Locale::Codes::Language'=> '3.21',
            'Locale::Codes::Language_Codes'=> '3.21',
            'Locale::Codes::Language_Retired'=> '3.21',
            'Locale::Codes::Script' => '3.21',
            'Locale::Codes::Script_Codes'=> '3.21',
            'Locale::Codes::Script_Retired'=> '3.21',
            'Locale::Country'       => '3.21',
            'Locale::Currency'      => '3.21',
            'Locale::Language'      => '3.21',
            'Locale::Script'        => '3.21',
            'Module::CoreList'      => '2.65',
            'Pod::Html'             => '1.1501',
            'Pod::Perldoc'          => '3.17',
            'Pod::Perldoc::BaseTo'  => '3.17',
            'Pod::Perldoc::GetOptsOO'=> '3.17',
            'Pod::Perldoc::ToANSI'  => '3.17',
            'Pod::Perldoc::ToChecker'=> '3.17',
            'Pod::Perldoc::ToMan'   => '3.17',
            'Pod::Perldoc::ToNroff' => '3.17',
            'Pod::Perldoc::ToPod'   => '3.17',
            'Pod::Perldoc::ToRtf'   => '3.17',
            'Pod::Perldoc::ToTerm'  => '3.17',
            'Pod::Perldoc::ToText'  => '3.17',
            'Pod::Perldoc::ToTk'    => '3.17',
            'Pod::Perldoc::ToXml'   => '3.17',
            'Pod::Simple'           => '3.20',
            'Pod::Simple::BlackBox' => '3.20',
            'Pod::Simple::Checker'  => '3.20',
            'Pod::Simple::Debug'    => '3.20',
            'Pod::Simple::DumpAsText'=> '3.20',
            'Pod::Simple::DumpAsXML'=> '3.20',
            'Pod::Simple::HTML'     => '3.20',
            'Pod::Simple::HTMLBatch'=> '3.20',
            'Pod::Simple::LinkSection'=> '3.20',
            'Pod::Simple::Methody'  => '3.20',
            'Pod::Simple::Progress' => '3.20',
            'Pod::Simple::PullParser'=> '3.20',
            'Pod::Simple::PullParserEndToken'=> '3.20',
            'Pod::Simple::PullParserStartToken'=> '3.20',
            'Pod::Simple::PullParserTextToken'=> '3.20',
            'Pod::Simple::PullParserToken'=> '3.20',
            'Pod::Simple::RTF'      => '3.20',
            'Pod::Simple::Search'   => '3.20',
            'Pod::Simple::SimpleTree'=> '3.20',
            'Pod::Simple::Text'     => '3.20',
            'Pod::Simple::TextContent'=> '3.20',
            'Pod::Simple::TiedOutFH'=> '3.20',
            'Pod::Simple::Transcode'=> '3.20',
            'Pod::Simple::TranscodeDumb'=> '3.20',
            'Pod::Simple::TranscodeSmart'=> '3.20',
            'Pod::Simple::XHTML'    => '3.20',
            'Pod::Simple::XMLOutStream'=> '3.20',
            'Socket'                => '2.000',
            'Term::ReadLine'        => '1.09',
            'Unicode::Collate'      => '0.89',
            'Unicode::Collate::CJK::Korean'=> '0.88',
            'Unicode::Collate::Locale'=> '0.89',
            'Unicode::Normalize'    => '1.14',
            'Unicode::UCD'          => '0.42',
            'XS::APItest'           => '0.37',
            'arybase'               => '0.05',
            'attributes'            => '0.18',
            'charnames'             => '1.30',
            'feature'               => '1.27',
        },
        removed => {
        }
    },
    5.016 => {
        delta_from => 5.015009,
        changed => {
            'B::Concise'            => '0.89',
            'B::Deparse'            => '1.14',
            'Carp'                  => '1.26',
            'Carp::Heavy'           => '1.26',
            'IO::Socket'            => '1.35',
            'Module::CoreList'      => '2.66',
            'PerlIO::scalar'        => '0.14',
            'Pod::Html'             => '1.1502',
            'Safe'                  => '2.31_01',
            'Socket'                => '2.001',
            'Unicode::UCD'          => '0.43',
            'XS::APItest'           => '0.38',
            '_charnames'            => '1.31',
            'attributes'            => '0.19',
            'strict'                => '1.07',
            'version'               => '0.99',
        },
        removed => {
        }
    },
    5.016001 => {
        delta_from => 5.016,
        changed => {
            'B'                     => '1.35',
            'B::Deparse'            => '1.14_01',
            'List::Util'            => '1.25',
            'List::Util::PP'        => '1.25',
            'List::Util::XS'        => '1.25',
            'Module::CoreList'      => '2.70',
            'PerlIO::scalar'        => '0.14_01',
            'Scalar::Util'          => '1.25',
            'Scalar::Util::PP'      => '1.25',
            're'                    => '0.19_01',
        },
        removed => {
        }
    },
    5.016002 => {
        delta_from => 5.016001,
        changed => {
            'Module::CoreList'      => '2.76',
        },
        removed => {
        }
    },
    5.016003 => {
        delta_from => 5.016002,
        changed => {
            'Encode'                => '2.44_01',
            'Module::CoreList'      => '2.76_02',
            'XS::APItest'           => '0.39',
        },
        removed => {
        }
    },
    5.017 => {
        delta_from => 5.016,
        changed => {
            'B'                     => '1.35',
            'B::Concise'            => '0.90',
            'ExtUtils::ParseXS'     => '3.17',
            'ExtUtils::ParseXS::Utilities'=> '3.17',
            'File::DosGlob'         => '1.07',
            'File::Find'            => '1.21',
            'File::stat'            => '1.06',
            'Hash::Util'            => '0.12',
            'IO::Socket'            => '1.34',
            'Module::CoreList'      => '2.67',
            'Pod::Functions'        => '1.06',
            'Storable'              => '2.35',
            'XS::APItest'           => '0.39',
            'diagnostics'           => '1.29',
            'feature'               => '1.28',
            'overload'              => '1.19',
            'utf8'                  => '1.10',
        },
        removed => {
            'Version::Requirements' => 1,
        }
    },
    5.017001 => {
        delta_from => 5.017,
        changed => {
            'App::Prove'            => '3.25',
            'App::Prove::State'     => '3.25',
            'App::Prove::State::Result'=> '3.25',
            'App::Prove::State::Result::Test'=> '3.25',
            'Archive::Extract'      => '0.60',
            'Archive::Tar'          => '1.88',
            'Archive::Tar::Constant'=> '1.88',
            'Archive::Tar::File'    => '1.88',
            'B'                     => '1.36',
            'B::Deparse'            => '1.15',
            'CPAN::Meta'            => '2.120921',
            'CPAN::Meta::Converter' => '2.120921',
            'CPAN::Meta::Feature'   => '2.120921',
            'CPAN::Meta::History'   => '2.120921',
            'CPAN::Meta::Prereqs'   => '2.120921',
            'CPAN::Meta::Requirements'=> '2.122',
            'CPAN::Meta::Spec'      => '2.120921',
            'CPAN::Meta::Validator' => '2.120921',
            'CPAN::Meta::YAML'      => '0.008',
            'CPANPLUS'              => '0.9130',
            'CPANPLUS::Config::HomeEnv'=> '0.04',
            'CPANPLUS::Internals'   => '0.9130',
            'CPANPLUS::Shell::Default'=> '0.9130',
            'Class::Struct'         => '0.64',
            'Compress::Raw::Bzip2'  => '2.052',
            'Compress::Raw::Zlib'   => '2.054',
            'Compress::Zlib'        => '2.052',
            'Digest::MD5'           => '2.52',
            'DynaLoader'            => '1.15',
            'ExtUtils::CBuilder'    => '0.280208',
            'ExtUtils::CBuilder::Base'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280208',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280208',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280208',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280208',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280208',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280208',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280208',
            'Fatal'                 => '2.11',
            'File::DosGlob'         => '1.08',
            'File::Fetch'           => '0.34',
            'File::Spec::Unix'      => '3.39_03',
            'Filter::Util::Call'    => '1.45',
            'HTTP::Tiny'            => '0.022',
            'IO'                    => '1.25_07',
            'IO::Compress::Adapter::Bzip2'=> '2.052',
            'IO::Compress::Adapter::Deflate'=> '2.052',
            'IO::Compress::Adapter::Identity'=> '2.052',
            'IO::Compress::Base'    => '2.052',
            'IO::Compress::Base::Common'=> '2.052',
            'IO::Compress::Bzip2'   => '2.052',
            'IO::Compress::Deflate' => '2.052',
            'IO::Compress::Gzip'    => '2.052',
            'IO::Compress::Gzip::Constants'=> '2.052',
            'IO::Compress::RawDeflate'=> '2.052',
            'IO::Compress::Zip'     => '2.052',
            'IO::Compress::Zip::Constants'=> '2.052',
            'IO::Compress::Zlib::Constants'=> '2.052',
            'IO::Compress::Zlib::Extra'=> '2.052',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.052',
            'IO::Uncompress::Adapter::Identity'=> '2.052',
            'IO::Uncompress::Adapter::Inflate'=> '2.052',
            'IO::Uncompress::AnyInflate'=> '2.052',
            'IO::Uncompress::AnyUncompress'=> '2.052',
            'IO::Uncompress::Base'  => '2.052',
            'IO::Uncompress::Bunzip2'=> '2.052',
            'IO::Uncompress::Gunzip'=> '2.052',
            'IO::Uncompress::Inflate'=> '2.052',
            'IO::Uncompress::RawInflate'=> '2.052',
            'IO::Uncompress::Unzip' => '2.052',
            'IPC::Cmd'              => '0.78',
            'List::Util'            => '1.25',
            'List::Util::XS'        => '1.25',
            'Locale::Codes'         => '3.22',
            'Locale::Codes::Constants'=> '3.22',
            'Locale::Codes::Country'=> '3.22',
            'Locale::Codes::Country_Codes'=> '3.22',
            'Locale::Codes::Country_Retired'=> '3.22',
            'Locale::Codes::Currency'=> '3.22',
            'Locale::Codes::Currency_Codes'=> '3.22',
            'Locale::Codes::Currency_Retired'=> '3.22',
            'Locale::Codes::LangExt'=> '3.22',
            'Locale::Codes::LangExt_Codes'=> '3.22',
            'Locale::Codes::LangExt_Retired'=> '3.22',
            'Locale::Codes::LangFam'=> '3.22',
            'Locale::Codes::LangFam_Codes'=> '3.22',
            'Locale::Codes::LangFam_Retired'=> '3.22',
            'Locale::Codes::LangVar'=> '3.22',
            'Locale::Codes::LangVar_Codes'=> '3.22',
            'Locale::Codes::LangVar_Retired'=> '3.22',
            'Locale::Codes::Language'=> '3.22',
            'Locale::Codes::Language_Codes'=> '3.22',
            'Locale::Codes::Language_Retired'=> '3.22',
            'Locale::Codes::Script' => '3.22',
            'Locale::Codes::Script_Codes'=> '3.22',
            'Locale::Codes::Script_Retired'=> '3.22',
            'Locale::Country'       => '3.22',
            'Locale::Currency'      => '3.22',
            'Locale::Language'      => '3.22',
            'Locale::Script'        => '3.22',
            'Memoize'               => '1.03',
            'Memoize::AnyDBM_File'  => '1.03',
            'Memoize::Expire'       => '1.03',
            'Memoize::ExpireFile'   => '1.03',
            'Memoize::ExpireTest'   => '1.03',
            'Memoize::NDBM_File'    => '1.03',
            'Memoize::SDBM_File'    => '1.03',
            'Memoize::Storable'     => '1.03',
            'Module::Build'         => '0.40',
            'Module::Build::Base'   => '0.40',
            'Module::Build::Compat' => '0.40',
            'Module::Build::Config' => '0.40',
            'Module::Build::Cookbook'=> '0.40',
            'Module::Build::Dumper' => '0.40',
            'Module::Build::ModuleInfo'=> '0.40',
            'Module::Build::Notes'  => '0.40',
            'Module::Build::PPMMaker'=> '0.40',
            'Module::Build::Platform::Amiga'=> '0.40',
            'Module::Build::Platform::Default'=> '0.40',
            'Module::Build::Platform::EBCDIC'=> '0.40',
            'Module::Build::Platform::MPEiX'=> '0.40',
            'Module::Build::Platform::MacOS'=> '0.40',
            'Module::Build::Platform::RiscOS'=> '0.40',
            'Module::Build::Platform::Unix'=> '0.40',
            'Module::Build::Platform::VMS'=> '0.40',
            'Module::Build::Platform::VOS'=> '0.40',
            'Module::Build::Platform::Windows'=> '0.40',
            'Module::Build::Platform::aix'=> '0.40',
            'Module::Build::Platform::cygwin'=> '0.40',
            'Module::Build::Platform::darwin'=> '0.40',
            'Module::Build::Platform::os2'=> '0.40',
            'Module::Build::PodParser'=> '0.40',
            'Module::CoreList'      => '2.68',
            'Module::Load::Conditional'=> '0.50',
            'Object::Accessor'      => '0.44',
            'POSIX'                 => '1.31',
            'Params::Check'         => '0.36',
            'Parse::CPAN::Meta'     => '1.4404',
            'PerlIO::mmap'          => '0.011',
            'PerlIO::via::QuotedPrint'=> '0.07',
            'Pod::Html'             => '1.16',
            'Pod::Man'              => '2.26',
            'Pod::Text'             => '3.16',
            'Safe'                  => '2.33_01',
            'Scalar::Util'          => '1.25',
            'Search::Dict'          => '1.07',
            'Storable'              => '2.36',
            'TAP::Base'             => '3.25',
            'TAP::Formatter::Base'  => '3.25',
            'TAP::Formatter::Color' => '3.25',
            'TAP::Formatter::Console'=> '3.25',
            'TAP::Formatter::Console::ParallelSession'=> '3.25',
            'TAP::Formatter::Console::Session'=> '3.25',
            'TAP::Formatter::File'  => '3.25',
            'TAP::Formatter::File::Session'=> '3.25',
            'TAP::Formatter::Session'=> '3.25',
            'TAP::Harness'          => '3.25',
            'TAP::Object'           => '3.25',
            'TAP::Parser'           => '3.25',
            'TAP::Parser::Aggregator'=> '3.25',
            'TAP::Parser::Grammar'  => '3.25',
            'TAP::Parser::Iterator' => '3.25',
            'TAP::Parser::Iterator::Array'=> '3.25',
            'TAP::Parser::Iterator::Process'=> '3.25',
            'TAP::Parser::Iterator::Stream'=> '3.25',
            'TAP::Parser::IteratorFactory'=> '3.25',
            'TAP::Parser::Multiplexer'=> '3.25',
            'TAP::Parser::Result'   => '3.25',
            'TAP::Parser::Result::Bailout'=> '3.25',
            'TAP::Parser::Result::Comment'=> '3.25',
            'TAP::Parser::Result::Plan'=> '3.25',
            'TAP::Parser::Result::Pragma'=> '3.25',
            'TAP::Parser::Result::Test'=> '3.25',
            'TAP::Parser::Result::Unknown'=> '3.25',
            'TAP::Parser::Result::Version'=> '3.25',
            'TAP::Parser::Result::YAML'=> '3.25',
            'TAP::Parser::ResultFactory'=> '3.25',
            'TAP::Parser::Scheduler'=> '3.25',
            'TAP::Parser::Scheduler::Job'=> '3.25',
            'TAP::Parser::Scheduler::Spinner'=> '3.25',
            'TAP::Parser::Source'   => '3.25',
            'TAP::Parser::SourceHandler'=> '3.25',
            'TAP::Parser::SourceHandler::Executable'=> '3.25',
            'TAP::Parser::SourceHandler::File'=> '3.25',
            'TAP::Parser::SourceHandler::Handle'=> '3.25',
            'TAP::Parser::SourceHandler::Perl'=> '3.25',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.25',
            'TAP::Parser::Utils'    => '3.25',
            'TAP::Parser::YAMLish::Reader'=> '3.25',
            'TAP::Parser::YAMLish::Writer'=> '3.25',
            'Term::ANSIColor'       => '3.02',
            'Test::Harness'         => '3.25',
            'Unicode'               => '6.2.0',
            'Unicode::UCD'          => '0.44',
            'XS::APItest'           => '0.40',
            '_charnames'            => '1.32',
            'attributes'            => '0.2',
            'autodie'               => '2.11',
            'autodie::exception'    => '2.11',
            'autodie::exception::system'=> '2.11',
            'autodie::hints'        => '2.11',
            'bigint'                => '0.30',
            'charnames'             => '1.32',
            'feature'               => '1.29',
            'inc::latest'           => '0.40',
            'perlfaq'               => '5.0150040',
            're'                    => '0.20',
        },
        removed => {
            'List::Util::PP'        => 1,
            'Scalar::Util::PP'      => 1,
        }
    },
    5.017002 => {
        delta_from => 5.017001,
        changed => {
            'App::Prove'            => '3.25_01',
            'App::Prove::State'     => '3.25_01',
            'App::Prove::State::Result'=> '3.25_01',
            'App::Prove::State::Result::Test'=> '3.25_01',
            'B::Concise'            => '0.91',
            'Compress::Raw::Bzip2'  => '2.05201',
            'Compress::Raw::Zlib'   => '2.05401',
            'Exporter'              => '5.67',
            'Exporter::Heavy'       => '5.67',
            'Fatal'                 => '2.12',
            'File::Fetch'           => '0.36',
            'File::stat'            => '1.07',
            'IO'                    => '1.25_08',
            'IO::Socket'            => '1.35',
            'Module::CoreList'      => '2.69',
            'PerlIO::scalar'        => '0.15',
            'Socket'                => '2.002',
            'Storable'              => '2.37',
            'TAP::Base'             => '3.25_01',
            'TAP::Formatter::Base'  => '3.25_01',
            'TAP::Formatter::Color' => '3.25_01',
            'TAP::Formatter::Console'=> '3.25_01',
            'TAP::Formatter::Console::ParallelSession'=> '3.25_01',
            'TAP::Formatter::Console::Session'=> '3.25_01',
            'TAP::Formatter::File'  => '3.25_01',
            'TAP::Formatter::File::Session'=> '3.25_01',
            'TAP::Formatter::Session'=> '3.25_01',
            'TAP::Harness'          => '3.25_01',
            'TAP::Object'           => '3.25_01',
            'TAP::Parser'           => '3.25_01',
            'TAP::Parser::Aggregator'=> '3.25_01',
            'TAP::Parser::Grammar'  => '3.25_01',
            'TAP::Parser::Iterator' => '3.25_01',
            'TAP::Parser::Iterator::Array'=> '3.25_01',
            'TAP::Parser::Iterator::Process'=> '3.25_01',
            'TAP::Parser::Iterator::Stream'=> '3.25_01',
            'TAP::Parser::IteratorFactory'=> '3.25_01',
            'TAP::Parser::Multiplexer'=> '3.25_01',
            'TAP::Parser::Result'   => '3.25_01',
            'TAP::Parser::Result::Bailout'=> '3.25_01',
            'TAP::Parser::Result::Comment'=> '3.25_01',
            'TAP::Parser::Result::Plan'=> '3.25_01',
            'TAP::Parser::Result::Pragma'=> '3.25_01',
            'TAP::Parser::Result::Test'=> '3.25_01',
            'TAP::Parser::Result::Unknown'=> '3.25_01',
            'TAP::Parser::Result::Version'=> '3.25_01',
            'TAP::Parser::Result::YAML'=> '3.25_01',
            'TAP::Parser::ResultFactory'=> '3.25_01',
            'TAP::Parser::Scheduler'=> '3.25_01',
            'TAP::Parser::Scheduler::Job'=> '3.25_01',
            'TAP::Parser::Scheduler::Spinner'=> '3.25_01',
            'TAP::Parser::Source'   => '3.25_01',
            'TAP::Parser::SourceHandler'=> '3.25_01',
            'TAP::Parser::SourceHandler::Executable'=> '3.25_01',
            'TAP::Parser::SourceHandler::File'=> '3.25_01',
            'TAP::Parser::SourceHandler::Handle'=> '3.25_01',
            'TAP::Parser::SourceHandler::Perl'=> '3.25_01',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.25_01',
            'TAP::Parser::Utils'    => '3.25_01',
            'TAP::Parser::YAMLish::Reader'=> '3.25_01',
            'TAP::Parser::YAMLish::Writer'=> '3.25_01',
            'Test::Harness'         => '3.25_01',
            'Tie::StdHandle'        => '4.3',
            'XS::APItest'           => '0.41',
            'autodie'               => '2.12',
            'autodie::exception'    => '2.12',
            'autodie::exception::system'=> '2.12',
            'autodie::hints'        => '2.12',
            'diagnostics'           => '1.30',
            'overload'              => '1.20',
            're'                    => '0.21',
            'vars'                  => '1.03',
        },
        removed => {
        }
    },
    5.017003 => {
        delta_from => 5.017002,
        changed => {
            'B'                     => '1.37',
            'B::Concise'            => '0.92',
            'B::Debug'              => '1.18',
            'B::Deparse'            => '1.16',
            'CGI'                   => '3.60',
            'Compress::Raw::Bzip2'  => '2.055',
            'Compress::Raw::Zlib'   => '2.056',
            'Compress::Zlib'        => '2.055',
            'Data::Dumper'          => '2.135_07',
            'Devel::Peek'           => '1.09',
            'Encode'                => '2.47',
            'Encode::Alias'         => '2.16',
            'Encode::GSM0338'       => '2.02',
            'Encode::Unicode::UTF7' => '2.06',
            'IO::Compress::Adapter::Bzip2'=> '2.055',
            'IO::Compress::Adapter::Deflate'=> '2.055',
            'IO::Compress::Adapter::Identity'=> '2.055',
            'IO::Compress::Base'    => '2.055',
            'IO::Compress::Base::Common'=> '2.055',
            'IO::Compress::Bzip2'   => '2.055',
            'IO::Compress::Deflate' => '2.055',
            'IO::Compress::Gzip'    => '2.055',
            'IO::Compress::Gzip::Constants'=> '2.055',
            'IO::Compress::RawDeflate'=> '2.055',
            'IO::Compress::Zip'     => '2.055',
            'IO::Compress::Zip::Constants'=> '2.055',
            'IO::Compress::Zlib::Constants'=> '2.055',
            'IO::Compress::Zlib::Extra'=> '2.055',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.055',
            'IO::Uncompress::Adapter::Identity'=> '2.055',
            'IO::Uncompress::Adapter::Inflate'=> '2.055',
            'IO::Uncompress::AnyInflate'=> '2.055',
            'IO::Uncompress::AnyUncompress'=> '2.055',
            'IO::Uncompress::Base'  => '2.055',
            'IO::Uncompress::Bunzip2'=> '2.055',
            'IO::Uncompress::Gunzip'=> '2.055',
            'IO::Uncompress::Inflate'=> '2.055',
            'IO::Uncompress::RawInflate'=> '2.055',
            'IO::Uncompress::Unzip' => '2.055',
            'Module::Build'         => '0.4003',
            'Module::Build::Base'   => '0.4003',
            'Module::Build::Compat' => '0.4003',
            'Module::Build::Config' => '0.4003',
            'Module::Build::Cookbook'=> '0.4003',
            'Module::Build::Dumper' => '0.4003',
            'Module::Build::ModuleInfo'=> '0.4003',
            'Module::Build::Notes'  => '0.4003',
            'Module::Build::PPMMaker'=> '0.4003',
            'Module::Build::Platform::Amiga'=> '0.4003',
            'Module::Build::Platform::Default'=> '0.4003',
            'Module::Build::Platform::EBCDIC'=> '0.4003',
            'Module::Build::Platform::MPEiX'=> '0.4003',
            'Module::Build::Platform::MacOS'=> '0.4003',
            'Module::Build::Platform::RiscOS'=> '0.4003',
            'Module::Build::Platform::Unix'=> '0.4003',
            'Module::Build::Platform::VMS'=> '0.4003',
            'Module::Build::Platform::VOS'=> '0.4003',
            'Module::Build::Platform::Windows'=> '0.4003',
            'Module::Build::Platform::aix'=> '0.4003',
            'Module::Build::Platform::cygwin'=> '0.4003',
            'Module::Build::Platform::darwin'=> '0.4003',
            'Module::Build::Platform::os2'=> '0.4003',
            'Module::Build::PodParser'=> '0.4003',
            'Module::CoreList'      => '2.71',
            'Module::CoreList::TieHashDelta'=> '2.71',
            'Module::Load::Conditional'=> '0.54',
            'Module::Metadata'      => '1.000011',
            'Module::Pluggable'     => '4.3',
            'Module::Pluggable::Object'=> '4.3',
            'Pod::Simple'           => '3.23',
            'Pod::Simple::BlackBox' => '3.23',
            'Pod::Simple::Checker'  => '3.23',
            'Pod::Simple::Debug'    => '3.23',
            'Pod::Simple::DumpAsText'=> '3.23',
            'Pod::Simple::DumpAsXML'=> '3.23',
            'Pod::Simple::HTML'     => '3.23',
            'Pod::Simple::HTMLBatch'=> '3.23',
            'Pod::Simple::LinkSection'=> '3.23',
            'Pod::Simple::Methody'  => '3.23',
            'Pod::Simple::Progress' => '3.23',
            'Pod::Simple::PullParser'=> '3.23',
            'Pod::Simple::PullParserEndToken'=> '3.23',
            'Pod::Simple::PullParserStartToken'=> '3.23',
            'Pod::Simple::PullParserTextToken'=> '3.23',
            'Pod::Simple::PullParserToken'=> '3.23',
            'Pod::Simple::RTF'      => '3.23',
            'Pod::Simple::Search'   => '3.23',
            'Pod::Simple::SimpleTree'=> '3.23',
            'Pod::Simple::Text'     => '3.23',
            'Pod::Simple::TextContent'=> '3.23',
            'Pod::Simple::TiedOutFH'=> '3.23',
            'Pod::Simple::Transcode'=> '3.23',
            'Pod::Simple::TranscodeDumb'=> '3.23',
            'Pod::Simple::TranscodeSmart'=> '3.23',
            'Pod::Simple::XHTML'    => '3.23',
            'Pod::Simple::XMLOutStream'=> '3.23',
            'Socket'                => '2.004',
            'Storable'              => '2.38',
            'Sys::Syslog'           => '0.31',
            'Term::ReadLine'        => '1.10',
            'Text::Tabs'            => '2012.0818',
            'Text::Wrap'            => '2012.0818',
            'Time::Local'           => '1.2300',
            'Unicode::UCD'          => '0.45',
            'Win32'                 => '0.45',
            'Win32CORE'             => '0.03',
            'XS::APItest'           => '0.42',
            'inc::latest'           => '0.4003',
            'perlfaq'               => '5.0150041',
            're'                    => '0.22',
        },
        removed => {
        }
    },
    5.017004 => {
        delta_from => 5.017003,
        changed => {
            'Archive::Tar'          => '1.90',
            'Archive::Tar::Constant'=> '1.90',
            'Archive::Tar::File'    => '1.90',
            'B'                     => '1.38',
            'B::Concise'            => '0.93',
            'B::Deparse'            => '1.17',
            'B::Xref'               => '1.04',
            'CPANPLUS'              => '0.9131',
            'CPANPLUS::Internals'   => '0.9131',
            'CPANPLUS::Shell::Default'=> '0.9131',
            'DB_File'               => '1.827',
            'Devel::Peek'           => '1.10',
            'DynaLoader'            => '1.16',
            'Errno'                 => '1.16',
            'ExtUtils::ParseXS'     => '3.18',
            'ExtUtils::ParseXS::Constants'=> '3.18',
            'ExtUtils::ParseXS::CountLines'=> '3.18',
            'ExtUtils::ParseXS::Utilities'=> '3.18',
            'File::Copy'            => '2.24',
            'File::Find'            => '1.22',
            'IPC::Open3'            => '1.13',
            'Locale::Codes'         => '3.23',
            'Locale::Codes::Constants'=> '3.23',
            'Locale::Codes::Country'=> '3.23',
            'Locale::Codes::Country_Codes'=> '3.23',
            'Locale::Codes::Country_Retired'=> '3.23',
            'Locale::Codes::Currency'=> '3.23',
            'Locale::Codes::Currency_Codes'=> '3.23',
            'Locale::Codes::Currency_Retired'=> '3.23',
            'Locale::Codes::LangExt'=> '3.23',
            'Locale::Codes::LangExt_Codes'=> '3.23',
            'Locale::Codes::LangExt_Retired'=> '3.23',
            'Locale::Codes::LangFam'=> '3.23',
            'Locale::Codes::LangFam_Codes'=> '3.23',
            'Locale::Codes::LangFam_Retired'=> '3.23',
            'Locale::Codes::LangVar'=> '3.23',
            'Locale::Codes::LangVar_Codes'=> '3.23',
            'Locale::Codes::LangVar_Retired'=> '3.23',
            'Locale::Codes::Language'=> '3.23',
            'Locale::Codes::Language_Codes'=> '3.23',
            'Locale::Codes::Language_Retired'=> '3.23',
            'Locale::Codes::Script' => '3.23',
            'Locale::Codes::Script_Codes'=> '3.23',
            'Locale::Codes::Script_Retired'=> '3.23',
            'Locale::Country'       => '3.23',
            'Locale::Currency'      => '3.23',
            'Locale::Language'      => '3.23',
            'Locale::Script'        => '3.23',
            'Math::BigFloat::Trace' => '0.30',
            'Math::BigInt::Trace'   => '0.30',
            'Module::CoreList'      => '2.73',
            'Module::CoreList::TieHashDelta'=> '2.73',
            'Opcode'                => '1.24',
            'Socket'                => '2.006',
            'Storable'              => '2.39',
            'Sys::Syslog'           => '0.32',
            'Unicode::UCD'          => '0.46',
            'XS::APItest'           => '0.43',
            'bignum'                => '0.30',
            'bigrat'                => '0.30',
            'constant'              => '1.24',
            'feature'               => '1.30',
            'threads::shared'       => '1.41',
            'version'               => '0.9901',
            'warnings'              => '1.14',
        },
        removed => {
        }
    },
    5.017005 => {
        delta_from => 5.017004,
        changed => {
            'AutoLoader'            => '5.73',
            'B'                     => '1.39',
            'B::Deparse'            => '1.18',
            'CPANPLUS'              => '0.9133',
            'CPANPLUS::Internals'   => '0.9133',
            'CPANPLUS::Shell::Default'=> '0.9133',
            'Carp'                  => '1.27',
            'Carp::Heavy'           => '1.27',
            'Data::Dumper'          => '2.136',
            'Digest::SHA'           => '5.72',
            'ExtUtils::CBuilder'    => '0.280209',
            'ExtUtils::CBuilder::Base'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280209',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280209',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280209',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280209',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280209',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280209',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280209',
            'File::Copy'            => '2.25',
            'File::Glob'            => '1.18',
            'HTTP::Tiny'            => '0.024',
            'Module::CoreList'      => '2.75',
            'Module::CoreList::TieHashDelta'=> '2.75',
            'PerlIO::encoding'      => '0.16',
            'Unicode::Collate'      => '0.90',
            'Unicode::Collate::Locale'=> '0.90',
            'Unicode::Normalize'    => '1.15',
            'Win32CORE'             => '0.04',
            'XS::APItest'           => '0.44',
            'attributes'            => '0.21',
            'bigint'                => '0.31',
            'bignum'                => '0.31',
            'bigrat'                => '0.31',
            'feature'               => '1.31',
            'threads::shared'       => '1.42',
            'warnings'              => '1.15',
        },
        removed => {
        }
    },
    5.017006 => {
        delta_from => 5.017005,
        changed => {
            'B'                     => '1.40',
            'B::Concise'            => '0.94',
            'B::Deparse'            => '1.19',
            'B::Xref'               => '1.05',
            'CGI'                   => '3.63',
            'CGI::Util'             => '3.62',
            'CPAN'                  => '1.99_51',
            'CPANPLUS::Dist::Build' => '0.64',
            'CPANPLUS::Dist::Build::Constants'=> '0.64',
            'Carp'                  => '1.28',
            'Carp::Heavy'           => '1.28',
            'Compress::Raw::Bzip2'  => '2.058',
            'Compress::Raw::Zlib'   => '2.058',
            'Compress::Zlib'        => '2.058',
            'Data::Dumper'          => '2.137',
            'Digest::SHA'           => '5.73',
            'DynaLoader'            => '1.17',
            'Env'                   => '1.04',
            'Errno'                 => '1.17',
            'ExtUtils::Manifest'    => '1.62',
            'ExtUtils::Typemaps'    => '3.18',
            'ExtUtils::Typemaps::Cmd'=> '3.18',
            'ExtUtils::Typemaps::InputMap'=> '3.18',
            'ExtUtils::Typemaps::OutputMap'=> '3.18',
            'ExtUtils::Typemaps::Type'=> '3.18',
            'Fatal'                 => '2.13',
            'File::Find'            => '1.23',
            'Hash::Util'            => '0.13',
            'IO::Compress::Adapter::Bzip2'=> '2.058',
            'IO::Compress::Adapter::Deflate'=> '2.058',
            'IO::Compress::Adapter::Identity'=> '2.058',
            'IO::Compress::Base'    => '2.058',
            'IO::Compress::Base::Common'=> '2.058',
            'IO::Compress::Bzip2'   => '2.058',
            'IO::Compress::Deflate' => '2.058',
            'IO::Compress::Gzip'    => '2.058',
            'IO::Compress::Gzip::Constants'=> '2.058',
            'IO::Compress::RawDeflate'=> '2.058',
            'IO::Compress::Zip'     => '2.058',
            'IO::Compress::Zip::Constants'=> '2.058',
            'IO::Compress::Zlib::Constants'=> '2.058',
            'IO::Compress::Zlib::Extra'=> '2.058',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.058',
            'IO::Uncompress::Adapter::Identity'=> '2.058',
            'IO::Uncompress::Adapter::Inflate'=> '2.058',
            'IO::Uncompress::AnyInflate'=> '2.058',
            'IO::Uncompress::AnyUncompress'=> '2.058',
            'IO::Uncompress::Base'  => '2.058',
            'IO::Uncompress::Bunzip2'=> '2.058',
            'IO::Uncompress::Gunzip'=> '2.058',
            'IO::Uncompress::Inflate'=> '2.058',
            'IO::Uncompress::RawInflate'=> '2.058',
            'IO::Uncompress::Unzip' => '2.058',
            'Module::CoreList'      => '2.78',
            'Module::CoreList::TieHashDelta'=> '2.77',
            'Module::Pluggable'     => '4.5',
            'Module::Pluggable::Object'=> '4.5',
            'Opcode'                => '1.25',
            'Sys::Hostname'         => '1.17',
            'Term::UI'              => '0.32',
            'Thread::Queue'         => '3.01',
            'Tie::Hash::NamedCapture'=> '0.09',
            'Unicode::Collate'      => '0.93',
            'Unicode::Collate::CJK::Korean'=> '0.93',
            'Unicode::Collate::Locale'=> '0.93',
            'Unicode::Normalize'    => '1.16',
            'Unicode::UCD'          => '0.47',
            'XS::APItest'           => '0.46',
            '_charnames'            => '1.33',
            'autodie'               => '2.13',
            'autodie::exception'    => '2.13',
            'autodie::exception::system'=> '2.13',
            'autodie::hints'        => '2.13',
            'charnames'             => '1.33',
            're'                    => '0.23',
        },
        removed => {
        }
    },
    5.017007 => {
        delta_from => 5.017006,
        changed => {
            'B'                     => '1.41',
            'CPANPLUS::Dist::Build' => '0.68',
            'CPANPLUS::Dist::Build::Constants'=> '0.68',
            'Compress::Raw::Bzip2'  => '2.059',
            'Compress::Raw::Zlib'   => '2.059',
            'Compress::Zlib'        => '2.059',
            'Cwd'                   => '3.39_03',
            'Data::Dumper'          => '2.139',
            'Devel::Peek'           => '1.11',
            'Digest::SHA'           => '5.80',
            'DynaLoader'            => '1.18',
            'English'               => '1.06',
            'Errno'                 => '1.18',
            'ExtUtils::Command::MM' => '6.64',
            'ExtUtils::Liblist'     => '6.64',
            'ExtUtils::Liblist::Kid'=> '6.64',
            'ExtUtils::MM'          => '6.64',
            'ExtUtils::MM_AIX'      => '6.64',
            'ExtUtils::MM_Any'      => '6.64',
            'ExtUtils::MM_BeOS'     => '6.64',
            'ExtUtils::MM_Cygwin'   => '6.64',
            'ExtUtils::MM_DOS'      => '6.64',
            'ExtUtils::MM_Darwin'   => '6.64',
            'ExtUtils::MM_MacOS'    => '6.64',
            'ExtUtils::MM_NW5'      => '6.64',
            'ExtUtils::MM_OS2'      => '6.64',
            'ExtUtils::MM_QNX'      => '6.64',
            'ExtUtils::MM_UWIN'     => '6.64',
            'ExtUtils::MM_Unix'     => '6.64',
            'ExtUtils::MM_VMS'      => '6.64',
            'ExtUtils::MM_VOS'      => '6.64',
            'ExtUtils::MM_Win32'    => '6.64',
            'ExtUtils::MM_Win95'    => '6.64',
            'ExtUtils::MY'          => '6.64',
            'ExtUtils::MakeMaker'   => '6.64',
            'ExtUtils::MakeMaker::Config'=> '6.64',
            'ExtUtils::Mkbootstrap' => '6.64',
            'ExtUtils::Mksymlists'  => '6.64',
            'ExtUtils::testlib'     => '6.64',
            'File::DosGlob'         => '1.09',
            'File::Glob'            => '1.19',
            'GDBM_File'             => '1.15',
            'IO::Compress::Adapter::Bzip2'=> '2.059',
            'IO::Compress::Adapter::Deflate'=> '2.059',
            'IO::Compress::Adapter::Identity'=> '2.059',
            'IO::Compress::Base'    => '2.059',
            'IO::Compress::Base::Common'=> '2.059',
            'IO::Compress::Bzip2'   => '2.059',
            'IO::Compress::Deflate' => '2.059',
            'IO::Compress::Gzip'    => '2.059',
            'IO::Compress::Gzip::Constants'=> '2.059',
            'IO::Compress::RawDeflate'=> '2.059',
            'IO::Compress::Zip'     => '2.059',
            'IO::Compress::Zip::Constants'=> '2.059',
            'IO::Compress::Zlib::Constants'=> '2.059',
            'IO::Compress::Zlib::Extra'=> '2.059',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.059',
            'IO::Uncompress::Adapter::Identity'=> '2.059',
            'IO::Uncompress::Adapter::Inflate'=> '2.059',
            'IO::Uncompress::AnyInflate'=> '2.059',
            'IO::Uncompress::AnyUncompress'=> '2.059',
            'IO::Uncompress::Base'  => '2.059',
            'IO::Uncompress::Bunzip2'=> '2.059',
            'IO::Uncompress::Gunzip'=> '2.059',
            'IO::Uncompress::Inflate'=> '2.059',
            'IO::Uncompress::RawInflate'=> '2.059',
            'IO::Uncompress::Unzip' => '2.059',
            'List::Util'            => '1.26',
            'List::Util::XS'        => '1.26',
            'Locale::Codes'         => '3.24',
            'Locale::Codes::Constants'=> '3.24',
            'Locale::Codes::Country'=> '3.24',
            'Locale::Codes::Country_Codes'=> '3.24',
            'Locale::Codes::Country_Retired'=> '3.24',
            'Locale::Codes::Currency'=> '3.24',
            'Locale::Codes::Currency_Codes'=> '3.24',
            'Locale::Codes::Currency_Retired'=> '3.24',
            'Locale::Codes::LangExt'=> '3.24',
            'Locale::Codes::LangExt_Codes'=> '3.24',
            'Locale::Codes::LangExt_Retired'=> '3.24',
            'Locale::Codes::LangFam'=> '3.24',
            'Locale::Codes::LangFam_Codes'=> '3.24',
            'Locale::Codes::LangFam_Retired'=> '3.24',
            'Locale::Codes::LangVar'=> '3.24',
            'Locale::Codes::LangVar_Codes'=> '3.24',
            'Locale::Codes::LangVar_Retired'=> '3.24',
            'Locale::Codes::Language'=> '3.24',
            'Locale::Codes::Language_Codes'=> '3.24',
            'Locale::Codes::Language_Retired'=> '3.24',
            'Locale::Codes::Script' => '3.24',
            'Locale::Codes::Script_Codes'=> '3.24',
            'Locale::Codes::Script_Retired'=> '3.24',
            'Locale::Country'       => '3.24',
            'Locale::Currency'      => '3.24',
            'Locale::Language'      => '3.24',
            'Locale::Maketext'      => '1.23',
            'Locale::Script'        => '3.24',
            'Module::CoreList'      => '2.79',
            'Module::CoreList::TieHashDelta'=> '2.79',
            'POSIX'                 => '1.32',
            'Scalar::Util'          => '1.26',
            'Socket'                => '2.006_001',
            'Storable'              => '2.40',
            'Term::ReadLine'        => '1.11',
            'Unicode::Collate'      => '0.96',
            'Unicode::Collate::CJK::Stroke'=> '0.94',
            'Unicode::Collate::CJK::Zhuyin'=> '0.94',
            'Unicode::Collate::Locale'=> '0.96',
            'XS::APItest'           => '0.48',
            'XS::Typemap'           => '0.09',
            '_charnames'            => '1.34',
            'charnames'             => '1.34',
            'feature'               => '1.32',
            'mro'                   => '1.10',
            'sigtrap'               => '1.07',
            'sort'                  => '2.02',
        },
        removed => {
        }
    },
    5.017008 => {
        delta_from => 5.017007,
        changed => {
            'Archive::Extract'      => '0.62',
            'B'                     => '1.42',
            'B::Concise'            => '0.95',
            'Compress::Raw::Bzip2'  => '2.060',
            'Compress::Raw::Zlib'   => '2.060',
            'Compress::Zlib'        => '2.060',
            'Cwd'                   => '3.40',
            'Data::Dumper'          => '2.141',
            'Digest::SHA'           => '5.81',
            'ExtUtils::Install'     => '1.59',
            'File::Fetch'           => '0.38',
            'File::Path'            => '2.09',
            'File::Spec'            => '3.40',
            'File::Spec::Cygwin'    => '3.40',
            'File::Spec::Epoc'      => '3.40',
            'File::Spec::Functions' => '3.40',
            'File::Spec::Mac'       => '3.40',
            'File::Spec::OS2'       => '3.40',
            'File::Spec::Unix'      => '3.40',
            'File::Spec::VMS'       => '3.40',
            'File::Spec::Win32'     => '3.40',
            'HTTP::Tiny'            => '0.025',
            'Hash::Util'            => '0.14',
            'I18N::LangTags'        => '0.39',
            'I18N::LangTags::List'  => '0.39',
            'I18N::Langinfo'        => '0.09',
            'IO'                    => '1.26',
            'IO::Compress::Adapter::Bzip2'=> '2.060',
            'IO::Compress::Adapter::Deflate'=> '2.060',
            'IO::Compress::Adapter::Identity'=> '2.060',
            'IO::Compress::Base'    => '2.060',
            'IO::Compress::Base::Common'=> '2.060',
            'IO::Compress::Bzip2'   => '2.060',
            'IO::Compress::Deflate' => '2.060',
            'IO::Compress::Gzip'    => '2.060',
            'IO::Compress::Gzip::Constants'=> '2.060',
            'IO::Compress::RawDeflate'=> '2.060',
            'IO::Compress::Zip'     => '2.060',
            'IO::Compress::Zip::Constants'=> '2.060',
            'IO::Compress::Zlib::Constants'=> '2.060',
            'IO::Compress::Zlib::Extra'=> '2.060',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.060',
            'IO::Uncompress::Adapter::Identity'=> '2.060',
            'IO::Uncompress::Adapter::Inflate'=> '2.060',
            'IO::Uncompress::AnyInflate'=> '2.060',
            'IO::Uncompress::AnyUncompress'=> '2.060',
            'IO::Uncompress::Base'  => '2.060',
            'IO::Uncompress::Bunzip2'=> '2.060',
            'IO::Uncompress::Gunzip'=> '2.060',
            'IO::Uncompress::Inflate'=> '2.060',
            'IO::Uncompress::RawInflate'=> '2.060',
            'IO::Uncompress::Unzip' => '2.060',
            'List::Util'            => '1.27',
            'List::Util::XS'        => '1.27',
            'Module::CoreList'      => '2.80',
            'Module::CoreList::TieHashDelta'=> '2.80',
            'Pod::Html'             => '1.17',
            'Pod::LaTeX'            => '0.61',
            'Pod::Man'              => '2.27',
            'Pod::Text'             => '3.17',
            'Pod::Text::Color'      => '2.07',
            'Pod::Text::Overstrike' => '2.05',
            'Pod::Text::Termcap'    => '2.07',
            'Safe'                  => '2.34',
            'Scalar::Util'          => '1.27',
            'Socket'                => '2.009',
            'Term::ANSIColor'       => '4.02',
            'Test'                  => '1.26',
            'Unicode::Collate'      => '0.97',
            'XS::APItest'           => '0.51',
            'XS::Typemap'           => '0.10',
            '_charnames'            => '1.35',
            'charnames'             => '1.35',
            'constant'              => '1.25',
            'diagnostics'           => '1.31',
            'threads::shared'       => '1.43',
            'warnings'              => '1.16',
        },
        removed => {
        }
    },
    5.017009 => {
        delta_from => 5.017008,
        changed => {
            'App::Cpan'             => '1.60_02',
            'App::Prove'            => '3.26',
            'App::Prove::State'     => '3.26',
            'App::Prove::State::Result'=> '3.26',
            'App::Prove::State::Result::Test'=> '3.26',
            'Archive::Extract'      => '0.68',
            'Attribute::Handlers'   => '0.94',
            'B::Lint'               => '1.17',
            'B::Lint::Debug'        => '1.17',
            'Benchmark'             => '1.14',
            'CPAN'                  => '2.00',
            'CPAN::Distribution'    => '2.00',
            'CPAN::FirstTime'       => '5.5304',
            'CPAN::Nox'             => '5.5001',
            'CPANPLUS'              => '0.9135',
            'CPANPLUS::Backend'     => '0.9135',
            'CPANPLUS::Backend::RV' => '0.9135',
            'CPANPLUS::Config'      => '0.9135',
            'CPANPLUS::Config::HomeEnv'=> '0.9135',
            'CPANPLUS::Configure'   => '0.9135',
            'CPANPLUS::Configure::Setup'=> '0.9135',
            'CPANPLUS::Dist'        => '0.9135',
            'CPANPLUS::Dist::Autobundle'=> '0.9135',
            'CPANPLUS::Dist::Base'  => '0.9135',
            'CPANPLUS::Dist::Build' => '0.70',
            'CPANPLUS::Dist::Build::Constants'=> '0.70',
            'CPANPLUS::Dist::MM'    => '0.9135',
            'CPANPLUS::Dist::Sample'=> '0.9135',
            'CPANPLUS::Error'       => '0.9135',
            'CPANPLUS::Internals'   => '0.9135',
            'CPANPLUS::Internals::Constants'=> '0.9135',
            'CPANPLUS::Internals::Constants::Report'=> '0.9135',
            'CPANPLUS::Internals::Extract'=> '0.9135',
            'CPANPLUS::Internals::Fetch'=> '0.9135',
            'CPANPLUS::Internals::Report'=> '0.9135',
            'CPANPLUS::Internals::Search'=> '0.9135',
            'CPANPLUS::Internals::Source'=> '0.9135',
            'CPANPLUS::Internals::Source::Memory'=> '0.9135',
            'CPANPLUS::Internals::Source::SQLite'=> '0.9135',
            'CPANPLUS::Internals::Source::SQLite::Tie'=> '0.9135',
            'CPANPLUS::Internals::Utils'=> '0.9135',
            'CPANPLUS::Internals::Utils::Autoflush'=> '0.9135',
            'CPANPLUS::Module'      => '0.9135',
            'CPANPLUS::Module::Author'=> '0.9135',
            'CPANPLUS::Module::Author::Fake'=> '0.9135',
            'CPANPLUS::Module::Checksums'=> '0.9135',
            'CPANPLUS::Module::Fake'=> '0.9135',
            'CPANPLUS::Module::Signature'=> '0.9135',
            'CPANPLUS::Selfupdate'  => '0.9135',
            'CPANPLUS::Shell'       => '0.9135',
            'CPANPLUS::Shell::Classic'=> '0.9135',
            'CPANPLUS::Shell::Default'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::CustomSource'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::Remote'=> '0.9135',
            'CPANPLUS::Shell::Default::Plugins::Source'=> '0.9135',
            'Config'                => '5.017009',
            'Config::Perl::V'       => '0.17',
            'DBM_Filter'            => '0.05',
            'Data::Dumper'          => '2.142',
            'Digest::SHA'           => '5.82',
            'Encode'                => '2.48',
            'ExtUtils::Installed'   => '1.999003',
            'ExtUtils::Manifest'    => '1.63',
            'ExtUtils::ParseXS::Utilities'=> '3.19',
            'ExtUtils::Typemaps'    => '3.19',
            'File::CheckTree'       => '4.42',
            'File::DosGlob'         => '1.10',
            'File::Temp'            => '0.22_90',
            'Filter::Simple'        => '0.89',
            'IO'                    => '1.27',
            'Log::Message'          => '0.06',
            'Log::Message::Config'  => '0.06',
            'Log::Message::Handlers'=> '0.06',
            'Log::Message::Item'    => '0.06',
            'Log::Message::Simple'  => '0.10',
            'Math::BigInt'          => '1.999',
            'Module::CoreList'      => '2.82',
            'Module::CoreList::TieHashDelta'=> '2.82',
            'Module::Load'          => '0.24',
            'Module::Pluggable'     => '4.6',
            'Module::Pluggable::Object'=> '4.6',
            'OS2::DLL'              => '1.05',
            'OS2::ExtAttr'          => '0.03',
            'OS2::Process'          => '1.08',
            'Object::Accessor'      => '0.46',
            'PerlIO::scalar'        => '0.16',
            'Pod::Checker'          => '1.60',
            'Pod::Find'             => '1.60',
            'Pod::Html'             => '1.18',
            'Pod::InputObjects'     => '1.60',
            'Pod::ParseUtils'       => '1.60',
            'Pod::Parser'           => '1.60',
            'Pod::Perldoc'          => '3.19',
            'Pod::Perldoc::BaseTo'  => '3.19',
            'Pod::Perldoc::GetOptsOO'=> '3.19',
            'Pod::Perldoc::ToANSI'  => '3.19',
            'Pod::Perldoc::ToChecker'=> '3.19',
            'Pod::Perldoc::ToMan'   => '3.19',
            'Pod::Perldoc::ToNroff' => '3.19',
            'Pod::Perldoc::ToPod'   => '3.19',
            'Pod::Perldoc::ToRtf'   => '3.19',
            'Pod::Perldoc::ToTerm'  => '3.19',
            'Pod::Perldoc::ToText'  => '3.19',
            'Pod::Perldoc::ToTk'    => '3.19',
            'Pod::Perldoc::ToXml'   => '3.19',
            'Pod::PlainText'        => '2.06',
            'Pod::Select'           => '1.60',
            'Pod::Usage'            => '1.61',
            'SelfLoader'            => '1.21',
            'TAP::Base'             => '3.26',
            'TAP::Formatter::Base'  => '3.26',
            'TAP::Formatter::Color' => '3.26',
            'TAP::Formatter::Console'=> '3.26',
            'TAP::Formatter::Console::ParallelSession'=> '3.26',
            'TAP::Formatter::Console::Session'=> '3.26',
            'TAP::Formatter::File'  => '3.26',
            'TAP::Formatter::File::Session'=> '3.26',
            'TAP::Formatter::Session'=> '3.26',
            'TAP::Harness'          => '3.26',
            'TAP::Object'           => '3.26',
            'TAP::Parser'           => '3.26',
            'TAP::Parser::Aggregator'=> '3.26',
            'TAP::Parser::Grammar'  => '3.26',
            'TAP::Parser::Iterator' => '3.26',
            'TAP::Parser::Iterator::Array'=> '3.26',
            'TAP::Parser::Iterator::Process'=> '3.26',
            'TAP::Parser::Iterator::Stream'=> '3.26',
            'TAP::Parser::IteratorFactory'=> '3.26',
            'TAP::Parser::Multiplexer'=> '3.26',
            'TAP::Parser::Result'   => '3.26',
            'TAP::Parser::Result::Bailout'=> '3.26',
            'TAP::Parser::Result::Comment'=> '3.26',
            'TAP::Parser::Result::Plan'=> '3.26',
            'TAP::Parser::Result::Pragma'=> '3.26',
            'TAP::Parser::Result::Test'=> '3.26',
            'TAP::Parser::Result::Unknown'=> '3.26',
            'TAP::Parser::Result::Version'=> '3.26',
            'TAP::Parser::Result::YAML'=> '3.26',
            'TAP::Parser::ResultFactory'=> '3.26',
            'TAP::Parser::Scheduler'=> '3.26',
            'TAP::Parser::Scheduler::Job'=> '3.26',
            'TAP::Parser::Scheduler::Spinner'=> '3.26',
            'TAP::Parser::Source'   => '3.26',
            'TAP::Parser::SourceHandler'=> '3.26',
            'TAP::Parser::SourceHandler::Executable'=> '3.26',
            'TAP::Parser::SourceHandler::File'=> '3.26',
            'TAP::Parser::SourceHandler::Handle'=> '3.26',
            'TAP::Parser::SourceHandler::Perl'=> '3.26',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.26',
            'TAP::Parser::Utils'    => '3.26',
            'TAP::Parser::YAMLish::Reader'=> '3.26',
            'TAP::Parser::YAMLish::Writer'=> '3.26',
            'Term::UI'              => '0.34',
            'Test::Harness'         => '3.26',
            'Text::Soundex'         => '3.04',
            'Thread::Queue'         => '3.02',
            'Unicode::UCD'          => '0.50',
            'Win32'                 => '0.46',
            'Win32API::File'        => '0.1201',
            '_charnames'            => '1.36',
            'arybase'               => '0.06',
            'bigint'                => '0.32',
            'bignum'                => '0.32',
            'charnames'             => '1.36',
            'filetest'              => '1.03',
            'locale'                => '1.02',
            'overload'              => '1.21',
            'warnings'              => '1.17',
        },
        removed => {
        }
    },
    5.017010 => {
        delta_from => 5.017009,
        changed => {
            'Benchmark'             => '1.15',
            'Config'                => '5.017009',
            'Data::Dumper'          => '2.145',
            'Digest::SHA'           => '5.84',
            'Encode'                => '2.49',
            'ExtUtils::Command::MM' => '6.65_01',
            'ExtUtils::Liblist'     => '6.65_01',
            'ExtUtils::Liblist::Kid'=> '6.65_01',
            'ExtUtils::MM'          => '6.65_01',
            'ExtUtils::MM_AIX'      => '6.65_01',
            'ExtUtils::MM_Any'      => '6.65_01',
            'ExtUtils::MM_BeOS'     => '6.65_01',
            'ExtUtils::MM_Cygwin'   => '6.65_01',
            'ExtUtils::MM_DOS'      => '6.65_01',
            'ExtUtils::MM_Darwin'   => '6.65_01',
            'ExtUtils::MM_MacOS'    => '6.65_01',
            'ExtUtils::MM_NW5'      => '6.65_01',
            'ExtUtils::MM_OS2'      => '6.65_01',
            'ExtUtils::MM_QNX'      => '6.65_01',
            'ExtUtils::MM_UWIN'     => '6.65_01',
            'ExtUtils::MM_Unix'     => '6.65_01',
            'ExtUtils::MM_VMS'      => '6.65_01',
            'ExtUtils::MM_VOS'      => '6.65_01',
            'ExtUtils::MM_Win32'    => '6.65_01',
            'ExtUtils::MM_Win95'    => '6.65_01',
            'ExtUtils::MY'          => '6.65_01',
            'ExtUtils::MakeMaker'   => '6.65_01',
            'ExtUtils::MakeMaker::Config'=> '6.65_01',
            'ExtUtils::Mkbootstrap' => '6.65_01',
            'ExtUtils::Mksymlists'  => '6.65_01',
            'ExtUtils::testlib'     => '6.65_01',
            'File::Copy'            => '2.26',
            'File::Temp'            => '0.23',
            'Getopt::Long'          => '2.39',
            'Hash::Util'            => '0.15',
            'I18N::Langinfo'        => '0.10',
            'IPC::Cmd'              => '0.80',
            'JSON::PP'              => '2.27202',
            'Locale::Codes'         => '3.25',
            'Locale::Codes::Constants'=> '3.25',
            'Locale::Codes::Country'=> '3.25',
            'Locale::Codes::Country_Codes'=> '3.25',
            'Locale::Codes::Country_Retired'=> '3.25',
            'Locale::Codes::Currency'=> '3.25',
            'Locale::Codes::Currency_Codes'=> '3.25',
            'Locale::Codes::Currency_Retired'=> '3.25',
            'Locale::Codes::LangExt'=> '3.25',
            'Locale::Codes::LangExt_Codes'=> '3.25',
            'Locale::Codes::LangExt_Retired'=> '3.25',
            'Locale::Codes::LangFam'=> '3.25',
            'Locale::Codes::LangFam_Codes'=> '3.25',
            'Locale::Codes::LangFam_Retired'=> '3.25',
            'Locale::Codes::LangVar'=> '3.25',
            'Locale::Codes::LangVar_Codes'=> '3.25',
            'Locale::Codes::LangVar_Retired'=> '3.25',
            'Locale::Codes::Language'=> '3.25',
            'Locale::Codes::Language_Codes'=> '3.25',
            'Locale::Codes::Language_Retired'=> '3.25',
            'Locale::Codes::Script' => '3.25',
            'Locale::Codes::Script_Codes'=> '3.25',
            'Locale::Codes::Script_Retired'=> '3.25',
            'Locale::Country'       => '3.25',
            'Locale::Currency'      => '3.25',
            'Locale::Language'      => '3.25',
            'Locale::Script'        => '3.25',
            'Math::BigFloat'        => '1.998',
            'Math::BigFloat::Trace' => '0.32',
            'Math::BigInt'          => '1.9991',
            'Math::BigInt::CalcEmu' => '1.998',
            'Math::BigInt::Trace'   => '0.32',
            'Math::BigRat'          => '0.2604',
            'Module::CoreList'      => '2.84',
            'Module::CoreList::TieHashDelta'=> '2.84',
            'Module::Pluggable'     => '4.7',
            'Net::Ping'             => '2.41',
            'Perl::OSType'          => '1.003',
            'Pod::Simple'           => '3.26',
            'Pod::Simple::BlackBox' => '3.26',
            'Pod::Simple::Checker'  => '3.26',
            'Pod::Simple::Debug'    => '3.26',
            'Pod::Simple::DumpAsText'=> '3.26',
            'Pod::Simple::DumpAsXML'=> '3.26',
            'Pod::Simple::HTML'     => '3.26',
            'Pod::Simple::HTMLBatch'=> '3.26',
            'Pod::Simple::LinkSection'=> '3.26',
            'Pod::Simple::Methody'  => '3.26',
            'Pod::Simple::Progress' => '3.26',
            'Pod::Simple::PullParser'=> '3.26',
            'Pod::Simple::PullParserEndToken'=> '3.26',
            'Pod::Simple::PullParserStartToken'=> '3.26',
            'Pod::Simple::PullParserTextToken'=> '3.26',
            'Pod::Simple::PullParserToken'=> '3.26',
            'Pod::Simple::RTF'      => '3.26',
            'Pod::Simple::Search'   => '3.26',
            'Pod::Simple::SimpleTree'=> '3.26',
            'Pod::Simple::Text'     => '3.26',
            'Pod::Simple::TextContent'=> '3.26',
            'Pod::Simple::TiedOutFH'=> '3.26',
            'Pod::Simple::Transcode'=> '3.26',
            'Pod::Simple::TranscodeDumb'=> '3.26',
            'Pod::Simple::TranscodeSmart'=> '3.26',
            'Pod::Simple::XHTML'    => '3.26',
            'Pod::Simple::XMLOutStream'=> '3.26',
            'Safe'                  => '2.35',
            'Term::ReadLine'        => '1.12',
            'Text::ParseWords'      => '3.28',
            'Tie::File'             => '0.99',
            'Unicode::UCD'          => '0.51',
            'Win32'                 => '0.47',
            'bigint'                => '0.33',
            'bignum'                => '0.33',
            'bigrat'                => '0.33',
            'constant'              => '1.27',
            'perlfaq'               => '5.0150042',
            'version'               => '0.9902',
        },
        removed => {
        }
    },
    5.017011 => {
        delta_from => 5.017010,
        changed => {
            'App::Cpan'             => '1.61',
            'B::Deparse'            => '1.20',
            'Config'                => '5.017009',
            'Exporter'              => '5.68',
            'Exporter::Heavy'       => '5.68',
            'ExtUtils::CBuilder'    => '0.280210',
            'ExtUtils::Command::MM' => '6.66',
            'ExtUtils::Liblist'     => '6.66',
            'ExtUtils::Liblist::Kid'=> '6.66',
            'ExtUtils::MM'          => '6.66',
            'ExtUtils::MM_AIX'      => '6.66',
            'ExtUtils::MM_Any'      => '6.66',
            'ExtUtils::MM_BeOS'     => '6.66',
            'ExtUtils::MM_Cygwin'   => '6.66',
            'ExtUtils::MM_DOS'      => '6.66',
            'ExtUtils::MM_Darwin'   => '6.66',
            'ExtUtils::MM_MacOS'    => '6.66',
            'ExtUtils::MM_NW5'      => '6.66',
            'ExtUtils::MM_OS2'      => '6.66',
            'ExtUtils::MM_QNX'      => '6.66',
            'ExtUtils::MM_UWIN'     => '6.66',
            'ExtUtils::MM_Unix'     => '6.66',
            'ExtUtils::MM_VMS'      => '6.66',
            'ExtUtils::MM_VOS'      => '6.66',
            'ExtUtils::MM_Win32'    => '6.66',
            'ExtUtils::MM_Win95'    => '6.66',
            'ExtUtils::MY'          => '6.66',
            'ExtUtils::MakeMaker'   => '6.66',
            'ExtUtils::MakeMaker::Config'=> '6.66',
            'ExtUtils::Mkbootstrap' => '6.66',
            'ExtUtils::Mksymlists'  => '6.66',
            'ExtUtils::testlib'     => '6.66',
            'File::Glob'            => '1.20',
            'IO'                    => '1.28',
            'Module::CoreList'      => '2.87',
            'Module::CoreList::TieHashDelta'=> '2.87',
            'Storable'              => '2.41',
            'bigint'                => '0.34',
            'mro'                   => '1.11',
            'overload'              => '1.22',
            'warnings'              => '1.18',
        },
        removed => {
        }
    },
    5.018000 => {
        delta_from => 5.017011,
        changed => {
            'Carp'                  => '1.29',
            'Carp::Heavy'           => '1.29',
            'Config'                => '5.018000',
            'Hash::Util'            => '0.16',
            'IO::Handle'            => '1.34',
            'IO::Socket'            => '1.36',
            'Module::CoreList'      => '2.89',
            'Module::CoreList::TieHashDelta'=> '2.89',
            'Pod::Simple'           => '3.28',
            'Pod::Simple::BlackBox' => '3.28',
            'Pod::Simple::Checker'  => '3.28',
            'Pod::Simple::Debug'    => '3.28',
            'Pod::Simple::DumpAsText'=> '3.28',
            'Pod::Simple::DumpAsXML'=> '3.28',
            'Pod::Simple::HTML'     => '3.28',
            'Pod::Simple::HTMLBatch'=> '3.28',
            'Pod::Simple::LinkSection'=> '3.28',
            'Pod::Simple::Methody'  => '3.28',
            'Pod::Simple::Progress' => '3.28',
            'Pod::Simple::PullParser'=> '3.28',
            'Pod::Simple::PullParserEndToken'=> '3.28',
            'Pod::Simple::PullParserStartToken'=> '3.28',
            'Pod::Simple::PullParserTextToken'=> '3.28',
            'Pod::Simple::PullParserToken'=> '3.28',
            'Pod::Simple::RTF'      => '3.28',
            'Pod::Simple::Search'   => '3.28',
            'Pod::Simple::SimpleTree'=> '3.28',
            'Pod::Simple::Text'     => '3.28',
            'Pod::Simple::TextContent'=> '3.28',
            'Pod::Simple::TiedOutFH'=> '3.28',
            'Pod::Simple::Transcode'=> '3.28',
            'Pod::Simple::TranscodeDumb'=> '3.28',
            'Pod::Simple::TranscodeSmart'=> '3.28',
            'Pod::Simple::XHTML'    => '3.28',
            'Pod::Simple::XMLOutStream'=> '3.28',
        },
        removed => {
        }
    },
    5.018001 => {
        delta_from => 5.018000,
        changed => {
            'B'                     => '1.42_01',
            'Config'                => '5.018001',
            'Digest::SHA'           => '5.84_01',
            'Module::CoreList'      => '2.96',
            'Module::CoreList::TieHashDelta'=> '2.96',
            'Module::CoreList::Utils'=> '2.96',
        },
        removed => {
           'VMS::Filespec'         => 1,
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
            'B'                     => '1.42_02',
            'B::Concise'            => '0.95_01',
            'Config'                => '5.018002',
            'File::Glob'            => '1.20_01',
            'Module::CoreList'      => '3.03',
            'Module::CoreList::TieHashDelta'=> '3.03',
            'Module::CoreList::Utils'=> '3.03',
        },
    },
    5.018003 => {
        delta_from => 5.018002,
        changed => {
            'Module::CoreList'      => '3.12',
            'Module::CoreList::TieHashDelta'=> '3.12',
            'Module::CoreList::Utils'=> '3.12',
        },
    },
    5.018004 => {
        delta_from => 5.018003,
        changed => {
            'Module::CoreList'      => '3.13',
            'Module::CoreList::TieHashDelta'=> '3.13',
            'Module::CoreList::Utils'=> '3.13',
        },
    },
    5.019000 => {
        delta_from => 5.018000,
        changed => {
            'Config'                => '5.019000',
            'Getopt::Std'           => '1.08',
            'Module::CoreList'      => '2.91',
            'Module::CoreList::TieHashDelta'=> '2.91',
            'Storable'              => '2.42',
            'feature'               => '1.33',
            'utf8'                  => '1.11',
        },
        removed => {
           'Archive::Extract'      => 1,
           'B::Lint'               => 1,
           'B::Lint::Debug'        => 1,
           'CPANPLUS'              => 1,
           'CPANPLUS::Backend'     => 1,
           'CPANPLUS::Backend::RV' => 1,
           'CPANPLUS::Config'      => 1,
           'CPANPLUS::Config::HomeEnv'=> 1,
           'CPANPLUS::Configure'   => 1,
           'CPANPLUS::Configure::Setup'=> 1,
           'CPANPLUS::Dist'        => 1,
           'CPANPLUS::Dist::Autobundle'=> 1,
           'CPANPLUS::Dist::Base'  => 1,
           'CPANPLUS::Dist::Build' => 1,
           'CPANPLUS::Dist::Build::Constants'=> 1,
           'CPANPLUS::Dist::MM'    => 1,
           'CPANPLUS::Dist::Sample'=> 1,
           'CPANPLUS::Error'       => 1,
           'CPANPLUS::Internals'   => 1,
           'CPANPLUS::Internals::Constants'=> 1,
           'CPANPLUS::Internals::Constants::Report'=> 1,
           'CPANPLUS::Internals::Extract'=> 1,
           'CPANPLUS::Internals::Fetch'=> 1,
           'CPANPLUS::Internals::Report'=> 1,
           'CPANPLUS::Internals::Search'=> 1,
           'CPANPLUS::Internals::Source'=> 1,
           'CPANPLUS::Internals::Source::Memory'=> 1,
           'CPANPLUS::Internals::Source::SQLite'=> 1,
           'CPANPLUS::Internals::Source::SQLite::Tie'=> 1,
           'CPANPLUS::Internals::Utils'=> 1,
           'CPANPLUS::Internals::Utils::Autoflush'=> 1,
           'CPANPLUS::Module'      => 1,
           'CPANPLUS::Module::Author'=> 1,
           'CPANPLUS::Module::Author::Fake'=> 1,
           'CPANPLUS::Module::Checksums'=> 1,
           'CPANPLUS::Module::Fake'=> 1,
           'CPANPLUS::Module::Signature'=> 1,
           'CPANPLUS::Selfupdate'  => 1,
           'CPANPLUS::Shell'       => 1,
           'CPANPLUS::Shell::Classic'=> 1,
           'CPANPLUS::Shell::Default'=> 1,
           'CPANPLUS::Shell::Default::Plugins::CustomSource'=> 1,
           'CPANPLUS::Shell::Default::Plugins::Remote'=> 1,
           'CPANPLUS::Shell::Default::Plugins::Source'=> 1,
           'Devel::InnerPackage'   => 1,
           'File::CheckTree'       => 1,
           'Log::Message'          => 1,
           'Log::Message::Config'  => 1,
           'Log::Message::Handlers'=> 1,
           'Log::Message::Item'    => 1,
           'Log::Message::Simple'  => 1,
           'Module::Pluggable'     => 1,
           'Module::Pluggable::Object'=> 1,
           'Object::Accessor'      => 1,
           'Pod::LaTeX'            => 1,
           'Term::UI'              => 1,
           'Term::UI::History'     => 1,
           'Text::Soundex'         => 1,
        }
    },
    5.019001 => {
        delta_from => 5.019000,
        changed => {
            'App::Prove'            => '3.28',
            'App::Prove::State'     => '3.28',
            'App::Prove::State::Result'=> '3.28',
            'App::Prove::State::Result::Test'=> '3.28',
            'Archive::Tar'          => '1.92',
            'Archive::Tar::Constant'=> '1.92',
            'Archive::Tar::File'    => '1.92',
            'Attribute::Handlers'   => '0.95',
            'B'                     => '1.43',
            'B::Concise'            => '0.96',
            'B::Deparse'            => '1.21',
            'B::Showlex'            => '1.04',
            'Benchmark'             => '1.16',
            'CPAN::Meta'            => '2.131560',
            'CPAN::Meta::Converter' => '2.131560',
            'CPAN::Meta::Feature'   => '2.131560',
            'CPAN::Meta::History'   => '2.131560',
            'CPAN::Meta::Prereqs'   => '2.131560',
            'CPAN::Meta::Spec'      => '2.131560',
            'CPAN::Meta::Validator' => '2.131560',
            'Carp'                  => '1.30',
            'Carp::Heavy'           => '1.30',
            'Compress::Raw::Bzip2'  => '2.061',
            'Compress::Raw::Zlib'   => '2.061',
            'Compress::Zlib'        => '2.061',
            'Config'                => '5.019001',
            'Config::Perl::V'       => '0.18',
            'Cwd'                   => '3.41',
            'DB'                    => '1.06',
            'DB_File'               => '1.828',
            'Data::Dumper'          => '2.146',
            'Encode'                => '2.51',
            'Encode::CN::HZ'        => '2.06',
            'Encode::GSM0338'       => '2.03',
            'Encode::Unicode::UTF7' => '2.07',
            'ExtUtils::CBuilder::Base'=> '0.280210',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280210',
            'ExtUtils::Command::MM' => '6.68',
            'ExtUtils::Install'     => '1.60',
            'ExtUtils::Liblist'     => '6.68',
            'ExtUtils::Liblist::Kid'=> '6.68',
            'ExtUtils::MM'          => '6.68',
            'ExtUtils::MM_AIX'      => '6.68',
            'ExtUtils::MM_Any'      => '6.68',
            'ExtUtils::MM_BeOS'     => '6.68',
            'ExtUtils::MM_Cygwin'   => '6.68',
            'ExtUtils::MM_DOS'      => '6.68',
            'ExtUtils::MM_Darwin'   => '6.68',
            'ExtUtils::MM_MacOS'    => '6.68',
            'ExtUtils::MM_NW5'      => '6.68',
            'ExtUtils::MM_OS2'      => '6.68',
            'ExtUtils::MM_QNX'      => '6.68',
            'ExtUtils::MM_UWIN'     => '6.68',
            'ExtUtils::MM_Unix'     => '6.68',
            'ExtUtils::MM_VMS'      => '6.68',
            'ExtUtils::MM_VOS'      => '6.68',
            'ExtUtils::MM_Win32'    => '6.68',
            'ExtUtils::MM_Win95'    => '6.68',
            'ExtUtils::MY'          => '6.68',
            'ExtUtils::MakeMaker'   => '6.68',
            'ExtUtils::MakeMaker::Config'=> '6.68',
            'ExtUtils::Mkbootstrap' => '6.68',
            'ExtUtils::Mksymlists'  => '6.68',
            'ExtUtils::ParseXS'     => '3.19',
            'ExtUtils::testlib'     => '6.68',
            'Fatal'                 => '2.19',
            'File::Copy'            => '2.27',
            'File::DosGlob'         => '1.11',
            'File::Fetch'           => '0.42',
            'File::Find'            => '1.24',
            'File::Spec'            => '3.41',
            'File::Spec::Cygwin'    => '3.41',
            'File::Spec::Epoc'      => '3.41',
            'File::Spec::Mac'       => '3.41',
            'File::Spec::OS2'       => '3.41',
            'File::Spec::Unix'      => '3.41',
            'File::Spec::VMS'       => '3.41',
            'File::Spec::Win32'     => '3.41',
            'File::Temp'            => '0.2301',
            'Filter::Simple'        => '0.90',
            'Filter::Util::Call'    => '1.49',
            'Getopt::Long'          => '2.4',
            'HTTP::Tiny'            => '0.031',
            'Hash::Util::FieldHash' => '1.11',
            'IO::Compress::Adapter::Bzip2'=> '2.061',
            'IO::Compress::Adapter::Deflate'=> '2.061',
            'IO::Compress::Adapter::Identity'=> '2.061',
            'IO::Compress::Base'    => '2.061',
            'IO::Compress::Base::Common'=> '2.061',
            'IO::Compress::Bzip2'   => '2.061',
            'IO::Compress::Deflate' => '2.061',
            'IO::Compress::Gzip'    => '2.061',
            'IO::Compress::Gzip::Constants'=> '2.061',
            'IO::Compress::RawDeflate'=> '2.061',
            'IO::Compress::Zip'     => '2.061',
            'IO::Compress::Zip::Constants'=> '2.061',
            'IO::Compress::Zlib::Constants'=> '2.061',
            'IO::Compress::Zlib::Extra'=> '2.061',
            'IO::Handle'            => '1.35',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.061',
            'IO::Uncompress::Adapter::Identity'=> '2.061',
            'IO::Uncompress::Adapter::Inflate'=> '2.061',
            'IO::Uncompress::AnyInflate'=> '2.061',
            'IO::Uncompress::AnyUncompress'=> '2.061',
            'IO::Uncompress::Base'  => '2.061',
            'IO::Uncompress::Bunzip2'=> '2.061',
            'IO::Uncompress::Gunzip'=> '2.061',
            'IO::Uncompress::Inflate'=> '2.061',
            'IO::Uncompress::RawInflate'=> '2.061',
            'IO::Uncompress::Unzip' => '2.061',
            'IPC::Open3'            => '1.14',
            'Locale::Codes'         => '3.26',
            'Locale::Codes::Constants'=> '3.26',
            'Locale::Codes::Country'=> '3.26',
            'Locale::Codes::Country_Codes'=> '3.26',
            'Locale::Codes::Country_Retired'=> '3.26',
            'Locale::Codes::Currency'=> '3.26',
            'Locale::Codes::Currency_Codes'=> '3.26',
            'Locale::Codes::Currency_Retired'=> '3.26',
            'Locale::Codes::LangExt'=> '3.26',
            'Locale::Codes::LangExt_Codes'=> '3.26',
            'Locale::Codes::LangExt_Retired'=> '3.26',
            'Locale::Codes::LangFam'=> '3.26',
            'Locale::Codes::LangFam_Codes'=> '3.26',
            'Locale::Codes::LangFam_Retired'=> '3.26',
            'Locale::Codes::LangVar'=> '3.26',
            'Locale::Codes::LangVar_Codes'=> '3.26',
            'Locale::Codes::LangVar_Retired'=> '3.26',
            'Locale::Codes::Language'=> '3.26',
            'Locale::Codes::Language_Codes'=> '3.26',
            'Locale::Codes::Language_Retired'=> '3.26',
            'Locale::Codes::Script' => '3.26',
            'Locale::Codes::Script_Codes'=> '3.26',
            'Locale::Codes::Script_Retired'=> '3.26',
            'Locale::Country'       => '3.26',
            'Locale::Currency'      => '3.26',
            'Locale::Language'      => '3.26',
            'Locale::Maketext'      => '1.24',
            'Locale::Script'        => '3.26',
            'Math::BigFloat'        => '1.999',
            'Math::BigInt'          => '1.9992',
            'Math::BigInt::Calc'    => '1.998',
            'Math::BigInt::CalcEmu' => '1.9991',
            'Math::BigRat'          => '0.2606',
            'Module::Build'         => '0.4005',
            'Module::Build::Base'   => '0.4005',
            'Module::Build::Compat' => '0.4005',
            'Module::Build::Config' => '0.4005',
            'Module::Build::Cookbook'=> '0.4005',
            'Module::Build::Dumper' => '0.4005',
            'Module::Build::ModuleInfo'=> '0.4005',
            'Module::Build::Notes'  => '0.4005',
            'Module::Build::PPMMaker'=> '0.4005',
            'Module::Build::Platform::Amiga'=> '0.4005',
            'Module::Build::Platform::Default'=> '0.4005',
            'Module::Build::Platform::EBCDIC'=> '0.4005',
            'Module::Build::Platform::MPEiX'=> '0.4005',
            'Module::Build::Platform::MacOS'=> '0.4005',
            'Module::Build::Platform::RiscOS'=> '0.4005',
            'Module::Build::Platform::Unix'=> '0.4005',
            'Module::Build::Platform::VMS'=> '0.4005',
            'Module::Build::Platform::VOS'=> '0.4005',
            'Module::Build::Platform::Windows'=> '0.4005',
            'Module::Build::Platform::aix'=> '0.4005',
            'Module::Build::Platform::cygwin'=> '0.4005',
            'Module::Build::Platform::darwin'=> '0.4005',
            'Module::Build::Platform::os2'=> '0.4005',
            'Module::Build::PodParser'=> '0.4005',
            'Module::CoreList'      => '2.92',
            'Module::CoreList::TieHashDelta'=> '2.92',
            'Module::CoreList::Utils'=> '2.92',
            'Module::Metadata'      => '1.000014',
            'Net::Ping'             => '2.42',
            'OS2::Process'          => '1.09',
            'POSIX'                 => '1.33',
            'Pod::Find'             => '1.61',
            'Pod::Html'             => '1.19',
            'Pod::InputObjects'     => '1.61',
            'Pod::ParseUtils'       => '1.61',
            'Pod::Parser'           => '1.61',
            'Pod::Perldoc'          => '3.20',
            'Pod::Perldoc::BaseTo'  => '3.20',
            'Pod::Perldoc::GetOptsOO'=> '3.20',
            'Pod::Perldoc::ToANSI'  => '3.20',
            'Pod::Perldoc::ToChecker'=> '3.20',
            'Pod::Perldoc::ToMan'   => '3.20',
            'Pod::Perldoc::ToNroff' => '3.20',
            'Pod::Perldoc::ToPod'   => '3.20',
            'Pod::Perldoc::ToRtf'   => '3.20',
            'Pod::Perldoc::ToTerm'  => '3.20',
            'Pod::Perldoc::ToText'  => '3.20',
            'Pod::Perldoc::ToTk'    => '3.20',
            'Pod::Perldoc::ToXml'   => '3.20',
            'Pod::Select'           => '1.61',
            'Pod::Usage'            => '1.63',
            'Safe'                  => '2.36',
            'Storable'              => '2.43',
            'Sys::Hostname'         => '1.18',
            'Sys::Syslog'           => '0.33',
            'TAP::Base'             => '3.28',
            'TAP::Formatter::Base'  => '3.28',
            'TAP::Formatter::Color' => '3.28',
            'TAP::Formatter::Console'=> '3.28',
            'TAP::Formatter::Console::ParallelSession'=> '3.28',
            'TAP::Formatter::Console::Session'=> '3.28',
            'TAP::Formatter::File'  => '3.28',
            'TAP::Formatter::File::Session'=> '3.28',
            'TAP::Formatter::Session'=> '3.28',
            'TAP::Harness'          => '3.28',
            'TAP::Object'           => '3.28',
            'TAP::Parser'           => '3.28',
            'TAP::Parser::Aggregator'=> '3.28',
            'TAP::Parser::Grammar'  => '3.28',
            'TAP::Parser::Iterator' => '3.28',
            'TAP::Parser::Iterator::Array'=> '3.28',
            'TAP::Parser::Iterator::Process'=> '3.28',
            'TAP::Parser::Iterator::Stream'=> '3.28',
            'TAP::Parser::IteratorFactory'=> '3.28',
            'TAP::Parser::Multiplexer'=> '3.28',
            'TAP::Parser::Result'   => '3.28',
            'TAP::Parser::Result::Bailout'=> '3.28',
            'TAP::Parser::Result::Comment'=> '3.28',
            'TAP::Parser::Result::Plan'=> '3.28',
            'TAP::Parser::Result::Pragma'=> '3.28',
            'TAP::Parser::Result::Test'=> '3.28',
            'TAP::Parser::Result::Unknown'=> '3.28',
            'TAP::Parser::Result::Version'=> '3.28',
            'TAP::Parser::Result::YAML'=> '3.28',
            'TAP::Parser::ResultFactory'=> '3.28',
            'TAP::Parser::Scheduler'=> '3.28',
            'TAP::Parser::Scheduler::Job'=> '3.28',
            'TAP::Parser::Scheduler::Spinner'=> '3.28',
            'TAP::Parser::Source'   => '3.28',
            'TAP::Parser::SourceHandler'=> '3.28',
            'TAP::Parser::SourceHandler::Executable'=> '3.28',
            'TAP::Parser::SourceHandler::File'=> '3.28',
            'TAP::Parser::SourceHandler::Handle'=> '3.28',
            'TAP::Parser::SourceHandler::Perl'=> '3.28',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.28',
            'TAP::Parser::Utils'    => '3.28',
            'TAP::Parser::YAMLish::Reader'=> '3.28',
            'TAP::Parser::YAMLish::Writer'=> '3.28',
            'Term::ReadLine'        => '1.13',
            'Test::Harness'         => '3.28',
            'Text::Tabs'            => '2013.0523',
            'Text::Wrap'            => '2013.0523',
            'Thread'                => '3.04',
            'Tie::File'             => '1.00',
            'Time::Piece'           => '1.2002',
            'Unicode::Collate'      => '0.98',
            'Unicode::UCD'          => '0.53',
            'XS::APItest'           => '0.53',
            '_charnames'            => '1.37',
            'autodie'               => '2.19',
            'autodie::exception'    => '2.19',
            'autodie::exception::system'=> '2.19',
            'autodie::hints'        => '2.19',
            'autodie::skip'         => '2.19',
            'bigint'                => '0.35',
            'charnames'             => '1.38',
            'encoding'              => '2.12',
            'inc::latest'           => '0.4005',
            'mro'                   => '1.12',
            'perlfaq'               => '5.0150043',
            're'                    => '0.25',
            'threads'               => '1.87',
            'threads::shared'       => '1.44',
            'utf8'                  => '1.12',
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
            'B'                     => '1.44',
            'B::Concise'            => '0.98',
            'B::Deparse'            => '1.22',
            'Benchmark'             => '1.17',
            'Class::Struct'         => '0.65',
            'Config'                => '5.019002',
            'DB'                    => '1.07',
            'DBM_Filter'            => '0.06',
            'DBM_Filter::compress'  => '0.03',
            'DBM_Filter::encode'    => '0.03',
            'DBM_Filter::int32'     => '0.03',
            'DBM_Filter::null'      => '0.03',
            'DBM_Filter::utf8'      => '0.03',
            'DB_File'               => '1.829',
            'Data::Dumper'          => '2.147',
            'Devel::Peek'           => '1.12',
            'Digest::MD5'           => '2.53',
            'Digest::SHA'           => '5.85',
            'English'               => '1.07',
            'Errno'                 => '1.19',
            'ExtUtils::Embed'       => '1.31',
            'ExtUtils::Miniperl'    => '1',
            'ExtUtils::ParseXS'     => '3.21',
            'ExtUtils::ParseXS::Constants'=> '3.21',
            'ExtUtils::ParseXS::CountLines'=> '3.21',
            'ExtUtils::ParseXS::Eval'=> '3.19',
            'ExtUtils::ParseXS::Utilities'=> '3.21',
            'ExtUtils::Typemaps'    => '3.21',
            'ExtUtils::Typemaps::Cmd'=> '3.21',
            'ExtUtils::Typemaps::InputMap'=> '3.21',
            'ExtUtils::Typemaps::OutputMap'=> '3.21',
            'ExtUtils::Typemaps::Type'=> '3.21',
            'ExtUtils::XSSymSet'    => '1.3',
            'Fatal'                 => '2.20',
            'File::Basename'        => '2.85',
            'File::Spec::VMS'       => '3.43',
            'File::Spec::Win32'     => '3.42',
            'Getopt::Long'          => '2.41',
            'Getopt::Std'           => '1.09',
            'HTTP::Tiny'            => '0.034',
            'Hash::Util::FieldHash' => '1.12',
            'I18N::Langinfo'        => '0.11',
            'IO::Socket::INET'      => '1.34',
            'IO::Socket::UNIX'      => '1.25',
            'IPC::Cmd'              => '0.82',
            'MIME::Base64'          => '3.14',
            'Module::CoreList'      => '2.94',
            'Module::CoreList::TieHashDelta'=> '2.94',
            'Module::CoreList::Utils'=> '2.94',
            'POSIX'                 => '1.34',
            'Params::Check'         => '0.38',
            'Parse::CPAN::Meta'     => '1.4405',
            'Pod::Functions'        => '1.07',
            'Pod::Html'             => '1.2',
            'Safe'                  => '2.37',
            'Socket'                => '2.010',
            'Storable'              => '2.45',
            'Text::ParseWords'      => '3.29',
            'Tie::Array'            => '1.06',
            'Tie::Hash'             => '1.05',
            'Tie::Scalar'           => '1.03',
            'Time::Piece'           => '1.21',
            'Time::Seconds'         => '1.21',
            'XS::APItest'           => '0.54',
            'autodie'               => '2.20',
            'autodie::exception'    => '2.20',
            'autodie::exception::system'=> '2.20',
            'autodie::hints'        => '2.20',
            'autodie::skip'         => '2.20',
            'base'                  => '2.19',
            'deprecate'             => '0.03',
            'if'                    => '0.0603',
            'integer'               => '1.01',
            'strict'                => '1.08',
            'subs'                  => '1.02',
            'vmsish'                => '1.04',
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
            'B'                     => '1.45',
            'CPAN::Meta'            => '2.132140',
            'CPAN::Meta::Converter' => '2.132140',
            'CPAN::Meta::Feature'   => '2.132140',
            'CPAN::Meta::History'   => '2.132140',
            'CPAN::Meta::Prereqs'   => '2.132140',
            'CPAN::Meta::Spec'      => '2.132140',
            'CPAN::Meta::Validator' => '2.132140',
            'Carp'                  => '1.31',
            'Carp::Heavy'           => '1.31',
            'Compress::Raw::Bzip2'  => '2.062',
            'Compress::Raw::Zlib'   => '2.062',
            'Compress::Zlib'        => '2.062',
            'Config'                => '5.019003',
            'Config::Perl::V'       => '0.19',
            'Cwd'                   => '3.44',
            'Data::Dumper'          => '2.148',
            'Devel::PPPort'         => '3.21',
            'Devel::Peek'           => '1.13',
            'DynaLoader'            => '1.19',
            'Encode'                => '2.52',
            'Encode::Alias'         => '2.17',
            'Encode::Encoding'      => '2.06',
            'Encode::GSM0338'       => '2.04',
            'Encode::MIME::Header'  => '2.14',
            'Encode::Unicode'       => '2.08',
            'English'               => '1.08',
            'Exporter'              => '5.69',
            'Exporter::Heavy'       => '5.69',
            'ExtUtils::Command::MM' => '6.72',
            'ExtUtils::Liblist'     => '6.72',
            'ExtUtils::Liblist::Kid'=> '6.72',
            'ExtUtils::MM'          => '6.72',
            'ExtUtils::MM_AIX'      => '6.72',
            'ExtUtils::MM_Any'      => '6.72',
            'ExtUtils::MM_BeOS'     => '6.72',
            'ExtUtils::MM_Cygwin'   => '6.72',
            'ExtUtils::MM_DOS'      => '6.72',
            'ExtUtils::MM_Darwin'   => '6.72',
            'ExtUtils::MM_MacOS'    => '6.72',
            'ExtUtils::MM_NW5'      => '6.72',
            'ExtUtils::MM_OS2'      => '6.72',
            'ExtUtils::MM_QNX'      => '6.72',
            'ExtUtils::MM_UWIN'     => '6.72',
            'ExtUtils::MM_Unix'     => '6.72',
            'ExtUtils::MM_VMS'      => '6.72',
            'ExtUtils::MM_VOS'      => '6.72',
            'ExtUtils::MM_Win32'    => '6.72',
            'ExtUtils::MM_Win95'    => '6.72',
            'ExtUtils::MY'          => '6.72',
            'ExtUtils::MakeMaker'   => '6.72',
            'ExtUtils::MakeMaker::Config'=> '6.72',
            'ExtUtils::Mkbootstrap' => '6.72',
            'ExtUtils::Mksymlists'  => '6.72',
            'ExtUtils::ParseXS::Eval'=> '3.21',
            'ExtUtils::testlib'     => '6.72',
            'File::Spec'            => '3.44',
            'File::Spec::Cygwin'    => '3.44',
            'File::Spec::Epoc'      => '3.44',
            'File::Spec::Functions' => '3.44',
            'File::Spec::Mac'       => '3.44',
            'File::Spec::OS2'       => '3.44',
            'File::Spec::Unix'      => '3.44',
            'File::Spec::VMS'       => '3.44',
            'File::Spec::Win32'     => '3.44',
            'Getopt::Std'           => '1.10',
            'IO::Compress::Adapter::Bzip2'=> '2.062',
            'IO::Compress::Adapter::Deflate'=> '2.062',
            'IO::Compress::Adapter::Identity'=> '2.062',
            'IO::Compress::Base'    => '2.062',
            'IO::Compress::Base::Common'=> '2.062',
            'IO::Compress::Bzip2'   => '2.062',
            'IO::Compress::Deflate' => '2.062',
            'IO::Compress::Gzip'    => '2.062',
            'IO::Compress::Gzip::Constants'=> '2.062',
            'IO::Compress::RawDeflate'=> '2.062',
            'IO::Compress::Zip'     => '2.062',
            'IO::Compress::Zip::Constants'=> '2.062',
            'IO::Compress::Zlib::Constants'=> '2.062',
            'IO::Compress::Zlib::Extra'=> '2.062',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.062',
            'IO::Uncompress::Adapter::Identity'=> '2.062',
            'IO::Uncompress::Adapter::Inflate'=> '2.062',
            'IO::Uncompress::AnyInflate'=> '2.062',
            'IO::Uncompress::AnyUncompress'=> '2.062',
            'IO::Uncompress::Base'  => '2.062',
            'IO::Uncompress::Bunzip2'=> '2.062',
            'IO::Uncompress::Gunzip'=> '2.062',
            'IO::Uncompress::Inflate'=> '2.062',
            'IO::Uncompress::RawInflate'=> '2.062',
            'IO::Uncompress::Unzip' => '2.062',
            'IPC::Cmd'              => '0.84',
            'IPC::Msg'              => '2.04',
            'IPC::Open3'            => '1.15',
            'IPC::Semaphore'        => '2.04',
            'IPC::SharedMem'        => '2.04',
            'IPC::SysV'             => '2.04',
            'List::Util'            => '1.31',
            'List::Util::XS'        => '1.31',
            'Math::BigFloat::Trace' => '0.36',
            'Math::BigInt::Trace'   => '0.36',
            'Module::Build'         => '0.4007',
            'Module::Build::Base'   => '0.4007',
            'Module::Build::Compat' => '0.4007',
            'Module::Build::Config' => '0.4007',
            'Module::Build::Cookbook'=> '0.4007',
            'Module::Build::Dumper' => '0.4007',
            'Module::Build::ModuleInfo'=> '0.4007',
            'Module::Build::Notes'  => '0.4007',
            'Module::Build::PPMMaker'=> '0.4007',
            'Module::Build::Platform::Default'=> '0.4007',
            'Module::Build::Platform::MacOS'=> '0.4007',
            'Module::Build::Platform::Unix'=> '0.4007',
            'Module::Build::Platform::VMS'=> '0.4007',
            'Module::Build::Platform::VOS'=> '0.4007',
            'Module::Build::Platform::Windows'=> '0.4007',
            'Module::Build::Platform::aix'=> '0.4007',
            'Module::Build::Platform::cygwin'=> '0.4007',
            'Module::Build::Platform::darwin'=> '0.4007',
            'Module::Build::Platform::os2'=> '0.4007',
            'Module::Build::PodParser'=> '0.4007',
            'Module::CoreList'      => '2.97',
            'Module::CoreList::TieHashDelta'=> '2.97',
            'Module::CoreList::Utils'=> '2.97',
            'Net::Cmd'              => '2.30',
            'Net::Config'           => '1.12',
            'Net::Domain'           => '2.22',
            'Net::FTP'              => '2.78',
            'Net::FTP::dataconn'    => '0.12',
            'Net::NNTP'             => '2.25',
            'Net::Netrc'            => '2.14',
            'Net::POP3'             => '2.30',
            'Net::SMTP'             => '2.32',
            'PerlIO'                => '1.08',
            'Pod::Functions'        => '1.08',
            'Scalar::Util'          => '1.31',
            'Socket'                => '2.011',
            'Storable'              => '2.46',
            'Time::HiRes'           => '1.9726',
            'Time::Piece'           => '1.22',
            'Time::Seconds'         => '1.22',
            'XS::APItest'           => '0.55',
            'bigint'                => '0.36',
            'bignum'                => '0.36',
            'bigrat'                => '0.36',
            'constant'              => '1.28',
            'diagnostics'           => '1.32',
            'inc::latest'           => '0.4007',
            'mro'                   => '1.13',
            'parent'                => '0.226',
            'utf8'                  => '1.13',
            'version'               => '0.9903',
        },
        removed => {
           'Module::Build::Platform::Amiga'=> 1,
           'Module::Build::Platform::EBCDIC'=> 1,
           'Module::Build::Platform::MPEiX'=> 1,
           'Module::Build::Platform::RiscOS'=> 1,
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
            'B'                     => '1.46',
            'B::Concise'            => '0.99',
            'B::Deparse'            => '1.23',
            'CPAN'                  => '2.03',
            'CPAN::Meta'            => '2.132620',
            'CPAN::Meta::Converter' => '2.132620',
            'CPAN::Meta::Feature'   => '2.132620',
            'CPAN::Meta::History'   => '2.132620',
            'CPAN::Meta::Prereqs'   => '2.132620',
            'CPAN::Meta::Requirements'=> '2.123',
            'CPAN::Meta::Spec'      => '2.132620',
            'CPAN::Meta::Validator' => '2.132620',
            'Carp'                  => '1.32',
            'Carp::Heavy'           => '1.32',
            'Config'                => '5.019004',
            'Data::Dumper'          => '2.149',
            'Devel::Peek'           => '1.14',
            'DynaLoader'            => '1.20',
            'Encode'                => '2.55',
            'Encode::Alias'         => '2.18',
            'Encode::CN::HZ'        => '2.07',
            'Encode::Encoder'       => '2.03',
            'Encode::Encoding'      => '2.07',
            'Encode::GSM0338'       => '2.05',
            'Encode::Guess'         => '2.06',
            'Encode::JP::JIS7'      => '2.05',
            'Encode::KR::2022_KR'   => '2.03',
            'Encode::MIME::Header'  => '2.15',
            'Encode::MIME::Header::ISO_2022_JP'=> '1.04',
            'Encode::Unicode'       => '2.09',
            'Encode::Unicode::UTF7' => '2.08',
            'Errno'                 => '1.20',
            'Exporter'              => '5.70',
            'Exporter::Heavy'       => '5.70',
            'ExtUtils::CBuilder'    => '0.280212',
            'ExtUtils::CBuilder::Base'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280212',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280212',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280212',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280212',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280212',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280212',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280212',
            'ExtUtils::Command'     => '1.18',
            'ExtUtils::Command::MM' => '6.76',
            'ExtUtils::Liblist'     => '6.76',
            'ExtUtils::Liblist::Kid'=> '6.76',
            'ExtUtils::MM'          => '6.76',
            'ExtUtils::MM_AIX'      => '6.76',
            'ExtUtils::MM_Any'      => '6.76',
            'ExtUtils::MM_BeOS'     => '6.76',
            'ExtUtils::MM_Cygwin'   => '6.76',
            'ExtUtils::MM_DOS'      => '6.76',
            'ExtUtils::MM_Darwin'   => '6.76',
            'ExtUtils::MM_MacOS'    => '6.76',
            'ExtUtils::MM_NW5'      => '6.76',
            'ExtUtils::MM_OS2'      => '6.76',
            'ExtUtils::MM_QNX'      => '6.76',
            'ExtUtils::MM_UWIN'     => '6.76',
            'ExtUtils::MM_Unix'     => '6.76',
            'ExtUtils::MM_VMS'      => '6.76',
            'ExtUtils::MM_VOS'      => '6.76',
            'ExtUtils::MM_Win32'    => '6.76',
            'ExtUtils::MM_Win95'    => '6.76',
            'ExtUtils::MY'          => '6.76',
            'ExtUtils::MakeMaker'   => '6.76',
            'ExtUtils::MakeMaker::Config'=> '6.76',
            'ExtUtils::Mkbootstrap' => '6.76',
            'ExtUtils::Mksymlists'  => '6.76',
            'ExtUtils::ParseXS'     => '3.23',
            'ExtUtils::ParseXS::Constants'=> '3.23',
            'ExtUtils::ParseXS::CountLines'=> '3.23',
            'ExtUtils::ParseXS::Eval'=> '3.23',
            'ExtUtils::ParseXS::Utilities'=> '3.23',
            'ExtUtils::Typemaps'    => '3.23',
            'ExtUtils::Typemaps::Cmd'=> '3.23',
            'ExtUtils::Typemaps::InputMap'=> '3.23',
            'ExtUtils::Typemaps::OutputMap'=> '3.23',
            'ExtUtils::Typemaps::Type'=> '3.23',
            'ExtUtils::testlib'     => '6.76',
            'Fatal'                 => '2.21',
            'File::Copy'            => '2.28',
            'File::Find'            => '1.25',
            'File::Glob'            => '1.21',
            'FileCache'             => '1.09',
            'HTTP::Tiny'            => '0.035',
            'Hash::Util::FieldHash' => '1.13',
            'I18N::LangTags'        => '0.40',
            'IO'                    => '1.29',
            'IO::Socket'            => '1.37',
            'IPC::Open3'            => '1.16',
            'JSON::PP'              => '2.27202_01',
            'List::Util'            => '1.32',
            'List::Util::XS'        => '1.32',
            'Locale::Codes'         => '3.27',
            'Locale::Codes::Constants'=> '3.27',
            'Locale::Codes::Country'=> '3.27',
            'Locale::Codes::Country_Codes'=> '3.27',
            'Locale::Codes::Country_Retired'=> '3.27',
            'Locale::Codes::Currency'=> '3.27',
            'Locale::Codes::Currency_Codes'=> '3.27',
            'Locale::Codes::Currency_Retired'=> '3.27',
            'Locale::Codes::LangExt'=> '3.27',
            'Locale::Codes::LangExt_Codes'=> '3.27',
            'Locale::Codes::LangExt_Retired'=> '3.27',
            'Locale::Codes::LangFam'=> '3.27',
            'Locale::Codes::LangFam_Codes'=> '3.27',
            'Locale::Codes::LangFam_Retired'=> '3.27',
            'Locale::Codes::LangVar'=> '3.27',
            'Locale::Codes::LangVar_Codes'=> '3.27',
            'Locale::Codes::LangVar_Retired'=> '3.27',
            'Locale::Codes::Language'=> '3.27',
            'Locale::Codes::Language_Codes'=> '3.27',
            'Locale::Codes::Language_Retired'=> '3.27',
            'Locale::Codes::Script' => '3.27',
            'Locale::Codes::Script_Codes'=> '3.27',
            'Locale::Codes::Script_Retired'=> '3.27',
            'Locale::Country'       => '3.27',
            'Locale::Currency'      => '3.27',
            'Locale::Language'      => '3.27',
            'Locale::Script'        => '3.27',
            'Math::BigFloat'        => '1.9991',
            'Math::BigInt'          => '1.9993',
            'Math::BigInt::FastCalc'=> '0.31',
            'Module::CoreList'      => '2.99',
            'Module::CoreList::TieHashDelta'=> '2.99',
            'Module::CoreList::Utils'=> '2.99',
            'Module::Load::Conditional'=> '0.58',
            'Module::Metadata'      => '1.000018',
            'Opcode'                => '1.26',
            'POSIX'                 => '1.35',
            'Parse::CPAN::Meta'     => '1.4407',
            'Perl::OSType'          => '1.005',
            'Pod::Html'             => '1.21',
            'Scalar::Util'          => '1.32',
            'Socket'                => '2.012',
            'Storable'              => '2.47',
            'Term::ReadLine'        => '1.14',
            'Test::Builder'         => '0.98_06',
            'Test::Builder::Module' => '0.98_06',
            'Test::More'            => '0.98_06',
            'Test::Simple'          => '0.98_06',
            'Time::Piece'           => '1.23',
            'Time::Seconds'         => '1.23',
            'Unicode::Collate'      => '0.99',
            'Unicode::UCD'          => '0.54',
            'XS::APItest'           => '0.56',
            'XS::Typemap'           => '0.11',
            '_charnames'            => '1.39',
            'autodie'               => '2.21',
            'autodie::exception'    => '2.21',
            'autodie::exception::system'=> '2.21',
            'autodie::hints'        => '2.21',
            'autodie::skip'         => '2.21',
            'charnames'             => '1.39',
            'diagnostics'           => '1.33',
            'mro'                   => '1.14',
            'parent'                => '0.228',
            'perlfaq'               => '5.0150044',
            're'                    => '0.26',
            'version'               => '0.9904',
            'warnings'              => '1.19',
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
            'App::Prove'            => '3.29',
            'App::Prove::State'     => '3.29',
            'App::Prove::State::Result'=> '3.29',
            'App::Prove::State::Result::Test'=> '3.29',
            'CPAN::Meta'            => '2.132830',
            'CPAN::Meta::Converter' => '2.132830',
            'CPAN::Meta::Feature'   => '2.132830',
            'CPAN::Meta::History'   => '2.132830',
            'CPAN::Meta::Prereqs'   => '2.132830',
            'CPAN::Meta::Requirements'=> '2.125',
            'CPAN::Meta::Spec'      => '2.132830',
            'CPAN::Meta::Validator' => '2.132830',
            'CPAN::Meta::YAML'      => '0.010',
            'Config'                => '5.019005',
            'Cwd'                   => '3.45',
            'ExtUtils::Command::MM' => '6.80',
            'ExtUtils::Install'     => '1.61',
            'ExtUtils::Liblist'     => '6.80',
            'ExtUtils::Liblist::Kid'=> '6.80',
            'ExtUtils::MM'          => '6.80',
            'ExtUtils::MM_AIX'      => '6.80',
            'ExtUtils::MM_Any'      => '6.80',
            'ExtUtils::MM_BeOS'     => '6.80',
            'ExtUtils::MM_Cygwin'   => '6.80',
            'ExtUtils::MM_DOS'      => '6.80',
            'ExtUtils::MM_Darwin'   => '6.80',
            'ExtUtils::MM_MacOS'    => '6.80',
            'ExtUtils::MM_NW5'      => '6.80',
            'ExtUtils::MM_OS2'      => '6.80',
            'ExtUtils::MM_QNX'      => '6.80',
            'ExtUtils::MM_UWIN'     => '6.80',
            'ExtUtils::MM_Unix'     => '6.80',
            'ExtUtils::MM_VMS'      => '6.80',
            'ExtUtils::MM_VOS'      => '6.80',
            'ExtUtils::MM_Win32'    => '6.80',
            'ExtUtils::MM_Win95'    => '6.80',
            'ExtUtils::MY'          => '6.80',
            'ExtUtils::MakeMaker'   => '6.80',
            'ExtUtils::MakeMaker::Config'=> '6.80',
            'ExtUtils::Mkbootstrap' => '6.80',
            'ExtUtils::Mksymlists'  => '6.80',
            'ExtUtils::testlib'     => '6.80',
            'Fatal'                 => '2.22',
            'File::Fetch'           => '0.44',
            'File::Glob'            => '1.22',
            'File::Spec'            => '3.45',
            'File::Spec::Cygwin'    => '3.45',
            'File::Spec::Epoc'      => '3.45',
            'File::Spec::Functions' => '3.45',
            'File::Spec::Mac'       => '3.45',
            'File::Spec::OS2'       => '3.45',
            'File::Spec::Unix'      => '3.45',
            'File::Spec::VMS'       => '3.45',
            'File::Spec::Win32'     => '3.45',
            'File::Temp'            => '0.2304',
            'Getopt::Long'          => '2.42',
            'HTTP::Tiny'            => '0.036',
            'IPC::Cmd'              => '0.84_01',
            'JSON::PP'              => '2.27203',
            'List::Util'            => '1.35',
            'List::Util::XS'        => '1.35',
            'Module::CoreList'      => '3.00',
            'Module::CoreList::TieHashDelta'=> '3.00',
            'Module::CoreList::Utils'=> '3.00',
            'Module::Metadata'      => '1.000019',
            'Parse::CPAN::Meta'     => '1.4409',
            'Perl::OSType'          => '1.006',
            'PerlIO::scalar'        => '0.17',
            'Pod::Man'              => '2.28',
            'Pod::Text'             => '3.18',
            'Pod::Text::Termcap'    => '2.08',
            'Scalar::Util'          => '1.35',
            'TAP::Base'             => '3.29',
            'TAP::Formatter::Base'  => '3.29',
            'TAP::Formatter::Color' => '3.29',
            'TAP::Formatter::Console'=> '3.29',
            'TAP::Formatter::Console::ParallelSession'=> '3.29',
            'TAP::Formatter::Console::Session'=> '3.29',
            'TAP::Formatter::File'  => '3.29',
            'TAP::Formatter::File::Session'=> '3.29',
            'TAP::Formatter::Session'=> '3.29',
            'TAP::Harness'          => '3.29',
            'TAP::Harness::Env'     => '3.29',
            'TAP::Object'           => '3.29',
            'TAP::Parser'           => '3.29',
            'TAP::Parser::Aggregator'=> '3.29',
            'TAP::Parser::Grammar'  => '3.29',
            'TAP::Parser::Iterator' => '3.29',
            'TAP::Parser::Iterator::Array'=> '3.29',
            'TAP::Parser::Iterator::Process'=> '3.29',
            'TAP::Parser::Iterator::Stream'=> '3.29',
            'TAP::Parser::IteratorFactory'=> '3.29',
            'TAP::Parser::Multiplexer'=> '3.29',
            'TAP::Parser::Result'   => '3.29',
            'TAP::Parser::Result::Bailout'=> '3.29',
            'TAP::Parser::Result::Comment'=> '3.29',
            'TAP::Parser::Result::Plan'=> '3.29',
            'TAP::Parser::Result::Pragma'=> '3.29',
            'TAP::Parser::Result::Test'=> '3.29',
            'TAP::Parser::Result::Unknown'=> '3.29',
            'TAP::Parser::Result::Version'=> '3.29',
            'TAP::Parser::Result::YAML'=> '3.29',
            'TAP::Parser::ResultFactory'=> '3.29',
            'TAP::Parser::Scheduler'=> '3.29',
            'TAP::Parser::Scheduler::Job'=> '3.29',
            'TAP::Parser::Scheduler::Spinner'=> '3.29',
            'TAP::Parser::Source'   => '3.29',
            'TAP::Parser::SourceHandler'=> '3.29',
            'TAP::Parser::SourceHandler::Executable'=> '3.29',
            'TAP::Parser::SourceHandler::File'=> '3.29',
            'TAP::Parser::SourceHandler::Handle'=> '3.29',
            'TAP::Parser::SourceHandler::Perl'=> '3.29',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.29',
            'TAP::Parser::YAMLish::Reader'=> '3.29',
            'TAP::Parser::YAMLish::Writer'=> '3.29',
            'Test::Builder'         => '0.99',
            'Test::Builder::Module' => '0.99',
            'Test::Builder::Tester' => '1.23_002',
            'Test::Builder::Tester::Color'=> '1.23_002',
            'Test::Harness'         => '3.29',
            'Test::More'            => '0.99',
            'Test::Simple'          => '0.99',
            'Unicode'               => '6.3.0',
            'Unicode::Normalize'    => '1.17',
            'Unicode::UCD'          => '0.55',
            'attributes'            => '0.22',
            'autodie'               => '2.22',
            'autodie::exception'    => '2.22',
            'autodie::exception::system'=> '2.22',
            'autodie::hints'        => '2.22',
            'autodie::skip'         => '2.22',
            'feature'               => '1.34',
            'threads'               => '1.89',
            'warnings'              => '1.20',
        },
        removed => {
            'TAP::Parser::Utils'    => 1,
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
            'App::Prove'            => '3.30',
            'App::Prove::State'     => '3.30',
            'App::Prove::State::Result'=> '3.30',
            'App::Prove::State::Result::Test'=> '3.30',
            'Archive::Tar'          => '1.96',
            'Archive::Tar::Constant'=> '1.96',
            'Archive::Tar::File'    => '1.96',
            'AutoLoader'            => '5.74',
            'B'                     => '1.47',
            'B::Concise'            => '0.991',
            'B::Debug'              => '1.19',
            'B::Deparse'            => '1.24',
            'Benchmark'             => '1.18',
            'Compress::Raw::Bzip2'  => '2.063',
            'Compress::Raw::Zlib'   => '2.063',
            'Compress::Zlib'        => '2.063',
            'Config'                => '5.019006',
            'DB_File'               => '1.831',
            'Devel::Peek'           => '1.15',
            'DynaLoader'            => '1.21',
            'Errno'                 => '1.20_01',
            'ExtUtils::Command::MM' => '6.82',
            'ExtUtils::Liblist'     => '6.82',
            'ExtUtils::Liblist::Kid'=> '6.82',
            'ExtUtils::MM'          => '6.82',
            'ExtUtils::MM_AIX'      => '6.82',
            'ExtUtils::MM_Any'      => '6.82',
            'ExtUtils::MM_BeOS'     => '6.82',
            'ExtUtils::MM_Cygwin'   => '6.82',
            'ExtUtils::MM_DOS'      => '6.82',
            'ExtUtils::MM_Darwin'   => '6.82',
            'ExtUtils::MM_MacOS'    => '6.82',
            'ExtUtils::MM_NW5'      => '6.82',
            'ExtUtils::MM_OS2'      => '6.82',
            'ExtUtils::MM_QNX'      => '6.82',
            'ExtUtils::MM_UWIN'     => '6.82',
            'ExtUtils::MM_Unix'     => '6.82',
            'ExtUtils::MM_VMS'      => '6.82',
            'ExtUtils::MM_VOS'      => '6.82',
            'ExtUtils::MM_Win32'    => '6.82',
            'ExtUtils::MM_Win95'    => '6.82',
            'ExtUtils::MY'          => '6.82',
            'ExtUtils::MakeMaker'   => '6.82',
            'ExtUtils::MakeMaker::Config'=> '6.82',
            'ExtUtils::Mkbootstrap' => '6.82',
            'ExtUtils::Mksymlists'  => '6.82',
            'ExtUtils::testlib'     => '6.82',
            'File::DosGlob'         => '1.12',
            'File::Find'            => '1.26',
            'File::Glob'            => '1.23',
            'HTTP::Tiny'            => '0.038',
            'IO'                    => '1.30',
            'IO::Compress::Adapter::Bzip2'=> '2.063',
            'IO::Compress::Adapter::Deflate'=> '2.063',
            'IO::Compress::Adapter::Identity'=> '2.063',
            'IO::Compress::Base'    => '2.063',
            'IO::Compress::Base::Common'=> '2.063',
            'IO::Compress::Bzip2'   => '2.063',
            'IO::Compress::Deflate' => '2.063',
            'IO::Compress::Gzip'    => '2.063',
            'IO::Compress::Gzip::Constants'=> '2.063',
            'IO::Compress::RawDeflate'=> '2.063',
            'IO::Compress::Zip'     => '2.063',
            'IO::Compress::Zip::Constants'=> '2.063',
            'IO::Compress::Zlib::Constants'=> '2.063',
            'IO::Compress::Zlib::Extra'=> '2.063',
            'IO::Select'            => '1.22',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.063',
            'IO::Uncompress::Adapter::Identity'=> '2.063',
            'IO::Uncompress::Adapter::Inflate'=> '2.063',
            'IO::Uncompress::AnyInflate'=> '2.063',
            'IO::Uncompress::AnyUncompress'=> '2.063',
            'IO::Uncompress::Base'  => '2.063',
            'IO::Uncompress::Bunzip2'=> '2.063',
            'IO::Uncompress::Gunzip'=> '2.063',
            'IO::Uncompress::Inflate'=> '2.063',
            'IO::Uncompress::RawInflate'=> '2.063',
            'IO::Uncompress::Unzip' => '2.063',
            'IPC::Cmd'              => '0.90',
            'Locale::Maketext'      => '1.25',
            'Module::Build'         => '0.4202',
            'Module::Build::Base'   => '0.4202',
            'Module::Build::Compat' => '0.4202',
            'Module::Build::Config' => '0.4202',
            'Module::Build::Cookbook'=> '0.4202',
            'Module::Build::Dumper' => '0.4202',
            'Module::Build::ModuleInfo'=> '0.4202',
            'Module::Build::Notes'  => '0.4202',
            'Module::Build::PPMMaker'=> '0.4202',
            'Module::Build::Platform::Default'=> '0.4202',
            'Module::Build::Platform::MacOS'=> '0.4202',
            'Module::Build::Platform::Unix'=> '0.4202',
            'Module::Build::Platform::VMS'=> '0.4202',
            'Module::Build::Platform::VOS'=> '0.4202',
            'Module::Build::Platform::Windows'=> '0.4202',
            'Module::Build::Platform::aix'=> '0.4202',
            'Module::Build::Platform::cygwin'=> '0.4202',
            'Module::Build::Platform::darwin'=> '0.4202',
            'Module::Build::Platform::os2'=> '0.4202',
            'Module::Build::PodParser'=> '0.4202',
            'Module::CoreList'      => '3.01',
            'Module::CoreList::TieHashDelta'=> '3.01',
            'Module::CoreList::Utils'=> '3.01',
            'Opcode'                => '1.27',
            'POSIX'                 => '1.36',
            'Package::Constants'    => '0.04',
            'PerlIO::scalar'        => '0.18',
            'PerlIO::via'           => '0.13',
            'SDBM_File'             => '1.10',
            'Socket'                => '2.013',
            'TAP::Base'             => '3.30',
            'TAP::Formatter::Base'  => '3.30',
            'TAP::Formatter::Color' => '3.30',
            'TAP::Formatter::Console'=> '3.30',
            'TAP::Formatter::Console::ParallelSession'=> '3.30',
            'TAP::Formatter::Console::Session'=> '3.30',
            'TAP::Formatter::File'  => '3.30',
            'TAP::Formatter::File::Session'=> '3.30',
            'TAP::Formatter::Session'=> '3.30',
            'TAP::Harness'          => '3.30',
            'TAP::Harness::Env'     => '3.30',
            'TAP::Object'           => '3.30',
            'TAP::Parser'           => '3.30',
            'TAP::Parser::Aggregator'=> '3.30',
            'TAP::Parser::Grammar'  => '3.30',
            'TAP::Parser::Iterator' => '3.30',
            'TAP::Parser::Iterator::Array'=> '3.30',
            'TAP::Parser::Iterator::Process'=> '3.30',
            'TAP::Parser::Iterator::Stream'=> '3.30',
            'TAP::Parser::IteratorFactory'=> '3.30',
            'TAP::Parser::Multiplexer'=> '3.30',
            'TAP::Parser::Result'   => '3.30',
            'TAP::Parser::Result::Bailout'=> '3.30',
            'TAP::Parser::Result::Comment'=> '3.30',
            'TAP::Parser::Result::Plan'=> '3.30',
            'TAP::Parser::Result::Pragma'=> '3.30',
            'TAP::Parser::Result::Test'=> '3.30',
            'TAP::Parser::Result::Unknown'=> '3.30',
            'TAP::Parser::Result::Version'=> '3.30',
            'TAP::Parser::Result::YAML'=> '3.30',
            'TAP::Parser::ResultFactory'=> '3.30',
            'TAP::Parser::Scheduler'=> '3.30',
            'TAP::Parser::Scheduler::Job'=> '3.30',
            'TAP::Parser::Scheduler::Spinner'=> '3.30',
            'TAP::Parser::Source'   => '3.30',
            'TAP::Parser::SourceHandler'=> '3.30',
            'TAP::Parser::SourceHandler::Executable'=> '3.30',
            'TAP::Parser::SourceHandler::File'=> '3.30',
            'TAP::Parser::SourceHandler::Handle'=> '3.30',
            'TAP::Parser::SourceHandler::Perl'=> '3.30',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.30',
            'TAP::Parser::YAMLish::Reader'=> '3.30',
            'TAP::Parser::YAMLish::Writer'=> '3.30',
            'Term::Cap'             => '1.15',
            'Test::Builder'         => '1.001002',
            'Test::Builder::Module' => '1.001002',
            'Test::Harness'         => '3.30',
            'Test::More'            => '1.001002',
            'Test::Simple'          => '1.001002',
            'Tie::StdHandle'        => '4.4',
            'Unicode::Collate'      => '1.02',
            'Unicode::Collate::CJK::Korean'=> '1.02',
            'Unicode::Collate::Locale'=> '1.02',
            'XS::APItest'           => '0.57',
            'XS::Typemap'           => '0.12',
            'arybase'               => '0.07',
            'bignum'                => '0.37',
            'constant'              => '1.29',
            'fields'                => '2.17',
            'inc::latest'           => '0.4202',
            'threads'               => '1.90',
            'threads::shared'       => '1.45',
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
            'CGI'                   => '3.64',
            'CGI::Apache'           => '1.02',
            'CGI::Carp'             => '3.64',
            'CGI::Cookie'           => '1.31',
            'CGI::Fast'             => '1.10',
            'CGI::Pretty'           => '3.64',
            'CGI::Push'             => '1.06',
            'CGI::Switch'           => '1.02',
            'CGI::Util'             => '3.64',
            'CPAN::Meta'            => '2.133380',
            'CPAN::Meta::Converter' => '2.133380',
            'CPAN::Meta::Feature'   => '2.133380',
            'CPAN::Meta::History'   => '2.133380',
            'CPAN::Meta::Prereqs'   => '2.133380',
            'CPAN::Meta::Spec'      => '2.133380',
            'CPAN::Meta::Validator' => '2.133380',
            'Config'                => '5.019007',
            'Data::Dumper'          => '2.150',
            'DynaLoader'            => '1.22',
            'ExtUtils::Command::MM' => '6.84',
            'ExtUtils::Liblist'     => '6.84',
            'ExtUtils::Liblist::Kid'=> '6.84',
            'ExtUtils::MM'          => '6.84',
            'ExtUtils::MM_AIX'      => '6.84',
            'ExtUtils::MM_Any'      => '6.84',
            'ExtUtils::MM_BeOS'     => '6.84',
            'ExtUtils::MM_Cygwin'   => '6.84',
            'ExtUtils::MM_DOS'      => '6.84',
            'ExtUtils::MM_Darwin'   => '6.84',
            'ExtUtils::MM_MacOS'    => '6.84',
            'ExtUtils::MM_NW5'      => '6.84',
            'ExtUtils::MM_OS2'      => '6.84',
            'ExtUtils::MM_QNX'      => '6.84',
            'ExtUtils::MM_UWIN'     => '6.84',
            'ExtUtils::MM_Unix'     => '6.84',
            'ExtUtils::MM_VMS'      => '6.84',
            'ExtUtils::MM_VOS'      => '6.84',
            'ExtUtils::MM_Win32'    => '6.84',
            'ExtUtils::MM_Win95'    => '6.84',
            'ExtUtils::MY'          => '6.84',
            'ExtUtils::MakeMaker'   => '6.84',
            'ExtUtils::MakeMaker::Config'=> '6.84',
            'ExtUtils::Mkbootstrap' => '6.84',
            'ExtUtils::Mksymlists'  => '6.84',
            'ExtUtils::testlib'     => '6.84',
            'File::Fetch'           => '0.46',
            'HTTP::Tiny'            => '0.039',
            'Locale::Codes'         => '3.28',
            'Locale::Codes::Constants'=> '3.28',
            'Locale::Codes::Country'=> '3.28',
            'Locale::Codes::Country_Codes'=> '3.28',
            'Locale::Codes::Country_Retired'=> '3.28',
            'Locale::Codes::Currency'=> '3.28',
            'Locale::Codes::Currency_Codes'=> '3.28',
            'Locale::Codes::Currency_Retired'=> '3.28',
            'Locale::Codes::LangExt'=> '3.28',
            'Locale::Codes::LangExt_Codes'=> '3.28',
            'Locale::Codes::LangExt_Retired'=> '3.28',
            'Locale::Codes::LangFam'=> '3.28',
            'Locale::Codes::LangFam_Codes'=> '3.28',
            'Locale::Codes::LangFam_Retired'=> '3.28',
            'Locale::Codes::LangVar'=> '3.28',
            'Locale::Codes::LangVar_Codes'=> '3.28',
            'Locale::Codes::LangVar_Retired'=> '3.28',
            'Locale::Codes::Language'=> '3.28',
            'Locale::Codes::Language_Codes'=> '3.28',
            'Locale::Codes::Language_Retired'=> '3.28',
            'Locale::Codes::Script' => '3.28',
            'Locale::Codes::Script_Codes'=> '3.28',
            'Locale::Codes::Script_Retired'=> '3.28',
            'Locale::Country'       => '3.28',
            'Locale::Currency'      => '3.28',
            'Locale::Language'      => '3.28',
            'Locale::Script'        => '3.28',
            'Module::Build'         => '0.4203',
            'Module::Build::Base'   => '0.4203',
            'Module::Build::Compat' => '0.4203',
            'Module::Build::Config' => '0.4203',
            'Module::Build::Cookbook'=> '0.4203',
            'Module::Build::Dumper' => '0.4203',
            'Module::Build::ModuleInfo'=> '0.4203',
            'Module::Build::Notes'  => '0.4203',
            'Module::Build::PPMMaker'=> '0.4203',
            'Module::Build::Platform::Default'=> '0.4203',
            'Module::Build::Platform::MacOS'=> '0.4203',
            'Module::Build::Platform::Unix'=> '0.4203',
            'Module::Build::Platform::VMS'=> '0.4203',
            'Module::Build::Platform::VOS'=> '0.4203',
            'Module::Build::Platform::Windows'=> '0.4203',
            'Module::Build::Platform::aix'=> '0.4203',
            'Module::Build::Platform::cygwin'=> '0.4203',
            'Module::Build::Platform::darwin'=> '0.4203',
            'Module::Build::Platform::os2'=> '0.4203',
            'Module::Build::PodParser'=> '0.4203',
            'Module::CoreList'      => '3.02',
            'Module::CoreList::TieHashDelta'=> '3.02',
            'Module::CoreList::Utils'=> '3.02',
            'POSIX'                 => '1.37',
            'PerlIO::encoding'      => '0.17',
            'PerlIO::via'           => '0.14',
            'SDBM_File'             => '1.11',
            'Storable'              => '2.48',
            'Time::Piece'           => '1.24',
            'Time::Seconds'         => '1.24',
            'Unicode::Collate'      => '1.04',
            'Win32'                 => '0.48',
            'XS::APItest'           => '0.58',
            'base'                  => '2.20',
            'constant'              => '1.30',
            'inc::latest'           => '0.4203',
            'threads'               => '1.91',
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
            'Config'                => '5.019008',
            'DynaLoader'            => '1.24',
            'Encode'                => '2.57',
            'Errno'                 => '1.20_02',
            'ExtUtils::CBuilder'    => '0.280213',
            'ExtUtils::CBuilder::Base'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280213',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280213',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280213',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280213',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280213',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280213',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280213',
            'ExtUtils::Command::MM' => '6.86',
            'ExtUtils::Liblist'     => '6.86',
            'ExtUtils::Liblist::Kid'=> '6.86',
            'ExtUtils::MM'          => '6.86',
            'ExtUtils::MM_AIX'      => '6.86',
            'ExtUtils::MM_Any'      => '6.86',
            'ExtUtils::MM_BeOS'     => '6.86',
            'ExtUtils::MM_Cygwin'   => '6.86',
            'ExtUtils::MM_DOS'      => '6.86',
            'ExtUtils::MM_Darwin'   => '6.86',
            'ExtUtils::MM_MacOS'    => '6.86',
            'ExtUtils::MM_NW5'      => '6.86',
            'ExtUtils::MM_OS2'      => '6.86',
            'ExtUtils::MM_QNX'      => '6.86',
            'ExtUtils::MM_UWIN'     => '6.86',
            'ExtUtils::MM_Unix'     => '6.86',
            'ExtUtils::MM_VMS'      => '6.86',
            'ExtUtils::MM_VOS'      => '6.86',
            'ExtUtils::MM_Win32'    => '6.86',
            'ExtUtils::MM_Win95'    => '6.86',
            'ExtUtils::MY'          => '6.86',
            'ExtUtils::MakeMaker'   => '6.86',
            'ExtUtils::MakeMaker::Config'=> '6.86',
            'ExtUtils::Mkbootstrap' => '6.86',
            'ExtUtils::Mksymlists'  => '6.86',
            'ExtUtils::testlib'     => '6.86',
            'File::Copy'            => '2.29',
            'Hash::Util::FieldHash' => '1.14',
            'IO::Socket::IP'        => '0.26',
            'IO::Socket::UNIX'      => '1.26',
            'List::Util'            => '1.36',
            'List::Util::XS'        => '1.36',
            'Module::Build'         => '0.4204',
            'Module::Build::Base'   => '0.4204',
            'Module::Build::Compat' => '0.4204',
            'Module::Build::Config' => '0.4204',
            'Module::Build::Cookbook'=> '0.4204',
            'Module::Build::Dumper' => '0.4204',
            'Module::Build::ModuleInfo'=> '0.4204',
            'Module::Build::Notes'  => '0.4204',
            'Module::Build::PPMMaker'=> '0.4204',
            'Module::Build::Platform::Default'=> '0.4204',
            'Module::Build::Platform::MacOS'=> '0.4204',
            'Module::Build::Platform::Unix'=> '0.4204',
            'Module::Build::Platform::VMS'=> '0.4204',
            'Module::Build::Platform::VOS'=> '0.4204',
            'Module::Build::Platform::Windows'=> '0.4204',
            'Module::Build::Platform::aix'=> '0.4204',
            'Module::Build::Platform::cygwin'=> '0.4204',
            'Module::Build::Platform::darwin'=> '0.4204',
            'Module::Build::Platform::os2'=> '0.4204',
            'Module::Build::PodParser'=> '0.4204',
            'Module::CoreList'      => '3.04',
            'Module::CoreList::TieHashDelta'=> '3.04',
            'Module::CoreList::Utils'=> '3.04',
            'Module::Load'          => '0.28',
            'Module::Load::Conditional'=> '0.60',
            'Net::Config'           => '1.13',
            'Net::FTP::A'           => '1.19',
            'POSIX'                 => '1.38_01',
            'Perl::OSType'          => '1.007',
            'PerlIO::encoding'      => '0.18',
            'Pod::Perldoc'          => '3.21',
            'Pod::Perldoc::BaseTo'  => '3.21',
            'Pod::Perldoc::GetOptsOO'=> '3.21',
            'Pod::Perldoc::ToANSI'  => '3.21',
            'Pod::Perldoc::ToChecker'=> '3.21',
            'Pod::Perldoc::ToMan'   => '3.21',
            'Pod::Perldoc::ToNroff' => '3.21',
            'Pod::Perldoc::ToPod'   => '3.21',
            'Pod::Perldoc::ToRtf'   => '3.21',
            'Pod::Perldoc::ToTerm'  => '3.21',
            'Pod::Perldoc::ToText'  => '3.21',
            'Pod::Perldoc::ToTk'    => '3.21',
            'Pod::Perldoc::ToXml'   => '3.21',
            'Scalar::Util'          => '1.36',
            'Time::Piece'           => '1.27',
            'Time::Seconds'         => '1.27',
            'Unicode::UCD'          => '0.57',
            'XS::APItest'           => '0.59',
            'XSLoader'              => '0.17',
            'base'                  => '2.21',
            'constant'              => '1.31',
            'inc::latest'           => '0.4204',
            'threads::shared'       => '1.46',
            'version'               => '0.9907',
            'version::regex'        => '0.9907',
            'version::vpp'          => '0.9907',
            'warnings'              => '1.21',
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
            'B'                     => '1.48',
            'B::Concise'            => '0.992',
            'B::Deparse'            => '1.25',
            'CGI'                   => '3.65',
            'CPAN::Meta::YAML'      => '0.011',
            'Compress::Raw::Bzip2'  => '2.064',
            'Compress::Raw::Zlib'   => '2.065',
            'Compress::Zlib'        => '2.064',
            'Config'                => '5.019009',
            'Config::Perl::V'       => '0.20',
            'Cwd'                   => '3.47',
            'Devel::Peek'           => '1.16',
            'Digest::SHA'           => '5.87',
            'DynaLoader'            => '1.25',
            'English'               => '1.09',
            'ExtUtils::CBuilder'    => '0.280216',
            'ExtUtils::CBuilder::Base'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280216',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280216',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280216',
            'ExtUtils::CBuilder::Platform::android'=> '0.280216',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280216',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280216',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280216',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280216',
            'ExtUtils::Command::MM' => '6.88',
            'ExtUtils::Embed'       => '1.32',
            'ExtUtils::Install'     => '1.62',
            'ExtUtils::Installed'   => '1.999004',
            'ExtUtils::Liblist'     => '6.88',
            'ExtUtils::Liblist::Kid'=> '6.88',
            'ExtUtils::MM'          => '6.88',
            'ExtUtils::MM_AIX'      => '6.88',
            'ExtUtils::MM_Any'      => '6.88',
            'ExtUtils::MM_BeOS'     => '6.88',
            'ExtUtils::MM_Cygwin'   => '6.88',
            'ExtUtils::MM_DOS'      => '6.88',
            'ExtUtils::MM_Darwin'   => '6.88',
            'ExtUtils::MM_MacOS'    => '6.88',
            'ExtUtils::MM_NW5'      => '6.88',
            'ExtUtils::MM_OS2'      => '6.88',
            'ExtUtils::MM_QNX'      => '6.88',
            'ExtUtils::MM_UWIN'     => '6.88',
            'ExtUtils::MM_Unix'     => '6.88',
            'ExtUtils::MM_VMS'      => '6.88',
            'ExtUtils::MM_VOS'      => '6.88',
            'ExtUtils::MM_Win32'    => '6.88',
            'ExtUtils::MM_Win95'    => '6.88',
            'ExtUtils::MY'          => '6.88',
            'ExtUtils::MakeMaker'   => '6.88',
            'ExtUtils::MakeMaker::Config'=> '6.88',
            'ExtUtils::Mkbootstrap' => '6.88',
            'ExtUtils::Mksymlists'  => '6.88',
            'ExtUtils::Packlist'    => '1.47',
            'ExtUtils::testlib'     => '6.88',
            'Fatal'                 => '2.23',
            'File::Fetch'           => '0.48',
            'File::Spec'            => '3.47',
            'File::Spec::Cygwin'    => '3.47',
            'File::Spec::Epoc'      => '3.47',
            'File::Spec::Functions' => '3.47',
            'File::Spec::Mac'       => '3.47',
            'File::Spec::OS2'       => '3.47',
            'File::Spec::Unix'      => '3.47',
            'File::Spec::VMS'       => '3.47',
            'File::Spec::Win32'     => '3.47',
            'HTTP::Tiny'            => '0.042',
            'IO::Compress::Adapter::Bzip2'=> '2.064',
            'IO::Compress::Adapter::Deflate'=> '2.064',
            'IO::Compress::Adapter::Identity'=> '2.064',
            'IO::Compress::Base'    => '2.064',
            'IO::Compress::Base::Common'=> '2.064',
            'IO::Compress::Bzip2'   => '2.064',
            'IO::Compress::Deflate' => '2.064',
            'IO::Compress::Gzip'    => '2.064',
            'IO::Compress::Gzip::Constants'=> '2.064',
            'IO::Compress::RawDeflate'=> '2.064',
            'IO::Compress::Zip'     => '2.064',
            'IO::Compress::Zip::Constants'=> '2.064',
            'IO::Compress::Zlib::Constants'=> '2.064',
            'IO::Compress::Zlib::Extra'=> '2.064',
            'IO::Socket::INET'      => '1.35',
            'IO::Socket::IP'        => '0.28',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.064',
            'IO::Uncompress::Adapter::Identity'=> '2.064',
            'IO::Uncompress::Adapter::Inflate'=> '2.064',
            'IO::Uncompress::AnyInflate'=> '2.064',
            'IO::Uncompress::AnyUncompress'=> '2.064',
            'IO::Uncompress::Base'  => '2.064',
            'IO::Uncompress::Bunzip2'=> '2.064',
            'IO::Uncompress::Gunzip'=> '2.064',
            'IO::Uncompress::Inflate'=> '2.064',
            'IO::Uncompress::RawInflate'=> '2.064',
            'IO::Uncompress::Unzip' => '2.064',
            'IPC::Cmd'              => '0.92',
            'List::Util'            => '1.38',
            'List::Util::XS'        => '1.38',
            'Locale::Codes'         => '3.29',
            'Locale::Codes::Constants'=> '3.29',
            'Locale::Codes::Country'=> '3.29',
            'Locale::Codes::Country_Codes'=> '3.29',
            'Locale::Codes::Country_Retired'=> '3.29',
            'Locale::Codes::Currency'=> '3.29',
            'Locale::Codes::Currency_Codes'=> '3.29',
            'Locale::Codes::Currency_Retired'=> '3.29',
            'Locale::Codes::LangExt'=> '3.29',
            'Locale::Codes::LangExt_Codes'=> '3.29',
            'Locale::Codes::LangExt_Retired'=> '3.29',
            'Locale::Codes::LangFam'=> '3.29',
            'Locale::Codes::LangFam_Codes'=> '3.29',
            'Locale::Codes::LangFam_Retired'=> '3.29',
            'Locale::Codes::LangVar'=> '3.29',
            'Locale::Codes::LangVar_Codes'=> '3.29',
            'Locale::Codes::LangVar_Retired'=> '3.29',
            'Locale::Codes::Language'=> '3.29',
            'Locale::Codes::Language_Codes'=> '3.29',
            'Locale::Codes::Language_Retired'=> '3.29',
            'Locale::Codes::Script' => '3.29',
            'Locale::Codes::Script_Codes'=> '3.29',
            'Locale::Codes::Script_Retired'=> '3.29',
            'Locale::Country'       => '3.29',
            'Locale::Currency'      => '3.29',
            'Locale::Language'      => '3.29',
            'Locale::Script'        => '3.29',
            'Module::Build'         => '0.4205',
            'Module::Build::Base'   => '0.4205',
            'Module::Build::Compat' => '0.4205',
            'Module::Build::Config' => '0.4205',
            'Module::Build::Cookbook'=> '0.4205',
            'Module::Build::Dumper' => '0.4205',
            'Module::Build::ModuleInfo'=> '0.4205',
            'Module::Build::Notes'  => '0.4205',
            'Module::Build::PPMMaker'=> '0.4205',
            'Module::Build::Platform::Default'=> '0.4205',
            'Module::Build::Platform::MacOS'=> '0.4205',
            'Module::Build::Platform::Unix'=> '0.4205',
            'Module::Build::Platform::VMS'=> '0.4205',
            'Module::Build::Platform::VOS'=> '0.4205',
            'Module::Build::Platform::Windows'=> '0.4205',
            'Module::Build::Platform::aix'=> '0.4205',
            'Module::Build::Platform::cygwin'=> '0.4205',
            'Module::Build::Platform::darwin'=> '0.4205',
            'Module::Build::Platform::os2'=> '0.4205',
            'Module::Build::PodParser'=> '0.4205',
            'Module::CoreList'      => '3.06',
            'Module::CoreList::TieHashDelta'=> '3.06',
            'Module::CoreList::Utils'=> '3.06',
            'Module::Load'          => '0.30',
            'Module::Load::Conditional'=> '0.62',
            'Net::Domain'           => '2.23',
            'Net::FTP'              => '2.79',
            'Net::NNTP'             => '2.26',
            'Net::POP3'             => '2.31',
            'Net::Ping'             => '2.43',
            'Net::SMTP'             => '2.33',
            'POSIX'                 => '1.38_02',
            'Parse::CPAN::Meta'     => '1.4413',
            'Pod::Escapes'          => '1.06',
            'Pod::Find'             => '1.62',
            'Pod::InputObjects'     => '1.62',
            'Pod::ParseUtils'       => '1.62',
            'Pod::Parser'           => '1.62',
            'Pod::Select'           => '1.62',
            'Scalar::Util'          => '1.38',
            'autodie'               => '2.23',
            'autodie::exception'    => '2.23',
            'autodie::exception::system'=> '2.23',
            'autodie::hints'        => '2.23',
            'autodie::skip'         => '2.23',
            'diagnostics'           => '1.34',
            'feature'               => '1.35',
            'inc::latest'           => '0.4205',
            'locale'                => '1.03',
            'mro'                   => '1.15',
            'threads'               => '1.92',
            'version'               => '0.9908',
            'version::regex'        => '0.9908',
            'version::vpp'          => '0.9908',
            'warnings'              => '1.22',
        },
        removed => {
        }
    },
    5.01901 => {
        delta_from => 5.019009,
        changed => {
            'App::Cpan'             => '1.62',
            'Attribute::Handlers'   => '0.96',
            'B::Deparse'            => '1.26',
            'CPAN'                  => '2.04',
            'CPAN::Bundle'          => '5.5001',
            'CPAN::Complete'        => '5.5001',
            'CPAN::Distribution'    => '2.01',
            'CPAN::Distroprefs'     => '6.0001',
            'CPAN::FirstTime'       => '5.5305',
            'CPAN::Meta'            => '2.140640',
            'CPAN::Meta::Converter' => '2.140640',
            'CPAN::Meta::Feature'   => '2.140640',
            'CPAN::Meta::History'   => '2.140640',
            'CPAN::Meta::Prereqs'   => '2.140640',
            'CPAN::Meta::Spec'      => '2.140640',
            'CPAN::Meta::Validator' => '2.140640',
            'CPAN::Meta::YAML'      => '0.012',
            'CPAN::Queue'           => '5.5002',
            'CPAN::Shell'           => '5.5003',
            'CPAN::Tarzip'          => '5.5012',
            'CPAN::Version'         => '5.5003',
            'Carp'                  => '1.33',
            'Carp::Heavy'           => '1.33',
            'Config'                => '5.019010',
            'Data::Dumper'          => '2.151',
            'Devel::PPPort'         => '3.22',
            'Digest::SHA'           => '5.88',
            'ExtUtils::Command::MM' => '6.92',
            'ExtUtils::Install'     => '1.63',
            'ExtUtils::Installed'   => '1.999005',
            'ExtUtils::Liblist'     => '6.92',
            'ExtUtils::Liblist::Kid'=> '6.92',
            'ExtUtils::MM'          => '6.92',
            'ExtUtils::MM_AIX'      => '6.92',
            'ExtUtils::MM_Any'      => '6.92',
            'ExtUtils::MM_BeOS'     => '6.92',
            'ExtUtils::MM_Cygwin'   => '6.92',
            'ExtUtils::MM_DOS'      => '6.92',
            'ExtUtils::MM_Darwin'   => '6.92',
            'ExtUtils::MM_MacOS'    => '6.92',
            'ExtUtils::MM_NW5'      => '6.92',
            'ExtUtils::MM_OS2'      => '6.92',
            'ExtUtils::MM_QNX'      => '6.92',
            'ExtUtils::MM_UWIN'     => '6.92',
            'ExtUtils::MM_Unix'     => '6.92',
            'ExtUtils::MM_VMS'      => '6.92',
            'ExtUtils::MM_VOS'      => '6.92',
            'ExtUtils::MM_Win32'    => '6.92',
            'ExtUtils::MM_Win95'    => '6.92',
            'ExtUtils::MY'          => '6.92',
            'ExtUtils::MakeMaker'   => '6.92',
            'ExtUtils::MakeMaker::Config'=> '6.92',
            'ExtUtils::Mkbootstrap' => '6.92',
            'ExtUtils::Mksymlists'  => '6.92',
            'ExtUtils::Packlist'    => '1.48',
            'ExtUtils::ParseXS'     => '3.24',
            'ExtUtils::ParseXS::Constants'=> '3.24',
            'ExtUtils::ParseXS::CountLines'=> '3.24',
            'ExtUtils::ParseXS::Eval'=> '3.24',
            'ExtUtils::ParseXS::Utilities'=> '3.24',
            'ExtUtils::Typemaps'    => '3.24',
            'ExtUtils::Typemaps::Cmd'=> '3.24',
            'ExtUtils::Typemaps::InputMap'=> '3.24',
            'ExtUtils::Typemaps::OutputMap'=> '3.24',
            'ExtUtils::Typemaps::Type'=> '3.24',
            'ExtUtils::testlib'     => '6.92',
            'File::Find'            => '1.27',
            'Filter::Simple'        => '0.91',
            'HTTP::Tiny'            => '0.043',
            'Hash::Util::FieldHash' => '1.15',
            'IO'                    => '1.31',
            'IO::Socket::IP'        => '0.29',
            'Locale::Codes'         => '3.30',
            'Locale::Codes::Constants'=> '3.30',
            'Locale::Codes::Country'=> '3.30',
            'Locale::Codes::Country_Codes'=> '3.30',
            'Locale::Codes::Country_Retired'=> '3.30',
            'Locale::Codes::Currency'=> '3.30',
            'Locale::Codes::Currency_Codes'=> '3.30',
            'Locale::Codes::Currency_Retired'=> '3.30',
            'Locale::Codes::LangExt'=> '3.30',
            'Locale::Codes::LangExt_Codes'=> '3.30',
            'Locale::Codes::LangExt_Retired'=> '3.30',
            'Locale::Codes::LangFam'=> '3.30',
            'Locale::Codes::LangFam_Codes'=> '3.30',
            'Locale::Codes::LangFam_Retired'=> '3.30',
            'Locale::Codes::LangVar'=> '3.30',
            'Locale::Codes::LangVar_Codes'=> '3.30',
            'Locale::Codes::LangVar_Retired'=> '3.30',
            'Locale::Codes::Language'=> '3.30',
            'Locale::Codes::Language_Codes'=> '3.30',
            'Locale::Codes::Language_Retired'=> '3.30',
            'Locale::Codes::Script' => '3.30',
            'Locale::Codes::Script_Codes'=> '3.30',
            'Locale::Codes::Script_Retired'=> '3.30',
            'Locale::Country'       => '3.30',
            'Locale::Currency'      => '3.30',
            'Locale::Language'      => '3.30',
            'Locale::Script'        => '3.30',
            'Module::CoreList'      => '3.09',
            'Module::CoreList::TieHashDelta'=> '3.09',
            'Module::CoreList::Utils'=> '3.09',
            'Module::Load'          => '0.32',
            'POSIX'                 => '1.38_03',
            'Parse::CPAN::Meta'     => '1.4414',
            'Pod::Perldoc'          => '3.23',
            'Pod::Perldoc::BaseTo'  => '3.23',
            'Pod::Perldoc::GetOptsOO'=> '3.23',
            'Pod::Perldoc::ToANSI'  => '3.23',
            'Pod::Perldoc::ToChecker'=> '3.23',
            'Pod::Perldoc::ToMan'   => '3.23',
            'Pod::Perldoc::ToNroff' => '3.23',
            'Pod::Perldoc::ToPod'   => '3.23',
            'Pod::Perldoc::ToRtf'   => '3.23',
            'Pod::Perldoc::ToTerm'  => '3.23',
            'Pod::Perldoc::ToText'  => '3.23',
            'Pod::Perldoc::ToTk'    => '3.23',
            'Pod::Perldoc::ToXml'   => '3.23',
            'Thread::Queue'         => '3.05',
            'XS::APItest'           => '0.60',
            'XS::Typemap'           => '0.13',
            'autouse'               => '1.08',
            'base'                  => '2.22',
            'charnames'             => '1.40',
            'feature'               => '1.36',
            'mro'                   => '1.16',
            'threads'               => '1.93',
            'warnings'              => '1.23',
            'warnings::register'    => '1.03',
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.01901,
        changed => {
            'CPAN'                  => '2.05',
            'CPAN::Distribution'    => '2.02',
            'CPAN::FirstTime'       => '5.5306',
            'CPAN::Shell'           => '5.5004',
            'Carp'                  => '1.3301',
            'Carp::Heavy'           => '1.3301',
            'Config'                => '5.019011',
            'ExtUtils::Command::MM' => '6.94',
            'ExtUtils::Install'     => '1.67',
            'ExtUtils::Liblist'     => '6.94',
            'ExtUtils::Liblist::Kid'=> '6.94',
            'ExtUtils::MM'          => '6.94',
            'ExtUtils::MM_AIX'      => '6.94',
            'ExtUtils::MM_Any'      => '6.94',
            'ExtUtils::MM_BeOS'     => '6.94',
            'ExtUtils::MM_Cygwin'   => '6.94',
            'ExtUtils::MM_DOS'      => '6.94',
            'ExtUtils::MM_Darwin'   => '6.94',
            'ExtUtils::MM_MacOS'    => '6.94',
            'ExtUtils::MM_NW5'      => '6.94',
            'ExtUtils::MM_OS2'      => '6.94',
            'ExtUtils::MM_QNX'      => '6.94',
            'ExtUtils::MM_UWIN'     => '6.94',
            'ExtUtils::MM_Unix'     => '6.94',
            'ExtUtils::MM_VMS'      => '6.94',
            'ExtUtils::MM_VOS'      => '6.94',
            'ExtUtils::MM_Win32'    => '6.94',
            'ExtUtils::MM_Win95'    => '6.94',
            'ExtUtils::MY'          => '6.94',
            'ExtUtils::MakeMaker'   => '6.94',
            'ExtUtils::MakeMaker::Config'=> '6.94',
            'ExtUtils::Mkbootstrap' => '6.94',
            'ExtUtils::Mksymlists'  => '6.94',
            'ExtUtils::testlib'     => '6.94',
            'Module::CoreList'      => '3.10',
            'Module::CoreList::TieHashDelta'=> '3.10',
            'Module::CoreList::Utils'=> '3.10',
            'PerlIO'                => '1.09',
            'Storable'              => '2.49',
            'Win32'                 => '0.49',
            'experimental'          => '0.007',
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
            'Config'                => '5.02',
            'Devel::PPPort'         => '3.21',
            'Encode'                => '2.60',
            'Errno'                 => '1.20_03',
            'ExtUtils::Command::MM' => '6.98',
            'ExtUtils::Liblist'     => '6.98',
            'ExtUtils::Liblist::Kid'=> '6.98',
            'ExtUtils::MM'          => '6.98',
            'ExtUtils::MM_AIX'      => '6.98',
            'ExtUtils::MM_Any'      => '6.98',
            'ExtUtils::MM_BeOS'     => '6.98',
            'ExtUtils::MM_Cygwin'   => '6.98',
            'ExtUtils::MM_DOS'      => '6.98',
            'ExtUtils::MM_Darwin'   => '6.98',
            'ExtUtils::MM_MacOS'    => '6.98',
            'ExtUtils::MM_NW5'      => '6.98',
            'ExtUtils::MM_OS2'      => '6.98',
            'ExtUtils::MM_QNX'      => '6.98',
            'ExtUtils::MM_UWIN'     => '6.98',
            'ExtUtils::MM_Unix'     => '6.98',
            'ExtUtils::MM_VMS'      => '6.98',
            'ExtUtils::MM_VOS'      => '6.98',
            'ExtUtils::MM_Win32'    => '6.98',
            'ExtUtils::MM_Win95'    => '6.98',
            'ExtUtils::MY'          => '6.98',
            'ExtUtils::MakeMaker'   => '6.98',
            'ExtUtils::MakeMaker::Config'=> '6.98',
            'ExtUtils::Miniperl'    => '1.01',
            'ExtUtils::Mkbootstrap' => '6.98',
            'ExtUtils::Mksymlists'  => '6.98',
            'ExtUtils::testlib'     => '6.98',
            'Pod::Functions::Functions'=> '1.08',
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
            'Module::CoreList'      => '5.021001',
            'Module::CoreList::TieHashDelta'=> '5.021001',
            'Module::CoreList::Utils'=> '5.021001',
            'feature'               => '1.37',
        },
        removed => {
            'CGI'                   => 1,
            'CGI::Apache'           => 1,
            'CGI::Carp'             => 1,
            'CGI::Cookie'           => 1,
            'CGI::Fast'             => 1,
            'CGI::Pretty'           => 1,
            'CGI::Push'             => 1,
            'CGI::Switch'           => 1,
            'CGI::Util'             => 1,
            'Module::Build'         => 1,
            'Module::Build::Base'   => 1,
            'Module::Build::Compat' => 1,
            'Module::Build::Config' => 1,
            'Module::Build::ConfigData'=> 1,
            'Module::Build::Cookbook'=> 1,
            'Module::Build::Dumper' => 1,
            'Module::Build::ModuleInfo'=> 1,
            'Module::Build::Notes'  => 1,
            'Module::Build::PPMMaker'=> 1,
            'Module::Build::Platform::Default'=> 1,
            'Module::Build::Platform::MacOS'=> 1,
            'Module::Build::Platform::Unix'=> 1,
            'Module::Build::Platform::VMS'=> 1,
            'Module::Build::Platform::VOS'=> 1,
            'Module::Build::Platform::Windows'=> 1,
            'Module::Build::Platform::aix'=> 1,
            'Module::Build::Platform::cygwin'=> 1,
            'Module::Build::Platform::darwin'=> 1,
            'Module::Build::Platform::os2'=> 1,
            'Module::Build::PodParser'=> 1,
            'Module::Build::Version'=> 1,
            'Module::Build::YAML'   => 1,
            'Package::Constants'    => 1,
            'Simple'                => 1,
            'inc::latest'           => 1,
        }
    },
    5.021001 => {
        delta_from => 5.021000,
        changed => {
            'App::Prove'            => '3.32',
            'App::Prove::State'     => '3.32',
            'App::Prove::State::Result'=> '3.32',
            'App::Prove::State::Result::Test'=> '3.32',
            'Archive::Tar'          => '2.00',
            'Archive::Tar::Constant'=> '2.00',
            'Archive::Tar::File'    => '2.00',
            'B'                     => '1.49',
            'B::Deparse'            => '1.27',
            'Benchmark'             => '1.19',
            'CPAN::Meta'            => '2.141520',
            'CPAN::Meta::Converter' => '2.141520',
            'CPAN::Meta::Feature'   => '2.141520',
            'CPAN::Meta::History'   => '2.141520',
            'CPAN::Meta::Prereqs'   => '2.141520',
            'CPAN::Meta::Spec'      => '2.141520',
            'CPAN::Meta::Validator' => '2.141520',
            'Carp'                  => '1.34',
            'Carp::Heavy'           => '1.34',
            'Config'                => '5.021001',
            'Cwd'                   => '3.48',
            'Data::Dumper'          => '2.152',
            'Devel::PPPort'         => '3.24',
            'Devel::Peek'           => '1.17',
            'Digest::SHA'           => '5.92',
            'DynaLoader'            => '1.26',
            'Encode'                => '2.62',
            'Errno'                 => '1.20_04',
            'Exporter'              => '5.71',
            'Exporter::Heavy'       => '5.71',
            'ExtUtils::Install'     => '1.68',
            'ExtUtils::Miniperl'    => '1.02',
            'ExtUtils::ParseXS'     => '3.25',
            'ExtUtils::ParseXS::Constants'=> '3.25',
            'ExtUtils::ParseXS::CountLines'=> '3.25',
            'ExtUtils::ParseXS::Eval'=> '3.25',
            'ExtUtils::ParseXS::Utilities'=> '3.25',
            'ExtUtils::Typemaps'    => '3.25',
            'ExtUtils::Typemaps::Cmd'=> '3.25',
            'ExtUtils::Typemaps::InputMap'=> '3.25',
            'ExtUtils::Typemaps::OutputMap'=> '3.25',
            'ExtUtils::Typemaps::Type'=> '3.25',
            'Fatal'                 => '2.25',
            'File::Spec'            => '3.48',
            'File::Spec::Cygwin'    => '3.48',
            'File::Spec::Epoc'      => '3.48',
            'File::Spec::Functions' => '3.48',
            'File::Spec::Mac'       => '3.48',
            'File::Spec::OS2'       => '3.48',
            'File::Spec::Unix'      => '3.48',
            'File::Spec::VMS'       => '3.48',
            'File::Spec::Win32'     => '3.48',
            'Hash::Util'            => '0.17',
            'IO'                    => '1.32',
            'List::Util'            => '1.39',
            'List::Util::XS'        => '1.39',
            'Locale::Codes'         => '3.31',
            'Locale::Codes::Constants'=> '3.31',
            'Locale::Codes::Country'=> '3.31',
            'Locale::Codes::Country_Codes'=> '3.31',
            'Locale::Codes::Country_Retired'=> '3.31',
            'Locale::Codes::Currency'=> '3.31',
            'Locale::Codes::Currency_Codes'=> '3.31',
            'Locale::Codes::Currency_Retired'=> '3.31',
            'Locale::Codes::LangExt'=> '3.31',
            'Locale::Codes::LangExt_Codes'=> '3.31',
            'Locale::Codes::LangExt_Retired'=> '3.31',
            'Locale::Codes::LangFam'=> '3.31',
            'Locale::Codes::LangFam_Codes'=> '3.31',
            'Locale::Codes::LangFam_Retired'=> '3.31',
            'Locale::Codes::LangVar'=> '3.31',
            'Locale::Codes::LangVar_Codes'=> '3.31',
            'Locale::Codes::LangVar_Retired'=> '3.31',
            'Locale::Codes::Language'=> '3.31',
            'Locale::Codes::Language_Codes'=> '3.31',
            'Locale::Codes::Language_Retired'=> '3.31',
            'Locale::Codes::Script' => '3.31',
            'Locale::Codes::Script_Codes'=> '3.31',
            'Locale::Codes::Script_Retired'=> '3.31',
            'Locale::Country'       => '3.31',
            'Locale::Currency'      => '3.31',
            'Locale::Language'      => '3.31',
            'Locale::Script'        => '3.31',
            'Math::BigFloat'        => '1.9994',
            'Math::BigInt'          => '1.9995',
            'Math::BigInt::Calc'    => '1.9994',
            'Math::BigInt::CalcEmu' => '1.9994',
            'Math::BigRat'          => '0.2608',
            'Module::CoreList'      => '5.021001_01',
            'Module::CoreList::TieHashDelta'=> '5.021001_01',
            'Module::CoreList::Utils'=> '5.021001_01',
            'Module::Metadata'      => '1.000024',
            'Module::Metadata::corpus::BOMTest::UTF16BE'=> undef,
            'Module::Metadata::corpus::BOMTest::UTF16LE'=> undef,
            'Module::Metadata::corpus::BOMTest::UTF8'=> '1',
            'NDBM_File'             => '1.13',
            'Net::Config'           => '1.14',
            'Net::SMTP'             => '2.34',
            'Net::Time'             => '2.11',
            'OS2::Process'          => '1.10',
            'POSIX'                 => '1.40',
            'PerlIO::encoding'      => '0.19',
            'PerlIO::mmap'          => '0.013',
            'PerlIO::scalar'        => '0.19',
            'PerlIO::via'           => '0.15',
            'Pod::Html'             => '1.22',
            'Scalar::Util'          => '1.39',
            'SelfLoader'            => '1.22',
            'Socket'                => '2.014',
            'Storable'              => '2.51',
            'TAP::Base'             => '3.32',
            'TAP::Formatter::Base'  => '3.32',
            'TAP::Formatter::Color' => '3.32',
            'TAP::Formatter::Console'=> '3.32',
            'TAP::Formatter::Console::ParallelSession'=> '3.32',
            'TAP::Formatter::Console::Session'=> '3.32',
            'TAP::Formatter::File'  => '3.32',
            'TAP::Formatter::File::Session'=> '3.32',
            'TAP::Formatter::Session'=> '3.32',
            'TAP::Harness'          => '3.32',
            'TAP::Harness::Env'     => '3.32',
            'TAP::Object'           => '3.32',
            'TAP::Parser'           => '3.32',
            'TAP::Parser::Aggregator'=> '3.32',
            'TAP::Parser::Grammar'  => '3.32',
            'TAP::Parser::Iterator' => '3.32',
            'TAP::Parser::Iterator::Array'=> '3.32',
            'TAP::Parser::Iterator::Process'=> '3.32',
            'TAP::Parser::Iterator::Stream'=> '3.32',
            'TAP::Parser::IteratorFactory'=> '3.32',
            'TAP::Parser::Multiplexer'=> '3.32',
            'TAP::Parser::Result'   => '3.32',
            'TAP::Parser::Result::Bailout'=> '3.32',
            'TAP::Parser::Result::Comment'=> '3.32',
            'TAP::Parser::Result::Plan'=> '3.32',
            'TAP::Parser::Result::Pragma'=> '3.32',
            'TAP::Parser::Result::Test'=> '3.32',
            'TAP::Parser::Result::Unknown'=> '3.32',
            'TAP::Parser::Result::Version'=> '3.32',
            'TAP::Parser::Result::YAML'=> '3.32',
            'TAP::Parser::ResultFactory'=> '3.32',
            'TAP::Parser::Scheduler'=> '3.32',
            'TAP::Parser::Scheduler::Job'=> '3.32',
            'TAP::Parser::Scheduler::Spinner'=> '3.32',
            'TAP::Parser::Source'   => '3.32',
            'TAP::Parser::SourceHandler'=> '3.32',
            'TAP::Parser::SourceHandler::Executable'=> '3.32',
            'TAP::Parser::SourceHandler::File'=> '3.32',
            'TAP::Parser::SourceHandler::Handle'=> '3.32',
            'TAP::Parser::SourceHandler::Perl'=> '3.32',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.32',
            'TAP::Parser::YAMLish::Reader'=> '3.32',
            'TAP::Parser::YAMLish::Writer'=> '3.32',
            'Term::ANSIColor'       => '4.03',
            'Test::Builder'         => '1.001003',
            'Test::Builder::Module' => '1.001003',
            'Test::Builder::Tester' => '1.23_003',
            'Test::Harness'         => '3.32',
            'Test::More'            => '1.001003',
            'Test::Simple'          => '1.001003',
            'Tie::File'             => '1.01',
            'Unicode'               => '7.0.0',
            'Unicode::Collate'      => '1.07',
            'Unicode::Normalize'    => '1.18',
            'Unicode::UCD'          => '0.58',
            'XS::APItest'           => '0.61',
            '_charnames'            => '1.41',
            'autodie'               => '2.25',
            'autodie::Scope::Guard' => '2.25',
            'autodie::Scope::GuardStack'=> '2.25',
            'autodie::ScopeUtil'    => '2.25',
            'autodie::exception'    => '2.25',
            'autodie::exception::system'=> '2.25',
            'autodie::hints'        => '2.25',
            'autodie::skip'         => '2.25',
            'charnames'             => '1.41',
            'locale'                => '1.04',
            'threads'               => '1.94',
            'utf8'                  => '1.14',
            'warnings'              => '1.24',
        },
        removed => {
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
            'B'                     => '1.50',
            'Config'                => '5.021002',
            'Cwd'                   => '3.49',
            'Devel::Peek'           => '1.18',
            'ExtUtils::Manifest'    => '1.64',
            'File::Copy'            => '2.30',
            'File::Spec'            => '3.49',
            'File::Spec::Cygwin'    => '3.49',
            'File::Spec::Epoc'      => '3.49',
            'File::Spec::Functions' => '3.49',
            'File::Spec::Mac'       => '3.49',
            'File::Spec::OS2'       => '3.49',
            'File::Spec::Unix'      => '3.49',
            'File::Spec::VMS'       => '3.49',
            'File::Spec::Win32'     => '3.49',
            'Filter::Simple'        => '0.92',
            'Hash::Util'            => '0.18',
            'IO'                    => '1.33',
            'IO::Socket::IP'        => '0.31',
            'IPC::Open3'            => '1.17',
            'Math::BigFloat'        => '1.9996',
            'Math::BigInt'          => '1.9996',
            'Math::BigInt::Calc'    => '1.9996',
            'Math::BigInt::CalcEmu' => '1.9996',
            'Module::CoreList'      => '5.021002',
            'Module::CoreList::TieHashDelta'=> '5.021002',
            'Module::CoreList::Utils'=> '5.021002',
            'POSIX'                 => '1.41',
            'Pod::Usage'            => '1.64',
            'XS::APItest'           => '0.62',
            'arybase'               => '0.08',
            'experimental'          => '0.008',
            'threads'               => '1.95',
            'warnings'              => '1.26',
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
            'B::Debug'              => '1.21',
            'CPAN::Meta'            => '2.142060',
            'CPAN::Meta::Converter' => '2.142060',
            'CPAN::Meta::Feature'   => '2.142060',
            'CPAN::Meta::History'   => '2.142060',
            'CPAN::Meta::Merge'     => '2.142060',
            'CPAN::Meta::Prereqs'   => '2.142060',
            'CPAN::Meta::Requirements'=> '2.126',
            'CPAN::Meta::Spec'      => '2.142060',
            'CPAN::Meta::Validator' => '2.142060',
            'Config'                => '5.021003',
            'Config::Perl::V'       => '0.22',
            'ExtUtils::CBuilder'    => '0.280217',
            'ExtUtils::CBuilder::Base'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::android'=> '0.280217',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280217',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280217',
            'ExtUtils::Manifest'    => '1.65',
            'HTTP::Tiny'            => '0.047',
            'IPC::Open3'            => '1.18',
            'Module::CoreList'      => '5.021003',
            'Module::CoreList::TieHashDelta'=> '5.021003',
            'Module::CoreList::Utils'=> '5.021003',
            'Opcode'                => '1.28',
            'POSIX'                 => '1.42',
            'Safe'                  => '2.38',
            'Socket'                => '2.015',
            'Sys::Hostname'         => '1.19',
            'UNIVERSAL'             => '1.12',
            'XS::APItest'           => '0.63',
            'perlfaq'               => '5.0150045',
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.020000,
        changed => {
            'Config'                => '5.020001',
            'Config::Perl::V'       => '0.22',
            'Cwd'                   => '3.48',
            'Exporter'              => '5.71',
            'Exporter::Heavy'       => '5.71',
            'ExtUtils::CBuilder'    => '0.280217',
            'ExtUtils::CBuilder::Base'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280217',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280217',
            'ExtUtils::CBuilder::Platform::android'=> '0.280217',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280217',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280217',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280217',
            'File::Copy'            => '2.30',
            'File::Spec'            => '3.48',
            'File::Spec::Cygwin'    => '3.48',
            'File::Spec::Epoc'      => '3.48',
            'File::Spec::Functions' => '3.48',
            'File::Spec::Mac'       => '3.48',
            'File::Spec::OS2'       => '3.48',
            'File::Spec::Unix'      => '3.48',
            'File::Spec::VMS'       => '3.48',
            'File::Spec::Win32'     => '3.48',
            'Module::CoreList'      => '5.020001',
            'Module::CoreList::TieHashDelta'=> '5.020001',
            'Module::CoreList::Utils'=> '5.020001',
            'PerlIO::via'           => '0.15',
            'Unicode::UCD'          => '0.58',
            'XS::APItest'           => '0.60_01',
            'utf8'                  => '1.13_01',
            'version'               => '0.9909',
            'version::regex'        => '0.9909',
            'version::vpp'          => '0.9909',
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
            'App::Prove'            => '3.33',
            'App::Prove::State'     => '3.33',
            'App::Prove::State::Result'=> '3.33',
            'App::Prove::State::Result::Test'=> '3.33',
            'Archive::Tar'          => '2.02',
            'Archive::Tar::Constant'=> '2.02',
            'Archive::Tar::File'    => '2.02',
            'Attribute::Handlers'   => '0.97',
            'B'                     => '1.51',
            'B::Concise'            => '0.993',
            'B::Deparse'            => '1.28',
            'B::Op_private'         => '5.021004',
            'CPAN::Meta::Requirements'=> '2.128',
            'Config'                => '5.021004',
            'Cwd'                   => '3.50',
            'Data::Dumper'          => '2.154',
            'ExtUtils::CBuilder'    => '0.280219',
            'ExtUtils::CBuilder::Base'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280219',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280219',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280219',
            'ExtUtils::CBuilder::Platform::android'=> '0.280219',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280219',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280219',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280219',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280219',
            'ExtUtils::Install'     => '2.04',
            'ExtUtils::Installed'   => '2.04',
            'ExtUtils::Liblist::Kid'=> '6.98_01',
            'ExtUtils::Manifest'    => '1.68',
            'ExtUtils::Packlist'    => '2.04',
            'File::Find'            => '1.28',
            'File::Spec'            => '3.50',
            'File::Spec::Cygwin'    => '3.50',
            'File::Spec::Epoc'      => '3.50',
            'File::Spec::Functions' => '3.50',
            'File::Spec::Mac'       => '3.50',
            'File::Spec::OS2'       => '3.50',
            'File::Spec::Unix'      => '3.50',
            'File::Spec::VMS'       => '3.50',
            'File::Spec::Win32'     => '3.50',
            'Getopt::Std'           => '1.11',
            'HTTP::Tiny'            => '0.049',
            'IO'                    => '1.34',
            'IO::Socket::IP'        => '0.32',
            'List::Util'            => '1.41',
            'List::Util::XS'        => '1.41',
            'Locale::Codes'         => '3.32',
            'Locale::Codes::Constants'=> '3.32',
            'Locale::Codes::Country'=> '3.32',
            'Locale::Codes::Country_Codes'=> '3.32',
            'Locale::Codes::Country_Retired'=> '3.32',
            'Locale::Codes::Currency'=> '3.32',
            'Locale::Codes::Currency_Codes'=> '3.32',
            'Locale::Codes::Currency_Retired'=> '3.32',
            'Locale::Codes::LangExt'=> '3.32',
            'Locale::Codes::LangExt_Codes'=> '3.32',
            'Locale::Codes::LangExt_Retired'=> '3.32',
            'Locale::Codes::LangFam'=> '3.32',
            'Locale::Codes::LangFam_Codes'=> '3.32',
            'Locale::Codes::LangFam_Retired'=> '3.32',
            'Locale::Codes::LangVar'=> '3.32',
            'Locale::Codes::LangVar_Codes'=> '3.32',
            'Locale::Codes::LangVar_Retired'=> '3.32',
            'Locale::Codes::Language'=> '3.32',
            'Locale::Codes::Language_Codes'=> '3.32',
            'Locale::Codes::Language_Retired'=> '3.32',
            'Locale::Codes::Script' => '3.32',
            'Locale::Codes::Script_Codes'=> '3.32',
            'Locale::Codes::Script_Retired'=> '3.32',
            'Locale::Country'       => '3.32',
            'Locale::Currency'      => '3.32',
            'Locale::Language'      => '3.32',
            'Locale::Script'        => '3.32',
            'Math::BigFloat'        => '1.9997',
            'Math::BigInt'          => '1.9997',
            'Math::BigInt::Calc'    => '1.9997',
            'Math::BigInt::CalcEmu' => '1.9997',
            'Module::CoreList'      => '5.20140920',
            'Module::CoreList::TieHashDelta'=> '5.20140920',
            'Module::CoreList::Utils'=> '5.20140920',
            'POSIX'                 => '1.43',
            'Pod::Perldoc'          => '3.24',
            'Pod::Perldoc::BaseTo'  => '3.24',
            'Pod::Perldoc::GetOptsOO'=> '3.24',
            'Pod::Perldoc::ToANSI'  => '3.24',
            'Pod::Perldoc::ToChecker'=> '3.24',
            'Pod::Perldoc::ToMan'   => '3.24',
            'Pod::Perldoc::ToNroff' => '3.24',
            'Pod::Perldoc::ToPod'   => '3.24',
            'Pod::Perldoc::ToRtf'   => '3.24',
            'Pod::Perldoc::ToTerm'  => '3.24',
            'Pod::Perldoc::ToText'  => '3.24',
            'Pod::Perldoc::ToTk'    => '3.24',
            'Pod::Perldoc::ToXml'   => '3.24',
            'Scalar::Util'          => '1.41',
            'Sub::Util'             => '1.41',
            'TAP::Base'             => '3.33',
            'TAP::Formatter::Base'  => '3.33',
            'TAP::Formatter::Color' => '3.33',
            'TAP::Formatter::Console'=> '3.33',
            'TAP::Formatter::Console::ParallelSession'=> '3.33',
            'TAP::Formatter::Console::Session'=> '3.33',
            'TAP::Formatter::File'  => '3.33',
            'TAP::Formatter::File::Session'=> '3.33',
            'TAP::Formatter::Session'=> '3.33',
            'TAP::Harness'          => '3.33',
            'TAP::Harness::Env'     => '3.33',
            'TAP::Object'           => '3.33',
            'TAP::Parser'           => '3.33',
            'TAP::Parser::Aggregator'=> '3.33',
            'TAP::Parser::Grammar'  => '3.33',
            'TAP::Parser::Iterator' => '3.33',
            'TAP::Parser::Iterator::Array'=> '3.33',
            'TAP::Parser::Iterator::Process'=> '3.33',
            'TAP::Parser::Iterator::Stream'=> '3.33',
            'TAP::Parser::IteratorFactory'=> '3.33',
            'TAP::Parser::Multiplexer'=> '3.33',
            'TAP::Parser::Result'   => '3.33',
            'TAP::Parser::Result::Bailout'=> '3.33',
            'TAP::Parser::Result::Comment'=> '3.33',
            'TAP::Parser::Result::Plan'=> '3.33',
            'TAP::Parser::Result::Pragma'=> '3.33',
            'TAP::Parser::Result::Test'=> '3.33',
            'TAP::Parser::Result::Unknown'=> '3.33',
            'TAP::Parser::Result::Version'=> '3.33',
            'TAP::Parser::Result::YAML'=> '3.33',
            'TAP::Parser::ResultFactory'=> '3.33',
            'TAP::Parser::Scheduler'=> '3.33',
            'TAP::Parser::Scheduler::Job'=> '3.33',
            'TAP::Parser::Scheduler::Spinner'=> '3.33',
            'TAP::Parser::Source'   => '3.33',
            'TAP::Parser::SourceHandler'=> '3.33',
            'TAP::Parser::SourceHandler::Executable'=> '3.33',
            'TAP::Parser::SourceHandler::File'=> '3.33',
            'TAP::Parser::SourceHandler::Handle'=> '3.33',
            'TAP::Parser::SourceHandler::Perl'=> '3.33',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.33',
            'TAP::Parser::YAMLish::Reader'=> '3.33',
            'TAP::Parser::YAMLish::Writer'=> '3.33',
            'Term::ReadLine'        => '1.15',
            'Test::Builder'         => '1.001006',
            'Test::Builder::Module' => '1.001006',
            'Test::Builder::Tester' => '1.24',
            'Test::Builder::Tester::Color'=> '1.24',
            'Test::Harness'         => '3.33',
            'Test::More'            => '1.001006',
            'Test::Simple'          => '1.001006',
            'Time::Piece'           => '1.29',
            'Time::Seconds'         => '1.29',
            'XS::APItest'           => '0.64',
            '_charnames'            => '1.42',
            'attributes'            => '0.23',
            'bigint'                => '0.37',
            'bignum'                => '0.38',
            'bigrat'                => '0.37',
            'constant'              => '1.32',
            'experimental'          => '0.010',
            'overload'              => '1.23',
            'threads'               => '1.96',
            'version'               => '0.9909',
            'version::regex'        => '0.9909',
            'version::vpp'          => '0.9909',
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
            'B'                     => '1.52',
            'B::Concise'            => '0.994',
            'B::Debug'              => '1.22',
            'B::Deparse'            => '1.29',
            'B::Op_private'         => '5.021005',
            'CPAN::Meta'            => '2.142690',
            'CPAN::Meta::Converter' => '2.142690',
            'CPAN::Meta::Feature'   => '2.142690',
            'CPAN::Meta::History'   => '2.142690',
            'CPAN::Meta::Merge'     => '2.142690',
            'CPAN::Meta::Prereqs'   => '2.142690',
            'CPAN::Meta::Spec'      => '2.142690',
            'CPAN::Meta::Validator' => '2.142690',
            'Compress::Raw::Bzip2'  => '2.066',
            'Compress::Raw::Zlib'   => '2.066',
            'Compress::Zlib'        => '2.066',
            'Config'                => '5.021005',
            'Cwd'                   => '3.51',
            'DynaLoader'            => '1.27',
            'Errno'                 => '1.21',
            'ExtUtils::CBuilder'    => '0.280220',
            'ExtUtils::CBuilder::Base'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280220',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::BCC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::GCC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::Windows::MSVC'=> '0.280220',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280220',
            'ExtUtils::CBuilder::Platform::android'=> '0.280220',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280220',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280220',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280220',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280220',
            'ExtUtils::Miniperl'    => '1.03',
            'Fcntl'                 => '1.13',
            'File::Find'            => '1.29',
            'File::Spec'            => '3.51',
            'File::Spec::Cygwin'    => '3.51',
            'File::Spec::Epoc'      => '3.51',
            'File::Spec::Functions' => '3.51',
            'File::Spec::Mac'       => '3.51',
            'File::Spec::OS2'       => '3.51',
            'File::Spec::Unix'      => '3.51',
            'File::Spec::VMS'       => '3.51',
            'File::Spec::Win32'     => '3.51',
            'HTTP::Tiny'            => '0.050',
            'IO::Compress::Adapter::Bzip2'=> '2.066',
            'IO::Compress::Adapter::Deflate'=> '2.066',
            'IO::Compress::Adapter::Identity'=> '2.066',
            'IO::Compress::Base'    => '2.066',
            'IO::Compress::Base::Common'=> '2.066',
            'IO::Compress::Bzip2'   => '2.066',
            'IO::Compress::Deflate' => '2.066',
            'IO::Compress::Gzip'    => '2.066',
            'IO::Compress::Gzip::Constants'=> '2.066',
            'IO::Compress::RawDeflate'=> '2.066',
            'IO::Compress::Zip'     => '2.066',
            'IO::Compress::Zip::Constants'=> '2.066',
            'IO::Compress::Zlib::Constants'=> '2.066',
            'IO::Compress::Zlib::Extra'=> '2.066',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.066',
            'IO::Uncompress::Adapter::Identity'=> '2.066',
            'IO::Uncompress::Adapter::Inflate'=> '2.066',
            'IO::Uncompress::AnyInflate'=> '2.066',
            'IO::Uncompress::AnyUncompress'=> '2.066',
            'IO::Uncompress::Base'  => '2.066',
            'IO::Uncompress::Bunzip2'=> '2.066',
            'IO::Uncompress::Gunzip'=> '2.066',
            'IO::Uncompress::Inflate'=> '2.066',
            'IO::Uncompress::RawInflate'=> '2.066',
            'IO::Uncompress::Unzip' => '2.066',
            'JSON::PP'              => '2.27300',
            'Module::CoreList'      => '5.20141020',
            'Module::CoreList::TieHashDelta'=> '5.20141020',
            'Module::CoreList::Utils'=> '5.20141020',
            'Net::Cmd'              => '3.02',
            'Net::Config'           => '3.02',
            'Net::Domain'           => '3.02',
            'Net::FTP'              => '3.02',
            'Net::FTP::A'           => '3.02',
            'Net::FTP::E'           => '3.02',
            'Net::FTP::I'           => '3.02',
            'Net::FTP::L'           => '3.02',
            'Net::FTP::dataconn'    => '3.02',
            'Net::NNTP'             => '3.02',
            'Net::Netrc'            => '3.02',
            'Net::POP3'             => '3.02',
            'Net::SMTP'             => '3.02',
            'Net::Time'             => '3.02',
            'Opcode'                => '1.29',
            'POSIX'                 => '1.45',
            'Socket'                => '2.016',
            'Test::Builder'         => '1.001008',
            'Test::Builder::Module' => '1.001008',
            'Test::More'            => '1.001008',
            'Test::Simple'          => '1.001008',
            'XS::APItest'           => '0.65',
            'XSLoader'              => '0.18',
            'attributes'            => '0.24',
            'experimental'          => '0.012',
            'feature'               => '1.38',
            'perlfaq'               => '5.0150046',
            're'                    => '0.27',
            'threads::shared'       => '1.47',
            'warnings'              => '1.28',
            'warnings::register'    => '1.04',
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
            'App::Prove'            => '3.34',
            'App::Prove::State'     => '3.34',
            'App::Prove::State::Result'=> '3.34',
            'App::Prove::State::Result::Test'=> '3.34',
            'B'                     => '1.53',
            'B::Concise'            => '0.995',
            'B::Deparse'            => '1.30',
            'B::Op_private'         => '5.021006',
            'CPAN::Meta'            => '2.143240',
            'CPAN::Meta::Converter' => '2.143240',
            'CPAN::Meta::Feature'   => '2.143240',
            'CPAN::Meta::History'   => '2.143240',
            'CPAN::Meta::Merge'     => '2.143240',
            'CPAN::Meta::Prereqs'   => '2.143240',
            'CPAN::Meta::Requirements'=> '2.130',
            'CPAN::Meta::Spec'      => '2.143240',
            'CPAN::Meta::Validator' => '2.143240',
            'Config'                => '5.021006',
            'Devel::Peek'           => '1.19',
            'Digest::SHA'           => '5.93',
            'DynaLoader'            => '1.28',
            'Encode'                => '2.64',
            'Exporter'              => '5.72',
            'Exporter::Heavy'       => '5.72',
            'ExtUtils::Command::MM' => '7.02',
            'ExtUtils::Liblist'     => '7.02',
            'ExtUtils::Liblist::Kid'=> '7.02',
            'ExtUtils::MM'          => '7.02',
            'ExtUtils::MM_AIX'      => '7.02',
            'ExtUtils::MM_Any'      => '7.02',
            'ExtUtils::MM_BeOS'     => '7.02',
            'ExtUtils::MM_Cygwin'   => '7.02',
            'ExtUtils::MM_DOS'      => '7.02',
            'ExtUtils::MM_Darwin'   => '7.02',
            'ExtUtils::MM_MacOS'    => '7.02',
            'ExtUtils::MM_NW5'      => '7.02',
            'ExtUtils::MM_OS2'      => '7.02',
            'ExtUtils::MM_QNX'      => '7.02',
            'ExtUtils::MM_UWIN'     => '7.02',
            'ExtUtils::MM_Unix'     => '7.02',
            'ExtUtils::MM_VMS'      => '7.02',
            'ExtUtils::MM_VOS'      => '7.02',
            'ExtUtils::MM_Win32'    => '7.02',
            'ExtUtils::MM_Win95'    => '7.02',
            'ExtUtils::MY'          => '7.02',
            'ExtUtils::MakeMaker'   => '7.02',
            'ExtUtils::MakeMaker::Config'=> '7.02',
            'ExtUtils::MakeMaker::Locale'=> '7.02',
            'ExtUtils::MakeMaker::version'=> '7.02',
            'ExtUtils::MakeMaker::version::regex'=> '7.02',
            'ExtUtils::MakeMaker::version::vpp'=> '7.02',
            'ExtUtils::Manifest'    => '1.69',
            'ExtUtils::Mkbootstrap' => '7.02',
            'ExtUtils::Mksymlists'  => '7.02',
            'ExtUtils::ParseXS'     => '3.26',
            'ExtUtils::ParseXS::Constants'=> '3.26',
            'ExtUtils::ParseXS::CountLines'=> '3.26',
            'ExtUtils::ParseXS::Eval'=> '3.26',
            'ExtUtils::ParseXS::Utilities'=> '3.26',
            'ExtUtils::testlib'     => '7.02',
            'File::Spec::VMS'       => '3.52',
            'HTTP::Tiny'            => '0.051',
            'I18N::Langinfo'        => '0.12',
            'IO::Socket'            => '1.38',
            'Module::CoreList'      => '5.20141120',
            'Module::CoreList::TieHashDelta'=> '5.20141120',
            'Module::CoreList::Utils'=> '5.20141120',
            'POSIX'                 => '1.46',
            'PerlIO::encoding'      => '0.20',
            'PerlIO::scalar'        => '0.20',
            'TAP::Base'             => '3.34',
            'TAP::Formatter::Base'  => '3.34',
            'TAP::Formatter::Color' => '3.34',
            'TAP::Formatter::Console'=> '3.34',
            'TAP::Formatter::Console::ParallelSession'=> '3.34',
            'TAP::Formatter::Console::Session'=> '3.34',
            'TAP::Formatter::File'  => '3.34',
            'TAP::Formatter::File::Session'=> '3.34',
            'TAP::Formatter::Session'=> '3.34',
            'TAP::Harness'          => '3.34',
            'TAP::Harness::Env'     => '3.34',
            'TAP::Object'           => '3.34',
            'TAP::Parser'           => '3.34',
            'TAP::Parser::Aggregator'=> '3.34',
            'TAP::Parser::Grammar'  => '3.34',
            'TAP::Parser::Iterator' => '3.34',
            'TAP::Parser::Iterator::Array'=> '3.34',
            'TAP::Parser::Iterator::Process'=> '3.34',
            'TAP::Parser::Iterator::Stream'=> '3.34',
            'TAP::Parser::IteratorFactory'=> '3.34',
            'TAP::Parser::Multiplexer'=> '3.34',
            'TAP::Parser::Result'   => '3.34',
            'TAP::Parser::Result::Bailout'=> '3.34',
            'TAP::Parser::Result::Comment'=> '3.34',
            'TAP::Parser::Result::Plan'=> '3.34',
            'TAP::Parser::Result::Pragma'=> '3.34',
            'TAP::Parser::Result::Test'=> '3.34',
            'TAP::Parser::Result::Unknown'=> '3.34',
            'TAP::Parser::Result::Version'=> '3.34',
            'TAP::Parser::Result::YAML'=> '3.34',
            'TAP::Parser::ResultFactory'=> '3.34',
            'TAP::Parser::Scheduler'=> '3.34',
            'TAP::Parser::Scheduler::Job'=> '3.34',
            'TAP::Parser::Scheduler::Spinner'=> '3.34',
            'TAP::Parser::Source'   => '3.34',
            'TAP::Parser::SourceHandler'=> '3.34',
            'TAP::Parser::SourceHandler::Executable'=> '3.34',
            'TAP::Parser::SourceHandler::File'=> '3.34',
            'TAP::Parser::SourceHandler::Handle'=> '3.34',
            'TAP::Parser::SourceHandler::Perl'=> '3.34',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.34',
            'TAP::Parser::YAMLish::Reader'=> '3.34',
            'TAP::Parser::YAMLish::Writer'=> '3.34',
            'Test::Builder'         => '1.301001_075',
            'Test::Builder::Module' => '1.301001_075',
            'Test::Builder::Tester' => '1.301001_075',
            'Test::Builder::Tester::Color'=> '1.301001_075',
            'Test::Harness'         => '3.34',
            'Test::More'            => '1.301001_075',
            'Test::More::DeepCheck' => undef,
            'Test::More::DeepCheck::Strict'=> undef,
            'Test::More::DeepCheck::Tolerant'=> undef,
            'Test::More::Tools'     => undef,
            'Test::MostlyLike'      => undef,
            'Test::Simple'          => '1.301001_075',
            'Test::Stream'          => '1.301001_075',
            'Test::Stream::ArrayBase'=> undef,
            'Test::Stream::ArrayBase::Meta'=> undef,
            'Test::Stream::Carp'    => undef,
            'Test::Stream::Context' => undef,
            'Test::Stream::Event'   => undef,
            'Test::Stream::Event::Bail'=> undef,
            'Test::Stream::Event::Child'=> undef,
            'Test::Stream::Event::Diag'=> undef,
            'Test::Stream::Event::Finish'=> undef,
            'Test::Stream::Event::Note'=> undef,
            'Test::Stream::Event::Ok'=> undef,
            'Test::Stream::Event::Plan'=> undef,
            'Test::Stream::Event::Subtest'=> undef,
            'Test::Stream::ExitMagic'=> undef,
            'Test::Stream::ExitMagic::Context'=> undef,
            'Test::Stream::Exporter'=> undef,
            'Test::Stream::Exporter::Meta'=> undef,
            'Test::Stream::IOSets'  => undef,
            'Test::Stream::Meta'    => undef,
            'Test::Stream::PackageUtil'=> undef,
            'Test::Stream::Tester'  => undef,
            'Test::Stream::Tester::Checks'=> undef,
            'Test::Stream::Tester::Checks::Event'=> undef,
            'Test::Stream::Tester::Events'=> undef,
            'Test::Stream::Tester::Events::Event'=> undef,
            'Test::Stream::Tester::Grab'=> undef,
            'Test::Stream::Threads' => undef,
            'Test::Stream::Toolset' => undef,
            'Test::Stream::Util'    => undef,
            'Test::Tester'          => '1.301001_075',
            'Test::Tester::Capture' => undef,
            'Test::use::ok'         => '1.301001_075',
            'Unicode::UCD'          => '0.59',
            'XS::APItest'           => '0.68',
            'XSLoader'              => '0.19',
            'experimental'          => '0.013',
            'locale'                => '1.05',
            'ok'                    => '1.301001_075',
            'overload'              => '1.24',
            're'                    => '0.28',
            'warnings'              => '1.29',
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
            'Archive::Tar'          => '2.04',
            'Archive::Tar::Constant'=> '2.04',
            'Archive::Tar::File'    => '2.04',
            'B'                     => '1.54',
            'B::Concise'            => '0.996',
            'B::Deparse'            => '1.31',
            'B::Op_private'         => '5.021007',
            'B::Showlex'            => '1.05',
            'Compress::Raw::Bzip2'  => '2.067',
            'Compress::Raw::Zlib'   => '2.067',
            'Compress::Zlib'        => '2.067',
            'Config'                => '5.021007',
            'Cwd'                   => '3.54',
            'DB_File'               => '1.834',
            'Data::Dumper'          => '2.155',
            'Devel::PPPort'         => '3.25',
            'Devel::Peek'           => '1.20',
            'DynaLoader'            => '1.29',
            'Encode'                => '2.67',
            'Errno'                 => '1.22',
            'ExtUtils::CBuilder'    => '0.280221',
            'ExtUtils::CBuilder::Base'=> '0.280221',
            'ExtUtils::CBuilder::Platform::Unix'=> '0.280221',
            'ExtUtils::CBuilder::Platform::VMS'=> '0.280221',
            'ExtUtils::CBuilder::Platform::Windows'=> '0.280221',
            'ExtUtils::CBuilder::Platform::aix'=> '0.280221',
            'ExtUtils::CBuilder::Platform::android'=> '0.280221',
            'ExtUtils::CBuilder::Platform::cygwin'=> '0.280221',
            'ExtUtils::CBuilder::Platform::darwin'=> '0.280221',
            'ExtUtils::CBuilder::Platform::dec_osf'=> '0.280221',
            'ExtUtils::CBuilder::Platform::os2'=> '0.280221',
            'ExtUtils::Command::MM' => '7.04',
            'ExtUtils::Liblist'     => '7.04',
            'ExtUtils::Liblist::Kid'=> '7.04',
            'ExtUtils::MM'          => '7.04',
            'ExtUtils::MM_AIX'      => '7.04',
            'ExtUtils::MM_Any'      => '7.04',
            'ExtUtils::MM_BeOS'     => '7.04',
            'ExtUtils::MM_Cygwin'   => '7.04',
            'ExtUtils::MM_DOS'      => '7.04',
            'ExtUtils::MM_Darwin'   => '7.04',
            'ExtUtils::MM_MacOS'    => '7.04',
            'ExtUtils::MM_NW5'      => '7.04',
            'ExtUtils::MM_OS2'      => '7.04',
            'ExtUtils::MM_QNX'      => '7.04',
            'ExtUtils::MM_UWIN'     => '7.04',
            'ExtUtils::MM_Unix'     => '7.04',
            'ExtUtils::MM_VMS'      => '7.04',
            'ExtUtils::MM_VOS'      => '7.04',
            'ExtUtils::MM_Win32'    => '7.04',
            'ExtUtils::MM_Win95'    => '7.04',
            'ExtUtils::MY'          => '7.04',
            'ExtUtils::MakeMaker'   => '7.04',
            'ExtUtils::MakeMaker::Config'=> '7.04',
            'ExtUtils::MakeMaker::Locale'=> '7.04',
            'ExtUtils::MakeMaker::version'=> '7.04',
            'ExtUtils::MakeMaker::version::regex'=> '7.04',
            'ExtUtils::MakeMaker::version::vpp'=> '7.04',
            'ExtUtils::Mkbootstrap' => '7.04',
            'ExtUtils::Mksymlists'  => '7.04',
            'ExtUtils::ParseXS'     => '3.27',
            'ExtUtils::ParseXS::Constants'=> '3.27',
            'ExtUtils::ParseXS::CountLines'=> '3.27',
            'ExtUtils::ParseXS::Eval'=> '3.27',
            'ExtUtils::ParseXS::Utilities'=> '3.27',
            'ExtUtils::testlib'     => '7.04',
            'File::Spec'            => '3.53',
            'File::Spec::Cygwin'    => '3.54',
            'File::Spec::Epoc'      => '3.54',
            'File::Spec::Functions' => '3.54',
            'File::Spec::Mac'       => '3.54',
            'File::Spec::OS2'       => '3.54',
            'File::Spec::Unix'      => '3.54',
            'File::Spec::VMS'       => '3.54',
            'File::Spec::Win32'     => '3.54',
            'Filter::Util::Call'    => '1.51',
            'HTTP::Tiny'            => '0.053',
            'IO'                    => '1.35',
            'IO::Compress::Adapter::Bzip2'=> '2.067',
            'IO::Compress::Adapter::Deflate'=> '2.067',
            'IO::Compress::Adapter::Identity'=> '2.067',
            'IO::Compress::Base'    => '2.067',
            'IO::Compress::Base::Common'=> '2.067',
            'IO::Compress::Bzip2'   => '2.067',
            'IO::Compress::Deflate' => '2.067',
            'IO::Compress::Gzip'    => '2.067',
            'IO::Compress::Gzip::Constants'=> '2.067',
            'IO::Compress::RawDeflate'=> '2.067',
            'IO::Compress::Zip'     => '2.067',
            'IO::Compress::Zip::Constants'=> '2.067',
            'IO::Compress::Zlib::Constants'=> '2.067',
            'IO::Compress::Zlib::Extra'=> '2.067',
            'IO::Socket::IP'        => '0.34',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.067',
            'IO::Uncompress::Adapter::Identity'=> '2.067',
            'IO::Uncompress::Adapter::Inflate'=> '2.067',
            'IO::Uncompress::AnyInflate'=> '2.067',
            'IO::Uncompress::AnyUncompress'=> '2.067',
            'IO::Uncompress::Base'  => '2.067',
            'IO::Uncompress::Bunzip2'=> '2.067',
            'IO::Uncompress::Gunzip'=> '2.067',
            'IO::Uncompress::Inflate'=> '2.067',
            'IO::Uncompress::RawInflate'=> '2.067',
            'IO::Uncompress::Unzip' => '2.067',
            'Locale::Codes'         => '3.33',
            'Locale::Codes::Constants'=> '3.33',
            'Locale::Codes::Country'=> '3.33',
            'Locale::Codes::Country_Codes'=> '3.33',
            'Locale::Codes::Country_Retired'=> '3.33',
            'Locale::Codes::Currency'=> '3.33',
            'Locale::Codes::Currency_Codes'=> '3.33',
            'Locale::Codes::Currency_Retired'=> '3.33',
            'Locale::Codes::LangExt'=> '3.33',
            'Locale::Codes::LangExt_Codes'=> '3.33',
            'Locale::Codes::LangExt_Retired'=> '3.33',
            'Locale::Codes::LangFam'=> '3.33',
            'Locale::Codes::LangFam_Codes'=> '3.33',
            'Locale::Codes::LangFam_Retired'=> '3.33',
            'Locale::Codes::LangVar'=> '3.33',
            'Locale::Codes::LangVar_Codes'=> '3.33',
            'Locale::Codes::LangVar_Retired'=> '3.33',
            'Locale::Codes::Language'=> '3.33',
            'Locale::Codes::Language_Codes'=> '3.33',
            'Locale::Codes::Language_Retired'=> '3.33',
            'Locale::Codes::Script' => '3.33',
            'Locale::Codes::Script_Codes'=> '3.33',
            'Locale::Codes::Script_Retired'=> '3.33',
            'Locale::Country'       => '3.33',
            'Locale::Currency'      => '3.33',
            'Locale::Language'      => '3.33',
            'Locale::Maketext'      => '1.26',
            'Locale::Script'        => '3.33',
            'Module::CoreList'      => '5.20141220',
            'Module::CoreList::TieHashDelta'=> '5.20141220',
            'Module::CoreList::Utils'=> '5.20141220',
            'NDBM_File'             => '1.14',
            'Net::Cmd'              => '3.04',
            'Net::Config'           => '3.04',
            'Net::Domain'           => '3.04',
            'Net::FTP'              => '3.04',
            'Net::FTP::A'           => '3.04',
            'Net::FTP::E'           => '3.04',
            'Net::FTP::I'           => '3.04',
            'Net::FTP::L'           => '3.04',
            'Net::FTP::dataconn'    => '3.04',
            'Net::NNTP'             => '3.04',
            'Net::Netrc'            => '3.04',
            'Net::POP3'             => '3.04',
            'Net::SMTP'             => '3.04',
            'Net::Time'             => '3.04',
            'Opcode'                => '1.30',
            'POSIX'                 => '1.48',
            'PerlIO::scalar'        => '0.21',
            'Pod::Escapes'          => '1.07',
            'SDBM_File'             => '1.12',
            'Storable'              => '2.52',
            'Sys::Hostname'         => '1.20',
            'Test::Builder'         => '1.301001_090',
            'Test::Builder::Module' => '1.301001_090',
            'Test::Builder::Tester' => '1.301001_090',
            'Test::Builder::Tester::Color'=> '1.301001_090',
            'Test::CanFork'         => undef,
            'Test::CanThread'       => undef,
            'Test::More'            => '1.301001_090',
            'Test::Simple'          => '1.301001_090',
            'Test::Stream'          => '1.301001_090',
            'Test::Stream::API'     => undef,
            'Test::Stream::ForceExit'=> undef,
            'Test::Stream::Subtest' => undef,
            'Test::Tester'          => '1.301001_090',
            'Test::use::ok'         => '1.301001_090',
            'Unicode::Collate'      => '1.09',
            'Unicode::Collate::CJK::Big5'=> '1.09',
            'Unicode::Collate::CJK::GB2312'=> '1.09',
            'Unicode::Collate::CJK::JISX0208'=> '1.09',
            'Unicode::Collate::CJK::Korean'=> '1.09',
            'Unicode::Collate::CJK::Pinyin'=> '1.09',
            'Unicode::Collate::CJK::Stroke'=> '1.09',
            'Unicode::Collate::CJK::Zhuyin'=> '1.09',
            'Unicode::Collate::Locale'=> '1.09',
            'XS::APItest'           => '0.69',
            'XSLoader'              => '0.20',
            '_charnames'            => '1.43',
            'arybase'               => '0.09',
            'charnames'             => '1.43',
            'feature'               => '1.39',
            'mro'                   => '1.17',
            'ok'                    => '1.301001_090',
            'strict'                => '1.09',
            'threads'               => '1.96_001',
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
            'App::Prove'            => '3.35',
            'App::Prove::State'     => '3.35',
            'App::Prove::State::Result'=> '3.35',
            'App::Prove::State::Result::Test'=> '3.35',
            'B'                     => '1.55',
            'B::Deparse'            => '1.32',
            'B::Op_private'         => '5.021008',
            'CPAN::Meta::Requirements'=> '2.131',
            'Compress::Raw::Bzip2'  => '2.068',
            'Compress::Raw::Zlib'   => '2.068',
            'Compress::Zlib'        => '2.068',
            'Config'                => '5.021008',
            'DB_File'               => '1.835',
            'Data::Dumper'          => '2.156',
            'Devel::PPPort'         => '3.28',
            'Devel::Peek'           => '1.21',
            'Digest::MD5'           => '2.54',
            'Digest::SHA'           => '5.95',
            'DynaLoader'            => '1.30',
            'ExtUtils::Command'     => '1.20',
            'ExtUtils::Manifest'    => '1.70',
            'Fatal'                 => '2.26',
            'File::Glob'            => '1.24',
            'Filter::Util::Call'    => '1.54',
            'Getopt::Long'          => '2.43',
            'IO::Compress::Adapter::Bzip2'=> '2.068',
            'IO::Compress::Adapter::Deflate'=> '2.068',
            'IO::Compress::Adapter::Identity'=> '2.068',
            'IO::Compress::Base'    => '2.068',
            'IO::Compress::Base::Common'=> '2.068',
            'IO::Compress::Bzip2'   => '2.068',
            'IO::Compress::Deflate' => '2.068',
            'IO::Compress::Gzip'    => '2.068',
            'IO::Compress::Gzip::Constants'=> '2.068',
            'IO::Compress::RawDeflate'=> '2.068',
            'IO::Compress::Zip'     => '2.068',
            'IO::Compress::Zip::Constants'=> '2.068',
            'IO::Compress::Zlib::Constants'=> '2.068',
            'IO::Compress::Zlib::Extra'=> '2.068',
            'IO::Socket::IP'        => '0.36',
            'IO::Uncompress::Adapter::Bunzip2'=> '2.068',
            'IO::Uncompress::Adapter::Identity'=> '2.068',
            'IO::Uncompress::Adapter::Inflate'=> '2.068',
            'IO::Uncompress::AnyInflate'=> '2.068',
            'IO::Uncompress::AnyUncompress'=> '2.068',
            'IO::Uncompress::Base'  => '2.068',
            'IO::Uncompress::Bunzip2'=> '2.068',
            'IO::Uncompress::Gunzip'=> '2.068',
            'IO::Uncompress::Inflate'=> '2.068',
            'IO::Uncompress::RawInflate'=> '2.068',
            'IO::Uncompress::Unzip' => '2.068',
            'MIME::Base64'          => '3.15',
            'Module::CoreList'      => '5.20150220',
            'Module::CoreList::TieHashDelta'=> '5.20150220',
            'Module::CoreList::Utils'=> '5.20150220',
            'Module::Load::Conditional'=> '0.64',
            'Module::Metadata'      => '1.000026',
            'Net::Cmd'              => '3.05',
            'Net::Config'           => '3.05',
            'Net::Domain'           => '3.05',
            'Net::FTP'              => '3.05',
            'Net::FTP::A'           => '3.05',
            'Net::FTP::E'           => '3.05',
            'Net::FTP::I'           => '3.05',
            'Net::FTP::L'           => '3.05',
            'Net::FTP::dataconn'    => '3.05',
            'Net::NNTP'             => '3.05',
            'Net::Netrc'            => '3.05',
            'Net::POP3'             => '3.05',
            'Net::SMTP'             => '3.05',
            'Net::Time'             => '3.05',
            'Opcode'                => '1.31',
            'POSIX'                 => '1.49',
            'PerlIO::encoding'      => '0.21',
            'Pod::Simple'           => '3.29',
            'Pod::Simple::BlackBox' => '3.29',
            'Pod::Simple::Checker'  => '3.29',
            'Pod::Simple::Debug'    => '3.29',
            'Pod::Simple::DumpAsText'=> '3.29',
            'Pod::Simple::DumpAsXML'=> '3.29',
            'Pod::Simple::HTML'     => '3.29',
            'Pod::Simple::HTMLBatch'=> '3.29',
            'Pod::Simple::LinkSection'=> '3.29',
            'Pod::Simple::Methody'  => '3.29',
            'Pod::Simple::Progress' => '3.29',
            'Pod::Simple::PullParser'=> '3.29',
            'Pod::Simple::PullParserEndToken'=> '3.29',
            'Pod::Simple::PullParserStartToken'=> '3.29',
            'Pod::Simple::PullParserTextToken'=> '3.29',
            'Pod::Simple::PullParserToken'=> '3.29',
            'Pod::Simple::RTF'      => '3.29',
            'Pod::Simple::Search'   => '3.29',
            'Pod::Simple::SimpleTree'=> '3.29',
            'Pod::Simple::Text'     => '3.29',
            'Pod::Simple::TextContent'=> '3.29',
            'Pod::Simple::TiedOutFH'=> '3.29',
            'Pod::Simple::Transcode'=> '3.29',
            'Pod::Simple::TranscodeDumb'=> '3.29',
            'Pod::Simple::TranscodeSmart'=> '3.29',
            'Pod::Simple::XHTML'    => '3.29',
            'Pod::Simple::XMLOutStream'=> '3.29',
            'SDBM_File'             => '1.13',
            'Safe'                  => '2.39',
            'TAP::Base'             => '3.35',
            'TAP::Formatter::Base'  => '3.35',
            'TAP::Formatter::Color' => '3.35',
            'TAP::Formatter::Console'=> '3.35',
            'TAP::Formatter::Console::ParallelSession'=> '3.35',
            'TAP::Formatter::Console::Session'=> '3.35',
            'TAP::Formatter::File'  => '3.35',
            'TAP::Formatter::File::Session'=> '3.35',
            'TAP::Formatter::Session'=> '3.35',
            'TAP::Harness'          => '3.35',
            'TAP::Harness::Env'     => '3.35',
            'TAP::Object'           => '3.35',
            'TAP::Parser'           => '3.35',
            'TAP::Parser::Aggregator'=> '3.35',
            'TAP::Parser::Grammar'  => '3.35',
            'TAP::Parser::Iterator' => '3.35',
            'TAP::Parser::Iterator::Array'=> '3.35',
            'TAP::Parser::Iterator::Process'=> '3.35',
            'TAP::Parser::Iterator::Stream'=> '3.35',
            'TAP::Parser::IteratorFactory'=> '3.35',
            'TAP::Parser::Multiplexer'=> '3.35',
            'TAP::Parser::Result'   => '3.35',
            'TAP::Parser::Result::Bailout'=> '3.35',
            'TAP::Parser::Result::Comment'=> '3.35',
            'TAP::Parser::Result::Plan'=> '3.35',
            'TAP::Parser::Result::Pragma'=> '3.35',
            'TAP::Parser::Result::Test'=> '3.35',
            'TAP::Parser::Result::Unknown'=> '3.35',
            'TAP::Parser::Result::Version'=> '3.35',
            'TAP::Parser::Result::YAML'=> '3.35',
            'TAP::Parser::ResultFactory'=> '3.35',
            'TAP::Parser::Scheduler'=> '3.35',
            'TAP::Parser::Scheduler::Job'=> '3.35',
            'TAP::Parser::Scheduler::Spinner'=> '3.35',
            'TAP::Parser::Source'   => '3.35',
            'TAP::Parser::SourceHandler'=> '3.35',
            'TAP::Parser::SourceHandler::Executable'=> '3.35',
            'TAP::Parser::SourceHandler::File'=> '3.35',
            'TAP::Parser::SourceHandler::Handle'=> '3.35',
            'TAP::Parser::SourceHandler::Perl'=> '3.35',
            'TAP::Parser::SourceHandler::RawTAP'=> '3.35',
            'TAP::Parser::YAMLish::Reader'=> '3.35',
            'TAP::Parser::YAMLish::Writer'=> '3.35',
            'Test::Builder'         => '1.301001_097',
            'Test::Builder::Module' => '1.301001_097',
            'Test::Builder::Tester' => '1.301001_097',
            'Test::Builder::Tester::Color'=> '1.301001_097',
            'Test::Harness'         => '3.35',
            'Test::More'            => '1.301001_097',
            'Test::Simple'          => '1.301001_097',
            'Test::Stream'          => '1.301001_097',
            'Test::Stream::Block'   => undef,
            'Test::Tester'          => '1.301001_097',
            'Test::Tester::CaptureRunner'=> undef,
            'Test::Tester::Delegate'=> undef,
            'Test::use::ok'         => '1.301001_097',
            'Unicode::Collate'      => '1.10',
            'Unicode::Collate::CJK::Big5'=> '1.10',
            'Unicode::Collate::CJK::GB2312'=> '1.10',
            'Unicode::Collate::CJK::JISX0208'=> '1.10',
            'Unicode::Collate::CJK::Korean'=> '1.10',
            'Unicode::Collate::CJK::Pinyin'=> '1.10',
            'Unicode::Collate::CJK::Stroke'=> '1.10',
            'Unicode::Collate::CJK::Zhuyin'=> '1.10',
            'Unicode::Collate::Locale'=> '1.10',
            'VMS::DCLsym'           => '1.06',
            'XS::APItest'           => '0.70',
            'arybase'               => '0.10',
            'attributes'            => '0.25',
            'autodie'               => '2.26',
            'autodie::Scope::Guard' => '2.26',
            'autodie::Scope::GuardStack'=> '2.26',
            'autodie::ScopeUtil'    => '2.26',
            'autodie::exception'    => '2.26',
            'autodie::exception::system'=> '2.26',
            'autodie::hints'        => '2.26',
            'autodie::skip'         => '2.26',
            'ok'                    => '1.301001_097',
            're'                    => '0.30',
            'warnings'              => '1.30',
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
            'CPAN::Author'          => '5.5002',
            'CPAN::CacheMgr'        => '5.5002',
            'CPAN::FTP'             => '5.5006',
            'CPAN::HTTP::Client'    => '1.9601',
            'CPAN::HandleConfig'    => '5.5005',
            'CPAN::Index'           => '1.9601',
            'CPAN::LWP::UserAgent'  => '1.9601',
            'CPAN::Mirrors'         => '1.9601',
            'Config'                => '5.020002',
            'Cwd'                   => '3.48_01',
            'Data::Dumper'          => '2.151_01',
            'Errno'                 => '1.20_05',
            'File::Spec'            => '3.48_01',
            'File::Spec::Cygwin'    => '3.48_01',
            'File::Spec::Epoc'      => '3.48_01',
            'File::Spec::Functions' => '3.48_01',
            'File::Spec::Mac'       => '3.48_01',
            'File::Spec::OS2'       => '3.48_01',
            'File::Spec::Unix'      => '3.48_01',
            'File::Spec::VMS'       => '3.48_01',
            'File::Spec::Win32'     => '3.48_01',
            'IO::Socket'            => '1.38',
            'Module::CoreList'      => '5.20150214',
            'Module::CoreList::TieHashDelta'=> '5.20150214',
            'Module::CoreList::Utils'=> '5.20150214',
            'PerlIO::scalar'        => '0.18_01',
            'Pod::PlainText'        => '2.07',
            'Storable'              => '2.49_01',
            'VMS::DCLsym'           => '1.05_01',
            'VMS::Stdio'            => '2.41',
            'attributes'            => '0.23',
            'feature'               => '1.36_01',
        },
        removed => {
        }
    },
);

sub is_core
{
    my $module = shift;
    $module = shift if eval { $module->isa(__PACKAGE__) } && @_ > 0 && defined($_[0]) && $_[0] =~ /^\w/;
    my ($module_version, $perl_version);

    $module_version = shift if @_ > 0;
    $perl_version   = @_ > 0 ? shift : $];

    my $first_release = first_release($module);

    return 0 if !defined($first_release) || $first_release > $perl_version;

    my $final_release = removed_from($module);

    return 0 if defined($final_release) && $perl_version > $final_release;

    # If a minimum version of the module was specified:
    # Step through all perl releases ($prn)
    # so we can find what version of the module
    # was included in the specified version of perl.
    # On the way if we pass the required module version, we can
    # short-circuit and return true
    if (defined($module_version)) {
        # The Perl releases aren't a linear sequence, but a tree. We need to build the path
        # of releases from 5 to the specified release, and follow the module's version(s)
        # along that path.
        my @releases = ($perl_version);
        my $rel = $perl_version;
        while (defined($rel)) {
            $rel = $delta{$rel}->{delta_from};
            unshift(@releases, $rel) if defined($rel);
        }
        RELEASE:
        foreach my $prn (@releases) {
            next RELEASE if $prn <= $first_release;
            last RELEASE if $prn > $perl_version;
            next unless defined(my $next_module_version
                                   = $delta{$prn}->{changed}->{$module});
            return 1 if version->parse($next_module_version) >= version->parse($module_version);
        }
        return 0;
    }

    return 1 if !defined($final_release);

    return $perl_version <= $final_release;
}

for my $version (sort { $a <=> $b } keys %delta) {
    my $data = $delta{$version};

    tie %{$version{$version}}, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $version{$data->{delta_from}} : undef;
}

%deprecated = (
    5.011    => {
        changed => { map { $_ => 1 } qw/
            Class::ISA
            Pod::Plainer
            Shell
            Switch
        /},
    },
    5.011001 => { delta_from => 5.011 },
    5.011002 => { delta_from => 5.011001 },
    5.011003 => { delta_from => 5.011002 },
    5.011004 => { delta_from => 5.011003 },
    5.011005 => { delta_from => 5.011004 },

    5.012    => { delta_from => 5.011005 },
    5.012001 => { delta_from => 5.012 },
    5.012002 => { delta_from => 5.012001 },
    5.012003 => { delta_from => 5.012002 },
    5.012004 => { delta_from => 5.012003 },
    5.012005 => { delta_from => 5.012004 },

    5.013    => { delta_from => 5.012005 },
    5.013001 => {
        delta_from => 5.013,
        removed => { map { $_ => 1 } qw/
            Class::ISA
            Pod::Plainer
            Switch
        /},
    },
    5.013002 => { delta_from => 5.013001 },
    5.013003 => { delta_from => 5.013002 },
    5.013004 => { delta_from => 5.013003 },
    5.013005 => { delta_from => 5.013004 },
    5.013006 => { delta_from => 5.013005 },
    5.013007 => { delta_from => 5.013006 },
    5.013008 => { delta_from => 5.013007 },
    5.013009 => { delta_from => 5.013008 },
    5.01301  => { delta_from => 5.013009 },
    5.013011 => { delta_from => 5.01301  },

    5.014    => { delta_from => 5.013011 },
    5.014001 => { delta_from => 5.014    },
    5.014002 => { delta_from => 5.014001 },
    5.014003 => { delta_from => 5.014002 },
    5.014004 => { delta_from => 5.014003 },

    5.015    => {
        delta_from => 5.014004,
        removed => { Shell => 1 },
    },
    5.015001 => { delta_from => 5.015    },
    5.015002 => { delta_from => 5.015001 },
    5.015003 => { delta_from => 5.015002 },
    5.015004 => { delta_from => 5.015003 },
    5.015005 => { delta_from => 5.015004 },
    5.015006 => { delta_from => 5.015005 },
    5.015007 => { delta_from => 5.015006 },
    5.015008 => { delta_from => 5.015007 },
    5.015009 => { delta_from => 5.015008 },

    5.016    => { delta_from => 5.015009 },
    5.016001 => { delta_from => 5.016    },
    5.016002 => { delta_from => 5.016001 },
    5.016003 => { delta_from => 5.016002 },

    5.017    => { delta_from => 5.016003 },
    5.017001 => { delta_from => 5.017    },
    5.017002 => { delta_from => 5.017001 },
    5.017003 => { delta_from => 5.017002 },
    5.017004 => { delta_from => 5.017003 },
    5.017005 => { delta_from => 5.017004 },
    5.017006 => { delta_from => 5.017005 },
    5.017007 => { delta_from => 5.017006 },
    5.017008 => {
        delta_from => 5.017007,
        changed => { 'Pod::LaTeX' => 1 },
    },
    5.017009 => {
        delta_from => 5.017008,
        changed => { map { $_ => 1 } qw/
            Archive::Extract
            B::Lint
            B::Lint::Debug
            CPANPLUS
            CPANPLUS::Backend
            CPANPLUS::Backend::RV
            CPANPLUS::Config
            CPANPLUS::Config::HomeEnv
            CPANPLUS::Configure
            CPANPLUS::Configure::Setup
            CPANPLUS::Dist
            CPANPLUS::Dist::Autobundle
            CPANPLUS::Dist::Base
            CPANPLUS::Dist::Build
            CPANPLUS::Dist::Build::Constants
            CPANPLUS::Dist::MM
            CPANPLUS::Dist::Sample
            CPANPLUS::Error
            CPANPLUS::Internals
            CPANPLUS::Internals::Constants
            CPANPLUS::Internals::Constants::Report
            CPANPLUS::Internals::Extract
            CPANPLUS::Internals::Fetch
            CPANPLUS::Internals::Report
            CPANPLUS::Internals::Search
            CPANPLUS::Internals::Source
            CPANPLUS::Internals::Source::Memory
            CPANPLUS::Internals::Source::SQLite
            CPANPLUS::Internals::Source::SQLite::Tie
            CPANPLUS::Internals::Utils
            CPANPLUS::Internals::Utils::Autoflush
            CPANPLUS::Module
            CPANPLUS::Module::Author
            CPANPLUS::Module::Author::Fake
            CPANPLUS::Module::Checksums
            CPANPLUS::Module::Fake
            CPANPLUS::Module::Signature
            CPANPLUS::Selfupdate
            CPANPLUS::Shell
            CPANPLUS::Shell::Classic
            CPANPLUS::Shell::Default
            CPANPLUS::Shell::Default::Plugins::CustomSource
            CPANPLUS::Shell::Default::Plugins::Remote
            CPANPLUS::Shell::Default::Plugins::Source
            Devel::InnerPackage
            File::CheckTree
            Log::Message
            Log::Message::Config
            Log::Message::Handlers
            Log::Message::Item
            Log::Message::Simple
            Module::Pluggable
            Module::Pluggable::Object
            Object::Accessor
            Term::UI
            Term::UI::History
            Text::Soundex
        /},
    },
    5.01701  => { delta_from => 5.017009 },
    5.017011 => { delta_from => 5.01701  },
    5.017012 => { delta_from => 5.017011 },

    5.018    => { delta_from => 5.017012 },
    5.018001 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },
    5.018002 => {
        delta_from => 5.018001,
        changed => {
        },
        removed => {
        }
    },
    5.018003 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },
    5.018004 => {
        delta_from => 5.018,
        changed => {
        },
        removed => {
        }
    },

    5.019    => {
        delta_from => 5.018,
        changed => { 'Module::Build' => 1 },
        removed => { map { $_ => 1 } qw/
            Archive::Extract
            B::Lint
            B::Lint::Debug
            CPANPLUS
            CPANPLUS::Backend
            CPANPLUS::Backend::RV
            CPANPLUS::Config
            CPANPLUS::Config::HomeEnv
            CPANPLUS::Configure
            CPANPLUS::Configure::Setup
            CPANPLUS::Dist
            CPANPLUS::Dist::Autobundle
            CPANPLUS::Dist::Base
            CPANPLUS::Dist::Build
            CPANPLUS::Dist::Build::Constants
            CPANPLUS::Dist::MM
            CPANPLUS::Dist::Sample
            CPANPLUS::Error
            CPANPLUS::Internals
            CPANPLUS::Internals::Constants
            CPANPLUS::Internals::Constants::Report
            CPANPLUS::Internals::Extract
            CPANPLUS::Internals::Fetch
            CPANPLUS::Internals::Report
            CPANPLUS::Internals::Search
            CPANPLUS::Internals::Source
            CPANPLUS::Internals::Source::Memory
            CPANPLUS::Internals::Source::SQLite
            CPANPLUS::Internals::Source::SQLite::Tie
            CPANPLUS::Internals::Utils
            CPANPLUS::Internals::Utils::Autoflush
            CPANPLUS::Module
            CPANPLUS::Module::Author
            CPANPLUS::Module::Author::Fake
            CPANPLUS::Module::Checksums
            CPANPLUS::Module::Fake
            CPANPLUS::Module::Signature
            CPANPLUS::Selfupdate
            CPANPLUS::Shell
            CPANPLUS::Shell::Classic
            CPANPLUS::Shell::Default
            CPANPLUS::Shell::Default::Plugins::CustomSource
            CPANPLUS::Shell::Default::Plugins::Remote
            CPANPLUS::Shell::Default::Plugins::Source
            Devel::InnerPackage
            File::CheckTree
            Log::Message
            Log::Message::Config
            Log::Message::Handlers
            Log::Message::Item
            Log::Message::Simple
            Module::Pluggable
            Module::Pluggable::Object
            Object::Accessor
            Pod::LaTeX
            Term::UI
            Term::UI::History
            Text::Soundex
        /}
    },
    5.019001 => {
        delta_from => 5.019,
        changed => {
        },
        removed => {
        }
    },
    5.019002 => {
        delta_from => 5.019001,
        changed => {
        },
        removed => {
        }
    },
    5.019003 => {
        delta_from => 5.019002,
        changed => {
        },
        removed => {
        }
    },
    5.019004 => {
        delta_from => 5.019003,
        changed => {
            'Module::Build::Base'   => '1',
            'Module::Build::Compat' => '1',
            'Module::Build::Config' => '1',
            'Module::Build::ConfigData'=> '1',
            'Module::Build::Cookbook'=> '1',
            'Module::Build::Dumper' => '1',
            'Module::Build::ModuleInfo'=> '1',
            'Module::Build::Notes'  => '1',
            'Module::Build::PPMMaker'=> '1',
            'Module::Build::Platform::Default'=> '1',
            'Module::Build::Platform::MacOS'=> '1',
            'Module::Build::Platform::Unix'=> '1',
            'Module::Build::Platform::VMS'=> '1',
            'Module::Build::Platform::VOS'=> '1',
            'Module::Build::Platform::Windows'=> '1',
            'Module::Build::Platform::aix'=> '1',
            'Module::Build::Platform::cygwin'=> '1',
            'Module::Build::Platform::darwin'=> '1',
            'Module::Build::Platform::os2'=> '1',
            'Module::Build::PodParser'=> '1',
            'Module::Build::Version'=> '1',
            'Module::Build::YAML'   => '1',
            'inc::latest'           => '1',
        },
        removed => {
        }
    },
    5.019005 => {
        delta_from => 5.019004,
        changed => {
        },
        removed => {
        }
    },
    5.019006 => {
        delta_from => 5.019005,
        changed => {
            'Package::Constants'    => '1',
        },
        removed => {
        }
    },
    5.019007 => {
        delta_from => 5.019006,
        changed => {
            'CGI'                   => '1',
            'CGI::Apache'           => '1',
            'CGI::Carp'             => '1',
            'CGI::Cookie'           => '1',
            'CGI::Fast'             => '1',
            'CGI::Pretty'           => '1',
            'CGI::Push'             => '1',
            'CGI::Switch'           => '1',
            'CGI::Util'             => '1',
        },
        removed => {
        }
    },
    5.019008 => {
        delta_from => 5.019007,
        changed => {
        },
        removed => {
        }
    },
    5.019009 => {
        delta_from => 5.019008,
        changed => {
        },
        removed => {
        }
    },
    5.01901 => {
        delta_from => 5.019009,
        changed => {
        },
        removed => {
        }
    },
    5.019011 => {
        delta_from => 5.019010,
        changed => {
        },
        removed => {
        }
    },
    5.020000 => {
        delta_from => 5.019011,
        changed => {
        },
        removed => {
        }
    },
    5.021000 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
        }
    },
    5.021001 => {
        delta_from => 5.017007,
        changed => {
        },
        removed => {
        }
    },
    5.021002 => {
        delta_from => 5.021001,
        changed => {
        },
        removed => {
        }
    },
    5.021003 => {
        delta_from => 5.021002,
        changed => {
        },
        removed => {
        }
    },
    5.020001 => {
        delta_from => 5.020000,
        changed => {
        },
        removed => {
        }
    },
    5.021004 => {
        delta_from => 5.021003,
        changed => {
        },
        removed => {
        }
    },
    5.021005 => {
        delta_from => 5.021004,
        changed => {
        },
        removed => {
        }
    },
    5.021006 => {
        delta_from => 5.021005,
        changed => {
        },
        removed => {
        }
    },
    5.021007 => {
        delta_from => 5.021006,
        changed => {
        },
        removed => {
        }
    },
    5.021008 => {
        delta_from => 5.021007,
        changed => {
        },
        removed => {
        }
    },
    5.020002 => {
        delta_from => 5.020001,
        changed => {
        },
        removed => {
        }
    },
);

for my $version (sort { $a <=> $b } keys %deprecated) {
    my $data = $deprecated{$version};

    tie %{ $deprecated{$version} }, 'Module::CoreList::TieHashDelta',
        $data->{changed}, $data->{removed},
        $data->{delta_from} ? $deprecated{ $data->{delta_from} } : undef;
}

%upstream = (
    'App::Cpan'             => 'cpan',
    'App::Prove'            => 'cpan',
    'App::Prove::State'     => 'cpan',
    'App::Prove::State::Result'=> 'cpan',
    'App::Prove::State::Result::Test'=> 'cpan',
    'Archive::Tar'          => 'cpan',
    'Archive::Tar::Constant'=> 'cpan',
    'Archive::Tar::File'    => 'cpan',
    'AutoLoader'            => 'cpan',
    'AutoSplit'             => 'cpan',
    'B::Debug'              => 'cpan',
    'CGI'                   => 'cpan',
    'CGI::Apache'           => 'cpan',
    'CGI::Carp'             => 'cpan',
    'CGI::Cookie'           => 'cpan',
    'CGI::Fast'             => 'cpan',
    'CGI::Pretty'           => 'cpan',
    'CGI::Push'             => 'cpan',
    'CGI::Switch'           => 'cpan',
    'CGI::Util'             => 'cpan',
    'CPAN'                  => 'cpan',
    'CPAN::Author'          => 'cpan',
    'CPAN::Bundle'          => 'cpan',
    'CPAN::CacheMgr'        => 'cpan',
    'CPAN::Complete'        => 'cpan',
    'CPAN::Debug'           => 'cpan',
    'CPAN::DeferredCode'    => 'cpan',
    'CPAN::Distribution'    => 'cpan',
    'CPAN::Distroprefs'     => 'cpan',
    'CPAN::Distrostatus'    => 'cpan',
    'CPAN::Exception::RecursiveDependency'=> 'cpan',
    'CPAN::Exception::blocked_urllist'=> 'cpan',
    'CPAN::Exception::yaml_not_installed'=> 'cpan',
    'CPAN::Exception::yaml_process_error'=> 'cpan',
    'CPAN::FTP'             => 'cpan',
    'CPAN::FTP::netrc'      => 'cpan',
    'CPAN::FirstTime'       => 'cpan',
    'CPAN::HTTP::Client'    => 'cpan',
    'CPAN::HTTP::Credentials'=> 'cpan',
    'CPAN::HandleConfig'    => 'cpan',
    'CPAN::Index'           => 'cpan',
    'CPAN::InfoObj'         => 'cpan',
    'CPAN::Kwalify'         => 'cpan',
    'CPAN::LWP::UserAgent'  => 'cpan',
    'CPAN::Meta'            => 'cpan',
    'CPAN::Meta::Converter' => 'cpan',
    'CPAN::Meta::Feature'   => 'cpan',
    'CPAN::Meta::History'   => 'cpan',
    'CPAN::Meta::Prereqs'   => 'cpan',
    'CPAN::Meta::Requirements'=> 'cpan',
    'CPAN::Meta::Spec'      => 'cpan',
    'CPAN::Meta::Validator' => 'cpan',
    'CPAN::Meta::YAML'      => 'cpan',
    'CPAN::Mirrors'         => 'cpan',
    'CPAN::Module'          => 'cpan',
    'CPAN::Nox'             => 'cpan',
    'CPAN::Prompt'          => 'cpan',
    'CPAN::Queue'           => 'cpan',
    'CPAN::Shell'           => 'cpan',
    'CPAN::Tarzip'          => 'cpan',
    'CPAN::URL'             => 'cpan',
    'CPAN::Version'         => 'cpan',
    'Compress::Raw::Bzip2'  => 'cpan',
    'Compress::Raw::Zlib'   => 'cpan',
    'Compress::Zlib'        => 'cpan',
    'Config::Perl::V'       => 'cpan',
    'DB_File'               => 'cpan',
    'Devel::PPPort'         => 'cpan',
    'Digest'                => 'cpan',
    'Digest::MD5'           => 'cpan',
    'Digest::SHA'           => 'cpan',
    'Digest::base'          => 'cpan',
    'Digest::file'          => 'cpan',
    'Encode'                => 'cpan',
    'Encode::Alias'         => 'cpan',
    'Encode::Byte'          => 'cpan',
    'Encode::CJKConstants'  => 'cpan',
    'Encode::CN'            => 'cpan',
    'Encode::CN::HZ'        => 'cpan',
    'Encode::Config'        => 'cpan',
    'Encode::EBCDIC'        => 'cpan',
    'Encode::Encoder'       => 'cpan',
    'Encode::Encoding'      => 'cpan',
    'Encode::GSM0338'       => 'cpan',
    'Encode::Guess'         => 'cpan',
    'Encode::JP'            => 'cpan',
    'Encode::JP::H2Z'       => 'cpan',
    'Encode::JP::JIS7'      => 'cpan',
    'Encode::KR'            => 'cpan',
    'Encode::KR::2022_KR'   => 'cpan',
    'Encode::MIME::Header'  => 'cpan',
    'Encode::MIME::Header::ISO_2022_JP'=> 'cpan',
    'Encode::MIME::Name'    => 'cpan',
    'Encode::Symbol'        => 'cpan',
    'Encode::TW'            => 'cpan',
    'Encode::Unicode'       => 'cpan',
    'Encode::Unicode::UTF7' => 'cpan',
    'ExtUtils::Command::MM' => 'cpan',
    'ExtUtils::Constant'    => 'cpan',
    'ExtUtils::Constant::Base'=> 'cpan',
    'ExtUtils::Constant::ProxySubs'=> 'cpan',
    'ExtUtils::Constant::Utils'=> 'cpan',
    'ExtUtils::Constant::XS'=> 'cpan',
    'ExtUtils::Liblist'     => 'cpan',
    'ExtUtils::Liblist::Kid'=> 'cpan',
    'ExtUtils::MM'          => 'cpan',
    'ExtUtils::MM_AIX'      => 'cpan',
    'ExtUtils::MM_Any'      => 'cpan',
    'ExtUtils::MM_BeOS'     => 'cpan',
    'ExtUtils::MM_Cygwin'   => 'cpan',
    'ExtUtils::MM_DOS'      => 'cpan',
    'ExtUtils::MM_Darwin'   => 'cpan',
    'ExtUtils::MM_MacOS'    => 'cpan',
    'ExtUtils::MM_NW5'      => 'cpan',
    'ExtUtils::MM_OS2'      => 'cpan',
    'ExtUtils::MM_QNX'      => 'cpan',
    'ExtUtils::MM_UWIN'     => 'cpan',
    'ExtUtils::MM_Unix'     => 'cpan',
    'ExtUtils::MM_VMS'      => 'cpan',
    'ExtUtils::MM_VOS'      => 'cpan',
    'ExtUtils::MM_Win32'    => 'cpan',
    'ExtUtils::MM_Win95'    => 'cpan',
    'ExtUtils::MY'          => 'cpan',
    'ExtUtils::MakeMaker'   => 'cpan',
    'ExtUtils::MakeMaker::Config'=> 'cpan',
    'ExtUtils::Mkbootstrap' => 'cpan',
    'ExtUtils::Mksymlists'  => 'cpan',
    'ExtUtils::testlib'     => 'cpan',
    'Fatal'                 => 'cpan',
    'File::Fetch'           => 'cpan',
    'File::GlobMapper'      => 'cpan',
    'File::Path'            => 'cpan',
    'File::Temp'            => 'cpan',
    'Filter::Util::Call'    => 'cpan',
    'Getopt::Long'          => 'cpan',
    'HTTP::Tiny'            => 'cpan',
    'IO::Compress::Adapter::Bzip2'=> 'cpan',
    'IO::Compress::Adapter::Deflate'=> 'cpan',
    'IO::Compress::Adapter::Identity'=> 'cpan',
    'IO::Compress::Base'    => 'cpan',
    'IO::Compress::Base::Common'=> 'cpan',
    'IO::Compress::Bzip2'   => 'cpan',
    'IO::Compress::Deflate' => 'cpan',
    'IO::Compress::Gzip'    => 'cpan',
    'IO::Compress::Gzip::Constants'=> 'cpan',
    'IO::Compress::RawDeflate'=> 'cpan',
    'IO::Compress::Zip'     => 'cpan',
    'IO::Compress::Zip::Constants'=> 'cpan',
    'IO::Compress::Zlib::Constants'=> 'cpan',
    'IO::Compress::Zlib::Extra'=> 'cpan',
    'IO::Socket::IP'        => 'cpan',
    'IO::Uncompress::Adapter::Bunzip2'=> 'cpan',
    'IO::Uncompress::Adapter::Identity'=> 'cpan',
    'IO::Uncompress::Adapter::Inflate'=> 'cpan',
    'IO::Uncompress::AnyInflate'=> 'cpan',
    'IO::Uncompress::AnyUncompress'=> 'cpan',
    'IO::Uncompress::Base'  => 'cpan',
    'IO::Uncompress::Bunzip2'=> 'cpan',
    'IO::Uncompress::Gunzip'=> 'cpan',
    'IO::Uncompress::Inflate'=> 'cpan',
    'IO::Uncompress::RawInflate'=> 'cpan',
    'IO::Uncompress::Unzip' => 'cpan',
    'IO::Zlib'              => 'cpan',
    'IPC::Cmd'              => 'cpan',
    'IPC::Msg'              => 'cpan',
    'IPC::Semaphore'        => 'cpan',
    'IPC::SharedMem'        => 'cpan',
    'IPC::SysV'             => 'cpan',
    'JSON::PP'              => 'cpan',
    'JSON::PP::Boolean'     => 'cpan',
    'List::Util'            => 'cpan',
    'List::Util::XS'        => 'cpan',
    'Locale::Codes'         => 'cpan',
    'Locale::Codes::Constants'=> 'cpan',
    'Locale::Codes::Country'=> 'cpan',
    'Locale::Codes::Country_Codes'=> 'cpan',
    'Locale::Codes::Country_Retired'=> 'cpan',
    'Locale::Codes::Currency'=> 'cpan',
    'Locale::Codes::Currency_Codes'=> 'cpan',
    'Locale::Codes::Currency_Retired'=> 'cpan',
    'Locale::Codes::LangExt'=> 'cpan',
    'Locale::Codes::LangExt_Codes'=> 'cpan',
    'Locale::Codes::LangExt_Retired'=> 'cpan',
    'Locale::Codes::LangFam'=> 'cpan',
    'Locale::Codes::LangFam_Codes'=> 'cpan',
    'Locale::Codes::LangFam_Retired'=> 'cpan',
    'Locale::Codes::LangVar'=> 'cpan',
    'Locale::Codes::LangVar_Codes'=> 'cpan',
    'Locale::Codes::LangVar_Retired'=> 'cpan',
    'Locale::Codes::Language'=> 'cpan',
    'Locale::Codes::Language_Codes'=> 'cpan',
    'Locale::Codes::Language_Retired'=> 'cpan',
    'Locale::Codes::Script' => 'cpan',
    'Locale::Codes::Script_Codes'=> 'cpan',
    'Locale::Codes::Script_Retired'=> 'cpan',
    'Locale::Country'       => 'cpan',
    'Locale::Currency'      => 'cpan',
    'Locale::Language'      => 'cpan',
    'Locale::Maketext::Simple'=> 'cpan',
    'Locale::Script'        => 'cpan',
    'MIME::Base64'          => 'cpan',
    'MIME::QuotedPrint'     => 'cpan',
    'Math::Complex'         => 'cpan',
    'Math::Trig'            => 'cpan',
    'Memoize'               => 'cpan',
    'Memoize::AnyDBM_File'  => 'cpan',
    'Memoize::Expire'       => 'cpan',
    'Memoize::ExpireFile'   => 'cpan',
    'Memoize::ExpireTest'   => 'cpan',
    'Memoize::NDBM_File'    => 'cpan',
    'Memoize::SDBM_File'    => 'cpan',
    'Memoize::Storable'     => 'cpan',
    'Module::Build'         => 'cpan',
    'Module::Build::Base'   => 'cpan',
    'Module::Build::Compat' => 'cpan',
    'Module::Build::Config' => 'cpan',
    'Module::Build::ConfigData'=> 'cpan',
    'Module::Build::Cookbook'=> 'cpan',
    'Module::Build::Dumper' => 'cpan',
    'Module::Build::ModuleInfo'=> 'cpan',
    'Module::Build::Notes'  => 'cpan',
    'Module::Build::PPMMaker'=> 'cpan',
    'Module::Build::Platform::Default'=> 'cpan',
    'Module::Build::Platform::MacOS'=> 'cpan',
    'Module::Build::Platform::Unix'=> 'cpan',
    'Module::Build::Platform::VMS'=> 'cpan',
    'Module::Build::Platform::VOS'=> 'cpan',
    'Module::Build::Platform::Windows'=> 'cpan',
    'Module::Build::Platform::aix'=> 'cpan',
    'Module::Build::Platform::cygwin'=> 'cpan',
    'Module::Build::Platform::darwin'=> 'cpan',
    'Module::Build::Platform::os2'=> 'cpan',
    'Module::Build::PodParser'=> 'cpan',
    'Module::Build::Version'=> 'cpan',
    'Module::Build::YAML'   => 'cpan',
    'Module::Load'          => 'cpan',
    'Module::Load::Conditional'=> 'cpan',
    'Module::Loaded'        => 'cpan',
    'Module::Metadata'      => 'cpan',
    'NEXT'                  => 'cpan',
    'Net::Cmd'              => 'cpan',
    'Net::Config'           => 'cpan',
    'Net::Domain'           => 'cpan',
    'Net::FTP'              => 'cpan',
    'Net::FTP::A'           => 'cpan',
    'Net::FTP::E'           => 'cpan',
    'Net::FTP::I'           => 'cpan',
    'Net::FTP::L'           => 'cpan',
    'Net::FTP::dataconn'    => 'cpan',
    'Net::NNTP'             => 'cpan',
    'Net::Netrc'            => 'cpan',
    'Net::POP3'             => 'cpan',
    'Net::SMTP'             => 'cpan',
    'Net::Time'             => 'cpan',
    'Package::Constants'    => 'cpan',
    'Params::Check'         => 'cpan',
    'Parse::CPAN::Meta'     => 'cpan',
    'Perl::OSType'          => 'cpan',
    'PerlIO::via::QuotedPrint'=> 'cpan',
    'Pod::Checker'          => 'cpan',
    'Pod::Escapes'          => 'cpan',
    'Pod::Find'             => 'cpan',
    'Pod::InputObjects'     => 'cpan',
    'Pod::Man'              => 'cpan',
    'Pod::ParseLink'        => 'cpan',
    'Pod::ParseUtils'       => 'cpan',
    'Pod::Parser'           => 'cpan',
    'Pod::Perldoc'          => 'cpan',
    'Pod::Perldoc::BaseTo'  => 'cpan',
    'Pod::Perldoc::GetOptsOO'=> 'cpan',
    'Pod::Perldoc::ToANSI'  => 'cpan',
    'Pod::Perldoc::ToChecker'=> 'cpan',
    'Pod::Perldoc::ToMan'   => 'cpan',
    'Pod::Perldoc::ToNroff' => 'cpan',
    'Pod::Perldoc::ToPod'   => 'cpan',
    'Pod::Perldoc::ToRtf'   => 'cpan',
    'Pod::Perldoc::ToTerm'  => 'cpan',
    'Pod::Perldoc::ToText'  => 'cpan',
    'Pod::Perldoc::ToTk'    => 'cpan',
    'Pod::Perldoc::ToXml'   => 'cpan',
    'Pod::PlainText'        => 'cpan',
    'Pod::Select'           => 'cpan',
    'Pod::Simple'           => 'cpan',
    'Pod::Simple::BlackBox' => 'cpan',
    'Pod::Simple::Checker'  => 'cpan',
    'Pod::Simple::Debug'    => 'cpan',
    'Pod::Simple::DumpAsText'=> 'cpan',
    'Pod::Simple::DumpAsXML'=> 'cpan',
    'Pod::Simple::HTML'     => 'cpan',
    'Pod::Simple::HTMLBatch'=> 'cpan',
    'Pod::Simple::HTMLLegacy'=> 'cpan',
    'Pod::Simple::LinkSection'=> 'cpan',
    'Pod::Simple::Methody'  => 'cpan',
    'Pod::Simple::Progress' => 'cpan',
    'Pod::Simple::PullParser'=> 'cpan',
    'Pod::Simple::PullParserEndToken'=> 'cpan',
    'Pod::Simple::PullParserStartToken'=> 'cpan',
    'Pod::Simple::PullParserTextToken'=> 'cpan',
    'Pod::Simple::PullParserToken'=> 'cpan',
    'Pod::Simple::RTF'      => 'cpan',
    'Pod::Simple::Search'   => 'cpan',
    'Pod::Simple::SimpleTree'=> 'cpan',
    'Pod::Simple::Text'     => 'cpan',
    'Pod::Simple::TextContent'=> 'cpan',
    'Pod::Simple::TiedOutFH'=> 'cpan',
    'Pod::Simple::Transcode'=> 'cpan',
    'Pod::Simple::TranscodeDumb'=> 'cpan',
    'Pod::Simple::TranscodeSmart'=> 'cpan',
    'Pod::Simple::XHTML'    => 'cpan',
    'Pod::Simple::XMLOutStream'=> 'cpan',
    'Pod::Text'             => 'cpan',
    'Pod::Text::Color'      => 'cpan',
    'Pod::Text::Overstrike' => 'cpan',
    'Pod::Text::Termcap'    => 'cpan',
    'Pod::Usage'            => 'cpan',
    'Scalar::Util'          => 'cpan',
    'Socket'                => 'cpan',
    'Sys::Syslog'           => 'cpan',
    'Sys::Syslog::Win32'    => 'cpan',
    'TAP::Base'             => 'cpan',
    'TAP::Formatter::Base'  => 'cpan',
    'TAP::Formatter::Color' => 'cpan',
    'TAP::Formatter::Console'=> 'cpan',
    'TAP::Formatter::Console::ParallelSession'=> 'cpan',
    'TAP::Formatter::Console::Session'=> 'cpan',
    'TAP::Formatter::File'  => 'cpan',
    'TAP::Formatter::File::Session'=> 'cpan',
    'TAP::Formatter::Session'=> 'cpan',
    'TAP::Harness'          => 'cpan',
    'TAP::Harness::Env'     => 'cpan',
    'TAP::Object'           => 'cpan',
    'TAP::Parser'           => 'cpan',
    'TAP::Parser::Aggregator'=> 'cpan',
    'TAP::Parser::Grammar'  => 'cpan',
    'TAP::Parser::Iterator' => 'cpan',
    'TAP::Parser::Iterator::Array'=> 'cpan',
    'TAP::Parser::Iterator::Process'=> 'cpan',
    'TAP::Parser::Iterator::Stream'=> 'cpan',
    'TAP::Parser::IteratorFactory'=> 'cpan',
    'TAP::Parser::Multiplexer'=> 'cpan',
    'TAP::Parser::Result'   => 'cpan',
    'TAP::Parser::Result::Bailout'=> 'cpan',
    'TAP::Parser::Result::Comment'=> 'cpan',
    'TAP::Parser::Result::Plan'=> 'cpan',
    'TAP::Parser::Result::Pragma'=> 'cpan',
    'TAP::Parser::Result::Test'=> 'cpan',
    'TAP::Parser::Result::Unknown'=> 'cpan',
    'TAP::Parser::Result::Version'=> 'cpan',
    'TAP::Parser::Result::YAML'=> 'cpan',
    'TAP::Parser::ResultFactory'=> 'cpan',
    'TAP::Parser::Scheduler'=> 'cpan',
    'TAP::Parser::Scheduler::Job'=> 'cpan',
    'TAP::Parser::Scheduler::Spinner'=> 'cpan',
    'TAP::Parser::Source'   => 'cpan',
    'TAP::Parser::SourceHandler'=> 'cpan',
    'TAP::Parser::SourceHandler::Executable'=> 'cpan',
    'TAP::Parser::SourceHandler::File'=> 'cpan',
    'TAP::Parser::SourceHandler::Handle'=> 'cpan',
    'TAP::Parser::SourceHandler::Perl'=> 'cpan',
    'TAP::Parser::SourceHandler::RawTAP'=> 'cpan',
    'TAP::Parser::YAMLish::Reader'=> 'cpan',
    'TAP::Parser::YAMLish::Writer'=> 'cpan',
    'Term::ANSIColor'       => 'cpan',
    'Term::Cap'             => 'cpan',
    'Test'                  => 'cpan',
    'Test::Builder'         => 'cpan',
    'Test::Builder::Module' => 'cpan',
    'Test::Builder::Tester' => 'cpan',
    'Test::Builder::Tester::Color'=> 'cpan',
    'Test::Harness'         => 'cpan',
    'Test::More'            => 'cpan',
    'Test::Simple'          => 'cpan',
    'Text::Balanced'        => 'cpan',
    'Text::ParseWords'      => 'cpan',
    'Text::Tabs'            => 'cpan',
    'Text::Wrap'            => 'cpan',
    'Tie::RefHash'          => 'cpan',
    'Time::HiRes'           => 'cpan',
    'Time::Local'           => 'cpan',
    'Time::Piece'           => 'cpan',
    'Time::Seconds'         => 'cpan',
    'Unicode::Collate'      => 'cpan',
    'Unicode::Collate::CJK::Big5'=> 'cpan',
    'Unicode::Collate::CJK::GB2312'=> 'cpan',
    'Unicode::Collate::CJK::JISX0208'=> 'cpan',
    'Unicode::Collate::CJK::Korean'=> 'cpan',
    'Unicode::Collate::CJK::Pinyin'=> 'cpan',
    'Unicode::Collate::CJK::Stroke'=> 'cpan',
    'Unicode::Collate::CJK::Zhuyin'=> 'cpan',
    'Unicode::Collate::Locale'=> 'cpan',
    'Unicode::Normalize'    => 'cpan',
    'Win32'                 => 'cpan',
    'Win32API::File'        => 'cpan',
    'Win32API::File::ExtUtils::Myconst2perl'=> 'cpan',
    'autodie'               => 'cpan',
    'autodie::exception'    => 'cpan',
    'autodie::exception::system'=> 'cpan',
    'autodie::hints'        => 'cpan',
    'autodie::skip'         => 'cpan',
    'encoding'              => 'cpan',
    'encoding::warnings'    => 'cpan',
    'experimental'          => 'cpan',
    'inc::latest'           => 'cpan',
    'parent'                => 'cpan',
    'perlfaq'               => 'cpan',
    'version'               => 'cpan',
    'version::regex'        => 'cpan',
    'version::vpp'          => 'cpan',
);

%bug_tracker = (
    'App::Cpan'             => undef,
    'App::Prove'            => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State'     => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State::Result'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'App::Prove::State::Result::Test'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Archive::Tar'          => undef,
    'Archive::Tar::Constant'=> undef,
    'Archive::Tar::File'    => undef,
    'B::Debug'              => undef,
    'CGI'                   => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Apache'           => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Carp'             => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Cookie'           => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Fast'             => 'https://github.com/leejo/cgi-fast/issues',
    'CGI::Pretty'           => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Push'             => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Switch'           => 'https://github.com/leejo/CGI.pm/issues',
    'CGI::Util'             => 'https://github.com/leejo/CGI.pm/issues',
    'CPAN'                  => undef,
    'CPAN::Author'          => undef,
    'CPAN::Bundle'          => undef,
    'CPAN::CacheMgr'        => undef,
    'CPAN::Complete'        => undef,
    'CPAN::Debug'           => undef,
    'CPAN::DeferredCode'    => undef,
    'CPAN::Distribution'    => undef,
    'CPAN::Distroprefs'     => undef,
    'CPAN::Distrostatus'    => undef,
    'CPAN::Exception::RecursiveDependency'=> undef,
    'CPAN::Exception::blocked_urllist'=> undef,
    'CPAN::Exception::yaml_not_installed'=> undef,
    'CPAN::Exception::yaml_process_error'=> undef,
    'CPAN::FTP'             => undef,
    'CPAN::FTP::netrc'      => undef,
    'CPAN::FirstTime'       => undef,
    'CPAN::HTTP::Client'    => undef,
    'CPAN::HTTP::Credentials'=> undef,
    'CPAN::HandleConfig'    => undef,
    'CPAN::Index'           => undef,
    'CPAN::InfoObj'         => undef,
    'CPAN::Kwalify'         => undef,
    'CPAN::LWP::UserAgent'  => undef,
    'CPAN::Meta'            => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Converter' => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Feature'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::History'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Prereqs'   => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Requirements'=> 'https://github.com/dagolden/CPAN-Meta-Requirements/issues',
    'CPAN::Meta::Spec'      => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::Validator' => 'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues',
    'CPAN::Meta::YAML'      => 'https://github.com/dagolden/CPAN-Meta-YAML/issues',
    'CPAN::Mirrors'         => undef,
    'CPAN::Module'          => undef,
    'CPAN::Nox'             => undef,
    'CPAN::Prompt'          => undef,
    'CPAN::Queue'           => undef,
    'CPAN::Shell'           => undef,
    'CPAN::Tarzip'          => undef,
    'CPAN::URL'             => undef,
    'CPAN::Version'         => undef,
    'Compress::Raw::Bzip2'  => undef,
    'Compress::Raw::Zlib'   => undef,
    'Compress::Zlib'        => undef,
    'Config::Perl::V'       => undef,
    'DB_File'               => undef,
    'Devel::PPPort'         => 'https://github.com/mhx/Devel-PPPort/issues/',
    'Digest'                => undef,
    'Digest::MD5'           => undef,
    'Digest::SHA'           => undef,
    'Digest::base'          => undef,
    'Digest::file'          => undef,
    'Encode'                => undef,
    'Encode::Alias'         => undef,
    'Encode::Byte'          => undef,
    'Encode::CJKConstants'  => undef,
    'Encode::CN'            => undef,
    'Encode::CN::HZ'        => undef,
    'Encode::Config'        => undef,
    'Encode::EBCDIC'        => undef,
    'Encode::Encoder'       => undef,
    'Encode::Encoding'      => undef,
    'Encode::GSM0338'       => undef,
    'Encode::Guess'         => undef,
    'Encode::JP'            => undef,
    'Encode::JP::H2Z'       => undef,
    'Encode::JP::JIS7'      => undef,
    'Encode::KR'            => undef,
    'Encode::KR::2022_KR'   => undef,
    'Encode::MIME::Header'  => undef,
    'Encode::MIME::Header::ISO_2022_JP'=> undef,
    'Encode::MIME::Name'    => undef,
    'Encode::Symbol'        => undef,
    'Encode::TW'            => undef,
    'Encode::Unicode'       => undef,
    'Encode::Unicode::UTF7' => undef,
    'ExtUtils::Command::MM' => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Constant'    => undef,
    'ExtUtils::Constant::Base'=> undef,
    'ExtUtils::Constant::ProxySubs'=> undef,
    'ExtUtils::Constant::Utils'=> undef,
    'ExtUtils::Constant::XS'=> undef,
    'ExtUtils::Liblist'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Liblist::Kid'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM'          => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_AIX'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Any'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_BeOS'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Cygwin'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_DOS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Darwin'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_MacOS'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_NW5'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_OS2'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_QNX'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_UWIN'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Unix'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_VMS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_VOS'      => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Win32'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MM_Win95'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MY'          => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker'   => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::MakeMaker::Config'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Mkbootstrap' => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::Mksymlists'  => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'ExtUtils::testlib'     => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker',
    'Fatal'                 => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'File::Fetch'           => undef,
    'File::GlobMapper'      => undef,
    'File::Path'            => undef,
    'File::Temp'            => 'http://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp',
    'Filter::Util::Call'    => undef,
    'Getopt::Long'          => undef,
    'HTTP::Tiny'            => 'https://github.com/chansen/p5-http-tiny/issues',
    'IO::Compress::Adapter::Bzip2'=> undef,
    'IO::Compress::Adapter::Deflate'=> undef,
    'IO::Compress::Adapter::Identity'=> undef,
    'IO::Compress::Base'    => undef,
    'IO::Compress::Base::Common'=> undef,
    'IO::Compress::Bzip2'   => undef,
    'IO::Compress::Deflate' => undef,
    'IO::Compress::Gzip'    => undef,
    'IO::Compress::Gzip::Constants'=> undef,
    'IO::Compress::RawDeflate'=> undef,
    'IO::Compress::Zip'     => undef,
    'IO::Compress::Zip::Constants'=> undef,
    'IO::Compress::Zlib::Constants'=> undef,
    'IO::Compress::Zlib::Extra'=> undef,
    'IO::Socket::IP'        => undef,
    'IO::Uncompress::Adapter::Bunzip2'=> undef,
    'IO::Uncompress::Adapter::Identity'=> undef,
    'IO::Uncompress::Adapter::Inflate'=> undef,
    'IO::Uncompress::AnyInflate'=> undef,
    'IO::Uncompress::AnyUncompress'=> undef,
    'IO::Uncompress::Base'  => undef,
    'IO::Uncompress::Bunzip2'=> undef,
    'IO::Uncompress::Gunzip'=> undef,
    'IO::Uncompress::Inflate'=> undef,
    'IO::Uncompress::RawInflate'=> undef,
    'IO::Uncompress::Unzip' => undef,
    'IO::Zlib'              => undef,
    'IPC::Cmd'              => undef,
    'IPC::Msg'              => undef,
    'IPC::Semaphore'        => undef,
    'IPC::SharedMem'        => undef,
    'IPC::SysV'             => undef,
    'JSON::PP'              => undef,
    'JSON::PP::Boolean'     => undef,
    'List::Util'            => undef,
    'List::Util::XS'        => undef,
    'Locale::Codes'         => undef,
    'Locale::Codes::Constants'=> undef,
    'Locale::Codes::Country'=> undef,
    'Locale::Codes::Country_Codes'=> undef,
    'Locale::Codes::Country_Retired'=> undef,
    'Locale::Codes::Currency'=> undef,
    'Locale::Codes::Currency_Codes'=> undef,
    'Locale::Codes::Currency_Retired'=> undef,
    'Locale::Codes::LangExt'=> undef,
    'Locale::Codes::LangExt_Codes'=> undef,
    'Locale::Codes::LangExt_Retired'=> undef,
    'Locale::Codes::LangFam'=> undef,
    'Locale::Codes::LangFam_Codes'=> undef,
    'Locale::Codes::LangFam_Retired'=> undef,
    'Locale::Codes::LangVar'=> undef,
    'Locale::Codes::LangVar_Codes'=> undef,
    'Locale::Codes::LangVar_Retired'=> undef,
    'Locale::Codes::Language'=> undef,
    'Locale::Codes::Language_Codes'=> undef,
    'Locale::Codes::Language_Retired'=> undef,
    'Locale::Codes::Script' => undef,
    'Locale::Codes::Script_Codes'=> undef,
    'Locale::Codes::Script_Retired'=> undef,
    'Locale::Country'       => undef,
    'Locale::Currency'      => undef,
    'Locale::Language'      => undef,
    'Locale::Maketext::Simple'=> undef,
    'Locale::Script'        => undef,
    'MIME::Base64'          => undef,
    'MIME::QuotedPrint'     => undef,
    'Math::Complex'         => undef,
    'Math::Trig'            => undef,
    'Memoize'               => undef,
    'Memoize::AnyDBM_File'  => undef,
    'Memoize::Expire'       => undef,
    'Memoize::ExpireFile'   => undef,
    'Memoize::ExpireTest'   => undef,
    'Memoize::NDBM_File'    => undef,
    'Memoize::SDBM_File'    => undef,
    'Memoize::Storable'     => undef,
    'Module::Build'         => undef,
    'Module::Build::Base'   => undef,
    'Module::Build::Compat' => undef,
    'Module::Build::Config' => undef,
    'Module::Build::ConfigData'=> undef,
    'Module::Build::Cookbook'=> undef,
    'Module::Build::Dumper' => undef,
    'Module::Build::ModuleInfo'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Module-Build-Deprecated',
    'Module::Build::Notes'  => undef,
    'Module::Build::PPMMaker'=> undef,
    'Module::Build::Platform::Default'=> undef,
    'Module::Build::Platform::MacOS'=> undef,
    'Module::Build::Platform::Unix'=> undef,
    'Module::Build::Platform::VMS'=> undef,
    'Module::Build::Platform::VOS'=> undef,
    'Module::Build::Platform::Windows'=> undef,
    'Module::Build::Platform::aix'=> undef,
    'Module::Build::Platform::cygwin'=> undef,
    'Module::Build::Platform::darwin'=> undef,
    'Module::Build::Platform::os2'=> undef,
    'Module::Build::PodParser'=> undef,
    'Module::Build::Version'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Module-Build-Deprecated',
    'Module::Build::YAML'   => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Module-Build-Deprecated',
    'Module::Load'          => undef,
    'Module::Load::Conditional'=> undef,
    'Module::Loaded'        => undef,
    'Module::Metadata'      => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata',
    'NEXT'                  => undef,
    'Net::Cmd'              => undef,
    'Net::Config'           => undef,
    'Net::Domain'           => undef,
    'Net::FTP'              => undef,
    'Net::FTP::A'           => undef,
    'Net::FTP::E'           => undef,
    'Net::FTP::I'           => undef,
    'Net::FTP::L'           => undef,
    'Net::FTP::dataconn'    => undef,
    'Net::NNTP'             => undef,
    'Net::Netrc'            => undef,
    'Net::POP3'             => undef,
    'Net::SMTP'             => undef,
    'Net::Time'             => undef,
    'Package::Constants'    => undef,
    'Params::Check'         => undef,
    'Parse::CPAN::Meta'     => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta',
    'Perl::OSType'          => 'https://github.com/dagolden/Perl-OSType/issues',
    'PerlIO::via::QuotedPrint'=> undef,
    'Pod::Checker'          => undef,
    'Pod::Escapes'          => undef,
    'Pod::Find'             => undef,
    'Pod::InputObjects'     => undef,
    'Pod::Man'              => undef,
    'Pod::ParseLink'        => undef,
    'Pod::ParseUtils'       => undef,
    'Pod::Parser'           => undef,
    'Pod::Perldoc'          => undef,
    'Pod::Perldoc::BaseTo'  => undef,
    'Pod::Perldoc::GetOptsOO'=> undef,
    'Pod::Perldoc::ToANSI'  => undef,
    'Pod::Perldoc::ToChecker'=> undef,
    'Pod::Perldoc::ToMan'   => undef,
    'Pod::Perldoc::ToNroff' => undef,
    'Pod::Perldoc::ToPod'   => undef,
    'Pod::Perldoc::ToRtf'   => undef,
    'Pod::Perldoc::ToTerm'  => undef,
    'Pod::Perldoc::ToText'  => undef,
    'Pod::Perldoc::ToTk'    => undef,
    'Pod::Perldoc::ToXml'   => undef,
    'Pod::PlainText'        => undef,
    'Pod::Select'           => undef,
    'Pod::Simple'           => undef,
    'Pod::Simple::BlackBox' => undef,
    'Pod::Simple::Checker'  => undef,
    'Pod::Simple::Debug'    => undef,
    'Pod::Simple::DumpAsText'=> undef,
    'Pod::Simple::DumpAsXML'=> undef,
    'Pod::Simple::HTML'     => undef,
    'Pod::Simple::HTMLBatch'=> undef,
    'Pod::Simple::HTMLLegacy'=> undef,
    'Pod::Simple::LinkSection'=> undef,
    'Pod::Simple::Methody'  => undef,
    'Pod::Simple::Progress' => undef,
    'Pod::Simple::PullParser'=> undef,
    'Pod::Simple::PullParserEndToken'=> undef,
    'Pod::Simple::PullParserStartToken'=> undef,
    'Pod::Simple::PullParserTextToken'=> undef,
    'Pod::Simple::PullParserToken'=> undef,
    'Pod::Simple::RTF'      => undef,
    'Pod::Simple::Search'   => undef,
    'Pod::Simple::SimpleTree'=> undef,
    'Pod::Simple::Text'     => undef,
    'Pod::Simple::TextContent'=> undef,
    'Pod::Simple::TiedOutFH'=> undef,
    'Pod::Simple::Transcode'=> undef,
    'Pod::Simple::TranscodeDumb'=> undef,
    'Pod::Simple::TranscodeSmart'=> undef,
    'Pod::Simple::XHTML'    => undef,
    'Pod::Simple::XMLOutStream'=> undef,
    'Pod::Text'             => undef,
    'Pod::Text::Color'      => undef,
    'Pod::Text::Overstrike' => undef,
    'Pod::Text::Termcap'    => undef,
    'Pod::Usage'            => undef,
    'Scalar::Util'          => undef,
    'Socket'                => undef,
    'Sys::Syslog'           => undef,
    'Sys::Syslog::Win32'    => undef,
    'TAP::Base'             => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Base'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Color' => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console::ParallelSession'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Console::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::File'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::File::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Formatter::Session'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Harness'          => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Harness::Env'     => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Object'           => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser'           => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Aggregator'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Grammar'  => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator' => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Array'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Process'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Iterator::Stream'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::IteratorFactory'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Multiplexer'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result'   => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Bailout'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Comment'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Plan'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Pragma'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Test'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Unknown'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::Version'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Result::YAML'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::ResultFactory'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler::Job'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Scheduler::Spinner'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::Source'   => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Executable'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::File'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Handle'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::Perl'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::SourceHandler::RawTAP'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::YAMLish::Reader'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'TAP::Parser::YAMLish::Writer'=> 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Term::ANSIColor'       => 'https://rt.cpan.org/Public/Dist/Display.html?Name=Term-ANSIColor',
    'Term::Cap'             => undef,
    'Test'                  => undef,
    'Test::Builder'         => 'http://github.com/Test-More/test-more/issues/',
    'Test::Builder::Module' => 'http://github.com/Test-More/test-more/issues/',
    'Test::Builder::Tester' => 'http://github.com/Test-More/test-more/issues/',
    'Test::Builder::Tester::Color'=> 'http://github.com/Test-More/test-more/issues/',
    'Test::Harness'         => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness',
    'Test::More'            => 'http://github.com/Test-More/test-more/issues/',
    'Test::Simple'          => 'http://github.com/Test-More/test-more/issues/',
    'Text::Balanced'        => undef,
    'Text::ParseWords'      => undef,
    'Text::Tabs'            => undef,
    'Text::Wrap'            => undef,
    'Tie::RefHash'          => undef,
    'Time::HiRes'           => undef,
    'Time::Local'           => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=Time-Local',
    'Time::Piece'           => undef,
    'Time::Seconds'         => undef,
    'Unicode::Collate'      => undef,
    'Unicode::Collate::CJK::Big5'=> undef,
    'Unicode::Collate::CJK::GB2312'=> undef,
    'Unicode::Collate::CJK::JISX0208'=> undef,
    'Unicode::Collate::CJK::Korean'=> undef,
    'Unicode::Collate::CJK::Pinyin'=> undef,
    'Unicode::Collate::CJK::Stroke'=> undef,
    'Unicode::Collate::CJK::Zhuyin'=> undef,
    'Unicode::Collate::Locale'=> undef,
    'Unicode::Normalize'    => undef,
    'Win32'                 => undef,
    'Win32API::File'        => undef,
    'Win32API::File::ExtUtils::Myconst2perl'=> undef,
    'autodie'               => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::exception'    => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::exception::system'=> 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::hints'        => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'autodie::skip'         => 'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie',
    'encoding'              => undef,
    'encoding::warnings'    => undef,
    'experimental'          => 'http://rt.cpan.org/Public/Dist/Display.html?Name=experimental',
    'inc::latest'           => 'https://github.com/dagolden/inc-latest/issues',
    'parent'                => undef,
    'perlfaq'               => 'https://github.com/perl-doc-cats/perlfaq/issues',
    'version'               => 'https://rt.cpan.org/Public/Dist/Display.html?Name=version',
    'version::regex'        => 'https://rt.cpan.org/Public/Dist/Display.html?Name=version',
    'version::vpp'          => 'https://rt.cpan.org/Public/Dist/Display.html?Name=version',
);

# Create aliases with trailing zeros for $] use

$released{'5.000'} = $released{5};
$version{'5.000'} = $version{5};

_create_aliases(\%delta);
_create_aliases(\%released);
_create_aliases(\%version);
_create_aliases(\%deprecated);

sub _create_aliases {
    my ($hash) = @_;

    for my $version (keys %$hash) {
        next unless $version >= 5.006;

        my $padded = sprintf "%0.6f", $version;

        # If the version in string form isn't the same as the numeric version,
        # alias it.
        if ($padded ne $version && $version == $padded) {
            $hash->{$padded} = $hash->{$version};
        }
    }
}

1;
__END__
                                                                                                                                                                                               usr/share/perl/5.20.2/Module/CoreList.pod                                                           0100644 0000000 0000000 00000020110 12744441327 016325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

Module::CoreList - what modules shipped with versions of perl

=head1 SYNOPSIS

 use Module::CoreList;

 print $Module::CoreList::version{5.00503}{CPAN}; # prints 1.48

 print Module::CoreList->first_release('File::Spec');         # prints 5.00405
 print Module::CoreList->first_release_by_date('File::Spec'); # prints 5.005
 print Module::CoreList->first_release('File::Spec', 0.82);   # prints 5.006001

 if (Module::CoreList::is_core('File::Spec')) {
   print "File::Spec is a core module\n";
 }

 print join ', ', Module::CoreList->find_modules(qr/Data/);
    # prints 'Data::Dumper'
 print join ', ',
            Module::CoreList->find_modules(qr/test::h.*::.*s/i, 5.008008);
    # prints 'Test::Harness::Assert, Test::Harness::Straps'

 print join ", ", @{ $Module::CoreList::families{5.005} };
    # prints "5.005, 5.00503, 5.00504"

=head1 DESCRIPTION

Module::CoreList provides information on which core and dual-life modules shipped
with each version of L<perl>.

It provides a number of mechanisms for querying this information.

There is a utility called L<corelist> provided with this module
which is a convenient way of querying from the command-line.

There is a functional programming API available for programmers to query
information.

Programmers may also query the contained hash structures to find relevant
information.

=head1 FUNCTIONS API

These are the functions that are available, they may either be called as functions or class methods:

  Module::CoreList::first_release('File::Spec'); # as a function

  Module::CoreList->first_release('File::Spec'); # class method

=over

=item C<first_release( MODULE )>

Behaviour since version 2.11

Requires a MODULE name as an argument, returns the perl version when that module first
appeared in core as ordered by perl version number or undef ( in scalar context )
or an empty list ( in list context ) if that module is not in core.

=item C<first_release_by_date( MODULE )>

Requires a MODULE name as an argument, returns the perl version when that module first
appeared in core as ordered by release date or undef ( in scalar context )
or an empty list ( in list context ) if that module is not in core.

=item C<find_modules( REGEX, [ LIST OF PERLS ] )>

Takes a regex as an argument, returns a list of modules that match the regex given.
If only a regex is provided applies to all modules in all perl versions. Optionally
you may provide a list of perl versions to limit the regex search.

=item C<find_version( PERL_VERSION )>

Takes a perl version as an argument. Returns that perl version if it exists or C<undef>
otherwise.

=item C<is_core( MODULE, [ MODULE_VERSION, [ PERL_VERSION ] ] )>

Available in version 2.99 and above.

Returns true if MODULE was bundled with the specified version of Perl.
You can optionally specify a minimum version of the module,
and can also specify a version of Perl.
If a version of Perl isn't specified,
C<is_core()> will use the numeric version of Perl that is running (ie C<$]>).

If you want to specify the version of Perl, but don't care about
the version of the module, pass C<undef> for the module version:

=item C<is_deprecated( MODULE, PERL_VERSION )>

Available in version 2.22 and above.

Returns true if MODULE is marked as deprecated in PERL_VERSION.  If PERL_VERSION is
omitted, it defaults to the current version of Perl.

=item C<deprecated_in( MODULE )>

Available in version 2.77 and above.

Returns the first PERL_VERSION where the MODULE was marked as deprecated. Returns C<undef>
if the MODULE has not been marked as deprecated.

=item C<removed_from( MODULE )>

Available in version 2.32 and above

Takes a module name as an argument, returns the first perl version where that module
was removed from core. Returns undef if the given module was never in core or remains
in core.

=item C<removed_from_by_date( MODULE )>

Available in version 2.32 and above

Takes a module name as an argument, returns the first perl version by release date where that module
was removed from core. Returns undef if the given module was never in core or remains
in core.

=item C<changes_between( PERL_VERSION, PERL_VERSION )>

Available in version 2.66 and above.

Given two perl versions, this returns a list of pairs describing the changes in
core module content between them.  The list is suitable for storing in a hash.
The keys are library names and the values are hashrefs.  Each hashref has an
entry for one or both of C<left> and C<right>, giving the versions of the
library in each of the left and right perl distributions.

For example, it might return these data (among others) for the difference
between 5.008000 and 5.008001:

  'Pod::ParseLink'  => { left => '1.05', right => '1.06' },
  'Pod::ParseUtils' => { left => '0.22', right => '0.3'  },
  'Pod::Perldoc'    => {                 right => '3.10' },
  'Pod::Perldoc::BaseTo' => {            right => undef  },

This shows us two libraries being updated and two being added, one of which has
an undefined version in the right-hand side version.

=back

=head1 DATA STRUCTURES

These are the hash data structures that are available:

=over

=item C<%Module::CoreList::version>

A hash of hashes that is keyed on perl version as indicated
in $].  The second level hash is module => version pairs.

Note, it is possible for the version of a module to be unspecified,
whereby the value is C<undef>, so use C<exists $version{$foo}{$bar}> if
that's what you're testing for.

Starting with 2.10, the special module name C<Unicode> refers to the version of
the Unicode Character Database bundled with Perl.

=item C<%Module::CoreList::delta>

Available in version 3.00 and above.

C<%Module::CoreList::version> is implemented via C<Module::CoreList::TieHashDelta>
using this hash of delta changes.

It is a hash of hashes that is keyed on perl version. Each keyed hash will have the
following keys:

  delta_from - a previous perl version that the changes are based on
  changed    - a hash of module/versions that have changed
  removed    - a hash of modules that have been removed

=item C<%Module::CoreList::released>

Keyed on perl version this contains ISO
formatted versions of the release dates, as gleaned from L<perlhist>.

=item C<%Module::CoreList::families>

New, in 1.96, a hash that
clusters known perl releases by their major versions.

=item C<%Module::CoreList::deprecated>

A hash of hashes keyed on perl version and on module name.
If a module is defined it indicates that that module is
deprecated in that perl version and is scheduled for removal
from core at some future point.

=item C<%Module::CoreList::upstream>

A hash that contains information on where patches should be directed
for each core module.

UPSTREAM indicates where patches should go. C<undef> implies
that this hasn't been discussed for the module at hand.
C<blead> indicates that the copy of the module in the blead
sources is to be considered canonical, C<cpan> means that the
module on CPAN is to be patched first. C<first-come> means
that blead can be patched freely if it is in sync with the
latest release on CPAN.

=item C<%Module::CoreList::bug_tracker>

A hash that contains information on the appropriate bug tracker
for each core module.

BUGS is an email or url to post bug reports.  For modules with
UPSTREAM => 'blead', use perl5-porters@perl.org.  rt.cpan.org
appears to automatically provide a URL for CPAN modules; any value
given here overrides the default:
http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName

=back

=head1 CAVEATS

Module::CoreList currently covers the 5.000, 5.001, 5.002, 5.003_07,
5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 and 5.7.3 releases of perl.

All stable releases of perl since 5.6.0 are covered.

All development releases of perl since 5.9.0 are covered.


=head1 HISTORY

Moved to Changes file.

=head1 AUTHOR

Richard Clamp E<lt>richardc@unixbeard.netE<gt>

Currently maintained by the perl 5 porters E<lt>perl5-porters@perl.orgE<gt>.

=head1 LICENSE

Copyright (C) 2002-2009 Richard Clamp.  All Rights Reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<corelist>, L<Module::Info>, L<perl>, L<http://perlpunks.de/corelist>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/perl/5.20.2/Module/Load/                                                                  0040755 0000000 0000000 00000000000 13077704254 014766  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Module/Load/Conditional.pm                                                    0100644 0000000 0000000 00000044117 12744441327 017572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Load::Conditional;

use strict;

use Module::Load qw/load autoload_remote/;
use Params::Check                       qw[check];
use Locale::Maketext::Simple Style  => 'gettext';

use Carp        ();
use File::Spec  ();
use FileHandle  ();
use version;

use Module::Metadata ();

use constant ON_VMS   => $^O eq 'VMS';
use constant ON_WIN32 => $^O eq 'MSWin32' ? 1 : 0;
use constant QUOTE    => do { ON_WIN32 ? q["] : q['] };

BEGIN {
    use vars        qw[ $VERSION @ISA $VERBOSE $CACHE @EXPORT_OK $DEPRECATED
                        $FIND_VERSION $ERROR $CHECK_INC_HASH];
    use Exporter;
    @ISA            = qw[Exporter];
    $VERSION        = '0.62';
    $VERBOSE        = 0;
    $DEPRECATED     = 0;
    $FIND_VERSION   = 1;
    $CHECK_INC_HASH = 0;
    @EXPORT_OK      = qw[check_install can_load requires];
}

=pod

=head1 NAME

Module::Load::Conditional - Looking up module information / loading at runtime

=head1 SYNOPSIS

    use Module::Load::Conditional qw[can_load check_install requires];


    my $use_list = {
            CPANPLUS        => 0.05,
            LWP             => 5.60,
            'Test::More'    => undef,
    };

    print can_load( modules => $use_list )
            ? 'all modules loaded successfully'
            : 'failed to load required modules';


    my $rv = check_install( module => 'LWP', version => 5.60 )
                or print 'LWP is not installed!';

    print 'LWP up to date' if $rv->{uptodate};
    print "LWP version is $rv->{version}\n";
    print "LWP is installed as file $rv->{file}\n";


    print "LWP requires the following modules to be installed:\n";
    print join "\n", requires('LWP');

    ### allow M::L::C to peek in your %INC rather than just
    ### scanning @INC
    $Module::Load::Conditional::CHECK_INC_HASH = 1;

    ### reset the 'can_load' cache
    undef $Module::Load::Conditional::CACHE;

    ### don't have Module::Load::Conditional issue warnings --
    ### default is '1'
    $Module::Load::Conditional::VERBOSE = 0;

    ### The last error that happened during a call to 'can_load'
    my $err = $Module::Load::Conditional::ERROR;


=head1 DESCRIPTION

Module::Load::Conditional provides simple ways to query and possibly load any of
the modules you have installed on your system during runtime.

It is able to load multiple modules at once or none at all if one of
them was not able to load. It also takes care of any error checking
and so forth.

=head1 Methods

=head2 $href = check_install( module => NAME [, version => VERSION, verbose => BOOL ] );

C<check_install> allows you to verify if a certain module is installed
or not. You may call it with the following arguments:

=over 4

=item module

The name of the module you wish to verify -- this is a required key

=item version

The version this module needs to be -- this is optional

=item verbose

Whether or not to be verbose about what it is doing -- it will default
to $Module::Load::Conditional::VERBOSE

=back

It will return undef if it was not able to find where the module was
installed, or a hash reference with the following keys if it was able
to find the file:

=over 4

=item file

Full path to the file that contains the module

=item dir

Directory, or more exact the C<@INC> entry, where the module was
loaded from.

=item version

The version number of the installed module - this will be C<undef> if
the module had no (or unparsable) version number, or if the variable
C<$Module::Load::Conditional::FIND_VERSION> was set to true.
(See the C<GLOBAL VARIABLES> section below for details)

=item uptodate

A boolean value indicating whether or not the module was found to be
at least the version you specified. If you did not specify a version,
uptodate will always be true if the module was found.
If no parsable version was found in the module, uptodate will also be
true, since C<check_install> had no way to verify clearly.

See also C<$Module::Load::Conditional::DEPRECATED>, which affects
the outcome of this value.

=back

=cut

### this checks if a certain module is installed already ###
### if it returns true, the module in question is already installed
### or we found the file, but couldn't open it, OR there was no version
### to be found in the module
### it will return 0 if the version in the module is LOWER then the one
### we are looking for, or if we couldn't find the desired module to begin with
### if the installed version is higher or equal to the one we want, it will return
### a hashref with he module name and version in it.. so 'true' as well.
sub check_install {
    my %hash = @_;

    my $tmpl = {
            version => { default    => '0.0'    },
            module  => { required   => 1        },
            verbose => { default    => $VERBOSE },
    };

    my $args;
    unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
        warn loc( q[A problem occurred checking arguments] ) if $VERBOSE;
        return;
    }

    my $file     = File::Spec->catfile( split /::/, $args->{module} ) . '.pm';
    my $file_inc = File::Spec::Unix->catfile(
                        split /::/, $args->{module}
                    ) . '.pm';

    ### where we store the return value ###
    my $href = {
            file        => undef,
            version     => undef,
            uptodate    => undef,
    };

    my $filename;

    ### check the inc hash if we're allowed to
    if( $CHECK_INC_HASH ) {
        $filename = $href->{'file'} =
            $INC{ $file_inc } if defined $INC{ $file_inc };

        ### find the version by inspecting the package
        if( defined $filename && $FIND_VERSION ) {
            no strict 'refs';
            $href->{version} = ${ "$args->{module}"."::VERSION" };
        }
    }

    ### we didn't find the filename yet by looking in %INC,
    ### so scan the dirs
    unless( $filename ) {

        DIR: for my $dir ( @INC ) {

            my $fh;

            if ( ref $dir ) {
                ### @INC hook -- we invoke it and get the filehandle back
                ### this is actually documented behaviour as of 5.8 ;)

                my $existed_in_inc = $INC{$file_inc};

                if (UNIVERSAL::isa($dir, 'CODE')) {
                    ($fh) = $dir->($dir, $file);

                } elsif (UNIVERSAL::isa($dir, 'ARRAY')) {
                    ($fh) = $dir->[0]->($dir, $file, @{$dir}{1..$#{$dir}})

                } elsif (UNIVERSAL::can($dir, 'INC')) {
                    ($fh) = $dir->INC($file);
                }

                if (!UNIVERSAL::isa($fh, 'GLOB')) {
                    warn loc(q[Cannot open file '%1': %2], $file, $!)
                            if $args->{verbose};
                    next;
                }

                $filename = $INC{$file_inc} || $file;

                delete $INC{$file_inc} if not $existed_in_inc;

            } else {
                $filename = File::Spec->catfile($dir, $file);
                next unless -e $filename;

                $fh = new FileHandle;
                if (!$fh->open($filename)) {
                    warn loc(q[Cannot open file '%1': %2], $file, $!)
                            if $args->{verbose};
                    next;
                }
            }

            ### store the directory we found the file in
            $href->{dir} = $dir;

            ### files need to be in unix format under vms,
            ### or they might be loaded twice
            $href->{file} = ON_VMS
                ? VMS::Filespec::unixify( $filename )
                : $filename;

            ### if we don't need the version, we're done
            last DIR unless $FIND_VERSION;

            ### otherwise, the user wants us to find the version from files
            my $mod_info = Module::Metadata->new_from_handle( $fh, $filename );
            my $ver      = $mod_info->version( $args->{module} );

            if( defined $ver ) {
                $href->{version} = $ver;

                last DIR;
            }
        }
    }

    ### if we couldn't find the file, return undef ###
    return unless defined $href->{file};

    ### only complain if we're expected to find a version higher than 0.0 anyway
    if( $FIND_VERSION and not defined $href->{version} ) {
        {   ### don't warn about the 'not numeric' stuff ###
            local $^W;

            ### if we got here, we didn't find the version
            warn loc(q[Could not check version on '%1'], $args->{module} )
                    if $args->{verbose} and $args->{version} > 0;
        }
        $href->{uptodate} = 1;

    } else {
        ### don't warn about the 'not numeric' stuff ###
        local $^W;

        ### use qv(), as it will deal with developer release number
        ### ie ones containing _ as well. This addresses bug report
        ### #29348: Version compare logic doesn't handle alphas?
        ###
        ### Update from JPeacock: apparently qv() and version->new
        ### are different things, and we *must* use version->new
        ### here, or things like #30056 might start happening

        ### We have to wrap this in an eval as version-0.82 raises
        ### exceptions and not warnings now *sigh*

        eval {

          $href->{uptodate} =
            version->new( $args->{version} ) <= version->new( $href->{version} )
                ? 1
                : 0;

        };
    }

    if ( $DEPRECATED and "$]" >= 5.011 ) {
        require Module::CoreList;
        require Config;

        $href->{uptodate} = 0 if
           exists $Module::CoreList::version{ 0+$] }{ $args->{module} } and
           Module::CoreList::is_deprecated( $args->{module} ) and
           $Config::Config{privlibexp} eq $href->{dir};
    }

    return $href;
}

=head2 $bool = can_load( modules => { NAME => VERSION [,NAME => VERSION] }, [verbose => BOOL, nocache => BOOL, autoload => BOOL] )

C<can_load> will take a list of modules, optionally with version
numbers and determine if it is able to load them. If it can load *ALL*
of them, it will. If one or more are unloadable, none will be loaded.

This is particularly useful if you have More Than One Way (tm) to
solve a problem in a program, and only wish to continue down a path
if all modules could be loaded, and not load them if they couldn't.

This function uses the C<load> function or the C<autoload_remote> function
from Module::Load under the hood.

C<can_load> takes the following arguments:

=over 4

=item modules

This is a hashref of module/version pairs. The version indicates the
minimum version to load. If no version is provided, any version is
assumed to be good enough.

=item verbose

This controls whether warnings should be printed if a module failed
to load.
The default is to use the value of $Module::Load::Conditional::VERBOSE.

=item nocache

C<can_load> keeps its results in a cache, so it will not load the
same module twice, nor will it attempt to load a module that has
already failed to load before. By default, C<can_load> will check its
cache, but you can override that by setting C<nocache> to true.

=item autoload

This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.

See the C<autoload> function and the C<autoload_remote> function from L<Module::Load> for details.

=cut

sub can_load {
    my %hash = @_;

    my $tmpl = {
        modules     => { default => {}, strict_type => 1 },
        verbose     => { default => $VERBOSE },
        nocache     => { default => 0 },
        autoload    => { default => 0 },
    };

    my $args;

    unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
        $ERROR = loc(q[Problem validating arguments!]);
        warn $ERROR if $VERBOSE;
        return;
    }

    ### layout of $CACHE:
    ### $CACHE = {
    ###     $ module => {
    ###             usable  => BOOL,
    ###             version => \d,
    ###             file    => /path/to/file,
    ###     },
    ### };

    $CACHE ||= {}; # in case it was undef'd

    my $error;
    BLOCK: {
        my $href = $args->{modules};

        my @load;
        for my $mod ( keys %$href ) {

            next if $CACHE->{$mod}->{usable} && !$args->{nocache};

            ### else, check if the hash key is defined already,
            ### meaning $mod => 0,
            ### indicating UNSUCCESSFUL prior attempt of usage

            ### use qv(), as it will deal with developer release number
            ### ie ones containing _ as well. This addresses bug report
            ### #29348: Version compare logic doesn't handle alphas?
            ###
            ### Update from JPeacock: apparently qv() and version->new
            ### are different things, and we *must* use version->new
            ### here, or things like #30056 might start happening
            if (    !$args->{nocache}
                    && defined $CACHE->{$mod}->{usable}
                    && (version->new( $CACHE->{$mod}->{version}||0 )
                        >= version->new( $href->{$mod} ) )
            ) {
                $error = loc( q[Already tried to use '%1', which was unsuccessful], $mod);
                last BLOCK;
            }

            my $mod_data = check_install(
                                    module  => $mod,
                                    version => $href->{$mod}
                                );

            if( !$mod_data or !defined $mod_data->{file} ) {
                $error = loc(q[Could not find or check module '%1'], $mod);
                $CACHE->{$mod}->{usable} = 0;
                last BLOCK;
            }

            map {
                $CACHE->{$mod}->{$_} = $mod_data->{$_}
            } qw[version file uptodate];

            push @load, $mod;
        }

        for my $mod ( @load ) {

            if ( $CACHE->{$mod}->{uptodate} ) {

                if ( $args->{autoload} ) {
                    my $who = (caller())[0];
                    eval { autoload_remote $who, $mod };
                } else {
                    eval { load $mod };
                }

                ### in case anything goes wrong, log the error, the fact
                ### we tried to use this module and return 0;
                if( $@ ) {
                    $error = $@;
                    $CACHE->{$mod}->{usable} = 0;
                    last BLOCK;
                } else {
                    $CACHE->{$mod}->{usable} = 1;
                }

            ### module not found in @INC, store the result in
            ### $CACHE and return 0
            } else {

                $error = loc(q[Module '%1' is not uptodate!], $mod);
                $CACHE->{$mod}->{usable} = 0;
                last BLOCK;
            }
        }

    } # BLOCK

    if( defined $error ) {
        $ERROR = $error;
        Carp::carp( loc(q|%1 [THIS MAY BE A PROBLEM!]|,$error) ) if $args->{verbose};
        return;
    } else {
        return 1;
    }
}

=back

=head2 @list = requires( MODULE );

C<requires> can tell you what other modules a particular module
requires. This is particularly useful when you're intending to write
a module for public release and are listing its prerequisites.

C<requires> takes but one argument: the name of a module.
It will then first check if it can actually load this module, and
return undef if it can't.
Otherwise, it will return a list of modules and pragmas that would
have been loaded on the module's behalf.

Note: The list C<require> returns has originated from your current
perl and your current install.

=cut

sub requires {
    my $who = shift;

    unless( check_install( module => $who ) ) {
        warn loc(q[You do not have module '%1' installed], $who) if $VERBOSE;
        return undef;
    }

    my $lib = join " ", map { qq["-I$_"] } @INC;
    my $oneliner = 'print(join(qq[\n],map{qq[BONG=$_]}keys(%INC)),qq[\n])';
    my $cmd = join '', qq["$^X" $lib -M$who -e], QUOTE, $oneliner, QUOTE;

    return  sort
                grep { !/^$who$/  }
                map  { chomp; s|/|::|g; $_ }
                grep { s|\.pm$||i; }
                map  { s!^BONG\=!!; $_ }
                grep { m!^BONG\=! }
            `$cmd`;
}

1;

__END__

=head1 Global Variables

The behaviour of Module::Load::Conditional can be altered by changing the
following global variables:

=head2 $Module::Load::Conditional::VERBOSE

This controls whether Module::Load::Conditional will issue warnings and
explanations as to why certain things may have failed. If you set it
to 0, Module::Load::Conditional will not output any warnings.
The default is 0;

=head2 $Module::Load::Conditional::FIND_VERSION

This controls whether Module::Load::Conditional will try to parse
(and eval) the version from the module you're trying to load.

If you don't wish to do this, set this variable to C<false>. Understand
then that version comparisons are not possible, and Module::Load::Conditional
can not tell you what module version you have installed.
This may be desirable from a security or performance point of view.
Note that C<$FIND_VERSION> code runs safely under C<taint mode>.

The default is 1;

=head2 $Module::Load::Conditional::CHECK_INC_HASH

This controls whether C<Module::Load::Conditional> checks your
C<%INC> hash to see if a module is available. By default, only
C<@INC> is scanned to see if a module is physically on your
filesystem, or available via an C<@INC-hook>. Setting this variable
to C<true> will trust any entries in C<%INC> and return them for
you.

The default is 0;

=head2 $Module::Load::Conditional::CACHE

This holds the cache of the C<can_load> function. If you explicitly
want to remove the current cache, you can set this variable to
C<undef>

=head2 $Module::Load::Conditional::ERROR

This holds a string of the last error that happened during a call to
C<can_load>. It is useful to inspect this when C<can_load> returns
C<undef>.

=head2 $Module::Load::Conditional::DEPRECATED

This controls whether C<Module::Load::Conditional> checks if
a dual-life core module has been deprecated. If this is set to
true C<check_install> will return false to C<uptodate>, if
a dual-life module is found to be loaded from C<$Config{privlibexp}>

The default is 0;

=head1 See Also

C<Module::Load>

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-load-conditional@rt.cpan.orgE<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Module/Load.pm                                                                0100644 0000000 0000000 00000020505 12744441327 015322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Load;

$VERSION = '0.32';

use strict;
use warnings;
use File::Spec ();

sub import {
    my $who = _who();
    my $h; shift;

    {   no strict 'refs';

        @_ or (
            *{"${who}::load"} = \&load, # compat to prev version
            *{"${who}::autoload"} = \&autoload,
            return
        );

        map { $h->{$_} = () if defined $_ } @_;

        (exists $h->{none} or exists $h->{''})
            and shift, last;

        ((exists $h->{autoload} and shift,1) or (exists $h->{all} and shift))
            and *{"${who}::autoload"} = \&autoload;

        ((exists $h->{load} and shift,1) or exists $h->{all})
            and *{"${who}::load"} = \&load;

        ((exists $h->{load_remote} and shift,1) or exists $h->{all})
            and *{"${who}::load_remote"} = \&load_remote;

        ((exists $h->{autoload_remote} and shift,1) or exists $h->{all})
            and *{"${who}::autoload_remote"} = \&autoload_remote;

    }

}

sub load(*;@){
    goto &_load;
}

sub autoload(*;@){
    unshift @_, 'autoimport';
    goto &_load;
}

sub load_remote($$;@){
    my ($dst, $src, @exp) = @_;

    eval "package $dst;Module::Load::load('$src', qw/@exp/);";
    $@ && die "$@";
}

sub autoload_remote($$;@){
    my ($dst, $src, @exp) = @_;

    eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";
    $@ && die "$@";
}

sub _load{
    my $autoimport = $_[0] eq 'autoimport' and shift;
    my $mod = shift or return;
    my $who = _who();

    if( _is_file( $mod ) ) {
        require $mod;
    } else {
        LOAD: {
            my $err;
            for my $flag ( qw[1 0] ) {
                my $file = _to_file( $mod, $flag);
                eval { require $file };
                $@ ? $err .= $@ : last LOAD;
            }
            die $err if $err;
        }
    }

    ### This addresses #41883: Module::Load cannot import
    ### non-Exporter module. ->import() routines weren't
    ### properly called when load() was used.

    {   no strict 'refs';
        my $import;

    ((@_ or $autoimport) and (
        $import = $mod->can('import')
        ) and (
        unshift(@_, $mod),
        goto &$import,
        return
        )
    );
    }

}

sub _to_file{
    local $_    = shift;
    my $pm      = shift || '';

    ## trailing blanks ignored by default. [rt #69886]
    my @parts = split /::|'/, $_, -1;
    ## make sure that we can't hop out of @INC
    shift @parts if @parts && !$parts[0];

    ### because of [perl #19213], see caveats ###
    my $file = $^O eq 'MSWin32'
                    ? join "/", @parts
                    : File::Spec->catfile( @parts );

    $file   .= '.pm' if $pm;

    ### on perl's before 5.10 (5.9.5@31746) if you require
    ### a file in VMS format, it's stored in %INC in VMS
    ### format. Therefor, better unixify it first
    ### Patch in reply to John Malmbergs patch (as mentioned
    ### above) on p5p Tue 21 Aug 2007 04:55:07
    $file = VMS::Filespec::unixify($file) if $^O eq 'VMS';

    return $file;
}

sub _who { (caller(1))[0] }

sub _is_file {
    local $_ = shift;
    return  /^\./               ? 1 :
            /[^\w:']/           ? 1 :
            undef
    #' silly bbedit..
}


1;

__END__

=pod

=head1 NAME

Module::Load - runtime require of both modules and files

=head1 SYNOPSIS

  use Module::Load;

  my $module = 'Data::Dumper';

  load Data::Dumper;     # loads that module, but not import any functions
                         # -> cannot use 'Dumper' function

  load 'Data::Dumper';   # ditto
  load $module           # tritto

  autoload Data::Dumper; # loads that module and imports the default functions
                         # -> can use 'Dumper' function

  my $script = 'some/script.pl'
  load $script;
  load 'some/script.pl';  # use quotes because of punctuations

  load thing;             # try 'thing' first, then 'thing.pm'

  load CGI, ':all';       # like 'use CGI qw[:standard]'

=head1 DESCRIPTION

C<Module::Load> eliminates the need to know whether you are trying
to require either a file or a module.

If you consult C<perldoc -f require> you will see that C<require> will
behave differently when given a bareword or a string.

In the case of a string, C<require> assumes you are wanting to load a
file. But in the case of a bareword, it assumes you mean a module.

This gives nasty overhead when you are trying to dynamically require
modules at runtime, since you will need to change the module notation
(C<Acme::Comment>) to a file notation fitting the particular platform
you are on.

C<Module::Load> eliminates the need for this overhead and will
just DWYM.

=head2 Difference between C<load> and C<autoload>

C<Module::Load> imports the two functions - C<load> and C<autoload>

C<autoload> imports the default functions automatically,
but C<load> do not import any functions.

C<autoload> is usable under C<BEGIN{};>.

Both the functions can import the functions that are specified.

Following codes are same.

  load File::Spec::Functions, qw/splitpath/;

  autoload File::Spec::Functions, qw/splitpath/;

=head1 FUNCTIONS

=over 4

=item load

Loads a specified module.

See L</Rules> for detailed loading rule.

=item autoload

Loads a specified module and imports the default functions.

Except importing the functions, 'autoload' is same as 'load'.

=item load_remote

Loads a specified module to the specified package.

  use Module::Load 'load_remote';

  my $pkg = 'Other::Package';

  load_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                    # but do not import 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'load_remote' is same as 'load'.

=item autoload_remote

Loads a specified module and imports the default functions to the specified package.

  use Module::Load 'autoload_remote';

  my $pkg = 'Other::Package';

  autoload_remote $pkg, 'Data::Dumper'; # load a module to 'Other::Package'
                                        # and imports 'Dumper' function

A module for loading must be quoted.

Except specifing the package and quoting module name,
'autoload_remote' is same as 'load_remote'.

=back

=head1 Rules

All functions have the following rules to decide what it thinks
you want:

=over 4

=item *

If the argument has any characters in it other than those matching
C<\w>, C<:> or C<'>, it must be a file

=item *

If the argument matches only C<[\w:']>, it must be a module

=item *

If the argument matches only C<\w>, it could either be a module or a
file. We will try to find C<file.pm> first in C<@INC> and if that
fails, we will try to find C<file> in @INC.  If both fail, we die with
the respective error messages.

=back

=head1 IMPORTS THE FUNCTIONS

'load' and 'autoload' are imported by default, but 'load_remote' and
'autoload_remote' are not imported.

To use 'load_remote' or 'autoload_remote', specify at 'use'.

=over 4

=item "load","autoload","load_remote","autoload_remote"

Imports the selected functions.

  # imports 'load' and 'autoload' (default)
  use Module::Load;

  # imports 'autoload' only
  use Module::Load 'autoload';

  # imports 'autoload' and 'autoload_remote', but don't import 'load';
  use Module::Load qw/autoload autoload_remote/;

=item 'all'

Imports all the functions.

  use Module::Load 'all'; # imports load, autoload, load_remote, autoload_remote

=item '','none',undef

Not import any functions (C<load> and C<autoload> are not imported).

  use Module::Load '';

  use Module::Load 'none';

  use Module::Load undef;

=back

=head1 Caveats

Because of a bug in perl (#19213), at least in version 5.6.1, we have
to hardcode the path separator for a require on Win32 to be C</>, like
on Unix rather than the Win32 C<\>. Otherwise perl will not read its
own %INC accurately double load files if they are required again, or
in the worst case, core dump.

C<Module::Load> cannot do implicit imports, only explicit imports.
(in other words, you always have to specify explicitly what you wish
to import from a module, even if the functions are in that modules'
C<@EXPORT>)

=head1 ACKNOWLEDGEMENTS

Thanks to Jonas B. Nielsen for making explicit imports work.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-load@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                           usr/share/perl/5.20.2/Module/Loaded.pm                                                              0100644 0000000 0000000 00000006424 12744441327 015637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Module::Loaded;

use strict;
use Carp qw[carp];

BEGIN { use base 'Exporter';
        use vars qw[@EXPORT $VERSION];

        $VERSION = '0.08';
        @EXPORT  = qw[mark_as_loaded mark_as_unloaded is_loaded];
}

=head1 NAME

Module::Loaded - mark modules as loaded or unloaded

=head1 SYNOPSIS

    use Module::Loaded;

    $bool = mark_as_loaded('Foo');   # Foo.pm is now marked as loaded
    $loc  = is_loaded('Foo');        # location of Foo.pm set to the
                                     # loaders location
    eval "require 'Foo'";            # is now a no-op

    $bool = mark_as_unloaded('Foo'); # Foo.pm no longer marked as loaded
    eval "require 'Foo'";            # Will try to find Foo.pm in @INC

=head1 DESCRIPTION

When testing applications, often you find yourself needing to provide
functionality in your test environment that would usually be provided
by external modules. Rather than munging the C<%INC> by hand to mark
these external modules as loaded, so they are not attempted to be loaded
by perl, this module offers you a very simple way to mark modules as
loaded and/or unloaded.

=head1 FUNCTIONS

=head2 $bool = mark_as_loaded( PACKAGE );

Marks the package as loaded to perl. C<PACKAGE> can be a bareword or
string.

If the module is already loaded, C<mark_as_loaded> will carp about
this and tell you from where the C<PACKAGE> has been loaded already.

=cut

sub mark_as_loaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;
    my $who     = [caller]->[1];

    my $where   = is_loaded( $pm );
    if ( defined $where ) {
        carp "'$pm' already marked as loaded ('$where')";

    } else {
        $INC{$file} = $who;
    }

    return 1;
}

=head2 $bool = mark_as_unloaded( PACKAGE );

Marks the package as unloaded to perl, which is the exact opposite
of C<mark_as_loaded>. C<PACKAGE> can be a bareword or string.

If the module is already unloaded, C<mark_as_unloaded> will carp about
this and tell you the C<PACKAGE> has been unloaded already.

=cut

sub mark_as_unloaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;

    unless( defined is_loaded( $pm ) ) {
        carp "'$pm' already marked as unloaded";

    } else {
        delete $INC{ $file };
    }

    return 1;
}

=head2 $loc = is_loaded( PACKAGE );

C<is_loaded> tells you if C<PACKAGE> has been marked as loaded yet.
C<PACKAGE> can be a bareword or string.

It returns falls if C<PACKAGE> has not been loaded yet and the location
from where it is said to be loaded on success.

=cut

sub is_loaded (*) {
    my $pm      = shift;
    my $file    = __PACKAGE__->_pm_to_file( $pm ) or return;

    return $INC{$file} if exists $INC{$file};

    return;
}


sub _pm_to_file {
    my $pkg = shift;
    my $pm  = shift or return;

    my $file = join '/', split '::', $pm;
    $file .= '.pm';

    return $file;
}

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-module-loaded@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:

1;
                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Module/Metadata.pm                                                            0100644 0000000 0000000 00000070000 12744441327 016156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
# vim:ts=8:sw=2:et:sta:sts=2
package Module::Metadata;

# Adapted from Perl-licensed code originally distributed with
# Module-Build by Ken Williams

# This module provides routines to gather information about
# perl modules (assuming this may be expanded in the distant
# parrot future to look at other types of modules).

use strict;
use warnings;

our $VERSION = '1.000019';
$VERSION = eval $VERSION;

use Carp qw/croak/;
use File::Spec;
use IO::File;
use version 0.87;
BEGIN {
  if ($INC{'Log/Contextual.pm'}) {
    Log::Contextual->import('log_info');
  } else {
    *log_info = sub (&) { warn $_[0]->() };
  }
}
use File::Find qw(find);

my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal

my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
  [a-zA-Z_]                     # the first word CANNOT start with a digit
    (?:
      [\w']?                    # can contain letters, digits, _, or ticks
      \w                        # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
  \w                           # the 2nd+ word CAN start with digits
    (?:
      [\w']?                   # and can contain letters or ticks
      \w                       # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_NAME_REGEXP = qr{ # match a package name
  (?: :: )?               # a pkg name can start with aristotle
  $PKG_FIRST_WORD_REGEXP  # a package word
  (?:
    (?: :: )+             ### aristotle (allow one or many times)
    $PKG_ADDL_WORD_REGEXP ### a package word
  )*                      # ^ zero, one or many times
  (?:
    ::                    # allow trailing aristotle
  )?
}x;

my $PKG_REGEXP  = qr{   # match a package declaration
  ^[\s\{;]*             # intro chars on a line
  package               # the word 'package'
  \s+                   # whitespace
  ($PKG_NAME_REGEXP)    # a package name
  \s*                   # optional whitespace
  ($V_NUM_REGEXP)?        # optional version number
  \s*                   # optional whitesapce
  [;\{]                 # semicolon line terminator or block start (since 5.16)
}x;

my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
  ([\$*])         # sigil - $ or *
  (
    (             # optional leading package name
      (?:::|\')?  # possibly starting like just :: (  la $::VERSION)
      (?:\w+(?:::|\'))*  # Foo::Bar:: ...
    )?
    VERSION
  )\b
}x;

my $VERS_REGEXP = qr{ # match a VERSION definition
  (?:
    \(\s*$VARNAME_REGEXP\s*\) # with parens
  |
    $VARNAME_REGEXP           # without parens
  )
  \s*
  =[^=~]  # = but not ==, nor =~
}x;

sub new_from_file {
  my $class    = shift;
  my $filename = File::Spec->rel2abs( shift );

  return undef unless defined( $filename ) && -f $filename;
  return $class->_init(undef, $filename, @_);
}

sub new_from_handle {
  my $class    = shift;
  my $handle   = shift;
  my $filename = shift;
  return undef unless defined($handle) && defined($filename);
  $filename = File::Spec->rel2abs( $filename );

  return $class->_init(undef, $filename, @_, handle => $handle);

}


sub new_from_module {
  my $class   = shift;
  my $module  = shift;
  my %props   = @_;

  $props{inc} ||= \@INC;
  my $filename = $class->find_module_by_name( $module, $props{inc} );
  return undef unless defined( $filename ) && -f $filename;
  return $class->_init($module, $filename, %props);
}

{

  my $compare_versions = sub {
    my ($v1, $op, $v2) = @_;
    $v1 = version->new($v1)
      unless UNIVERSAL::isa($v1,'version');

    my $eval_str = "\$v1 $op \$v2";
    my $result   = eval $eval_str;
    log_info { "error comparing versions: '$eval_str' $@" } if $@;

    return $result;
  };

  my $normalize_version = sub {
    my ($version) = @_;
    if ( $version =~ /[=<>!,]/ ) { # logic, not just version
      # take as is without modification
    }
    elsif ( ref $version eq 'version' ) { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  };

  # separate out some of the conflict resolution logic

  my $resolve_module_versions = sub {
    my $packages = shift;

    my( $file, $version );
    my $err = '';
      foreach my $p ( @$packages ) {
        if ( defined( $p->{version} ) ) {
  	if ( defined( $version ) ) {
   	  if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
  	    $err .= "  $p->{file} ($p->{version})\n";
  	  } else {
  	    # same version declared multiple times, ignore
  	  }
  	} else {
  	  $file    = $p->{file};
  	  $version = $p->{version};
  	}
        }
        $file ||= $p->{file} if defined( $p->{file} );
      }

    if ( $err ) {
      $err = "  $file ($version)\n" . $err;
    }

    my %result = (
      file    => $file,
      version => $version,
      err     => $err
    );

    return \%result;
  };

  sub provides {
    my $class = shift;

    croak "provides() requires key/value pairs \n" if @_ % 2;
    my %args = @_;

    croak "provides() takes only one of 'dir' or 'files'\n"
      if $args{dir} && $args{files};

    croak "provides() requires a 'version' argument"
      unless defined $args{version};

    croak "provides() does not support version '$args{version}' metadata"
        unless grep { $args{version} eq $_ } qw/1.4 2/;

    $args{prefix} = 'lib' unless defined $args{prefix};

    my $p;
    if ( $args{dir} ) {
      $p = $class->package_versions_from_directory($args{dir});
    }
    else {
      croak "provides() requires 'files' to be an array reference\n"
        unless ref $args{files} eq 'ARRAY';
      $p = $class->package_versions_from_directory($args{files});
    }

    # Now, fix up files with prefix
    if ( length $args{prefix} ) { # check in case disabled with q{}
      $args{prefix} =~ s{/$}{};
      for my $v ( values %$p ) {
        $v->{file} = "$args{prefix}/$v->{file}";
      }
    }

    return $p
  }

  sub package_versions_from_directory {
    my ( $class, $dir, $files ) = @_;

    my @files;

    if ( $files ) {
      @files = @$files;
    } else {
      find( {
        wanted => sub {
          push @files, $_ if -f $_ && /\.pm$/;
        },
        no_chdir => 1,
      }, $dir );
    }

    # First, we enumerate all packages & versions,
    # separating into primary & alternative candidates
    my( %prime, %alt );
    foreach my $file (@files) {
      my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
      my @path = split( /\//, $mapped_filename );
      (my $prime_package = join( '::', @path )) =~ s/\.pm$//;

      my $pm_info = $class->new_from_file( $file );

      foreach my $package ( $pm_info->packages_inside ) {
        next if $package eq 'main';  # main can appear numerous times, ignore
        next if $package eq 'DB';    # special debugging package, ignore
        next if grep /^_/, split( /::/, $package ); # private package, ignore

        my $version = $pm_info->version( $package );

        $prime_package = $package if lc($prime_package) eq lc($package);
        if ( $package eq $prime_package ) {
          if ( exists( $prime{$package} ) ) {
            croak "Unexpected conflict in '$package'; multiple versions found.\n";
          } else {
            $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
            $prime{$package}{file} = $mapped_filename;
            $prime{$package}{version} = $version if defined( $version );
          }
        } else {
          push( @{$alt{$package}}, {
                                    file    => $mapped_filename,
                                    version => $version,
                                   } );
        }
      }
    }

    # Then we iterate over all the packages found above, identifying conflicts
    # and selecting the "best" candidate for recording the file & version
    # for each package.
    foreach my $package ( keys( %alt ) ) {
      my $result = $resolve_module_versions->( $alt{$package} );

      if ( exists( $prime{$package} ) ) { # primary package selected

        if ( $result->{err} ) {
  	# Use the selected primary package, but there are conflicting
  	# errors among multiple alternative packages that need to be
  	# reported
          log_info {
  	    "Found conflicting versions for package '$package'\n" .
  	    "  $prime{$package}{file} ($prime{$package}{version})\n" .
  	    $result->{err}
          };

        } elsif ( defined( $result->{version} ) ) {
  	# There is a primary package selected, and exactly one
  	# alternative package

  	if ( exists( $prime{$package}{version} ) &&
  	     defined( $prime{$package}{version} ) ) {
  	  # Unless the version of the primary package agrees with the
  	  # version of the alternative package, report a conflict
  	  if ( $compare_versions->(
                 $prime{$package}{version}, '!=', $result->{version}
               )
             ) {

            log_info {
              "Found conflicting versions for package '$package'\n" .
  	      "  $prime{$package}{file} ($prime{$package}{version})\n" .
  	      "  $result->{file} ($result->{version})\n"
            };
  	  }

  	} else {
  	  # The prime package selected has no version so, we choose to
  	  # use any alternative package that does have a version
  	  $prime{$package}{file}    = $result->{file};
  	  $prime{$package}{version} = $result->{version};
  	}

        } else {
  	# no alt package found with a version, but we have a prime
  	# package so we use it whether it has a version or not
        }

      } else { # No primary package was selected, use the best alternative

        if ( $result->{err} ) {
          log_info {
            "Found conflicting versions for package '$package'\n" .
  	    $result->{err}
          };
        }

        # Despite possible conflicting versions, we choose to record
        # something rather than nothing
        $prime{$package}{file}    = $result->{file};
        $prime{$package}{version} = $result->{version}
  	  if defined( $result->{version} );
      }
    }

    # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
    # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
    for (grep defined $_->{version}, values %prime) {
      $_->{version} = $normalize_version->( $_->{version} );
    }

    return \%prime;
  }
}


sub _init {
  my $class    = shift;
  my $module   = shift;
  my $filename = shift;
  my %props = @_;

  my $handle = delete $props{handle};
  my( %valid_props, @valid_props );
  @valid_props = qw( collect_pod inc );
  @valid_props{@valid_props} = delete( @props{@valid_props} );
  warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );

  my %data = (
    module       => $module,
    filename     => $filename,
    version      => undef,
    packages     => [],
    versions     => {},
    pod          => {},
    pod_headings => [],
    collect_pod  => 0,

    %valid_props,
  );

  my $self = bless(\%data, $class);

  if ( $handle ) {
    $self->_parse_fh($handle);
  }
  else {
    $self->_parse_file();
  }

  unless($self->{module} and length($self->{module})) {
    my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
    if($f =~ /\.pm$/) {
      $f =~ s/\..+$//;
      my @candidates = grep /$f$/, @{$self->{packages}};
      $self->{module} = shift(@candidates); # punt
    }
    else {
      if(grep /main/, @{$self->{packages}}) {
        $self->{module} = 'main';
      }
      else {
        $self->{module} = $self->{packages}[0] || '';
      }
    }
  }

  $self->{version} = $self->{versions}{$self->{module}}
      if defined( $self->{module} );

  return $self;
}

# class method
sub _do_find_module {
  my $class   = shift;
  my $module  = shift || croak 'find_module_by_name() requires a package name';
  my $dirs    = shift || \@INC;

  my $file = File::Spec->catfile(split( /::/, $module));
  foreach my $dir ( @$dirs ) {
    my $testfile = File::Spec->catfile($dir, $file);
    return [ File::Spec->rel2abs( $testfile ), $dir ]
	if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
    return [ File::Spec->rel2abs( "$testfile.pm" ), $dir ]
	if -e "$testfile.pm";
  }
  return;
}

# class method
sub find_module_by_name {
  my $found = shift()->_do_find_module(@_) or return;
  return $found->[0];
}

# class method
sub find_module_dir_by_name {
  my $found = shift()->_do_find_module(@_) or return;
  return $found->[1];
}


# given a line of perl code, attempt to parse it if it looks like a
# $VERSION assignment, returning sigil, full name, & package name
sub _parse_version_expression {
  my $self = shift;
  my $line = shift;

  my( $sig, $var, $pkg );
  if ( $line =~ /$VERS_REGEXP/o ) {
    ( $sig, $var, $pkg ) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
    if ( $pkg ) {
      $pkg = ($pkg eq '::') ? 'main' : $pkg;
      $pkg =~ s/::$//;
    }
  }

  return ( $sig, $var, $pkg );
}

sub _parse_file {
  my $self = shift;

  my $filename = $self->{filename};
  my $fh = IO::File->new( $filename )
    or croak( "Can't open '$filename': $!" );

  $self->_handle_bom($fh, $filename);

  $self->_parse_fh($fh);
}

# Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
# If there's one, then skip it and set the :encoding layer appropriately.
sub _handle_bom {
  my ($self, $fh, $filename) = @_;

  my $pos = $fh->getpos;
  return unless defined $pos;

  my $buf = ' ' x 2;
  my $count = $fh->read( $buf, length $buf );
  return unless defined $count and $count >= 2;

  my $encoding;
  if ( $buf eq "\x{FE}\x{FF}" ) {
    $encoding = 'UTF-16BE';
  } elsif ( $buf eq "\x{FF}\x{FE}" ) {
    $encoding = 'UTF-16LE';
  } elsif ( $buf eq "\x{EF}\x{BB}" ) {
    $buf = ' ';
    $count = $fh->read( $buf, length $buf );
    if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
      $encoding = 'UTF-8';
    }
  }

  if ( defined $encoding ) {
    if ( "$]" >= 5.008 ) {
      # $fh->binmode requires perl 5.10
      binmode( $fh, ":encoding($encoding)" );
    }
  } else {
    $fh->setpos($pos)
      or croak( sprintf "Can't reset position to the top of '$filename'" );
  }

  return $encoding;
}

sub _parse_fh {
  my ($self, $fh) = @_;

  my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
  my( @pkgs, %vers, %pod, @pod );
  my $pkg = 'main';
  my $pod_sect = '';
  my $pod_data = '';
  my $in_end = 0;

  while (defined( my $line = <$fh> )) {
    my $line_num = $.;

    chomp( $line );

    # From toke.c : any line that begins by "=X", where X is an alphabetic
    # character, introduces a POD segment.
    my $is_cut;
    if ( $line =~ /^=([a-zA-Z].*)/ ) {
      my $cmd = $1;
      # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
      # character (which includes the newline, but here we chomped it away).
      $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
      $in_pod = !$is_cut;
    }

    if ( $in_pod ) {

      if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
	push( @pod, $1 );
	if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
	$pod_sect = $1;

      } elsif ( $self->{collect_pod} ) {
	$pod_data .= "$line\n";

      }

    } elsif ( $is_cut ) {

      if ( $self->{collect_pod} && length( $pod_data ) ) {
        $pod{$pod_sect} = $pod_data;
        $pod_data = '';
      }
      $pod_sect = '';

    } else {

      # Skip after __END__
      next if $in_end;

      # Skip comments in code
      next if $line =~ /^\s*#/;

      # Would be nice if we could also check $in_string or something too
      if ($line eq '__END__') {
        $in_end++;
        next;
      }
      last if $line eq '__DATA__';

      # parse $line to see if it's a $VERSION declaration
      my( $vers_sig, $vers_fullname, $vers_pkg ) =
          ($line =~ /VERSION/)
              ? $self->_parse_version_expression( $line )
              : ();

      if ( $line =~ /$PKG_REGEXP/o ) {
        $pkg = $1;
        push( @pkgs, $pkg ) unless grep( $pkg eq $_, @pkgs );
        $vers{$pkg} = $2 unless exists( $vers{$pkg} );
        $need_vers = defined $2 ? 0 : 1;

      # VERSION defined with full package spec, i.e. $Module::VERSION
      } elsif ( $vers_fullname && $vers_pkg ) {
	push( @pkgs, $vers_pkg ) unless grep( $vers_pkg eq $_, @pkgs );
	$need_vers = 0 if $vers_pkg eq $pkg;

	unless ( defined $vers{$vers_pkg} && length $vers{$vers_pkg} ) {
	  $vers{$vers_pkg} =
	    $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
	}

      # first non-comment line in undeclared package main is VERSION
      } elsif ( !exists($vers{main}) && $pkg eq 'main' && $vers_fullname ) {
	$need_vers = 0;
	my $v =
	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
	$vers{$pkg} = $v;
	push( @pkgs, 'main' );

      # first non-comment line in undeclared package defines package main
      } elsif ( !exists($vers{main}) && $pkg eq 'main' && $line =~ /\w+/ ) {
	$need_vers = 1;
	$vers{main} = '';
	push( @pkgs, 'main' );

      # only keep if this is the first $VERSION seen
      } elsif ( $vers_fullname && $need_vers ) {
	$need_vers = 0;
	my $v =
	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );


	unless ( defined $vers{$pkg} && length $vers{$pkg} ) {
	  $vers{$pkg} = $v;
	}

      }

    }

  }

  if ( $self->{collect_pod} && length($pod_data) ) {
    $pod{$pod_sect} = $pod_data;
  }

  $self->{versions} = \%vers;
  $self->{packages} = \@pkgs;
  $self->{pod} = \%pod;
  $self->{pod_headings} = \@pod;
}

{
my $pn = 0;
sub _evaluate_version_line {
  my $self = shift;
  my( $sigil, $var, $line ) = @_;

  # Some of this code came from the ExtUtils:: hierarchy.

  # We compile into $vsub because 'use version' would cause
  # compiletime/runtime issues with local()
  my $vsub;
  $pn++; # everybody gets their own package
  my $eval = qq{BEGIN { my \$dummy = q#  Hide from _packages_inside()
    #; package Module::Metadata::_version::p$pn;
    use version;
    no strict;
    no warnings;

      \$vsub = sub {
        local $sigil$var;
        \$$var=undef;
        $line;
        \$$var
      };
  }};

  $eval = $1 if $eval =~ m{^(.+)}s;

  local $^W;
  # Try to get the $VERSION
  eval $eval;
  # some modules say $VERSION = $Foo::Bar::VERSION, but Foo::Bar isn't
  # installed, so we need to hunt in ./lib for it
  if ( $@ =~ /Can't locate/ && -d 'lib' ) {
    local @INC = ('lib',@INC);
    eval $eval;
  }
  warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
    if $@;
  (ref($vsub) eq 'CODE') or
    croak "failed to build version sub for $self->{filename}";
  my $result = eval { $vsub->() };
  croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
    if $@;

  # Upgrade it into a version object
  my $version = eval { _dwim_version($result) };

  croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
    unless defined $version; # "0" is OK!

  return $version;
}
}

# Try to DWIM when things fail the lax version test in obvious ways
{
  my @version_prep = (
    # Best case, it just works
    sub { return shift },

    # If we still don't have a version, try stripping any
    # trailing junk that is prohibited by lax rules
    sub {
      my $v = shift;
      $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
      return $v;
    },

    # Activestate apparently creates custom versions like '1.23_45_01', which
    # cause version.pm to think it's an invalid alpha.  So check for that
    # and strip them
    sub {
      my $v = shift;
      my $num_dots = () = $v =~ m{(\.)}g;
      my $num_unders = () = $v =~ m{(_)}g;
      my $leading_v = substr($v,0,1) eq 'v';
      if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
        $v =~ s{_}{}g;
        $num_unders = () = $v =~ m{(_)}g;
      }
      return $v;
    },

    # Worst case, try numifying it like we would have before version objects
    sub {
      my $v = shift;
      no warnings 'numeric';
      return 0 + $v;
    },

  );

  sub _dwim_version {
    my ($result) = shift;

    return $result if ref($result) eq 'version';

    my ($version, $error);
    for my $f (@version_prep) {
      $result = $f->($result);
      $version = eval { version->new($result) };
      $error ||= $@ if $@; # capture first failure
      last if defined $version;
    }

    croak $error unless defined $version;

    return $version;
  }
}

############################################################

# accessors
sub name            { $_[0]->{module}            }

sub filename        { $_[0]->{filename}          }
sub packages_inside { @{$_[0]->{packages}}       }
sub pod_inside      { @{$_[0]->{pod_headings}}   }
sub contains_pod    { 0+@{$_[0]->{pod_headings}} }

sub version {
    my $self = shift;
    my $mod  = shift || $self->{module};
    my $vers;
    if ( defined( $mod ) && length( $mod ) &&
	 exists( $self->{versions}{$mod} ) ) {
	return $self->{versions}{$mod};
    } else {
	return undef;
    }
}

sub pod {
    my $self = shift;
    my $sect = shift;
    if ( defined( $sect ) && length( $sect ) &&
	 exists( $self->{pod}{$sect} ) ) {
	return $self->{pod}{$sect};
    } else {
	return undef;
    }
}

1;

=head1 NAME

Module::Metadata - Gather package and POD information from perl module files

=head1 SYNOPSIS

  use Module::Metadata;

  # information about a .pm file
  my $info = Module::Metadata->new_from_file( $file );
  my $version = $info->version;

  # CPAN META 'provides' field for .pm files in a directory
  my $provides = Module::Metadata->provides(
    dir => 'lib', version => 2
  );

=head1 DESCRIPTION

This module provides a standard way to gather metadata about a .pm file through
(mostly) static analysis and (some) code execution.  When determining the
version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
in the CPAN toolchain.

=head1 USAGE

=head2 Class methods

=over 4

=item C<< new_from_file($filename, collect_pod => 1) >>

Constructs a C<Module::Metadata> object given the path to a file.  Returns
undef if the filename does not exist.

C<collect_pod> is a optional boolean argument that determines whether POD
data is collected and stored for reference.  POD data is not collected by
default.  POD headings are always collected.

If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
it is skipped before processing, and the content of the file is also decoded
appropriately starting from perl 5.8.

=item C<< new_from_handle($handle, $filename, collect_pod => 1) >>

This works just like C<new_from_file>, except that a handle can be provided
as the first argument.

Note that there is no validation to confirm that the handle is a handle or
something that can act like one.  Passing something that isn't a handle will
cause a exception when trying to read from it.  The C<filename> argument is
mandatory or undef will be returned.

You are responsible for setting the decoding layers on C<$handle> if
required.

=item C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>

Constructs a C<Module::Metadata> object given a module or package name.
Returns undef if the module cannot be found.

In addition to accepting the C<collect_pod> argument as described above,
this method accepts a C<inc> argument which is a reference to an array of
directories to search for the module.  If none are given, the default is
@INC.

If the file that contains the module begins by an UTF-8, UTF-16BE or
UTF-16LE byte-order mark, then it is skipped before processing, and the
content of the file is also decoded appropriately starting from perl 5.8.

=item C<< find_module_by_name($module, \@dirs) >>

Returns the path to a module given the module or package name. A list
of directories can be passed in as an optional parameter, otherwise
@INC is searched.

Can be called as either an object or a class method.

=item C<< find_module_dir_by_name($module, \@dirs) >>

Returns the entry in C<@dirs> (or C<@INC> by default) that contains
the module C<$module>. A list of directories can be passed in as an
optional parameter, otherwise @INC is searched.

Can be called as either an object or a class method.

=item C<< provides( %options ) >>

This is a convenience wrapper around C<package_versions_from_directory>
to generate a CPAN META C<provides> data structure.  It takes key/value
pairs.  Valid option keys include:

=over

=item version B<(required)>

Specifies which version of the L<CPAN::Meta::Spec> should be used as
the format of the C<provides> output.  Currently only '1.4' and '2'
are supported (and their format is identical).  This may change in
the future as the definition of C<provides> changes.

The C<version> option is required.  If it is omitted or if
an unsupported version is given, then C<provides> will throw an error.

=item dir

Directory to search recursively for F<.pm> files.  May not be specified with
C<files>.

=item files

Array reference of files to examine.  May not be specified with C<dir>.

=item prefix

String to prepend to the C<file> field of the resulting output. This defaults
to F<lib>, which is the common case for most CPAN distributions with their
F<.pm> files in F<lib>.  This option ensures the META information has the
correct relative path even when the C<dir> or C<files> arguments are
absolute or have relative paths from a location other than the distribution
root.

=back

For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
is a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'lib/Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

=item C<< package_versions_from_directory($dir, \@files?) >>

Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
for those files in C<$dir> - and reads each file for packages and versions,
returning a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

The C<DB> and C<main> packages are always omitted, as are any "private"
packages that have leading underscores in the namespace (e.g.
C<Foo::_private>)

Note that the file path is relative to C<$dir> if that is specified.
This B<must not> be used directly for CPAN META C<provides>.  See
the C<provides> method instead.

=item C<< log_info (internal) >>

Used internally to perform logging; imported from Log::Contextual if
Log::Contextual has already been loaded, otherwise simply calls warn.

=back

=head2 Object methods

=over 4

=item C<< name() >>

Returns the name of the package represented by this module. If there
are more than one packages, it makes a best guess based on the
filename. If it's a script (i.e. not a *.pm) the package name is
'main'.

=item C<< version($package) >>

Returns the version as defined by the $VERSION variable for the
package as returned by the C<name> method if no arguments are
given. If given the name of a package it will attempt to return the
version of that package if it is specified in the file.

=item C<< filename() >>

Returns the absolute path to the file.

=item C<< packages_inside() >>

Returns a list of packages. Note: this is a raw list of packages
discovered (or assumed, in the case of C<main>).  It is not
filtered for C<DB>, C<main> or private packages the way the
C<provides> method does.  Invalid package names are not returned,
for example "Foo:Bar".  Strange but valid package names are
returned, for example "Foo::Bar::", and are left up to the caller
on how to handle.

=item C<< pod_inside() >>

Returns a list of POD sections.

=item C<< contains_pod() >>

Returns true if there is any POD in the file.

=item C<< pod($section) >>

Returns the POD data in the given section.

=back

=head1 AUTHOR

Original code from Module::Build::ModuleInfo by Ken Williams
<kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>

Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
assistance from David Golden (xdg) <dagolden@cpan.org>.

=head1 COPYRIGHT & LICENSE

Original code Copyright (c) 2001-2011 Ken Williams.
Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

usr/share/perl/5.20.2/NEXT.pm                                                                       0100644 0000000 0000000 00000044061 12744441327 013777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package NEXT;
$VERSION = '0.65';
use Carp;
use strict;
use overload ();

sub NEXT::ELSEWHERE::ancestors
{
	my @inlist = shift;
	my @outlist = ();
	while (my $next = shift @inlist) {
		push @outlist, $next;
		no strict 'refs';
		unshift @inlist, @{"$outlist[-1]::ISA"};
	}
	return @outlist;
}

sub NEXT::ELSEWHERE::ordered_ancestors
{
	my @inlist = shift;
	my @outlist = ();
	while (my $next = shift @inlist) {
		push @outlist, $next;
		no strict 'refs';
		push @inlist, @{"$outlist[-1]::ISA"};
	}
	return sort { $a->isa($b) ? -1
	            : $b->isa($a) ? +1
	            :                0 } @outlist;
}

sub NEXT::ELSEWHERE::buildAUTOLOAD
{
    my $autoload_name = caller() . '::AUTOLOAD';

    no strict 'refs';
    *{$autoload_name} = sub {
        my ($self) = @_;
        my $depth = 1;
        until (((caller($depth))[3]||q{}) !~ /^\(eval\)$/) { $depth++ }
        my $caller = (caller($depth))[3];
        my $wanted = $NEXT::AUTOLOAD || $autoload_name;
        undef $NEXT::AUTOLOAD;
        my ($caller_class, $caller_method) = do { $caller =~ m{(.*)::(.*)}g };
        my ($wanted_class, $wanted_method) = do { $wanted =~ m{(.*)::(.*)}g };
        croak "Can't call $wanted from $caller"
            unless $caller_method eq $wanted_method;

        my $key = ref $self && overload::Overloaded($self)
            ? overload::StrVal($self) : $self;

        local ($NEXT::NEXT{$key,$wanted_method}, $NEXT::SEEN) =
            ($NEXT::NEXT{$key,$wanted_method}, $NEXT::SEEN);

        unless ($NEXT::NEXT{$key,$wanted_method}) {
            my @forebears =
                NEXT::ELSEWHERE::ancestors ref $self || $self,
                            $wanted_class;
            while (@forebears) {
                last if shift @forebears eq $caller_class
            }
            no strict 'refs';
            @{$NEXT::NEXT{$key,$wanted_method}} =
                map {
                    my $stash = \%{"${_}::"};
                    ($stash->{$caller_method} && (*{$stash->{$caller_method}}{CODE}))
                        ? *{$stash->{$caller_method}}{CODE}
                        : () } @forebears
                    unless $wanted_method eq 'AUTOLOAD';
            @{$NEXT::NEXT{$key,$wanted_method}} =
                map {
                    my $stash = \%{"${_}::"};
                    ($stash->{AUTOLOAD} && (*{$stash->{AUTOLOAD}}{CODE}))
                        ? "${_}::AUTOLOAD"
                        : () } @forebears
                    unless @{$NEXT::NEXT{$key,$wanted_method}||[]};
            $NEXT::SEEN->{$key,*{$caller}{CODE}}++;
        }
        my $call_method = shift @{$NEXT::NEXT{$key,$wanted_method}};
        while (do { $wanted_class =~ /^NEXT\b.*\b(UNSEEN|DISTINCT)\b/ }
            && defined $call_method
            && $NEXT::SEEN->{$key,$call_method}++) {
            $call_method = shift @{$NEXT::NEXT{$key,$wanted_method}};
        }
        unless (defined $call_method) {
            return unless do { $wanted_class =~ /^NEXT:.*:ACTUAL/ };
            (local $Carp::CarpLevel)++;
            croak qq(Can't locate object method "$wanted_method" ),
                qq(via package "$caller_class");
        };
        return $self->$call_method(@_[1..$#_]) if ref $call_method eq 'CODE';
        no strict 'refs';
        do { ($wanted_method=${$caller_class."::AUTOLOAD"}) =~ s/.*::// }
            if $wanted_method eq 'AUTOLOAD';
        $$call_method = $caller_class."::NEXT::".$wanted_method;
        return $call_method->(@_);
    };
}

no strict 'vars';
package NEXT;                                  NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::UNSEEN;		@ISA = 'NEXT';     NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::DISTINCT;		@ISA = 'NEXT';     NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::ACTUAL;		@ISA = 'NEXT';     NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::ACTUAL::UNSEEN;	@ISA = 'NEXT'; NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::ACTUAL::DISTINCT;	@ISA = 'NEXT'; NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::UNSEEN::ACTUAL;	@ISA = 'NEXT'; NEXT::ELSEWHERE::buildAUTOLOAD();
package NEXT::DISTINCT::ACTUAL;	@ISA = 'NEXT'; NEXT::ELSEWHERE::buildAUTOLOAD();

package EVERY;

sub EVERY::ELSEWHERE::buildAUTOLOAD {
    my $autoload_name = caller() . '::AUTOLOAD';

    no strict 'refs';
    *{$autoload_name} = sub {
        my ($self) = @_;
        my $depth = 1;
        until (((caller($depth))[3]||q{}) !~ /^\(eval\)$/) { $depth++ }
        my $caller = (caller($depth))[3];
        my $wanted = $EVERY::AUTOLOAD || $autoload_name;
        undef $EVERY::AUTOLOAD;
        my ($wanted_class, $wanted_method) = do { $wanted =~ m{(.*)::(.*)}g };

        my $key = ref($self) && overload::Overloaded($self)
            ? overload::StrVal($self) : $self;

        local $NEXT::ALREADY_IN_EVERY{$key,$wanted_method} =
            $NEXT::ALREADY_IN_EVERY{$key,$wanted_method};

        return if $NEXT::ALREADY_IN_EVERY{$key,$wanted_method}++;

        my @forebears = NEXT::ELSEWHERE::ordered_ancestors ref $self || $self,
                                        $wanted_class;
        @forebears = reverse @forebears if do { $wanted_class =~ /\bLAST\b/ };
        no strict 'refs';
        my %seen;
        my @every = map { my $sub = "${_}::$wanted_method";
                    !*{$sub}{CODE} || $seen{$sub}++ ? () : $sub
                    } @forebears
                    unless $wanted_method eq 'AUTOLOAD';

        my $want = wantarray;
        if (@every) {
            if ($want) {
                return map {($_, [$self->$_(@_[1..$#_])])} @every;
            }
            elsif (defined $want) {
                return { map {($_, scalar($self->$_(@_[1..$#_])))}
                        @every
                    };
            }
            else {
                $self->$_(@_[1..$#_]) for @every;
                return;
            }
        }

        @every = map { my $sub = "${_}::AUTOLOAD";
                !*{$sub}{CODE} || $seen{$sub}++ ? () : "${_}::AUTOLOAD"
                } @forebears;
        if ($want) {
            return map { $$_ = ref($self)."::EVERY::".$wanted_method;
                    ($_, [$self->$_(@_[1..$#_])]);
                } @every;
        }
        elsif (defined $want) {
            return { map { $$_ = ref($self)."::EVERY::".$wanted_method;
                    ($_, scalar($self->$_(@_[1..$#_])))
                    } @every
                };
        }
        else {
            for (@every) {
                $$_ = ref($self)."::EVERY::".$wanted_method;
                $self->$_(@_[1..$#_]);
            }
            return;
        }
    };
}

package EVERY::LAST;   @ISA = 'EVERY';   EVERY::ELSEWHERE::buildAUTOLOAD();
package EVERY;         @ISA = 'NEXT';    EVERY::ELSEWHERE::buildAUTOLOAD();

1;

__END__

=head1 NAME

NEXT.pm - Provide a pseudo-class NEXT (et al) that allows method redispatch


=head1 SYNOPSIS

    use NEXT;

    package A;
    sub A::method   { print "$_[0]: A method\n";   $_[0]->NEXT::method() }
    sub A::DESTROY  { print "$_[0]: A dtor\n";     $_[0]->NEXT::DESTROY() }

    package B;
    use base qw( A );
    sub B::AUTOLOAD { print "$_[0]: B AUTOLOAD\n"; $_[0]->NEXT::AUTOLOAD() }
    sub B::DESTROY  { print "$_[0]: B dtor\n";     $_[0]->NEXT::DESTROY() }

    package C;
    sub C::method   { print "$_[0]: C method\n";   $_[0]->NEXT::method() }
    sub C::AUTOLOAD { print "$_[0]: C AUTOLOAD\n"; $_[0]->NEXT::AUTOLOAD() }
    sub C::DESTROY  { print "$_[0]: C dtor\n";     $_[0]->NEXT::DESTROY() }

    package D;
    use base qw( B C );
    sub D::method   { print "$_[0]: D method\n";   $_[0]->NEXT::method() }
    sub D::AUTOLOAD { print "$_[0]: D AUTOLOAD\n"; $_[0]->NEXT::AUTOLOAD() }
    sub D::DESTROY  { print "$_[0]: D dtor\n";     $_[0]->NEXT::DESTROY() }

    package main;

    my $obj = bless {}, "D";

    $obj->method();		# Calls D::method, A::method, C::method
    $obj->missing_method(); # Calls D::AUTOLOAD, B::AUTOLOAD, C::AUTOLOAD

    # Clean-up calls D::DESTROY, B::DESTROY, A::DESTROY, C::DESTROY



=head1 DESCRIPTION

NEXT.pm adds a pseudoclass named C<NEXT> to any program
that uses it. If a method C<m> calls C<$self-E<gt>NEXT::m()>, the call to
C<m> is redispatched as if the calling method had not originally been found.

In other words, a call to C<$self-E<gt>NEXT::m()> resumes the depth-first,
left-to-right search of C<$self>'s class hierarchy that resulted in the
original call to C<m>.

Note that this is not the same thing as C<$self-E<gt>SUPER::m()>, which
begins a new dispatch that is restricted to searching the ancestors
of the current class. C<$self-E<gt>NEXT::m()> can backtrack
past the current class -- to look for a suitable method in other
ancestors of C<$self> -- whereas C<$self-E<gt>SUPER::m()> cannot.

A typical use would be in the destructors of a class hierarchy,
as illustrated in the synopsis above. Each class in the hierarchy
has a DESTROY method that performs some class-specific action
and then redispatches the call up the hierarchy. As a result,
when an object of class D is destroyed, the destructors of I<all>
its parent classes are called (in depth-first, left-to-right order).

Another typical use of redispatch would be in C<AUTOLOAD>'ed methods.
If such a method determined that it was not able to handle a
particular call, it might choose to redispatch that call, in the
hope that some other C<AUTOLOAD> (above it, or to its left) might
do better.

By default, if a redispatch attempt fails to find another method
elsewhere in the objects class hierarchy, it quietly gives up and does
nothing (but see L<"Enforcing redispatch">). This gracious acquiescence
is also unlike the (generally annoying) behaviour of C<SUPER>, which
throws an exception if it cannot redispatch.

Note that it is a fatal error for any method (including C<AUTOLOAD>)
to attempt to redispatch any method that does not have the
same name. For example:

        sub D::oops { print "oops!\n"; $_[0]->NEXT::other_method() }


=head2 Enforcing redispatch

It is possible to make C<NEXT> redispatch more demandingly (i.e. like
C<SUPER> does), so that the redispatch throws an exception if it cannot
find a "next" method to call.

To do this, simple invoke the redispatch as:

	$self->NEXT::ACTUAL::method();

rather than:

	$self->NEXT::method();

The C<ACTUAL> tells C<NEXT> that there must actually be a next method to call,
or it should throw an exception.

C<NEXT::ACTUAL> is most commonly used in C<AUTOLOAD> methods, as a means to
decline an C<AUTOLOAD> request, but preserve the normal exception-on-failure 
semantics:

	sub AUTOLOAD {
		if ($AUTOLOAD =~ /foo|bar/) {
			# handle here
		}
		else {  # try elsewhere
			shift()->NEXT::ACTUAL::AUTOLOAD(@_);
		}
	}

By using C<NEXT::ACTUAL>, if there is no other C<AUTOLOAD> to handle the
method call, an exception will be thrown (as usually happens in the absence of
a suitable C<AUTOLOAD>).


=head2 Avoiding repetitions

If C<NEXT> redispatching is used in the methods of a "diamond" class hierarchy:

	#     A   B
	#    / \ /
	#   C   D
	#    \ /
	#     E

	use NEXT;

	package A;                 
	sub foo { print "called A::foo\n"; shift->NEXT::foo() }

	package B;                 
	sub foo { print "called B::foo\n"; shift->NEXT::foo() }

	package C; @ISA = qw( A );
	sub foo { print "called C::foo\n"; shift->NEXT::foo() }

	package D; @ISA = qw(A B);
	sub foo { print "called D::foo\n"; shift->NEXT::foo() }

	package E; @ISA = qw(C D);
	sub foo { print "called E::foo\n"; shift->NEXT::foo() }

	E->foo();

then derived classes may (re-)inherit base-class methods through two or
more distinct paths (e.g. in the way C<E> inherits C<A::foo> twice --
through C<C> and C<D>). In such cases, a sequence of C<NEXT> redispatches
will invoke the multiply inherited method as many times as it is
inherited. For example, the above code prints:

        called E::foo
        called C::foo
        called A::foo
        called D::foo
        called A::foo
        called B::foo

(i.e. C<A::foo> is called twice).

In some cases this I<may> be the desired effect within a diamond hierarchy,
but in others (e.g. for destructors) it may be more appropriate to 
call each method only once during a sequence of redispatches.

To cover such cases, you can redispatch methods via:

        $self->NEXT::DISTINCT::method();

rather than:

        $self->NEXT::method();

This causes the redispatcher to only visit each distinct C<method> method
once. That is, to skip any classes in the hierarchy that it has
already visited during redispatch. So, for example, if the
previous example were rewritten:

        package A;                 
        sub foo { print "called A::foo\n"; shift->NEXT::DISTINCT::foo() }

        package B;                 
        sub foo { print "called B::foo\n"; shift->NEXT::DISTINCT::foo() }

        package C; @ISA = qw( A );
        sub foo { print "called C::foo\n"; shift->NEXT::DISTINCT::foo() }

        package D; @ISA = qw(A B);
        sub foo { print "called D::foo\n"; shift->NEXT::DISTINCT::foo() }

        package E; @ISA = qw(C D);
        sub foo { print "called E::foo\n"; shift->NEXT::DISTINCT::foo() }

        E->foo();

then it would print:
        
        called E::foo
        called C::foo
        called A::foo
        called D::foo
        called B::foo

and omit the second call to C<A::foo> (since it would not be distinct
from the first call to C<A::foo>).

Note that you can also use:

        $self->NEXT::DISTINCT::ACTUAL::method();

or:

        $self->NEXT::ACTUAL::DISTINCT::method();

to get both unique invocation I<and> exception-on-failure.

Note that, for historical compatibility, you can also use
C<NEXT::UNSEEN> instead of C<NEXT::DISTINCT>.


=head2 Invoking all versions of a method with a single call

Yet another pseudo-class that NEXT.pm provides is C<EVERY>.
Its behaviour is considerably simpler than that of the C<NEXT> family.
A call to:

	$obj->EVERY::foo();

calls I<every> method named C<foo> that the object in C<$obj> has inherited.
That is:

	use NEXT;

	package A; @ISA = qw(B D X);
	sub foo { print "A::foo " }

	package B; @ISA = qw(D X);
	sub foo { print "B::foo " }

	package X; @ISA = qw(D);
	sub foo { print "X::foo " }

	package D;
	sub foo { print "D::foo " }

	package main;

	my $obj = bless {}, 'A';
	$obj->EVERY::foo();        # prints" A::foo B::foo X::foo D::foo

Prefixing a method call with C<EVERY::> causes every method in the
object's hierarchy with that name to be invoked. As the above example
illustrates, they are not called in Perl's usual "left-most-depth-first"
order. Instead, they are called "breadth-first-dependency-wise".

That means that the inheritance tree of the object is traversed breadth-first
and the resulting order of classes is used as the sequence in which methods
are called. However, that sequence is modified by imposing a rule that the
appropriate method of a derived class must be called before the same method of
any ancestral class. That's why, in the above example, C<X::foo> is called
before C<D::foo>, even though C<D> comes before C<X> in C<@B::ISA>.

In general, there's no need to worry about the order of calls. They will be
left-to-right, breadth-first, most-derived-first. This works perfectly for
most inherited methods (including destructors), but is inappropriate for
some kinds of methods (such as constructors, cloners, debuggers, and
initializers) where it's more appropriate that the least-derived methods be
called first (as more-derived methods may rely on the behaviour of their
"ancestors"). In that case, instead of using the C<EVERY> pseudo-class:

	$obj->EVERY::foo();        # prints" A::foo B::foo X::foo D::foo      

you can use the C<EVERY::LAST> pseudo-class:

	$obj->EVERY::LAST::foo();  # prints" D::foo X::foo B::foo A::foo      

which reverses the order of method call.

Whichever version is used, the actual methods are called in the same
context (list, scalar, or void) as the original call via C<EVERY>, and return:

=over

=item *

A hash of array references in list context. Each entry of the hash has the
fully qualified method name as its key and a reference to an array containing
the method's list-context return values as its value.

=item *

A reference to a hash of scalar values in scalar context. Each entry of the hash has the
fully qualified method name as its key and the method's scalar-context return values as its value.

=item *

Nothing in void context (obviously).

=back

=head2 Using C<EVERY> methods

The typical way to use an C<EVERY> call is to wrap it in another base
method, that all classes inherit. For example, to ensure that every
destructor an object inherits is actually called (as opposed to just the
left-most-depth-first-est one):

        package Base;
        sub DESTROY { $_[0]->EVERY::Destroy }

        package Derived1; 
        use base 'Base';
        sub Destroy {...}

        package Derived2; 
        use base 'Base', 'Derived1';
        sub Destroy {...}

et cetera. Every derived class than needs its own clean-up
behaviour simply adds its own C<Destroy> method (I<not> a C<DESTROY> method),
which the call to C<EVERY::LAST::Destroy> in the inherited destructor
then correctly picks up.

Likewise, to create a class hierarchy in which every initializer inherited by
a new object is invoked:

        package Base;
        sub new {
		my ($class, %args) = @_;
		my $obj = bless {}, $class;
		$obj->EVERY::LAST::Init(\%args);
	}

        package Derived1; 
        use base 'Base';
        sub Init {
		my ($argsref) = @_;
		...
	}

        package Derived2; 
        use base 'Base', 'Derived1';
        sub Init {
		my ($argsref) = @_;
		...
	}

et cetera. Every derived class than needs some additional initialization
behaviour simply adds its own C<Init> method (I<not> a C<new> method),
which the call to C<EVERY::LAST::Init> in the inherited constructor
then correctly picks up.


=head1 AUTHOR

Damian Conway (damian@conway.org)

=head1 BUGS AND IRRITATIONS

Because it's a module, not an integral part of the interpreter, NEXT.pm
has to guess where the surrounding call was found in the method
look-up sequence. In the presence of diamond inheritance patterns
it occasionally guesses wrong.

It's also too slow (despite caching).

Comment, suggestions, and patches welcome.

=head1 COPYRIGHT

 Copyright (c) 2000-2001, Damian Conway. All Rights Reserved.
 This module is free software. It may be used, redistributed
    and/or modified under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Net/                                                                          0040755 0000000 0000000 00000000000 13077704254 013410  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Net/Cmd.pm                                                                    0100644 0000000 0000000 00000041424 12744441327 014452  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::Cmd.pm
#
# Copyright (c) 1995-2006 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Cmd;

require 5.001;
require Exporter;

use strict;
use vars qw(@ISA @EXPORT $VERSION);
use Carp;
use Symbol 'gensym';

BEGIN {
  if ($^O eq 'os390') {
    require Convert::EBCDIC;

    #    Convert::EBCDIC->import;
  }
}

BEGIN {
  if (!eval { require utf8 }) {
    *is_utf8 = sub { 0 };
  }
  elsif (eval { utf8::is_utf8(undef); 1 }) {
    *is_utf8 = \&utf8::is_utf8;
  }
  elsif (eval { require Encode; Encode::is_utf8(undef); 1 }) {
    *is_utf8 = \&Encode::is_utf8;
  }
  else {
    *is_utf8 = sub { $_[0] =~ /[^\x00-\xff]/ };
  }
}

$VERSION = "2.30";
@ISA     = qw(Exporter);
@EXPORT  = qw(CMD_INFO CMD_OK CMD_MORE CMD_REJECT CMD_ERROR CMD_PENDING);


sub CMD_INFO    {1}
sub CMD_OK      {2}
sub CMD_MORE    {3}
sub CMD_REJECT  {4}
sub CMD_ERROR   {5}
sub CMD_PENDING {0}

my %debug = ();

my $tr = $^O eq 'os390' ? Convert::EBCDIC->new() : undef;


sub toebcdic {
  my $cmd = shift;

  unless (exists ${*$cmd}{'net_cmd_asciipeer'}) {
    my $string    = $_[0];
    my $ebcdicstr = $tr->toebcdic($string);
    ${*$cmd}{'net_cmd_asciipeer'} = $string !~ /^\d+/ && $ebcdicstr =~ /^\d+/;
  }

  ${*$cmd}{'net_cmd_asciipeer'}
    ? $tr->toebcdic($_[0])
    : $_[0];
}


sub toascii {
  my $cmd = shift;
  ${*$cmd}{'net_cmd_asciipeer'}
    ? $tr->toascii($_[0])
    : $_[0];
}


sub _print_isa {
  no strict qw(refs);

  my $pkg = shift;
  my $cmd = $pkg;

  $debug{$pkg} ||= 0;

  my %done = ();
  my @do   = ($pkg);
  my %spc  = ($pkg, "");

  while ($pkg = shift @do) {
    next if defined $done{$pkg};

    $done{$pkg} = 1;

    my $v =
      defined ${"${pkg}::VERSION"}
      ? "(" . ${"${pkg}::VERSION"} . ")"
      : "";

    my $spc = $spc{$pkg};
    $cmd->debug_print(1, "${spc}${pkg}${v}\n");

    if (@{"${pkg}::ISA"}) {
      @spc{@{"${pkg}::ISA"}} = ("  " . $spc{$pkg}) x @{"${pkg}::ISA"};
      unshift(@do, @{"${pkg}::ISA"});
    }
  }
}


sub debug {
  @_ == 1 or @_ == 2 or croak 'usage: $obj->debug([LEVEL])';

  my ($cmd, $level) = @_;
  my $pkg    = ref($cmd) || $cmd;
  my $oldval = 0;

  if (ref($cmd)) {
    $oldval = ${*$cmd}{'net_cmd_debug'} || 0;
  }
  else {
    $oldval = $debug{$pkg} || 0;
  }

  return $oldval
    unless @_ == 2;

  $level = $debug{$pkg} || 0
    unless defined $level;

  _print_isa($pkg)
    if ($level && !exists $debug{$pkg});

  if (ref($cmd)) {
    ${*$cmd}{'net_cmd_debug'} = $level;
  }
  else {
    $debug{$pkg} = $level;
  }

  $oldval;
}


sub message {
  @_ == 1 or croak 'usage: $obj->message()';

  my $cmd = shift;

  wantarray
    ? @{${*$cmd}{'net_cmd_resp'}}
    : join("", @{${*$cmd}{'net_cmd_resp'}});
}


sub debug_text { $_[2] }


sub debug_print {
  my ($cmd, $out, $text) = @_;
  print STDERR $cmd, ($out ? '>>> ' : '<<< '), $cmd->debug_text($out, $text);
}


sub code {
  @_ == 1 or croak 'usage: $obj->code()';

  my $cmd = shift;

  ${*$cmd}{'net_cmd_code'} = "000"
    unless exists ${*$cmd}{'net_cmd_code'};

  ${*$cmd}{'net_cmd_code'};
}


sub status {
  @_ == 1 or croak 'usage: $obj->status()';

  my $cmd = shift;

  substr(${*$cmd}{'net_cmd_code'}, 0, 1);
}


sub set_status {
  @_ == 3 or croak 'usage: $obj->set_status(CODE, MESSAGE)';

  my $cmd = shift;
  my ($code, $resp) = @_;

  $resp = [$resp]
    unless ref($resp);

  (${*$cmd}{'net_cmd_code'}, ${*$cmd}{'net_cmd_resp'}) = ($code, $resp);

  1;
}


sub command {
  my $cmd = shift;

  unless (defined fileno($cmd)) {
    $cmd->set_status("599", "Connection closed");
    return $cmd;
  }


  $cmd->dataend()
    if (exists ${*$cmd}{'net_cmd_last_ch'});

  if (scalar(@_)) {
    local $SIG{PIPE} = 'IGNORE' unless $^O eq 'MacOS';

    my $str = join(
      " ",
      map {
        /\n/
          ? do { my $n = $_; $n =~ tr/\n/ /; $n }
          : $_;
        } @_
    );
    $str = $cmd->toascii($str) if $tr;
    $str .= "\015\012";

    my $len = length $str;
    my $swlen;

    $cmd->close
      unless (defined($swlen = syswrite($cmd, $str, $len)) && $swlen == $len);

    $cmd->debug_print(1, $str)
      if ($cmd->debug);

    ${*$cmd}{'net_cmd_resp'} = [];       # the response
    ${*$cmd}{'net_cmd_code'} = "000";    # Made this one up :-)
  }

  $cmd;
}


sub ok {
  @_ == 1 or croak 'usage: $obj->ok()';

  my $code = $_[0]->code;
  0 < $code && $code < 400;
}


sub unsupported {
  my $cmd = shift;

  ${*$cmd}{'net_cmd_resp'} = ['Unsupported command'];
  ${*$cmd}{'net_cmd_code'} = 580;
  0;
}


sub getline {
  my $cmd = shift;

  ${*$cmd}{'net_cmd_lines'} ||= [];

  return shift @{${*$cmd}{'net_cmd_lines'}}
    if scalar(@{${*$cmd}{'net_cmd_lines'}});

  my $partial = defined(${*$cmd}{'net_cmd_partial'}) ? ${*$cmd}{'net_cmd_partial'} : "";
  my $fd      = fileno($cmd);

  return undef
    unless defined $fd;

  my $rin = "";
  vec($rin, $fd, 1) = 1;

  my $buf;

  until (scalar(@{${*$cmd}{'net_cmd_lines'}})) {
    my $timeout = $cmd->timeout || undef;
    my $rout;

    my $select_ret = select($rout = $rin, undef, undef, $timeout);
    if ($select_ret > 0) {
      unless (sysread($cmd, $buf = "", 1024)) {
        carp(ref($cmd) . ": Unexpected EOF on command channel")
          if $cmd->debug;
        $cmd->close;
        return undef;
      }

      substr($buf, 0, 0) = $partial;    ## prepend from last sysread

      my @buf = split(/\015?\012/, $buf, -1);    ## break into lines

      $partial = pop @buf;

      push(@{${*$cmd}{'net_cmd_lines'}}, map {"$_\n"} @buf);

    }
    else {
      my $msg = $select_ret ? "Error or Interrupted: $!" : "Timeout";
      carp("$cmd: $msg") if ($cmd->debug);
      return undef;
    }
  }

  ${*$cmd}{'net_cmd_partial'} = $partial;

  if ($tr) {
    foreach my $ln (@{${*$cmd}{'net_cmd_lines'}}) {
      $ln = $cmd->toebcdic($ln);
    }
  }

  shift @{${*$cmd}{'net_cmd_lines'}};
}


sub ungetline {
  my ($cmd, $str) = @_;

  ${*$cmd}{'net_cmd_lines'} ||= [];
  unshift(@{${*$cmd}{'net_cmd_lines'}}, $str);
}


sub parse_response {
  return ()
    unless $_[1] =~ s/^(\d\d\d)(.?)//o;
  ($1, $2 eq "-");
}


sub response {
  my $cmd = shift;
  my ($code, $more) = (undef) x 2;

  ${*$cmd}{'net_cmd_resp'} ||= [];

  while (1) {
    my $str = $cmd->getline();

    return CMD_ERROR
      unless defined($str);

    $cmd->debug_print(0, $str)
      if ($cmd->debug);

    ($code, $more) = $cmd->parse_response($str);
    unless (defined $code) {
      $cmd->ungetline($str);
      $@ = $str;   # $@ used as tunneling hack
      last;
    }

    ${*$cmd}{'net_cmd_code'} = $code;

    push(@{${*$cmd}{'net_cmd_resp'}}, $str);

    last unless ($more);
  }

  return undef unless defined $code;
  substr($code, 0, 1);
}


sub read_until_dot {
  my $cmd = shift;
  my $fh  = shift;
  my $arr = [];

  while (1) {
    my $str = $cmd->getline() or return undef;

    $cmd->debug_print(0, $str)
      if ($cmd->debug & 4);

    last if ($str =~ /^\.\r?\n/o);

    $str =~ s/^\.\././o;

    if (defined $fh) {
      print $fh $str;
    }
    else {
      push(@$arr, $str);
    }
  }

  $arr;
}


sub datasend {
  my $cmd  = shift;
  my $arr  = @_ == 1 && ref($_[0]) ? $_[0] : \@_;
  my $line = join("", @$arr);

  # encode to individual utf8 bytes if
  # $line is a string (in internal UTF-8)
  utf8::encode($line) if is_utf8($line);

  return 0 unless defined(fileno($cmd));

  my $last_ch = ${*$cmd}{'net_cmd_last_ch'};

  # We have not send anything yet, so last_ch = "\012" means we are at the start of a line
  $last_ch = ${*$cmd}{'net_cmd_last_ch'} = "\012" unless defined $last_ch;

  return 1 unless length $line;

  if ($cmd->debug) {
    foreach my $b (split(/\n/, $line)) {
      $cmd->debug_print(1, "$b\n");
    }
  }

  $line =~ tr/\r\n/\015\012/ unless "\r" eq "\015";

  my $first_ch = '';

  if ($last_ch eq "\015") {
    # Remove \012 so it does not get prefixed with another \015 below
    # and escape the . if there is one following it because the fixup
    # below will not find it
    $first_ch = "\012" if $line =~ s/^\012(\.?)/$1$1/;
  }
  elsif ($last_ch eq "\012") {
    # Fixup below will not find the . as the first character of the buffer
    $first_ch = "." if $line =~ /^\./;
  }

  $line =~ s/\015?\012(\.?)/\015\012$1$1/sg;

  substr($line, 0, 0) = $first_ch;

  ${*$cmd}{'net_cmd_last_ch'} = substr($line, -1, 1);

  my $len    = length($line);
  my $offset = 0;
  my $win    = "";
  vec($win, fileno($cmd), 1) = 1;
  my $timeout = $cmd->timeout || undef;

  local $SIG{PIPE} = 'IGNORE' unless $^O eq 'MacOS';

  while ($len) {
    my $wout;
    my $s = select(undef, $wout = $win, undef, $timeout);
    if ((defined $s and $s > 0) or -f $cmd)    # -f for testing on win32
    {
      my $w = syswrite($cmd, $line, $len, $offset);
      unless (defined($w)) {
        carp("$cmd: $!") if $cmd->debug;
        return undef;
      }
      $len -= $w;
      $offset += $w;
    }
    else {
      carp("$cmd: Timeout") if ($cmd->debug);
      return undef;
    }
  }

  1;
}


sub rawdatasend {
  my $cmd  = shift;
  my $arr  = @_ == 1 && ref($_[0]) ? $_[0] : \@_;
  my $line = join("", @$arr);

  return 0 unless defined(fileno($cmd));

  return 1
    unless length($line);

  if ($cmd->debug) {
    my $b = "$cmd>>> ";
    print STDERR $b, join("\n$b", split(/\n/, $line)), "\n";
  }

  my $len    = length($line);
  my $offset = 0;
  my $win    = "";
  vec($win, fileno($cmd), 1) = 1;
  my $timeout = $cmd->timeout || undef;

  local $SIG{PIPE} = 'IGNORE' unless $^O eq 'MacOS';
  while ($len) {
    my $wout;
    if (select(undef, $wout = $win, undef, $timeout) > 0) {
      my $w = syswrite($cmd, $line, $len, $offset);
      unless (defined($w)) {
        carp("$cmd: $!") if $cmd->debug;
        return undef;
      }
      $len -= $w;
      $offset += $w;
    }
    else {
      carp("$cmd: Timeout") if ($cmd->debug);
      return undef;
    }
  }

  1;
}


sub dataend {
  my $cmd = shift;

  return 0 unless defined(fileno($cmd));

  my $ch = ${*$cmd}{'net_cmd_last_ch'};
  my $tosend;

  if (!defined $ch) {
    return 1;
  }
  elsif ($ch ne "\012") {
    $tosend = "\015\012";
  }

  $tosend .= ".\015\012";

  local $SIG{PIPE} = 'IGNORE' unless $^O eq 'MacOS';

  $cmd->debug_print(1, ".\n")
    if ($cmd->debug);

  syswrite($cmd, $tosend, length $tosend);

  delete ${*$cmd}{'net_cmd_last_ch'};

  $cmd->response() == CMD_OK;
}

# read and write to tied filehandle
sub tied_fh {
  my $cmd = shift;
  ${*$cmd}{'net_cmd_readbuf'} = '';
  my $fh = gensym();
  tie *$fh, ref($cmd), $cmd;
  return $fh;
}

# tie to myself
sub TIEHANDLE {
  my $class = shift;
  my $cmd   = shift;
  return $cmd;
}

# Tied filehandle read.  Reads requested data length, returning
# end-of-file when the dot is encountered.
sub READ {
  my $cmd = shift;
  my ($len, $offset) = @_[1, 2];
  return unless exists ${*$cmd}{'net_cmd_readbuf'};
  my $done = 0;
  while (!$done and length(${*$cmd}{'net_cmd_readbuf'}) < $len) {
    ${*$cmd}{'net_cmd_readbuf'} .= $cmd->getline() or return;
    $done++ if ${*$cmd}{'net_cmd_readbuf'} =~ s/^\.\r?\n\Z//m;
  }

  $_[0] = '';
  substr($_[0], $offset + 0) = substr(${*$cmd}{'net_cmd_readbuf'}, 0, $len);
  substr(${*$cmd}{'net_cmd_readbuf'}, 0, $len) = '';
  delete ${*$cmd}{'net_cmd_readbuf'} if $done;

  return length $_[0];
}


sub READLINE {
  my $cmd = shift;

  # in this context, we use the presence of readbuf to
  # indicate that we have not yet reached the eof
  return unless exists ${*$cmd}{'net_cmd_readbuf'};
  my $line = $cmd->getline;
  return if $line =~ /^\.\r?\n/;
  $line;
}


sub PRINT {
  my $cmd = shift;
  my ($buf, $len, $offset) = @_;
  $len ||= length($buf);
  $offset += 0;
  return unless $cmd->datasend(substr($buf, $offset, $len));
  ${*$cmd}{'net_cmd_sending'}++;    # flag that we should call dataend()
  return $len;
}


sub CLOSE {
  my $cmd = shift;
  my $r = exists(${*$cmd}{'net_cmd_sending'}) ? $cmd->dataend : 1;
  delete ${*$cmd}{'net_cmd_readbuf'};
  delete ${*$cmd}{'net_cmd_sending'};
  $r;
}

1;

__END__


=head1 NAME

Net::Cmd - Network Command class (as used by FTP, SMTP etc)

=head1 SYNOPSIS

    use Net::Cmd;

    @ISA = qw(Net::Cmd);

=head1 DESCRIPTION

C<Net::Cmd> is a collection of methods that can be inherited by a sub class
of C<IO::Handle>. These methods implement the functionality required for a
command based protocol, for example FTP and SMTP.

=head1 USER METHODS

These methods provide a user interface to the C<Net::Cmd> object.

=over 4

=item debug ( VALUE )

Set the level of debug information for this object. If C<VALUE> is not given
then the current state is returned. Otherwise the state is changed to 
C<VALUE> and the previous state returned. 

Different packages
may implement different levels of debug but a non-zero value results in 
copies of all commands and responses also being sent to STDERR.

If C<VALUE> is C<undef> then the debug level will be set to the default
debug level for the class.

This method can also be called as a I<static> method to set/get the default
debug level for a given class.

=item message ()

Returns the text message returned from the last command. In a scalar
context it returns a single string, in a list context it will return
each line as a separate element

=item code ()

Returns the 3-digit code from the last command. If a command is pending
then the value 0 is returned

=item ok ()

Returns non-zero if the last code value was greater than zero and
less than 400. This holds true for most command servers. Servers
where this does not hold may override this method.

=item status ()

Returns the most significant digit of the current status code. If a command
is pending then C<CMD_PENDING> is returned.

=item datasend ( DATA )

Send data to the remote server, converting LF to CRLF. Any line starting
with a '.' will be prefixed with another '.'.
C<DATA> may be an array or a reference to an array.

=item dataend ()

End the sending of data to the remote server. This is done by ensuring that
the data already sent ends with CRLF then sending '.CRLF' to end the
transmission. Once this data has been sent C<dataend> calls C<response> and
returns true if C<response> returns CMD_OK.

=back

=head1 CLASS METHODS

These methods are not intended to be called by the user, but used or 
over-ridden by a sub-class of C<Net::Cmd>

=over 4

=item debug_print ( DIR, TEXT )

Print debugging information. C<DIR> denotes the direction I<true> being
data being sent to the server. Calls C<debug_text> before printing to
STDERR.

=item debug_text ( TEXT )

This method is called to print debugging information. TEXT is
the text being sent. The method should return the text to be printed

This is primarily meant for the use of modules such as FTP where passwords
are sent, but we do not want to display them in the debugging information.

=item command ( CMD [, ARGS, ... ])

Send a command to the command server. All arguments a first joined with
a space character and CRLF is appended, this string is then sent to the
command server.

Returns undef upon failure

=item unsupported ()

Sets the status code to 580 and the response text to 'Unsupported command'.
Returns zero.

=item response ()

Obtain a response from the server. Upon success the most significant digit
of the status code is returned. Upon failure, timeout etc., I<undef> is
returned.

=item parse_response ( TEXT )

This method is called by C<response> as a method with one argument. It should
return an array of 2 values, the 3-digit status code and a flag which is true
when this is part of a multi-line response and this line is not the list.

=item getline ()

Retrieve one line, delimited by CRLF, from the remote server. Returns I<undef>
upon failure.

B<NOTE>: If you do use this method for any reason, please remember to add
some C<debug_print> calls into your method.

=item ungetline ( TEXT )

Unget a line of text from the server.

=item rawdatasend ( DATA )

Send data to the remote server without performing any conversions. C<DATA>
is a scalar.

=item read_until_dot ()

Read data from the remote server until a line consisting of a single '.'.
Any lines starting with '..' will have one of the '.'s removed.

Returns a reference to a list containing the lines, or I<undef> upon failure.

=item tied_fh ()

Returns a filehandle tied to the Net::Cmd object.  After issuing a
command, you may read from this filehandle using read() or <>.  The
filehandle will return EOF when the final dot is encountered.
Similarly, you may write to the filehandle in order to send data to
the server after issuing a command that expects data to be written.

See the Net::POP3 and Net::SMTP modules for examples of this.

=back

=head1 EXPORTS

C<Net::Cmd> exports six subroutines, five of these, C<CMD_INFO>, C<CMD_OK>,
C<CMD_MORE>, C<CMD_REJECT> and C<CMD_ERROR>, correspond to possible results
of C<response> and C<status>. The sixth is C<CMD_PENDING>.

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1995-2006 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Net/Config.pm                                                                 0100644 0000000 0000000 00000017030 12744441327 015150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::Config.pm
#
# Copyright (c) 2000 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Config;

require Exporter;
use vars qw(@ISA @EXPORT %NetConfig $VERSION $CONFIGURE $LIBNET_CFG);
use Socket qw(inet_aton inet_ntoa);
use strict;

@EXPORT  = qw(%NetConfig);
@ISA     = qw(Net::LocalCfg Exporter);
$VERSION = "1.13";

eval {
  local @INC = @INC;
  pop @INC if $INC[-1] eq '.';
  local $SIG{__DIE__};
  require Net::LocalCfg;
};

%NetConfig = (
  nntp_hosts      => [],
  snpp_hosts      => [],
  pop3_hosts      => [],
  smtp_hosts      => [],
  ph_hosts        => [],
  daytime_hosts   => [],
  time_hosts      => [],
  inet_domain     => undef,
  ftp_firewall    => undef,
  ftp_ext_passive => 1,
  ftp_int_passive => 1,
  test_hosts      => 1,
  test_exist      => 1,
);

#
# Try to get as much configuration info as possible from InternetConfig
#
$^O eq 'MacOS' and eval <<TRY_INTERNET_CONFIG;
use Mac::InternetConfig;

{
my %nc = (
    nntp_hosts      => [ \$InternetConfig{ kICNNTPHost() } ],
    pop3_hosts      => [ \$InternetConfig{ kICMailAccount() } =~ /\@(.*)/ ],
    smtp_hosts      => [ \$InternetConfig{ kICSMTPHost() } ],
    ftp_testhost    => \$InternetConfig{ kICFTPHost() } ? \$InternetConfig{ kICFTPHost()} : undef,
    ph_hosts        => [ \$InternetConfig{ kICPhHost() }   ],
    ftp_ext_passive => \$InternetConfig{"646F676F\xA5UsePassiveMode"} || 0,
    ftp_int_passive => \$InternetConfig{"646F676F\xA5UsePassiveMode"} || 0,
    socks_hosts     => 
    	\$InternetConfig{ kICUseSocks() }    ? [ \$InternetConfig{ kICSocksHost() }    ] : [],
    ftp_firewall    => 
    	\$InternetConfig{ kICUseFTPProxy() } ? [ \$InternetConfig{ kICFTPProxyHost() } ] : [],
);
\@NetConfig{keys %nc} = values %nc;
}
TRY_INTERNET_CONFIG

my $file = '/etc/perl/Net/libnet.cfg';
my $ref;
if (-f $file) {
  $ref = eval { local $SIG{__DIE__}; do $file };
  if (ref($ref) eq 'HASH') {
    %NetConfig = (%NetConfig, %{$ref});
    $LIBNET_CFG = $file;
  }
}
if ($< == $> and !$CONFIGURE) {
  my $home = eval { local $SIG{__DIE__}; (getpwuid($>))[7] } || $ENV{HOME};
  $home ||= $ENV{HOMEDRIVE} . ($ENV{HOMEPATH} || '') if defined $ENV{HOMEDRIVE};
  if (defined $home) {
    $file      = $home . "/.libnetrc";
    $ref       = eval { local $SIG{__DIE__}; do $file } if -f $file;
    %NetConfig = (%NetConfig, %{$ref})
      if ref($ref) eq 'HASH';
  }
}
my ($k, $v);
while (($k, $v) = each %NetConfig) {
  $NetConfig{$k} = [$v]
    if ($k =~ /_hosts$/ and $k ne "test_hosts" and defined($v) and !ref($v));
}

# Take a hostname and determine if it is inside the firewall


sub requires_firewall {
  shift;    # ignore package
  my $host = shift;

  return 0 unless defined $NetConfig{'ftp_firewall'};

  $host = inet_aton($host) or return -1;
  $host = inet_ntoa($host);

  if (exists $NetConfig{'local_netmask'}) {
    my $quad = unpack("N", pack("C*", split(/\./, $host)));
    my $list = $NetConfig{'local_netmask'};
    $list = [$list] unless ref($list);
    foreach (@$list) {
      my ($net, $bits) = (m#^(\d+\.\d+\.\d+\.\d+)/(\d+)$#) or next;
      my $mask = ~0 << (32 - $bits);
      my $addr = unpack("N", pack("C*", split(/\./, $net)));

      return 0 if (($addr & $mask) == ($quad & $mask));
    }
    return 1;
  }

  return 0;
}

use vars qw(*is_external);
*is_external = \&requires_firewall;

1;

__END__

=head1 NAME

Net::Config - Local configuration data for libnet

=head1 SYNOPSYS

    use Net::Config qw(%NetConfig);

=head1 DESCRIPTION

C<Net::Config> holds configuration data for the modules in the libnet
distribution. During installation you will be asked for these values.

The configuration data is held globally in C</etc/perl/Net/libnet.cfg>,
but a user may override any of these values by providing their own. This
can be done by having a C<.libnetrc> file in their home directory. This file
should return a reference to a HASH containing the keys described below.
For example

    # .libnetrc
    {
        nntp_hosts => [ "my_preferred_host" ],
	ph_hosts   => [ "my_ph_server" ],
    }
    __END__

=head1 METHODS

C<Net::Config> defines the following methods. They are methods as they are
invoked as class methods. This is because C<Net::Config> inherits from
C<Net::LocalCfg> so you can override these methods if you want.

=over 4

=item requires_firewall HOST

Attempts to determine if a given host is outside your firewall. Possible
return values are.

  -1  Cannot lookup hostname
   0  Host is inside firewall (or there is no ftp_firewall entry)
   1  Host is outside the firewall

This is done by using hostname lookup and the C<local_netmask> entry in
the configuration data.

=back

=head1 NetConfig VALUES

=over 4

=item nntp_hosts

=item snpp_hosts

=item pop3_hosts

=item smtp_hosts

=item ph_hosts

=item daytime_hosts

=item time_hosts

Each is a reference to an array of hostnames (in order of preference),
which should be used for the given protocol

=item inet_domain

Your internet domain name

=item ftp_firewall

If you have an FTP proxy firewall (B<NOT> an HTTP or SOCKS firewall)
then this value should be set to the firewall hostname. If your firewall
does not listen to port 21, then this value should be set to
C<"hostname:port"> (eg C<"hostname:99">)

=item ftp_firewall_type

There are many different ftp firewall products available. But unfortunately
there is no standard for how to traverse a firewall.  The list below shows the
sequence of commands that Net::FTP will use

  user        Username for remote host
  pass        Password for remote host
  fwuser      Username for firewall
  fwpass      Password for firewall
  remote.host The hostname of the remote ftp server

=over 4

=item 0Z<>

There is no firewall

=item 1Z<>

     USER user@remote.host
     PASS pass

=item 2Z<>

     USER fwuser
     PASS fwpass
     USER user@remote.host
     PASS pass

=item 3Z<>

     USER fwuser
     PASS fwpass
     SITE remote.site
     USER user
     PASS pass

=item 4Z<>

     USER fwuser
     PASS fwpass
     OPEN remote.site
     USER user
     PASS pass

=item 5Z<>

     USER user@fwuser@remote.site
     PASS pass@fwpass

=item 6Z<>

     USER fwuser@remote.site
     PASS fwpass
     USER user
     PASS pass

=item 7Z<>

     USER user@remote.host
     PASS pass
     AUTH fwuser
     RESP fwpass

=back

=item ftp_ext_passive

=item ftp_int_passive

FTP servers can work in passive or active mode. Active mode is when
you want to transfer data you have to tell the server the address and
port to connect to.  Passive mode is when the server provide the
address and port and you establish the connection.

With some firewalls active mode does not work as the server cannot
connect to your machine (because you are behind a firewall) and the firewall
does not re-write the command. In this case you should set C<ftp_ext_passive>
to a I<true> value.

Some servers are configured to only work in passive mode. If you have
one of these you can force C<Net::FTP> to always transfer in passive
mode; when not going via a firewall, by setting C<ftp_int_passive> to
a I<true> value.

=item local_netmask

A reference to a list of netmask strings in the form C<"134.99.4.0/24">.
These are used by the C<requires_firewall> function to determine if a given
host is inside or outside your firewall.

=back

The following entries are used during installation & testing on the
libnet package

=over 4

=item test_hosts

If true then C<make test> may attempt to connect to hosts given in the
configuration.

=item test_exists

If true then C<Configure> will check each hostname given that it exists

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/perl/5.20.2/Net/Domain.pm                                                                 0100644 0000000 0000000 00000016643 12744441327 015163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::Domain.pm
#
# Copyright (c) 1995-1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Domain;

require Exporter;

use Carp;
use strict;
use vars qw($VERSION @ISA @EXPORT_OK);
use Net::Config;

@ISA       = qw(Exporter);
@EXPORT_OK = qw(hostname hostdomain hostfqdn domainname);

$VERSION = "2.23";

my ($host, $domain, $fqdn) = (undef, undef, undef);

# Try every conceivable way to get hostname.


sub _hostname {

  # we already know it
  return $host
    if (defined $host);

  if ($^O eq 'MSWin32') {
    require Socket;
    my ($name, $alias, $type, $len, @addr) = gethostbyname($ENV{'COMPUTERNAME'} || 'localhost');
    while (@addr) {
      my $a = shift(@addr);
      $host = gethostbyaddr($a, Socket::AF_INET());
      last if defined $host;
    }
    if (defined($host) && index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
    }
    return $host;
  }
  elsif ($^O eq 'MacOS') {
    chomp($host = `hostname`);
  }
  elsif ($^O eq 'VMS') {    ## multiple varieties of net s/w makes this hard
    $host = $ENV{'UCX$INET_HOST'}      if defined($ENV{'UCX$INET_HOST'});
    $host = $ENV{'MULTINET_HOST_NAME'} if defined($ENV{'MULTINET_HOST_NAME'});
    if (index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
    }
    return $host;
  }
  else {
    local $SIG{'__DIE__'};

    # syscall is preferred since it avoids tainting problems
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph";
        defined(&main::SYS_gethostname);
        }
        || eval {
        package main;
        require "sys/syscall.ph";
        defined(&main::SYS_gethostname);
        }
        and $host =
        (syscall(&main::SYS_gethostname, $tmp, 256) == 0)
        ? $tmp
        : undef;
      }

      # POSIX
      || eval {
      require POSIX;
      $host = (POSIX::uname())[1];
      }

      # trusty old hostname command
      || eval {
      chop($host = `(hostname) 2>/dev/null`);    # BSD'ish
      }

      # sysV/POSIX uname command (may truncate)
      || eval {
      chop($host = `uname -n 2>/dev/null`);      ## SYSV'ish && POSIX'ish
      }

      # Apollo pre-SR10
      || eval { $host = (split(/[:\. ]/, `/com/host`, 6))[0]; }

      || eval { $host = ""; };
  }

  # remove garbage
  $host =~ s/[\0\r\n]+//go;
  $host =~ s/(\A\.+|\.+\Z)//go;
  $host =~ s/\.\.+/\./go;

  $host;
}


sub _hostdomain {

  # we already know it
  return $domain
    if (defined $domain);

  local $SIG{'__DIE__'};

  return $domain = $NetConfig{'inet_domain'}
    if defined $NetConfig{'inet_domain'};

  # try looking in /etc/resolv.conf
  # putting this here and assuming that it is correct, eliminates
  # calls to gethostbyname, and therefore DNS lookups. This helps
  # those on dialup systems.

  local *RES;
  local ($_);

  if (open(RES, "/etc/resolv.conf")) {
    while (<RES>) {
      $domain = $1
        if (/\A\s*(?:domain|search)\s+(\S+)/);
    }
    close(RES);

    return $domain
      if (defined $domain);
  }

  # just try hostname and system calls

  my $host = _hostname();
  my (@hosts);

  @hosts = ($host, "localhost");

  unless (defined($host) && $host =~ /\./) {
    my $dom = undef;
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph";
        }
        || eval {
        package main;
        require "sys/syscall.ph";
        }
        and $dom =
        (syscall(&main::SYS_getdomainname, $tmp, 256) == 0)
        ? $tmp
        : undef;
    };

    if ($^O eq 'VMS') {
      $dom ||= $ENV{'TCPIP$INET_DOMAIN'}
        || $ENV{'UCX$INET_DOMAIN'};
    }

    chop($dom = `domainname 2>/dev/null`)
      unless (defined $dom || $^O =~ /^(?:cygwin|MSWin32|android)/);

    if (defined $dom) {
      my @h = ();
      $dom =~ s/^\.+//;
      while (length($dom)) {
        push(@h, "$host.$dom");
        $dom =~ s/^[^.]+.+// or last;
      }
      unshift(@hosts, @h);
    }
  }

  # Attempt to locate FQDN

  foreach (grep { defined $_ } @hosts) {
    my @info = gethostbyname($_);

    next unless @info;

    # look at real name & aliases
    my $site;
    foreach $site ($info[0], split(/ /, $info[1])) {
      if (rindex($site, ".") > 0) {

        # Extract domain from FQDN

        ($domain = $site) =~ s/\A[^\.]+\.//;
        return $domain;
      }
    }
  }

  # Look for environment variable

  $domain ||= $ENV{LOCALDOMAIN} || $ENV{DOMAIN};

  if (defined $domain) {
    $domain =~ s/[\r\n\0]+//g;
    $domain =~ s/(\A\.+|\.+\Z)//g;
    $domain =~ s/\.\.+/\./g;
  }

  $domain;
}


sub domainname {

  return $fqdn
    if (defined $fqdn);

  _hostname();

  # *.local names are special on darwin. If we call gethostbyname below, it
  # may hang while waiting for another, non-existent computer to respond.
  if($^O eq 'darwin' && $host =~ /\.local$/) {
    return $host;
  }

  _hostdomain();

  # Assumption: If the host name does not contain a period
  # and the domain name does, then assume that they are correct
  # this helps to eliminate calls to gethostbyname, and therefore
  # eliminate DNS lookups

  return $fqdn = $host . "." . $domain
    if (defined $host
    and defined $domain
    and $host !~ /\./
    and $domain =~ /\./);

  # For hosts that have no name, just an IP address
  return $fqdn = $host if defined $host and $host =~ /^\d+(\.\d+){3}$/;

  my @host   = defined $host   ? split(/\./, $host)   : ('localhost');
  my @domain = defined $domain ? split(/\./, $domain) : ();
  my @fqdn   = ();

  # Determine from @host & @domain the FQDN

  my @d = @domain;

LOOP:
  while (1) {
    my @h = @host;
    while (@h) {
      my $tmp = join(".", @h, @d);
      if ((gethostbyname($tmp))[0]) {
        @fqdn = (@h, @d);
        $fqdn = $tmp;
        last LOOP;
      }
      pop @h;
    }
    last unless shift @d;
  }

  if (@fqdn) {
    $host = shift @fqdn;
    until ((gethostbyname($host))[0]) {
      $host .= "." . shift @fqdn;
    }
    $domain = join(".", @fqdn);
  }
  else {
    undef $host;
    undef $domain;
    undef $fqdn;
  }

  $fqdn;
}


sub hostfqdn { domainname() }


sub hostname {
  domainname()
    unless (defined $host);
  return $host;
}


sub hostdomain {
  domainname()
    unless (defined $domain);
  return $domain;
}

1;    # Keep require happy

__END__

=head1 NAME

Net::Domain - Attempt to evaluate the current host's internet name and domain

=head1 SYNOPSIS

    use Net::Domain qw(hostname hostfqdn hostdomain domainname);

=head1 DESCRIPTION

Using various methods B<attempt> to find the Fully Qualified Domain Name (FQDN)
of the current host. From this determine the host-name and the host-domain.

Each of the functions will return I<undef> if the FQDN cannot be determined.

=over 4

=item hostfqdn ()

Identify and return the FQDN of the current host.

=item domainname ()

An alias for hostfqdn ().

=item hostname ()

Returns the smallest part of the FQDN which can be used to identify the host.

=item hostdomain ()

Returns the remainder of the FQDN after the I<hostname> has been removed.

=back

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>.
Adapted from Sys::Hostname by David Sundstrom <sunds@asictest.sc.ti.com>

=head1 COPYRIGHT

Copyright (c) 1995-1998 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                             usr/share/perl/5.20.2/Net/FTP/                                                                      0040755 0000000 0000000 00000000000 13077704254 014041  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Net/FTP/A.pm                                                                  0100644 0000000 0000000 00000004541 12744441327 014557  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ## 
## Package to read/write on ASCII data connections
##

package Net::FTP::A;
use strict;
use vars qw(@ISA $buf $VERSION);
use Carp;

require Net::FTP::dataconn;

@ISA     = qw(Net::FTP::dataconn);
$VERSION = "1.19";


sub read {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'read($buf,$size,[$offset])';
  my $timeout = @_ ? shift: $data->timeout;

  if (length(${*$data}) < $size && !${*$data}{'net_ftp_eof'}) {
    my $blksize = ${*$data}{'net_ftp_blksize'};
    $blksize = $size if $size > $blksize;

    my $l = 0;
    my $n;

  READ:
    {
      my $readbuf = defined(${*$data}{'net_ftp_cr'}) ? "\015" : '';

      $data->can_read($timeout)
        or croak "Timeout";

      if ($n = sysread($data, $readbuf, $blksize, length $readbuf)) {
        ${*$data}{'net_ftp_bytesread'} += $n;
        ${*$data}{'net_ftp_cr'} =
          substr($readbuf, -1) eq "\015"
          ? chop($readbuf)
          : undef;
      }
      else {
        return undef
          unless defined $n;

        ${*$data}{'net_ftp_eof'} = 1;
      }

      $readbuf =~ s/\015\012/\n/sgo;
      ${*$data} .= $readbuf;

      unless (length(${*$data})) {

        redo READ
          if ($n > 0);

        $size = length(${*$data})
          if ($n == 0);
      }
    }
  }

  $buf = substr(${*$data}, 0, $size);
  substr(${*$data}, 0, $size) = '';

  length $buf;
}


sub write {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'write($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  my $nr = (my $tmp = substr($buf, 0, $size)) =~ tr/\r\n/\015\012/;
  $tmp =~ s/(?<!\015)\012/\015\012/sg if $nr;
  $tmp =~ s/^\015// if ${*$data}{'net_ftp_outcr'};
  ${*$data}{'net_ftp_outcr'} = substr($tmp, -1) eq "\015";

  # If the remote server has closed the connection we will be signal'd
  # when we write. This can happen if the disk on the remote server fills up

  local $SIG{PIPE} = 'IGNORE'
    unless ($SIG{PIPE} || '') eq 'IGNORE'
    or $^O eq 'MacOS';

  my $len   = length($tmp);
  my $off   = 0;
  my $wrote = 0;

  my $blksize = ${*$data}{'net_ftp_blksize'};

  while ($len) {
    $data->can_write($timeout)
      or croak "Timeout";

    $off += $wrote;
    $wrote = syswrite($data, substr($tmp, $off), $len > $blksize ? $blksize : $len);
    return undef
      unless defined($wrote);
    $len -= $wrote;
  }

  $size;
}

1;
                                                                                                                                                               usr/share/perl/5.20.2/Net/FTP/E.pm                                                                  0100644 0000000 0000000 00000000133 12744441327 014554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::FTP::E;

require Net::FTP::I;

@ISA = qw(Net::FTP::I);
$VERSION = "0.01";

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Net/FTP/I.pm                                                                  0100644 0000000 0000000 00000003161 12744441327 014564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ## 
## Package to read/write on BINARY data connections
##

package Net::FTP::I;

use vars qw(@ISA $buf $VERSION);
use Carp;

require Net::FTP::dataconn;

@ISA     = qw(Net::FTP::dataconn);
$VERSION = "1.12";


sub read {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'read($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  my $n;

  if ($size > length ${*$data} and !${*$data}{'net_ftp_eof'}) {
    $data->can_read($timeout)
      or croak "Timeout";

    my $blksize = ${*$data}{'net_ftp_blksize'};
    $blksize = $size if $size > $blksize;

    unless ($n = sysread($data, ${*$data}, $blksize, length ${*$data})) {
      return undef unless defined $n;
      ${*$data}{'net_ftp_eof'} = 1;
    }
  }

  $buf = substr(${*$data}, 0, $size);

  $n = length($buf);

  substr(${*$data}, 0, $n) = '';

  ${*$data}{'net_ftp_bytesread'} += $n;

  $n;
}


sub write {
  my $data = shift;
  local *buf = \$_[0];
  shift;
  my $size = shift || croak 'write($buf,$size,[$timeout])';
  my $timeout = @_ ? shift: $data->timeout;

  # If the remote server has closed the connection we will be signal'd
  # when we write. This can happen if the disk on the remote server fills up

  local $SIG{PIPE} = 'IGNORE'
    unless ($SIG{PIPE} || '') eq 'IGNORE'
    or $^O eq 'MacOS';
  my $sent = $size;
  my $off  = 0;

  my $blksize = ${*$data}{'net_ftp_blksize'};
  while ($sent > 0) {
    $data->can_write($timeout)
      or croak "Timeout";

    my $n = syswrite($data, $buf, $sent > $blksize ? $blksize : $sent, $off);
    return undef unless defined($n);
    $sent -= $n;
    $off += $n;
  }

  $size;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/perl/5.20.2/Net/FTP/L.pm                                                                  0100644 0000000 0000000 00000000133 12744441327 014563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::FTP::L;

require Net::FTP::I;

@ISA = qw(Net::FTP::I);
$VERSION = "0.01";

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Net/FTP/dataconn.pm                                                           0100644 0000000 0000000 00000004454 12744441327 016171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ##
## Generic data connection package
##

package Net::FTP::dataconn;

use Carp;
use vars qw(@ISA $timeout $VERSION);
use Net::Cmd;
use Errno;

$VERSION = '0.12';
@ISA     = qw(IO::Socket::INET);


sub reading {
  my $data = shift;
  ${*$data}{'net_ftp_bytesread'} = 0;
}


sub abort {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  # no need to abort if we have finished the xfer
  return $data->close
    if ${*$data}{'net_ftp_eof'};

  # for some reason if we continuously open RETR connections and not
  # read a single byte, then abort them after a while the server will
  # close our connection, this prevents the unexpected EOF on the
  # command channel -- GMB
  if (exists ${*$data}{'net_ftp_bytesread'}
    && (${*$data}{'net_ftp_bytesread'} == 0))
  {
    my $buf     = "";
    my $timeout = $data->timeout;
    $data->can_read($timeout) && sysread($data, $buf, 1);
  }

  ${*$data}{'net_ftp_eof'} = 1;    # fake

  $ftp->abort;                     # this will close me
}


sub _close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  $data->SUPER::close();

  delete ${*$ftp}{'net_ftp_dataconn'}
    if defined $ftp
    && exists ${*$ftp}{'net_ftp_dataconn'}
    && $data == ${*$ftp}{'net_ftp_dataconn'};
}


sub close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  if (exists ${*$data}{'net_ftp_bytesread'} && !${*$data}{'net_ftp_eof'}) {
    my $junk;
    eval { local($SIG{__DIE__}); $data->read($junk, 1, 0) };
    return $data->abort unless ${*$data}{'net_ftp_eof'};
  }

  $data->_close;

  return unless defined $ftp;

  $ftp->response() == CMD_OK
    && $ftp->message =~ /unique file name:\s*(\S*)\s*\)/
    && (${*$ftp}{'net_ftp_unique'} = $1);

  $ftp->status == CMD_OK;
}


sub _select {
  my ($data, $timeout, $do_read) = @_;
  my ($rin, $rout, $win, $wout, $tout, $nfound);

  vec($rin = '', fileno($data), 1) = 1;

  ($win, $rin) = ($rin, $win) unless $do_read;

  while (1) {
    $nfound = select($rout = $rin, $wout = $win, undef, $tout = $timeout);

    last if $nfound >= 0;

    croak "select: $!"
      unless $!{EINTR};
  }

  $nfound;
}


sub can_read {
  _select(@_[0, 1], 1);
}


sub can_write {
  _select(@_[0, 1], 0);
}


sub cmd {
  my $ftp = shift;

  ${*$ftp}{'net_ftp_cmd'};
}


sub bytes_read {
  my $ftp = shift;

  ${*$ftp}{'net_ftp_bytesread'} || 0;
}

1;
                                                                                                                                                                                                                    usr/share/perl/5.20.2/Net/FTP.pm                                                                    0100644 0000000 0000000 00000132453 12744441327 014403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::FTP.pm
#
# Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Documentation (at end) improved 1996 by Nathan Torkington <gnat@frii.com>.

package Net::FTP;

require 5.001;

use strict;
use vars qw(@ISA $VERSION);
use Carp;

use Socket 1.3;
use IO::Socket;
use Time::Local;
use Net::Cmd;
use Net::Config;
use Fcntl qw(O_WRONLY O_RDONLY O_APPEND O_CREAT O_TRUNC);

$VERSION = '2.79';
@ISA     = qw(Exporter Net::Cmd IO::Socket::INET);

# Someday I will "use constant", when I am not bothered to much about
# compatibility with older releases of perl

use vars qw($TELNET_IAC $TELNET_IP $TELNET_DM);
($TELNET_IAC, $TELNET_IP, $TELNET_DM) = (255, 244, 242);


BEGIN {

  # make a constant so code is fast'ish
  my $is_os390 = $^O eq 'os390';
  *trEBCDIC = sub () {$is_os390}
}


sub new {
  my $pkg = shift;
  my ($peer, %arg);
  if (@_ % 2) {
    $peer = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $peer = delete $arg{Host};
  }

  my $host      = $peer;
  my $fire      = undef;
  my $fire_type = undef;

  if (exists($arg{Firewall}) || Net::Config->requires_firewall($peer)) {
         $fire = $arg{Firewall}
      || $ENV{FTP_FIREWALL}
      || $NetConfig{ftp_firewall}
      || undef;

    if (defined $fire) {
      $peer = $fire;
      delete $arg{Port};
           $fire_type = $arg{FirewallType}
        || $ENV{FTP_FIREWALL_TYPE}
        || $NetConfig{firewall_type}
        || undef;
    }
  }

  my $ftp = $pkg->SUPER::new(
    PeerAddr  => $peer,
    PeerPort  => $arg{Port} || 'ftp(21)',
    LocalAddr => $arg{'LocalAddr'},
    Proto     => 'tcp',
    Timeout   => defined $arg{Timeout}
    ? $arg{Timeout}
    : 120
    )
    or return undef;

  ${*$ftp}{'net_ftp_host'}    = $host;                             # Remote hostname
  ${*$ftp}{'net_ftp_type'}    = 'A';                               # ASCII/binary/etc mode
  ${*$ftp}{'net_ftp_blksize'} = abs($arg{'BlockSize'} || 10240);

  ${*$ftp}{'net_ftp_localaddr'} = $arg{'LocalAddr'};

  ${*$ftp}{'net_ftp_firewall'} = $fire
    if (defined $fire);
  ${*$ftp}{'net_ftp_firewall_type'} = $fire_type
    if (defined $fire_type);

  ${*$ftp}{'net_ftp_passive'} =
      int exists $arg{Passive} ? $arg{Passive}
    : exists $ENV{FTP_PASSIVE} ? $ENV{FTP_PASSIVE}
    : defined $fire            ? $NetConfig{ftp_ext_passive}
    : $NetConfig{ftp_int_passive};    # Whew! :-)

  $ftp->hash(exists $arg{Hash} ? $arg{Hash} : 0, 1024);

  $ftp->autoflush(1);

  $ftp->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($ftp->response() == CMD_OK) {
    $ftp->close();
    # keep @$ if no message. Happens, when response did not start with a code.
    $@ = $ftp->message || $@;
    undef $ftp;
  }

  $ftp;
}

##
## User interface methods
##


sub host {
  my $me = shift;
  ${*$me}{'net_ftp_host'};
}

sub passive {
  my $ftp = shift;
  return ${*$ftp}{'net_ftp_passive'} unless @_;
  ${*$ftp}{'net_ftp_passive'} = shift;
}


sub hash {
  my $ftp = shift;    # self

  my ($h, $b) = @_;
  unless ($h) {
    delete ${*$ftp}{'net_ftp_hash'};
    return [\*STDERR, 0];
  }
  ($h, $b) = (ref($h) ? $h : \*STDERR, $b || 1024);
  select((select($h), $| = 1)[0]);
  $b = 512 if $b < 512;
  ${*$ftp}{'net_ftp_hash'} = [$h, $b];
}


sub quit {
  my $ftp = shift;

  $ftp->_QUIT;
  $ftp->close;
}


sub DESTROY { }


sub ascii  { shift->type('A', @_); }
sub binary { shift->type('I', @_); }


sub ebcdic {
  carp "TYPE E is unsupported, shall default to I";
  shift->type('E', @_);
}


sub byte {
  carp "TYPE L is unsupported, shall default to I";
  shift->type('L', @_);
}

# Allow the user to send a command directly, BE CAREFUL !!


sub quot {
  my $ftp = shift;
  my $cmd = shift;

  $ftp->command(uc $cmd, @_);
  $ftp->response();
}


sub site {
  my $ftp = shift;

  $ftp->command("SITE", @_);
  $ftp->response();
}


sub mdtm {
  my $ftp  = shift;
  my $file = shift;

  # Server Y2K bug workaround
  #
  # sigh; some idiotic FTP servers use ("19%d",tm.tm_year) instead of
  # ("%d",tm.tm_year+1900).  This results in an extra digit in the
  # string returned. To account for this we allow an optional extra
  # digit in the year. Then if the first two digits are 19 we use the
  # remainder, otherwise we subtract 1900 from the whole year.

  $ftp->_MDTM($file)
    && $ftp->message =~ /((\d\d)(\d\d\d?))(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/
    ? timegm($8, $7, $6, $5, $4 - 1, $2 eq '19' ? $3 : ($1 - 1900))
    : undef;
}


sub size {
  my $ftp  = shift;
  my $file = shift;
  my $io;
  if ($ftp->supported("SIZE")) {
    return $ftp->_SIZE($file)
      ? ($ftp->message =~ /(\d+)\s*(bytes?\s*)?$/)[0]
      : undef;
  }
  elsif ($ftp->supported("STAT")) {
    my @msg;
    return undef
      unless $ftp->_STAT($file) && (@msg = $ftp->message) == 3;
    my $line;
    foreach $line (@msg) {
      return (split(/\s+/, $line))[4]
        if $line =~ /^[-rwxSsTt]{10}/;
    }
  }
  else {
    my @files = $ftp->dir($file);
    if (@files) {
      return (split(/\s+/, $1))[4]
        if $files[0] =~ /^([-rwxSsTt]{10}.*)$/;
    }
  }
  undef;
}


sub login {
  my ($ftp, $user, $pass, $acct) = @_;
  my ($ok, $ruser, $fwtype);

  unless (defined $user) {
    require Net::Netrc;

    my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_host'});

    ($user, $pass, $acct) = $rc->lpa()
      if ($rc);
  }

  $user ||= "anonymous";
  $ruser = $user;

  $fwtype = ${*$ftp}{'net_ftp_firewall_type'}
    || $NetConfig{'ftp_firewall_type'}
    || 0;

  if ($fwtype && defined ${*$ftp}{'net_ftp_firewall'}) {
    if ($fwtype == 1 || $fwtype == 7) {
      $user .= '@' . ${*$ftp}{'net_ftp_host'};
    }
    else {
      require Net::Netrc;

      my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'});

      my ($fwuser, $fwpass, $fwacct) = $rc ? $rc->lpa() : ();

      if ($fwtype == 5) {
        $user = join('@', $user, $fwuser, ${*$ftp}{'net_ftp_host'});
        $pass = $pass . '@' . $fwpass;
      }
      else {
        if ($fwtype == 2) {
          $user .= '@' . ${*$ftp}{'net_ftp_host'};
        }
        elsif ($fwtype == 6) {
          $fwuser .= '@' . ${*$ftp}{'net_ftp_host'};
        }

        $ok = $ftp->_USER($fwuser);

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;

        $ok = $ftp->_PASS($fwpass || "");

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;

        $ok = $ftp->_ACCT($fwacct)
          if defined($fwacct);

        if ($fwtype == 3) {
          $ok = $ftp->command("SITE", ${*$ftp}{'net_ftp_host'})->response;
        }
        elsif ($fwtype == 4) {
          $ok = $ftp->command("OPEN", ${*$ftp}{'net_ftp_host'})->response;
        }

        return 0 unless $ok == CMD_OK || $ok == CMD_MORE;
      }
    }
  }

  $ok = $ftp->_USER($user);

  # Some dumb firewalls don't prefix the connection messages
  $ok = $ftp->response()
    if ($ok == CMD_OK && $ftp->code == 220 && $user =~ /\@/);

  if ($ok == CMD_MORE) {
    unless (defined $pass) {
      require Net::Netrc;

      my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_host'}, $ruser);

      ($ruser, $pass, $acct) = $rc->lpa()
        if ($rc);

      $pass = '-anonymous@'
        if (!defined $pass && (!defined($ruser) || $ruser =~ /^anonymous/o));
    }

    $ok = $ftp->_PASS($pass || "");
  }

  $ok = $ftp->_ACCT($acct)
    if (defined($acct) && ($ok == CMD_MORE || $ok == CMD_OK));

  if ($fwtype == 7 && $ok == CMD_OK && defined ${*$ftp}{'net_ftp_firewall'}) {
    my ($f, $auth, $resp) = _auth_id($ftp);
    $ftp->authorize($auth, $resp) if defined($resp);
  }

  $ok == CMD_OK;
}


sub account {
  @_ == 2 or croak 'usage: $ftp->account( ACCT )';
  my $ftp  = shift;
  my $acct = shift;
  $ftp->_ACCT($acct) == CMD_OK;
}


sub _auth_id {
  my ($ftp, $auth, $resp) = @_;

  unless (defined $resp) {
    require Net::Netrc;

    $auth ||= eval { (getpwuid($>))[0] } || $ENV{NAME};

    my $rc = Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'}, $auth)
      || Net::Netrc->lookup(${*$ftp}{'net_ftp_firewall'});

    ($auth, $resp) = $rc->lpa()
      if ($rc);
  }
  ($ftp, $auth, $resp);
}


sub authorize {
  @_ >= 1 || @_ <= 3 or croak 'usage: $ftp->authorize( [AUTH [, RESP]])';

  my ($ftp, $auth, $resp) = &_auth_id;

  my $ok = $ftp->_AUTH($auth || "");

  $ok = $ftp->_RESP($resp || "")
    if ($ok == CMD_MORE);

  $ok == CMD_OK;
}


sub rename {
  @_ == 3 or croak 'usage: $ftp->rename(FROM, TO)';

  my ($ftp, $from, $to) = @_;

  $ftp->_RNFR($from)
    && $ftp->_RNTO($to);
}


sub type {
  my $ftp    = shift;
  my $type   = shift;
  my $oldval = ${*$ftp}{'net_ftp_type'};

  return $oldval
    unless (defined $type);

  return undef
    unless ($ftp->_TYPE($type, @_));

  ${*$ftp}{'net_ftp_type'} = join(" ", $type, @_);

  $oldval;
}


sub alloc {
  my $ftp    = shift;
  my $size   = shift;
  my $oldval = ${*$ftp}{'net_ftp_allo'};

  return $oldval
    unless (defined $size);

  return undef
    unless ($ftp->_ALLO($size, @_));

  ${*$ftp}{'net_ftp_allo'} = join(" ", $size, @_);

  $oldval;
}


sub abort {
  my $ftp = shift;

  send($ftp, pack("CCC", $TELNET_IAC, $TELNET_IP, $TELNET_IAC), MSG_OOB);

  $ftp->command(pack("C", $TELNET_DM) . "ABOR");

  ${*$ftp}{'net_ftp_dataconn'}->close()
    if defined ${*$ftp}{'net_ftp_dataconn'};

  $ftp->response();

  $ftp->status == CMD_OK;
}


sub get {
  my ($ftp, $remote, $local, $where) = @_;

  my ($loc, $len, $buf, $resp, $data);
  local *FD;

  my $localfd = ref($local) || ref(\$local) eq "GLOB";

  ($local = $remote) =~ s#^.*/##
    unless (defined $local);

  croak("Bad remote filename '$remote'\n")
    if $remote =~ /[\r\n]/s;

  ${*$ftp}{'net_ftp_rest'} = $where if defined $where;
  my $rest = ${*$ftp}{'net_ftp_rest'};

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  $data = $ftp->retr($remote)
    or return undef;

  if ($localfd) {
    $loc = $local;
  }
  else {
    $loc = \*FD;

    unless (sysopen($loc, $local, O_CREAT | O_WRONLY | ($rest ? O_APPEND: O_TRUNC))) {
      carp "Cannot open Local file $local: $!\n";
      $data->abort;
      return undef;
    }
  }

  if ($ftp->type eq 'I' && !binmode($loc)) {
    carp "Cannot binmode Local file $local: $!\n";
    $data->abort;
    close($loc) unless $localfd;
    return undef;
  }

  $buf = '';
  my ($count, $hashh, $hashb, $ref) = (0);

  ($hashh, $hashb) = @$ref
    if ($ref = ${*$ftp}{'net_ftp_hash'});

  my $blksize = ${*$ftp}{'net_ftp_blksize'};
  local $\;    # Just in case

  while (1) {
    last unless $len = $data->read($buf, $blksize);

    if (trEBCDIC && $ftp->type ne 'I') {
      $buf = $ftp->toebcdic($buf);
      $len = length($buf);
    }

    if ($hashh) {
      $count += $len;
      print $hashh "#" x (int($count / $hashb));
      $count %= $hashb;
    }
    unless (print $loc $buf) {
      carp "Cannot write to Local file $local: $!\n";
      $data->abort;
      close($loc)
        unless $localfd;
      return undef;
    }
  }

  print $hashh "\n" if $hashh;

  unless ($localfd) {
    unless (close($loc)) {
      carp "Cannot close file $local (perhaps disk space) $!\n";
      return undef;
    }
  }

  unless ($data->close())    # implied $ftp->response
  {
    carp "Unable to close datastream";
    return undef;
  }

  return $local;
}


sub cwd {
  @_ == 1 || @_ == 2 or croak 'usage: $ftp->cwd( [ DIR ] )';

  my ($ftp, $dir) = @_;

  $dir = "/" unless defined($dir) && $dir =~ /\S/;

  $dir eq ".."
    ? $ftp->_CDUP()
    : $ftp->_CWD($dir);
}


sub cdup {
  @_ == 1 or croak 'usage: $ftp->cdup()';
  $_[0]->_CDUP;
}


sub pwd {
  @_ == 1 || croak 'usage: $ftp->pwd()';
  my $ftp = shift;

  $ftp->_PWD();
  $ftp->_extract_path;
}

# rmdir( $ftp, $dir, [ $recurse ] )
#
# Removes $dir on remote host via FTP.
# $ftp is handle for remote host
#
# If $recurse is TRUE, the directory and deleted recursively.
# This means all of its contents and subdirectories.
#
# Initial version contributed by Dinkum Software
#
sub rmdir {
  @_ == 2 || @_ == 3 or croak('usage: $ftp->rmdir( DIR [, RECURSE ] )');

  # Pick off the args
  my ($ftp, $dir, $recurse) = @_;
  my $ok;

  return $ok
    if $ok = $ftp->_RMD($dir)
    or !$recurse;

  # Try to delete the contents
  # Get a list of all the files in the directory
  my @filelist = grep { !/^\.{1,2}$/ } $ftp->ls($dir);

  return undef
    unless @filelist;    # failed, it is probably not a directory

  return $ftp->delete($dir)
    if @filelist == 1 and $dir eq $filelist[0];

  # Go thru and delete each file or the directory
  my $file;
  foreach $file (map { m,/, ? $_ : "$dir/$_" } @filelist) {
    next                 # successfully deleted the file
      if $ftp->delete($file);

    # Failed to delete it, assume its a directory
    # Recurse and ignore errors, the final rmdir() will
    # fail on any errors here
    return $ok
      unless $ok = $ftp->rmdir($file, 1);
  }

  # Directory should be empty
  # Try to remove the directory again
  # Pass results directly to caller
  # If any of the prior deletes failed, this
  # rmdir() will fail because directory is not empty
  return $ftp->_RMD($dir);
}


sub restart {
  @_ == 2 || croak 'usage: $ftp->restart( BYTE_OFFSET )';

  my ($ftp, $where) = @_;

  ${*$ftp}{'net_ftp_rest'} = $where;

  return undef;
}


sub mkdir {
  @_ == 2 || @_ == 3 or croak 'usage: $ftp->mkdir( DIR [, RECURSE ] )';

  my ($ftp, $dir, $recurse) = @_;

  $ftp->_MKD($dir) || $recurse
    or return undef;

  my $path = $dir;

  unless ($ftp->ok) {
    my @path = split(m#(?=/+)#, $dir);

    $path = "";

    while (@path) {
      $path .= shift @path;

      $ftp->_MKD($path);

      $path = $ftp->_extract_path($path);
    }

    # If the creation of the last element was not successful, see if we
    # can cd to it, if so then return path

    unless ($ftp->ok) {
      my ($status, $message) = ($ftp->status, $ftp->message);
      my $pwd = $ftp->pwd;

      if ($pwd && $ftp->cwd($dir)) {
        $path = $dir;
        $ftp->cwd($pwd);
      }
      else {
        undef $path;
      }
      $ftp->set_status($status, $message);
    }
  }

  $path;
}


sub delete {
  @_ == 2 || croak 'usage: $ftp->delete( FILENAME )';

  $_[0]->_DELE($_[1]);
}


sub put        { shift->_store_cmd("stor", @_) }
sub put_unique { shift->_store_cmd("stou", @_) }
sub append     { shift->_store_cmd("appe", @_) }


sub nlst { shift->_data_cmd("NLST", @_) }
sub list { shift->_data_cmd("LIST", @_) }
sub retr { shift->_data_cmd("RETR", @_) }
sub stor { shift->_data_cmd("STOR", @_) }
sub stou { shift->_data_cmd("STOU", @_) }
sub appe { shift->_data_cmd("APPE", @_) }


sub _store_cmd {
  my ($ftp, $cmd, $local, $remote) = @_;
  my ($loc, $sock, $len, $buf);
  local *FD;

  my $localfd = ref($local) || ref(\$local) eq "GLOB";

  if (!defined($remote) and 'STOU' ne uc($cmd)) {
    croak 'Must specify remote filename with stream input'
      if $localfd;

    require File::Basename;
    $remote = File::Basename::basename($local);
  }
  if (defined ${*$ftp}{'net_ftp_allo'}) {
    delete ${*$ftp}{'net_ftp_allo'};
  }
  else {

    # if the user hasn't already invoked the alloc method since the last
    # _store_cmd call, figure out if the local file is a regular file(not
    # a pipe, or device) and if so get the file size from stat, and send
    # an ALLO command before sending the STOR, STOU, or APPE command.
    my $size = do { local $^W; -f $local && -s _ };    # no ALLO if sending data from a pipe
    ${*$ftp}{'net_ftp_allo'} = $size if $size;
  }
  croak("Bad remote filename '$remote'\n")
    if defined($remote) and $remote =~ /[\r\n]/s;

  if ($localfd) {
    $loc = $local;
  }
  else {
    $loc = \*FD;

    unless (sysopen($loc, $local, O_RDONLY)) {
      carp "Cannot open Local file $local: $!\n";
      return undef;
    }
  }

  if ($ftp->type eq 'I' && !binmode($loc)) {
    carp "Cannot binmode Local file $local: $!\n";
    return undef;
  }

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  $sock = $ftp->_data_cmd($cmd, grep { defined } $remote)
    or return undef;

  $remote = ($ftp->message =~ /\w+\s*:\s*(.*)/)[0]
    if 'STOU' eq uc $cmd;

  my $blksize = ${*$ftp}{'net_ftp_blksize'};

  my ($count, $hashh, $hashb, $ref) = (0);

  ($hashh, $hashb) = @$ref
    if ($ref = ${*$ftp}{'net_ftp_hash'});

  while (1) {
    last unless $len = read($loc, $buf = "", $blksize);

    if (trEBCDIC && $ftp->type ne 'I') {
      $buf = $ftp->toascii($buf);
      $len = length($buf);
    }

    if ($hashh) {
      $count += $len;
      print $hashh "#" x (int($count / $hashb));
      $count %= $hashb;
    }

    my $wlen;
    unless (defined($wlen = $sock->write($buf, $len)) && $wlen == $len) {
      $sock->abort;
      close($loc)
        unless $localfd;
      print $hashh "\n" if $hashh;
      return undef;
    }
  }

  print $hashh "\n" if $hashh;

  close($loc)
    unless $localfd;

  $sock->close()
    or return undef;

  if ('STOU' eq uc $cmd and $ftp->message =~ m/unique\s+file\s*name\s*:\s*(.*)\)|"(.*)"/) {
    require File::Basename;
    $remote = File::Basename::basename($+);
  }

  return $remote;
}


sub port {
  @_ == 1 || @_ == 2 or croak 'usage: $ftp->port([PORT])';

  my ($ftp, $port) = @_;
  my $ok;

  delete ${*$ftp}{'net_ftp_intern_port'};

  unless (defined $port) {

    # create a Listen socket at same address as the command socket

    ${*$ftp}{'net_ftp_listen'} ||= IO::Socket::INET->new(
      Listen    => 5,
      Proto     => 'tcp',
      Timeout   => $ftp->timeout,
      LocalAddr => $ftp->sockhost,
    );

    my $listen = ${*$ftp}{'net_ftp_listen'};

    my ($myport, @myaddr) = ($listen->sockport, split(/\./, $listen->sockhost));

    $port = join(',', @myaddr, $myport >> 8, $myport & 0xff);

    ${*$ftp}{'net_ftp_intern_port'} = 1;
  }

  $ok = $ftp->_PORT($port);

  ${*$ftp}{'net_ftp_port'} = $port;

  $ok;
}


sub ls  { shift->_list_cmd("NLST", @_); }
sub dir { shift->_list_cmd("LIST", @_); }


sub pasv {
  @_ == 1 or croak 'usage: $ftp->pasv()';

  my $ftp = shift;

  delete ${*$ftp}{'net_ftp_intern_port'};

  $ftp->_PASV && $ftp->message =~ /(\d+(,\d+)+)/
    ? ${*$ftp}{'net_ftp_pasv'} = $1
    : undef;
}


sub unique_name {
  my $ftp = shift;
  ${*$ftp}{'net_ftp_unique'} || undef;
}


sub supported {
  @_ == 2 or croak 'usage: $ftp->supported( CMD )';
  my $ftp  = shift;
  my $cmd  = uc shift;
  my $hash = ${*$ftp}{'net_ftp_supported'} ||= {};

  return $hash->{$cmd}
    if exists $hash->{$cmd};

  return $hash->{$cmd} = 1
    if $ftp->feature($cmd);

  return $hash->{$cmd} = 0
    unless $ftp->_HELP($cmd);

  my $text = $ftp->message;
  if ($text =~ /following\s+commands/i) {
    $text =~ s/^.*\n//;
    while ($text =~ /(\*?)(\w+)(\*?)/sg) {
      $hash->{"\U$2"} = !length("$1$3");
    }
  }
  else {
    $hash->{$cmd} = $text !~ /unimplemented/i;
  }

  $hash->{$cmd} ||= 0;
}

##
## Deprecated methods
##


sub lsl {
  carp "Use of Net::FTP::lsl deprecated, use 'dir'"
    if $^W;
  goto &dir;
}


sub authorise {
  carp "Use of Net::FTP::authorise deprecated, use 'authorize'"
    if $^W;
  goto &authorize;
}


##
## Private methods
##


sub _extract_path {
  my ($ftp, $path) = @_;

  # This tries to work both with and without the quote doubling
  # convention (RFC 959 requires it, but the first 3 servers I checked
  # didn't implement it).  It will fail on a server which uses a quote in
  # the message which isn't a part of or surrounding the path.
  $ftp->ok
    && $ftp->message =~ /(?:^|\s)\"(.*)\"(?:$|\s)/
    && ($path = $1) =~ s/\"\"/\"/g;

  $path;
}

##
## Communication methods
##


sub _dataconn {
  my $ftp  = shift;
  my $data = undef;
  my $pkg  = "Net::FTP::" . $ftp->type;

  eval "require " . $pkg;

  $pkg =~ s/ /_/g;

  delete ${*$ftp}{'net_ftp_dataconn'};

  if (defined ${*$ftp}{'net_ftp_pasv'}) {
    my @port = map { 0 + $_ } split(/,/, ${*$ftp}{'net_ftp_pasv'});

    $data = $pkg->new(
      PeerAddr  => join(".", @port[0 .. 3]),
      PeerPort  => $port[4] * 256 + $port[5],
      LocalAddr => ${*$ftp}{'net_ftp_localaddr'},
      Proto     => 'tcp',
      Timeout   => $ftp->timeout
    );
  }
  elsif (defined ${*$ftp}{'net_ftp_listen'}) {
    $data = ${*$ftp}{'net_ftp_listen'}->accept($pkg);
    close(delete ${*$ftp}{'net_ftp_listen'});
  }

  if ($data) {
    ${*$data} = "";
    $data->timeout($ftp->timeout);
    ${*$ftp}{'net_ftp_dataconn'} = $data;
    ${*$data}{'net_ftp_cmd'}     = $ftp;
    ${*$data}{'net_ftp_blksize'} = ${*$ftp}{'net_ftp_blksize'};
  }

  $data;
}


sub _list_cmd {
  my $ftp = shift;
  my $cmd = uc shift;

  delete ${*$ftp}{'net_ftp_port'};
  delete ${*$ftp}{'net_ftp_pasv'};

  my $data = $ftp->_data_cmd($cmd, @_);

  return
    unless (defined $data);

  require Net::FTP::A;
  bless $data, "Net::FTP::A";    # Force ASCII mode

  my $databuf = '';
  my $buf     = '';
  my $blksize = ${*$ftp}{'net_ftp_blksize'};

  while ($data->read($databuf, $blksize)) {
    $buf .= $databuf;
  }

  my $list = [split(/\n/, $buf)];

  $data->close();

  if (trEBCDIC) {
    for (@$list) { $_ = $ftp->toebcdic($_) }
  }

  wantarray
    ? @{$list}
    : $list;
}


sub _data_cmd {
  my $ftp   = shift;
  my $cmd   = uc shift;
  my $ok    = 1;
  my $where = delete ${*$ftp}{'net_ftp_rest'} || 0;
  my $arg;

  for $arg (@_) {
    croak("Bad argument '$arg'\n")
      if $arg =~ /[\r\n]/s;
  }

  if ( ${*$ftp}{'net_ftp_passive'}
    && !defined ${*$ftp}{'net_ftp_pasv'}
    && !defined ${*$ftp}{'net_ftp_port'})
  {
    my $data = undef;

    return undef unless defined $ftp->pasv;
    $data = $ftp->_dataconn() or return undef;

    if ($where and !$ftp->_REST($where)) {
      my ($status, $message) = ($ftp->status, $ftp->message);
      $ftp->abort;
      $ftp->set_status($status, $message);
      return undef;
    }

    $ftp->command($cmd, @_);
    if (CMD_INFO == $ftp->response()) {
      $data->reading
        if $cmd =~ /RETR|LIST|NLST/;
      return $data;
    }
    $data->_close;

    return undef;
  }

  $ok = $ftp->port
    unless (defined ${*$ftp}{'net_ftp_port'}
    || defined ${*$ftp}{'net_ftp_pasv'});

  $ok = $ftp->_REST($where)
    if $ok && $where;

  return undef
    unless $ok;

  if ($cmd =~ /(STOR|APPE|STOU)/ and exists ${*$ftp}{net_ftp_allo}) {
    $ftp->_ALLO(delete ${*$ftp}{net_ftp_allo})
      or return undef;
  }

  $ftp->command($cmd, @_);

  return 1
    if (defined ${*$ftp}{'net_ftp_pasv'});

  $ok = CMD_INFO == $ftp->response();

  return $ok
    unless exists ${*$ftp}{'net_ftp_intern_port'};

  if ($ok) {
    my $data = $ftp->_dataconn();

    $data->reading
      if $data && $cmd =~ /RETR|LIST|NLST/;

    return $data;
  }


  close(delete ${*$ftp}{'net_ftp_listen'});

  return undef;
}

##
## Over-ride methods (Net::Cmd)
##


sub debug_text { $_[2] =~ /^(pass|resp|acct)/i ? "$1 ....\n" : $_[2]; }


sub command {
  my $ftp = shift;

  delete ${*$ftp}{'net_ftp_port'};
  $ftp->SUPER::command(@_);
}


sub response {
  my $ftp  = shift;
  my $code = $ftp->SUPER::response() || 5;    # assume 500 if undef

  delete ${*$ftp}{'net_ftp_pasv'}
    if ($code != CMD_MORE && $code != CMD_INFO);

  $code;
}


sub parse_response {
  return ($1, $2 eq "-")
    if $_[1] =~ s/^(\d\d\d)([- ]?)//o;

  my $ftp = shift;

  # Darn MS FTP server is a load of CRAP !!!!
  # Expect to see undef here.
  return ()
    unless 0 + (${*$ftp}{'net_cmd_code'} || 0);

  (${*$ftp}{'net_cmd_code'}, 1);
}

##
## Allow 2 servers to talk directly
##


sub pasv_xfer_unique {
  my ($sftp, $sfile, $dftp, $dfile) = @_;
  $sftp->pasv_xfer($sfile, $dftp, $dfile, 1);
}


sub pasv_xfer {
  my ($sftp, $sfile, $dftp, $dfile, $unique) = @_;

  ($dfile = $sfile) =~ s#.*/##
    unless (defined $dfile);

  my $port = $sftp->pasv
    or return undef;

  $dftp->port($port)
    or return undef;

  return undef
    unless ($unique ? $dftp->stou($dfile) : $dftp->stor($dfile));

  unless ($sftp->retr($sfile) && $sftp->response == CMD_INFO) {
    $sftp->retr($sfile);
    $dftp->abort;
    $dftp->response();
    return undef;
  }

  $dftp->pasv_wait($sftp);
}


sub pasv_wait {
  @_ == 2 or croak 'usage: $ftp->pasv_wait(NON_PASV_FTP)';

  my ($ftp, $non_pasv) = @_;
  my ($file, $rin, $rout);

  vec($rin = '', fileno($ftp), 1) = 1;
  select($rout = $rin, undef, undef, undef);

  my $dres = $ftp->response();
  my $sres = $non_pasv->response();

  return undef
    unless $dres == CMD_OK && $sres == CMD_OK;

  return undef
    unless $ftp->ok() && $non_pasv->ok();

  return $1
    if $ftp->message =~ /unique file name:\s*(\S*)\s*\)/;

  return $1
    if $non_pasv->message =~ /unique file name:\s*(\S*)\s*\)/;

  return 1;
}


sub feature {
  @_ == 2 or croak 'usage: $ftp->feature( NAME )';
  my ($ftp, $feat) = @_;

  my $feature = ${*$ftp}{net_ftp_feature} ||= do {
    my @feat;

    # Example response
    # 211-Features:
    #  MDTM
    #  REST STREAM
    #  SIZE
    # 211 End

    @feat = map { /^\s+(.*\S)/ } $ftp->message
      if $ftp->_FEAT;

    \@feat;
  };

  return grep { /^\Q$feat\E\b/i } @$feature;
}


sub cmd { shift->command(@_)->response() }

########################################
#
# RFC959 commands
#


sub _ABOR { shift->command("ABOR")->response() == CMD_OK }
sub _ALLO { shift->command("ALLO", @_)->response() == CMD_OK }
sub _CDUP { shift->command("CDUP")->response() == CMD_OK }
sub _NOOP { shift->command("NOOP")->response() == CMD_OK }
sub _PASV { shift->command("PASV")->response() == CMD_OK }
sub _QUIT { shift->command("QUIT")->response() == CMD_OK }
sub _DELE { shift->command("DELE", @_)->response() == CMD_OK }
sub _CWD  { shift->command("CWD", @_)->response() == CMD_OK }
sub _PORT { shift->command("PORT", @_)->response() == CMD_OK }
sub _RMD  { shift->command("RMD", @_)->response() == CMD_OK }
sub _MKD  { shift->command("MKD", @_)->response() == CMD_OK }
sub _PWD  { shift->command("PWD", @_)->response() == CMD_OK }
sub _TYPE { shift->command("TYPE", @_)->response() == CMD_OK }
sub _RNTO { shift->command("RNTO", @_)->response() == CMD_OK }
sub _RESP { shift->command("RESP", @_)->response() == CMD_OK }
sub _MDTM { shift->command("MDTM", @_)->response() == CMD_OK }
sub _SIZE { shift->command("SIZE", @_)->response() == CMD_OK }
sub _HELP { shift->command("HELP", @_)->response() == CMD_OK }
sub _STAT { shift->command("STAT", @_)->response() == CMD_OK }
sub _FEAT { shift->command("FEAT", @_)->response() == CMD_OK }
sub _APPE { shift->command("APPE", @_)->response() == CMD_INFO }
sub _LIST { shift->command("LIST", @_)->response() == CMD_INFO }
sub _NLST { shift->command("NLST", @_)->response() == CMD_INFO }
sub _RETR { shift->command("RETR", @_)->response() == CMD_INFO }
sub _STOR { shift->command("STOR", @_)->response() == CMD_INFO }
sub _STOU { shift->command("STOU", @_)->response() == CMD_INFO }
sub _RNFR { shift->command("RNFR", @_)->response() == CMD_MORE }
sub _REST { shift->command("REST", @_)->response() == CMD_MORE }
sub _PASS { shift->command("PASS", @_)->response() }
sub _ACCT { shift->command("ACCT", @_)->response() }
sub _AUTH { shift->command("AUTH", @_)->response() }


sub _USER {
  my $ftp = shift;
  my $ok  = $ftp->command("USER", @_)->response();

  # A certain brain dead firewall :-)
  $ok = $ftp->command("user", @_)->response()
    unless $ok == CMD_MORE or $ok == CMD_OK;

  $ok;
}


sub _SMNT { shift->unsupported(@_) }
sub _MODE { shift->unsupported(@_) }
sub _SYST { shift->unsupported(@_) }
sub _STRU { shift->unsupported(@_) }
sub _REIN { shift->unsupported(@_) }

1;

__END__

=head1 NAME

Net::FTP - FTP Client class

=head1 SYNOPSIS

    use Net::FTP;

    $ftp = Net::FTP->new("some.host.name", Debug => 0)
      or die "Cannot connect to some.host.name: $@";

    $ftp->login("anonymous",'-anonymous@')
      or die "Cannot login ", $ftp->message;

    $ftp->cwd("/pub")
      or die "Cannot change working directory ", $ftp->message;

    $ftp->get("that.file")
      or die "get failed ", $ftp->message;

    $ftp->quit;

=head1 DESCRIPTION

C<Net::FTP> is a class implementing a simple FTP client in Perl as
described in RFC959.  It provides wrappers for a subset of the RFC959
commands.

The Net::FTP class is a subclass of Net::Cmd and IO::Socket::INET.

=head1 OVERVIEW

FTP stands for File Transfer Protocol.  It is a way of transferring
files between networked machines.  The protocol defines a client
(whose commands are provided by this module) and a server (not
implemented in this module).  Communication is always initiated by the
client, and the server responds with a message and a status code (and
sometimes with data).

The FTP protocol allows files to be sent to or fetched from the
server.  Each transfer involves a B<local file> (on the client) and a
B<remote file> (on the server).  In this module, the same file name
will be used for both local and remote if only one is specified.  This
means that transferring remote file C</path/to/file> will try to put
that file in C</path/to/file> locally, unless you specify a local file
name.

The protocol also defines several standard B<translations> which the
file can undergo during transfer.  These are ASCII, EBCDIC, binary,
and byte.  ASCII is the default type, and indicates that the sender of
files will translate the ends of lines to a standard representation
which the receiver will then translate back into their local
representation.  EBCDIC indicates the file being transferred is in
EBCDIC format.  Binary (also known as image) format sends the data as
a contiguous bit stream.  Byte format transfers the data as bytes, the
values of which remain the same regardless of differences in byte size
between the two machines (in theory - in practice you should only use
this if you really know what you're doing).

=head1 CONSTRUCTOR

=over 4

=item new ([ HOST ] [, OPTIONS ])

This is the constructor for a new Net::FTP object. C<HOST> is the
name of the remote host to which an FTP connection is required.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. 

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - FTP host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.


B<Firewall> - The name of a machine which acts as an FTP firewall. This can be
overridden by an environment variable C<FTP_FIREWALL>. If specified, and the
given host cannot be directly connected to, then the
connection is made to the firewall machine and the string C<@hostname> is
appended to the login identifier. This kind of setup is also referred to
as an ftp proxy.

B<FirewallType> - The type of firewall running on the machine indicated by
B<Firewall>. This can be overridden by an environment variable
C<FTP_FIREWALL_TYPE>. For a list of permissible types, see the description of
ftp_firewall_type in L<Net::Config>.

B<BlockSize> - This is the block size that Net::FTP will use when doing
transfers. (defaults to 10240)

B<Port> - The port number to connect to on the remote machine for the
FTP connection

B<Timeout> - Set a timeout value in seconds (defaults to 120)

B<Debug> - debug level (see the debug method in L<Net::Cmd>)

B<Passive> - If set to a non-zero value then all data transfers will
be done using passive mode. If set to zero then data transfers will be
done using active mode.  If the machine is connected to the Internet
directly, both passive and active mode should work equally well.
Behind most firewall and NAT configurations passive mode has a better
chance of working.  However, in some rare firewall configurations,
active mode actually works when passive mode doesn't.  Some really old
FTP servers might not implement passive transfers.  If not specified,
then the transfer mode is set by the environment variable
C<FTP_PASSIVE> or if that one is not set by the settings done by the
F<libnetcfg> utility.  If none of these apply then passive mode is
used.

B<Hash> - If given a reference to a file handle (e.g., C<\*STDERR>),
print hash marks (#) on that filehandle every 1024 bytes.  This
simply invokes the C<hash()> method for you, so that hash marks
are displayed for all transfers.  You can, of course, call C<hash()>
explicitly whenever you'd like.

B<LocalAddr> - Local address to use for all socket connections, this
argument will be passed to L<IO::Socket::INET>

If the constructor fails undef will be returned and an error message will
be in $@

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::FTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote FTP server in addition to the methods
documented here.

=over 4

=item login ([LOGIN [,PASSWORD [, ACCOUNT] ] ])

Log into the remote FTP server with the given login information. If
no arguments are given then the C<Net::FTP> uses the C<Net::Netrc>
package to lookup the login information for the connected host.
If no information is found then a login of I<anonymous> is used.
If no password is given and the login is I<anonymous> then I<anonymous@>
will be used for password.

If the connection is via a firewall then the C<authorize> method will
be called with no arguments.

=item authorize ( [AUTH [, RESP]])

This is a protocol used by some firewall ftp proxies. It is used
to authorise the user to send data out.  If both arguments are not specified
then C<authorize> uses C<Net::Netrc> to do a lookup.

=item site (ARGS)

Send a SITE command to the remote server and wait for a response.

Returns most significant digit of the response code.

=item ascii

Transfer file in ASCII. CRLF translation will be done if required

=item binary

Transfer file in binary mode. No transformation will be done.

B<Hint>: If both server and client machines use the same line ending for
text files, then it will be faster to transfer all files in binary mode.

=item rename ( OLDNAME, NEWNAME )

Rename a file on the remote FTP server from C<OLDNAME> to C<NEWNAME>. This
is done by sending the RNFR and RNTO commands.

=item delete ( FILENAME )

Send a request to the server to delete C<FILENAME>.

=item cwd ( [ DIR ] )

Attempt to change directory to the directory given in C<$dir>.  If
C<$dir> is C<"..">, the FTP C<CDUP> command is used to attempt to
move up one directory. If no directory is given then an attempt is made
to change the directory to the root directory.

=item cdup ()

Change directory to the parent of the current directory.

=item passive ( [ PASSIVE ] )

Set or get if data connections will be initiated in passive mode.

=item pwd ()

Returns the full pathname of the current directory.

=item restart ( WHERE )

Set the byte offset at which to begin the next data transfer. Net::FTP simply
records this value and uses it when during the next data transfer. For this
reason this method will not return an error, but setting it may cause
a subsequent data transfer to fail.

=item rmdir ( DIR [, RECURSE ])

Remove the directory with the name C<DIR>. If C<RECURSE> is I<true> then
C<rmdir> will attempt to delete everything inside the directory.

=item mkdir ( DIR [, RECURSE ])

Create a new directory with the name C<DIR>. If C<RECURSE> is I<true> then
C<mkdir> will attempt to create all the directories in the given path.

Returns the full pathname to the new directory.

=item alloc ( SIZE [, RECORD_SIZE] )

The alloc command allows you to give the ftp server a hint about the size
of the file about to be transferred using the ALLO ftp command. Some storage
systems use this to make intelligent decisions about how to store the file.
The C<SIZE> argument represents the size of the file in bytes. The
C<RECORD_SIZE> argument indicates a maximum record or page size for files
sent with a record or page structure.

The size of the file will be determined, and sent to the server
automatically for normal files so that this method need only be called if
you are transferring data from a socket, named pipe, or other stream not
associated with a normal file.

=item ls ( [ DIR ] )

Get a directory listing of C<DIR>, or the current directory.

In an array context, returns a list of lines returned from the server. In
a scalar context, returns a reference to a list.

=item dir ( [ DIR ] )

Get a directory listing of C<DIR>, or the current directory in long format.

In an array context, returns a list of lines returned from the server. In
a scalar context, returns a reference to a list.

=item get ( REMOTE_FILE [, LOCAL_FILE [, WHERE]] )

Get C<REMOTE_FILE> from the server and store locally. C<LOCAL_FILE> may be
a filename or a filehandle. If not specified, the file will be stored in
the current directory with the same leafname as the remote file.

If C<WHERE> is given then the first C<WHERE> bytes of the file will
not be transferred, and the remaining bytes will be appended to
the local file if it already exists.

Returns C<LOCAL_FILE>, or the generated local file name if C<LOCAL_FILE>
is not given. If an error was encountered undef is returned.

=item put ( LOCAL_FILE [, REMOTE_FILE ] )

Put a file on the remote server. C<LOCAL_FILE> may be a name or a filehandle.
If C<LOCAL_FILE> is a filehandle then C<REMOTE_FILE> must be specified. If
C<REMOTE_FILE> is not specified then the file will be stored in the current
directory with the same leafname as C<LOCAL_FILE>.

Returns C<REMOTE_FILE>, or the generated remote filename if C<REMOTE_FILE>
is not given.

B<NOTE>: If for some reason the transfer does not complete and an error is
returned then the contents that had been transferred will not be remove
automatically.

=item put_unique ( LOCAL_FILE [, REMOTE_FILE ] )

Same as put but uses the C<STOU> command.

Returns the name of the file on the server.

=item append ( LOCAL_FILE [, REMOTE_FILE ] )

Same as put but appends to the file on the remote server.

Returns C<REMOTE_FILE>, or the generated remote filename if C<REMOTE_FILE>
is not given.

=item unique_name ()

Returns the name of the last file stored on the server using the
C<STOU> command.

=item mdtm ( FILE )

Returns the I<modification time> of the given file

=item size ( FILE )

Returns the size in bytes for the given file as stored on the remote server.

B<NOTE>: The size reported is the size of the stored file on the remote server.
If the file is subsequently transferred from the server in ASCII mode
and the remote server and local machine have different ideas about
"End Of Line" then the size of file on the local machine after transfer
may be different.

=item supported ( CMD )

Returns TRUE if the remote server supports the given command.

=item hash ( [FILEHANDLE_GLOB_REF],[ BYTES_PER_HASH_MARK] )

Called without parameters, or with the first argument false, hash marks
are suppressed.  If the first argument is true but not a reference to a 
file handle glob, then \*STDERR is used.  The second argument is the number
of bytes per hash mark printed, and defaults to 1024.  In all cases the
return value is a reference to an array of two:  the filehandle glob reference
and the bytes per hash mark.

=item feature ( NAME )

Determine if the server supports the specified feature. The return
value is a list of lines the server responded with to describe the
options that it supports for the given feature. If the feature is
unsupported then the empty list is returned.

  if ($ftp->feature( 'MDTM' )) {
    # Do something
  }

  if (grep { /\bTLS\b/ } $ftp->feature('AUTH')) {
    # Server supports TLS
  }

=back

The following methods can return different results depending on
how they are called. If the user explicitly calls either
of the C<pasv> or C<port> methods then these methods will
return a I<true> or I<false> value. If the user does not
call either of these methods then the result will be a
reference to a C<Net::FTP::dataconn> based object.

=over 4

=item nlst ( [ DIR ] )

Send an C<NLST> command to the server, with an optional parameter.

=item list ( [ DIR ] )

Same as C<nlst> but using the C<LIST> command

=item retr ( FILE )

Begin the retrieval of a file called C<FILE> from the remote server.

=item stor ( FILE )

Tell the server that you wish to store a file. C<FILE> is the
name of the new file that should be created.

=item stou ( FILE )

Same as C<stor> but using the C<STOU> command. The name of the unique
file which was created on the server will be available via the C<unique_name>
method after the data connection has been closed.

=item appe ( FILE )

Tell the server that we want to append some data to the end of a file
called C<FILE>. If this file does not exist then create it.

=back

If for some reason you want to have complete control over the data connection,
this includes generating it and calling the C<response> method when required,
then the user can use these methods to do so.

However calling these methods only affects the use of the methods above that
can return a data connection. They have no effect on methods C<get>, C<put>,
C<put_unique> and those that do not require data connections.

=over 4

=item port ( [ PORT ] )

Send a C<PORT> command to the server. If C<PORT> is specified then it is sent
to the server. If not, then a listen socket is created and the correct information
sent to the server.

=item pasv ()

Tell the server to go into passive mode. Returns the text that represents the
port on which the server is listening, this text is in a suitable form to
sent to another ftp server using the C<port> method.

=back

The following methods can be used to transfer files between two remote
servers, providing that these two servers can connect directly to each other.

=over 4

=item pasv_xfer ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )

This method will do a file transfer between two remote ftp servers. If
C<DEST_FILE> is omitted then the leaf name of C<SRC_FILE> will be used.

=item pasv_xfer_unique ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )

Like C<pasv_xfer> but the file is stored on the remote server using
the STOU command.

=item pasv_wait ( NON_PASV_SERVER )

This method can be used to wait for a transfer to complete between a passive
server and a non-passive server. The method should be called on the passive
server with the C<Net::FTP> object for the non-passive server passed as an
argument.

=item abort ()

Abort the current data transfer.

=item quit ()

Send the QUIT command to the remote FTP server and close the socket connection.

=back

=head2 Methods for the adventurous

=over 4

=item quot (CMD [,ARGS])

Send a command, that Net::FTP does not directly support, to the remote
server and wait for a response.

Returns most significant digit of the response code.

B<WARNING> This call should only be used on commands that do not require
data connections. Misuse of this method can hang the connection.

=back

=head1 THE dataconn CLASS

Some of the methods defined in C<Net::FTP> return an object which will
be derived from this class.The dataconn class itself is derived from
the C<IO::Socket::INET> class, so any normal IO operations can be performed.
However the following methods are defined in the dataconn class and IO should
be performed using these.

=over 4

=item read ( BUFFER, SIZE [, TIMEOUT ] )

Read C<SIZE> bytes of data from the server and place it into C<BUFFER>, also
performing any <CRLF> translation necessary. C<TIMEOUT> is optional, if not
given, the timeout value from the command connection will be used.

Returns the number of bytes read before any <CRLF> translation.

=item write ( BUFFER, SIZE [, TIMEOUT ] )

Write C<SIZE> bytes of data from C<BUFFER> to the server, also
performing any <CRLF> translation necessary. C<TIMEOUT> is optional, if not
given, the timeout value from the command connection will be used.

Returns the number of bytes written before any <CRLF> translation.

=item bytes_read ()

Returns the number of bytes read so far.

=item abort ()

Abort the current data transfer.

=item close ()

Close the data connection and get a response from the FTP server. Returns
I<true> if the connection was closed successfully and the first digit of
the response from the server was a '2'.

=back

=head1 UNIMPLEMENTED

The following RFC959 commands have not been implemented:

=over 4

=item B<SMNT>

Mount a different file system structure without changing login or
accounting information.

=item B<HELP>

Ask the server for "helpful information" (that's what the RFC says) on
the commands it accepts.

=item B<MODE>

Specifies transfer mode (stream, block or compressed) for file to be
transferred.

=item B<SYST>

Request remote server system identification.

=item B<STAT>

Request remote server status.

=item B<STRU>

Specifies file structure for file to be transferred.

=item B<REIN>

Reinitialize the connection, flushing all I/O and account information.

=back

=head1 REPORTING BUGS

When reporting bugs/problems please include as much information as possible.
It may be difficult for me to reproduce the problem as almost every setup
is different.

A small script which yields the problem will probably be of help. It would
also be useful if this script was run with the extra options C<Debug => 1>
passed to the constructor, and the output sent with the bug report. If you
cannot include a small script then please include a Debug trace from a
run of your program which does yield the problem.

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 SEE ALSO

L<Net::Netrc>
L<Net::Cmd>

ftp(1), ftpd(8), RFC 959
http://www.ietf.org/rfc/rfc959.txt

=head1 USE EXAMPLES

For an example of the use of Net::FTP see

=over 4

=item http://www.csh.rit.edu/~adam/Progs/

C<autoftp> is a program that can retrieve, send, or list files via
the FTP protocol in a non-interactive manner.

=back

=head1 CREDITS

Henry Gabryjelski <henryg@WPI.EDU> - for the suggestion of creating directories
recursively.

Nathan Torkington <gnat@frii.com> - for some input on the documentation.

Roderick Schertler <roderick@gate.net> - for various inputs

=head1 COPYRIGHT

Copyright (c) 1995-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                     usr/share/perl/5.20.2/Net/NNTP.pm                                                                   0100644 0000000 0000000 00000066711 12744441327 014534  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::NNTP.pm
#
# Copyright (c) 1995-1997 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::NNTP;

use strict;
use vars qw(@ISA $VERSION $debug);
use IO::Socket;
use Net::Cmd;
use Carp;
use Time::Local;
use Net::Config;

$VERSION = "2.26";
@ISA     = qw(Net::Cmd IO::Socket::INET);


sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }
  my $obj;

  $host ||= $ENV{NNTPSERVER} || $ENV{NEWSHOST};

  my $hosts = defined $host ? [$host] : $NetConfig{nntp_hosts};

  @{$hosts} = qw(news)
    unless @{$hosts};

  my %connect = ( Proto => 'tcp');
  my $o;
  foreach $o (qw(LocalAddr Timeout)) {
    $connect{$o} = $arg{$o} if exists $arg{$o};
  }
  $connect{Timeout} = 120 unless defined $connect{Timeout};
  $connect{PeerPort} = $arg{Port} || 'nntp(119)';
  my $h;
  foreach $h (@{$hosts}) {
    $connect{PeerAddr} = $h;
    $obj = $type->SUPER::new(%connect)
      and last;
  }

  return undef
    unless defined $obj;

  ${*$obj}{'net_nntp_host'} = $connect{PeerAddr};

  $obj->autoflush(1);
  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    $obj->close;
    return undef;
  }

  my $c = $obj->code;
  my @m = $obj->message;

  unless (exists $arg{Reader} && $arg{Reader} == 0) {

    # if server is INN and we have transfer rights the we are currently
    # talking to innd not nnrpd
    if ($obj->reader) {

      # If reader succeeds the we need to consider this code to determine postok
      $c = $obj->code;
    }
    else {

      # I want to ignore this failure, so restore the previous status.
      $obj->set_status($c, \@m);
    }
  }

  ${*$obj}{'net_nntp_post'} = $c == 200 ? 1 : 0;

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_nntp_host'};
}


sub debug_text {
  my $nntp  = shift;
  my $inout = shift;
  my $text  = shift;

  if ( (ref($nntp) and $nntp->code == 350 and $text =~ /^(\S+)/)
    || ($text =~ /^(authinfo\s+pass)/io))
  {
    $text = "$1 ....\n";
  }

  $text;
}


sub postok {
  @_ == 1 or croak 'usage: $nntp->postok()';
  my $nntp = shift;
  ${*$nntp}{'net_nntp_post'} || 0;
}


sub article {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->article( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && (ref($_[0]) || ref(\$_[0]) eq 'GLOB'));

  $nntp->_ARTICLE(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub articlefh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->articlefh( [ MSGID ] )';
  my $nntp = shift;

  return unless $nntp->_ARTICLE(@_);
  return $nntp->tied_fh;
}


sub authinfo {
  @_ == 3 or croak 'usage: $nntp->authinfo( USER, PASS )';
  my ($nntp, $user, $pass) = @_;

  $nntp->_AUTHINFO("USER",      $user) == CMD_MORE
    && $nntp->_AUTHINFO("PASS", $pass) == CMD_OK;
}


sub authinfo_simple {
  @_ == 3 or croak 'usage: $nntp->authinfo( USER, PASS )';
  my ($nntp, $user, $pass) = @_;

  $nntp->_AUTHINFO('SIMPLE') == CMD_MORE
    && $nntp->command($user, $pass)->response == CMD_OK;
}


sub body {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->body( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && ref($_[0]) || ref(\$_[0]) eq 'GLOB');

  $nntp->_BODY(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub bodyfh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->bodyfh( [ MSGID ] )';
  my $nntp = shift;
  return unless $nntp->_BODY(@_);
  return $nntp->tied_fh;
}


sub head {
  @_ >= 1 && @_ <= 3 or croak 'usage: $nntp->head( [ MSGID ], [ FH ] )';
  my $nntp = shift;
  my @fh;

  @fh = (pop) if @_ == 2 || (@_ && ref($_[0]) || ref(\$_[0]) eq 'GLOB');

  $nntp->_HEAD(@_)
    ? $nntp->read_until_dot(@fh)
    : undef;
}


sub headfh {
  @_ >= 1 && @_ <= 2 or croak 'usage: $nntp->headfh( [ MSGID ] )';
  my $nntp = shift;
  return unless $nntp->_HEAD(@_);
  return $nntp->tied_fh;
}


sub nntpstat {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->nntpstat( [ MSGID ] )';
  my $nntp = shift;

  $nntp->_STAT(@_) && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub group {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->group( [ GROUP ] )';
  my $nntp = shift;
  my $grp  = ${*$nntp}{'net_nntp_group'};

  return $grp
    unless (@_ || wantarray);

  my $newgrp = shift;

  $newgrp = (defined($grp) and length($grp)) ? $grp : ""
    unless defined($newgrp) and length($newgrp);

  return 
    unless $nntp->_GROUP($newgrp) and $nntp->message =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\S+)/;

  my ($count, $first, $last, $group) = ($1, $2, $3, $4);

  # group may be replied as '(current group)'
  $group = ${*$nntp}{'net_nntp_group'}
    if $group =~ /\(/;

  ${*$nntp}{'net_nntp_group'} = $group;

  wantarray
    ? ($count, $first, $last, $group)
    : $group;
}


sub help {
  @_ == 1 or croak 'usage: $nntp->help()';
  my $nntp = shift;

  $nntp->_HELP
    ? $nntp->read_until_dot
    : undef;
}


sub ihave {
  @_ >= 2 or croak 'usage: $nntp->ihave( MESSAGE-ID [, MESSAGE ])';
  my $nntp = shift;
  my $mid  = shift;

  $nntp->_IHAVE($mid) && $nntp->datasend(@_)
    ? @_ == 0 || $nntp->dataend
    : undef;
}


sub last {
  @_ == 1 or croak 'usage: $nntp->last()';
  my $nntp = shift;

  $nntp->_LAST && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub list {
  @_ == 1 or croak 'usage: $nntp->list()';
  my $nntp = shift;

  $nntp->_LIST
    ? $nntp->_grouplist
    : undef;
}


sub newgroups {
  @_ >= 2 or croak 'usage: $nntp->newgroups( SINCE [, DISTRIBUTIONS ])';
  my $nntp = shift;
  my $time = _timestr(shift);
  my $dist = shift || "";

  $dist = join(",", @{$dist})
    if ref($dist);

  $nntp->_NEWGROUPS($time, $dist)
    ? $nntp->_grouplist
    : undef;
}


sub newnews {
  @_ >= 2 && @_ <= 4
    or croak 'usage: $nntp->newnews( SINCE [, GROUPS [, DISTRIBUTIONS ]])';
  my $nntp = shift;
  my $time = _timestr(shift);
  my $grp  = @_ ? shift: $nntp->group;
  my $dist = shift || "";

  $grp ||= "*";
  $grp = join(",", @{$grp})
    if ref($grp);

  $dist = join(",", @{$dist})
    if ref($dist);

  $nntp->_NEWNEWS($grp, $time, $dist)
    ? $nntp->_articlelist
    : undef;
}


sub next {
  @_ == 1 or croak 'usage: $nntp->next()';
  my $nntp = shift;

  $nntp->_NEXT && $nntp->message =~ /(<[^>]+>)/o
    ? $1
    : undef;
}


sub post {
  @_ >= 1 or croak 'usage: $nntp->post( [ MESSAGE ] )';
  my $nntp = shift;

  $nntp->_POST() && $nntp->datasend(@_)
    ? @_ == 0 || $nntp->dataend
    : undef;
}


sub postfh {
  my $nntp = shift;
  return unless $nntp->_POST();
  return $nntp->tied_fh;
}


sub quit {
  @_ == 1 or croak 'usage: $nntp->quit()';
  my $nntp = shift;

  $nntp->_QUIT;
  $nntp->close;
}


sub slave {
  @_ == 1 or croak 'usage: $nntp->slave()';
  my $nntp = shift;

  $nntp->_SLAVE;
}

##
## The following methods are not implemented by all servers
##


sub active {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->active( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_LIST('ACTIVE', @_)
    ? $nntp->_grouplist
    : undef;
}


sub active_times {
  @_ == 1 or croak 'usage: $nntp->active_times()';
  my $nntp = shift;

  $nntp->_LIST('ACTIVE.TIMES')
    ? $nntp->_grouplist
    : undef;
}


sub distributions {
  @_ == 1 or croak 'usage: $nntp->distributions()';
  my $nntp = shift;

  $nntp->_LIST('DISTRIBUTIONS')
    ? $nntp->_description
    : undef;
}


sub distribution_patterns {
  @_ == 1 or croak 'usage: $nntp->distributions()';
  my $nntp = shift;

  my $arr;
  local $_;

  $nntp->_LIST('DISTRIB.PATS')
    && ($arr = $nntp->read_until_dot)
    ? [grep { /^\d/ && (chomp, $_ = [split /:/]) } @$arr]
    : undef;
}


sub newsgroups {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->newsgroups( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_LIST('NEWSGROUPS', @_)
    ? $nntp->_description
    : undef;
}


sub overview_fmt {
  @_ == 1 or croak 'usage: $nntp->overview_fmt()';
  my $nntp = shift;

  $nntp->_LIST('OVERVIEW.FMT')
    ? $nntp->_articlelist
    : undef;
}


sub subscriptions {
  @_ == 1 or croak 'usage: $nntp->subscriptions()';
  my $nntp = shift;

  $nntp->_LIST('SUBSCRIPTIONS')
    ? $nntp->_articlelist
    : undef;
}


sub listgroup {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->listgroup( [ GROUP ] )';
  my $nntp = shift;

  $nntp->_LISTGROUP(@_)
    ? $nntp->_articlelist
    : undef;
}


sub reader {
  @_ == 1 or croak 'usage: $nntp->reader()';
  my $nntp = shift;

  $nntp->_MODE('READER');
}


sub xgtitle {
  @_ == 1 || @_ == 2 or croak 'usage: $nntp->xgtitle( [ PATTERN ] )';
  my $nntp = shift;

  $nntp->_XGTITLE(@_)
    ? $nntp->_description
    : undef;
}


sub xhdr {
  @_ >= 2 && @_ <= 4 or croak 'usage: $nntp->xhdr( HEADER, [ MESSAGE-SPEC ] )';
  my $nntp = shift;
  my $hdr  = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XHDR($hdr, $arg)
    ? $nntp->_description
    : undef;
}


sub xover {
  @_ == 2 || @_ == 3 or croak 'usage: $nntp->xover( MESSAGE-SPEC )';
  my $nntp = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XOVER($arg)
    ? $nntp->_fieldlist
    : undef;
}


sub xpat {
  @_ == 4 || @_ == 5 or croak '$nntp->xpat( HEADER, PATTERN, MESSAGE-SPEC )';
  my $nntp = shift;
  my $hdr  = shift;
  my $pat  = shift;
  my $arg  = _msg_arg(@_);

  $pat = join(" ", @$pat)
    if ref($pat);

  $nntp->_XPAT($hdr, $arg, $pat)
    ? $nntp->_description
    : undef;
}


sub xpath {
  @_ == 2 or croak 'usage: $nntp->xpath( MESSAGE-ID )';
  my ($nntp, $mid) = @_;

  return undef
    unless $nntp->_XPATH($mid);

  my $m;
  ($m = $nntp->message) =~ s/^\d+\s+//o;
  my @p = split /\s+/, $m;

  wantarray ? @p : $p[0];
}


sub xrover {
  @_ == 2 || @_ == 3 or croak 'usage: $nntp->xrover( MESSAGE-SPEC )';
  my $nntp = shift;
  my $arg  = _msg_arg(@_);

  $nntp->_XROVER($arg)
    ? $nntp->_description
    : undef;
}


sub date {
  @_ == 1 or croak 'usage: $nntp->date()';
  my $nntp = shift;

  $nntp->_DATE
    && $nntp->message =~ /(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/
    ? timegm($6, $5, $4, $3, $2 - 1, $1 - 1900)
    : undef;
}


##
## Private subroutines
##


sub _msg_arg {
  my $spec = shift;
  my $arg  = "";

  if (@_) {
    carp "Depriciated passing of two message numbers, " . "pass a reference"
      if $^W;
    $spec = [$spec, $_[0]];
  }

  if (defined $spec) {
    if (ref($spec)) {
      $arg = $spec->[0];
      if (defined $spec->[1]) {
        $arg .= "-"
          if $spec->[1] != $spec->[0];
        $arg .= $spec->[1]
          if $spec->[1] > $spec->[0];
      }
    }
    else {
      $arg = $spec;
    }
  }

  $arg;
}


sub _timestr {
  my $time = shift;
  my @g    = reverse((gmtime($time))[0 .. 5]);
  $g[1] += 1;
  $g[0] %= 100;
  sprintf "%02d%02d%02d %02d%02d%02d GMT", @g;
}


sub _grouplist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return undef;

  my $hash = {};
  my $ln;

  foreach $ln (@$arr) {
    my @a = split(/[\s\n]+/, $ln);
    $hash->{$a[0]} = [@a[1, 2, 3]];
  }

  $hash;
}


sub _fieldlist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return undef;

  my $hash = {};
  my $ln;

  foreach $ln (@$arr) {
    my @a = split(/[\t\n]/, $ln);
    my $m = shift @a;
    $hash->{$m} = [@a];
  }

  $hash;
}


sub _articlelist {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot;

  chomp(@$arr)
    if $arr;

  $arr;
}


sub _description {
  my $nntp = shift;
  my $arr  = $nntp->read_until_dot
    or return undef;

  my $hash = {};
  my $ln;

  foreach $ln (@$arr) {
    chomp($ln);

    $hash->{$1} = $ln
      if $ln =~ s/^\s*(\S+)\s*//o;
  }

  $hash;

}

##
## The commands
##


sub _ARTICLE  { shift->command('ARTICLE',  @_)->response == CMD_OK }
sub _AUTHINFO { shift->command('AUTHINFO', @_)->response }
sub _BODY     { shift->command('BODY',     @_)->response == CMD_OK }
sub _DATE      { shift->command('DATE')->response == CMD_INFO }
sub _GROUP     { shift->command('GROUP', @_)->response == CMD_OK }
sub _HEAD      { shift->command('HEAD', @_)->response == CMD_OK }
sub _HELP      { shift->command('HELP', @_)->response == CMD_INFO }
sub _IHAVE     { shift->command('IHAVE', @_)->response == CMD_MORE }
sub _LAST      { shift->command('LAST')->response == CMD_OK }
sub _LIST      { shift->command('LIST', @_)->response == CMD_OK }
sub _LISTGROUP { shift->command('LISTGROUP', @_)->response == CMD_OK }
sub _NEWGROUPS { shift->command('NEWGROUPS', @_)->response == CMD_OK }
sub _NEWNEWS   { shift->command('NEWNEWS', @_)->response == CMD_OK }
sub _NEXT      { shift->command('NEXT')->response == CMD_OK }
sub _POST      { shift->command('POST', @_)->response == CMD_MORE }
sub _QUIT      { shift->command('QUIT', @_)->response == CMD_OK }
sub _SLAVE     { shift->command('SLAVE', @_)->response == CMD_OK }
sub _STAT      { shift->command('STAT', @_)->response == CMD_OK }
sub _MODE      { shift->command('MODE', @_)->response == CMD_OK }
sub _XGTITLE   { shift->command('XGTITLE', @_)->response == CMD_OK }
sub _XHDR      { shift->command('XHDR', @_)->response == CMD_OK }
sub _XPAT      { shift->command('XPAT', @_)->response == CMD_OK }
sub _XPATH     { shift->command('XPATH', @_)->response == CMD_OK }
sub _XOVER     { shift->command('XOVER', @_)->response == CMD_OK }
sub _XROVER    { shift->command('XROVER', @_)->response == CMD_OK }
sub _XTHREAD   { shift->unsupported }
sub _XSEARCH   { shift->unsupported }
sub _XINDEX    { shift->unsupported }

##
## IO/perl methods
##


sub DESTROY {
  my $nntp = shift;
  defined(fileno($nntp)) && $nntp->quit;
}


1;

__END__

=head1 NAME

Net::NNTP - NNTP Client class

=head1 SYNOPSIS

    use Net::NNTP;

    $nntp = Net::NNTP->new("some.host.name");
    $nntp->quit;

=head1 DESCRIPTION

C<Net::NNTP> is a class implementing a simple NNTP client in Perl as described
in RFC977.

The Net::NNTP class is a subclass of Net::Cmd and IO::Socket::INET.

=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ])

This is the constructor for a new Net::NNTP object. C<HOST> is the
name of the remote host to which a NNTP connection is required. If not
given then it may be passed as the C<Host> option described below. If no host is passed
then two environment variables are checked, first C<NNTPSERVER> then
C<NEWSHOST>, then C<Net::Config> is checked, and if a host is not found
then C<news> is used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - NNTP host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
NNTP server, a value of zero will cause all IO operations to block.
(default: 120)

B<Debug> - Enable the printing of debugging information to STDERR

B<Reader> - If the remote server is INN then initially the connection
will be to nnrpd, by default C<Net::NNTP> will issue a C<MODE READER> command
so that the remote server becomes innd. If the C<Reader> option is given
with a value of zero, then this command will not be sent and the
connection will be left talking to nnrpd.

B<LocalAddr> - If multiple IP addresses are present on the client host
with a valid route to the destination, you can specify the address your
C<Net::NNTP> connects from and this way override the operating system's
pick.

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::NNTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote NNTP server in addition to the methods
documented here.

=over 4

=item article ( [ MSGID|MSGNUM ], [FH] )

Retrieve the header, a blank line, then the body (text) of the
specified article. 

If C<FH> is specified then it is expected to be a valid filehandle
and the result will be printed to it, on success a true value will be
returned. If C<FH> is not specified then the return value, on success,
will be a reference to an array containing the article requested, each
entry in the array will contain one line of the article.

If no arguments are passed then the current article in the currently
selected newsgroup is fetched.

C<MSGNUM> is a numeric id of an article in the current newsgroup, and
will change the current article pointer.  C<MSGID> is the message id of
an article as shown in that article's header.  It is anticipated that the
client will obtain the C<MSGID> from a list provided by the C<newnews>
command, from references contained within another article, or from the
message-id provided in the response to some other commands.

If there is an error then C<undef> will be returned.

=item body ( [ MSGID|MSGNUM ], [FH] )

Like C<article> but only fetches the body of the article.

=item head ( [ MSGID|MSGNUM ], [FH] )

Like C<article> but only fetches the headers for the article.

=item articlefh ( [ MSGID|MSGNUM ] )

=item bodyfh ( [ MSGID|MSGNUM ] )

=item headfh ( [ MSGID|MSGNUM ] )

These are similar to article(), body() and head(), but rather than
returning the requested data directly, they return a tied filehandle
from which to read the article.

=item nntpstat ( [ MSGID|MSGNUM ] )

The C<nntpstat> command is similar to the C<article> command except that no
text is returned.  When selecting by message number within a group,
the C<nntpstat> command serves to set the "current article pointer" without
sending text.

Using the C<nntpstat> command to
select by message-id is valid but of questionable value, since a
selection by message-id does B<not> alter the "current article pointer".

Returns the message-id of the "current article".

=item group ( [ GROUP ] )

Set and/or get the current group. If C<GROUP> is not given then information
is returned on the current group.

In a scalar context it returns the group name.

In an array context the return value is a list containing, the number
of articles in the group, the number of the first article, the number
of the last article and the group name.

=item ihave ( MSGID [, MESSAGE ])

The C<ihave> command informs the server that the client has an article
whose id is C<MSGID>.  If the server desires a copy of that
article, and C<MESSAGE> has been given the it will be sent.

Returns I<true> if the server desires the article and C<MESSAGE> was
successfully sent,if specified.

If C<MESSAGE> is not specified then the message must be sent using the
C<datasend> and C<dataend> methods from L<Net::Cmd>

C<MESSAGE> can be either an array of lines or a reference to an array.

=item last ()

Set the "current article pointer" to the previous article in the current
newsgroup.

Returns the message-id of the article.

=item date ()

Returns the date on the remote server. This date will be in a UNIX time
format (seconds since 1970)

=item postok ()

C<postok> will return I<true> if the servers initial response indicated
that it will allow posting.

=item authinfo ( USER, PASS )

Authenticates to the server (using AUTHINFO USER / AUTHINFO PASS)
using the supplied username and password.  Please note that the
password is sent in clear text to the server.  This command should not
be used with valuable passwords unless the connection to the server is
somehow protected.

=item list ()

Obtain information about all the active newsgroups. The results is a reference
to a hash where the key is a group name and each value is a reference to an
array. The elements in this array are:- the last article number in the group,
the first article number in the group and any information flags about the group.

=item newgroups ( SINCE [, DISTRIBUTIONS ])

C<SINCE> is a time value and C<DISTRIBUTIONS> is either a distribution
pattern or a reference to a list of distribution patterns.
The result is the same as C<list>, but the
groups return will be limited to those created after C<SINCE> and, if
specified, in one of the distribution areas in C<DISTRIBUTIONS>. 

=item newnews ( SINCE [, GROUPS [, DISTRIBUTIONS ]])

C<SINCE> is a time value. C<GROUPS> is either a group pattern or a reference
to a list of group patterns. C<DISTRIBUTIONS> is either a distribution
pattern or a reference to a list of distribution patterns.

Returns a reference to a list which contains the message-ids of all news posted
after C<SINCE>, that are in a groups which matched C<GROUPS> and a
distribution which matches C<DISTRIBUTIONS>.

=item next ()

Set the "current article pointer" to the next article in the current
newsgroup.

Returns the message-id of the article.

=item post ( [ MESSAGE ] )

Post a new article to the news server. If C<MESSAGE> is specified and posting
is allowed then the message will be sent.

If C<MESSAGE> is not specified then the message must be sent using the
C<datasend> and C<dataend> methods from L<Net::Cmd>

C<MESSAGE> can be either an array of lines or a reference to an array.

The message, either sent via C<datasend> or as the C<MESSAGE>
parameter, must be in the format as described by RFC822 and must
contain From:, Newsgroups: and Subject: headers.

=item postfh ()

Post a new article to the news server using a tied filehandle.  If
posting is allowed, this method will return a tied filehandle that you
can print() the contents of the article to be posted.  You must
explicitly close() the filehandle when you are finished posting the
article, and the return value from the close() call will indicate
whether the message was successfully posted.

=item slave ()

Tell the remote server that I am not a user client, but probably another
news server.

=item quit ()

Quit the remote server and close the socket connection.

=back

=head2 Extension methods

These methods use commands that are not part of the RFC977 documentation. Some
servers may not support all of them.

=over 4

=item newsgroups ( [ PATTERN ] )

Returns a reference to a hash where the keys are all the group names which
match C<PATTERN>, or all of the groups if no pattern is specified, and
each value contains the description text for the group.

=item distributions ()

Returns a reference to a hash where the keys are all the possible
distribution names and the values are the distribution descriptions.

=item subscriptions ()

Returns a reference to a list which contains a list of groups which
are recommended for a new user to subscribe to.

=item overview_fmt ()

Returns a reference to an array which contain the names of the fields returned
by C<xover>.

=item active_times ()

Returns a reference to a hash where the keys are the group names and each
value is a reference to an array containing the time the groups was created
and an identifier, possibly an Email address, of the creator.

=item active ( [ PATTERN ] )

Similar to C<list> but only active groups that match the pattern are returned.
C<PATTERN> can be a group pattern.

=item xgtitle ( PATTERN )

Returns a reference to a hash where the keys are all the group names which
match C<PATTERN> and each value is the description text for the group.

=item xhdr ( HEADER, MESSAGE-SPEC )

Obtain the header field C<HEADER> for all the messages specified. 

The return value will be a reference
to a hash where the keys are the message numbers and each value contains
the text of the requested header for that message.

=item xover ( MESSAGE-SPEC )

The return value will be a reference
to a hash where the keys are the message numbers and each value contains
a reference to an array which contains the overview fields for that
message.

The names of the fields can be obtained by calling C<overview_fmt>.

=item xpath ( MESSAGE-ID )

Returns the path name to the file on the server which contains the specified
message.

=item xpat ( HEADER, PATTERN, MESSAGE-SPEC)

The result is the same as C<xhdr> except the is will be restricted to
headers where the text of the header matches C<PATTERN>

=item xrover

The XROVER command returns reference information for the article(s)
specified.

Returns a reference to a HASH where the keys are the message numbers and the
values are the References: lines from the articles

=item listgroup ( [ GROUP ] )

Returns a reference to a list of all the active messages in C<GROUP>, or
the current group if C<GROUP> is not specified.

=item reader

Tell the server that you are a reader and not another server.

This is required by some servers. For example if you are connecting to
an INN server and you have transfer permission your connection will
be connected to the transfer daemon, not the NNTP daemon. Issuing
this command will cause the transfer daemon to hand over control
to the NNTP daemon.

Some servers do not understand this command, but issuing it and ignoring
the response is harmless.

=back

=head1 UNSUPPORTED

The following NNTP command are unsupported by the package, and there are
no plans to do so.

    AUTHINFO GENERIC
    XTHREAD
    XSEARCH
    XINDEX

=head1 DEFINITIONS

=over 4

=item MESSAGE-SPEC

C<MESSAGE-SPEC> is either a single message-id, a single message number, or
a reference to a list of two message numbers.

If C<MESSAGE-SPEC> is a reference to a list of two message numbers and the
second number in a range is less than or equal to the first then the range
represents all messages in the group after the first message number.

B<NOTE> For compatibility reasons only with earlier versions of Net::NNTP
a message spec can be passed as a list of two numbers, this is deprecated
and a reference to the list should now be passed

=item PATTERN

The C<NNTP> protocol uses the C<WILDMAT> format for patterns.
The WILDMAT format was first developed by Rich Salz based on
the format used in the UNIX "find" command to articulate
file names. It was developed to provide a uniform mechanism
for matching patterns in the same manner that the UNIX shell
matches filenames.

Patterns are implicitly anchored at the
beginning and end of each string when testing for a match.

There are five pattern matching operations other than a strict
one-to-one match between the pattern and the source to be
checked for a match.

The first is an asterisk C<*> to match any sequence of zero or more
characters.

The second is a question mark C<?> to match any single character. The
third specifies a specific set of characters.

The set is specified as a list of characters, or as a range of characters
where the beginning and end of the range are separated by a minus (or dash)
character, or as any combination of lists and ranges. The dash can
also be included in the set as a character it if is the beginning
or end of the set. This set is enclosed in square brackets. The
close square bracket C<]> may be used in a set if it is the first
character in the set.

The fourth operation is the same as the
logical not of the third operation and is specified the same
way as the third with the addition of a caret character C<^> at
the beginning of the test string just inside the open square
bracket.

The final operation uses the backslash character to
invalidate the special meaning of an open square bracket C<[>,
the asterisk, backslash or the question mark. Two backslashes in
sequence will result in the evaluation of the backslash as a
character with no special meaning.

=over 4

=item Examples

=item C<[^]-]>

matches any single character other than a close square
bracket or a minus sign/dash.

=item C<*bdc>

matches any string that ends with the string "bdc"
including the string "bdc" (without quotes).

=item C<[0-9a-zA-Z]>

matches any single printable alphanumeric ASCII character.

=item C<a??d>

matches any four character string which begins
with a and ends with d.

=back

=back

=head1 SEE ALSO

L<Net::Cmd>

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1995-1997 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                       usr/share/perl/5.20.2/Net/Netrc.pm                                                                  0100644 0000000 0000000 00000016312 12744441327 015020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::Netrc.pm
#
# Copyright (c) 1995-1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Netrc;

use Carp;
use strict;
use FileHandle;
use vars qw($VERSION $TESTING);

$VERSION = "2.14";

my %netrc = ();


sub _readrc {
  my $host = shift;
  my ($home, $file);

  if ($^O eq "MacOS") {
    $home = $ENV{HOME} || `pwd`;
    chomp($home);
    $file = ($home =~ /:$/ ? $home . "netrc" : $home . ":netrc");
  }
  else {

    # Some OS's don't have "getpwuid", so we default to $ENV{HOME}
    $home = eval { (getpwuid($>))[7] } || $ENV{HOME};
    $home ||= $ENV{HOMEDRIVE} . ($ENV{HOMEPATH} || '') if defined $ENV{HOMEDRIVE};
    if (-e $home . "/.netrc") {
      $file = $home . "/.netrc";
    }
    elsif (-e $home . "/_netrc") {
      $file = $home . "/_netrc";
    }
    else {
      return unless $TESTING;
    }
  }

  my ($login, $pass, $acct) = (undef, undef, undef);
  my $fh;
  local $_;

  $netrc{default} = undef;

  # OS/2 and Win32 do not handle stat in a way compatible with this check :-(
  unless ($^O eq 'os2'
    || $^O eq 'MSWin32'
    || $^O eq 'MacOS'
    || $^O =~ /^cygwin/)
  {
    my @stat = stat($file);

    if (@stat) {
      if ($stat[2] & 077) {
        carp "Bad permissions: $file";
        return;
      }
      if ($stat[4] != $<) {
        carp "Not owner: $file";
        return;
      }
    }
  }

  if ($fh = FileHandle->new($file, "r")) {
    my ($mach, $macdef, $tok, @tok) = (0, 0);

    while (<$fh>) {
      undef $macdef if /\A\n\Z/;

      if ($macdef) {
        push(@$macdef, $_);
        next;
      }

      s/^\s*//;
      chomp;

      while (length && s/^("((?:[^"]+|\\.)*)"|((?:[^\\\s]+|\\.)*))\s*//) {
        (my $tok = $+) =~ s/\\(.)/$1/g;
        push(@tok, $tok);
      }

    TOKEN:
      while (@tok) {
        if ($tok[0] eq "default") {
          shift(@tok);
          $mach = bless {};
          $netrc{default} = [$mach];

          next TOKEN;
        }

        last TOKEN
          unless @tok > 1;

        $tok = shift(@tok);

        if ($tok eq "machine") {
          my $host = shift @tok;
          $mach = bless {machine => $host};

          $netrc{$host} = []
            unless exists($netrc{$host});
          push(@{$netrc{$host}}, $mach);
        }
        elsif ($tok =~ /^(login|password|account)$/) {
          next TOKEN unless $mach;
          my $value = shift @tok;

          # Following line added by rmerrell to remove '/' escape char in .netrc
          $value =~ s/\/\\/\\/g;
          $mach->{$1} = $value;
        }
        elsif ($tok eq "macdef") {
          next TOKEN unless $mach;
          my $value = shift @tok;
          $mach->{macdef} = {}
            unless exists $mach->{macdef};
          $macdef = $mach->{machdef}{$value} = [];
        }
      }
    }
    $fh->close();
  }
}


sub lookup {
  my ($pkg, $mach, $login) = @_;

  _readrc()
    unless exists $netrc{default};

  $mach ||= 'default';
  undef $login
    if $mach eq 'default';

  if (exists $netrc{$mach}) {
    if (defined $login) {
      my $m;
      foreach $m (@{$netrc{$mach}}) {
        return $m
          if (exists $m->{login} && $m->{login} eq $login);
      }
      return undef;
    }
    return $netrc{$mach}->[0];
  }

  return $netrc{default}->[0]
    if defined $netrc{default};

  return undef;
}


sub login {
  my $me = shift;

  exists $me->{login}
    ? $me->{login}
    : undef;
}


sub account {
  my $me = shift;

  exists $me->{account}
    ? $me->{account}
    : undef;
}


sub password {
  my $me = shift;

  exists $me->{password}
    ? $me->{password}
    : undef;
}


sub lpa {
  my $me = shift;
  ($me->login, $me->password, $me->account);
}

1;

__END__

=head1 NAME

Net::Netrc - OO interface to users netrc file

=head1 SYNOPSIS

    use Net::Netrc;

    $mach = Net::Netrc->lookup('some.machine');
    $login = $mach->login;
    ($login, $password, $account) = $mach->lpa;

=head1 DESCRIPTION

C<Net::Netrc> is a class implementing a simple interface to the .netrc file
used as by the ftp program.

C<Net::Netrc> also implements security checks just like the ftp program,
these checks are, first that the .netrc file must be owned by the user and 
second the ownership permissions should be such that only the owner has
read and write access. If these conditions are not met then a warning is
output and the .netrc file is not read.

=head1 THE .netrc FILE

The .netrc file contains login and initialization information used by the
auto-login process.  It resides in the user's home directory.  The following
tokens are recognized; they may be separated by spaces, tabs, or new-lines:

=over 4

=item machine name

Identify a remote machine name. The auto-login process searches
the .netrc file for a machine token that matches the remote machine
specified.  Once a match is made, the subsequent .netrc tokens
are processed, stopping when the end of file is reached or an-
other machine or a default token is encountered.

=item default

This is the same as machine name except that default matches
any name.  There can be only one default token, and it must be
after all machine tokens.  This is normally used as:

    default login anonymous password user@site

thereby giving the user automatic anonymous login to machines
not specified in .netrc.

=item login name

Identify a user on the remote machine.  If this token is present,
the auto-login process will initiate a login using the
specified name.

=item password string

Supply a password.  If this token is present, the auto-login
process will supply the specified string if the remote server
requires a password as part of the login process.

=item account string

Supply an additional account password.  If this token is present,
the auto-login process will supply the specified string
if the remote server requires an additional account password.

=item macdef name

Define a macro. C<Net::Netrc> only parses this field to be compatible
with I<ftp>.

=back

=head1 CONSTRUCTOR

The constructor for a C<Net::Netrc> object is not called new as it does not
really create a new object. But instead is called C<lookup> as this is
essentially what it does.

=over 4

=item lookup ( MACHINE [, LOGIN ])

Lookup and return a reference to the entry for C<MACHINE>. If C<LOGIN> is given
then the entry returned will have the given login. If C<LOGIN> is not given then
the first entry in the .netrc file for C<MACHINE> will be returned.

If a matching entry cannot be found, and a default entry exists, then a
reference to the default entry is returned.

If there is no matching entry found and there is no default defined, or
no .netrc file is found, then C<undef> is returned.

=back

=head1 METHODS

=over 4

=item login ()

Return the login id for the netrc entry

=item password ()

Return the password for the netrc entry

=item account ()

Return the account information for the netrc entry

=item lpa ()

Return a list of login, password and account information for the netrc entry

=back

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 SEE ALSO

L<Net::Netrc>
L<Net::Cmd>

=head1 COPYRIGHT

Copyright (c) 1995-1998 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/Net/POP3.pm                                                                   0100644 0000000 0000000 00000042325 12744441327 014471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::POP3.pm
#
# Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::POP3;

use strict;
use IO::Socket;
use vars qw(@ISA $VERSION $debug);
use Net::Cmd;
use Carp;
use Net::Config;

$VERSION = "2.31";

@ISA = qw(Net::Cmd IO::Socket::INET);


sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }
  my $hosts = defined $host ? [$host] : $NetConfig{pop3_hosts};
  my $obj;
  my @localport = exists $arg{ResvPort} ? (LocalPort => $arg{ResvPort}) : ();

  my $h;
  foreach $h (@{$hosts}) {
    $obj = $type->SUPER::new(
      PeerAddr => ($host = $h),
      PeerPort => $arg{Port} || 'pop3(110)',
      Proto => 'tcp',
      @localport,
      Timeout => defined $arg{Timeout}
      ? $arg{Timeout}
      : 120
      )
      and last;
  }

  return undef
    unless defined $obj;

  ${*$obj}{'net_pop3_host'} = $host;

  $obj->autoflush(1);
  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    $obj->close();
    return undef;
  }

  ${*$obj}{'net_pop3_banner'} = $obj->message;

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_pop3_host'};
}

##
## We don't want people sending me their passwords when they report problems
## now do we :-)
##


sub debug_text { $_[2] =~ /^(pass|rpop)/i ? "$1 ....\n" : $_[2]; }


sub login {
  @_ >= 1 && @_ <= 3 or croak 'usage: $pop3->login( USER, PASS )';
  my ($me, $user, $pass) = @_;

  if (@_ <= 2) {
    ($user, $pass) = $me->_lookup_credentials($user);
  }

  $me->user($user)
    and $me->pass($pass);
}


sub apop {
  @_ >= 1 && @_ <= 3 or croak 'usage: $pop3->apop( USER, PASS )';
  my ($me, $user, $pass) = @_;
  my $banner;
  my $md;

  if (eval { local $SIG{__DIE__}; require Digest::MD5 }) {
    $md = Digest::MD5->new();
  }
  elsif (eval { local $SIG{__DIE__}; require MD5 }) {
    $md = MD5->new();
  }
  else {
    carp "You need to install Digest::MD5 or MD5 to use the APOP command";
    return undef;
  }

  return undef
    unless ($banner = (${*$me}{'net_pop3_banner'} =~ /(<.*>)/)[0]);

  if (@_ <= 2) {
    ($user, $pass) = $me->_lookup_credentials($user);
  }

  $md->add($banner, $pass);

  return undef
    unless ($me->_APOP($user, $md->hexdigest));

  $me->_get_mailbox_count();
}


sub user {
  @_ == 2 or croak 'usage: $pop3->user( USER )';
  $_[0]->_USER($_[1]) ? 1 : undef;
}


sub pass {
  @_ == 2 or croak 'usage: $pop3->pass( PASS )';

  my ($me, $pass) = @_;

  return undef
    unless ($me->_PASS($pass));

  $me->_get_mailbox_count();
}


sub reset {
  @_ == 1 or croak 'usage: $obj->reset()';

  my $me = shift;

  return 0
    unless ($me->_RSET);

  if (defined ${*$me}{'net_pop3_mail'}) {
    local $_;
    foreach (@{${*$me}{'net_pop3_mail'}}) {
      delete $_->{'net_pop3_deleted'};
    }
  }
}


sub last {
  @_ == 1 or croak 'usage: $obj->last()';

  return undef
    unless $_[0]->_LAST && $_[0]->message =~ /(\d+)/;

  return $1;
}


sub top {
  @_ == 2 || @_ == 3 or croak 'usage: $pop3->top( MSGNUM [, NUMLINES ])';
  my $me = shift;

  return undef
    unless $me->_TOP($_[0], $_[1] || 0);

  $me->read_until_dot;
}


sub popstat {
  @_ == 1 or croak 'usage: $pop3->popstat()';
  my $me = shift;

  return ()
    unless $me->_STAT && $me->message =~ /(\d+)\D+(\d+)/;

  ($1 || 0, $2 || 0);
}


sub list {
  @_ == 1 || @_ == 2 or croak 'usage: $pop3->list( [ MSGNUM ] )';
  my $me = shift;

  return undef
    unless $me->_LIST(@_);

  if (@_) {
    $me->message =~ /\d+\D+(\d+)/;
    return $1 || undef;
  }

  my $info = $me->read_until_dot
    or return undef;

  my %hash = map { (/(\d+)\D+(\d+)/) } @$info;

  return \%hash;
}


sub get {
  @_ == 2 or @_ == 3 or croak 'usage: $pop3->get( MSGNUM [, FH ])';
  my $me = shift;

  return undef
    unless $me->_RETR(shift);

  $me->read_until_dot(@_);
}


sub getfh {
  @_ == 2 or croak 'usage: $pop3->getfh( MSGNUM )';
  my $me = shift;

  return unless $me->_RETR(shift);
  return $me->tied_fh;
}


sub delete {
  @_ == 2 or croak 'usage: $pop3->delete( MSGNUM )';
  my $me = shift;
  return 0 unless $me->_DELE(@_);
  ${*$me}{'net_pop3_deleted'} = 1;
}


sub uidl {
  @_ == 1 || @_ == 2 or croak 'usage: $pop3->uidl( [ MSGNUM ] )';
  my $me = shift;
  my $uidl;

  $me->_UIDL(@_)
    or return undef;
  if (@_) {
    $uidl = ($me->message =~ /\d+\s+([\041-\176]+)/)[0];
  }
  else {
    my $ref = $me->read_until_dot
      or return undef;
    my $ln;
    $uidl = {};
    foreach $ln (@$ref) {
      my ($msg, $uid) = $ln =~ /^\s*(\d+)\s+([\041-\176]+)/;
      $uidl->{$msg} = $uid;
    }
  }
  return $uidl;
}


sub ping {
  @_ == 2 or croak 'usage: $pop3->ping( USER )';
  my $me = shift;

  return () unless $me->_PING(@_) && $me->message =~ /(\d+)\D+(\d+)/;

  ($1 || 0, $2 || 0);
}


sub _lookup_credentials {
  my ($me, $user) = @_;

  require Net::Netrc;

       $user ||= eval { local $SIG{__DIE__}; (getpwuid($>))[0] }
    || $ENV{NAME}
    || $ENV{USER}
    || $ENV{LOGNAME};

  my $m = Net::Netrc->lookup(${*$me}{'net_pop3_host'}, $user);
  $m ||= Net::Netrc->lookup(${*$me}{'net_pop3_host'});

  my $pass = $m
    ? $m->password || ""
    : "";

  ($user, $pass);
}


sub _get_mailbox_count {
  my ($me) = @_;
  my $ret = ${*$me}{'net_pop3_count'} =
    ($me->message =~ /(\d+)\s+message/io) ? $1 : ($me->popstat)[0];

  $ret ? $ret : "0E0";
}


sub _STAT { shift->command('STAT'       )->response() == CMD_OK }
sub _LIST { shift->command('LIST',    @_)->response() == CMD_OK }
sub _RETR { shift->command('RETR', $_[0])->response() == CMD_OK }
sub _DELE { shift->command('DELE', $_[0])->response() == CMD_OK }
sub _NOOP { shift->command('NOOP'       )->response() == CMD_OK }
sub _RSET { shift->command('RSET'       )->response() == CMD_OK }
sub _QUIT { shift->command('QUIT'       )->response() == CMD_OK }
sub _TOP  { shift->command( 'TOP',    @_)->response() == CMD_OK }
sub _UIDL { shift->command('UIDL',    @_)->response() == CMD_OK }
sub _USER { shift->command('USER', $_[0])->response() == CMD_OK }
sub _PASS { shift->command('PASS', $_[0])->response() == CMD_OK }
sub _APOP { shift->command('APOP',    @_)->response() == CMD_OK }
sub _PING { shift->command('PING', $_[0])->response() == CMD_OK }
sub _RPOP { shift->command('RPOP', $_[0])->response() == CMD_OK }
sub _LAST { shift->command('LAST'       )->response() == CMD_OK }
sub _CAPA { shift->command('CAPA'       )->response() == CMD_OK }


sub quit {
  my $me = shift;

  $me->_QUIT;
  $me->close;
}


sub DESTROY {
  my $me = shift;

  if (defined fileno($me) and ${*$me}{'net_pop3_deleted'}) {
    $me->reset;
    $me->quit;
  }
}

##
## POP3 has weird responses, so we emulate them to look the same :-)
##


sub response {
  my $cmd  = shift;
  my $str  = $cmd->getline() or return undef;
  my $code = "500";

  $cmd->debug_print(0, $str)
    if ($cmd->debug);

  if ($str =~ s/^\+OK\s*//io) {
    $code = "200";
  }
  elsif ($str =~ s/^\+\s*//io) {
    $code = "300";
  }
  else {
    $str =~ s/^-ERR\s*//io;
  }

  ${*$cmd}{'net_cmd_resp'} = [$str];
  ${*$cmd}{'net_cmd_code'} = $code;

  substr($code, 0, 1);
}


sub capa {
  my $this = shift;
  my ($capa, %capabilities);

  # Fake a capability here
  $capabilities{APOP} = '' if ($this->banner() =~ /<.*>/);

  if ($this->_CAPA()) {
    $capabilities{CAPA} = 1;
    $capa = $this->read_until_dot();
    %capabilities = (%capabilities, map {/^\s*(\S+)\s*(.*)/} @$capa);
  }
  else {

    # Check AUTH for SASL capabilities
    if ($this->command('AUTH')->response() == CMD_OK) {
      my $mechanism = $this->read_until_dot();
      $capabilities{SASL} = join " ", map {m/([A-Z0-9_-]+)/} @{$mechanism};
    }
  }

  return ${*$this}{'net_pop3e_capabilities'} = \%capabilities;
}


sub capabilities {
  my $this = shift;

  ${*$this}{'net_pop3e_capabilities'} || $this->capa;
}


sub auth {
  my ($self, $username, $password) = @_;

  eval {
    require MIME::Base64;
    require Authen::SASL;
  } or $self->set_status(500, ["Need MIME::Base64 and Authen::SASL todo auth"]), return 0;

  my $capa       = $self->capa;
  my $mechanisms = $capa->{SASL} || 'CRAM-MD5';

  my $sasl;

  if (ref($username) and UNIVERSAL::isa($username, 'Authen::SASL')) {
    $sasl = $username;
    my $user_mech = $sasl->mechanism || '';
    my @user_mech = split(/\s+/, $user_mech);
    my %user_mech;
    @user_mech{@user_mech} = ();

    my @server_mech = split(/\s+/, $mechanisms);
    my @mech = @user_mech
      ? grep { exists $user_mech{$_} } @server_mech
      : @server_mech;
    unless (@mech) {
      $self->set_status(
        500,
        [ 'Client SASL mechanisms (',
          join(', ', @user_mech),
          ') do not match the SASL mechnism the server announces (',
          join(', ', @server_mech), ')',
        ]
      );
      return 0;
    }

    $sasl->mechanism(join(" ", @mech));
  }
  else {
    die "auth(username, password)" if not length $username;
    $sasl = Authen::SASL->new(
      mechanism => $mechanisms,
      callback  => {
        user     => $username,
        pass     => $password,
        authname => $username,
      }
    );
  }

  # We should probably allow the user to pass the host, but I don't
  # currently know and SASL mechanisms that are used by smtp that need it
  my ($hostname) = split /:/, ${*$self}{'net_pop3_host'};
  my $client = eval { $sasl->client_new('pop', $hostname, 0) };

  unless ($client) {
    my $mech = $sasl->mechanism;
    $self->set_status(
      500,
      [ " Authen::SASL failure: $@",
        '(please check if your local Authen::SASL installation',
        "supports mechanism '$mech'"
      ]
    );
    return 0;
  }

  my ($token) = $client->client_start
    or do {
    my $mech = $client->mechanism;
    $self->set_status(
      500,
      [ ' Authen::SASL failure:  $client->client_start ',
        "mechanism '$mech' hostname #$hostname#",
        $client->error
      ]
    );
    return 0;
    };

  # We don't support sasl mechanisms that encrypt the socket traffic.
  # todo that we would really need to change the ISA hierarchy
  # so we don't inherit from IO::Socket, but instead hold it in an attribute

  my @cmd = ("AUTH", $client->mechanism);
  my $code;

  push @cmd, MIME::Base64::encode_base64($token, '')
    if defined $token and length $token;

  while (($code = $self->command(@cmd)->response()) == CMD_MORE) {

    my ($token) = $client->client_step(MIME::Base64::decode_base64(($self->message)[0])) or do {
      $self->set_status(
        500,
        [ ' Authen::SASL failure:  $client->client_step ',
          "mechanism '", $client->mechanism, " hostname #$hostname#, ",
          $client->error
        ]
      );
      return 0;
    };

    @cmd = (MIME::Base64::encode_base64(defined $token ? $token : '', ''));
  }

  $code == CMD_OK;
}


sub banner {
  my $this = shift;

  return ${*$this}{'net_pop3_banner'};
}

1;

__END__

=head1 NAME

Net::POP3 - Post Office Protocol 3 Client class (RFC1939)

=head1 SYNOPSIS

    use Net::POP3;

    # Constructors
    $pop = Net::POP3->new('pop3host');
    $pop = Net::POP3->new('pop3host', Timeout => 60);

    if ($pop->login($username, $password) > 0) {
      my $msgnums = $pop->list; # hashref of msgnum => size
      foreach my $msgnum (keys %$msgnums) {
        my $msg = $pop->get($msgnum);
        print @$msg;
        $pop->delete($msgnum);
      }
    }

    $pop->quit;

=head1 DESCRIPTION

This module implements a client interface to the POP3 protocol, enabling
a perl5 application to talk to POP3 servers. This documentation assumes
that you are familiar with the POP3 protocol described in RFC1939.

A new Net::POP3 object must be created with the I<new> method. Once
this has been done, all POP3 commands are accessed via method calls
on the object.

The Net::POP3 class is a subclass of Net::Cmd and IO::Socket::INET.

=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ] )

This is the constructor for a new Net::POP3 object. C<HOST> is the
name of the remote host to which an POP3 connection is required.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. If neither is given then
the C<POP3_Hosts> specified in C<Net::Config> will be used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Host> - POP3 host to connect to. It may be a single scalar, as defined for
the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<ResvPort> - If given then the socket for the C<Net::POP3> object
will be bound to the local port given using C<bind> when the socket is
created.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
POP3 server (default: 120)

B<Debug> - Enable debugging information

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::POP3> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote POP3 server in addition to the methods
documented here.

=over 4

=item auth ( USERNAME, PASSWORD )

Attempt SASL authentication.

=item user ( USER )

Send the USER command.

=item pass ( PASS )

Send the PASS command. Returns the number of messages in the mailbox.

=item login ( [ USER [, PASS ]] )

Send both the USER and PASS commands. If C<PASS> is not given the
C<Net::POP3> uses C<Net::Netrc> to lookup the password using the host
and username. If the username is not specified then the current user name
will be used.

Returns the number of messages in the mailbox. However if there are no
messages on the server the string C<"0E0"> will be returned. This is
will give a true value in a boolean context, but zero in a numeric context.

If there was an error authenticating the user then I<undef> will be returned.

=item apop ( [ USER [, PASS ]] )

Authenticate with the server identifying as C<USER> with password C<PASS>.
Similar to L</login>, but the password is not sent in clear text.

To use this method you must have the Digest::MD5 or the MD5 module installed,
otherwise this method will return I<undef>.

=item banner ()

Return the sever's connection banner

=item capa ()

Return a reference to a hash of the capabilities of the server.  APOP
is added as a pseudo capability.  Note that I've been unable to
find a list of the standard capability values, and some appear to
be multi-word and some are not.  We make an attempt at intelligently
parsing them, but it may not be correct.

=item  capabilities ()

Just like capa, but only uses a cache from the last time we asked
the server, so as to avoid asking more than once.

=item top ( MSGNUM [, NUMLINES ] )

Get the header and the first C<NUMLINES> of the body for the message
C<MSGNUM>. Returns a reference to an array which contains the lines of text
read from the server.

=item list ( [ MSGNUM ] )

If called with an argument the C<list> returns the size of the message
in octets.

If called without arguments a reference to a hash is returned. The
keys will be the C<MSGNUM>'s of all undeleted messages and the values will
be their size in octets.

=item get ( MSGNUM [, FH ] )

Get the message C<MSGNUM> from the remote mailbox. If C<FH> is not given
then get returns a reference to an array which contains the lines of
text read from the server. If C<FH> is given then the lines returned
from the server are printed to the filehandle C<FH>.

=item getfh ( MSGNUM )

As per get(), but returns a tied filehandle.  Reading from this
filehandle returns the requested message.  The filehandle will return
EOF at the end of the message and should not be reused.

=item last ()

Returns the highest C<MSGNUM> of all the messages accessed.

=item popstat ()

Returns a list of two elements. These are the number of undeleted
elements and the size of the mbox in octets.

=item ping ( USER )

Returns a list of two elements. These are the number of new messages
and the total number of messages for C<USER>.

=item uidl ( [ MSGNUM ] )

Returns a unique identifier for C<MSGNUM> if given. If C<MSGNUM> is not
given C<uidl> returns a reference to a hash where the keys are the
message numbers and the values are the unique identifiers.

=item delete ( MSGNUM )

Mark message C<MSGNUM> to be deleted from the remote mailbox. All messages
that are marked to be deleted will be removed from the remote mailbox
when the server connection closed.

=item reset ()

Reset the status of the remote POP3 server. This includes resetting the
status of all messages to not be deleted.

=item quit ()

Quit and close the connection to the remote POP3 server. Any messages marked
as deleted will be deleted from the remote mailbox.

=back

=head1 NOTES

If a C<Net::POP3> object goes out of scope before C<quit> method is called
then the C<reset> method will called before the connection is closed. This
means that any messages marked to be deleted will not be.

=head1 SEE ALSO

L<Net::Netrc>,
L<Net::Cmd>

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1995-2003 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                           usr/share/perl/5.20.2/Net/Ping.pm                                                                   0100644 0000000 0000000 00000166127 12744441327 014654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::Ping;

require 5.002;
require Exporter;

use strict;
use vars qw(@ISA @EXPORT $VERSION
            $def_timeout $def_proto $def_factor
            $max_datasize $pingstring $hires $source_verify $syn_forking);
use Fcntl qw( F_GETFL F_SETFL O_NONBLOCK );
use Socket qw( SOCK_DGRAM SOCK_STREAM SOCK_RAW PF_INET SOL_SOCKET SO_ERROR IPPROTO_IP IP_TOS IP_TTL
               inet_aton getnameinfo NI_NUMERICHOST sockaddr_in );
use POSIX qw( ENOTCONN ECONNREFUSED ECONNRESET EINPROGRESS EWOULDBLOCK EAGAIN WNOHANG );
use FileHandle;
use Carp;
use Time::HiRes;

@ISA = qw(Exporter);
@EXPORT = qw(pingecho);
$VERSION = "2.43";

# Constants

$def_timeout = 5;           # Default timeout to wait for a reply
$def_proto = "tcp";         # Default protocol to use for pinging
$def_factor = 1.2;          # Default exponential backoff rate.
$max_datasize = 1024;       # Maximum data bytes in a packet
# The data we exchange with the server for the stream protocol
$pingstring = "pingschwingping!\n";
$source_verify = 1;         # Default is to verify source endpoint
$syn_forking = 0;

if ($^O =~ /Win32/i) {
  # Hack to avoid this Win32 spewage:
  # Your vendor has not defined POSIX macro ECONNREFUSED
  my @pairs = (ECONNREFUSED => 10061, # "Unknown Error" Special Win32 Response?
	       ENOTCONN     => 10057,
	       ECONNRESET   => 10054,
	       EINPROGRESS  => 10036,
	       EWOULDBLOCK  => 10035,
	  );
  while (my $name = shift @pairs) {
    my $value = shift @pairs;
    # When defined, these all are non-zero
    unless (eval $name) {
      no strict 'refs';
      *{$name} = defined prototype \&{$name} ? sub () {$value} : sub {$value};
    }
  }
#  $syn_forking = 1;    # XXX possibly useful in < Win2K ?
};

# h2ph "asm/socket.h"
# require "asm/socket.ph";
sub SO_BINDTODEVICE {25;}

# Description:  The pingecho() subroutine is provided for backward
# compatibility with the original Net::Ping.  It accepts a host
# name/IP and an optional timeout in seconds.  Create a tcp ping
# object and try pinging the host.  The result of the ping is returned.

sub pingecho
{
  my ($host,              # Name or IP number of host to ping
      $timeout            # Optional timeout in seconds
      ) = @_;
  my ($p);                # A ping object

  $p = Net::Ping->new("tcp", $timeout);
  $p->ping($host);        # Going out of scope closes the connection
}

# Description:  The new() method creates a new ping object.  Optional
# parameters may be specified for the protocol to use, the timeout in
# seconds and the size in bytes of additional data which should be
# included in the packet.
#   After the optional parameters are checked, the data is constructed
# and a socket is opened if appropriate.  The object is returned.

sub new
{
  my ($this,
      $proto,             # Optional protocol to use for pinging
      $timeout,           # Optional timeout in seconds
      $data_size,         # Optional additional bytes of data
      $device,            # Optional device to use
      $tos,               # Optional ToS to set
      $ttl,               # Optional TTL to set
      ) = @_;
  my  $class = ref($this) || $this;
  my  $self = {};
  my ($cnt,               # Count through data bytes
      $min_datasize       # Minimum data bytes required
      );

  bless($self, $class);

  $proto = $def_proto unless $proto;          # Determine the protocol
  croak('Protocol for ping must be "icmp", "udp", "tcp", "syn", "stream", or "external"')
    unless $proto =~ m/^(icmp|udp|tcp|syn|stream|external)$/;
  $self->{"proto"} = $proto;

  $timeout = $def_timeout unless $timeout;    # Determine the timeout
  croak("Default timeout for ping must be greater than 0 seconds")
    if $timeout <= 0;
  $self->{"timeout"} = $timeout;

  $self->{"device"} = $device;

  $self->{"tos"} = $tos;

  if ($self->{"proto"} eq 'icmp') {
    croak('TTL must be from 0 to 255')
      if ($ttl && ($ttl < 0 || $ttl > 255));
    $self->{"ttl"} = $ttl;
  }

  $min_datasize = ($proto eq "udp") ? 1 : 0;  # Determine data size
  $data_size = $min_datasize unless defined($data_size) && $proto ne "tcp";
  croak("Data for ping must be from $min_datasize to $max_datasize bytes")
    if ($data_size < $min_datasize) || ($data_size > $max_datasize);
  $data_size-- if $self->{"proto"} eq "udp";  # We provide the first byte
  $self->{"data_size"} = $data_size;

  $self->{"data"} = "";                       # Construct data bytes
  for ($cnt = 0; $cnt < $self->{"data_size"}; $cnt++)
  {
    $self->{"data"} .= chr($cnt % 256);
  }

  $self->{"local_addr"} = undef;              # Don't bind by default
  $self->{"retrans"} = $def_factor;           # Default exponential backoff rate
  $self->{"econnrefused"} = undef;            # Default Connection refused behavior

  $self->{"seq"} = 0;                         # For counting packets
  if ($self->{"proto"} eq "udp")              # Open a socket
  {
    $self->{"proto_num"} = eval { (getprotobyname('udp'))[2] } ||
      croak("Can't udp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'udp'))[2] ||
      croak("Can't get udp echo port by name");
    $self->{"fh"} = FileHandle->new();
    socket($self->{"fh"}, PF_INET, SOCK_DGRAM,
           $self->{"proto_num"}) ||
             croak("udp socket error - $!");
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak "error binding to device $self->{'device'} $!";
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
  }
  elsif ($self->{"proto"} eq "icmp")
  {
    croak("icmp ping requires root privilege") if ($> and $^O ne 'VMS' and $^O ne 'cygwin');
    $self->{"proto_num"} = eval { (getprotobyname('icmp'))[2] } ||
      croak("Can't get icmp protocol by name");
    $self->{"pid"} = $$ & 0xffff;           # Save lower 16 bits of pid
    $self->{"fh"} = FileHandle->new();
    socket($self->{"fh"}, PF_INET, SOCK_RAW, $self->{"proto_num"}) ||
      croak("icmp socket error - $!");
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak "error binding to device $self->{'device'} $!";
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
    if ($self->{'ttl'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TTL, pack("I*", $self->{'ttl'}))
        or croak "error configuring ttl to $self->{'ttl'} $!";
    }
  }
  elsif ($self->{"proto"} eq "tcp" || $self->{"proto"} eq "stream")
  {
    $self->{"proto_num"} = eval { (getprotobyname('tcp'))[2] } ||
      croak("Can't get tcp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'tcp'))[2] ||
      croak("Can't get tcp echo port by name");
    $self->{"fh"} = FileHandle->new();
  }
  elsif ($self->{"proto"} eq "syn")
  {
    $self->{"proto_num"} = eval { (getprotobyname('tcp'))[2] } ||
      croak("Can't get tcp protocol by name");
    $self->{"port_num"} = (getservbyname('echo', 'tcp'))[2] ||
      croak("Can't get tcp echo port by name");
    if ($syn_forking) {
      $self->{"fork_rd"} = FileHandle->new();
      $self->{"fork_wr"} = FileHandle->new();
      pipe($self->{"fork_rd"}, $self->{"fork_wr"});
      $self->{"fh"} = FileHandle->new();
      $self->{"good"} = {};
      $self->{"bad"} = {};
    } else {
      $self->{"wbits"} = "";
      $self->{"bad"} = {};
    }
    $self->{"syn"} = {};
    $self->{"stop_time"} = 0;
  }
  elsif ($self->{"proto"} eq "external")
  {
    # No preliminary work needs to be done.
  }

  return($self);
}

# Description: Set the local IP address from which pings will be sent.
# For ICMP and UDP pings, this calls bind() on the already-opened socket;
# for TCP pings, just saves the address to be used when the socket is
# opened.  Returns non-zero if successful; croaks on error.
sub bind
{
  my ($self,
      $local_addr         # Name or IP number of local interface
      ) = @_;
  my ($ip                 # Packed IP number of $local_addr
      );

  croak("Usage: \$p->bind(\$local_addr)") unless @_ == 2;
  croak("already bound") if defined($self->{"local_addr"}) &&
    ($self->{"proto"} eq "udp" || $self->{"proto"} eq "icmp");

  $ip = inet_aton($local_addr);
  croak("nonexistent local address $local_addr") unless defined($ip);
  $self->{"local_addr"} = $ip; # Only used if proto is tcp

  if ($self->{"proto"} eq "udp" || $self->{"proto"} eq "icmp")
  {
  CORE::bind($self->{"fh"}, sockaddr_in(0, $ip)) ||
    croak("$self->{'proto'} bind error - $!");
  }
  elsif (($self->{"proto"} ne "tcp") && ($self->{"proto"} ne "syn"))
  {
    croak("Unknown protocol \"$self->{proto}\" in bind()");
  }

  return 1;
}

# Description: A select() wrapper that compensates for platform
# peculiarities.
sub mselect
{
    if ($_[3] > 0 and $^O eq 'MSWin32') {
	# On windows, select() doesn't process the message loop,
	# but sleep() will, allowing alarm() to interrupt the latter.
	# So we chop up the timeout into smaller pieces and interleave
	# select() and sleep() calls.
	my $t = $_[3];
	my $gran = 0.5;  # polling granularity in seconds
	my @args = @_;
	while (1) {
	    $gran = $t if $gran > $t;
	    my $nfound = select($_[0], $_[1], $_[2], $gran);
	    undef $nfound if $nfound == -1;
	    $t -= $gran;
	    return $nfound if $nfound or !defined($nfound) or $t <= 0;

	    sleep(0);
	    ($_[0], $_[1], $_[2]) = @args;
	}
    }
    else {
	my $nfound = select($_[0], $_[1], $_[2], $_[3]);
	undef $nfound if $nfound == -1;
	return $nfound;
    }
}

# Description: Allow UDP source endpoint comparison to be
#              skipped for those remote interfaces that do
#              not response from the same endpoint.

sub source_verify
{
  my $self = shift;
  $source_verify = 1 unless defined
    ($source_verify = ((defined $self) && (ref $self)) ? shift() : $self);
}

# Description: Set whether or not the connect
# behavior should enforce remote service
# availability as well as reachability.

sub service_check
{
  my $self = shift;
  $self->{"econnrefused"} = 1 unless defined
    ($self->{"econnrefused"} = shift());
}

sub tcp_service_check
{
  service_check(@_);
}

# Description: Set exponential backoff for retransmission.
# Should be > 1 to retain exponential properties.
# If set to 0, retransmissions are disabled.

sub retrans
{
  my $self = shift;
  $self->{"retrans"} = shift;
}

# Description: allows the module to use milliseconds as returned by
# the Time::HiRes module

$hires = 1;
sub hires
{
  my $self = shift;
  $hires = 1 unless defined
    ($hires = ((defined $self) && (ref $self)) ? shift() : $self);
}

sub time
{
  return $hires ? Time::HiRes::time() : CORE::time();
}

# Description: Sets or clears the O_NONBLOCK flag on a file handle.
sub socket_blocking_mode
{
  my ($self,
      $fh,              # the file handle whose flags are to be modified
      $block) = @_;     # if true then set the blocking
                        # mode (clear O_NONBLOCK), otherwise
                        # set the non-blocking mode (set O_NONBLOCK)

  my $flags;
  if ($^O eq 'MSWin32' || $^O eq 'VMS') {
      # FIONBIO enables non-blocking sockets on windows and vms.
      # FIONBIO is (0x80000000|(4<<16)|(ord('f')<<8)|126), as per winsock.h, ioctl.h
      my $f = 0x8004667e;
      my $v = pack("L", $block ? 0 : 1);
      ioctl($fh, $f, $v) or croak("ioctl failed: $!");
      return;
  }
  if ($flags = fcntl($fh, F_GETFL, 0)) {
    $flags = $block ? ($flags & ~O_NONBLOCK) : ($flags | O_NONBLOCK);
    if (!fcntl($fh, F_SETFL, $flags)) {
      croak("fcntl F_SETFL: $!");
    }
  } else {
    croak("fcntl F_GETFL: $!");
  }
}

# Description: Ping a host name or IP number with an optional timeout.
# First lookup the host, and return undef if it is not found.  Otherwise
# perform the specific ping method based on the protocol.  Return the
# result of the ping.

sub ping
{
  my ($self,
      $host,              # Name or IP number of host to ping
      $timeout,           # Seconds after which ping times out
      ) = @_;
  my ($ip,                # Packed IP number of $host
      $ret,               # The return value
      $ping_time,         # When ping began
      );

  croak("Usage: \$p->ping(\$host [, \$timeout])") unless @_ == 2 || @_ == 3;
  $timeout = $self->{"timeout"} unless $timeout;
  croak("Timeout must be greater than 0 seconds") if $timeout <= 0;

  $ip = inet_aton($host);
  return () unless defined($ip);      # Does host exist?

  # Dispatch to the appropriate routine.
  $ping_time = &time();
  if ($self->{"proto"} eq "external") {
    $ret = $self->ping_external($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "udp") {
    $ret = $self->ping_udp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "icmp") {
    $ret = $self->ping_icmp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "tcp") {
    $ret = $self->ping_tcp($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "stream") {
    $ret = $self->ping_stream($ip, $timeout);
  }
  elsif ($self->{"proto"} eq "syn") {
    $ret = $self->ping_syn($host, $ip, $ping_time, $ping_time+$timeout);
  } else {
    croak("Unknown protocol \"$self->{proto}\" in ping()");
  }

  return wantarray ? ($ret, &time() - $ping_time, $self->ntop($ip)) : $ret;
}

# Uses Net::Ping::External to do an external ping.
sub ping_external {
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
     ) = @_;

  eval {
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    require Net::Ping::External;
  }
    or croak('Protocol "external" not supported on your system: Net::Ping::External not found');
  return Net::Ping::External::ping(ip => $ip, timeout => $timeout);
}

use constant ICMP_ECHOREPLY   => 0; # ICMP packet types
use constant ICMP_UNREACHABLE => 3; # ICMP packet types
use constant ICMP_ECHO        => 8;
use constant ICMP_TIME_EXCEEDED => 11; # ICMP packet types
use constant ICMP_PARAMETER_PROBLEM => 12; # ICMP packet types
use constant ICMP_STRUCT      => "C2 n3 A"; # Structure of a minimal ICMP packet
use constant SUBCODE          => 0; # No ICMP subcode for ECHO and ECHOREPLY
use constant ICMP_FLAGS       => 0; # No special flags for send or recv
use constant ICMP_PORT        => 0; # No port with ICMP

sub ping_icmp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  my ($saddr,             # sockaddr_in with port and ip
      $checksum,          # Checksum of ICMP packet
      $msg,               # ICMP packet to send
      $len_msg,           # Length of $msg
      $rbits,             # Read bits, filehandles for reading
      $nfound,            # Number of ready filehandles found
      $finish_time,       # Time ping should be finished
      $done,              # set to 1 when we are done
      $ret,               # Return value
      $recv_msg,          # Received message including IP header
      $from_saddr,        # sockaddr_in of sender
      $from_port,         # Port packet was sent from
      $from_ip,           # Packed IP of sender
      $from_type,         # ICMP type
      $from_subcode,      # ICMP subcode
      $from_chk,          # ICMP packet checksum
      $from_pid,          # ICMP packet id
      $from_seq,          # ICMP packet sequence
      $from_msg           # ICMP message
      );

  $self->{"seq"} = ($self->{"seq"} + 1) % 65536; # Increment sequence
  $checksum = 0;                          # No checksum for starters
  $msg = pack(ICMP_STRUCT . $self->{"data_size"}, ICMP_ECHO, SUBCODE,
              $checksum, $self->{"pid"}, $self->{"seq"}, $self->{"data"});
  $checksum = Net::Ping->checksum($msg);
  $msg = pack(ICMP_STRUCT . $self->{"data_size"}, ICMP_ECHO, SUBCODE,
              $checksum, $self->{"pid"}, $self->{"seq"}, $self->{"data"});
  $len_msg = length($msg);
  $saddr = sockaddr_in(ICMP_PORT, $ip);
  $self->{"from_ip"} = undef;
  $self->{"from_type"} = undef;
  $self->{"from_subcode"} = undef;
  send($self->{"fh"}, $msg, ICMP_FLAGS, $saddr); # Send the message

  $rbits = "";
  vec($rbits, $self->{"fh"}->fileno(), 1) = 1;
  $ret = 0;
  $done = 0;
  $finish_time = &time() + $timeout;      # Must be done by this time
  while (!$done && $timeout > 0)          # Keep trying if we have time
  {
    $nfound = mselect((my $rout=$rbits), undef, undef, $timeout); # Wait for packet
    $timeout = $finish_time - &time();    # Get remaining time
    if (!defined($nfound))                # Hmm, a strange error
    {
      $ret = undef;
      $done = 1;
    }
    elsif ($nfound)                     # Got a packet from somewhere
    {
      $recv_msg = "";
      $from_pid = -1;
      $from_seq = -1;
      $from_saddr = recv($self->{"fh"}, $recv_msg, 1500, ICMP_FLAGS);
      ($from_port, $from_ip) = sockaddr_in($from_saddr);
      ($from_type, $from_subcode) = unpack("C2", substr($recv_msg, 20, 2));
      if ($from_type == ICMP_ECHOREPLY) {
        ($from_pid, $from_seq) = unpack("n3", substr($recv_msg, 24, 4))
          if length $recv_msg >= 28;
      } else {
        ($from_pid, $from_seq) = unpack("n3", substr($recv_msg, 52, 4))
          if length $recv_msg >= 56;
      }
      $self->{"from_ip"} = $from_ip;
      $self->{"from_type"} = $from_type;
      $self->{"from_subcode"} = $from_subcode;
      next if ($from_pid != $self->{"pid"});
      next if ($from_seq != $self->{"seq"});
      if (! $source_verify || ($self->ntop($from_ip) eq $self->ntop($ip))) { # Does the packet check out?
        if ($from_type == ICMP_ECHOREPLY) {
          $ret = 1;
	        $done = 1;
        } elsif ($from_type == ICMP_UNREACHABLE) {
          $done = 1;
        } elsif ($from_type == ICMP_TIME_EXCEEDED) {
          $ret = 0;
          $done = 1;
        }
      }
    } else {     # Oops, timed out
      $done = 1;
    }
  }
  return $ret;
}

sub icmp_result {
  my ($self) = @_;
  my $ip = $self->{"from_ip"} || "";
  $ip = "\0\0\0\0" unless 4 == length $ip;
  return ($self->ntop($ip),($self->{"from_type"} || 0), ($self->{"from_subcode"} || 0));
}

# Description:  Do a checksum on the message.  Basically sum all of
# the short words and fold the high order bits into the low order bits.

sub checksum
{
  my ($class,
      $msg            # The message to checksum
      ) = @_;
  my ($len_msg,       # Length of the message
      $num_short,     # The number of short words in the message
      $short,         # One short word
      $chk            # The checksum
      );

  $len_msg = length($msg);
  $num_short = int($len_msg / 2);
  $chk = 0;
  foreach $short (unpack("n$num_short", $msg))
  {
    $chk += $short;
  }                                           # Add the odd byte in
  $chk += (unpack("C", substr($msg, $len_msg - 1, 1)) << 8) if $len_msg % 2;
  $chk = ($chk >> 16) + ($chk & 0xffff);      # Fold high into low
  return(~(($chk >> 16) + $chk) & 0xffff);    # Again and complement
}


# Description:  Perform a tcp echo ping.  Since a tcp connection is
# host specific, we have to open and close each connection here.  We
# can't just leave a socket open.  Because of the robust nature of
# tcp, it will take a while before it gives up trying to establish a
# connection.  Therefore, we use select() on a non-blocking socket to
# check against our timeout.  No data bytes are actually
# sent since the successful establishment of a connection is proof
# enough of the reachability of the remote host.  Also, tcp is
# expensive and doesn't need our help to add to the overhead.

sub ping_tcp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;
  my ($ret                # The return value
      );

  $! = 0;
  $ret = $self -> tcp_connect( $ip, $timeout);
  if (!$self->{"econnrefused"} &&
      $! == ECONNREFUSED) {
    $ret = 1;  # "Connection refused" means reachable
  }
  $self->{"fh"}->close();
  return $ret;
}

sub tcp_connect
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which connect times out
      ) = @_;
  my ($saddr);            # Packed IP and Port

  $saddr = sockaddr_in($self->{"port_num"}, $ip);

  my $ret = 0;            # Default to unreachable

  my $do_socket = sub {
    socket($self->{"fh"}, PF_INET, SOCK_STREAM, $self->{"proto_num"}) ||
      croak("tcp socket error - $!");
    if (defined $self->{"local_addr"} &&
        !CORE::bind($self->{"fh"}, sockaddr_in(0, $self->{"local_addr"}))) {
      croak("tcp bind error - $!");
    }
    if ($self->{'device'}) {
      setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
        or croak("error binding to device $self->{'device'} $!");
    }
    if ($self->{'tos'}) {
      setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
        or croak "error configuring tos to $self->{'tos'} $!";
    }
  };
  my $do_connect = sub {
    $self->{"ip"} = $ip;
    # ECONNREFUSED is 10061 on MSWin32. If we pass it as child error through $?,
    # we'll get (10061 & 255) = 77, so we cannot check it in the parent process.
    return ($ret = connect($self->{"fh"}, $saddr) || ($! == ECONNREFUSED && !$self->{"econnrefused"}));
  };
  my $do_connect_nb = sub {
    # Set O_NONBLOCK property on filehandle
    $self->socket_blocking_mode($self->{"fh"}, 0);

    # start the connection attempt
    if (!connect($self->{"fh"}, $saddr)) {
      if ($! == ECONNREFUSED) {
        $ret = 1 unless $self->{"econnrefused"};
      } elsif ($! != EINPROGRESS && ($^O ne 'MSWin32' || $! != EWOULDBLOCK)) {
        # EINPROGRESS is the expected error code after a connect()
        # on a non-blocking socket.  But if the kernel immediately
        # determined that this connect() will never work,
        # Simply respond with "unreachable" status.
        # (This can occur on some platforms with errno
        # EHOSTUNREACH or ENETUNREACH.)
        return 0;
      } else {
        # Got the expected EINPROGRESS.
        # Just wait for connection completion...
        my ($wbits, $wout, $wexc);
        $wout = $wexc = $wbits = "";
        vec($wbits, $self->{"fh"}->fileno, 1) = 1;

        my $nfound = mselect(undef,
			    ($wout = $wbits),
			    ($^O eq 'MSWin32' ? ($wexc = $wbits) : undef),
			    $timeout);
        warn("select: $!") unless defined $nfound;

        if ($nfound && vec($wout, $self->{"fh"}->fileno, 1)) {
          # the socket is ready for writing so the connection
          # attempt completed. test whether the connection
          # attempt was successful or not

          if (getpeername($self->{"fh"})) {
            # Connection established to remote host
            $ret = 1;
          } else {
            # TCP ACK will never come from this host
            # because there was an error connecting.

            # This should set $! to the correct error.
            my $char;
            sysread($self->{"fh"},$char,1);
            $! = ECONNREFUSED if ($! == EAGAIN && $^O =~ /cygwin/i);

            $ret = 1 if (!$self->{"econnrefused"}
                         && $! == ECONNREFUSED);
          }
        } else {
          # the connection attempt timed out (or there were connect
	  # errors on Windows)
	  if ($^O =~ 'MSWin32') {
	      # If the connect will fail on a non-blocking socket,
	      # winsock reports ECONNREFUSED as an exception, and we
	      # need to fetch the socket-level error code via getsockopt()
	      # instead of using the thread-level error code that is in $!.
	      if ($nfound && vec($wexc, $self->{"fh"}->fileno, 1)) {
		  $! = unpack("i", getsockopt($self->{"fh"}, SOL_SOCKET,
			                      SO_ERROR));
	      }
	  }
        }
      }
    } else {
      # Connection established to remote host
      $ret = 1;
    }

    # Unset O_NONBLOCK property on filehandle
    $self->socket_blocking_mode($self->{"fh"}, 1);
    $self->{"ip"} = $ip;
    return $ret;
  };

  if ($syn_forking) {
    # Buggy Winsock API doesn't allow nonblocking connect.
    # Hence, if our OS is Windows, we need to create a separate
    # process to do the blocking connect attempt.
    # XXX Above comments are not true at least for Win2K, where
    # nonblocking connect works.

    $| = 1; # Clear buffer prior to fork to prevent duplicate flushing.
    $self->{'tcp_chld'} = fork;
    if (!$self->{'tcp_chld'}) {
      if (!defined $self->{'tcp_chld'}) {
        # Fork did not work
        warn "Fork error: $!";
        return 0;
      }
      &{ $do_socket }();

      # Try a slow blocking connect() call
      # and report the status to the parent.
      if ( &{ $do_connect }() ) {
        $self->{"fh"}->close();
        # No error
        exit 0;
      } else {
        # Pass the error status to the parent
        # Make sure that $! <= 255
        exit($! <= 255 ? $! : 255);
      }
    }

    &{ $do_socket }();

    my $patience = &time() + $timeout;

    my ($child, $child_errno);
    $? = 0; $child_errno = 0;
    # Wait up to the timeout
    # And clean off the zombie
    do {
      $child = waitpid($self->{'tcp_chld'}, &WNOHANG());
      $child_errno = $? >> 8;
      select(undef, undef, undef, 0.1);
    } while &time() < $patience && $child != $self->{'tcp_chld'};

    if ($child == $self->{'tcp_chld'}) {
      if ($self->{"proto"} eq "stream") {
        # We need the socket connected here, in parent
        # Should be safe to connect because the child finished
        # within the timeout
        &{ $do_connect }();
      }
      # $ret cannot be set by the child process
      $ret = !$child_errno;
    } else {
      # Time must have run out.
      # Put that choking client out of its misery
      kill "KILL", $self->{'tcp_chld'};
      # Clean off the zombie
      waitpid($self->{'tcp_chld'}, 0);
      $ret = 0;
    }
    delete $self->{'tcp_chld'};
    $! = $child_errno;
  } else {
    # Otherwise don't waste the resources to fork

    &{ $do_socket }();

    &{ $do_connect_nb }();
  }

  return $ret;
}

sub DESTROY {
  my $self = shift;
  if ($self->{'proto'} eq 'tcp' &&
      $self->{'tcp_chld'}) {
    # Put that choking client out of its misery
    kill "KILL", $self->{'tcp_chld'};
    # Clean off the zombie
    waitpid($self->{'tcp_chld'}, 0);
  }
}

# This writes the given string to the socket and then reads it
# back.  It returns 1 on success, 0 on failure.
sub tcp_echo
{
  my $self = shift;
  my $timeout = shift;
  my $pingstring = shift;

  my $ret = undef;
  my $time = &time();
  my $wrstr = $pingstring;
  my $rdstr = "";

  eval <<'EOM';
    do {
      my $rin = "";
      vec($rin, $self->{"fh"}->fileno(), 1) = 1;

      my $rout = undef;
      if($wrstr) {
        $rout = "";
        vec($rout, $self->{"fh"}->fileno(), 1) = 1;
      }

      if(mselect($rin, $rout, undef, ($time + $timeout) - &time())) {

        if($rout && vec($rout,$self->{"fh"}->fileno(),1)) {
          my $num = syswrite($self->{"fh"}, $wrstr, length $wrstr);
          if($num) {
            # If it was a partial write, update and try again.
            $wrstr = substr($wrstr,$num);
          } else {
            # There was an error.
            $ret = 0;
          }
        }

        if(vec($rin,$self->{"fh"}->fileno(),1)) {
          my $reply;
          if(sysread($self->{"fh"},$reply,length($pingstring)-length($rdstr))) {
            $rdstr .= $reply;
            $ret = 1 if $rdstr eq $pingstring;
          } else {
            # There was an error.
            $ret = 0;
          }
        }

      }
    } until &time() > ($time + $timeout) || defined($ret);
EOM

  return $ret;
}




# Description: Perform a stream ping.  If the tcp connection isn't
# already open, it opens it.  It then sends some data and waits for
# a reply.  It leaves the stream open on exit.

sub ping_stream
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  # Open the stream if it's not already open
  if(!defined $self->{"fh"}->fileno()) {
    $self->tcp_connect($ip, $timeout) or return 0;
  }

  croak "tried to switch servers while stream pinging"
    if $self->{"ip"} ne $ip;

  return $self->tcp_echo($timeout, $pingstring);
}

# Description: opens the stream.  You would do this if you want to
# separate the overhead of opening the stream from the first ping.

sub open
{
  my ($self,
      $host,              # Host or IP address
      $timeout            # Seconds after which open times out
      ) = @_;

  my ($ip);               # Packed IP number of the host
  $ip = inet_aton($host);
  $timeout = $self->{"timeout"} unless $timeout;

  if($self->{"proto"} eq "stream") {
    if(defined($self->{"fh"}->fileno())) {
      croak("socket is already open");
    } else {
      $self->tcp_connect($ip, $timeout);
    }
  }
}


# Description:  Perform a udp echo ping.  Construct a message of
# at least the one-byte sequence number and any additional data bytes.
# Send the message out and wait for a message to come back.  If we
# get a message, make sure all of its parts match.  If they do, we are
# done.  Otherwise go back and wait for the message until we run out
# of time.  Return the result of our efforts.

use constant UDP_FLAGS => 0; # Nothing special on send or recv
sub ping_udp
{
  my ($self,
      $ip,                # Packed IP number of the host
      $timeout            # Seconds after which ping times out
      ) = @_;

  my ($saddr,             # sockaddr_in with port and ip
      $ret,               # The return value
      $msg,               # Message to be echoed
      $finish_time,       # Time ping should be finished
      $flush,             # Whether socket needs to be disconnected
      $connect,           # Whether socket needs to be connected
      $done,              # Set to 1 when we are done pinging
      $rbits,             # Read bits, filehandles for reading
      $nfound,            # Number of ready filehandles found
      $from_saddr,        # sockaddr_in of sender
      $from_msg,          # Characters echoed by $host
      $from_port,         # Port message was echoed from
      $from_ip            # Packed IP number of sender
      );

  $saddr = sockaddr_in($self->{"port_num"}, $ip);
  $self->{"seq"} = ($self->{"seq"} + 1) % 256;    # Increment sequence
  $msg = chr($self->{"seq"}) . $self->{"data"};   # Add data if any

  if ($self->{"connected"}) {
    if ($self->{"connected"} ne $saddr) {
      # Still connected to wrong destination.
      # Need to flush out the old one.
      $flush = 1;
    }
  } else {
    # Not connected yet.
    # Need to connect() before send()
    $connect = 1;
  }

  # Have to connect() and send() instead of sendto()
  # in order to pick up on the ECONNREFUSED setting
  # from recv() or double send() errno as utilized in
  # the concept by rdw @ perlmonks.  See:
  # http://perlmonks.thepen.com/42898.html
  if ($flush) {
    # Need to socket() again to flush the descriptor
    # This will disconnect from the old saddr.
    socket($self->{"fh"}, PF_INET, SOCK_DGRAM,
           $self->{"proto_num"});
  }
  # Connect the socket if it isn't already connected
  # to the right destination.
  if ($flush || $connect) {
    connect($self->{"fh"}, $saddr);               # Tie destination to socket
    $self->{"connected"} = $saddr;
  }
  send($self->{"fh"}, $msg, UDP_FLAGS);           # Send it

  $rbits = "";
  vec($rbits, $self->{"fh"}->fileno(), 1) = 1;
  $ret = 0;                   # Default to unreachable
  $done = 0;
  my $retrans = 0.01;
  my $factor = $self->{"retrans"};
  $finish_time = &time() + $timeout;       # Ping needs to be done by then
  while (!$done && $timeout > 0)
  {
    if ($factor > 1)
    {
      $timeout = $retrans if $timeout > $retrans;
      $retrans*= $factor; # Exponential backoff
    }
    $nfound  = mselect((my $rout=$rbits), undef, undef, $timeout); # Wait for response
    my $why = $!;
    $timeout = $finish_time - &time();   # Get remaining time

    if (!defined($nfound))  # Hmm, a strange error
    {
      $ret = undef;
      $done = 1;
    }
    elsif ($nfound)         # A packet is waiting
    {
      $from_msg = "";
      $from_saddr = recv($self->{"fh"}, $from_msg, 1500, UDP_FLAGS);
      if (!$from_saddr) {
        # For example an unreachable host will make recv() fail.
        if (!$self->{"econnrefused"} &&
            ($! == ECONNREFUSED ||
             $! == ECONNRESET)) {
          # "Connection refused" means reachable
          # Good, continue
          $ret = 1;
        }
        $done = 1;
      } else {
        ($from_port, $from_ip) = sockaddr_in($from_saddr);
        if (!$source_verify ||
            (($from_ip eq $ip) &&        # Does the packet check out?
             ($from_port == $self->{"port_num"}) &&
             ($from_msg eq $msg)))
        {
          $ret = 1;       # It's a winner
          $done = 1;
        }
      }
    }
    elsif ($timeout <= 0)              # Oops, timed out
    {
      $done = 1;
    }
    else
    {
      # Send another in case the last one dropped
      if (send($self->{"fh"}, $msg, UDP_FLAGS)) {
        # Another send worked?  The previous udp packet
        # must have gotten lost or is still in transit.
        # Hopefully this new packet will arrive safely.
      } else {
        if (!$self->{"econnrefused"} &&
            $! == ECONNREFUSED) {
          # "Connection refused" means reachable
          # Good, continue
          $ret = 1;
        }
        $done = 1;
      }
    }
  }
  return $ret;
}

# Description: Send a TCP SYN packet to host specified.
sub ping_syn
{
  my $self = shift;
  my $host = shift;
  my $ip = shift;
  my $start_time = shift;
  my $stop_time = shift;

  if ($syn_forking) {
    return $self->ping_syn_fork($host, $ip, $start_time, $stop_time);
  }

  my $fh = FileHandle->new();
  my $saddr = sockaddr_in($self->{"port_num"}, $ip);

  # Create TCP socket
  if (!socket ($fh, PF_INET, SOCK_STREAM, $self->{"proto_num"})) {
    croak("tcp socket error - $!");
  }

  if (defined $self->{"local_addr"} &&
      !CORE::bind($fh, sockaddr_in(0, $self->{"local_addr"}))) {
    croak("tcp bind error - $!");
  }

  if ($self->{'device'}) {
    setsockopt($fh, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
      or croak("error binding to device $self->{'device'} $!");
  }
  if ($self->{'tos'}) {
    setsockopt($fh, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
      or croak "error configuring tos to $self->{'tos'} $!";
  }
  # Set O_NONBLOCK property on filehandle
  $self->socket_blocking_mode($fh, 0);

  # Attempt the non-blocking connect
  # by just sending the TCP SYN packet
  if (connect($fh, $saddr)) {
    # Non-blocking, yet still connected?
    # Must have connected very quickly,
    # or else it wasn't very non-blocking.
    #warn "WARNING: Nonblocking connect connected anyway? ($^O)";
  } else {
    # Error occurred connecting.
    if ($! == EINPROGRESS || ($^O eq 'MSWin32' && $! == EWOULDBLOCK)) {
      # The connection is just still in progress.
      # This is the expected condition.
    } else {
      # Just save the error and continue on.
      # The ack() can check the status later.
      $self->{"bad"}->{$host} = $!;
    }
  }

  my $entry = [ $host, $ip, $fh, $start_time, $stop_time ];
  $self->{"syn"}->{$fh->fileno} = $entry;
  if ($self->{"stop_time"} < $stop_time) {
    $self->{"stop_time"} = $stop_time;
  }
  vec($self->{"wbits"}, $fh->fileno, 1) = 1;

  return 1;
}

sub ping_syn_fork {
  my ($self, $host, $ip, $start_time, $stop_time) = @_;

  # Buggy Winsock API doesn't allow nonblocking connect.
  # Hence, if our OS is Windows, we need to create a separate
  # process to do the blocking connect attempt.
  my $pid = fork();
  if (defined $pid) {
    if ($pid) {
      # Parent process
      my $entry = [ $host, $ip, $pid, $start_time, $stop_time ];
      $self->{"syn"}->{$pid} = $entry;
      if ($self->{"stop_time"} < $stop_time) {
        $self->{"stop_time"} = $stop_time;
      }
    } else {
      # Child process
      my $saddr = sockaddr_in($self->{"port_num"}, $ip);

      # Create TCP socket
      if (!socket ($self->{"fh"}, PF_INET, SOCK_STREAM, $self->{"proto_num"})) {
        croak("tcp socket error - $!");
      }

      if (defined $self->{"local_addr"} &&
          !CORE::bind($self->{"fh"}, sockaddr_in(0, $self->{"local_addr"}))) {
        croak("tcp bind error - $!");
      }

      if ($self->{'device'}) {
        setsockopt($self->{"fh"}, SOL_SOCKET, SO_BINDTODEVICE(), pack("Z*", $self->{'device'}))
          or croak("error binding to device $self->{'device'} $!");
      }
      if ($self->{'tos'}) {
        setsockopt($self->{"fh"}, IPPROTO_IP, IP_TOS, pack("I*", $self->{'tos'}))
          or croak "error configuring tos to $self->{'tos'} $!";
      }

      $!=0;
      # Try to connect (could take a long time)
      connect($self->{"fh"}, $saddr);
      # Notify parent of connect error status
      my $err = $!+0;
      my $wrstr = "$$ $err";
      # Force to 16 chars including \n
      $wrstr .= " "x(15 - length $wrstr). "\n";
      syswrite($self->{"fork_wr"}, $wrstr, length $wrstr);
      exit;
    }
  } else {
    # fork() failed?
    die "fork: $!";
  }
  return 1;
}

# Description: Wait for TCP ACK from host specified
# from ping_syn above.  If no host is specified, wait
# for TCP ACK from any of the hosts in the SYN queue.
sub ack
{
  my $self = shift;

  if ($self->{"proto"} eq "syn") {
    if ($syn_forking) {
      my @answer = $self->ack_unfork(shift);
      return wantarray ? @answer : $answer[0];
    }
    my $wbits = "";
    my $stop_time = 0;
    if (my $host = shift) {
      # Host passed as arg
      if (exists $self->{"bad"}->{$host}) {
        if (!$self->{"econnrefused"} &&
            $self->{"bad"}->{ $host } &&
            (($! = ECONNREFUSED)>0) &&
            $self->{"bad"}->{ $host } eq "$!") {
          # "Connection refused" means reachable
          # Good, continue
        } else {
          # ECONNREFUSED means no good
          return ();
        }
      }
      my $host_fd = undef;
      foreach my $fd (keys %{ $self->{"syn"} }) {
        my $entry = $self->{"syn"}->{$fd};
        if ($entry->[0] eq $host) {
          $host_fd = $fd;
          $stop_time = $entry->[4]
            || croak("Corrupted SYN entry for [$host]");
          last;
        }
      }
      croak("ack called on [$host] without calling ping first!")
        unless defined $host_fd;
      vec($wbits, $host_fd, 1) = 1;
    } else {
      # No $host passed so scan all hosts
      # Use the latest stop_time
      $stop_time = $self->{"stop_time"};
      # Use all the bits
      $wbits = $self->{"wbits"};
    }

    while ($wbits !~ /^\0*\z/) {
      my $timeout = $stop_time - &time();
      # Force a minimum of 10 ms timeout.
      $timeout = 0.01 if $timeout <= 0.01;

      my $winner_fd = undef;
      my $wout = $wbits;
      my $fd = 0;
      # Do "bad" fds from $wbits first
      while ($wout !~ /^\0*\z/) {
        if (vec($wout, $fd, 1)) {
          # Wipe it from future scanning.
          vec($wout, $fd, 1) = 0;
          if (my $entry = $self->{"syn"}->{$fd}) {
            if ($self->{"bad"}->{ $entry->[0] }) {
              $winner_fd = $fd;
              last;
            }
          }
        }
        $fd++;
      }

      if (defined($winner_fd) or my $nfound = mselect(undef, ($wout=$wbits), undef, $timeout)) {
        if (defined $winner_fd) {
          $fd = $winner_fd;
        } else {
          # Done waiting for one of the ACKs
          $fd = 0;
          # Determine which one
          while ($wout !~ /^\0*\z/ &&
                 !vec($wout, $fd, 1)) {
            $fd++;
          }
        }
        if (my $entry = $self->{"syn"}->{$fd}) {
          # Wipe it from future scanning.
          delete $self->{"syn"}->{$fd};
          vec($self->{"wbits"}, $fd, 1) = 0;
          vec($wbits, $fd, 1) = 0;
          if (!$self->{"econnrefused"} &&
              $self->{"bad"}->{ $entry->[0] } &&
              (($! = ECONNREFUSED)>0) &&
              $self->{"bad"}->{ $entry->[0] } eq "$!") {
            # "Connection refused" means reachable
            # Good, continue
          } elsif (getpeername($entry->[2])) {
            # Connection established to remote host
            # Good, continue
          } else {
            # TCP ACK will never come from this host
            # because there was an error connecting.

            # This should set $! to the correct error.
            my $char;
            sysread($entry->[2],$char,1);
            # Store the excuse why the connection failed.
            $self->{"bad"}->{$entry->[0]} = $!;
            if (!$self->{"econnrefused"} &&
                (($! == ECONNREFUSED) ||
                 ($! == EAGAIN && $^O =~ /cygwin/i))) {
              # "Connection refused" means reachable
              # Good, continue
            } else {
              # No good, try the next socket...
              next;
            }
          }
          # Everything passed okay, return the answer
          return wantarray ?
            ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]))
            : $entry->[0];
        } else {
          warn "Corrupted SYN entry: unknown fd [$fd] ready!";
          vec($wbits, $fd, 1) = 0;
          vec($self->{"wbits"}, $fd, 1) = 0;
        }
      } elsif (defined $nfound) {
        # Timed out waiting for ACK
        foreach my $fd (keys %{ $self->{"syn"} }) {
          if (vec($wbits, $fd, 1)) {
            my $entry = $self->{"syn"}->{$fd};
            $self->{"bad"}->{$entry->[0]} = "Timed out";
            vec($wbits, $fd, 1) = 0;
            vec($self->{"wbits"}, $fd, 1) = 0;
            delete $self->{"syn"}->{$fd};
          }
        }
      } else {
        # Weird error occurred with select()
        warn("select: $!");
        $self->{"syn"} = {};
        $wbits = "";
      }
    }
  }
  return ();
}

sub ack_unfork {
  my ($self,$host) = @_;
  my $stop_time = $self->{"stop_time"};
  if ($host) {
    # Host passed as arg
    if (my $entry = $self->{"good"}->{$host}) {
      delete $self->{"good"}->{$host};
      return ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]));
    }
  }

  my $rbits = "";
  my $timeout;

  if (keys %{ $self->{"syn"} }) {
    # Scan all hosts that are left
    vec($rbits, fileno($self->{"fork_rd"}), 1) = 1;
    $timeout = $stop_time - &time();
    # Force a minimum of 10 ms timeout.
    $timeout = 0.01 if $timeout < 0.01;
  } else {
    # No hosts left to wait for
    $timeout = 0;
  }

  if ($timeout > 0) {
    my $nfound;
    while ( keys %{ $self->{"syn"} } and
           $nfound = mselect((my $rout=$rbits), undef, undef, $timeout)) {
      # Done waiting for one of the ACKs
      if (!sysread($self->{"fork_rd"}, $_, 16)) {
        # Socket closed, which means all children are done.
        return ();
      }
      my ($pid, $how) = split;
      if ($pid) {
        # Flush the zombie
        waitpid($pid, 0);
        if (my $entry = $self->{"syn"}->{$pid}) {
          # Connection attempt to remote host is done
          delete $self->{"syn"}->{$pid};
          if (!$how || # If there was no error connecting
              (!$self->{"econnrefused"} &&
               $how == ECONNREFUSED)) {  # "Connection refused" means reachable
            if ($host && $entry->[0] ne $host) {
              # A good connection, but not the host we need.
              # Move it from the "syn" hash to the "good" hash.
              $self->{"good"}->{$entry->[0]} = $entry;
              # And wait for the next winner
              next;
            }
            return ($entry->[0], &time() - $entry->[3], $self->ntop($entry->[1]));
          }
        } else {
          # Should never happen
          die "Unknown ping from pid [$pid]";
        }
      } else {
        die "Empty response from status socket?";
      }
    }
    if (defined $nfound) {
      # Timed out waiting for ACK status
    } else {
      # Weird error occurred with select()
      warn("select: $!");
    }
  }
  if (my @synners = keys %{ $self->{"syn"} }) {
    # Kill all the synners
    kill 9, @synners;
    foreach my $pid (@synners) {
      # Wait for the deaths to finish
      # Then flush off the zombie
      waitpid($pid, 0);
    }
  }
  $self->{"syn"} = {};
  return ();
}

# Description:  Tell why the ack() failed
sub nack {
  my $self = shift;
  my $host = shift || croak('Usage> nack($failed_ack_host)');
  return $self->{"bad"}->{$host} || undef;
}

# Description:  Close the connection.

sub close
{
  my ($self) = @_;

  if ($self->{"proto"} eq "syn") {
    delete $self->{"syn"};
  } elsif ($self->{"proto"} eq "tcp") {
    # The connection will already be closed
  } elsif ($self->{"proto"} eq "external") {
    # Nothing to close
  } else {
    $self->{"fh"}->close();
  }
}

sub port_number {
   my $self = shift;
   if(@_) {
       $self->{port_num} = shift @_;
       $self->service_check(1);
   }
   return $self->{port_num};
}

sub ntop {
    my($self, $ip) = @_;

    # Vista doesn't define a inet_ntop.  It has InetNtop instead.
    # Not following ANSI... priceless.  getnameinfo() is defined
    # for Windows 2000 and later, so that may be the choice.

    # Any port will work, even undef, but this will work for now.
    # Socket warns when undef is passed in, but it still works.
    my $port = getservbyname('echo', 'udp');
    my $sockaddr = sockaddr_in $port, $ip;
    my ($error, $address) = getnameinfo($sockaddr, NI_NUMERICHOST);
    if($error) {
      croak $error;
    }
    return $address;
}

1;
__END__

=head1 NAME

Net::Ping - check a remote host for reachability

=head1 SYNOPSIS

    use Net::Ping;

    $p = Net::Ping->new();
    print "$host is alive.\n" if $p->ping($host);
    $p->close();

    $p = Net::Ping->new("icmp");
    $p->bind($my_addr); # Specify source interface of pings
    foreach $host (@host_array)
    {
        print "$host is ";
        print "NOT " unless $p->ping($host, 2);
        print "reachable.\n";
        sleep(1);
    }
    $p->close();

    $p = Net::Ping->new("tcp", 2);
    # Try connecting to the www port instead of the echo port
    $p->port_number(scalar(getservbyname("http", "tcp")));
    while ($stop_time > time())
    {
        print "$host not reachable ", scalar(localtime()), "\n"
            unless $p->ping($host);
        sleep(300);
    }
    undef($p);

    # Like tcp protocol, but with many hosts
    $p = Net::Ping->new("syn");
    $p->port_number(getservbyname("http", "tcp"));
    foreach $host (@host_array) {
      $p->ping($host);
    }
    while (($host,$rtt,$ip) = $p->ack) {
      print "HOST: $host [$ip] ACKed in $rtt seconds.\n";
    }

    # High precision syntax (requires Time::HiRes)
    $p = Net::Ping->new();
    $p->hires();
    ($ret, $duration, $ip) = $p->ping($host, 5.5);
    printf("$host [ip: $ip] is alive (packet return time: %.2f ms)\n",
            1000 * $duration)
      if $ret;
    $p->close();

    # For backward compatibility
    print "$host is alive.\n" if pingecho($host);

=head1 DESCRIPTION

This module contains methods to test the reachability of remote
hosts on a network.  A ping object is first created with optional
parameters, a variable number of hosts may be pinged multiple
times and then the connection is closed.

You may choose one of six different protocols to use for the
ping. The "tcp" protocol is the default. Note that a live remote host
may still fail to be pingable by one or more of these protocols. For
example, www.microsoft.com is generally alive but not "icmp" pingable.

With the "tcp" protocol the ping() method attempts to establish a
connection to the remote host's echo port.  If the connection is
successfully established, the remote host is considered reachable.  No
data is actually echoed.  This protocol does not require any special
privileges but has higher overhead than the "udp" and "icmp" protocols.

Specifying the "udp" protocol causes the ping() method to send a udp
packet to the remote host's echo port.  If the echoed packet is
received from the remote host and the received packet contains the
same data as the packet that was sent, the remote host is considered
reachable.  This protocol does not require any special privileges.
It should be borne in mind that, for a udp ping, a host
will be reported as unreachable if it is not running the
appropriate echo service.  For Unix-like systems see L<inetd(8)>
for more information.

If the "icmp" protocol is specified, the ping() method sends an icmp
echo message to the remote host, which is what the UNIX ping program
does.  If the echoed message is received from the remote host and
the echoed information is correct, the remote host is considered
reachable.  Specifying the "icmp" protocol requires that the program
be run as root or that the program be setuid to root.

If the "external" protocol is specified, the ping() method attempts to
use the C<Net::Ping::External> module to ping the remote host.
C<Net::Ping::External> interfaces with your system's default C<ping>
utility to perform the ping, and generally produces relatively
accurate results. If C<Net::Ping::External> if not installed on your
system, specifying the "external" protocol will result in an error.

If the "syn" protocol is specified, the ping() method will only
send a TCP SYN packet to the remote host then immediately return.
If the syn packet was sent successfully, it will return a true value,
otherwise it will return false.  NOTE: Unlike the other protocols,
the return value does NOT determine if the remote host is alive or
not since the full TCP three-way handshake may not have completed
yet.  The remote host is only considered reachable if it receives
a TCP ACK within the timeout specified.  To begin waiting for the
ACK packets, use the ack() method as explained below.  Use the
"syn" protocol instead the "tcp" protocol to determine reachability
of multiple destinations simultaneously by sending parallel TCP
SYN packets.  It will not block while testing each remote host.
demo/fping is provided in this distribution to demonstrate the
"syn" protocol as an example.
This protocol does not require any special privileges.

=head2 Functions

=over 4

=item Net::Ping->new([$proto [, $def_timeout [, $bytes [, $device [, $tos [, $ttl ]]]]]]);

Create a new ping object.  All of the parameters are optional.  $proto
specifies the protocol to use when doing a ping.  The current choices
are "tcp", "udp", "icmp", "stream", "syn", or "external".
The default is "tcp".

If a default timeout ($def_timeout) in seconds is provided, it is used
when a timeout is not given to the ping() method (below).  The timeout
must be greater than 0 and the default, if not specified, is 5 seconds.

If the number of data bytes ($bytes) is given, that many data bytes
are included in the ping packet sent to the remote host. The number of
data bytes is ignored if the protocol is "tcp".  The minimum (and
default) number of data bytes is 1 if the protocol is "udp" and 0
otherwise.  The maximum number of data bytes that can be specified is
1024.

If $device is given, this device is used to bind the source endpoint
before sending the ping packet.  I believe this only works with
superuser privileges and with udp and icmp protocols at this time.

If $tos is given, this ToS is configured into the socket.

For icmp, $ttl can be specified to set the TTL of the outgoing packet.

=item $p->ping($host [, $timeout]);

Ping the remote host and wait for a response.  $host can be either the
hostname or the IP number of the remote host.  The optional timeout
must be greater than 0 seconds and defaults to whatever was specified
when the ping object was created.  Returns a success flag.  If the
hostname cannot be found or there is a problem with the IP number, the
success flag returned will be undef.  Otherwise, the success flag will
be 1 if the host is reachable and 0 if it is not.  For most practical
purposes, undef and 0 and can be treated as the same case.  In array
context, the elapsed time as well as the string form of the ip the
host resolved to are also returned.  The elapsed time value will
be a float, as returned by the Time::HiRes::time() function, if hires()
has been previously called, otherwise it is returned as an integer.

=item $p->source_verify( { 0 | 1 } );

Allows source endpoint verification to be enabled or disabled.
This is useful for those remote destinations with multiples
interfaces where the response may not originate from the same
endpoint that the original destination endpoint was sent to.
This only affects udp and icmp protocol pings.

This is enabled by default.

=item $p->service_check( { 0 | 1 } );

Set whether or not the connect behavior should enforce
remote service availability as well as reachability.  Normally,
if the remote server reported ECONNREFUSED, it must have been
reachable because of the status packet that it reported.
With this option enabled, the full three-way tcp handshake
must have been established successfully before it will
claim it is reachable.  NOTE:  It still does nothing more
than connect and disconnect.  It does not speak any protocol
(i.e., HTTP or FTP) to ensure the remote server is sane in
any way.  The remote server CPU could be grinding to a halt
and unresponsive to any clients connecting, but if the kernel
throws the ACK packet, it is considered alive anyway.  To
really determine if the server is responding well would be
application specific and is beyond the scope of Net::Ping.
For udp protocol, enabling this option demands that the
remote server replies with the same udp data that it was sent
as defined by the udp echo service.

This affects the "udp", "tcp", and "syn" protocols.

This is disabled by default.

=item $p->tcp_service_check( { 0 | 1 } );

Deprecated method, but does the same as service_check() method.

=item $p->hires( { 0 | 1 } );

Causes this module to use Time::HiRes module, allowing milliseconds
to be returned by subsequent calls to ping().

This is disabled by default.

=item $p->bind($local_addr);

Sets the source address from which pings will be sent.  This must be
the address of one of the interfaces on the local host.  $local_addr
may be specified as a hostname or as a text IP address such as
"192.168.1.1".

If the protocol is set to "tcp", this method may be called any
number of times, and each call to the ping() method (below) will use
the most recent $local_addr.  If the protocol is "icmp" or "udp",
then bind() must be called at most once per object, and (if it is
called at all) must be called before the first call to ping() for that
object.

=item $p->open($host);

When you are using the "stream" protocol, this call pre-opens the
tcp socket.  It's only necessary to do this if you want to
provide a different timeout when creating the connection, or
remove the overhead of establishing the connection from the
first ping.  If you don't call C<open()>, the connection is
automatically opened the first time C<ping()> is called.
This call simply does nothing if you are using any protocol other
than stream.

=item $p->ack( [ $host ] );

When using the "syn" protocol, use this method to determine
the reachability of the remote host.  This method is meant
to be called up to as many times as ping() was called.  Each
call returns the host (as passed to ping()) that came back
with the TCP ACK.  The order in which the hosts are returned
may not necessarily be the same order in which they were
SYN queued using the ping() method.  If the timeout is
reached before the TCP ACK is received, or if the remote
host is not listening on the port attempted, then the TCP
connection will not be established and ack() will return
undef.  In list context, the host, the ack time, and the
dotted ip string will be returned instead of just the host.
If the optional $host argument is specified, the return
value will be pertaining to that host only.
This call simply does nothing if you are using any protocol
other than syn.

=item $p->nack( $failed_ack_host );

The reason that host $failed_ack_host did not receive a
valid ACK.  Useful to find out why when ack( $fail_ack_host )
returns a false value.

=item $p->close();

Close the network connection for this ping object.  The network
connection is also closed by "undef $p".  The network connection is
automatically closed if the ping object goes out of scope (e.g. $p is
local to a subroutine and you leave the subroutine).

=item $p->port_number([$port_number])

When called with a port number, the port number used to ping is set to
$port_number rather than using the echo port.  It also has the effect
of calling C<$p-E<gt>service_check(1)> causing a ping to return a successful
response only if that specific port is accessible.  This function returns
the value of the port that C<ping()> will connect to.

=item pingecho($host [, $timeout]);

To provide backward compatibility with the previous version of
Net::Ping, a pingecho() subroutine is available with the same
functionality as before.  pingecho() uses the tcp protocol.  The
return values and parameters are the same as described for the ping()
method.  This subroutine is obsolete and may be removed in a future
version of Net::Ping.

=back

=head1 NOTES

There will be less network overhead (and some efficiency in your
program) if you specify either the udp or the icmp protocol.  The tcp
protocol will generate 2.5 times or more traffic for each ping than
either udp or icmp.  If many hosts are pinged frequently, you may wish
to implement a small wait (e.g. 25ms or more) between each ping to
avoid flooding your network with packets.

The icmp protocol requires that the program be run as root or that it
be setuid to root.  The other protocols do not require special
privileges, but not all network devices implement tcp or udp echo.

Local hosts should normally respond to pings within milliseconds.
However, on a very congested network it may take up to 3 seconds or
longer to receive an echo packet from the remote host.  If the timeout
is set too low under these conditions, it will appear that the remote
host is not reachable (which is almost the truth).

Reachability doesn't necessarily mean that the remote host is actually
functioning beyond its ability to echo packets.  tcp is slightly better
at indicating the health of a system than icmp because it uses more
of the networking stack to respond.

Because of a lack of anything better, this module uses its own
routines to pack and unpack ICMP packets.  It would be better for a
separate module to be written which understands all of the different
kinds of ICMP packets.

=head1 INSTALL

The latest source tree is available via cvs:

  cvs -z3 -q -d \
    :pserver:anonymous@cvs.roobik.com.:/usr/local/cvsroot/freeware \
    checkout Net-Ping
  cd Net-Ping

The tarball can be created as follows:

  perl Makefile.PL ; make ; make dist

The latest Net::Ping release can be found at CPAN:

  $CPAN/modules/by-module/Net/

1) Extract the tarball

  gtar -zxvf Net-Ping-xxxx.tar.gz
  cd Net-Ping-xxxx

2) Build:

  make realclean
  perl Makefile.PL
  make
  make test

3) Install

  make install

Or install it RPM Style:

  rpm -ta SOURCES/Net-Ping-xxxx.tar.gz

  rpm -ih RPMS/noarch/perl-Net-Ping-xxxx.rpm

=head1 BUGS

For a list of known issues, visit:

https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-Ping

To report a new bug, visit:

https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net-Ping

=head1 AUTHORS

  Current maintainer:
    bbb@cpan.org (Rob Brown)

  External protocol:
    colinm@cpan.org (Colin McMillen)

  Stream protocol:
    bronson@trestle.com (Scott Bronson)

  Original pingecho():
    karrer@bernina.ethz.ch (Andreas Karrer)
    pmarquess@bfsec.bt.co.uk (Paul Marquess)

  Original Net::Ping author:
    mose@ns.ccsn.edu (Russell Mosemann)

=head1 COPYRIGHT

Copyright (c) 2002-2003, Rob Brown.  All rights reserved.

Copyright (c) 2001, Colin McMillen.  All rights reserved.

This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/perl/5.20.2/Net/SMTP.pm                                                                   0100644 0000000 0000000 00000055553 12744441327 014542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::SMTP.pm
#
# Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::SMTP;

require 5.001;

use strict;
use vars qw($VERSION @ISA);
use Socket 1.3;
use Carp;
use IO::Socket;
use Net::Cmd;
use Net::Config;

$VERSION = "2.33";

@ISA = qw(Net::Cmd IO::Socket::INET);


sub new {
  my $self = shift;
  my $type = ref($self) || $self;
  my ($host, %arg);
  if (@_ % 2) {
    $host = shift;
    %arg  = @_;
  }
  else {
    %arg  = @_;
    $host = delete $arg{Host};
  }
  my $hosts = defined $host ? $host : $NetConfig{smtp_hosts};
  my $obj;

  my $h;
  foreach $h (@{ref($hosts) ? $hosts : [$hosts]}) {
    $obj = $type->SUPER::new(
      PeerAddr => ($host = $h),
      PeerPort => $arg{Port} || 'smtp(25)',
      LocalAddr => $arg{LocalAddr},
      LocalPort => $arg{LocalPort},
      Proto     => 'tcp',
      Timeout   => defined $arg{Timeout}
      ? $arg{Timeout}
      : 120
      )
      and last;
  }

  return undef
    unless defined $obj;

  $obj->autoflush(1);

  $obj->debug(exists $arg{Debug} ? $arg{Debug} : undef);

  unless ($obj->response() == CMD_OK) {
    my $err = ref($obj) . ": " . $obj->code . " " . $obj->message;
    $obj->close();
    $@ = $err;
    return undef;
  }

  ${*$obj}{'net_smtp_exact_addr'} = $arg{ExactAddresses};
  ${*$obj}{'net_smtp_host'}       = $host;

  (${*$obj}{'net_smtp_banner'}) = $obj->message;
  (${*$obj}{'net_smtp_domain'}) = $obj->message =~ /\A\s*(\S+)/;

  unless ($obj->hello($arg{Hello} || "")) {
    my $err = ref($obj) . ": " . $obj->code . " " . $obj->message;
    $obj->close();
    $@ = $err;
    return undef;
  }

  $obj;
}


sub host {
  my $me = shift;
  ${*$me}{'net_smtp_host'};
}

##
## User interface methods
##


sub banner {
  my $me = shift;

  return ${*$me}{'net_smtp_banner'} || undef;
}


sub domain {
  my $me = shift;

  return ${*$me}{'net_smtp_domain'} || undef;
}


sub etrn {
  my $self = shift;
  defined($self->supports('ETRN', 500, ["Command unknown: 'ETRN'"]))
    && $self->_ETRN(@_);
}


sub auth {
  my ($self, $username, $password) = @_;

  eval {
    require MIME::Base64;
    require Authen::SASL;
  } or $self->set_status(500, ["Need MIME::Base64 and Authen::SASL todo auth"]), return 0;

  my $mechanisms = $self->supports('AUTH', 500, ["Command unknown: 'AUTH'"]);
  return unless defined $mechanisms;

  my $sasl;

  if (ref($username) and UNIVERSAL::isa($username, 'Authen::SASL')) {
    $sasl = $username;
    $sasl->mechanism($mechanisms);
  }
  else {
    die "auth(username, password)" if not length $username;
    $sasl = Authen::SASL->new(
      mechanism => $mechanisms,
      callback  => {
        user     => $username,
        pass     => $password,
        authname => $username,
      }
    );
  }

  # We should probably allow the user to pass the host, but I don't
  # currently know and SASL mechanisms that are used by smtp that need it
  my $client = $sasl->client_new('smtp', ${*$self}{'net_smtp_host'}, 0);
  my $str    = $client->client_start;

  # We don't support sasl mechanisms that encrypt the socket traffic.
  # todo that we would really need to change the ISA hierarchy
  # so we don't inherit from IO::Socket, but instead hold it in an attribute

  my @cmd = ("AUTH", $client->mechanism);
  my $code;

  push @cmd, MIME::Base64::encode_base64($str, '')
    if defined $str and length $str;

  while (($code = $self->command(@cmd)->response()) == CMD_MORE) {
    @cmd = (
      MIME::Base64::encode_base64(
        $client->client_step(MIME::Base64::decode_base64(($self->message)[0])), ''
      )
    );
  }

  $code == CMD_OK;
}


sub hello {
  my $me     = shift;
  my $domain = shift || "localhost.localdomain";
  my $ok     = $me->_EHLO($domain);
  my @msg    = $me->message;

  if ($ok) {
    my $h = ${*$me}{'net_smtp_esmtp'} = {};
    my $ln;
    foreach $ln (@msg) {
      $h->{uc $1} = $2
        if $ln =~ /([-\w]+)\b[= \t]*([^\n]*)/;
    }
  }
  elsif ($me->status == CMD_ERROR) {
    @msg = $me->message
      if $ok = $me->_HELO($domain);
  }

  return undef unless $ok;

  $msg[0] =~ /\A\s*(\S+)/;
  return ($1 || " ");
}


sub supports {
  my $self = shift;
  my $cmd  = uc shift;
  return ${*$self}{'net_smtp_esmtp'}->{$cmd}
    if exists ${*$self}{'net_smtp_esmtp'}->{$cmd};
  $self->set_status(@_)
    if @_;
  return;
}


sub _addr {
  my $self = shift;
  my $addr = shift;
  $addr = "" unless defined $addr;

  if (${*$self}{'net_smtp_exact_addr'}) {
    return $1 if $addr =~ /^\s*(<.*>)\s*$/s;
  }
  else {
    return $1 if $addr =~ /(<[^>]*>)/;
    $addr =~ s/^\s+|\s+$//sg;
  }

  "<$addr>";
}


sub mail {
  my $me   = shift;
  my $addr = _addr($me, shift);
  my $opts = "";

  if (@_) {
    my %opt = @_;
    my ($k, $v);

    if (exists ${*$me}{'net_smtp_esmtp'}) {
      my $esmtp = ${*$me}{'net_smtp_esmtp'};

      if (defined($v = delete $opt{Size})) {
        if (exists $esmtp->{SIZE}) {
          $opts .= sprintf " SIZE=%d", $v + 0;
        }
        else {
          carp 'Net::SMTP::mail: SIZE option not supported by host';
        }
      }

      if (defined($v = delete $opt{Return})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " RET=" . ((uc($v) eq "FULL") ? "FULL" : "HDRS");
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{Bits})) {
        if ($v eq "8") {
          if (exists $esmtp->{'8BITMIME'}) {
            $opts .= " BODY=8BITMIME";
          }
          else {
            carp 'Net::SMTP::mail: 8BITMIME option not supported by host';
          }
        }
        elsif ($v eq "binary") {
          if (exists $esmtp->{'BINARYMIME'} && exists $esmtp->{'CHUNKING'}) {
            $opts .= " BODY=BINARYMIME";
            ${*$me}{'net_smtp_chunking'} = 1;
          }
          else {
            carp 'Net::SMTP::mail: BINARYMIME option not supported by host';
          }
        }
        elsif (exists $esmtp->{'8BITMIME'} or exists $esmtp->{'BINARYMIME'}) {
          $opts .= " BODY=7BIT";
        }
        else {
          carp 'Net::SMTP::mail: 8BITMIME and BINARYMIME options not supported by host';
        }
      }

      if (defined($v = delete $opt{Transaction})) {
        if (exists $esmtp->{CHECKPOINT}) {
          $opts .= " TRANSID=" . _addr($me, $v);
        }
        else {
          carp 'Net::SMTP::mail: CHECKPOINT option not supported by host';
        }
      }

      if (defined($v = delete $opt{Envelope})) {
        if (exists $esmtp->{DSN}) {
          $v =~ s/([^\041-\176]|=|\+)/sprintf "+%02X", ord($1)/sge;
          $opts .= " ENVID=$v";
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{ENVID})) {

        # expected to be in a format as required by RFC 3461, xtext-encoded
        if (exists $esmtp->{DSN}) {
          $opts .= " ENVID=$v";
        }
        else {
          carp 'Net::SMTP::mail: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{AUTH})) {

        # expected to be in a format as required by RFC 2554,
        # rfc2821-quoted and xtext-encoded, or <>
        if (exists $esmtp->{AUTH}) {
          $v = '<>' if !defined($v) || $v eq '';
          $opts .= " AUTH=$v";
        }
        else {
          carp 'Net::SMTP::mail: AUTH option not supported by host';
        }
      }

      if (defined($v = delete $opt{XVERP})) {
        if (exists $esmtp->{'XVERP'}) {
          $opts .= " XVERP";
        }
        else {
          carp 'Net::SMTP::mail: XVERP option not supported by host';
        }
      }

      carp 'Net::SMTP::recipient: unknown option(s) ' . join(" ", keys %opt) . ' - ignored'
        if scalar keys %opt;
    }
    else {
      carp 'Net::SMTP::mail: ESMTP not supported by host - options discarded :-(';
    }
  }

  $me->_MAIL("FROM:" . $addr . $opts);
}


sub send          { my $me = shift; $me->_SEND("FROM:" . _addr($me, $_[0])) }
sub send_or_mail  { my $me = shift; $me->_SOML("FROM:" . _addr($me, $_[0])) }
sub send_and_mail { my $me = shift; $me->_SAML("FROM:" . _addr($me, $_[0])) }


sub reset {
  my $me = shift;

  $me->dataend()
    if (exists ${*$me}{'net_smtp_lastch'});

  $me->_RSET();
}


sub recipient {
  my $smtp     = shift;
  my $opts     = "";
  my $skip_bad = 0;

  if (@_ && ref($_[-1])) {
    my %opt = %{pop(@_)};
    my $v;

    $skip_bad = delete $opt{'SkipBad'};

    if (exists ${*$smtp}{'net_smtp_esmtp'}) {
      my $esmtp = ${*$smtp}{'net_smtp_esmtp'};

      if (defined($v = delete $opt{Notify})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " NOTIFY=" . join(",", map { uc $_ } @$v);
        }
        else {
          carp 'Net::SMTP::recipient: DSN option not supported by host';
        }
      }

      if (defined($v = delete $opt{ORcpt})) {
        if (exists $esmtp->{DSN}) {
          $opts .= " ORCPT=" . $v;
        }
        else {
          carp 'Net::SMTP::recipient: DSN option not supported by host';
        }
      }

      carp 'Net::SMTP::recipient: unknown option(s) ' . join(" ", keys %opt) . ' - ignored'
        if scalar keys %opt;
    }
    elsif (%opt) {
      carp 'Net::SMTP::recipient: ESMTP not supported by host - options discarded :-(';
    }
  }

  my @ok;
  my $addr;
  foreach $addr (@_) {
    if ($smtp->_RCPT("TO:" . _addr($smtp, $addr) . $opts)) {
      push(@ok, $addr) if $skip_bad;
    }
    elsif (!$skip_bad) {
      return 0;
    }
  }

  return $skip_bad ? @ok : 1;
}

BEGIN {
  *to  = \&recipient;
  *cc  = \&recipient;
  *bcc = \&recipient;
}


sub data {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    carp 'Net::SMTP::data: CHUNKING extension in use, must call bdat instead';
  }
  else {
    my $ok = $me->_DATA() && $me->datasend(@_);

    $ok && @_
      ? $me->dataend
      : $ok;
  }
}


sub bdat {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    my $data = shift;

    $me->_BDAT(length $data)
      && $me->rawdatasend($data)
      && $me->response() == CMD_OK;
  }
  else {
    carp 'Net::SMTP::bdat: CHUNKING extension is not in use, call data instead';
  }
}


sub bdatlast {
  my $me = shift;

  if (exists ${*$me}{'net_smtp_chunking'}) {
    my $data = shift;

    $me->_BDAT(length $data, "LAST")
      && $me->rawdatasend($data)
      && $me->response() == CMD_OK;
  }
  else {
    carp 'Net::SMTP::bdat: CHUNKING extension is not in use, call data instead';
  }
}


sub datafh {
  my $me = shift;
  return unless $me->_DATA();
  return $me->tied_fh;
}


sub expand {
  my $me = shift;

  $me->_EXPN(@_)
    ? ($me->message)
    : ();
}


sub verify { shift->_VRFY(@_) }


sub help {
  my $me = shift;

  $me->_HELP(@_)
    ? scalar $me->message
    : undef;
}


sub quit {
  my $me = shift;

  $me->_QUIT;
  $me->close;
}


sub DESTROY {

  # ignore
}

##
## RFC821 commands
##


sub _EHLO { shift->command("EHLO", @_)->response() == CMD_OK }
sub _HELO { shift->command("HELO", @_)->response() == CMD_OK }
sub _MAIL { shift->command("MAIL", @_)->response() == CMD_OK }
sub _RCPT { shift->command("RCPT", @_)->response() == CMD_OK }
sub _SEND { shift->command("SEND", @_)->response() == CMD_OK }
sub _SAML { shift->command("SAML", @_)->response() == CMD_OK }
sub _SOML { shift->command("SOML", @_)->response() == CMD_OK }
sub _VRFY { shift->command("VRFY", @_)->response() == CMD_OK }
sub _EXPN { shift->command("EXPN", @_)->response() == CMD_OK }
sub _HELP { shift->command("HELP", @_)->response() == CMD_OK }
sub _RSET { shift->command("RSET")->response() == CMD_OK }
sub _NOOP { shift->command("NOOP")->response() == CMD_OK }
sub _QUIT { shift->command("QUIT")->response() == CMD_OK }
sub _DATA { shift->command("DATA")->response() == CMD_MORE }
sub _BDAT { shift->command("BDAT", @_) }
sub _TURN { shift->unsupported(@_); }
sub _ETRN { shift->command("ETRN", @_)->response() == CMD_OK }
sub _AUTH { shift->command("AUTH", @_)->response() == CMD_OK }

1;

__END__

=head1 NAME

Net::SMTP - Simple Mail Transfer Protocol Client

=head1 SYNOPSIS

    use Net::SMTP;

    # Constructors
    $smtp = Net::SMTP->new('mailhost');
    $smtp = Net::SMTP->new('mailhost', Timeout => 60);

=head1 DESCRIPTION

This module implements a client interface to the SMTP and ESMTP
protocol, enabling a perl5 application to talk to SMTP servers. This
documentation assumes that you are familiar with the concepts of the
SMTP protocol described in RFC821.

A new Net::SMTP object must be created with the I<new> method. Once
this has been done, all SMTP commands are accessed through this object.

The Net::SMTP class is a subclass of Net::Cmd and IO::Socket::INET.

=head1 EXAMPLES

This example prints the mail domain name of the SMTP server known as mailhost:

    #!/usr/local/bin/perl -w

    use Net::SMTP;

    $smtp = Net::SMTP->new('mailhost');
    print $smtp->domain,"\n";
    $smtp->quit;

This example sends a small message to the postmaster at the SMTP server
known as mailhost:

    #!/usr/local/bin/perl -w

    use Net::SMTP;

    my $smtp = Net::SMTP->new('mailhost');

    $smtp->mail($ENV{USER});
    if ($smtp->to('postmaster')) {
     $smtp->data();
     $smtp->datasend("To: postmaster\n");
     $smtp->datasend("\n");
     $smtp->datasend("A simple test message\n");
     $smtp->dataend();
    } else {
     print "Error: ", $smtp->message();
    }

    $smtp->quit;

=head1 CONSTRUCTOR

=over 4

=item new ( [ HOST ] [, OPTIONS ] )

This is the constructor for a new Net::SMTP object. C<HOST> is the
name of the remote host to which an SMTP connection is required.

On failure C<undef> will be returned and C<$@> will contain the reason
for the failure.

C<HOST> is optional. If C<HOST> is not given then it may instead be
passed as the C<Host> option described below. If neither is given then
the C<SMTP_Hosts> specified in C<Net::Config> will be used.

C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
Possible options are:

B<Hello> - SMTP requires that you identify yourself. This option
specifies a string to pass as your mail domain. If not given localhost.localdomain
will be used.

B<Host> - SMTP host to connect to. It may be a single scalar (hostname[:port]),
as defined for the C<PeerAddr> option in L<IO::Socket::INET>, or a reference to
an array with hosts to try in turn. The L</host> method will return the value
which was used to connect to the host.

B<Port> - port to connect to. Format - C<PeerHost> from L<IO::Socket::INET> new method.
Default - 25.

B<LocalAddr> and B<LocalPort> - These parameters are passed directly
to IO::Socket to allow binding the socket to a local port.

B<Timeout> - Maximum time, in seconds, to wait for a response from the
SMTP server (default: 120)

B<ExactAddresses> - If true the all ADDRESS arguments must be as
defined by C<addr-spec> in RFC2822. If not given, or false, then
Net::SMTP will attempt to extract the address from the value passed.

B<Debug> - Enable debugging information

B<Port> - Select a port on the remote host to connect to (default is 25)

Example:


    $smtp = Net::SMTP->new('mailhost',
			   Hello => 'my.mail.domain',
			   Timeout => 30,
                           Debug   => 1,
			  );

    # the same
    $smtp = Net::SMTP->new(
			   Host => 'mailhost',
			   Hello => 'my.mail.domain',
			   Timeout => 30,
                           Debug   => 1,
			  );

    # Connect to the default server from Net::config
    $smtp = Net::SMTP->new(
			   Hello => 'my.mail.domain',
			   Timeout => 30,
			  );

=back

=head1 METHODS

Unless otherwise stated all methods return either a I<true> or I<false>
value, with I<true> meaning that the operation was a success. When a method
states that it returns a value, failure will be returned as I<undef> or an
empty list.

C<Net::SMTP> inherits from C<Net::Cmd> so methods defined in C<Net::Cmd> may
be used to send commands to the remote SMTP server in addition to the methods
documented here.

=over 4

=item banner ()

Returns the banner message which the server replied with when the
initial connection was made.

=item domain ()

Returns the domain that the remote SMTP server identified itself as during
connection.

=item hello ( DOMAIN )

Tell the remote server the mail domain which you are in using the EHLO
command (or HELO if EHLO fails).  Since this method is invoked
automatically when the Net::SMTP object is constructed the user should
normally not have to call it manually.

=item host ()

Returns the value used by the constructor, and passed to IO::Socket::INET,
to connect to the host.

=item etrn ( DOMAIN )

Request a queue run for the DOMAIN given.

=item auth ( USERNAME, PASSWORD )

Attempt SASL authentication. Requires Authen::SASL module.

=item mail ( ADDRESS [, OPTIONS] )

=item send ( ADDRESS )

=item send_or_mail ( ADDRESS )

=item send_and_mail ( ADDRESS )

Send the appropriate command to the server MAIL, SEND, SOML or SAML. C<ADDRESS>
is the address of the sender. This initiates the sending of a message. The
method C<recipient> should be called for each address that the message is to
be sent to.

The C<mail> method can some additional ESMTP OPTIONS which is passed
in hash like fashion, using key and value pairs.  Possible options are:

 Size        => <bytes>
 Return      => "FULL" | "HDRS"
 Bits        => "7" | "8" | "binary"
 Transaction => <ADDRESS>
 Envelope    => <ENVID>     # xtext-encodes its argument
 ENVID       => <ENVID>     # similar to Envelope, but expects argument encoded
 XVERP       => 1
 AUTH        => <submitter> # encoded address according to RFC 2554

The C<Return> and C<Envelope> parameters are used for DSN (Delivery
Status Notification).

The submitter address in C<AUTH> option is expected to be in a format as
required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or <> .

=item reset ()

Reset the status of the server. This may be called after a message has been 
initiated, but before any data has been sent, to cancel the sending of the
message.

=item recipient ( ADDRESS [, ADDRESS, [...]] [, OPTIONS ] )

Notify the server that the current message should be sent to all of the
addresses given. Each address is sent as a separate command to the server.
Should the sending of any address result in a failure then the process is
aborted and a I<false> value is returned. It is up to the user to call
C<reset> if they so desire.

The C<recipient> method can also pass additional case-sensitive OPTIONS as an
anonymous hash using key and value pairs.  Possible options are:

  Notify  => ['NEVER'] or ['SUCCESS','FAILURE','DELAY']  (see below)
  ORcpt   => <ORCPT>
  SkipBad => 1        (to ignore bad addresses)

If C<SkipBad> is true the C<recipient> will not return an error when a bad
address is encountered and it will return an array of addresses that did
succeed.

  $smtp->recipient($recipient1,$recipient2);  # Good
  $smtp->recipient($recipient1,$recipient2, { SkipBad => 1 });  # Good
  $smtp->recipient($recipient1,$recipient2, { Notify => ['FAILURE','DELAY'], SkipBad => 1 });  # Good
  @goodrecips=$smtp->recipient(@recipients, { Notify => ['FAILURE'], SkipBad => 1 });  # Good
  $smtp->recipient("$recipient,$recipient2"); # BAD

Notify is used to request Delivery Status Notifications (DSNs), but your
SMTP/ESMTP service may not respect this request depending upon its version and
your site's SMTP configuration.

Leaving out the Notify option usually defaults an SMTP service to its default
behavior equivalent to ['FAILURE'] notifications only, but again this may be
dependent upon your site's SMTP configuration.

The NEVER keyword must appear by itself if used within the Notify option and "requests
that a DSN not be returned to the sender under any conditions."

  {Notify => ['NEVER']}

  $smtp->recipient(@recipients, { Notify => ['NEVER'], SkipBad => 1 });  # Good

You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in
the anonymous array reference as defined by RFC3461 (see http://www.ietf.org/rfc/rfc3461.txt
for more information.  Note: quotations in this topic from same.).

A Notify parameter of 'SUCCESS' or 'FAILURE' "requests that a DSN be issued on
successful delivery or delivery failure, respectively."

A Notify parameter of 'DELAY' "indicates the sender's willingness to receive
delayed DSNs.  Delayed DSNs may be issued if delivery of a message has been
delayed for an unusual amount of time (as determined by the Message Transfer
Agent (MTA) at which the message is delayed), but the final delivery status
(whether successful or failure) cannot be determined.  The absence of the DELAY
keyword in a NOTIFY parameter requests that a "delayed" DSN NOT be issued under
any conditions."

  {Notify => ['SUCCESS','FAILURE','DELAY']}

  $smtp->recipient(@recipients, { Notify => ['FAILURE','DELAY'], SkipBad => 1 });  # Good

ORcpt is also part of the SMTP DSN extension according to RFC3461.
It is used to pass along the original recipient that the mail was first
sent to.  The machine that generates a DSN will use this address to inform
the sender, because he can't know if recipients get rewritten by mail servers.
It is expected to be in a format as required by RFC3461, xtext-encoded.

=item to ( ADDRESS [, ADDRESS [...]] )

=item cc ( ADDRESS [, ADDRESS [...]] )

=item bcc ( ADDRESS [, ADDRESS [...]] )

Synonyms for C<recipient>.

=item data ( [ DATA ] )

Initiate the sending of the data from the current message. 

C<DATA> may be a reference to a list or a list. If specified the contents
of C<DATA> and a termination string C<".\r\n"> is sent to the server. And the
result will be true if the data was accepted.

If C<DATA> is not specified then the result will indicate that the server
wishes the data to be sent. The data must then be sent using the C<datasend>
and C<dataend> methods described in L<Net::Cmd>.

=item expand ( ADDRESS )

Request the server to expand the given address Returns an array
which contains the text read from the server.

=item verify ( ADDRESS )

Verify that C<ADDRESS> is a legitimate mailing address.

Most sites usually disable this feature in their SMTP service configuration.
Use "Debug => 1" option under new() to see if disabled.

=item help ( [ $subject ] )

Request help text from the server. Returns the text or undef upon failure

=item quit ()

Send the QUIT command to the remote SMTP server and close the socket connection.

=back

=head1 ADDRESSES

Net::SMTP attempts to DWIM with addresses that are passed. For
example an application might extract The From: line from an email
and pass that to mail(). While this may work, it is not recommended.
The application should really use a module like L<Mail::Address>
to extract the mail address and pass that.

If C<ExactAddresses> is passed to the constructor, then addresses
should be a valid rfc2821-quoted address, although Net::SMTP will
accept the address surrounded by angle brackets.

 funny user@domain      WRONG
 "funny user"@domain    RIGHT, recommended
 <"funny user"@domain>  OK

=head1 SEE ALSO

L<Net::Cmd>

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1995-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                     usr/share/perl/5.20.2/Net/Time.pm                                                                   0100644 0000000 0000000 00000006470 12744441327 014647  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Net::Time.pm
#
# Copyright (c) 1995-2004 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Time;

use strict;
use vars qw($VERSION @ISA @EXPORT_OK $TIMEOUT);
use Carp;
use IO::Socket;
require Exporter;
use Net::Config;
use IO::Select;

@ISA       = qw(Exporter);
@EXPORT_OK = qw(inet_time inet_daytime);

$VERSION = "2.10";

$TIMEOUT = 120;


sub _socket {
  my ($pname, $pnum, $host, $proto, $timeout) = @_;

  $proto ||= 'udp';

  my $port = (getservbyname($pname, $proto))[2] || $pnum;

  my $hosts = defined $host ? [$host] : $NetConfig{$pname . '_hosts'};

  my $me;

  foreach $host (@$hosts) {
    $me = IO::Socket::INET->new(
      PeerAddr => $host,
      PeerPort => $port,
      Proto    => $proto
      )
      and last;
  }

  return unless $me;

  $me->send("\n")
    if $proto eq 'udp';

  $timeout = $TIMEOUT
    unless defined $timeout;

  IO::Select->new($me)->can_read($timeout)
    ? $me
    : undef;
}


sub inet_time {
  my $s      = _socket('time', 37, @_) || return undef;
  my $buf    = '';
  my $offset = 0 | 0;

  return undef
    unless defined $s->recv($buf, length(pack("N", 0)));

  # unpack, we | 0 to ensure we have an unsigned
  my $time = (unpack("N", $buf))[0] | 0;

  # the time protocol return time in seconds since 1900, convert
  # it to a the required format

  if ($^O eq "MacOS") {

    # MacOS return seconds since 1904, 1900 was not a leap year.
    $offset = (4 * 31536000) | 0;
  }
  else {

    # otherwise return seconds since 1972, there were 17 leap years between
    # 1900 and 1972
    $offset = (70 * 31536000 + 17 * 86400) | 0;
  }

  $time - $offset;
}


sub inet_daytime {
  my $s   = _socket('daytime', 13, @_) || return undef;
  my $buf = '';

  defined($s->recv($buf, 1024))
    ? $buf
    : undef;
}

1;

__END__

=head1 NAME

Net::Time - time and daytime network client interface

=head1 SYNOPSIS

    use Net::Time qw(inet_time inet_daytime);

    print inet_time();		# use default host from Net::Config
    print inet_time('localhost');
    print inet_time('localhost', 'tcp');

    print inet_daytime();	# use default host from Net::Config
    print inet_daytime('localhost');
    print inet_daytime('localhost', 'tcp');

=head1 DESCRIPTION

C<Net::Time> provides subroutines that obtain the time on a remote machine.

=over 4

=item inet_time ( [HOST [, PROTOCOL [, TIMEOUT]]])

Obtain the time on C<HOST>, or some default host if C<HOST> is not given
or not defined, using the protocol as defined in RFC868. The optional
argument C<PROTOCOL> should define the protocol to use, either C<tcp> or
C<udp>. The result will be a time value in the same units as returned
by time() or I<undef> upon failure.

=item inet_daytime ( [HOST [, PROTOCOL [, TIMEOUT]]])

Obtain the time on C<HOST>, or some default host if C<HOST> is not given
or not defined, using the protocol as defined in RFC867. The optional
argument C<PROTOCOL> should define the protocol to use, either C<tcp> or
C<udp>. The result will be an ASCII string or I<undef> upon failure.

=back

=head1 AUTHOR

Graham Barr <gbarr@pobox.com>

=head1 COPYRIGHT

Copyright (c) 1995-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                        usr/share/perl/5.20.2/Net/hostent.pm                                                                0100644 0000000 0000000 00000007661 12744441327 015440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::hostent;
use strict;

use 5.006_001;
our $VERSION = '1.01';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(gethostbyname gethostbyaddr gethost);
    @EXPORT_OK   = qw(
			$h_name	    	@h_aliases
			$h_addrtype 	$h_length
			@h_addr_list 	$h_addr
		   );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::hostent' => [
   name		=> '$',
   aliases	=> '@',
   addrtype	=> '$',
   'length'	=> '$',
   addr_list	=> '@',
];

sub addr { shift->addr_list->[0] }

sub populate (@) {
    return unless @_;
    my $hob = new();
    $h_name 	 =    $hob->[0]     	     = $_[0];
    @h_aliases	 = @{ $hob->[1] } = split ' ', $_[1];
    $h_addrtype  =    $hob->[2] 	     = $_[2];
    $h_length	 =    $hob->[3] 	     = $_[3];
    $h_addr 	 =                             $_[4];
    @h_addr_list = @{ $hob->[4] } =          @_[ (4 .. $#_) ];
    return $hob;
} 

sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) } 

sub gethostbyaddr ($;$) { 
    my ($addr, $addrtype);
    $addr = shift;
    require Socket unless @_;
    $addrtype = @_ ? shift : Socket::AF_INET();
    populate(CORE::gethostbyaddr($addr, $addrtype)) 
} 

sub gethost($) {
    if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	require Socket;
	&gethostbyaddr(Socket::inet_aton(shift));
    } else {
	&gethostbyname;
    } 
} 

1;
__END__

=head1 NAME

Net::hostent - by-name interface to Perl's built-in gethost*() functions

=head1 SYNOPSIS

 use Net::hostent;

=head1 DESCRIPTION

This module's default exports override the core gethostbyname() and
gethostbyaddr() functions, replacing them with versions that return
"Net::hostent" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from F<netdb.h>;
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<h_>.  Thus, C<$host_obj-E<gt>name()> corresponds to
$h_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $host_obj-E<gt>aliases()
}> would be simply @h_aliases.

The gethost() function is a simple front-end that forwards a numeric
argument to gethostbyaddr() by way of Socket::inet_aton, and the rest
to gethostbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

 use Net::hostent;
 use Socket;

 @ARGV = ('netscape.com') unless @ARGV;

 for $host ( @ARGV ) {

    unless ($h = gethost($host)) {
	warn "$0: no such host: $host\n";
	next;
    }

    printf "\n%s is %s%s\n", 
	    $host, 
	    lc($h->name) eq lc($host) ? "" : "*really* ",
	    $h->name;

    print "\taliases are ", join(", ", @{$h->aliases}), "\n"
		if @{$h->aliases};     

    if ( @{$h->addr_list} > 1 ) { 
	my $i;
	for $addr ( @{$h->addr_list} ) {
	    printf "\taddr #%d is [%s]\n", $i++, inet_ntoa($addr);
	} 
    } else {
	printf "\taddress is [%s]\n", inet_ntoa($h->addr);
    } 

    if ($h = gethostbyaddr($h->addr)) {
	if (lc($h->name) ne lc($host)) {
	    printf "\tThat addr reverses to host %s!\n", $h->name;
	    $host = $h->name;
	    redo;
	} 
    }
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                               usr/share/perl/5.20.2/Net/libnetFAQ.pod                                                             0100644 0000000 0000000 00000023367 12744441327 015730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

libnetFAQ - libnet Frequently Asked Questions

=head1 DESCRIPTION

=head2 Where to get this document

This document is distributed with the libnet distribution, and is also
available on the libnet web page at

    http://search.cpan.org/dist/libnet/

=head2 How to contribute to this document

You may report corrections, additions, and suggestions on the
CPAN request tracker at

    http://rt.cpan.org/Dist/Display.html?Name=libnet

=head1 Author and Copyright Information

Copyright (c) 1997-1998 Graham Barr. All rights reserved.
This document is free; you can redistribute it and/or modify it
under the terms of the Artistic License.

Currently maintained by Steve Hay <shay@cpan.org>.

=head2 Disclaimer

This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability
in respect of this information or its use.


=head1 Obtaining and installing libnet

=head2 What is libnet ?

libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules available provided the
client side of popular server-client protocols that are used in
the internet community.

=head2 Which version of perl do I need ?

libnet has been know to work with versions of perl from 5.002 onwards. However
if your release of perl is prior to perl5.004 then you will need to
obtain and install the IO distribution from CPAN. If you have perl5.004
or later then you will have the IO modules in your installation already,
but CPAN may contain updates.

=head2 What other modules do I need ?

The only modules you will need installed are the modules from the IO
distribution. If you have perl5.004 or later you will already have
these modules.

=head2 What machines support libnet ?

libnet itself is an entirely perl-code distribution so it should work
on any machine that perl runs on. However IO may not work
with some machines and earlier releases of perl. But this
should not be the case with perl version 5.004 or later.

=head2 Where can I get the latest libnet release

The latest libnet release is always on CPAN, you will find it
in 

 http://search.cpan.org/dist/libnet/

=head1 Using Net::FTP

=head2 How do I download files from an FTP server ?

An example taken from an article posted to comp.lang.perl.misc

    #!/your/path/to/perl

    # a module making life easier

    use Net::FTP;

    # for debugging: $ftp = Net::FTP->new('site','Debug',10);
    # open a connection and log in!

    $ftp = Net::FTP->new('target_site.somewhere.xxx');
    $ftp->login('username','password');

    # set transfer mode to binary

    $ftp->binary();

    # change the directory on the ftp site

    $ftp->cwd('/some/path/to/somewhere/');

    foreach $name ('file1', 'file2', 'file3') {

    # get's arguments are in the following order:
    # ftp server's filename
    # filename to save the transfer to on the local machine
    # can be simply used as get($name) if you want the same name

      $ftp->get($name,$name);
    }

    # ftp done!

    $ftp->quit;

=head2 How do I transfer files in binary mode ?

To transfer files without <LF><CR> translation Net::FTP provides
the C<binary> method

    $ftp->binary;

=head2 How can I get the size of a file on a remote FTP server ?

=head2 How can I get the modification time of a file on a remote FTP server ?

=head2 How can I change the permissions of a file on a remote server ?

The FTP protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a SITE command, eg

    $ftp->quot('site chmod 0777',$filename);

But this is not guaranteed to work.

=head2 Can I do a reget operation like the ftp command ?

=head2 How do I get a directory listing from an FTP server ?

=head2 Changing directory to "" does not fail ?

Passing an argument of "" to ->cwd() has the same affect of calling ->cwd()
without any arguments. Turn on Debug (I<See below>) and you will see what is
happening

    $ftp = Net::FTP->new($host, Debug => 1);
    $ftp->login;
    $ftp->cwd("");

gives

    Net::FTP=GLOB(0x82196d8)>>> CWD /
    Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.

=head2 I am behind a SOCKS firewall, but the Firewall option does not work ?

The Firewall option is only for support of one type of firewall. The type
supported is an ftp proxy.

To use Net::FTP, or any other module in the libnet distribution,
through a SOCKS firewall you must create a socks-ified perl executable
by compiling perl with the socks library.

=head2 I am behind an FTP proxy firewall, but cannot access machines outside ?

Net::FTP implements the most popular ftp proxy firewall approach. The scheme
implemented is that where you log in to the firewall with C<user@hostname>

I have heard of one other type of firewall which requires a login to the
firewall with an account, then a second login with C<user@hostname>. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg

    $ftp = Net::FTP->new($firewall) or die $@;
    $ftp->login($firewall_user, $firewall_passwd) or die $ftp->message;
    $ftp->login($ext_user . '@' . $ext_host, $ext_passwd) or die $ftp->message.

=head2 My ftp proxy firewall does not listen on port 21

FTP servers usually listen on the same port number, port 21, as any other
FTP server. But there is no reason why this has to be the case.

If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try
to connect to the firewall on port 21.

Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like C<"hostname:1234">
or by setting the C<ftp_firewall> option in Net::Config to be a string
in the same form.

=head2 Is it possible to change the file permissions of a file on an FTP server ?

The answer to this is "maybe". The FTP protocol does not specify a command to change
file permissions on a remote host. However many servers do allow you to run the
chmod command via the C<SITE> command. This can be done with

  $ftp->site('chmod','0775',$file);

=head2 I have seen scripts call a method message, but cannot find it documented ?

Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so
all the methods described in Net::Cmd are also available on Net::FTP
objects.

=head2 Why does Net::FTP not implement mput and mget methods

The quick answer is because they are easy to implement yourself. The long
answer is that to write these in such a way that multiple platforms are
supported correctly would just require too much code. Below are
some examples how you can implement these yourself.

sub mput {
  my($ftp,$pattern) = @_;
  foreach my $file (glob($pattern)) {
    $ftp->put($file) or warn $ftp->message;
  }
}

sub mget {
  my($ftp,$pattern) = @_;
  foreach my $file ($ftp->ls($pattern)) {
    $ftp->get($file) or warn $ftp->message;
  }
}


=head1 Using Net::SMTP

=head2 Why can't the part of an Email address after the @ be used as the hostname ?

The part of an Email address which follows the @ is not necessarily a hostname,
it is a mail domain. To find the name of a host to connect for a mail domain
you need to do a DNS MX lookup

=head2 Why does Net::SMTP not do DNS MX lookups ?

Net::SMTP implements the SMTP protocol. The DNS MX lookup is not part
of this protocol.

=head2 The verify method always returns true ?

Well it may seem that way, but it does not. The verify method returns true
if the command succeeded. If you pass verify an address which the
server would normally have to forward to another machine, the command
will succeed with something like

    252 Couldn't verify <someone@there> but will attempt delivery anyway

This command will fail only if you pass it an address in a domain
the server directly delivers for, and that address does not exist.

=head1 Debugging scripts

=head2 How can I debug my scripts that use Net::* modules ?

Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called C<Debug>. Passing
this option with a non-zero value will turn on a protocol trace, which
will be sent to STDERR. This trace can be useful to see what commands
are being sent to the remote server and what responses are being
received back.

    #!/your/path/to/perl

    use Net::FTP;

    my $ftp = new Net::FTP($host, Debug => 1);
    $ftp->login('gbarr','password');
    $ftp->quit;

this script would output something like

 Net::FTP: Net::FTP(2.22)
 Net::FTP:   Exporter
 Net::FTP:   Net::Cmd(2.0801)
 Net::FTP:   IO::Socket::INET
 Net::FTP:     IO::Socket(1.1603)
 Net::FTP:       IO::Handle(1.1504)

 Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
 Net::FTP=GLOB(0x8152974)>>> user gbarr
 Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
 Net::FTP=GLOB(0x8152974)>>> PASS ....
 Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
 Net::FTP=GLOB(0x8152974)>>> QUIT
 Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.

The first few lines tell you the modules that Net::FTP uses and their versions,
this is useful data to me when a user reports a bug. The last seven lines
show the communication with the server. Each line has three parts. The first
part is the object itself, this is useful for separating the output
if you are using multiple objects. The second part is either C<<<<<> to
show data coming from the server or C<&gt&gt&gt&gt> to show data
going to the server. The remainder of the line is the command
being sent or response being received.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997 Graham Barr.
All rights reserved.

                                                                                                                                                                                                                                                                         usr/share/perl/5.20.2/Net/netent.pm                                                                 0100644 0000000 0000000 00000010601 12744441327 015235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::netent;
use strict;

use 5.006_001;
our $VERSION = '1.00';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(getnetbyname getnetbyaddr getnet);
    @EXPORT_OK   = qw(
			$n_name	    	@n_aliases
			$n_addrtype 	$n_net
		   );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::netent' => [
   name		=> '$',
   aliases	=> '@',
   addrtype	=> '$',
   net		=> '$',
];

sub populate (@) {
    return unless @_;
    my $nob = new();
    $n_name 	 =    $nob->[0]     	     = $_[0];
    @n_aliases	 = @{ $nob->[1] } = split ' ', $_[1];
    $n_addrtype  =    $nob->[2] 	     = $_[2];
    $n_net	 =    $nob->[3] 	     = $_[3];
    return $nob;
} 

sub getnetbyname ($)  { populate(CORE::getnetbyname(shift)) } 

sub getnetbyaddr ($;$) { 
    my ($net, $addrtype);
    $net = shift;
    require Socket if @_;
    $addrtype = @_ ? shift : Socket::AF_INET();
    populate(CORE::getnetbyaddr($net, $addrtype)) 
} 

sub getnet($) {
    if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	require Socket;
	&getnetbyaddr(Socket::inet_aton(shift));
    } else {
	&getnetbyname;
    } 
} 

1;
__END__

=head1 NAME

Net::netent - by-name interface to Perl's built-in getnet*() functions

=head1 SYNOPSIS

 use Net::netent qw(:FIELDS);
 getnetbyname("loopback") 		or die "bad net";
 printf "%s is %08X\n", $n_name, $n_net;

 use Net::netent;

 $n = getnetbyname("loopback") 		or die "bad net";
 { # there's gotta be a better way, eh?
     @bytes = unpack("C4", pack("N", $n->net));
     shift @bytes while @bytes && $bytes[0] == 0;
 }
 printf "%s is %08X [%d.%d.%d.%d]\n", $n->name, $n->net, @bytes;

=head1 DESCRIPTION

This module's default exports override the core getnetbyname() and
getnetbyaddr() functions, replacing them with versions that return
"Net::netent" objects.  This object has methods that return the similarly
named structure field name from the C's netent structure from F<netdb.h>;
namely name, aliases, addrtype, and net.  The aliases 
method returns an array reference, the rest scalars.  

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<n_>.  Thus, C<$net_obj-E<gt>name()> corresponds to
$n_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $net_obj-E<gt>aliases()
}> would be simply @n_aliases.

The getnet() function is a simple front-end that forwards a numeric
argument to getnetbyaddr(), and the rest
to getnetbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

The getnet() functions do this in the Perl core:

    sv_setiv(sv, (I32)nent->n_net);

The gethost() functions do this in the Perl core:

    sv_setpvn(sv, hent->h_addr, len);

That means that the address comes back in binary for the
host functions, and as a regular perl integer for the net ones.
This seems a bug, but here's how to deal with it:

 use strict;
 use Socket;
 use Net::netent;

 @ARGV = ('loopback') unless @ARGV;

 my($n, $net);

 for $net ( @ARGV ) {

     unless ($n = getnetbyname($net)) {
 	warn "$0: no such net: $net\n";
 	next;
     }

     printf "\n%s is %s%s\n", 
 	    $net, 
 	    lc($n->name) eq lc($net) ? "" : "*really* ",
 	    $n->name;

     print "\taliases are ", join(", ", @{$n->aliases}), "\n"
 		if @{$n->aliases};     

     # this is stupid; first, why is this not in binary?
     # second, why am i going through these convolutions
     # to make it looks right
     {
 	my @a = unpack("C4", pack("N", $n->net));
 	shift @a while @a && $a[0] == 0;
 	printf "\taddr is %s [%d.%d.%d.%d]\n", $n->net, @a;
     }

     if ($n = getnetbyaddr($n->net)) {
 	if (lc($n->name) ne lc($net)) {
 	    printf "\tThat addr reverses to net %s!\n", $n->name;
 	    $net = $n->name;
 	    redo;
 	} 
     }
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                                                                               usr/share/perl/5.20.2/Net/protoent.pm                                                               0100644 0000000 0000000 00000005735 12744441327 015626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::protoent;
use strict;

use 5.006_001;
our $VERSION = '1.00';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN { 
    use Exporter   ();
    @EXPORT      = qw(getprotobyname getprotobynumber getprotoent getproto);
    @EXPORT_OK   = qw( $p_name @p_aliases $p_proto );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::protoent' => [
   name		=> '$',
   aliases	=> '@',
   proto	=> '$',
];

sub populate (@) {
    return unless @_;
    my $pob = new();
    $p_name 	 =    $pob->[0]     	     = $_[0];
    @p_aliases	 = @{ $pob->[1] } = split ' ', $_[1];
    $p_proto	 =    $pob->[2] 	     = $_[2];
    return $pob;
} 

sub getprotoent      ( )  { populate(CORE::getprotoent()) } 
sub getprotobyname   ($)  { populate(CORE::getprotobyname(shift)) } 
sub getprotobynumber ($)  { populate(CORE::getprotobynumber(shift)) } 

sub getproto ($;$) {
    no strict 'refs';
    return &{'getprotoby' . ($_[0]=~/^\d+$/ ? 'number' : 'name')}(@_);
}

1;

__END__

=head1 NAME

Net::protoent - by-name interface to Perl's built-in getproto*() functions

=head1 SYNOPSIS

 use Net::protoent;
 $p = getprotobyname(shift || 'tcp') || die "no proto";
 printf "proto for %s is %d, aliases are %s\n",
    $p->name, $p->proto, "@{$p->aliases}";

 use Net::protoent qw(:FIELDS);
 getprotobyname(shift || 'tcp') || die "no proto";
 print "proto for $p_name is $p_proto, aliases are @p_aliases\n";

=head1 DESCRIPTION

This module's default exports override the core getprotoent(),
getprotobyname(), and getnetbyport() functions, replacing them with
versions that return "Net::protoent" objects.  They take default
second arguments of "tcp".  This object has methods that return the
similarly named structure field name from the C's protoent structure
from F<netdb.h>; namely name, aliases, and proto.  The aliases method
returns an array reference, the rest scalars.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<p_>.  Thus, C<$proto_obj-E<gt>name()> corresponds to
$p_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $proto_obj-E<gt>aliases()
}> would be simply @p_aliases.

The getproto() function is a simple front-end that forwards a numeric
argument to getprotobyport(), and the rest to getprotobyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                   usr/share/perl/5.20.2/Net/servent.pm                                                                0100644 0000000 0000000 00000006626 12744441327 015442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Net::servent;
use strict;

use 5.006_001;
our $VERSION = '1.01';
our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
BEGIN {
    use Exporter   ();
    @EXPORT      = qw(getservbyname getservbyport getservent getserv);
    @EXPORT_OK   = qw( $s_name @s_aliases $s_port $s_proto );
    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}
use vars      @EXPORT_OK;

# Class::Struct forbids use of @ISA
sub import { goto &Exporter::import }

use Class::Struct qw(struct);
struct 'Net::servent' => [
   name		=> '$',
   aliases	=> '@',
   port		=> '$',
   proto	=> '$',
];

sub populate (@) {
    return unless @_;
    my $sob = new();
    $s_name 	 =    $sob->[0]     	     = $_[0];
    @s_aliases	 = @{ $sob->[1] } = split ' ', $_[1];
    $s_port	 =    $sob->[2] 	     = $_[2];
    $s_proto	 =    $sob->[3] 	     = $_[3];
    return $sob;
}

sub getservent    (   ) { populate(CORE::getservent()) }
sub getservbyname ($;$) { populate(CORE::getservbyname(shift,shift||'tcp')) }
sub getservbyport ($;$) { populate(CORE::getservbyport(shift,shift||'tcp')) }

sub getserv ($;$) {
    no strict 'refs';
    return &{'getservby' . ($_[0]=~/^\d+$/ ? 'port' : 'name')}(@_);
}

1;

__END__

=head1 NAME

Net::servent - by-name interface to Perl's built-in getserv*() functions

=head1 SYNOPSIS

 use Net::servent;
 $s = getservbyname(shift || 'ftp') || die "no service";
 printf "port for %s is %s, aliases are %s\n",
    $s->name, $s->port, "@{$s->aliases}";

 use Net::servent qw(:FIELDS);
 getservbyname(shift || 'ftp') || die "no service";
 print "port for $s_name is $s_port, aliases are @s_aliases\n";

=head1 DESCRIPTION

This module's default exports override the core getservent(),
getservbyname(), and
getnetbyport() functions, replacing them with versions that return
"Net::servent" objects.  They take default second arguments of "tcp".  This object has methods that return the similarly
named structure field name from the C's servent structure from F<netdb.h>;
namely name, aliases, port, and proto.  The aliases
method returns an array reference, the rest scalars.

You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding C<s_>.  Thus, C<$serv_obj-E<gt>name()> corresponds to
$s_name if you import the fields.  Array references are available as
regular array variables, so for example C<@{ $serv_obj-E<gt>aliases()}>
would be simply @s_aliases.

The getserv() function is a simple front-end that forwards a numeric
argument to getservbyport(), and the rest to getservbyname().

To access this functionality without the core overrides,
pass the C<use> an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the C<CORE::> pseudo-package.

=head1 EXAMPLES

 use Net::servent qw(:FIELDS);

 while (@ARGV) {
     my ($service, $proto) = ((split m!/!, shift), 'tcp');
     my $valet = getserv($service, $proto);
     unless ($valet) {
         warn "$0: No service: $service/$proto\n"
         next;
     }
     printf "service $service/$proto is port %d\n", $valet->port;
     print "alias are @s_aliases\n" if @s_aliases;
 }

=head1 NOTE

While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

=head1 AUTHOR

Tom Christiansen
                                                                                                          usr/share/perl/5.20.2/Package/                                                                      0040755 0000000 0000000 00000000000 13077704254 014215  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Package/Constants.pm                                                          0100644 0000000 0000000 00000004434 12744441327 016530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Package::Constants;

use if $] >= 5.019006, 'deprecate';

use strict;
use vars qw[$VERSION $DEBUG];

$VERSION    = '0.04';
$DEBUG      = 0;

=head1 NAME

Package::Constants - List all constants declared in a package

=head1 SYNOPSIS

    use Package::Constants;

    ### list the names of all constants in a given package;
    @const = Package::Constants->list( __PACKAGE__ );
    @const = Package::Constants->list( 'main' );

    ### enable debugging output
    $Package::Constants::DEBUG = 1;

=head1 DESCRIPTION

C<Package::Constants> lists all the constants defined in a certain
package. This can be useful for, among others, setting up an
autogenerated C<@EXPORT/@EXPORT_OK> for a Constants.pm file.

=head1 CLASS METHODS

=head2 @const = Package::Constants->list( PACKAGE_NAME );

Lists the names of all the constants defined in the provided package.

=cut

sub list {
    my $class = shift;
    my $pkg   = shift;
    return unless defined $pkg; # some joker might use '0' as a pkg...

    _debug("Inspecting package '$pkg'");

    my @rv;
    {   no strict 'refs';
        my $stash = $pkg . '::';

        for my $name (sort keys %$stash ) {

            _debug( "   Checking stash entry '$name'" );

            ### is it a subentry?
            my $sub = $pkg->can( $name );
            next unless defined $sub;

            _debug( "       '$name' is a coderef" );

            next unless defined prototype($sub) and 
                     not length prototype($sub);

            _debug( "       '$name' is a constant" );
            push @rv, $name;
        }
    }

    return sort @rv;
}

=head1 GLOBAL VARIABLES

=head2 $Package::Constants::DEBUG

When set to true, prints out debug information to STDERR about the
package it is inspecting. Helps to identify issues when the results
are not as you expect.

Defaults to false.

=cut

sub _debug { warn "@_\n" if $DEBUG; }

1;

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-package-constants@rt.cpan.org<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:
                                                                                                                                                                                                                                    usr/share/perl/5.20.2/Params/                                                                       0040755 0000000 0000000 00000000000 13077704254 014105  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Params/Check.pm                                                               0100644 0000000 0000000 00000045602 12744441327 015463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Params::Check;

use strict;

use Carp                        qw[carp croak];
use Locale::Maketext::Simple    Style => 'gettext';

BEGIN {
    use Exporter    ();
    use vars        qw[ @ISA $VERSION @EXPORT_OK $VERBOSE $ALLOW_UNKNOWN
                        $STRICT_TYPE $STRIP_LEADING_DASHES $NO_DUPLICATES
                        $PRESERVE_CASE $ONLY_ALLOW_DEFINED $WARNINGS_FATAL
                        $SANITY_CHECK_TEMPLATE $CALLER_DEPTH $_ERROR_STRING
                    ];

    @ISA        =   qw[ Exporter ];
    @EXPORT_OK  =   qw[check allow last_error];

    $VERSION                = '0.38';
    $VERBOSE                = $^W ? 1 : 0;
    $NO_DUPLICATES          = 0;
    $STRIP_LEADING_DASHES   = 0;
    $STRICT_TYPE            = 0;
    $ALLOW_UNKNOWN          = 0;
    $PRESERVE_CASE          = 0;
    $ONLY_ALLOW_DEFINED     = 0;
    $SANITY_CHECK_TEMPLATE  = 1;
    $WARNINGS_FATAL         = 0;
    $CALLER_DEPTH           = 0;
}

my %known_keys = map { $_ => 1 }
                    qw| required allow default strict_type no_override
                        store defined |;

=pod

=head1 NAME

Params::Check - A generic input parsing/checking mechanism.

=head1 SYNOPSIS

    use Params::Check qw[check allow last_error];

    sub fill_personal_info {
        my %hash = @_;
        my $x;

        my $tmpl = {
            firstname   => { required   => 1, defined => 1 },
            lastname    => { required   => 1, store => \$x },
            gender      => { required   => 1,
                             allow      => [qr/M/i, qr/F/i],
                           },
            married     => { allow      => [0,1] },
            age         => { default    => 21,
                             allow      => qr/^\d+$/,
                           },

            phone       => { allow => [ sub { return 1 if /$valid_re/ },
                                        '1-800-PERL' ]
                           },
            id_list     => { default        => [],
                             strict_type    => 1
                           },
            employer    => { default => 'NSA', no_override => 1 },
        };

        ### check() returns a hashref of parsed args on success ###
        my $parsed_args = check( $tmpl, \%hash, $VERBOSE )
                            or die qw[Could not parse arguments!];

        ... other code here ...
    }

    my $ok = allow( $colour, [qw|blue green yellow|] );

    my $error = Params::Check::last_error();


=head1 DESCRIPTION

Params::Check is a generic input parsing/checking mechanism.

It allows you to validate input via a template. The only requirement
is that the arguments must be named.

Params::Check can do the following things for you:

=over 4

=item *

Convert all keys to lowercase

=item *

Check if all required arguments have been provided

=item *

Set arguments that have not been provided to the default

=item *

Weed out arguments that are not supported and warn about them to the
user

=item *

Validate the arguments given by the user based on strings, regexes,
lists or even subroutines

=item *

Enforce type integrity if required

=back

Most of Params::Check's power comes from its template, which we'll
discuss below:

=head1 Template

As you can see in the synopsis, based on your template, the arguments
provided will be validated.

The template can take a different set of rules per key that is used.

The following rules are available:

=over 4

=item default

This is the default value if none was provided by the user.
This is also the type C<strict_type> will look at when checking type
integrity (see below).

=item required

A boolean flag that indicates if this argument was a required
argument. If marked as required and not provided, check() will fail.

=item strict_type

This does a C<ref()> check on the argument provided. The C<ref> of the
argument must be the same as the C<ref> of the default value for this
check to pass.

This is very useful if you insist on taking an array reference as
argument for example.

=item defined

If this template key is true, enforces that if this key is provided by
user input, its value is C<defined>. This just means that the user is
not allowed to pass C<undef> as a value for this key and is equivalent
to:
    allow => sub { defined $_[0] && OTHER TESTS }

=item no_override

This allows you to specify C<constants> in your template. ie, they
keys that are not allowed to be altered by the user. It pretty much
allows you to keep all your C<configurable> data in one place; the
C<Params::Check> template.

=item store

This allows you to pass a reference to a scalar, in which the data
will be stored:

    my $x;
    my $args = check(foo => { default => 1, store => \$x }, $input);

This is basically shorthand for saying:

    my $args = check( { foo => { default => 1 }, $input );
    my $x    = $args->{foo};

You can alter the global variable $Params::Check::NO_DUPLICATES to
control whether the C<store>'d key will still be present in your
result set. See the L<Global Variables> section below.

=item allow

A set of criteria used to validate a particular piece of data if it
has to adhere to particular rules.

See the C<allow()> function for details.

=back

=head1 Functions

=head2 check( \%tmpl, \%args, [$verbose] );

This function is not exported by default, so you'll have to ask for it
via:

    use Params::Check qw[check];

or use its fully qualified name instead.

C<check> takes a list of arguments, as follows:

=over 4

=item Template

This is a hash reference which contains a template as explained in the
C<SYNOPSIS> and C<Template> section.

=item Arguments

This is a reference to a hash of named arguments which need checking.

=item Verbose

A boolean to indicate whether C<check> should be verbose and warn
about what went wrong in a check or not.

You can enable this program wide by setting the package variable
C<$Params::Check::VERBOSE> to a true value. For details, see the
section on C<Global Variables> below.

=back

C<check> will return when it fails, or a hashref with lowercase
keys of parsed arguments when it succeeds.

So a typical call to check would look like this:

    my $parsed = check( \%template, \%arguments, $VERBOSE )
                    or warn q[Arguments could not be parsed!];

A lot of the behaviour of C<check()> can be altered by setting
package variables. See the section on C<Global Variables> for details
on this.

=cut

sub check {
    my ($utmpl, $href, $verbose) = @_;

    ### clear the current error string ###
    _clear_error();

    ### did we get the arguments we need? ###
    if ( !$utmpl or !$href ) {
      _store_error(loc('check() expects two arguments'));
      return unless $WARNINGS_FATAL;
      croak(__PACKAGE__->last_error);
    }

    ### sensible defaults ###
    $verbose ||= $VERBOSE || 0;

    ### XXX what type of template is it? ###
    ### { key => { } } ?
    #if (ref $args eq 'HASH') {
    #    1;
    #}

    ### clean up the template ###
    my $args;

    ### don't even bother to loop, if there's nothing to clean up ###
    if( $PRESERVE_CASE and !$STRIP_LEADING_DASHES ) {
        $args = $href;
    } else {
        ### keys are not aliased ###
        for my $key (keys %$href) {
            my $org = $key;
            $key = lc $key unless $PRESERVE_CASE;
            $key =~ s/^-// if $STRIP_LEADING_DASHES;
            $args->{$key} = $href->{$org};
        }
    }

    my %defs;

    ### which template entries have a 'store' member
    my @want_store;

    ### sanity check + defaults + required keys set? ###
    my $fail;
    for my $key (keys %$utmpl) {
        my $tmpl = $utmpl->{$key};

        ### check if required keys are provided
        ### keys are now lower cased, unless preserve case was enabled
        ### at which point, the utmpl keys must match, but that's the users
        ### problem.
        if( $tmpl->{'required'} and not exists $args->{$key} ) {
            _store_error(
                loc(q|Required option '%1' is not provided for %2 by %3|,
                    $key, _who_was_it(), _who_was_it(1)), $verbose );

            ### mark the error ###
            $fail++;
            next;
        }

        ### next, set the default, make sure the key exists in %defs ###
        $defs{$key} = $tmpl->{'default'}
                        if exists $tmpl->{'default'};

        if( $SANITY_CHECK_TEMPLATE ) {
            ### last, check if they provided any weird template keys
            ### -- do this last so we don't always execute this code.
            ### just a small optimization.
            map {   _store_error(
                        loc(q|Template type '%1' not supported [at key '%2']|,
                        $_, $key), 1, 0 );
            } grep {
                not $known_keys{$_}
            } keys %$tmpl;

            ### make sure you passed a ref, otherwise, complain about it!
            if ( exists $tmpl->{'store'} ) {
                _store_error( loc(
                    q|Store variable for '%1' is not a reference!|, $key
                ), 1, 0 ) unless ref $tmpl->{'store'};
            }
        }

        push @want_store, $key if $tmpl->{'store'};
    }

    ### errors found ###
    return if $fail;

    ### flag to see if anything went wrong ###
    my $wrong;

    ### flag to see if we warned for anything, needed for warnings_fatal
    my $warned;

    for my $key (keys %$args) {
        my $arg = $args->{$key};

        ### you gave us this key, but it's not in the template ###
        unless( $utmpl->{$key} ) {

            ### but we'll allow it anyway ###
            if( $ALLOW_UNKNOWN ) {
                $defs{$key} = $arg;

            ### warn about the error ###
            } else {
                _store_error(
                    loc("Key '%1' is not a valid key for %2 provided by %3",
                        $key, _who_was_it(), _who_was_it(1)), $verbose);
                $warned ||= 1;
            }
            next;
        }

        ### copy of this keys template instructions, to save derefs ###
        my %tmpl = %{$utmpl->{$key}};

        ### check if you're even allowed to override this key ###
        if( $tmpl{'no_override'} ) {
            _store_error(
                loc(q[You are not allowed to override key '%1'].
                    q[for %2 from %3], $key, _who_was_it(), _who_was_it(1)),
                $verbose
            );
            $warned ||= 1;
            next;
        }

        ### check if you were supposed to provide defined() values ###
        if( ($tmpl{'defined'} || $ONLY_ALLOW_DEFINED) and not defined $arg ) {
            _store_error(loc(q|Key '%1' must be defined when passed|, $key),
                $verbose );
            $wrong ||= 1;
            next;
        }

        ### check if they should be of a strict type, and if it is ###
        if( ($tmpl{'strict_type'} || $STRICT_TYPE) and
            (ref $arg ne ref $tmpl{'default'})
        ) {
            _store_error(loc(q|Key '%1' needs to be of type '%2'|,
                        $key, ref $tmpl{'default'} || 'SCALAR'), $verbose );
            $wrong ||= 1;
            next;
        }

        ### check if we have an allow handler, to validate against ###
        ### allow() will report its own errors ###
        if( exists $tmpl{'allow'} and not do {
                local $_ERROR_STRING;
                allow( $arg, $tmpl{'allow'} )
            }
        ) {
            ### stringify the value in the error report -- we don't want dumps
            ### of objects, but we do want to see *roughly* what we passed
            _store_error(loc(q|Key '%1' (%2) is of invalid type for '%3' |.
                             q|provided by %4|,
                            $key, "$arg", _who_was_it(),
                            _who_was_it(1)), $verbose);
            $wrong ||= 1;
            next;
        }

        ### we got here, then all must be OK ###
        $defs{$key} = $arg;

    }

    ### croak with the collected errors if there were errors and
    ### we have the fatal flag toggled.
    croak(__PACKAGE__->last_error) if ($wrong || $warned) && $WARNINGS_FATAL;

    ### done with our loop... if $wrong is set, something went wrong
    ### and the user is already informed, just return...
    return if $wrong;

    ### check if we need to store any of the keys ###
    ### can't do it before, because something may go wrong later,
    ### leaving the user with a few set variables
    for my $key (@want_store) {
        next unless exists $defs{$key};
        my $ref = $utmpl->{$key}{'store'};
        $$ref = $NO_DUPLICATES ? delete $defs{$key} : $defs{$key};
    }

    return \%defs;
}

=head2 allow( $test_me, \@criteria );

The function that handles the C<allow> key in the template is also
available for independent use.

The function takes as first argument a key to test against, and
as second argument any form of criteria that are also allowed by
the C<allow> key in the template.

You can use the following types of values for allow:

=over 4

=item string

The provided argument MUST be equal to the string for the validation
to pass.

=item regexp

The provided argument MUST match the regular expression for the
validation to pass.

=item subroutine

The provided subroutine MUST return true in order for the validation
to pass and the argument accepted.

(This is particularly useful for more complicated data).

=item array ref

The provided argument MUST equal one of the elements of the array
ref for the validation to pass. An array ref can hold all the above
values.

=back

It returns true if the key matched the criteria, or false otherwise.

=cut

sub allow {
    ### use $_[0] and $_[1] since this is hot code... ###
    #my ($val, $ref) = @_;

    ### it's a regexp ###
    if( ref $_[1] eq 'Regexp' ) {
        local $^W;  # silence warnings if $val is undef #
        return if $_[0] !~ /$_[1]/;

    ### it's a sub ###
    } elsif ( ref $_[1] eq 'CODE' ) {
        return unless $_[1]->( $_[0] );

    ### it's an array ###
    } elsif ( ref $_[1] eq 'ARRAY' ) {

        ### loop over the elements, see if one of them says the
        ### value is OK
        ### also, short-circuit when possible
        for ( @{$_[1]} ) {
            return 1 if allow( $_[0], $_ );
        }

        return;

    ### fall back to a simple, but safe 'eq' ###
    } else {
        return unless _safe_eq( $_[0], $_[1] );
    }

    ### we got here, no failures ###
    return 1;
}

### helper functions ###

sub _safe_eq {
    ### only do a straight 'eq' if they're both defined ###
    return defined($_[0]) && defined($_[1])
                ? $_[0] eq $_[1]
                : defined($_[0]) eq defined($_[1]);
}

sub _who_was_it {
    my $level = $_[0] || 0;

    return (caller(2 + $CALLER_DEPTH + $level))[3] || 'ANON'
}

=head2 last_error()

Returns a string containing all warnings and errors reported during
the last time C<check> was called.

This is useful if you want to report then some other way than
C<carp>'ing when the verbose flag is on.

It is exported upon request.

=cut

{   $_ERROR_STRING = '';

    sub _store_error {
        my($err, $verbose, $offset) = @_[0..2];
        $verbose ||= 0;
        $offset  ||= 0;
        my $level   = 1 + $offset;

        local $Carp::CarpLevel = $level;

        carp $err if $verbose;

        $_ERROR_STRING .= $err . "\n";
    }

    sub _clear_error {
        $_ERROR_STRING = '';
    }

    sub last_error { $_ERROR_STRING }
}

1;

=head1 Global Variables

The behaviour of Params::Check can be altered by changing the
following global variables:

=head2 $Params::Check::VERBOSE

This controls whether Params::Check will issue warnings and
explanations as to why certain things may have failed.
If you set it to 0, Params::Check will not output any warnings.

The default is 1 when L<warnings> are enabled, 0 otherwise;

=head2 $Params::Check::STRICT_TYPE

This works like the C<strict_type> option you can pass to C<check>,
which will turn on C<strict_type> globally for all calls to C<check>.

The default is 0;

=head2 $Params::Check::ALLOW_UNKNOWN

If you set this flag, unknown options will still be present in the
return value, rather than filtered out. This is useful if your
subroutine is only interested in a few arguments, and wants to pass
the rest on blindly to perhaps another subroutine.

The default is 0;

=head2 $Params::Check::STRIP_LEADING_DASHES

If you set this flag, all keys passed in the following manner:

    function( -key => 'val' );

will have their leading dashes stripped.

=head2 $Params::Check::NO_DUPLICATES

If set to true, all keys in the template that are marked as to be
stored in a scalar, will also be removed from the result set.

Default is false, meaning that when you use C<store> as a template
key, C<check> will put it both in the scalar you supplied, as well as
in the hashref it returns.

=head2 $Params::Check::PRESERVE_CASE

If set to true, L<Params::Check> will no longer convert all keys from
the user input to lowercase, but instead expect them to be in the
case the template provided. This is useful when you want to use
similar keys with different casing in your templates.

Understand that this removes the case-insensitivity feature of this
module.

Default is 0;

=head2 $Params::Check::ONLY_ALLOW_DEFINED

If set to true, L<Params::Check> will require all values passed to be
C<defined>. If you wish to enable this on a 'per key' basis, use the
template option C<defined> instead.

Default is 0;

=head2 $Params::Check::SANITY_CHECK_TEMPLATE

If set to true, L<Params::Check> will sanity check templates, validating
for errors and unknown keys. Although very useful for debugging, this
can be somewhat slow in hot-code and large loops.

To disable this check, set this variable to C<false>.

Default is 1;

=head2 $Params::Check::WARNINGS_FATAL

If set to true, L<Params::Check> will C<croak> when an error during
template validation occurs, rather than return C<false>.

Default is 0;

=head2 $Params::Check::CALLER_DEPTH

This global modifies the argument given to C<caller()> by
C<Params::Check::check()> and is useful if you have a custom wrapper
function around C<Params::Check::check()>. The value must be an
integer, indicating the number of wrapper functions inserted between
the real function call and C<Params::Check::check()>.

Example wrapper function, using a custom stacktrace:

    sub check {
        my ($template, $args_in) = @_;

        local $Params::Check::WARNINGS_FATAL = 1;
        local $Params::Check::CALLER_DEPTH = $Params::Check::CALLER_DEPTH + 1;
        my $args_out = Params::Check::check($template, $args_in);

        my_stacktrace(Params::Check::last_error) unless $args_out;

        return $args_out;
    }

Default is 0;

=head1 Acknowledgements

Thanks to Richard Soderberg for his performance improvements.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-params-check@rt.cpan.orgE<gt>.

=head1 AUTHOR

This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.


=cut

# Local variables:
# c-indentation-style: bsd
# c-basic-offset: 4
# indent-tabs-mode: nil
# End:
# vim: expandtab shiftwidth=4:
                                                                                                                              usr/share/perl/5.20.2/Parse/                                                                        0040755 0000000 0000000 00000000000 13077704254 013734  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Parse/CPAN/                                                                   0040755 0000000 0000000 00000000000 13077704254 014455  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Parse/CPAN/Meta.pm                                                            0100644 0000000 0000000 00000021040 12744441327 015672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        use 5.008001;
use strict;
package Parse::CPAN::Meta;
# ABSTRACT: Parse META.yml and META.json CPAN metadata files
our $VERSION = '1.4414'; # VERSION

use Exporter;
use Carp 'croak';

our @ISA = qw/Exporter/;
our @EXPORT_OK = qw/Load LoadFile/;

sub load_file {
  my ($class, $filename) = @_;

  my $meta = _slurp($filename);

  if ($filename =~ /\.ya?ml$/) {
    return $class->load_yaml_string($meta);
  }
  elsif ($filename =~ /\.json$/) {
    return $class->load_json_string($meta);
  }
  else {
    $class->load_string($meta); # try to detect yaml/json
  }
}

sub load_string {
  my ($class, $string) = @_;
  if ( $string =~ /^---/ ) { # looks like YAML
    return $class->load_yaml_string($string);
  }
  elsif ( $string =~ /^\s*\{/ ) { # looks like JSON
    return $class->load_json_string($string);
  }
  else { # maybe doc-marker-free YAML
    return $class->load_yaml_string($string);
  }
}

sub load_yaml_string {
  my ($class, $string) = @_;
  my $backend = $class->yaml_backend();
  my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
  croak $@ if $@;
  return $data || {}; # in case document was valid but empty
}

sub load_json_string {
  my ($class, $string) = @_;
  my $data = eval { $class->json_backend()->new->decode($string) };
  croak $@ if $@;
  return $data || {};
}

sub yaml_backend {
  if (! defined $ENV{PERL_YAML_BACKEND} ) {
    _can_load( 'CPAN::Meta::YAML', 0.011 )
      or croak "CPAN::Meta::YAML 0.011 is not available\n";
    return "CPAN::Meta::YAML";
  }
  else {
    my $backend = $ENV{PERL_YAML_BACKEND};
    _can_load( $backend )
      or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
    $backend->can("Load")
      or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
    return $backend;
  }
}

sub json_backend {
  if (! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
    _can_load( 'JSON::PP' => 2.27103 )
      or croak "JSON::PP 2.27103 is not available\n";
    return 'JSON::PP';
  }
  else {
    _can_load( 'JSON' => 2.5 )
      or croak  "JSON 2.5 is required for " .
                "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
    return "JSON";
  }
}

sub _slurp {
  require Encode;
  open my $fh, "<:raw", "$_[0]" ## no critic
    or die "can't open $_[0] for reading: $!";
  my $content = do { local $/; <$fh> };
  $content = Encode::decode('UTF-8', $content, Encode::PERLQQ());
  return $content;
}
  
sub _can_load {
  my ($module, $version) = @_;
  (my $file = $module) =~ s{::}{/}g;
  $file .= ".pm";
  return 1 if $INC{$file};
  return 0 if exists $INC{$file}; # prior load failed
  eval { require $file; 1 }
    or return 0;
  if ( defined $version ) {
    eval { $module->VERSION($version); 1 }
      or return 0;
  }
  return 1;
}

# Kept for backwards compatibility only
# Create an object from a file
sub LoadFile ($) {
  return Load(_slurp(shift));
}

# Parse a document from a string.
sub Load ($) {
  require CPAN::Meta::YAML;
  my $object = eval { CPAN::Meta::YAML::Load(shift) };
  croak $@ if $@;
  return $object;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files

=head1 VERSION

version 1.4414

=head1 SYNOPSIS

    #############################################
    # In your file
    
    ---
    name: My-Distribution
    version: 1.23
    resources:
      homepage: "http://example.com/dist/My-Distribution"
    
    
    #############################################
    # In your program
    
    use Parse::CPAN::Meta;
    
    my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
    
    # Reading properties
    my $name     = $distmeta->{name};
    my $version  = $distmeta->{version};
    my $homepage = $distmeta->{resources}{homepage};

=head1 DESCRIPTION

B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
L<JSON::PP> and/or L<CPAN::Meta::YAML>.

B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
are described below in detail.

B<Parse::CPAN::Meta> provides a legacy API of only two functions,
based on the YAML functions of the same name. Wherever possible,
identical calling semantics are used.  These may only be used with YAML sources.

All error reporting is done with exceptions (die'ing).

Note that META files are expected to be in UTF-8 encoding, only.  When
converted string data, it must first be decoded from UTF-8.

=begin Pod::Coverage




=end Pod::Coverage

=head1 METHODS

=head2 load_file

  my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');

  my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');

This method will read the named file and deserialize it to a data structure,
determining whether it should be JSON or YAML based on the filename.
The file will be read using the ":utf8" IO layer.

=head2 load_yaml_string

  my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);

This method deserializes the given string of YAML and returns the first
document in it.  (CPAN metadata files should always have only one document.)
If the source was UTF-8 encoded, the string must be decoded before calling
C<load_yaml_string>.

=head2 load_json_string

  my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);

This method deserializes the given string of JSON and the result.  
If the source was UTF-8 encoded, the string must be decoded before calling
C<load_json_string>.

=head2 load_string

  my $metadata_structure = Parse::CPAN::Meta->load_string($some_string);

If you don't know whether a string contains YAML or JSON data, this method
will use some heuristics and guess.  If it can't tell, it assumes YAML.

=head2 yaml_backend

  my $backend = Parse::CPAN::Meta->yaml_backend;

Returns the module name of the YAML serializer. See L</ENVIRONMENT>
for details.

=head2 json_backend

  my $backend = Parse::CPAN::Meta->json_backend;

Returns the module name of the JSON serializer.  This will either
be L<JSON::PP> or L<JSON>.  Even if C<PERL_JSON_BACKEND> is set,
this will return L<JSON> as further delegation is handled by
the L<JSON> module.  See L</ENVIRONMENT> for details.

=head1 FUNCTIONS

For maintenance clarity, no functions are exported by default.  These functions
are available for backwards compatibility only and are best avoided in favor of
C<load_file>.

=head2 Load

  my @yaml = Parse::CPAN::Meta::Load( $string );

Parses a string containing a valid YAML stream into a list of Perl data
structures.

=head2 LoadFile

  my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );

Reads the YAML stream from a file instead of a string.

=head1 ENVIRONMENT

=head2 PERL_JSON_BACKEND

By default, L<JSON::PP> will be used for deserializing JSON data. If the
C<PERL_JSON_BACKEND> environment variable exists, is true and is not
"JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
old, an exception will be thrown.

=head2 PERL_YAML_BACKEND

By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
as a module to use for deserialization.  The given module must be installed,
must load correctly and must implement the C<Load()> function or an exception
will be thrown.

=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

=head1 SUPPORT

=head2 Bugs / Feature Requests

Please report any bugs or feature requests through the issue tracker
at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta>.
You will be notified automatically of any progress on your issue.

=head2 Source Code

This is open source software.  The code repository is available for
public review and contribution under the terms of the license.

L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta>

  git clone https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta.git

=head1 AUTHORS

=over 4

=item *

Adam Kennedy <adamk@cpan.org>

=item *

David Golden <dagolden@cpan.org>

=back

=head1 CONTRIBUTORS

=over 4

=item *

Graham Knop <haarg@haarg.org>

=item *

Joshua ben Jore <jjore@cpan.org>

=item *

Neil Bowers <neil@bowers.com>

=item *

Ricardo Signes <rjbs@cpan.org>

=item *

Steffen Mueller <smueller@cpan.org>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2014 by Adam Kennedy and Contributors.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Perl/                                                                         0040755 0000000 0000000 00000000000 13077704254 013564  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Perl/OSType.pm                                                                0100644 0000000 0000000 00000010364 12744441327 015305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        use strict;
use warnings;

package Perl::OSType;
# ABSTRACT: Map Perl operating system names to generic types
our $VERSION = '1.007'; # VERSION

require Exporter;
our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( all => [qw( os_type is_os_type )] );

our @EXPORT_OK = @{ $EXPORT_TAGS{all} };

# originally taken from Module::Build by Ken Williams et al.
my %OSTYPES = qw(
  aix         Unix
  bsdos       Unix
  beos        Unix
  bitrig      Unix
  dgux        Unix
  dragonfly   Unix
  dynixptx    Unix
  freebsd     Unix
  linux       Unix
  haiku       Unix
  hpux        Unix
  iphoneos    Unix
  irix        Unix
  darwin      Unix
  machten     Unix
  midnightbsd Unix
  mirbsd      Unix
  next        Unix
  openbsd     Unix
  netbsd      Unix
  dec_osf     Unix
  nto         Unix
  svr4        Unix
  svr5        Unix
  sco_sv      Unix
  unicos      Unix
  unicosmk    Unix
  solaris     Unix
  sunos       Unix
  cygwin      Unix
  os2         Unix
  interix     Unix
  gnu         Unix
  gnukfreebsd Unix
  nto         Unix
  qnx         Unix
  android     Unix

  dos         Windows
  MSWin32     Windows

  os390       EBCDIC
  os400       EBCDIC
  posix-bc    EBCDIC
  vmesa       EBCDIC

  MacOS       MacOS
  VMS         VMS
  vos         VOS
  riscos      RiscOS
  amigaos     Amiga
  mpeix       MPEiX
);

sub os_type {
    my ($os) = @_;
    $os = $^O unless defined $os;
    return $OSTYPES{$os} || q{};
}

sub is_os_type {
    my ( $type, $os ) = @_;
    return unless $type;
    $os = $^O unless defined $os;
    return os_type($os) eq $type;
}

1;

=pod

=encoding UTF-8

=head1 NAME

Perl::OSType - Map Perl operating system names to generic types

=head1 VERSION

version 1.007

=head1 SYNOPSIS

  use Perl::OSType ':all';

  $current_type = os_type();
  $other_type = os_type('dragonfly'); # gives 'Unix'

=head1 DESCRIPTION

Modules that provide OS-specific behaviors often need to know if
the current operating system matches a more generic type of
operating systems. For example, 'linux' is a type of 'Unix' operating system
and so is 'freebsd'.

This module provides a mapping between an operating system name as given by
C<$^O> and a more generic type.  The initial version is based on the OS type
mappings provided in L<Module::Build> and L<ExtUtils::CBuilder>.  (Thus,
Microsoft operating systems are given the type 'Windows' rather than 'Win32'.)

=head1 USAGE

No functions are exported by default. The export tag ":all" will export
all functions listed below.

=head2 os_type()

  $os_type = os_type();
  $os_type = os_type('MSWin32');

Returns a single, generic OS type for a given operating system name.  With no
arguments, returns the OS type for the current value of C<$^O>.  If the
operating system is not recognized, the function will return the empty string.

=head2 is_os_type()

  $is_windows = is_os_type('Windows');
  $is_unix    = is_os_type('Unix', 'dragonfly');

Given an OS type and OS name, returns true or false if the OS name is of the
given type.  As with C<os_type>, it will use the current operating system as a
default if no OS name is provided.

=head1 SEE ALSO

=over 4

=item *

L<Devel::CheckOS>

=back

=for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

=head1 SUPPORT

=head2 Bugs / Feature Requests

Please report any bugs or feature requests through the issue tracker
at L<https://github.com/dagolden/Perl-OSType/issues>.
You will be notified automatically of any progress on your issue.

=head2 Source Code

This is open source software.  The code repository is available for
public review and contribution under the terms of the license.

L<https://github.com/dagolden/Perl-OSType>

  git clone https://github.com/dagolden/Perl-OSType.git

=head1 AUTHOR

David Golden <dagolden@cpan.org>

=head1 CONTRIBUTORS

=over 4

=item *

Jonas B. Nielsen <jonasbn@hoarfrost.local>

=item *

Owain G. Ainsworth <oga@nicotinebsd.org>

=item *

Paul Green <Paul.Green@stratus.com>

=item *

Piotr Roszatycki <piotr.roszatycki@gmail.com>

=back

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2014 by David Golden.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

__END__


# vim: ts=4 sts=4 sw=4 et:
                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/PerlIO/                                                                       0040755 0000000 0000000 00000000000 13077704253 014013  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/PerlIO/via/                                                                   0040755 0000000 0000000 00000000000 13077704254 014573  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/PerlIO/via/QuotedPrint.pm                                                     0100644 0000000 0000000 00000005035 12744441327 017406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package PerlIO::via::QuotedPrint;

$VERSION= '0.07';

# be as strict as possible
use strict;

# modules that we need
use MIME::QuotedPrint (); # no need to pollute this namespace

# satisfy -require-
1;

#-------------------------------------------------------------------------------
#
# Standard Perl features
#
#-------------------------------------------------------------------------------
#  IN: 1 class to bless with
#      2 mode string (ignored)
#      3 file handle of PerlIO layer below (ignored)
# OUT: 1 blessed object

sub PUSHED { bless \*PUSHED,$_[0] } #PUSHED

#-------------------------------------------------------------------------------
#  IN: 1 instantiated object (ignored)
#      2 handle to read from
# OUT: 1 decoded string

sub FILL {

    # decode and return
    my $line= readline( $_[1] );
    return ( defined $line )
      ? MIME::QuotedPrint::decode_qp($line)
      : undef;
} #FILL

#-------------------------------------------------------------------------------
#  IN: 1 instantiated object (ignored)
#      2 buffer to be written
#      3 handle to write to
# OUT: 1 number of bytes written

sub WRITE {

    # encode and write to handle: indicate result
    return ( print { $_[2] } MIME::QuotedPrint::encode_qp( $_[1] ) )
      ? length( $_[1] )
      : -1;
} #WRITE

#-------------------------------------------------------------------------------

__END__

=head1 NAME

PerlIO::via::QuotedPrint - PerlIO layer for quoted-printable strings

=head1 SYNOPSIS

 use PerlIO::via::QuotedPrint;

 open( my $in, '<:via(QuotedPrint)', 'file.qp' )
   or die "Can't open file.qp for reading: $!\n";
 
 open( my $out, '>:via(QuotedPrint)', 'file.qp' )
   or die "Can't open file.qp for writing: $!\n";

=head1 VERSION

This documentation describes version 0.07.

=head1 DESCRIPTION

This module implements a PerlIO layer that works on files encoded in the
quoted-printable format.  It will decode from quoted-printable while reading
from a handle, and it will encode as quoted-printable while writing to a handle.

=head1 REQUIRED MODULES

 MIME::QuotedPrint (any)

=head1 SEE ALSO

L<PerlIO::via>, L<MIME::QuotedPrint>, L<PerlIO::via::Base64>,
L<PerlIO::via::MD5>, L<PerlIO::via::StripHTML>, L<PerlIO::via::Rotate>.

=head1 ACKNOWLEDGEMENTS

Based on example that was initially added to MIME::QuotedPrint.pm for the
5.8.0 distribution of Perl.

=head1 COPYRIGHT

Copyright (c) 2002, 2003, 2004, 2012 Elizabeth Mattijsen.  All rights reserved.
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/PerlIO.pm                                                                     0100644 0000000 0000000 00000024332 12744441327 014352  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package PerlIO;

our $VERSION = '1.09';

# Map layer name to package that defines it
our %alias;

sub import
{
 my $class = shift;
 while (@_)
  {
   my $layer = shift;
   if (exists $alias{$layer})
    {
     $layer = $alias{$layer}
    }
   else
    {
     $layer = "${class}::$layer";
    }
   eval { require $layer =~ s{::}{/}gr . '.pm' };
   warn $@ if $@;
  }
}

sub F_UTF8 () { 0x8000 }

1;
__END__

=head1 NAME

PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space

=head1 SYNOPSIS

  open($fh, "<:crlf", "my.txt"); # support platform-native and 
                                 # CRLF text files

  open($fh, "<", "his.jpg"); # portably open a binary file for reading
  binmode($fh);

  Shell:
    PERLIO=perlio perl ....

=head1 DESCRIPTION

When an undefined layer 'foo' is encountered in an C<open> or
C<binmode> layer specification then C code performs the equivalent of:

  use PerlIO 'foo';

The perl code in PerlIO.pm then attempts to locate a layer by doing

  require PerlIO::foo;

Otherwise the C<PerlIO> package is a place holder for additional
PerlIO related functions.

The following layers are currently defined:

=over 4

=item :unix

Lowest level layer which provides basic PerlIO operations in terms of
UNIX/POSIX numeric file descriptor calls
(open(), read(), write(), lseek(), close()).

=item :stdio

Layer which calls C<fread>, C<fwrite> and C<fseek>/C<ftell> etc.  Note
that as this is "real" stdio it will ignore any layers beneath it and
go straight to the operating system via the C library as usual.

=item :perlio

A from scratch implementation of buffering for PerlIO. Provides fast
access to the buffer for C<sv_gets> which implements perl's readline/E<lt>E<gt>
and in general attempts to minimize data copying.

C<:perlio> will insert a C<:unix> layer below itself to do low level IO.

=item :crlf

A layer that implements DOS/Windows like CRLF line endings.  On read
converts pairs of CR,LF to a single "\n" newline character.  On write
converts each "\n" to a CR,LF pair.  Note that this layer will silently
refuse to be pushed on top of itself.

It currently does I<not> mimic MS-DOS as far as treating of Control-Z
as being an end-of-file marker.

Based on the C<:perlio> layer.

=item :utf8

Declares that the stream accepts perl's I<internal> encoding of
characters.  (Which really is UTF-8 on ASCII machines, but is
UTF-EBCDIC on EBCDIC machines.)  This allows any character perl can
represent to be read from or written to the stream. The UTF-X encoding
is chosen to render simple text parts (i.e.  non-accented letters,
digits and common punctuation) human readable in the encoded file.

(B<CAUTION>: This layer does not validate byte sequences.  For reading input,
you should instead use C<:encoding(utf8)> instead of bare C<:utf8>.)

Here is how to write your native data out using UTF-8 (or UTF-EBCDIC)
and then read it back in.

	open(F, ">:utf8", "data.utf");
	print F $out;
	close(F);

	open(F, "<:utf8", "data.utf");
	$in = <F>;
	close(F);


=item :bytes

This is the inverse of the C<:utf8> layer. It turns off the flag
on the layer below so that data read from it is considered to
be "octets" i.e. characters in the range 0..255 only. Likewise
on output perl will warn if a "wide" character is written
to a such a stream.

=item :raw

The C<:raw> layer is I<defined> as being identical to calling
C<binmode($fh)> - the stream is made suitable for passing binary data,
i.e. each byte is passed as-is. The stream will still be
buffered.

In Perl 5.6 and some books the C<:raw> layer (previously sometimes also
referred to as a "discipline") is documented as the inverse of the
C<:crlf> layer. That is no longer the case - other layers which would
alter the binary nature of the stream are also disabled.  If you want UNIX
line endings on a platform that normally does CRLF translation, but still
want UTF-8 or encoding defaults, the appropriate thing to do is to add
C<:perlio> to the PERLIO environment variable.

The implementation of C<:raw> is as a pseudo-layer which when "pushed"
pops itself and then any layers which do not declare themselves as suitable
for binary data. (Undoing :utf8 and :crlf are implemented by clearing
flags rather than popping layers but that is an implementation detail.)

As a consequence of the fact that C<:raw> normally pops layers,
it usually only makes sense to have it as the only or first element in
a layer specification.  When used as the first element it provides
a known base on which to build e.g.

    open($fh,":raw:utf8",...)

will construct a "binary" stream, but then enable UTF-8 translation.

=item :pop

A pseudo layer that removes the top-most layer. Gives perl code a
way to manipulate the layer stack.  Note that C<:pop> only works on
real layers and will not undo the effects of pseudo layers like
C<:utf8>.  An example of a possible use might be:

    open($fh,...)
    ...
    binmode($fh,":encoding(...)");  # next chunk is encoded
    ...
    binmode($fh,":pop");            # back to un-encoded

A more elegant (and safer) interface is needed.

=item :win32

On Win32 platforms this I<experimental> layer uses the native "handle" IO
rather than the unix-like numeric file descriptor layer. Known to be
buggy as of perl 5.8.2.

=back

=head2 Custom Layers

It is possible to write custom layers in addition to the above builtin
ones, both in C/XS and Perl.  Two such layers (and one example written
in Perl using the latter) come with the Perl distribution.

=over 4

=item :encoding

Use C<:encoding(ENCODING)> either in open() or binmode() to install
a layer that transparently does character set and encoding transformations,
for example from Shift-JIS to Unicode.  Note that under C<stdio>
an C<:encoding> also enables C<:utf8>.  See L<PerlIO::encoding>
for more information.

=item :mmap

A layer which implements "reading" of files by using C<mmap()> to
make a (whole) file appear in the process's address space, and then
using that as PerlIO's "buffer". This I<may> be faster in certain
circumstances for large files, and may result in less physical memory
use when multiple processes are reading the same file.

Files which are not C<mmap()>-able revert to behaving like the C<:perlio>
layer. Writes also behave like the C<:perlio> layer, as C<mmap()> for write
needs extra house-keeping (to extend the file) which negates any advantage.

The C<:mmap> layer will not exist if the platform does not support C<mmap()>.

=item :via

Use C<:via(MODULE)> either in open() or binmode() to install a layer
that does whatever transformation (for example compression /
decompression, encryption / decryption) to the filehandle.
See L<PerlIO::via> for more information.

=back

=head2 Alternatives to raw

To get a binary stream an alternate method is to use:

    open($fh,"whatever")
    binmode($fh);

this has the advantage of being backward compatible with how such things have
had to be coded on some platforms for years.

To get an unbuffered stream specify an unbuffered layer (e.g. C<:unix>)
in the open call:

    open($fh,"<:unix",$path)

=head2 Defaults and how to override them

If the platform is MS-DOS like and normally does CRLF to "\n"
translation for text files then the default layers are :

  unix crlf

(The low level "unix" layer may be replaced by a platform specific low
level layer.)

Otherwise if C<Configure> found out how to do "fast" IO using the system's
stdio, then the default layers are:

  unix stdio

Otherwise the default layers are

  unix perlio

These defaults may change once perlio has been better tested and tuned.

The default can be overridden by setting the environment variable
PERLIO to a space separated list of layers (C<unix> or platform low
level layer is always pushed first).

This can be used to see the effect of/bugs in the various layers e.g.

  cd .../perl/t
  PERLIO=stdio  ./perl harness
  PERLIO=perlio ./perl harness

For the various values of PERLIO see L<perlrun/PERLIO>.

=head2 Querying the layers of filehandles

The following returns the B<names> of the PerlIO layers on a filehandle.

   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, "FH".

The layers are returned in the order an open() or binmode() call would
use them.  Note that the "default stack" depends on the operating
system and on the Perl version, and both the compile-time and
runtime configurations of Perl.

The following table summarizes the default layers on UNIX-like and
DOS-like platforms and depending on the setting of C<$ENV{PERLIO}>:

 PERLIO     UNIX-like                   DOS-like
 ------     ---------                   --------
 unset / "" unix perlio / stdio [1]     unix crlf
 stdio      unix perlio / stdio [1]     stdio
 perlio     unix perlio                 unix perlio

 # [1] "stdio" if Configure found out how to do "fast stdio" (depends
 # on the stdio implementation) and in Perl 5.8, otherwise "unix perlio"

By default the layers from the input side of the filehandle are
returned; to get the output side, use the optional C<output> argument:

   my @layers = PerlIO::get_layers($fh, output => 1);

(Usually the layers are identical on either side of a filehandle but
for example with sockets there may be differences, or if you have
been using the C<open> pragma.)

There is no set_layers(), nor does get_layers() return a tied array
mirroring the stack, or anything fancy like that.  This is not
accidental or unintentional.  The PerlIO layer stack is a bit more
complicated than just a stack (see for example the behaviour of C<:raw>).
You are supposed to use open() and binmode() to manipulate the stack.

B<Implementation details follow, please close your eyes.>

The arguments to layers are by default returned in parentheses after
the name of the layer, and certain layers (like C<utf8>) are not real
layers but instead flags on real layers; to get all of these returned
separately, use the optional C<details> argument:

   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details => 1);

The result will be up to be three times the number of layers:
the first element will be a name, the second element the arguments
(unspecified arguments will be C<undef>), the third element the flags,
the fourth element a name again, and so forth.

B<You may open your eyes now.>

=head1 AUTHOR

Nick Ing-Simmons E<lt>nick@ing-simmons.netE<gt>

=head1 SEE ALSO

L<perlfunc/"binmode">, L<perlfunc/"open">, L<perlunicode>, L<perliol>,
L<Encode>

=cut
                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/Pod/                                                                          0040755 0000000 0000000 00000000000 13077704254 013404  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Pod/Checker.pm                                                                0100644 0000000 0000000 00000126113 12744441327 015306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #############################################################################
# Pod/Checker.pm -- check pod documents for syntax errors
#
# Copyright (C) 1994-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Checker;
use strict;

use vars qw($VERSION @ISA @EXPORT %VALID_COMMANDS %VALID_SEQUENCES);
$VERSION = '1.60';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

use Pod::ParseUtils; ## for hyperlinks and lists

=head1 NAME

Pod::Checker, podchecker() - check pod documents for syntax errors

=head1 SYNOPSIS

  use Pod::Checker;

  $num_errors = podchecker($filepath, $outputpath, %options);

  my $checker = new Pod::Checker %options;
  $checker->parse_from_file($filepath, \*STDERR);

=head1 OPTIONS/ARGUMENTS

C<$filepath> is the input POD to read and C<$outputpath> is
where to write POD syntax error messages. Either argument may be a scalar
indicating a file-path, or else a reference to an open filehandle.
If unspecified, the input-file it defaults to C<\*STDIN>, and
the output-file defaults to C<\*STDERR>.

=head2 podchecker()

This function can take a hash of options:

=over 4

=item B<-warnings> =E<gt> I<val>

Turn warnings on/off. I<val> is usually 1 for on, but higher values
trigger additional warnings. See L<"Warnings">.

=back

=head1 DESCRIPTION

B<podchecker> will perform syntax checking of Perl5 POD format documentation.

Curious/ambitious users are welcome to propose additional features they wish
to see in B<Pod::Checker> and B<podchecker> and verify that the checks are
consistent with L<perlpod>.

The following checks are currently performed:

=over 4

=item *

Unknown '=xxxx' commands, unknown 'XE<lt>...E<gt>' interior-sequences,
and unterminated interior sequences.

=item *

Check for proper balancing of C<=begin> and C<=end>. The contents of such
a block are generally ignored, i.e. no syntax checks are performed.

=item *

Check for proper nesting and balancing of C<=over>, C<=item> and C<=back>.

=item *

Check for same nested interior-sequences (e.g.
C<LE<lt>...LE<lt>...E<gt>...E<gt>>).

=item *

Check for malformed or non-existing entities C<EE<lt>...E<gt>>.

=item *

Check for correct syntax of hyperlinks C<LE<lt>...E<gt>>. See L<perlpod>
for details.

=item *

Check for unresolved document-internal links. This check may also reveal
misspelled links that seem to be internal links but should be links
to something else.

=back

=head1 DIAGNOSTICS

=head2 Errors

=over 4

=item * empty =headn

A heading (C<=head1> or C<=head2>) without any text? That ain't no
heading!

=item * =over on line I<N> without closing =back

The C<=over> command does not have a corresponding C<=back> before the
next heading (C<=head1> or C<=head2>) or the end of the file.

=item * =item without previous =over

=item * =back without previous =over

An C<=item> or C<=back> command has been found outside a
C<=over>/C<=back> block.

=item * No argument for =begin

A C<=begin> command was found that is not followed by the formatter
specification.

=item * =end without =begin

A standalone C<=end> command was found.

=item * Nested =begin's

There were at least two consecutive C<=begin> commands without
the corresponding C<=end>. Only one C<=begin> may be active at
a time.

=item * =for without formatter specification

There is no specification of the formatter after the C<=for> command.

=item * Apparent command =foo not preceded by blank line

A command which has ended up in the middle of a paragraph or other command,
such as

  =item one
  =item two <-- bad

=item * unresolved internal link I<NAME>

The given link to I<NAME> does not have a matching node in the current
POD. This also happened when a single word node name is not enclosed in
C<"">.

=item * Unknown command "I<CMD>"

An invalid POD command has been found. Valid are C<=head1>, C<=head2>,
C<=head3>, C<=head4>, C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>,
C<=for>, C<=pod>, C<=cut>

=item * Unknown interior-sequence "I<SEQ>"

An invalid markup command has been encountered. Valid are:
C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>,
C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>,
C<ZE<lt>E<gt>>

=item * nested commands I<CMD>E<lt>...I<CMD>E<lt>...E<gt>...E<gt>

Two nested identical markup commands have been found. Generally this
does not make sense.

=item * garbled entity I<STRING>

The I<STRING> found cannot be interpreted as a character entity.

=item * Entity number out of range

An entity specified by number (dec, hex, oct) is out of range (1-255).

=item * malformed link LE<lt>E<gt>

The link found cannot be parsed because it does not conform to the
syntax described in L<perlpod>.

=item * nonempty ZE<lt>E<gt>

The C<ZE<lt>E<gt>> sequence is supposed to be empty.

=item * empty XE<lt>E<gt>

The index entry specified contains nothing but whitespace.

=item * Spurious text after =pod / =cut

The commands C<=pod> and C<=cut> do not take any arguments.

=item * Spurious =cut command

A C<=cut> command was found without a preceding POD paragraph.

=item * Spurious =pod command

A C<=pod> command was found after a preceding POD paragraph.

=item * Spurious character(s) after =back

The C<=back> command does not take any arguments.

=back

=head2 Warnings

These may not necessarily cause trouble, but indicate mediocre style.

=over 4

=item * multiple occurrence of link target I<name>

The POD file has some C<=item> and/or C<=head> commands that have
the same text. Potential hyperlinks to such a text cannot be unique then.
This warning is printed only with warning level greater than one.

=item * line containing nothing but whitespace in paragraph

There is some whitespace on a seemingly empty line. POD is very sensitive
to such things, so this is flagged. B<vi> users switch on the B<list>
option to avoid this problem.

=begin _disabled_

=item * file does not start with =head

The file starts with a different POD directive than head.
This is most probably something you do not want.

=end _disabled_

=item * previous =item has no contents

There is a list C<=item> right above the flagged line that has no
text contents. You probably want to delete empty items.

=item * preceding non-item paragraph(s)

A list introduced by C<=over> starts with a text or verbatim paragraph,
but continues with C<=item>s. Move the non-item paragraph out of the
C<=over>/C<=back> block.

=item * =item type mismatch (I<one> vs. I<two>)

A list started with e.g. a bullet-like C<=item> and continued with a
numbered one. This is obviously inconsistent. For most translators the
type of the I<first> C<=item> determines the type of the list.

=item * I<N> unescaped C<E<lt>E<gt>> in paragraph

Angle brackets not written as C<E<lt>ltE<gt>> and C<E<lt>gtE<gt>>
can potentially cause errors as they could be misinterpreted as
markup commands. This is only printed when the -warnings level is
greater than 1.

=item * Unknown entity

A character entity was found that does not belong to the standard
ISO set or the POD specials C<verbar> and C<sol>.

=item * No items in =over

The list opened with C<=over> does not contain any items.

=item * No argument for =item

C<=item> without any parameters is deprecated. It should either be followed
by C<*> to indicate an unordered list, by a number (optionally followed
by a dot) to indicate an ordered (numbered) list or simple text for a
definition list.

=item * empty section in previous paragraph

The previous section (introduced by a C<=head> command) does not contain
any text. This usually indicates that something is missing. Note: A
C<=head1> followed immediately by C<=head2> does not trigger this warning.

=item * Verbatim paragraph in NAME section

The NAME section (C<=head1 NAME>) should consist of a single paragraph
with the script/module name, followed by a dash `-' and a very short
description of what the thing is good for.

=item * =headI<n> without preceding higher level

For example if there is a C<=head2> in the POD file prior to a
C<=head1>.

=back

=head2 Hyperlinks

There are some warnings with respect to malformed hyperlinks:

=over 4

=item * ignoring leading/trailing whitespace in link

There is whitespace at the beginning or the end of the contents of
LE<lt>...E<gt>.

=item * (section) in '$page' deprecated

There is a section detected in the page name of LE<lt>...E<gt>, e.g.
C<LE<lt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
Please write C<CE<lt>passwd(2)E<gt>> instead. Some formatters are able
to expand this to appropriate code. For links to (builtin) functions,
please say C<LE<lt>perlfunc/mkdirE<gt>>, without ().

=item * alternative text/node '%s' contains non-escaped | or /

The characters C<|> and C</> are special in the LE<lt>...E<gt> context.
Although the hyperlink parser does its best to determine which "/" is
text and which is a delimiter in case of doubt, one ought to escape
these literal characters like this:

  /     E<sol>
  |     E<verbar>

=back

=head1 RETURN VALUE

B<podchecker> returns the number of POD syntax errors found or -1 if
there were no POD commands at all found in the file.

=head1 EXAMPLES

See L</SYNOPSIS>

=head1 INTERFACE

While checking, this module collects document properties, e.g. the nodes
for hyperlinks (C<=headX>, C<=item>) and index entries (C<XE<lt>E<gt>>).
POD translators can use this feature to syntax-check and get the nodes in
a first pass before actually starting to convert. This is expensive in terms
of execution time, but allows for very robust conversions.

Since PodParser-1.24 the B<Pod::Checker> module uses only the B<poderror>
method to print errors and warnings. The summary output (e.g.
"Pod syntax OK") has been dropped from the module and has been included in
B<podchecker> (the script). This allows users of B<Pod::Checker> to
control completely the output behavior. Users of B<podchecker> (the script)
get the well-known behavior.

=cut

#############################################################################

#use diagnostics;
use Carp qw(croak);
use Exporter;
use Pod::Parser;

@ISA = qw(Pod::Parser);
@EXPORT = qw(&podchecker);

my %VALID_COMMANDS = (
    'pod'    =>  1,
    'cut'    =>  1,
    'head1'  =>  1,
    'head2'  =>  1,
    'head3'  =>  1,
    'head4'  =>  1,
    'over'   =>  1,
    'back'   =>  1,
    'item'   =>  1,
    'for'    =>  1,
    'begin'  =>  1,
    'end'    =>  1,
    'encoding' =>  1,
);

my %VALID_SEQUENCES = (
    'I'  =>  1,
    'B'  =>  1,
    'S'  =>  1,
    'C'  =>  1,
    'L'  =>  1,
    'F'  =>  1,
    'X'  =>  1,
    'Z'  =>  1,
    'E'  =>  1,
);

# stolen from HTML::Entities
my %ENTITIES = (
 # Some normal chars that have special meaning in SGML context
 amp    => '&',  # ampersand
'gt'    => '>',  # greater than
'lt'    => '<',  # less than
 quot   => '"',  # double quote

 # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
 AElig  => '',  # capital AE diphthong (ligature)
 Aacute => '',  # capital A, acute accent
 Acirc  => '',  # capital A, circumflex accent
 Agrave => '',  # capital A, grave accent
 Aring  => '',  # capital A, ring
 Atilde => '',  # capital A, tilde
 Auml   => '',  # capital A, dieresis or umlaut mark
 Ccedil => '',  # capital C, cedilla
 ETH    => '',  # capital Eth, Icelandic
 Eacute => '',  # capital E, acute accent
 Ecirc  => '',  # capital E, circumflex accent
 Egrave => '',  # capital E, grave accent
 Euml   => '',  # capital E, dieresis or umlaut mark
 Iacute => '',  # capital I, acute accent
 Icirc  => '',  # capital I, circumflex accent
 Igrave => '',  # capital I, grave accent
 Iuml   => '',  # capital I, dieresis or umlaut mark
 Ntilde => '',  # capital N, tilde
 Oacute => '',  # capital O, acute accent
 Ocirc  => '',  # capital O, circumflex accent
 Ograve => '',  # capital O, grave accent
 Oslash => '',  # capital O, slash
 Otilde => '',  # capital O, tilde
 Ouml   => '',  # capital O, dieresis or umlaut mark
 THORN  => '',  # capital THORN, Icelandic
 Uacute => '',  # capital U, acute accent
 Ucirc  => '',  # capital U, circumflex accent
 Ugrave => '',  # capital U, grave accent
 Uuml   => '',  # capital U, dieresis or umlaut mark
 Yacute => '',  # capital Y, acute accent
 aacute => '',  # small a, acute accent
 acirc  => '',  # small a, circumflex accent
 aelig  => '',  # small ae diphthong (ligature)
 agrave => '',  # small a, grave accent
 aring  => '',  # small a, ring
 atilde => '',  # small a, tilde
 auml   => '',  # small a, dieresis or umlaut mark
 ccedil => '',  # small c, cedilla
 eacute => '',  # small e, acute accent
 ecirc  => '',  # small e, circumflex accent
 egrave => '',  # small e, grave accent
 eth    => '',  # small eth, Icelandic
 euml   => '',  # small e, dieresis or umlaut mark
 iacute => '',  # small i, acute accent
 icirc  => '',  # small i, circumflex accent
 igrave => '',  # small i, grave accent
 iuml   => '',  # small i, dieresis or umlaut mark
 ntilde => '',  # small n, tilde
 oacute => '',  # small o, acute accent
 ocirc  => '',  # small o, circumflex accent
 ograve => '',  # small o, grave accent
 oslash => '',  # small o, slash
 otilde => '',  # small o, tilde
 ouml   => '',  # small o, dieresis or umlaut mark
 szlig  => '',  # small sharp s, German (sz ligature)
 thorn  => '',  # small thorn, Icelandic
 uacute => '',  # small u, acute accent
 ucirc  => '',  # small u, circumflex accent
 ugrave => '',  # small u, grave accent
 uuml   => '',  # small u, dieresis or umlaut mark
 yacute => '',  # small y, acute accent
 yuml   => '',  # small y, dieresis or umlaut mark

 # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
 copy   => '',  # copyright sign
 reg    => '',  # registered sign
 nbsp   => "\240", # non breaking space

 # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
 iexcl  => '',
 cent   => '',
 pound  => '',
 curren => '',
 yen    => '',
 brvbar => '',
 sect   => '',
 uml    => '',
 ordf   => '',
 laquo  => '',
'not'   => '',    # not is a keyword in perl
 shy    => '',
 macr   => '',
 deg    => '',
 plusmn => '',
 sup1   => '',
 sup2   => '',
 sup3   => '',
 acute  => '',
 micro  => '',
 para   => '',
 middot => '',
 cedil  => '',
 ordm   => '',
 raquo  => '',
 frac14 => '',
 frac12 => '',
 frac34 => '',
 iquest => '',
'times' => '',    # times is a keyword in perl
 divide => '',

# some POD special entities
 verbar => '|',
 sol => '/'
);

##---------------------------------------------------------------------------

##---------------------------------
## Function definitions begin here
##---------------------------------

sub podchecker {
    my ($infile, $outfile, %options) = @_;
    local $_;

    ## Set defaults
    $infile  ||= \*STDIN;
    $outfile ||= \*STDERR;

    ## Now create a pod checker
    my $checker = new Pod::Checker(%options);

    ## Now check the pod document for errors
    $checker->parse_from_file($infile, $outfile);

    ## Return the number of errors found
    return $checker->num_errors();
}

##---------------------------------------------------------------------------

##-------------------------------
## Method definitions begin here
##-------------------------------

##################################

=over 4

=item C<Pod::Checker-E<gt>new( %options )>

Return a reference to a new Pod::Checker object that inherits from
Pod::Parser and is used for calling the required methods later. The
following options are recognized:

C<-warnings =E<gt> num>
  Print warnings if C<num> is true. The higher the value of C<num>,
the more warnings are printed. Currently there are only levels 1 and 2.

C<-quiet =E<gt> num>
  If C<num> is true, do not print any errors/warnings. This is useful
when Pod::Checker is used to munge POD code into plain text from within
POD formatters.

=cut

## sub new {
##     my $this = shift;
##     my $class = ref($this) || $this;
##     my %params = @_;
##     my $self = {%params};
##     bless $self, $class;
##     $self->initialize();
##     return $self;
## }

sub initialize {
    my $self = shift;
    ## Initialize number of errors, and setup an error function to
    ## increment this number and then print to the designated output.
    $self->{_NUM_ERRORS} = 0;
    $self->{_NUM_WARNINGS} = 0;
    $self->{-quiet} ||= 0;
    # set the error handling subroutine
    $self->errorsub($self->{-quiet} ? sub { 1; } : 'poderror');
    $self->{_commands} = 0; # total number of POD commands encountered
    $self->{_list_stack} = []; # stack for nested lists
    $self->{_have_begin} = ''; # stores =begin
    $self->{_links} = []; # stack for internal hyperlinks
    $self->{_nodes} = []; # stack for =head/=item nodes
    $self->{_index} = []; # text in X<>
    # print warnings?
    $self->{-warnings} = 1 unless(defined $self->{-warnings});
    $self->{_current_head1} = ''; # the current =head1 block
    $self->parseopts(-process_cut_cmd => 1, -warnings => $self->{-warnings});
}

##################################

=item C<$checker-E<gt>poderror( @args )>

=item C<$checker-E<gt>poderror( {%opts}, @args )>

Internal method for printing errors and warnings. If no options are
given, simply prints "@_". The following options are recognized and used
to form the output:

  -msg

A message to print prior to C<@args>.

  -line

The line number the error occurred in.

  -file

The file (name) the error occurred in.

  -severity

The error level, should be 'WARNING' or 'ERROR'.

=cut

# Invoked as $self->poderror( @args ), or $self->poderror( {%opts}, @args )
sub poderror {
    my $self = shift;
    my %opts = (ref $_[0]) ? %{shift()} : ();

    ## Retrieve options
    chomp( my $msg  = ($opts{-msg} || '')."@_" );
    my $line = (exists $opts{-line}) ? " at line $opts{-line}" : '';
    my $file = (exists $opts{-file}) ? " in file $opts{-file}" : '';
    unless (exists $opts{-severity}) {
       ## See if can find severity in message prefix
       $opts{-severity} = $1  if ( $msg =~ s/^\**\s*([A-Z]{3,}):\s+// );
    }
    my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : '';

    ## Increment error count and print message "
    ++($self->{_NUM_ERRORS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'ERROR'));
    ++($self->{_NUM_WARNINGS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'WARNING'));
    unless($self->{-quiet}) {
      my $out_fh = $self->output_handle() || \*STDERR;
      print $out_fh ($severity, $msg, $line, $file, "\n")
        if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
    }
}

##################################

=item C<$checker-E<gt>num_errors()>

Set (if argument specified) and retrieve the number of errors found.

=cut

sub num_errors {
   return (@_ > 1) ? ($_[0]->{_NUM_ERRORS} = $_[1]) : $_[0]->{_NUM_ERRORS};
}

##################################

=item C<$checker-E<gt>num_warnings()>

Set (if argument specified) and retrieve the number of warnings found.

=cut

sub num_warnings {
   return (@_ > 1) ? ($_[0]->{_NUM_WARNINGS} = $_[1]) : $_[0]->{_NUM_WARNINGS};
}

##################################

=item C<$checker-E<gt>name()>

Set (if argument specified) and retrieve the canonical name of POD as
found in the C<=head1 NAME> section.

=cut

sub name {
    return (@_ > 1 && $_[1]) ?
        ($_[0]->{-name} = $_[1]) : $_[0]->{-name};
}

##################################

=item C<$checker-E<gt>node()>

Add (if argument specified) and retrieve the nodes (as defined by C<=headX>
and C<=item>) of the current POD. The nodes are returned in the order of
their occurrence. They consist of plain text, each piece of whitespace is
collapsed to a single blank.

=cut

sub node {
    my ($self,$text) = @_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@{$self->{_nodes}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @{$self->{_nodes}};
}

##################################

=item C<$checker-E<gt>idx()>

Add (if argument specified) and retrieve the index entries (as defined by
C<XE<lt>E<gt>>) of the current POD. They consist of plain text, each piece
of whitespace is collapsed to a single blank.

=cut

# set/return index entries of current POD
sub idx {
    my ($self,$text) = @_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@{$self->{_index}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @{$self->{_index}};
}

##################################

=item C<$checker-E<gt>hyperlink()>

Add (if argument specified) and retrieve the hyperlinks (as defined by
C<LE<lt>E<gt>>) of the current POD. They consist of a 2-item array: line
number and C<Pod::Hyperlink> object.

=back

=cut

# set/return hyperlinks of the current POD
sub hyperlink {
    my $self = shift;
    if($_[0]) {
        push(@{$self->{_links}}, $_[0]);
        return $_[0];
    }
    @{$self->{_links}};
}

## overrides for Pod::Parser

sub end_pod {
    ## Do some final checks and
    ## print the number of errors found
    my $self   = shift;
    my $infile = $self->input_file();

    if(@{$self->{_list_stack}}) {
        my $list;
        while(($list = $self->_close_list('EOF',$infile)) &&
          $list->indent() ne 'auto') {
            $self->poderror({ -line => 'EOF', -file => $infile,
                -severity => 'ERROR', -msg => '=over on line ' .
                $list->start() . ' without closing =back' });
        }
    }

    # check validity of document internal hyperlinks
    # first build the node names from the paragraph text
    my %nodes;
    foreach($self->node()) {
        $nodes{$_} = 1;
        if(/^(\S+)\s+\S/) {
            # we have more than one word. Use the first as a node, too.
            # This is used heavily in perlfunc.pod
            $nodes{$1} ||= 2; # derived node
        }
    }
    foreach($self->idx()) {
        $nodes{$_} = 3; # index node
    }
    foreach($self->hyperlink()) {
        my ($line,$link) = @$_;
        # _TODO_ what if there is a link to the page itself by the name,
        # e.g. in Tk::Pod : L<Tk::Pod/"DESCRIPTION">
        if($link->node() && !$link->page() && $link->type() ne 'hyperlink') {
            my $node = $self->_check_ptree($self->parse_text($link->node(),
                $line), $line, $infile, 'L');
            if($node && !$nodes{$node}) {
                $self->poderror({ -line => $line || '', -file => $infile,
                    -severity => 'ERROR',
                    -msg => "unresolved internal link '$node'"});
            }
        }
    }

    # check the internal nodes for uniqueness. This pertains to
    # =headX, =item and X<...>
    if($self->{-warnings} && $self->{-warnings}>1) {
      foreach(grep($self->{_unique_nodes}->{$_} > 1,
        keys %{$self->{_unique_nodes}})) {
          $self->poderror({ -line => '-', -file => $infile,
            -severity => 'WARNING',
            -msg => "multiple occurrence of link target '$_'"});
      }
    }

    # no POD found here
    $self->num_errors(-1) if($self->{_commands} == 0);
}

# check a POD command directive
sub command {
    my ($self, $cmd, $paragraph, $line_num, $pod_para) = @_;
    my ($file, $line) = $pod_para->file_line;
    ## Check the command syntax
    my $arg; # this will hold the command argument
    if (! $VALID_COMMANDS{$cmd}) {
       $self->poderror({ -line => $line, -file => $file, -severity => 'ERROR',
                         -msg => "Unknown command '$cmd'" });
    }
    else { # found a valid command
        $self->{_commands}++; # delete this line if below is enabled again

	$self->_commands_in_paragraphs($paragraph, $pod_para);

        ##### following check disabled due to strong request
        #if(!$self->{_commands}++ && $cmd !~ /^head/) {
        #    $self->poderror({ -line => $line, -file => $file,
        #         -severity => 'WARNING',
        #         -msg => "file does not start with =head" });
        #}

        # check syntax of particular command
        if($cmd eq 'over') {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            my $indent = 4; # default
            if($arg && $arg =~ /^\s*(\d+)\s*$/) {
                $indent = $1;
            }
            # start a new list
            $self->_open_list($indent,$line,$file);
        }
        elsif($cmd eq 'item') {
            # are we in a list?
            unless(@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=item without previous =over' });
                # auto-open in case we encounter many more
                $self->_open_list('auto',$line,$file);
            }
            my $list = $self->{_list_stack}->[0];
            # check whether the previous item had some contents
            if(defined $self->{_list_item_contents} &&
              $self->{_list_item_contents} == 0) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'previous =item has no contents' });
            }
            if($list->{_has_par}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'preceding non-item paragraph(s)' });
                delete $list->{_has_par};
            }
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line, $file);
            if($arg && $arg =~ /(\S+)/) {
                $arg =~ s/[\s\n]+$//;
                my $type;
                if($arg =~ /^[*]\s*(\S*.*)/) {
                  $type = 'bullet';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                elsif($arg =~ /^\d+\.?\s+(\S*)/) {
                  $type = 'number';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                else {
                  $type = 'definition';
                  $self->{_list_item_contents} = 1;
                }
                my $first = $list->type();
                if($first && $first ne $type) {
                    $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => "=item type mismatch ('$first' vs. '$type')"});
                }
                else { # first item
                    $list->type($type);
                }
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'No argument for =item' });
                $arg = ' '; # empty
                $self->{_list_item_contents} = 0;
            }
            # add this item
            $list->item($arg);
            # remember this node
            $self->node($arg);
        }
        elsif($cmd eq 'back') {
            # check if we have an open list
            unless(@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=back without previous =over' });
            }
            else {
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                if($arg && $arg =~ /\S/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'Spurious character(s) after =back' });
                }
                # close list
                my $list = $self->_close_list($line,$file);
                # check for empty lists
                if(!$list->item() && $self->{-warnings}) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'WARNING',
                         -msg => 'No items in =over (at line ' .
                         $list->start() . ') / =back list'});
                }
            }
        }
        elsif($cmd =~ /^head(\d+)/) {
            my $hnum = $1;
            $self->{"_have_head_$hnum"}++; # count head types
            if($hnum > 1 && !$self->{'_have_head_'.($hnum -1)}) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'WARNING',
                   -msg => "=head$hnum without preceding higher level"});
            }
            # check whether the previous =head section had some contents
            if(defined $self->{_commands_in_head} &&
              $self->{_commands_in_head} == 0 &&
              defined $self->{_last_head} &&
              $self->{_last_head} >= $hnum) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'empty section in previous paragraph'});
            }
            $self->{_commands_in_head} = -1;
            $self->{_last_head} = $hnum;
            # check if there is an open list
            if(@{$self->{_list_stack}}) {
                my $list;
                while(($list = $self->_close_list($line,$file)) &&
                  $list->indent() ne 'auto') {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=over on line '. $list->start() .
                         " without closing =back (at $cmd)" });
                }
            }
            # remember this node
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            $arg =~ s/[\s\n]+$//s;
            $self->node($arg);
            unless(length($arg)) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => "empty =$cmd"});
            }
            if($cmd eq 'head1') {
                $self->{_current_head1} = $arg;
            } else {
                $self->{_current_head1} = '';
            }
        }
        elsif($cmd eq 'begin') {
            if($self->{_have_begin}) {
                # already have a begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => q{Nested =begin's (first at line } .
                     $self->{_have_begin} . ')'});
            }
            else {
                # check for argument
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                unless($arg && $arg =~ /(\S+)/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'No argument for =begin'});
                }
                # remember the =begin
                $self->{_have_begin} = "$line:$1";
            }
        }
        elsif($cmd eq 'end') {
            if($self->{_have_begin}) {
                # close the existing =begin
                $self->{_have_begin} = '';
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                # the closing argument is optional
                #if($arg && $arg =~ /\S/) {
                #    $self->poderror({ -line => $line, -file => $file,
                #         -severity => 'WARNING',
                #         -msg => "Spurious character(s) after =end" });
                #}
            }
            else {
                # don't have a matching =begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=end without =begin' });
            }
        }
        elsif($cmd eq 'for') {
            unless($paragraph =~ /\s*(\S+)\s*/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=for without formatter specification' });
            }
            $arg = ''; # do not expand paragraph below
        }
        elsif($cmd =~ /^(pod|cut)$/) {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            if($arg && $arg =~ /(\S+)/) {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious text after =$cmd"});
            }
	    if($cmd eq 'cut' && (!$self->{_PREVIOUS} || $self->{_PREVIOUS} eq 'cut')) {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious =cut command"});
	    }
	    if($cmd eq 'pod' && $self->{_PREVIOUS} && $self->{_PREVIOUS} ne 'cut') {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious =pod command"});
	    }
        }
    $self->{_commands_in_head}++;
    ## Check the interior sequences in the command-text
    $self->interpolate_and_check($paragraph, $line,$file)
        unless(defined $arg);
    }
}

sub _open_list
{
    my ($self,$indent,$line,$file) = @_;
    my $list = Pod::List->new(
           -indent => $indent,
           -start => $line,
           -file => $file);
    unshift(@{$self->{_list_stack}}, $list);
    undef $self->{_list_item_contents};
    $list;
}

sub _close_list
{
    my ($self,$line,$file) = @_;
    my $list = shift(@{$self->{_list_stack}});
    if(defined $self->{_list_item_contents} &&
      $self->{_list_item_contents} == 0) {
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'previous =item has no contents' });
    }
    undef $self->{_list_item_contents};
    $list;
}

# process a block of some text
sub interpolate_and_check {
    my ($self, $paragraph, $line, $file) = @_;
    ## Check the interior sequences in the command-text
    # and return the text
    $self->_check_ptree(
        $self->parse_text($paragraph,$line), $line, $file, '');
}

sub _check_ptree {
    my ($self,$ptree,$line,$file,$nestlist) = @_;
    local($_);
    my $text = '';
    # process each node in the parse tree
    foreach(@$ptree) {
        # regular text chunk
        unless(ref) {
            # count the unescaped angle brackets
            # complain only when warning level is greater than 1
            if($self->{-warnings} && $self->{-warnings}>1) {
              my $count;
              if($count = tr/<>/<>/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => "$count unescaped <> in paragraph" });
                }
            }
            $text .= $_;
            next;
        }
        # have an interior sequence
        my $cmd = $_->cmd_name();
        my $contents = $_->parse_tree();
        ($file,$line) = $_->file_line();
        # check for valid tag
        if (! $VALID_SEQUENCES{$cmd}) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'ERROR',
                 -msg => qq(Unknown interior-sequence '$cmd')});
            # expand it anyway
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            next;
        }
        if(index($nestlist, $cmd) != -1) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'WARNING',
                 -msg => "nested commands $cmd<...$cmd<...>...>"});
            # _TODO_ should we add the contents anyway?
            # expand it anyway, see below
        }
        if($cmd eq 'E') {
            # preserve entities
            if(@$contents > 1 || ref $$contents[0] || $$contents[0] !~ /^\w+$/) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'garbled entity ' . $_->raw_text()});
                next;
            }
            my $ent = $$contents[0];
            my $val;
            if($ent =~ /^0x[0-9a-f]+$/i) {
                # hexadec entity
                $val = hex($ent);
            }
            elsif($ent =~ /^0\d+$/) {
                # octal
                $val = oct($ent);
            }
            elsif($ent =~ /^\d+$/) {
                # numeric entity
                $val = $ent;
            }
            if(defined $val) {
                if($val>0 && $val<256) {
                    $text .= chr($val);
                }
                else {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => 'Entity number out of range ' . $_->raw_text()});
                }
            }
            elsif($ENTITIES{$ent}) {
                # known ISO entity
                $text .= $ENTITIES{$ent};
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'WARNING',
                    -msg => 'Unknown entity ' . $_->raw_text()});
                $text .= "E<$ent>";
            }
        }
        elsif($cmd eq 'L') {
            # try to parse the hyperlink
            my $link = Pod::Hyperlink->new($contents->raw_text());
            unless(defined $link) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'malformed link ' . $_->raw_text() ." : $@"});
                next;
            }
            $link->line($line); # remember line
            if($self->{-warnings}) {
                foreach my $w ($link->warning()) {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'WARNING',
                        -msg => $w });
                }
            }
            # check the link text
            $text .= $self->_check_ptree($self->parse_text($link->text(),
                $line), $line, $file, "$nestlist$cmd");
            # remember link
            $self->hyperlink([$line,$link]);
        }
        elsif($cmd =~ /[BCFIS]/) {
            # add the guts
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
        }
        elsif($cmd eq 'Z') {
            if(length($contents->raw_text())) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Nonempty Z<>'});
            }
        }
        elsif($cmd eq 'X') {
            my $idx = $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            if($idx =~ /^\s*$/s) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Empty X<>'});
            }
            else {
                # remember this node
                $self->idx($idx);
            }
        }
        else {
            # not reached
            croak 'internal error';
        }
    }
    $text;
}

# process a block of verbatim text
sub verbatim {
    ## Nothing particular to check
    my ($self, $paragraph, $line_num, $pod_para) = @_;

    $self->_preproc_par($paragraph);
    $self->_commands_in_paragraphs($paragraph, $pod_para);

    if($self->{_current_head1} eq 'NAME') {
        my ($file, $line) = $pod_para->file_line;
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'Verbatim paragraph in NAME section' });
    }
}

# process a block of regular text
sub textblock {
    my ($self, $paragraph, $line_num, $pod_para) = @_;
    my ($file, $line) = $pod_para->file_line;

    $self->_preproc_par($paragraph);
    $self->_commands_in_paragraphs($paragraph, $pod_para);

    # skip this paragraph if in a =begin block
    unless($self->{_have_begin}) {
        my $block = $self->interpolate_and_check($paragraph, $line,$file);
        if($self->{_current_head1} eq 'NAME') {
            if($block =~ /^\s*(\S+?)\s*[,-]/) {
                # this is the canonical name
                $self->{-name} = $1 unless(defined $self->{-name});
            }
        }
    }
}

sub _preproc_par
{
    my $self = shift;
    $_[0] =~ s/[\s\n]+$//;
    if($_[0]) {
        $self->{_commands_in_head}++;
        $self->{_list_item_contents}++ if(defined $self->{_list_item_contents});
        if(@{$self->{_list_stack}} && !$self->{_list_stack}->[0]->item()) {
            $self->{_list_stack}->[0]->{_has_par} = 1;
        }
    }
}

# look for =foo commands at the start of a line within a paragraph, as for
# instance the following which prints as "* one =item two".
#
#     =item one
#     =item two
#
# Examples of =foo written in docs are expected to be indented in a verbatim
# or marked up C<=foo> so won't be caught.  A double-angle C<< =foo >> could
# have the =foo at the start of a line, but that should be unlikely and is
# easily enough dealt with by not putting a newline after the C<<.
#
sub _commands_in_paragraphs {
  my ($self, $str, $pod_para) = @_;
  while ($str =~ /[^\n]\n=([a-z][a-z0-9]+)/sg) {
    my $cmd = $1;
    my $pos = pos($str);
    if ($VALID_COMMANDS{$cmd}) {
      my ($file, $line) = $pod_para->file_line;
      my $part = substr($str, 0, $pos);
      $line += ($part =~ tr/\n//);  # count of newlines

      $self->poderror
        ({ -line => $line, -file => $file,
           -severity => 'ERROR',
           -msg => "Apparent command =$cmd not preceded by blank line"});
    }
  }
}

1;

__END__

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@enteract.comE<gt> (initial version),
Marek Rouchal E<lt>marekr@cpan.orgE<gt>

Based on code for B<Pod::Text::pod2text()> written by
Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>

B<Pod::Checker> is part of the Pod-Checker distribution, and is based on
L<Pod::Parser>.

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Pod/Escapes.pm                                                                0100644 0000000 0000000 00000042333 12744441327 015326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Escapes;
use strict;
use warnings;
use 5.006;

use vars qw(
  %Code2USASCII
  %Name2character
  %Name2character_number
  %Latin1Code_to_fallback
  %Latin1Char_to_fallback
  $FAR_CHAR
  $FAR_CHAR_NUMBER
  $NOT_ASCII
  @ISA $VERSION @EXPORT_OK %EXPORT_TAGS
);

require Exporter;
@ISA = ('Exporter');
$VERSION = '1.06';
@EXPORT_OK = qw(
  %Code2USASCII
  %Name2character
  %Name2character_number
  %Latin1Code_to_fallback
  %Latin1Char_to_fallback
  e2char
  e2charnum
);
%EXPORT_TAGS = ('ALL' => \@EXPORT_OK);

#==========================================================================

$FAR_CHAR = "?" unless defined $FAR_CHAR;
$FAR_CHAR_NUMBER = ord($FAR_CHAR) unless defined $FAR_CHAR_NUMBER;

$NOT_ASCII = 'A' ne chr(65) unless defined $NOT_ASCII;

#--------------------------------------------------------------------------
sub e2char {
  my $in = $_[0];
  return undef unless defined $in and length $in;
  
  # Convert to decimal:
  if($in =~ m/^(0[0-7]*)$/s ) {
    $in = oct $in;
  } elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s ) {
    $in = hex $1;
  } # else it's decimal, or named

  if($NOT_ASCII) {
    # We're in bizarro world of not-ASCII!
    # Cope with US-ASCII codes, use fallbacks for Latin-1, or use FAR_CHAR.
    unless($in =~ m/^\d+$/s) {
      # It's a named character reference.  Get its numeric Unicode value.
      $in = $Name2character{$in};
      return undef unless defined $in;  # (if there's no such name)
      $in = ord $in; # (All ents must be one character long.)
        # ...So $in holds the char's US-ASCII numeric value, which we'll
        #  now go get the local equivalent for.
    }

    # It's numeric, whether by origin or by mutation from a known name
    return $Code2USASCII{$in} # so "65" => "A" everywhere
        || $Latin1Code_to_fallback{$in} # Fallback.
        || $FAR_CHAR; # Fall further back
  }
  
  # Normal handling:
  if($in =~ m/^\d+$/s) {
    if($] < 5.007  and  $in > 255) { # can't be trusted with Unicode
      return $FAR_CHAR;
    } else {
      return chr($in);
    }
  } else {
    return $Name2character{$in}; # returns undef if unknown
  }
}

#--------------------------------------------------------------------------
sub e2charnum {
  my $in = $_[0];
  return undef unless defined $in and length $in;
  
  # Convert to decimal:
  if($in =~ m/^(0[0-7]*)$/s ) {
    $in = oct $in;
  } elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s ) {
    $in = hex $1;
  } # else it's decimal, or named

  if($in =~ m/^[0-9]+$/s) {
    return 0 + $in;
  } else {
    return $Name2character_number{$in}; # returns undef if unknown
  }
}

#--------------------------------------------------------------------------

%Name2character_number = (
 # General XML/XHTML:
 'lt'   => 60,
 'gt'   => 62,
 'quot' => 34,
 'amp'  => 38,
 'apos' => 39,

 # POD-specific:
 'sol'    => 47,
 'verbar' => 124,

 'lchevron' => 171, # legacy for laquo
 'rchevron' => 187, # legacy for raquo

 # Remember, grave looks like \ (as in virtu\)
 #           acute looks like / (as in re/sume/)
 #           circumflex looks like ^ (as in papier ma^che/)
 #           umlaut/dieresis looks like " (as in nai"ve, Chloe")

 # From the XHTML 1 .ent files:
 'nbsp'     , 160,
 'iexcl'    , 161,
 'cent'     , 162,
 'pound'    , 163,
 'curren'   , 164,
 'yen'      , 165,
 'brvbar'   , 166,
 'sect'     , 167,
 'uml'      , 168,
 'copy'     , 169,
 'ordf'     , 170,
 'laquo'    , 171,
 'not'      , 172,
 'shy'      , 173,
 'reg'      , 174,
 'macr'     , 175,
 'deg'      , 176,
 'plusmn'   , 177,
 'sup2'     , 178,
 'sup3'     , 179,
 'acute'    , 180,
 'micro'    , 181,
 'para'     , 182,
 'middot'   , 183,
 'cedil'    , 184,
 'sup1'     , 185,
 'ordm'     , 186,
 'raquo'    , 187,
 'frac14'   , 188,
 'frac12'   , 189,
 'frac34'   , 190,
 'iquest'   , 191,
 'Agrave'   , 192,
 'Aacute'   , 193,
 'Acirc'    , 194,
 'Atilde'   , 195,
 'Auml'     , 196,
 'Aring'    , 197,
 'AElig'    , 198,
 'Ccedil'   , 199,
 'Egrave'   , 200,
 'Eacute'   , 201,
 'Ecirc'    , 202,
 'Euml'     , 203,
 'Igrave'   , 204,
 'Iacute'   , 205,
 'Icirc'    , 206,
 'Iuml'     , 207,
 'ETH'      , 208,
 'Ntilde'   , 209,
 'Ograve'   , 210,
 'Oacute'   , 211,
 'Ocirc'    , 212,
 'Otilde'   , 213,
 'Ouml'     , 214,
 'times'    , 215,
 'Oslash'   , 216,
 'Ugrave'   , 217,
 'Uacute'   , 218,
 'Ucirc'    , 219,
 'Uuml'     , 220,
 'Yacute'   , 221,
 'THORN'    , 222,
 'szlig'    , 223,
 'agrave'   , 224,
 'aacute'   , 225,
 'acirc'    , 226,
 'atilde'   , 227,
 'auml'     , 228,
 'aring'    , 229,
 'aelig'    , 230,
 'ccedil'   , 231,
 'egrave'   , 232,
 'eacute'   , 233,
 'ecirc'    , 234,
 'euml'     , 235,
 'igrave'   , 236,
 'iacute'   , 237,
 'icirc'    , 238,
 'iuml'     , 239,
 'eth'      , 240,
 'ntilde'   , 241,
 'ograve'   , 242,
 'oacute'   , 243,
 'ocirc'    , 244,
 'otilde'   , 245,
 'ouml'     , 246,
 'divide'   , 247,
 'oslash'   , 248,
 'ugrave'   , 249,
 'uacute'   , 250,
 'ucirc'    , 251,
 'uuml'     , 252,
 'yacute'   , 253,
 'thorn'    , 254,
 'yuml'     , 255,

 'fnof'     , 402,
 'Alpha'    , 913,
 'Beta'     , 914,
 'Gamma'    , 915,
 'Delta'    , 916,
 'Epsilon'  , 917,
 'Zeta'     , 918,
 'Eta'      , 919,
 'Theta'    , 920,
 'Iota'     , 921,
 'Kappa'    , 922,
 'Lambda'   , 923,
 'Mu'       , 924,
 'Nu'       , 925,
 'Xi'       , 926,
 'Omicron'  , 927,
 'Pi'       , 928,
 'Rho'      , 929,
 'Sigma'    , 931,
 'Tau'      , 932,
 'Upsilon'  , 933,
 'Phi'      , 934,
 'Chi'      , 935,
 'Psi'      , 936,
 'Omega'    , 937,
 'alpha'    , 945,
 'beta'     , 946,
 'gamma'    , 947,
 'delta'    , 948,
 'epsilon'  , 949,
 'zeta'     , 950,
 'eta'      , 951,
 'theta'    , 952,
 'iota'     , 953,
 'kappa'    , 954,
 'lambda'   , 955,
 'mu'       , 956,
 'nu'       , 957,
 'xi'       , 958,
 'omicron'  , 959,
 'pi'       , 960,
 'rho'      , 961,
 'sigmaf'   , 962,
 'sigma'    , 963,
 'tau'      , 964,
 'upsilon'  , 965,
 'phi'      , 966,
 'chi'      , 967,
 'psi'      , 968,
 'omega'    , 969,
 'thetasym' , 977,
 'upsih'    , 978,
 'piv'      , 982,
 'bull'     , 8226,
 'hellip'   , 8230,
 'prime'    , 8242,
 'Prime'    , 8243,
 'oline'    , 8254,
 'frasl'    , 8260,
 'weierp'   , 8472,
 'image'    , 8465,
 'real'     , 8476,
 'trade'    , 8482,
 'alefsym'  , 8501,
 'larr'     , 8592,
 'uarr'     , 8593,
 'rarr'     , 8594,
 'darr'     , 8595,
 'harr'     , 8596,
 'crarr'    , 8629,
 'lArr'     , 8656,
 'uArr'     , 8657,
 'rArr'     , 8658,
 'dArr'     , 8659,
 'hArr'     , 8660,
 'forall'   , 8704,
 'part'     , 8706,
 'exist'    , 8707,
 'empty'    , 8709,
 'nabla'    , 8711,
 'isin'     , 8712,
 'notin'    , 8713,
 'ni'       , 8715,
 'prod'     , 8719,
 'sum'      , 8721,
 'minus'    , 8722,
 'lowast'   , 8727,
 'radic'    , 8730,
 'prop'     , 8733,
 'infin'    , 8734,
 'ang'      , 8736,
 'and'      , 8743,
 'or'       , 8744,
 'cap'      , 8745,
 'cup'      , 8746,
 'int'      , 8747,
 'there4'   , 8756,
 'sim'      , 8764,
 'cong'     , 8773,
 'asymp'    , 8776,
 'ne'       , 8800,
 'equiv'    , 8801,
 'le'       , 8804,
 'ge'       , 8805,
 'sub'      , 8834,
 'sup'      , 8835,
 'nsub'     , 8836,
 'sube'     , 8838,
 'supe'     , 8839,
 'oplus'    , 8853,
 'otimes'   , 8855,
 'perp'     , 8869,
 'sdot'     , 8901,
 'lceil'    , 8968,
 'rceil'    , 8969,
 'lfloor'   , 8970,
 'rfloor'   , 8971,
 'lang'     , 9001,
 'rang'     , 9002,
 'loz'      , 9674,
 'spades'   , 9824,
 'clubs'    , 9827,
 'hearts'   , 9829,
 'diams'    , 9830,
 'OElig'    , 338,
 'oelig'    , 339,
 'Scaron'   , 352,
 'scaron'   , 353,
 'Yuml'     , 376,
 'circ'     , 710,
 'tilde'    , 732,
 'ensp'     , 8194,
 'emsp'     , 8195,
 'thinsp'   , 8201,
 'zwnj'     , 8204,
 'zwj'      , 8205,
 'lrm'      , 8206,
 'rlm'      , 8207,
 'ndash'    , 8211,
 'mdash'    , 8212,
 'lsquo'    , 8216,
 'rsquo'    , 8217,
 'sbquo'    , 8218,
 'ldquo'    , 8220,
 'rdquo'    , 8221,
 'bdquo'    , 8222,
 'dagger'   , 8224,
 'Dagger'   , 8225,
 'permil'   , 8240,
 'lsaquo'   , 8249,
 'rsaquo'   , 8250,
 'euro'     , 8364,
);


# Fill out %Name2character...
{
  %Name2character = ();
  my($name, $number);
  while( ($name, $number) = each %Name2character_number) {
    if($] < 5.007  and  $number > 255) {
      $Name2character{$name} = $FAR_CHAR;
      # substitute for Unicode characters, for perls
      #  that can't reliable handle them
    } else {
      $Name2character{$name} = chr $number;
      # normal case
    }
  }
  # So they resolve 'right' even in EBCDIC-land
  $Name2character{'lt'  }   = '<';
  $Name2character{'gt'  }   = '>';
  $Name2character{'quot'}   = '"';
  $Name2character{'amp' }   = '&';
  $Name2character{'apos'}   = "'";
  $Name2character{'sol' }   = '/';
  $Name2character{'verbar'} = '|';
}

#--------------------------------------------------------------------------

%Code2USASCII = (
# mostly generated by
#  perl -e "printf qq{  \x25 3s, '\x25s',\n}, $_, chr($_) foreach (32 .. 126)"
   32, ' ',
   33, '!',
   34, '"',
   35, '#',
   36, '$',
   37, '%',
   38, '&',
   39, "'", #!
   40, '(',
   41, ')',
   42, '*',
   43, '+',
   44, ',',
   45, '-',
   46, '.',
   47, '/',
   48, '0',
   49, '1',
   50, '2',
   51, '3',
   52, '4',
   53, '5',
   54, '6',
   55, '7',
   56, '8',
   57, '9',
   58, ':',
   59, ';',
   60, '<',
   61, '=',
   62, '>',
   63, '?',
   64, '@',
   65, 'A',
   66, 'B',
   67, 'C',
   68, 'D',
   69, 'E',
   70, 'F',
   71, 'G',
   72, 'H',
   73, 'I',
   74, 'J',
   75, 'K',
   76, 'L',
   77, 'M',
   78, 'N',
   79, 'O',
   80, 'P',
   81, 'Q',
   82, 'R',
   83, 'S',
   84, 'T',
   85, 'U',
   86, 'V',
   87, 'W',
   88, 'X',
   89, 'Y',
   90, 'Z',
   91, '[',
   92, "\\", #!
   93, ']',
   94, '^',
   95, '_',
   96, '`',
   97, 'a',
   98, 'b',
   99, 'c',
  100, 'd',
  101, 'e',
  102, 'f',
  103, 'g',
  104, 'h',
  105, 'i',
  106, 'j',
  107, 'k',
  108, 'l',
  109, 'm',
  110, 'n',
  111, 'o',
  112, 'p',
  113, 'q',
  114, 'r',
  115, 's',
  116, 't',
  117, 'u',
  118, 'v',
  119, 'w',
  120, 'x',
  121, 'y',
  122, 'z',
  123, '{',
  124, '|',
  125, '}',
  126, '~',
);

#--------------------------------------------------------------------------

%Latin1Code_to_fallback = ();
@Latin1Code_to_fallback{0xA0 .. 0xFF} = (
# Copied from Text/Unidecode/x00.pm:

' ', qq{!}, qq{C/}, 'PS', qq{\$?}, qq{Y=}, qq{|}, 'SS', qq{"}, qq{(c)}, 'a', qq{<<}, qq{!}, "", qq{(r)}, qq{-},
'deg', qq{+-}, '2', '3', qq{'}, 'u', 'P', qq{*}, qq{,}, '1', 'o', qq{>>}, qq{1/4}, qq{1/2}, qq{3/4}, qq{?},
'A', 'A', 'A', 'A', 'A', 'A', 'AE', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I',
'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', 'O', 'U', 'U', 'U', 'U', 'U', 'Th', 'ss',
'a', 'a', 'a', 'a', 'a', 'a', 'ae', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i',
'd', 'n', 'o', 'o', 'o', 'o', 'o', qq{/}, 'o', 'u', 'u', 'u', 'u', 'y', 'th', 'y',

);

{
  # Now stuff %Latin1Char_to_fallback:
  %Latin1Char_to_fallback = ();
  my($k,$v);
  while( ($k,$v) = each %Latin1Code_to_fallback) {
    $Latin1Char_to_fallback{chr $k} = $v;
    #print chr($k), ' => ', $v, "\n";
  }
}

#--------------------------------------------------------------------------
1;
__END__

=head1 NAME

Pod::Escapes - for resolving Pod EE<lt>...E<gt> sequences

=head1 SYNOPSIS

  use Pod::Escapes qw(e2char);
  ...la la la, parsing POD, la la la...
  $text = e2char($e_node->label);
  unless(defined $text) {
    print "Unknown E sequence \"", $e_node->label, "\"!";
  }
  ...else print/interpolate $text...

=head1 DESCRIPTION

This module provides things that are useful in decoding
Pod EE<lt>...E<gt> sequences.  Presumably, it should be used
only by Pod parsers and/or formatters.

By default, Pod::Escapes exports none of its symbols.  But
you can request any of them to be exported.
Either request them individually, as with
C<use Pod::Escapes qw(symbolname symbolname2...);>,
or you can do C<use Pod::Escapes qw(:ALL);> to get all
exportable symbols.

=head1 GOODIES

=over

=item e2char($e_content)

Given a name or number that could appear in a
C<EE<lt>name_or_numE<gt>> sequence, this returns the string that
it stands for.  For example, C<e2char('sol')>, C<e2char('47')>,
C<e2char('0x2F')>, and C<e2char('057')> all return "/",
because C<EE<lt>solE<gt>>, C<EE<lt>47E<gt>>, C<EE<lt>0x2fE<gt>>,
and C<EE<lt>057E<gt>>, all mean "/".  If
the name has no known value (as with a name of "qacute") or is
syntactically invalid (as with a name of "1/4"), this returns undef.

=item e2charnum($e_content)

Given a name or number that could appear in a
C<EE<lt>name_or_numE<gt>> sequence, this returns the number of
the Unicode character that this stands for.  For example,
C<e2char('sol')>, C<e2char('47')>,
C<e2char('0x2F')>, and C<e2char('057')> all return 47,
because C<EE<lt>solE<gt>>, C<EE<lt>47E<gt>>, C<EE<lt>0x2fE<gt>>,
and C<EE<lt>057E<gt>>, all mean "/", whose Unicode number is 47.  If
the name has no known value (as with a name of "qacute") or is
syntactically invalid (as with a name of "1/4"), this returns undef.

=item $Name2character{I<name>}

Maps from names (as in C<EE<lt>I<name>E<gt>>) like "eacute" or "sol"
to the string that each stands for.  Note that this does not
include numerics (like "64" or "x981c").  Under old Perl versions
(before 5.7) you get a "?" in place of characters whose Unicode
value is over 255.

=item $Name2character_number{I<name>}

Maps from names (as in C<EE<lt>I<name>E<gt>>) like "eacute" or "sol"
to the Unicode value that each stands for.  For example,
C<$Name2character_number{'eacute'}> is 201, and
C<$Name2character_number{'eacute'}> is 8364.  You get the correct
Unicode value, regardless of the version of Perl you're using --
which differs from C<%Name2character>'s behavior under pre-5.7 Perls.

Note that this hash does not
include numerics (like "64" or "x981c").

=item $Latin1Code_to_fallback{I<integer>}

For numbers in the range 160 (0x00A0) to 255 (0x00FF), this maps
from the character code for a Latin-1 character (like 233 for
lowercase e-acute) to the US-ASCII character that best aproximates
it (like "e").  You may find this useful if you are rendering
POD in a format that you think deals well only with US-ASCII
characters.

=item $Latin1Char_to_fallback{I<character>}

Just as above, but maps from characters (like "\xE9", 
lowercase e-acute) to characters (like "e").

=item $Code2USASCII{I<integer>}

This maps from US-ASCII codes (like 32) to the corresponding
character (like space, for 32).  Only characters 32 to 126 are
defined.  This is meant for use by C<e2char($x)> when it senses
that it's running on a non-ASCII platform (where chr(32) doesn't
get you a space -- but $Code2USASCII{32} will).  It's
documented here just in case you might find it useful.

=back

=head1 CAVEATS

On Perl versions before 5.7, Unicode characters with a value
over 255 (like lambda or emdash) can't be conveyed.  This
module does work under such early Perl versions, but in the
place of each such character, you get a "?".  Latin-1
characters (characters 160-255) are unaffected.

Under EBCDIC platforms, C<e2char($n)> may not always be the
same as C<chr(e2charnum($n))>, and ditto for
C<$Name2character{$name}> and
C<chr($Name2character_number{$name})>.

=head1 SEE ALSO

L<Pod::Browser> - a pod web server based on L<Catalyst>.

L<Pod::Checker> - check pod documents for syntax errors.

L<Pod::Coverage> - check if the documentation for a module is comprehensive.

L<perlpod> - description of pod format (for people documenting with pod).

L<perlpodspec> - specification of pod format (for people processing it).

L<Text::Unidecode> - ASCII transliteration of Unicode text.

=head1 REPOSITORY

L<https://github.com/neilbowers/Pod-Escapes>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2001-2004 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

Portions of the data tables in this module are derived from the
entity declarations in the W3C XHTML specification.

Currently (October 2001), that's these three:

 http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
 http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
 http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent

=head1 AUTHOR

Sean M. Burke C<sburke@cpan.org>

Now being maintained by Neil Bowers E<lt>neilb@cpan.orgE<gt>

=cut

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# What I used for reading the XHTML .ent files:

my(@norms, @good, @bad);
my $dir = 'c:/sgml/docbook/';
my %escapes;
foreach my $file (qw(
  xhtml-symbol.ent
  xhtml-lat1.ent
  xhtml-special.ent
)) {
  open(IN, "<$dir$file") or die "can't read-open $dir$file: $!";
  print "Reading $file...\n";
  while(<IN>) {
    if(m/<!ENTITY\s+(\S+)\s+"&#([^;]+);">/) {
      my($name, $value) = ($1,$2);
      next if $name eq 'quot' or $name eq 'apos' or $name eq 'gt';
    
      $value = hex $1 if $value =~ m/^x([a-fA-F0-9]+)$/s;
      print "ILLEGAL VALUE $value" unless $value =~ m/^\d+$/s;
      if($value > 255) {
        push @good , sprintf "   %-10s , chr(%s),\n", "'$name'", $value;
        push @bad  , sprintf "   %-10s , \$bad,\n", "'$name'", $value;
      } else {
        push @norms, sprintf " %-10s , chr(%s),\n", "'$name'", $value;
      }
    } elsif(m/<!ENT/) {
      print "# Skipping $_";
    }
  
  }
  close(IN);
}

print @norms;
print "\n ( \$] .= 5.006001 ? (\n";
print @good;
print " ) : (\n";
print @bad;
print " )\n);\n";

__END__
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Pod/Find.pm                                                                   0100644 0000000 0000000 00000036652 12744441327 014632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #############################################################################  
# Pod/Find.pm -- finds files containing POD documentation
#
# Author: Marek Rouchal <marekr@cpan.org>
# 
# Copyright (C) 1999-2000 by Marek Rouchal (and borrowing code
# from Nick Ing-Simmon's PodToHtml). All rights reserved.
# This file is part of "PodParser". Pod::Find is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Find;
use strict;

use vars qw($VERSION);
$VERSION = '1.62';   ## Current version of this package
require  5.005;   ## requires this Perl version or later
use Carp;

BEGIN {
   if ($] < 5.006) {
      require Symbol;
      import Symbol;
   }
}

#############################################################################

=head1 NAME

Pod::Find - find POD documents in directory trees

=head1 SYNOPSIS

  use Pod::Find qw(pod_find simplify_name);
  my %pods = pod_find({ -verbose => 1, -inc => 1 });
  foreach(keys %pods) {
     print "found library POD `$pods{$_}' in $_\n";
  }

  print "podname=",simplify_name('a/b/c/mymodule.pod'),"\n";

  $location = pod_where( { -inc => 1 }, "Pod::Find" );

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

B<Pod::Find> provides a set of functions to locate POD files.  Note that
no function is exported by default to avoid pollution of your namespace,
so be sure to specify them in the B<use> statement if you need them:

  use Pod::Find qw(pod_find);

From this version on the typical SCM (software configuration management)
files/directories like RCS, CVS, SCCS, .svn are ignored.

=cut

#use diagnostics;
use Exporter;
use File::Spec;
use File::Find;
use Cwd qw(abs_path cwd);

use vars qw(@ISA @EXPORT_OK $VERSION);
@ISA = qw(Exporter);
@EXPORT_OK = qw(&pod_find &simplify_name &pod_where &contains_pod);

# package global variables
my $SIMPLIFY_RX;

=head2 C<pod_find( { %opts } , @directories )>

The function B<pod_find> searches for POD documents in a given set of
files and/or directories. It returns a hash with the file names as keys
and the POD name as value. The POD name is derived from the file name
and its position in the directory tree.

E.g. when searching in F<$HOME/perl5lib>, the file
F<$HOME/perl5lib/MyModule.pm> would get the POD name I<MyModule>,
whereas F<$HOME/perl5lib/Myclass/Subclass.pm> would be
I<Myclass::Subclass>. The name information can be used for POD
translators.

Only text files containing at least one valid POD command are found.

A warning is printed if more than one POD file with the same POD name
is found, e.g. F<CPAN.pm> in different directories. This usually
indicates duplicate occurrences of modules in the I<@INC> search path.

B<OPTIONS> The first argument for B<pod_find> may be a hash reference
with options. The rest are either directories that are searched
recursively or files.  The POD names of files are the plain basenames
with any Perl-like extension (.pm, .pl, .pod) stripped.

=over 4

=item C<-verbose =E<gt> 1>

Print progress information while scanning.

=item C<-perl =E<gt> 1>

Apply Perl-specific heuristics to find the correct PODs. This includes
stripping Perl-like extensions, omitting subdirectories that are numeric
but do I<not> match the current Perl interpreter's version id, suppressing
F<site_perl> as a module hierarchy name etc.

=item C<-script =E<gt> 1>

Search for PODs in the current Perl interpreter's installation 
B<scriptdir>. This is taken from the local L<Config|Config> module.

=item C<-inc =E<gt> 1>

Search for PODs in the current Perl interpreter's I<@INC> paths. This
automatically considers paths specified in the C<PERL5LIB> environment
as this is included in I<@INC> by the Perl interpreter itself.

=back

=cut

# return a hash of the POD files found
# first argument may be a hashref (options),
# rest is a list of directories to search recursively
sub pod_find
{
    my %opts;
    if(ref $_[0]) {
        %opts = %{shift()};
    }

    $opts{-verbose} ||= 0;
    $opts{-perl}    ||= 0;

    my (@search) = @_;

    if($opts{-script}) {
        require Config;
        push(@search, $Config::Config{scriptdir})
            if -d $Config::Config{scriptdir};
        $opts{-perl} = 1;
    }

    if($opts{-inc}) {
        if ($^O eq 'MacOS') {
            # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
            my @new_INC = @INC;
            for (@new_INC) {
                if ( $_ eq '.' ) {
                    $_ = ':';
                } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                    $_ = ':'. $_;
                } else {
                    $_ =~ s{^\./}{:};
                }
            }
            push(@search, grep($_ ne File::Spec->curdir, @new_INC));
        } else {
            my %seen;
            my $curdir = File::Spec->curdir;
	    foreach(@INC) {
                next if $_ eq $curdir;
		my $path = abs_path($_);
                push(@search, $path) unless $seen{$path}++;
            }
        }

        $opts{-perl} = 1;
    }

    if($opts{-perl}) {
        require Config;
        # this code simplifies the POD name for Perl modules:
        # * remove "site_perl"
        # * remove e.g. "i586-linux" (from 'archname')
        # * remove e.g. 5.00503
        # * remove pod/ if followed by *.pod (e.g. in pod/perlfunc.pod)

        # Mac OS:
        # * remove ":?site_perl:"
        # * remove :?pod: if followed by *.pod (e.g. in :pod:perlfunc.pod)

        if ($^O eq 'MacOS') {
            $SIMPLIFY_RX =
              qq!^(?i:\:?site_perl\:|\:?pod\:(?=.*?\\.pod\\z))*!;
        } else {
            $SIMPLIFY_RX =
              qq!^(?i:site(_perl)?/|\Q$Config::Config{archname}\E/|\\d+\\.\\d+([_.]?\\d+)?/|pod/(?=.*?\\.pod\\z))*!;
        }
    }

    my %dirs_visited;
    my %pods;
    my %names;
    my $pwd = cwd();

    foreach my $try (@search) {
        unless(File::Spec->file_name_is_absolute($try)) {
            # make path absolute
            $try = File::Spec->catfile($pwd,$try);
        }
        # simplify path
        # on VMS canonpath will vmsify:[the.path], but File::Find::find
        # wants /unixy/paths
        if ($^O eq 'VMS') {
            $try = VMS::Filespec::unixify($try);
        }
        else {
            $try = File::Spec->canonpath($try);
        }
        my $name;
        if(-f $try) {
            if($name = _check_and_extract_name($try, $opts{-verbose})) {
                _check_for_duplicates($try, $name, \%names, \%pods);
            }
            next;
        }
        my $root_rx = $^O eq 'MacOS' ? qq!^\Q$try\E! : qq!^\Q$try\E/!;
        $root_rx=~ s|//$|/|;  # remove trailing double slash
        File::Find::find( sub {
            my $item = $File::Find::name;
            if(-d) {
                if($item =~ m{/(?:RCS|CVS|SCCS|\.svn)$}) {
                    $File::Find::prune = 1;
                    return;
                }
                elsif($dirs_visited{$item}) {
                    warn "Directory '$item' already seen, skipping.\n"
                        if($opts{-verbose});
                    $File::Find::prune = 1;
                    return;
                }
                else {
                    $dirs_visited{$item} = 1;
                }
                if($opts{-perl} && /^(\d+\.[\d_]+)\z/s && eval "$1" != $]) {
                    $File::Find::prune = 1;
                    warn "Perl $] version mismatch on $_, skipping.\n"
                        if($opts{-verbose});
                }
                return;
            }
            if($name = _check_and_extract_name($item, $opts{-verbose}, $root_rx)) {
                _check_for_duplicates($item, $name, \%names, \%pods);
            }
        }, $try); # end of File::Find::find
    }
    chdir $pwd;
    return %pods;
}

sub _check_for_duplicates {
    my ($file, $name, $names_ref, $pods_ref) = @_;
    if($$names_ref{$name}) {
        warn "Duplicate POD found (shadowing?): $name ($file)\n";
        warn '    Already seen in ',
            join(' ', grep($$pods_ref{$_} eq $name, keys %$pods_ref)),"\n";
    }
    else {
        $$names_ref{$name} = 1;
    }
    return $$pods_ref{$file} = $name;
}

sub _check_and_extract_name {
    my ($file, $verbose, $root_rx) = @_;

    # check extension or executable flag
    # this involves testing the .bat extension on Win32!
    unless(-f $file && -T $file && ($file =~ /\.(pod|pm|plx?)\z/i || -x $file )) {
      return;
    }

    return unless contains_pod($file,$verbose);

    # strip non-significant path components
    # TODO what happens on e.g. Win32?
    my $name = $file;
    if(defined $root_rx) {
        $name =~ s/$root_rx//is;
        $name =~ s/$SIMPLIFY_RX//is if(defined $SIMPLIFY_RX);
    }
    else {
        if ($^O eq 'MacOS') {
            $name =~ s/^.*://s;
        } else {
            $name =~ s{^.*/}{}s;
        }
    }
    _simplify($name);
    $name =~ s{/+}{::}g;
    if ($^O eq 'MacOS') {
        $name =~ s{:+}{::}g; # : -> ::
    } else {
        $name =~ s{/+}{::}g; # / -> ::
    }
    return $name;
}

=head2 C<simplify_name( $str )>

The function B<simplify_name> is equivalent to B<basename>, but also
strips Perl-like extensions (.pm, .pl, .pod) and extensions like
F<.bat>, F<.cmd> on Win32 and OS/2, or F<.com> on VMS, respectively.

=cut

# basic simplification of the POD name:
# basename & strip extension
sub simplify_name {
    my ($str) = @_;
    # remove all path components
    if ($^O eq 'MacOS') {
        $str =~ s/^.*://s;
    } else {
        $str =~ s{^.*/}{}s;
    }
    _simplify($str);
    return $str;
}

# internal sub only
sub _simplify {
    # strip Perl's own extensions
    $_[0] =~ s/\.(pod|pm|plx?)\z//i;
    # strip meaningless extensions on Win32 and OS/2
    $_[0] =~ s/\.(bat|exe|cmd)\z//i if($^O =~ /mswin|os2/i);
    # strip meaningless extensions on VMS
    $_[0] =~ s/\.(com)\z//i if($^O eq 'VMS');
}

# contribution from Tim Jenness <t.jenness@jach.hawaii.edu>

=head2 C<pod_where( { %opts }, $pod )>

Returns the location of a pod document given a search directory
and a module (e.g. C<File::Find>) or script (e.g. C<perldoc>) name.

Options:

=over 4

=item C<-inc =E<gt> 1>

Search @INC for the pod and also the C<scriptdir> defined in the
L<Config|Config> module.

=item C<-dirs =E<gt> [ $dir1, $dir2, ... ]>

Reference to an array of search directories. These are searched in order
before looking in C<@INC> (if B<-inc>). Current directory is used if
none are specified.

=item C<-verbose =E<gt> 1>

List directories as they are searched

=back

Returns the full path of the first occurrence to the file.
Package names (eg 'A::B') are automatically converted to directory
names in the selected directory. (eg on unix 'A::B' is converted to
'A/B'). Additionally, '.pm', '.pl' and '.pod' are appended to the
search automatically if required.

A subdirectory F<pod/> is also checked if it exists in any of the given
search directories. This ensures that e.g. L<perlfunc|perlfunc> is
found.

It is assumed that if a module name is supplied, that that name
matches the file name. Pods are not opened to check for the 'NAME'
entry.

A check is made to make sure that the file that is found does 
contain some pod documentation.

=cut

sub pod_where {

  # default options
  my %options = (
         '-inc' => 0,
         '-verbose' => 0,
         '-dirs' => [ File::Spec->curdir ],
        );

  # Check for an options hash as first argument
  if (defined $_[0] && ref($_[0]) eq 'HASH') {
    my $opt = shift;

    # Merge default options with supplied options
    %options = (%options, %$opt);
  }

  # Check usage
  carp 'Usage: pod_where({options}, $pod)' unless (scalar(@_));

  # Read argument
  my $pod = shift;

  # Split on :: and then join the name together using File::Spec
  my @parts = split (/::/, $pod);

  # Get full directory list
  my @search_dirs = @{ $options{'-dirs'} };

  if ($options{'-inc'}) {

    require Config;

    # Add @INC
    if ($^O eq 'MacOS' && $options{'-inc'}) {
        # tolerate '.', './some_dir' and '(../)+some_dir' on Mac OS
        my @new_INC = @INC;
        for (@new_INC) {
            if ( $_ eq '.' ) {
                $_ = ':';
            } elsif ( $_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e ) {
                $_ = ':'. $_;
            } else {
                $_ =~ s{^\./}{:};
            }
        }
        push (@search_dirs, @new_INC);
    } elsif ($options{'-inc'}) {
        push (@search_dirs, @INC);
    }

    # Add location of pod documentation for perl man pages (eg perlfunc)
    # This is a pod directory in the private install tree
    #my $perlpoddir = File::Spec->catdir($Config::Config{'installprivlib'},
    #					'pod');
    #push (@search_dirs, $perlpoddir)
    #  if -d $perlpoddir;

    # Add location of binaries such as pod2text
    push (@search_dirs, $Config::Config{'scriptdir'})
      if -d $Config::Config{'scriptdir'};
  }

  warn 'Search path is: '.join(' ', @search_dirs)."\n"
        if $options{'-verbose'};

  # Loop over directories
  Dir: foreach my $dir ( @search_dirs ) {

    # Don't bother if can't find the directory
    if (-d $dir) {
      warn "Looking in directory $dir\n"
        if $options{'-verbose'};

      # Now concatenate this directory with the pod we are searching for
      my $fullname = File::Spec->catfile($dir, @parts);
      $fullname = VMS::Filespec::unixify($fullname) if $^O eq 'VMS';
      warn "Filename is now $fullname\n"
        if $options{'-verbose'};

      # Loop over possible extensions
      foreach my $ext ('', '.pod', '.pm', '.pl') {
        my $fullext = $fullname . $ext;
        if (-f $fullext &&
         contains_pod($fullext, $options{'-verbose'}) ) {
          warn "FOUND: $fullext\n" if $options{'-verbose'};
          return $fullext;
        }
      }
    } else {
      warn "Directory $dir does not exist\n"
        if $options{'-verbose'};
      next Dir;
    }
    # for some strange reason the path on MacOS/darwin/cygwin is
    # 'pods' not 'pod'
    # this could be the case also for other systems that
    # have a case-tolerant file system, but File::Spec
    # does not recognize 'darwin' yet. And cygwin also has "pods",
    # but is not case tolerant. Oh well...
    if((File::Spec->case_tolerant || $^O =~ /macos|darwin|cygwin/i)
     && -d File::Spec->catdir($dir,'pods')) {
      $dir = File::Spec->catdir($dir,'pods');
      redo Dir;
    }
    if(-d File::Spec->catdir($dir,'pod')) {
      $dir = File::Spec->catdir($dir,'pod');
      redo Dir;
    }
  }
  # No match;
  return;
}

=head2 C<contains_pod( $file , $verbose )>

Returns true if the supplied filename (not POD module) contains some pod
information.

=cut

sub contains_pod {
  my $file = shift;
  my $verbose = 0;
  $verbose = shift if @_;

  # check for one line of POD
  my $podfh;
  if ($] < 5.006) {
    $podfh = gensym();
  }

  unless(open($podfh,"<$file")) {
    warn "Error: $file is unreadable: $!\n";
    return;
  }
  
  local $/ = undef;
  my $pod = <$podfh>;
  close($podfh) || die "Error closing $file: $!\n";
  unless($pod =~ /^=(head\d|pod|over|item|cut)\b/m) {
    warn "No POD in $file, skipping.\n"
      if($verbose);
    return 0;
  }

  return 1;
}

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Marek Rouchal E<lt>marekr@cpan.orgE<gt>,
heavily borrowing code from Nick Ing-Simmons' PodToHtml.

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt> provided
C<pod_where> and C<contains_pod>.

B<Pod::Find> is part of the L<Pod::Parser> distribution.

=head1 SEE ALSO

L<Pod::Parser>, L<Pod::Checker>, L<perldoc>

=cut

1;

                                                                                      usr/share/perl/5.20.2/Pod/Functions.pm                                                              0100644 0000000 0000000 00000034014 12744441327 015710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Functions;
use strict;

=head1 NAME

Pod::Functions - Group Perl's functions a la perlfunc.pod

=head1 SYNOPSIS

    use Pod::Functions;
    
    my @misc_ops = @{ $Kinds{ 'Misc' } };
    my $misc_dsc = $Type_Description{ 'Misc' };

or

    perl /path/to/lib/Pod/Functions.pm

This will print a grouped list of Perl's functions, like the 
L<perlfunc/"Perl Functions by Category"> section.

=head1 DESCRIPTION

It exports the following variables:

=over 4

=item %Kinds

This holds a hash-of-lists. Each list contains the functions in the category
the key denotes.

=item %Type

In this hash each key represents a function and the value is the category.
The category can be a comma separated list.

=item %Flavor

In this hash each key represents a function and the value is a short 
description of that function.

=item %Type_Description

In this hash each key represents a category of functions and the value is 
a short description of that category.

=item @Type_Order

This list of categories is used to produce the same order as the
L<perlfunc/"Perl Functions by Category"> section.

=back

=cut

our $VERSION = '1.08';

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw(%Kinds %Type %Flavor %Type_Description @Type_Order);

our(%Kinds, %Type, %Flavor, %Type_Description, @Type_Order);

foreach (
    [String     => 'Functions for SCALARs or strings'],
    [Regexp     => 'Regular expressions and pattern matching'],
    [Math       => 'Numeric functions'],
    [ARRAY      => 'Functions for real @ARRAYs'],
    [LIST       => 'Functions for list data'],
    [HASH       => 'Functions for real %HASHes'],
    ['I/O'      => 'Input and output functions'],
    [Binary     => 'Functions for fixed-length data or records'],
    [File       => 'Functions for filehandles, files, or directories'],
    [Flow       => 'Keywords related to the control flow of your Perl program'],
    [Namespace  => 'Keywords related to scoping'],
    [Misc       => 'Miscellaneous functions'],
    [Process    => 'Functions for processes and process groups'],
    [Modules    => 'Keywords related to Perl modules'],
    [Objects    => 'Keywords related to classes and object-orientation'],
    [Socket     => 'Low-level socket functions'],
    [SysV       => 'System V interprocess communication functions'],
    [User       => 'Fetching user and group info'],
    [Network    => 'Fetching network info'],
    [Time       => 'Time-related functions'],
	) {
    push @Type_Order, $_->[0];
    $Type_Description{$_->[0]} = $_->[1];
};

while (<DATA>) {
    chomp;
    s/^#.*//;
    next unless $_;
    my($name, @data) = split "\t", $_;
    $Flavor{$name} = pop @data;
    $Type{$name} = join ',', @data;
    for my $t (@data) {
        push @{$Kinds{$t}}, $name;
    }
}

close DATA;

my( $typedesc, $list );
unless (caller) { 
    foreach my $type ( @Type_Order ) {
	$list = join(", ", sort @{$Kinds{$type}});
	$typedesc = $Type_Description{$type} . ":";
	write;
    } 
}

format = 

^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    $typedesc 
~~ ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    $typedesc 
 ~~  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	$list
.

1;

__DATA__
-X	File	a file test (-r, -x, etc)
abs	Math	absolute value function
accept	Socket	accept an incoming socket connect
alarm	Process	schedule a SIGALRM
atan2	Math	arctangent of Y/X in the range -PI to PI
bind	Socket	binds an address to a socket
binmode	I/O	prepare binary files for I/O
bless	Objects	create an object
break	Flow	break out of a C<given> block
caller	Flow	Namespace	get context of the current subroutine call
chdir	File	change your current working directory
chmod	File	changes the permissions on a list of files
chomp	String	remove a trailing record separator from a string
chop	String	remove the last character from a string
chown	File	change the ownership on a list of files
chr	String	get character this number represents
chroot	File	make directory new root for path lookups
close	I/O	close file (or pipe or socket) handle
closedir	I/O	close directory handle
connect	Socket	connect to a remote socket
continue	Flow	optional trailing block in a while or foreach
cos	Math	cosine function
crypt	String	one-way passwd-style encryption
dbmclose	I/O	Objects	breaks binding on a tied dbm file
dbmopen	I/O	Objects	create binding on a tied dbm file
defined	Misc	test whether a value, variable, or function is defined
delete	HASH	deletes a value from a hash
die	Flow	I/O	raise an exception or bail out
do	Flow	Modules	turn a BLOCK into a TERM
dump	Flow	create an immediate core dump
each	ARRAY	HASH	retrieve the next key/value pair from a hash
endgrent	User	be done using group file
endhostent	User	be done using hosts file
endnetent	User	be done using networks file
endprotoent	Network	be done using protocols file
endpwent	User	be done using passwd file
endservent	Network	be done using services file
eof	I/O	test a filehandle for its end
eval	Flow	catch exceptions or compile and run code
evalbytes	Flow	similar to string eval, but intend to parse a bytestream
exec	Process	abandon this program to run another
exists	HASH	test whether a hash key is present
exit	Flow	terminate this program
exp	Math	raise I<e> to a power
fc	String	return casefolded version of a string
fcntl	File	file control system call
__FILE__	Flow	the name of the current source file
fileno	I/O	return file descriptor from filehandle
flock	I/O	lock an entire file with an advisory lock
fork	Process	create a new process just like this one
format	I/O	declare a picture format with use by the write() function
formline	Misc	internal function used for formats
getc	I/O	get the next character from the filehandle
getgrent	User	get next group record
getgrgid	User	get group record given group user ID
getgrnam	User	get group record given group name
gethostbyaddr	Network	get host record given its address
gethostbyname	Network	get host record given name
gethostent	Network	get next hosts record
getlogin	User	return who logged in at this tty
getnetbyaddr	Network	get network record given its address
getnetbyname	Network	get networks record given name
getnetent	Network	get next networks record
getpeername	Socket	find the other end of a socket connection
getpgrp	Process	get process group
getppid	Process	get parent process ID
getpriority	Process	get current nice value
getprotobyname	Network	get protocol record given name
getprotobynumber	Network	get protocol record numeric protocol
getprotoent	Network	get next protocols record
getpwent	User	get next passwd record
getpwnam	User	get passwd record given user login name
getpwuid	User	get passwd record given user ID
getservbyname	Network	get services record given its name
getservbyport	Network	get services record given numeric port
getservent	Network	get next services record
getsockname	Socket	retrieve the sockaddr for a given socket
getsockopt	Socket	get socket options on a given socket
glob	File	expand filenames using wildcards
gmtime	Time	convert UNIX time into record or string using Greenwich time
goto	Flow	create spaghetti code
grep	LIST	locate elements in a list test true against a given criterion
hex	Math	String	convert a string to a hexadecimal number
import	Modules	Namespace	patch a module's namespace into your own
index	String	find a substring within a string
int	Math	get the integer portion of a number
ioctl	File	system-dependent device control system call
join	LIST	join a list into a string using a separator
keys	ARRAY	HASH	retrieve list of indices from a hash
kill	Process	send a signal to a process or process group
last	Flow	exit a block prematurely
lc	String	return lower-case version of a string
lcfirst	String	return a string with just the next letter in lower case
length	String	return the number of characters in a string
__LINE__	Flow	the current source line number
link	File	create a hard link in the filesystem
listen	Socket	register your socket as a server
local	Namespace	create a temporary value for a global variable (dynamic scoping)
localtime	Time	convert UNIX time into record or string using local time
lock	Misc	get a thread lock on a variable, subroutine, or method
log	Math	retrieve the natural logarithm for a number
lstat	File	stat a symbolic link
m//	Regexp	match a string with a regular expression pattern
map	LIST	apply a change to a list to get back a new list with the changes
mkdir	File	create a directory
msgctl	SysV	SysV IPC message control operations
msgget	SysV	get SysV IPC message queue
msgrcv	SysV	receive a SysV IPC message from a message queue
msgsnd	SysV	send a SysV IPC message to a message queue
my	Namespace	declare and assign a local variable (lexical scoping)
next	Flow	iterate a block prematurely
no	Modules	unimport some module symbols or semantics at compile time
oct	Math	String	convert a string to an octal number
open	File	open a file, pipe, or descriptor
opendir	File	open a directory
ord	String	find a character's numeric representation
our	Namespace	declare and assign a package variable (lexical scoping)
pack	Binary	String	convert a list into a binary representation
package	Modules	Namespace	Objects	declare a separate global namespace
__PACKAGE__	Flow	the current package
pipe	Process	open a pair of connected filehandles
pop	ARRAY	remove the last element from an array and return it
pos	Regexp	find or set the offset for the last/next m//g search
print	I/O	output a list to a filehandle
printf	I/O	output a formatted list to a filehandle
prototype	Misc	get the prototype (if any) of a subroutine
push	ARRAY	append one or more elements to an array
q/STRING/	String	singly quote a string
qq/STRING/	String	doubly quote a string
qr/STRING/	Regexp	compile pattern
quotemeta	Regexp	quote regular expression magic characters
qw/STRING/	LIST	quote a list of words
qx/STRING/	Process	backquote quote a string
rand	Math	retrieve the next pseudorandom number
read	Binary	I/O	fixed-length buffered input from a filehandle
readdir	I/O	get a directory from a directory handle
readline	I/O	fetch a record from a file
readlink	File	determine where a symbolic link is pointing
readpipe	Process	execute a system command and collect standard output
recv	Socket	receive a message over a Socket
redo	Flow	start this loop iteration over again
ref	Objects	find out the type of thing being referenced
rename	File	change a filename
require	Modules	load in external functions from a library at runtime
reset	Misc	clear all variables of a given name
return	Flow	get out of a function early
reverse	LIST	String	flip a string or a list
rewinddir	I/O	reset directory handle
rindex	String	right-to-left substring search
rmdir	File	remove a directory
s///	Regexp	replace a pattern with a string
say	I/O	output a list to a filehandle, appending a newline
scalar	Misc	force a scalar context
seek	I/O	reposition file pointer for random-access I/O
seekdir	I/O	reposition directory pointer
select	I/O	reset default output or do I/O multiplexing
semctl	SysV	SysV semaphore control operations
semget	SysV	get set of SysV semaphores
semop	SysV	SysV semaphore operations
send	Socket	send a message over a socket
setgrent	User	prepare group file for use
sethostent	Network	prepare hosts file for use
setnetent	Network	prepare networks file for use
setpgrp	Process	set the process group of a process
setpriority	Process	set a process's nice value
setprotoent	Network	prepare protocols file for use
setpwent	User	prepare passwd file for use
setservent	Network	prepare services file for use
setsockopt	Socket	set some socket options
shift	ARRAY	remove the first element of an array, and return it
shmctl	SysV	SysV shared memory operations
shmget	SysV	get SysV shared memory segment identifier
shmread	SysV	read SysV shared memory
shmwrite	SysV	write SysV shared memory
shutdown	Socket	close down just half of a socket connection
sin	Math	return the sine of a number
sleep	Process	block for some number of seconds
socket	Socket	create a socket
socketpair	Socket	create a pair of sockets
sort	LIST	sort a list of values
splice	ARRAY	add or remove elements anywhere in an array
split	Regexp	split up a string using a regexp delimiter
sprintf	String	formatted print into a string
sqrt	Math	square root function
srand	Math	seed the random number generator
stat	File	get a file's status information
state	Namespace	declare and assign a persistent lexical variable
study	Regexp	optimize input data for repeated searches
sub	Flow	declare a subroutine, possibly anonymously
__SUB__	Flow	the current subroutine, or C<undef> if not in a subroutine
substr	String	get or alter a portion of a string
symlink	File	create a symbolic link to a file
syscall	Binary	I/O	execute an arbitrary system call
sysopen	File	open a file, pipe, or descriptor
sysread	Binary	I/O	fixed-length unbuffered input from a filehandle
sysseek	Binary	I/O	position I/O pointer on handle used with sysread and syswrite
system	Process	run a separate program
syswrite	Binary	I/O	fixed-length unbuffered output to a filehandle
tell	I/O	get current seekpointer on a filehandle
telldir	I/O	get current seekpointer on a directory handle
tie	Objects	bind a variable to an object class
tied	Objects	get a reference to the object underlying a tied variable
time	Time	return number of seconds since 1970
times	Process	Time	return elapsed time for self and child processes
tr///	String	transliterate a string
truncate	I/O	shorten a file
uc	String	return upper-case version of a string
ucfirst	String	return a string with just the next letter in upper case
umask	File	set file creation mode mask
undef	Misc	remove a variable or function definition
unlink	File	remove one link to a file
unpack	Binary	LIST	convert binary structure into normal perl variables
unshift	ARRAY	prepend more elements to the beginning of a list
untie	Objects	break a tie binding to a variable
use	Modules	Namespace	Objects	load in a module at compile time and import its namespace
utime	File	set a file's last access and modify times
values	ARRAY	HASH	return a list of the values in a hash
vec	Binary	test or set particular bits in a string
wait	Process	wait for any child process to die
waitpid	Process	wait for a particular child process to die
wantarray	Flow	get void vs scalar vs list context of current subroutine call
warn	I/O	print debugging info
write	I/O	print a picture record
y///	String	transliterate a string
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/Pod/Html.pm                                                                   0100644 0000000 0000000 00000060044 12744441327 014646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Html;
use strict;
require Exporter;

use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
$VERSION = 1.21;
@ISA = qw(Exporter);
@EXPORT = qw(pod2html htmlify);
@EXPORT_OK = qw(anchorify);

use Carp;
use Config;
use Cwd;
use File::Basename;
use File::Spec;
use File::Spec::Unix;
use Getopt::Long;
use Pod::Simple::Search;
BEGIN {
    if($Config{d_setlocale}) {
        require locale; import locale; # make \w work right in non-ASCII lands
    }
}

=head1 NAME

Pod::Html - module to convert pod files to HTML

=head1 SYNOPSIS

    use Pod::Html;
    pod2html([options]);

=head1 DESCRIPTION

Converts files from pod format (see L<perlpod>) to HTML format.  It
can automatically generate indexes and cross-references, and it keeps
a cache of things it knows how to cross-reference.

=head1 FUNCTIONS

=head2 pod2html

    pod2html("pod2html",
             "--podpath=lib:ext:pod:vms",
             "--podroot=/usr/src/perl",
             "--htmlroot=/perl/nmanual",
             "--recurse",
             "--infile=foo.pod",
             "--outfile=/perl/nmanual/foo.html");

pod2html takes the following arguments:

=over 4

=item backlink

    --backlink

Turns every C<head1> heading into a link back to the top of the page.
By default, no backlinks are generated.

=item cachedir

    --cachedir=name

Creates the directory cache in the given directory.

=item css

    --css=stylesheet

Specify the URL of a cascading style sheet.  Also disables all HTML/CSS
C<style> attributes that are output by default (to avoid conflicts).

=item flush

    --flush

Flushes the directory cache.

=item header

    --header
    --noheader

Creates header and footer blocks containing the text of the C<NAME>
section.  By default, no headers are generated.

=item help

    --help

Displays the usage message.

=item htmldir

    --htmldir=name

Sets the directory to which all cross references in the resulting
html file will be relative. Not passing this causes all links to be
absolute since this is the value that tells Pod::Html the root of the 
documentation tree.

Do not use this and --htmlroot in the same call to pod2html; they are
mutually exclusive.

=item htmlroot

    --htmlroot=name

Sets the base URL for the HTML files.  When cross-references are made,
the HTML root is prepended to the URL.

Do not use this if relative links are desired: use --htmldir instead.

Do not pass both this and --htmldir to pod2html; they are mutually
exclusive.

=item index

    --index
    --noindex

Generate an index at the top of the HTML file.  This is the default
behaviour.

=item infile

    --infile=name

Specify the pod file to convert.  Input is taken from STDIN if no
infile is specified.

=item outfile

    --outfile=name

Specify the HTML file to create.  Output goes to STDOUT if no outfile
is specified.

=item poderrors

    --poderrors
    --nopoderrors

Include a "POD ERRORS" section in the outfile if there were any POD 
errors in the infile. This section is included by default.

=item podpath

    --podpath=name:...:name

Specify which subdirectories of the podroot contain pod files whose
HTML converted forms can be linked to in cross references.

=item podroot

    --podroot=name

Specify the base directory for finding library pods. Default is the
current working directory.

=item quiet

    --quiet
    --noquiet

Don't display I<mostly harmless> warning messages.  These messages
will be displayed by default.  But this is not the same as C<verbose>
mode.

=item recurse

    --recurse
    --norecurse

Recurse into subdirectories specified in podpath (default behaviour).

=item title

    --title=title

Specify the title of the resulting HTML file.

=item verbose

    --verbose
    --noverbose

Display progress messages.  By default, they won't be displayed.

=back

=head2 htmlify

    htmlify($heading);

Converts a pod section specification to a suitable section specification
for HTML. Note that we keep spaces and special characters except
C<", ?> (Netscape problem) and the hyphen (writer's problem...).

=head2 anchorify

    anchorify(@heading);

Similar to C<htmlify()>, but turns non-alphanumerics into underscores.  Note
that C<anchorify()> is not exported by default.

=head1 ENVIRONMENT

Uses C<$Config{pod2html}> to setup default options.

=head1 AUTHOR

Marc Green, E<lt>marcgreen@cpan.orgE<gt>. 

Original version by Tom Christiansen, E<lt>tchrist@perl.comE<gt>.

=head1 SEE ALSO

L<perlpod>

=head1 COPYRIGHT

This program is distributed under the Artistic License.

=cut

my $Cachedir; 
my $Dircache;
my($Htmlroot, $Htmldir, $Htmlfile, $Htmlfileurl);
my($Podfile, @Podpath, $Podroot);
my $Poderrors;
my $Css;

my $Recurse;
my $Quiet;
my $Verbose;
my $Doindex;

my $Backlink;

my($Title, $Header);

my %Pages = ();                 # associative array used to find the location
                                #   of pages referenced by L<> links.

my $Curdir = File::Spec->curdir;

init_globals();

sub init_globals {
    $Cachedir = ".";            # The directory to which directory caches
                                #   will be written.

    $Dircache = "pod2htmd.tmp";

    $Htmlroot = "/";            # http-server base directory from which all
                                #   relative paths in $podpath stem.
    $Htmldir = "";              # The directory to which the html pages
                                #   will (eventually) be written.
    $Htmlfile = "";             # write to stdout by default
    $Htmlfileurl = "";          # The url that other files would use to
                                # refer to this file.  This is only used
                                # to make relative urls that point to
                                # other files.

    $Poderrors = 1;
    $Podfile = "";              # read from stdin by default
    @Podpath = ();              # list of directories containing library pods.
    $Podroot = $Curdir;         # filesystem base directory from which all
                                #   relative paths in $podpath stem.
    $Css = '';                  # Cascading style sheet
    $Recurse = 1;               # recurse on subdirectories in $podpath.
    $Quiet = 0;                 # not quiet by default
    $Verbose = 0;               # not verbose by default
    $Doindex = 1;               # non-zero if we should generate an index
    $Backlink = 0;              # no backlinks added by default
    $Header = 0;                # produce block header/footer
    $Title = '';                # title to give the pod(s)
}

sub pod2html {
    local(@ARGV) = @_;
    local $_;

    init_globals();
    parse_command_line();

    # prevent '//' in urls
    $Htmlroot = "" if $Htmlroot eq "/";
    $Htmldir =~ s#/\z##;

    if (  $Htmlroot eq ''
       && defined( $Htmldir )
       && $Htmldir ne ''
       && substr( $Htmlfile, 0, length( $Htmldir ) ) eq $Htmldir
       ) {
        # Set the 'base' url for this file, so that we can use it
        # as the location from which to calculate relative links
        # to other files. If this is '', then absolute links will
        # be used throughout.
        #$Htmlfileurl = "$Htmldir/" . substr( $Htmlfile, length( $Htmldir ) + 1);
        # Is the above not just "$Htmlfileurl = $Htmlfile"?
        $Htmlfileurl = Pod::Html::_unixify($Htmlfile);

    }

    # load or generate/cache %Pages
    unless (get_cache($Dircache, \@Podpath, $Podroot, $Recurse)) {
        # generate %Pages
        my $pwd = getcwd();
        chdir($Podroot) || 
            die "$0: error changing to directory $Podroot: $!\n";

        # find all pod modules/pages in podpath, store in %Pages
        # - callback used to remove Podroot and extension from each file
        # - laborious to allow '.' in dirnames (e.g., /usr/share/perl/5.14.1)
        Pod::Simple::Search->new->inc(0)->verbose($Verbose)->laborious(1)
            ->callback(\&_save_page)->recurse($Recurse)->survey(@Podpath);

        chdir($pwd) || die "$0: error changing to directory $pwd: $!\n";

        # cache the directory list for later use
        warn "caching directories for later use\n" if $Verbose;
        open my $cache, '>', $Dircache
            or die "$0: error open $Dircache for writing: $!\n";

        print $cache join(":", @Podpath) . "\n$Podroot\n";
        my $_updirs_only = ($Podroot =~ /\.\./) && !($Podroot =~ /[^\.\\\/]/);
        foreach my $key (keys %Pages) {
            if($_updirs_only) {
              my $_dirlevel = $Podroot;
              while($_dirlevel =~ /\.\./) {
                $_dirlevel =~ s/\.\.//;
                # Assume $Pages{$key} has '/' separators (html dir separators).
                $Pages{$key} =~ s/^[\w\s\-\.]+\///;
              }
            }
            print $cache "$key $Pages{$key}\n";
        }

        close $cache or die "error closing $Dircache: $!";
    }

    # set options for the parser
    my $parser = Pod::Simple::XHTML::LocalPodLinks->new();
    $parser->codes_in_verbatim(0);
    $parser->anchor_items(1); # the old Pod::Html always did
    $parser->backlink($Backlink); # linkify =head1 directives
    $parser->htmldir($Htmldir);
    $parser->htmlfileurl($Htmlfileurl);
    $parser->htmlroot($Htmlroot);
    $parser->index($Doindex);
    $parser->no_errata_section(!$Poderrors); # note the inverse
    $parser->output_string(\my $output); # written to file later
    $parser->pages(\%Pages);
    $parser->quiet($Quiet);
    $parser->verbose($Verbose);

    # XXX: implement default title generator in pod::simple::xhtml
    # copy the way the old Pod::Html did it
    $Title = html_escape($Title);

    # We need to add this ourselves because we use our own header, not
    # ::XHTML's header. We need to set $parser->backlink to linkify
    # the =head1 directives
    my $bodyid = $Backlink ? ' id="_podtop_"' : '';

    my $csslink = '';
    my $tdstyle = ' style="background-color: #cccccc; color: #000"';

    if ($Css) {
        $csslink = qq(\n<link rel="stylesheet" href="$Css" type="text/css" />);
        $csslink =~ s,\\,/,g;
        $csslink =~ s,(/.):,$1|,;
        $tdstyle= '';
    }

    # header/footer block
    my $block = $Header ? <<END_OF_BLOCK : '';
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_"$tdstyle valign="middle">
<big><strong><span class="_podblock_">&nbsp;$Title</span></strong></big>
</td></tr>
</table>
END_OF_BLOCK

    # create own header/footer because of --header
    $parser->html_header(<<"HTMLHEAD");
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$Title</title>$csslink
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:$Config{perladmin}" />
</head>

<body$bodyid>
$block
HTMLHEAD

    $parser->html_footer(<<"HTMLFOOT");
$block
</body>

</html>
HTMLFOOT

    my $input;
    unless (@ARGV && $ARGV[0]) {
        if ($Podfile and $Podfile ne '-') {
            $input = $Podfile;
        } else {
            $input = '-'; # XXX: make a test case for this
        }
    } else {
        $Podfile = $ARGV[0];
        $input = *ARGV;
    }

    warn "Converting input file $Podfile\n" if $Verbose;
    $parser->parse_file($input);

    # Write output to file
    $Htmlfile = "-" unless $Htmlfile; # stdout
    my $fhout;
    if($Htmlfile and $Htmlfile ne '-') {
        open $fhout, ">", $Htmlfile
            or die "$0: cannot open $Htmlfile file for output: $!\n";
    } else {
        open $fhout, ">-";
    }
    binmode $fhout, ":utf8";
    print $fhout $output;
    close $fhout or die "Failed to close $Htmlfile: $!";
    chmod 0644, $Htmlfile unless $Htmlfile eq '-';
}

##############################################################################

sub usage {
    my $podfile = shift;
    warn "$0: $podfile: @_\n" if @_;
    die <<END_OF_USAGE;
Usage:  $0 --help --htmldir=<name> --htmlroot=<URL>
           --infile=<name> --outfile=<name>
           --podpath=<name>:...:<name> --podroot=<name>
           --cachedir=<name> --flush --recurse --norecurse
           --quiet --noquiet --verbose --noverbose
           --index --noindex --backlink --nobacklink
           --header --noheader --poderrors --nopoderrors
           --css=<URL> --title=<name>

  --[no]backlink  - turn =head1 directives into links pointing to the top of
                      the page (off by default).
  --cachedir      - directory for the directory cache files.
  --css           - stylesheet URL
  --flush         - flushes the directory cache.
  --[no]header    - produce block header/footer (default is no headers).
  --help          - prints this message.
  --htmldir       - directory for resulting HTML files.
  --htmlroot      - http-server base directory from which all relative paths
                      in podpath stem (default is /).
  --[no]index     - generate an index at the top of the resulting html
                      (default behaviour).
  --infile        - filename for the pod to convert (input taken from stdin
                      by default).
  --outfile       - filename for the resulting html file (output sent to
                      stdout by default).
  --[no]poderrors - include a POD ERRORS section in the output if there were 
                      any POD errors in the input (default behavior).
  --podpath       - colon-separated list of directories containing library
                      pods (empty by default).
  --podroot       - filesystem base directory from which all relative paths
                      in podpath stem (default is .).
  --[no]quiet     - suppress some benign warning messages (default is off).
  --[no]recurse   - recurse on those subdirectories listed in podpath
                      (default behaviour).
  --title         - title that will appear in resulting html file.
  --[no]verbose   - self-explanatory (off by default).

END_OF_USAGE

}

sub parse_command_line {
    my ($opt_backlink,$opt_cachedir,$opt_css,$opt_flush,$opt_header,
        $opt_help,$opt_htmldir,$opt_htmlroot,$opt_index,$opt_infile,
        $opt_outfile,$opt_poderrors,$opt_podpath,$opt_podroot,
        $opt_quiet,$opt_recurse,$opt_title,$opt_verbose,$opt_libpods);

    unshift @ARGV, split ' ', $Config{pod2html} if $Config{pod2html};
    my $result = GetOptions(
                       'backlink!'  => \$opt_backlink,
                       'cachedir=s' => \$opt_cachedir,
                       'css=s'      => \$opt_css,
                       'flush'      => \$opt_flush,
                       'help'       => \$opt_help,
                       'header!'    => \$opt_header,
                       'htmldir=s'  => \$opt_htmldir,
                       'htmlroot=s' => \$opt_htmlroot,
                       'index!'     => \$opt_index,
                       'infile=s'   => \$opt_infile,
                       'libpods=s'  => \$opt_libpods, # deprecated
                       'outfile=s'  => \$opt_outfile,
                       'poderrors!' => \$opt_poderrors,
                       'podpath=s'  => \$opt_podpath,
                       'podroot=s'  => \$opt_podroot,
                       'quiet!'     => \$opt_quiet,
                       'recurse!'   => \$opt_recurse,
                       'title=s'    => \$opt_title,
                       'verbose!'   => \$opt_verbose,
    );
    usage("-", "invalid parameters") if not $result;

    usage("-") if defined $opt_help;    # see if the user asked for help
    $opt_help = "";                     # just to make -w shut-up.

    @Podpath  = split(":", $opt_podpath) if defined $opt_podpath;
    warn "--libpods is no longer supported" if defined $opt_libpods;

    $Backlink  =          $opt_backlink   if defined $opt_backlink;
    $Cachedir  = _unixify($opt_cachedir)  if defined $opt_cachedir;
    $Css       =          $opt_css        if defined $opt_css;
    $Header    =          $opt_header     if defined $opt_header;
    $Htmldir   = _unixify($opt_htmldir)   if defined $opt_htmldir;
    $Htmlroot  = _unixify($opt_htmlroot)  if defined $opt_htmlroot;
    $Doindex   =          $opt_index      if defined $opt_index;
    $Podfile   = _unixify($opt_infile)    if defined $opt_infile;
    $Htmlfile  = _unixify($opt_outfile)   if defined $opt_outfile;
    $Poderrors =          $opt_poderrors  if defined $opt_poderrors;
    $Podroot   = _unixify($opt_podroot)   if defined $opt_podroot;
    $Quiet     =          $opt_quiet      if defined $opt_quiet;
    $Recurse   =          $opt_recurse    if defined $opt_recurse;
    $Title     =          $opt_title      if defined $opt_title;
    $Verbose   =          $opt_verbose    if defined $opt_verbose;

    warn "Flushing directory caches\n"
        if $opt_verbose && defined $opt_flush;
    $Dircache = "$Cachedir/pod2htmd.tmp";
    if (defined $opt_flush) {
        1 while unlink($Dircache);
    }
}

my $Saved_Cache_Key;

sub get_cache {
    my($dircache, $podpath, $podroot, $recurse) = @_;
    my @cache_key_args = @_;

    # A first-level cache:
    # Don't bother reading the cache files if they still apply
    # and haven't changed since we last read them.

    my $this_cache_key = cache_key(@cache_key_args);
    return 1 if $Saved_Cache_Key and $this_cache_key eq $Saved_Cache_Key;
    $Saved_Cache_Key = $this_cache_key;

    # load the cache of %Pages if possible.  $tests will be
    # non-zero if successful.
    my $tests = 0;
    if (-f $dircache) {
        warn "scanning for directory cache\n" if $Verbose;
        $tests = load_cache($dircache, $podpath, $podroot);
    }

    return $tests;
}

sub cache_key {
    my($dircache, $podpath, $podroot, $recurse) = @_;
    return join('!',$dircache,$recurse,@$podpath,$podroot,stat($dircache));
}

#
# load_cache - tries to find if the cache stored in $dircache is a valid
#  cache of %Pages.  if so, it loads them and returns a non-zero value.
#
sub load_cache {
    my($dircache, $podpath, $podroot) = @_;
    my $tests = 0;
    local $_;

    warn "scanning for directory cache\n" if $Verbose;
    open(my $cachefh, '<', $dircache) ||
        die "$0: error opening $dircache for reading: $!\n";
    $/ = "\n";

    # is it the same podpath?
    $_ = <$cachefh>;
    chomp($_);
    $tests++ if (join(":", @$podpath) eq $_);

    # is it the same podroot?
    $_ = <$cachefh>;
    chomp($_);
    $tests++ if ($podroot eq $_);

    # load the cache if its good
    if ($tests != 2) {
        close($cachefh);
        return 0;
    }

    warn "loading directory cache\n" if $Verbose;
    while (<$cachefh>) {
        /(.*?) (.*)$/;
        $Pages{$1} = $2;
    }

    close($cachefh);
    return 1;
}


#
# html_escape: make text safe for HTML
#
sub html_escape {
    my $rest = $_[0];
    $rest   =~ s/&/&amp;/g;
    $rest   =~ s/</&lt;/g;
    $rest   =~ s/>/&gt;/g;
    $rest   =~ s/"/&quot;/g;
    # &apos; is only in XHTML, not HTML4.  Be conservative
    #$rest   =~ s/'/&apos;/g;
    return $rest;
}

#
# htmlify - converts a pod section specification to a suitable section
# specification for HTML. Note that we keep spaces and special characters
# except ", ? (Netscape problem) and the hyphen (writer's problem...).
#
sub htmlify {
    my( $heading) = @_;
    $heading =~ s/(\s+)/ /g;
    $heading =~ s/\s+\Z//;
    $heading =~ s/\A\s+//;
    # The hyphen is a disgrace to the English language.
    # $heading =~ s/[-"?]//g;
    $heading =~ s/["?]//g;
    $heading = lc( $heading );
    return $heading;
}

#
# similar to htmlify, but turns non-alphanumerics into underscores
#
sub anchorify {
    my ($anchor) = @_;
    $anchor = htmlify($anchor);
    $anchor =~ s/\W/_/g;
    return $anchor;
}

#
# store POD files in %Pages
#
sub _save_page {
    my ($modspec, $modname) = @_;

    # Remove Podroot from path
    $modspec = $Podroot eq File::Spec->curdir
               ? File::Spec->abs2rel($modspec)
               : File::Spec->abs2rel($modspec,
                                     File::Spec->canonpath($Podroot));

    # Convert path to unix style path
    $modspec = Pod::Html::_unixify($modspec);

    my ($file, $dir) = fileparse($modspec, qr/\.[^.]*/); # strip .ext
    $Pages{$modname} = $dir.$file;
}

sub _unixify {
    my $full_path = shift;
    return '' unless $full_path;
    return $full_path if $full_path eq '/';

    my ($vol, $dirs, $file) = File::Spec->splitpath($full_path);
    my @dirs = $dirs eq File::Spec->curdir()
               ? (File::Spec::Unix->curdir())
               : File::Spec->splitdir($dirs);
    if (defined($vol) && $vol) {
        $vol =~ s/:$// if $^O eq 'VMS';
        $vol = uc $vol if $^O eq 'MSWin32';

        if( $dirs[0] ) {
            unshift @dirs, $vol;
        }
        else {
            $dirs[0] = $vol;
        }
    }
    unshift @dirs, '' if File::Spec->file_name_is_absolute($full_path);
    return $file unless scalar(@dirs);
    $full_path = File::Spec::Unix->catfile(File::Spec::Unix->catdir(@dirs),
                                           $file);
    $full_path =~ s|^\/|| if $^O eq 'MSWin32'; # C:/foo works, /C:/foo doesn't
    $full_path =~ s/\^\././g if $^O eq 'VMS'; # unescape dots
    return $full_path;
}

package Pod::Simple::XHTML::LocalPodLinks;
use strict;
use warnings;
use parent 'Pod::Simple::XHTML';

use File::Spec;
use File::Spec::Unix;

__PACKAGE__->_accessorize(
 'htmldir',
 'htmlfileurl',
 'htmlroot',
 'pages', # Page name => relative/path/to/page from root POD dir
 'quiet',
 'verbose',
);

sub resolve_pod_page_link {
    my ($self, $to, $section) = @_;

    return undef unless defined $to || defined $section;
    if (defined $section) {
        $section = '#' . $self->idify($section, 1);
        return $section unless defined $to;
    } else {
        $section = '';
    }

    my $path; # path to $to according to %Pages
    unless (exists $self->pages->{$to}) {
        # Try to find a POD that ends with $to and use that.
        # e.g., given L<XHTML>, if there is no $Podpath/XHTML in %Pages,
        # look for $Podpath/*/XHTML in %Pages, with * being any path,
        # as a substitute (e.g., $Podpath/Pod/Simple/XHTML)
        my @matches;
        foreach my $modname (keys %{$self->pages}) {
            push @matches, $modname if $modname =~ /::\Q$to\E\z/;
        }

        if ($#matches == -1) {
            warn "Cannot find \"$to\" in podpath: " . 
                 "cannot find suitable replacement path, cannot resolve link\n"
                 unless $self->quiet;
            return '';
        } elsif ($#matches == 0) {
            warn "Cannot find \"$to\" in podpath: " .
                 "using $matches[0] as replacement path to $to\n" 
                 unless $self->quiet;
            $path = $self->pages->{$matches[0]};
        } else {
            warn "Cannot find \"$to\" in podpath: " .
                 "more than one possible replacement path to $to, " .
                 "using $matches[-1]\n" unless $self->quiet;
            # Use [-1] so newer (higher numbered) perl PODs are used
            $path = $self->pages->{$matches[-1]};
        }
    } else {
        $path = $self->pages->{$to};
    }

    my $url = File::Spec::Unix->catfile(Pod::Html::_unixify($self->htmlroot),
                                        $path);

    if ($self->htmlfileurl ne '') {
        # then $self->htmlroot eq '' (by definition of htmlfileurl) so
        # $self->htmldir needs to be prepended to link to get the absolute path
        # that will be relativized
        $url = relativize_url(
            File::Spec::Unix->catdir(Pod::Html::_unixify($self->htmldir), $url),
            $self->htmlfileurl # already unixified
        );
    }

    return $url . ".html$section";
}

#
# relativize_url - convert an absolute URL to one relative to a base URL.
# Assumes both end in a filename.
#
sub relativize_url {
    my ($dest, $source) = @_;

    # Remove each file from its path
    my ($dest_volume, $dest_directory, $dest_file) =
        File::Spec::Unix->splitpath( $dest );
    $dest = File::Spec::Unix->catpath( $dest_volume, $dest_directory, '' );

    my ($source_volume, $source_directory, $source_file) =
        File::Spec::Unix->splitpath( $source );
    $source = File::Spec::Unix->catpath( $source_volume, $source_directory, '' );

    my $rel_path = '';
    if ($dest ne '') {
       $rel_path = File::Spec::Unix->abs2rel( $dest, $source );
    }

    if ($rel_path ne '' && substr( $rel_path, -1 ) ne '/') {
        $rel_path .= "/$dest_file";
    } else {
        $rel_path .= "$dest_file";
    }

    return $rel_path;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Pod/InputObjects.pm                                                           0100644 0000000 0000000 00000065572 12744441327 016366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #############################################################################
# Pod/InputObjects.pm -- package which defines objects for input streams
# and paragraphs and commands when parsing POD docs.
#
# Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::InputObjects;
use strict;

use vars qw($VERSION);
$VERSION = '1.62';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

#############################################################################

=head1 NAME

Pod::InputObjects - objects representing POD input paragraphs, commands, etc.

=head1 SYNOPSIS

    use Pod::InputObjects;

=head1 REQUIRES

perl5.004, Carp

=head1 EXPORTS

Nothing.

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

This module defines some basic input objects used by B<Pod::Parser> when
reading and parsing POD text from an input source. The following objects
are defined:

=begin __PRIVATE__

=over 4

=item package B<Pod::InputSource>

An object corresponding to a source of POD input text. It is mostly a
wrapper around a filehandle or C<IO::Handle>-type object (or anything
that implements the C<getline()> method) which keeps track of some
additional information relevant to the parsing of PODs.

=back

=end __PRIVATE__

=over 4

=item package B<Pod::Paragraph>

An object corresponding to a paragraph of POD input text. It may be a
plain paragraph, a verbatim paragraph, or a command paragraph (see
L<perlpod>).

=item package B<Pod::InteriorSequence>

An object corresponding to an interior sequence command from the POD
input text (see L<perlpod>).

=item package B<Pod::ParseTree>

An object corresponding to a tree of parsed POD text. Each "node" in
a parse-tree (or I<ptree>) is either a text-string or a reference to
a B<Pod::InteriorSequence> object. The nodes appear in the parse-tree
in the order in which they were parsed from left-to-right.

=back

Each of these input objects are described in further detail in the
sections which follow.

=cut

#############################################################################

package Pod::InputSource;

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head1 B<Pod::InputSource>

This object corresponds to an input source or stream of POD
documentation. When parsing PODs, it is necessary to associate and store
certain context information with each input source. All of this
information is kept together with the stream itself in one of these
C<Pod::InputSource> objects. Each such object is merely a wrapper around
an C<IO::Handle> object of some kind (or at least something that
implements the C<getline()> method). They have the following
methods/attributes:

=end __PRIVATE__

=cut

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<new()>

        my $pod_input1 = Pod::InputSource->new(-handle => $filehandle);
        my $pod_input2 = new Pod::InputSource(-handle => $filehandle,
                                              -name   => $name);
        my $pod_input3 = new Pod::InputSource(-handle => \*STDIN);
        my $pod_input4 = Pod::InputSource->new(-handle => \*STDIN,
                                               -name => "(STDIN)");

This is a class method that constructs a C<Pod::InputSource> object and
returns a reference to the new input source object. It takes one or more
keyword arguments in the form of a hash. The keyword C<-handle> is
required and designates the corresponding input handle. The keyword
C<-name> is optional and specifies the name associated with the input
handle (typically a file name).

=end __PRIVATE__

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = { -name        => '(unknown)',
                 -handle      => undef,
                 -was_cutting => 0,
                 @_ };

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<name()>

        my $filename = $pod_input->name();
        $pod_input->name($new_filename_to_use);

This method gets/sets the name of the input source (usually a filename).
If no argument is given, it returns a string containing the name of
the input source; otherwise it sets the name of the input source to the
contents of the given argument.

=end __PRIVATE__

=cut

sub name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## allow 'filename' as an alias for 'name'
*filename = \&name;

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<handle()>

        my $handle = $pod_input->handle();

Returns a reference to the handle object from which input is read (the
one used to contructed this input source object).

=end __PRIVATE__

=cut

sub handle {
   return $_[0]->{'-handle'};
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head2 B<was_cutting()>

        print "Yes.\n" if ($pod_input->was_cutting());

The value of the C<cutting> state (that the B<cutting()> method would
have returned) immediately before any input was read from this input
stream. After all input from this stream has been read, the C<cutting>
state is restored to this value.

=end __PRIVATE__

=cut

sub was_cutting {
   (@_ > 1)  and  $_[0]->{-was_cutting} = $_[1];
   return $_[0]->{-was_cutting};
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::Paragraph;

##---------------------------------------------------------------------------

=head1 B<Pod::Paragraph>

An object representing a paragraph of POD input text.
It has the following methods/attributes:

=cut

##---------------------------------------------------------------------------

=head2 Pod::Paragraph-E<gt>B<new()>

        my $pod_para1 = Pod::Paragraph->new(-text => $text);
        my $pod_para2 = Pod::Paragraph->new(-name => $cmd,
                                            -text => $text);
        my $pod_para3 = new Pod::Paragraph(-text => $text);
        my $pod_para4 = new Pod::Paragraph(-name => $cmd,
                                           -text => $text);
        my $pod_para5 = Pod::Paragraph->new(-name => $cmd,
                                            -text => $text,
                                            -file => $filename,
                                            -line => $line_number);

This is a class method that constructs a C<Pod::Paragraph> object and
returns a reference to the new paragraph object. It may be given one or
two keyword arguments. The C<-text> keyword indicates the corresponding
text of the POD paragraph. The C<-name> keyword indicates the name of
the corresponding POD command, such as C<head1> or C<item> (it should
I<not> contain the C<=> prefix); this is needed only if the POD
paragraph corresponds to a command paragraph. The C<-file> and C<-line>
keywords indicate the filename and line number corresponding to the
beginning of the paragraph 

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = {
          -name       => undef,
          -text       => (@_ == 1) ? shift : undef,
          -file       => '<unknown-file>',
          -line       => 0,
          -prefix     => '=',
          -separator  => ' ',
          -ptree => [],
          @_
    };

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_name()>

        my $para_cmd = $pod_para->cmd_name();

If this paragraph is a command paragraph, then this method will return 
the name of the command (I<without> any leading C<=> prefix).

=cut

sub cmd_name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## let name() be an alias for cmd_name()
*name = \&cmd_name;

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<text()>

        my $para_text = $pod_para->text();

This method will return the corresponding text of the paragraph.

=cut

sub text {
   (@_ > 1)  and  $_[0]->{'-text'} = $_[1];
   return $_[0]->{'-text'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<raw_text()>

        my $raw_pod_para = $pod_para->raw_text();

This method will return the I<raw> text of the POD paragraph, exactly
as it appeared in the input.

=cut

sub raw_text {
   return $_[0]->{'-text'}  unless (defined $_[0]->{'-name'});
   return $_[0]->{'-prefix'} . $_[0]->{'-name'} .
          $_[0]->{'-separator'} . $_[0]->{'-text'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_prefix()>

        my $prefix = $pod_para->cmd_prefix();

If this paragraph is a command paragraph, then this method will return 
the prefix used to denote the command (which should be the string "="
or "==").

=cut

sub cmd_prefix {
   return $_[0]->{'-prefix'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<cmd_separator()>

        my $separator = $pod_para->cmd_separator();

If this paragraph is a command paragraph, then this method will return
the text used to separate the command name from the rest of the
paragraph (if any).

=cut

sub cmd_separator {
   return $_[0]->{'-separator'};
}

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<parse_tree()>

        my $ptree = $pod_parser->parse_text( $pod_para->text() );
        $pod_para->parse_tree( $ptree );
        $ptree = $pod_para->parse_tree();

This method will get/set the corresponding parse-tree of the paragraph's text.

=cut

sub parse_tree {
   (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
   return $_[0]->{'-ptree'};
}

## let ptree() be an alias for parse_tree()
*ptree = \&parse_tree;

##---------------------------------------------------------------------------

=head2 $pod_para-E<gt>B<file_line()>

        my ($filename, $line_number) = $pod_para->file_line();
        my $position = $pod_para->file_line();

Returns the current filename and line number for the paragraph
object.  If called in a list context, it returns a list of two
elements: first the filename, then the line number. If called in
a scalar context, it returns a string containing the filename, followed
by a colon (':'), followed by the line number.

=cut

sub file_line {
   my @loc = ($_[0]->{'-file'} || '<unknown-file>',
              $_[0]->{'-line'} || 0);
   return (wantarray) ? @loc : join(':', @loc);
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::InteriorSequence;

##---------------------------------------------------------------------------

=head1 B<Pod::InteriorSequence>

An object representing a POD interior sequence command.
It has the following methods/attributes:

=cut

##---------------------------------------------------------------------------

=head2 Pod::InteriorSequence-E<gt>B<new()>

        my $pod_seq1 = Pod::InteriorSequence->new(-name => $cmd
                                                  -ldelim => $delimiter);
        my $pod_seq2 = new Pod::InteriorSequence(-name => $cmd,
                                                 -ldelim => $delimiter);
        my $pod_seq3 = new Pod::InteriorSequence(-name => $cmd,
                                                 -ldelim => $delimiter,
                                                 -file => $filename,
                                                 -line => $line_number);

        my $pod_seq4 = new Pod::InteriorSequence(-name => $cmd, $ptree);
        my $pod_seq5 = new Pod::InteriorSequence($cmd, $ptree);

This is a class method that constructs a C<Pod::InteriorSequence> object
and returns a reference to the new interior sequence object. It should
be given two keyword arguments.  The C<-ldelim> keyword indicates the
corresponding left-delimiter of the interior sequence (e.g. 'E<lt>').
The C<-name> keyword indicates the name of the corresponding interior
sequence command, such as C<I> or C<B> or C<C>. The C<-file> and
C<-line> keywords indicate the filename and line number corresponding
to the beginning of the interior sequence. If the C<$ptree> argument is
given, it must be the last argument, and it must be either string, or
else an array-ref suitable for passing to B<Pod::ParseTree::new> (or
it may be a reference to a Pod::ParseTree object).

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    ## See if first argument has no keyword
    if (((@_ <= 2) or (@_ % 2)) and $_[0] !~ /^-\w/) {
       ## Yup - need an implicit '-name' before first parameter
       unshift @_, '-name';
    }

    ## See if odd number of args
    if ((@_ % 2) != 0) {
       ## Yup - need an implicit '-ptree' before the last parameter
       splice @_, $#_, 0, '-ptree';
    }

    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object. Note that we default
    ## certain values by specifying them *before* the arguments passed.
    ## If they are in the argument list, they will override the defaults.
    my $self = {
          -name       => (@_ == 1) ? $_[0] : undef,
          -file       => '<unknown-file>',
          -line       => 0,
          -ldelim     => '<',
          -rdelim     => '>',
          @_
    };

    ## Initialize contents if they haven't been already
    my $ptree = $self->{'-ptree'} || new Pod::ParseTree();
    if ( ref $ptree =~ /^(ARRAY)?$/ ) {
        ## We have an array-ref, or a normal scalar. Pass it as an
        ## an argument to the ptree-constructor
        $ptree = new Pod::ParseTree($1 ? [$ptree] : $ptree);
    }
    $self->{'-ptree'} = $ptree;

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<cmd_name()>

        my $seq_cmd = $pod_seq->cmd_name();

The name of the interior sequence command.

=cut

sub cmd_name {
   (@_ > 1)  and  $_[0]->{'-name'} = $_[1];
   return $_[0]->{'-name'};
}

## let name() be an alias for cmd_name()
*name = \&cmd_name;

##---------------------------------------------------------------------------

## Private subroutine to set the parent pointer of all the given
## children that are interior-sequences to be $self

sub _set_child2parent_links {
   my ($self, @children) = @_;
   ## Make sure any sequences know who their parent is
   for (@children) {
      next  unless (length  and  ref  and  ref ne 'SCALAR');
      if (UNIVERSAL::isa($_, 'Pod::InteriorSequence') or
          UNIVERSAL::can($_, 'nested'))
      {
          $_->nested($self);
      }
   }
}

## Private subroutine to unset child->parent links

sub _unset_child2parent_links {
   my $self = shift;
   $self->{'-parent_sequence'} = undef;
   my $ptree = $self->{'-ptree'};
   for (@$ptree) {
      next  unless (length  and  ref  and  ref ne 'SCALAR');
      $_->_unset_child2parent_links()
          if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
   }
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<prepend()>

        $pod_seq->prepend($text);
        $pod_seq1->prepend($pod_seq2);

Prepends the given string or parse-tree or sequence object to the parse-tree
of this interior sequence.

=cut

sub prepend {
   my $self  = shift;
   $self->{'-ptree'}->prepend(@_);
   _set_child2parent_links($self, @_);
   return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<append()>

        $pod_seq->append($text);
        $pod_seq1->append($pod_seq2);

Appends the given string or parse-tree or sequence object to the parse-tree
of this interior sequence.

=cut

sub append {
   my $self = shift;
   $self->{'-ptree'}->append(@_);
   _set_child2parent_links($self, @_);
   return $self;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<nested()>

        $outer_seq = $pod_seq->nested || print "not nested";

If this interior sequence is nested inside of another interior
sequence, then the outer/parent sequence that contains it is
returned. Otherwise C<undef> is returned.

=cut

sub nested {
   my $self = shift;
  (@_ == 1)  and  $self->{'-parent_sequence'} = shift;
   return  $self->{'-parent_sequence'} || undef;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<raw_text()>

        my $seq_raw_text = $pod_seq->raw_text();

This method will return the I<raw> text of the POD interior sequence,
exactly as it appeared in the input.

=cut

sub raw_text {
   my $self = shift;
   my $text = $self->{'-name'} . $self->{'-ldelim'};
   for ( $self->{'-ptree'}->children ) {
      $text .= (ref $_) ? $_->raw_text : $_;
   }
   $text .= $self->{'-rdelim'};
   return $text;
}

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<left_delimiter()>

        my $ldelim = $pod_seq->left_delimiter();

The leftmost delimiter beginning the argument text to the interior
sequence (should be "<").

=cut

sub left_delimiter {
   (@_ > 1)  and  $_[0]->{'-ldelim'} = $_[1];
   return $_[0]->{'-ldelim'};
}

## let ldelim() be an alias for left_delimiter()
*ldelim = \&left_delimiter;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<right_delimiter()>

The rightmost delimiter beginning the argument text to the interior
sequence (should be ">").

=cut

sub right_delimiter {
   (@_ > 1)  and  $_[0]->{'-rdelim'} = $_[1];
   return $_[0]->{'-rdelim'};
}

## let rdelim() be an alias for right_delimiter()
*rdelim = \&right_delimiter;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<parse_tree()>

        my $ptree = $pod_parser->parse_text($paragraph_text);
        $pod_seq->parse_tree( $ptree );
        $ptree = $pod_seq->parse_tree();

This method will get/set the corresponding parse-tree of the interior
sequence's text.

=cut

sub parse_tree {
   (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
   return $_[0]->{'-ptree'};
}

## let ptree() be an alias for parse_tree()
*ptree = \&parse_tree;

##---------------------------------------------------------------------------

=head2 $pod_seq-E<gt>B<file_line()>

        my ($filename, $line_number) = $pod_seq->file_line();
        my $position = $pod_seq->file_line();

Returns the current filename and line number for the interior sequence
object.  If called in a list context, it returns a list of two
elements: first the filename, then the line number. If called in
a scalar context, it returns a string containing the filename, followed
by a colon (':'), followed by the line number.

=cut

sub file_line {
   my @loc = ($_[0]->{'-file'}  || '<unknown-file>',
              $_[0]->{'-line'}  || 0);
   return (wantarray) ? @loc : join(':', @loc);
}

##---------------------------------------------------------------------------

=head2 Pod::InteriorSequence::B<DESTROY()>

This method performs any necessary cleanup for the interior-sequence.
If you override this method then it is B<imperative> that you invoke
the parent method from within your own method, otherwise
I<interior-sequence storage will not be reclaimed upon destruction!>

=cut

sub DESTROY {
   ## We need to get rid of all child->parent pointers throughout the
   ## tree so their reference counts will go to zero and they can be
   ## garbage-collected
   _unset_child2parent_links(@_);
}

##---------------------------------------------------------------------------

#############################################################################

package Pod::ParseTree;

##---------------------------------------------------------------------------

=head1 B<Pod::ParseTree>

This object corresponds to a tree of parsed POD text. As POD text is
scanned from left to right, it is parsed into an ordered list of
text-strings and B<Pod::InteriorSequence> objects (in order of
appearance). A B<Pod::ParseTree> object corresponds to this list of
strings and sequences. Each interior sequence in the parse-tree may
itself contain a parse-tree (since interior sequences may be nested).

=cut

##---------------------------------------------------------------------------

=head2 Pod::ParseTree-E<gt>B<new()>

        my $ptree1 = Pod::ParseTree->new;
        my $ptree2 = new Pod::ParseTree;
        my $ptree4 = Pod::ParseTree->new($array_ref);
        my $ptree3 = new Pod::ParseTree($array_ref);

This is a class method that constructs a C<Pod::Parse_tree> object and
returns a reference to the new parse-tree. If a single-argument is given,
it must be a reference to an array, and is used to initialize the root
(top) of the parse tree.

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my $this = shift;
    my $class = ref($this) || $this;

    my $self = (@_ == 1  and  ref $_[0]) ? $_[0] : [];

    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    return $self;
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<top()>

        my $top_node = $ptree->top();
        $ptree->top( $top_node );
        $ptree->top( @children );

This method gets/sets the top node of the parse-tree. If no arguments are
given, it returns the topmost node in the tree (the root), which is also
a B<Pod::ParseTree>. If it is given a single argument that is a reference,
then the reference is assumed to a parse-tree and becomes the new top node.
Otherwise, if arguments are given, they are treated as the new list of
children for the top node.

=cut

sub top {
   my $self = shift;
   if (@_ > 0) {
      @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
   }
   return $self;
}

## let parse_tree() & ptree() be aliases for the 'top' method
*parse_tree = *ptree = \&top;

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<children()>

This method gets/sets the children of the top node in the parse-tree.
If no arguments are given, it returns the list (array) of children
(each of which should be either a string or a B<Pod::InteriorSequence>.
Otherwise, if arguments are given, they are treated as the new list of
children for the top node.

=cut

sub children {
   my $self = shift;
   if (@_ > 0) {
      @{ $self } = (@_ == 1  and  ref $_[0]) ? ${ @_ } : @_;
   }
   return @{ $self };
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<prepend()>

This method prepends the given text or parse-tree to the current parse-tree.
If the first item on the parse-tree is text and the argument is also text,
then the text is prepended to the first item (not added as a separate string).
Otherwise the argument is added as a new string or parse-tree I<before>
the current one.

=cut

use vars qw(@ptree);  ## an alias used for performance reasons

sub prepend {
   my $self = shift;
   local *ptree = $self;
   for (@_) {
      next  unless length;
      if (@ptree && !(ref $ptree[0]) && !(ref $_)) {
         $ptree[0] = $_ . $ptree[0];
      }
      else {
         unshift @ptree, $_;
      }
   }
}

##---------------------------------------------------------------------------

=head2 $ptree-E<gt>B<append()>

This method appends the given text or parse-tree to the current parse-tree.
If the last item on the parse-tree is text and the argument is also text,
then the text is appended to the last item (not added as a separate string).
Otherwise the argument is added as a new string or parse-tree I<after>
the current one.

=cut

sub append {
   my $self = shift;
   local *ptree = $self;
   my $can_append = @ptree && !(ref $ptree[-1]);
   for (@_) {
      if (ref) {
         push @ptree, $_;
      }
      elsif(!length) {
         next;
      }
      elsif ($can_append) {
         $ptree[-1] .= $_;
      }
      else {
         push @ptree, $_;
      }
   }
}

=head2 $ptree-E<gt>B<raw_text()>

        my $ptree_raw_text = $ptree->raw_text();

This method will return the I<raw> text of the POD parse-tree
exactly as it appeared in the input.

=cut

sub raw_text {
   my $self = shift;
   my $text = '';
   for ( @$self ) {
      $text .= (ref $_) ? $_->raw_text : $_;
   }
   return $text;
}

##---------------------------------------------------------------------------

## Private routines to set/unset child->parent links

sub _unset_child2parent_links {
   my $self = shift;
   local *ptree = $self;
   for (@ptree) {
       next  unless (defined and length  and  ref  and  ref ne 'SCALAR');
       $_->_unset_child2parent_links()
           if UNIVERSAL::isa($_, 'Pod::InteriorSequence');
   }
}

sub _set_child2parent_links {
    ## nothing to do, Pod::ParseTrees cant have parent pointers
}

=head2 Pod::ParseTree::B<DESTROY()>

This method performs any necessary cleanup for the parse-tree.
If you override this method then it is B<imperative>
that you invoke the parent method from within your own method,
otherwise I<parse-tree storage will not be reclaimed upon destruction!>

=cut

sub DESTROY {
   ## We need to get rid of all child->parent pointers throughout the
   ## tree so their reference counts will go to zero and they can be
   ## garbage-collected
   _unset_child2parent_links(@_);
}

#############################################################################

=head1 SEE ALSO

B<Pod::InputObjects> is part of the L<Pod::Parser> distribution.

See L<Pod::Parser>, L<Pod::Select>

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@enteract.comE<gt>

=cut

1;
                                                                                                                                      usr/share/perl/5.20.2/Pod/Man.pm                                                                    0100644 0000000 0000000 00000222240 12744441327 014453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Pod::Man -- Convert POD data to formatted *roff input.
#
# This module translates POD documentation into *roff markup using the man
# macro set, and is intended for converting POD documents written as Unix
# manual pages to manual pages that can be read by the man(1) command.  It is
# a replacement for the pod2man command distributed with versions of Perl
# prior to 5.6.
#
# Perl core hackers, please note that this module is also separately
# maintained outside of the Perl core as part of the podlators.  Please send
# me any patches at the address above in addition to sending them to the
# standard Perl mailing lists.
#
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
#     2010, 2012, 2013 Russ Allbery <rra@stanford.edu>
# Substantial contributions by Sean Burke <sburke@cpan.org>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.

##############################################################################
# Modules and declarations
##############################################################################

package Pod::Man;

require 5.005;

use strict;
use subs qw(makespace);
use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);

use Carp qw(croak);
use Encode qw(encode);
use Pod::Simple ();

@ISA = qw(Pod::Simple);

$VERSION = '2.28';

# Set the debugging level.  If someone has inserted a debug function into this
# class already, use that.  Otherwise, use any Pod::Simple debug function
# that's defined, and failing that, define a debug level of 10.
BEGIN {
    my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
    unless (defined &DEBUG) {
        *DEBUG = $parent || sub () { 10 };
    }
}

# Import the ASCII constant from Pod::Simple.  This is true iff we're in an
# ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
# generally only false for EBCDIC.
BEGIN { *ASCII = \&Pod::Simple::ASCII }

# Pretty-print a data structure.  Only used for debugging.
BEGIN { *pretty = \&Pod::Simple::pretty }

# Formatting instructions for various types of blocks.  cleanup makes hyphens
# hard, adds spaces between consecutive underscores, and escapes backslashes.
# convert translates characters into escapes.  guesswork means to apply the
# transformations done by the guesswork sub.  literal says to protect literal
# quotes from being turned into UTF-8 quotes.  By default, all transformations
# are on except literal, but some elements override.
#
# DEFAULT specifies the default settings.  All other elements should list only
# those settings that they are overriding.  Data indicates =for roff blocks,
# which should be passed along completely verbatim.
#
# Formatting inherits negatively, in the sense that if the parent has turned
# off guesswork, all child elements should leave it off.
my %FORMATTING = (
    DEFAULT  => { cleanup => 1, convert => 1, guesswork => 1, literal => 0 },
    Data     => { cleanup => 0, convert => 0, guesswork => 0, literal => 0 },
    Verbatim => {                             guesswork => 0, literal => 1 },
    C        => {                             guesswork => 0, literal => 1 },
    X        => { cleanup => 0,               guesswork => 0               },
);

##############################################################################
# Object initialization
##############################################################################

# Initialize the object and set various Pod::Simple options that we need.
# Here, we also process any additional options passed to the constructor or
# set up defaults if none were given.  Note that all internal object keys are
# in all-caps, reserving all lower-case object keys for Pod::Simple and user
# arguments.
sub new {
    my $class = shift;
    my $self = $class->SUPER::new;

    # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
    $self->nbsp_for_S (1);

    # Tell Pod::Simple to keep whitespace whenever possible.
    if (my $preserve_whitespace = $self->can ('preserve_whitespace')) {
        $self->$preserve_whitespace (1);
    } else {
        $self->fullstop_space_harden (1);
    }

    # The =for and =begin targets that we accept.
    $self->accept_targets (qw/man MAN roff ROFF/);

    # Ensure that contiguous blocks of code are merged together.  Otherwise,
    # some of the guesswork heuristics don't work right.
    $self->merge_text (1);

    # Pod::Simple doesn't do anything useful with our arguments, but we want
    # to put them in our object as hash keys and values.  This could cause
    # problems if we ever clash with Pod::Simple's own internal class
    # variables.
    %$self = (%$self, @_);

    # Send errors to stderr if requested.
    if ($$self{stderr} and not $$self{errors}) {
        $$self{errors} = 'stderr';
    }
    delete $$self{stderr};

    # Validate the errors parameter and act on it.
    if (not defined $$self{errors}) {
        $$self{errors} = 'pod';
    }
    if ($$self{errors} eq 'stderr' || $$self{errors} eq 'die') {
        $self->no_errata_section (1);
        $self->complain_stderr (1);
        if ($$self{errors} eq 'die') {
            $$self{complain_die} = 1;
        }
    } elsif ($$self{errors} eq 'pod') {
        $self->no_errata_section (0);
        $self->complain_stderr (0);
    } elsif ($$self{errors} eq 'none') {
        $self->no_whining (1);
    } else {
        croak (qq(Invalid errors setting: "$$self{errors}"));
    }
    delete $$self{errors};

    # Initialize various other internal constants based on our arguments.
    $self->init_fonts;
    $self->init_quotes;
    $self->init_page;

    # For right now, default to turning on all of the magic.
    $$self{MAGIC_CPP}       = 1;
    $$self{MAGIC_EMDASH}    = 1;
    $$self{MAGIC_FUNC}      = 1;
    $$self{MAGIC_MANREF}    = 1;
    $$self{MAGIC_SMALLCAPS} = 1;
    $$self{MAGIC_VARS}      = 1;

    return $self;
}

# Translate a font string into an escape.
sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }

# Determine which fonts the user wishes to use and store them in the object.
# Regular, italic, bold, and bold-italic are constants, but the fixed width
# fonts may be set by the user.  Sets the internal hash key FONTS which is
# used to map our internal font escapes to actual *roff sequences later.
sub init_fonts {
    my ($self) = @_;

    # Figure out the fixed-width font.  If user-supplied, make sure that they
    # are the right length.
    for (qw/fixed fixedbold fixeditalic fixedbolditalic/) {
        my $font = $$self{$_};
        if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
            croak qq(roff font should be 1 or 2 chars, not "$font");
        }
    }

    # Set the default fonts.  We can't be sure portably across different
    # implementations what fixed bold-italic may be called (if it's even
    # available), so default to just bold.
    $$self{fixed}           ||= 'CW';
    $$self{fixedbold}       ||= 'CB';
    $$self{fixeditalic}     ||= 'CI';
    $$self{fixedbolditalic} ||= 'CB';

    # Set up a table of font escapes.  First number is fixed-width, second is
    # bold, third is italic.
    $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                      '010' => '\fB', '011' => '\f(BI',
                      '100' => toescape ($$self{fixed}),
                      '101' => toescape ($$self{fixeditalic}),
                      '110' => toescape ($$self{fixedbold}),
                      '111' => toescape ($$self{fixedbolditalic}) };
}

# Initialize the quotes that we'll be using for C<> text.  This requires some
# special handling, both to parse the user parameter if given and to make sure
# that the quotes will be safe against *roff.  Sets the internal hash keys
# LQUOTE and RQUOTE.
sub init_quotes {
    my ($self) = (@_);

    $$self{quotes} ||= '"';
    if ($$self{quotes} eq 'none') {
        $$self{LQUOTE} = $$self{RQUOTE} = '';
    } elsif (length ($$self{quotes}) == 1) {
        $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
    } elsif ($$self{quotes} =~ /^(.)(.)$/
             || $$self{quotes} =~ /^(..)(..)$/) {
        $$self{LQUOTE} = $1;
        $$self{RQUOTE} = $2;
    } else {
        croak(qq(Invalid quote specification "$$self{quotes}"))
    }

    # Double the first quote; note that this should not be s///g as two double
    # quotes is represented in *roff as three double quotes, not four.  Weird,
    # I know.
    $$self{LQUOTE} =~ s/\"/\"\"/;
    $$self{RQUOTE} =~ s/\"/\"\"/;
}

# Initialize the page title information and indentation from our arguments.
sub init_page {
    my ($self) = @_;

    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
    my @version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
    $version[2] ||= 0;
    $version[2] *= 10 ** (3 - length $version[2]);
    for (@version) { $_ += 0 }
    my $version = join ('.', @version);

    # Set the defaults for page titles and indentation if the user didn't
    # override anything.
    $$self{center} = 'User Contributed Perl Documentation'
        unless defined $$self{center};
    $$self{release} = 'perl v' . $version
        unless defined $$self{release};
    $$self{indent} = 4
        unless defined $$self{indent};

    # Double quotes in things that will be quoted.
    for (qw/center release/) {
        $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
    }
}

##############################################################################
# Core parsing
##############################################################################

# This is the glue that connects the code below with Pod::Simple itself.  The
# goal is to convert the event stream coming from the POD parser into method
# calls to handlers once the complete content of a tag has been seen.  Each
# paragraph or POD command will have textual content associated with it, and
# as soon as all of a paragraph or POD command has been seen, that content
# will be passed in to the corresponding method for handling that type of
# object.  The exceptions are handlers for lists, which have opening tag
# handlers and closing tag handlers that will be called right away.
#
# The internal hash key PENDING is used to store the contents of a tag until
# all of it has been seen.  It holds a stack of open tags, each one
# represented by a tuple of the attributes hash for the tag, formatting
# options for the tag (which are inherited), and the contents of the tag.

# Add a block of text to the contents of the current node, formatting it
# according to the current formatting instructions as we do.
sub _handle_text {
    my ($self, $text) = @_;
    DEBUG > 3 and print "== $text\n";
    my $tag = $$self{PENDING}[-1];
    $$tag[2] .= $self->format_text ($$tag[1], $text);
}

# Given an element name, get the corresponding method name.
sub method_for_element {
    my ($self, $element) = @_;
    $element =~ tr/A-Z-/a-z_/;
    $element =~ tr/_a-z0-9//cd;
    return $element;
}

# Handle the start of a new element.  If cmd_element is defined, assume that
# we need to collect the entire tree for this element before passing it to the
# element method, and create a new tree into which we'll collect blocks of
# text and nested elements.  Otherwise, if start_element is defined, call it.
sub _handle_element_start {
    my ($self, $element, $attrs) = @_;
    DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, we need to accumulate the contents of the
    # tag before calling it.  Turn off IN_NAME for any command other than
    # <Para> and the formatting codes so that IN_NAME isn't still set for the
    # first heading after the NAME heading.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "<$element> starts saving a tag\n";
        $$self{IN_NAME} = 0 if ($element ne 'Para' && length ($element) > 1);

        # How we're going to format embedded text blocks depends on the tag
        # and also depends on our parent tags.  Thankfully, inside tags that
        # turn off guesswork and reformatting, nothing else can turn it back
        # on, so this can be strictly inherited.
        my $formatting = {
            %{ $$self{PENDING}[-1][1] || $FORMATTING{DEFAULT} },
            %{ $FORMATTING{$element} || {} },
        };
        push (@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
    } elsif (my $start_method = $self->can ("start_$method")) {
        $self->$start_method ($attrs, '');
    } else {
        DEBUG > 2 and print "No $method start method, skipping\n";
    }
}

# Handle the end of an element.  If we had a cmd_ method for this element,
# this is where we pass along the tree that we built.  Otherwise, if we have
# an end_ method for the element, call that.
sub _handle_element_end {
    my ($self, $element) = @_;
    DEBUG > 3 and print "-- $element\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, pull off the pending text and pass it to
    # the handler along with the saved attribute hash.
    if (my $cmd_method = $self->can ("cmd_$method")) {
        DEBUG > 2 and print "</$element> stops saving a tag\n";
        my $tag = pop @{ $$self{PENDING} };
        DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
        my $text = $self->$cmd_method ($$tag[0], $$tag[2]);
        if (defined $text) {
            if (@{ $$self{PENDING} } > 1) {
                $$self{PENDING}[-1][2] .= $text;
            } else {
                $self->output ($text);
            }
        }
    } elsif (my $end_method = $self->can ("end_$method")) {
        $self->$end_method ();
    } else {
        DEBUG > 2 and print "No $method end method, skipping\n";
    }
}

##############################################################################
# General formatting
##############################################################################

# Format a text block.  Takes a hash of formatting options and the text to
# format.  Currently, the only formatting options are guesswork, cleanup, and
# convert, all of which are boolean.
sub format_text {
    my ($self, $options, $text) = @_;
    my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
    my $cleanup = $$options{cleanup};
    my $convert = $$options{convert};
    my $literal = $$options{literal};

    # Cleanup just tidies up a few things, telling *roff that the hyphens are
    # hard, putting a bit of space between consecutive underscores, and
    # escaping backslashes.  Be careful not to mangle our character
    # translations by doing this before processing character translation.
    if ($cleanup) {
        $text =~ s/\\/\\e/g;
        $text =~ s/-/\\-/g;
        $text =~ s/_(?=_)/_\\|/g;
    }

    # Normally we do character translation, but we won't even do that in
    # <Data> blocks or if UTF-8 output is desired.
    if ($convert && !$$self{utf8} && ASCII) {
        $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
    }

    # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
    # but don't mess up our accept escapes.
    if ($literal) {
        $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
        $text =~ s/(?<!\\\*)\`/\\\`/g;
    }

    # If guesswork is asked for, do that.  This involves more substantial
    # formatting based on various heuristics that may only be appropriate for
    # particular documents.
    if ($guesswork) {
        $text = $self->guesswork ($text);
    }

    return $text;
}

# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;

    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';

    # If in NAME section, just return an ASCII quoted string to avoid
    # confusing tools like whatis.
    return qq{"$_"} if $$self{IN_NAME};

    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
       | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xso and return '\f(FS' . $_ . '\f(FE';

    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
}

# Takes a text block to perform guesswork on.  Returns the text block with
# formatting codes added.  This is the code that marks up various Perl
# constructs and things commonly used in man pages without requiring the user
# to add any explicit markup, and is applied to all non-literal text.  We're
# guaranteed that the text we're applying guesswork to does not contain any
# *roff formatting codes.  Note that the inserted font sequences must be
# treated later with mapfonts or textmapfonts.
#
# This method is very fragile, both in the regular expressions it uses and in
# the ordering of those modifications.  Care and testing is required when
# modifying it.
sub guesswork {
    my $self = shift;
    local $_ = shift;
    DEBUG > 5 and print "   Guesswork called on [$_]\n";

    # By the time we reach this point, all hyphens will be escaped by adding a
    # backslash.  We want to undo that escaping if they're part of regular
    # words and there's only a single dash, since that's a real hyphen that
    # *roff gets to consider a possible break point.  Make sure that a dash
    # after the first character of a word stays non-breaking, however.
    #
    # Note that this is not user-controllable; we pretty much have to do this
    # transformation or *roff will mangle the output in unacceptable ways.
    s{
        ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
        ( (?: [a-zA-Z\']+ \\-)+ )
        ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
        \b
    } {
        my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
        $hyphen ||= '';
        $main =~ s/\\-/-/g;
        $prefix . $hyphen . $main . $suffix;
    }egx;

    # Translate "--" into a real em-dash if it's used like one.  This means
    # that it's either surrounded by whitespace, it follows a regular word, or
    # it occurs between two regular words.
    if ($$self{MAGIC_EMDASH}) {
        s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
        s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
    }

    # Make words in all-caps a little bit smaller; they look better that way.
    # However, we don't want to change Perl code (like @ARGV), nor do we want
    # to fix the MIME in MIME-Version since it looks weird with the
    # full-height V.
    #
    # We change only a string of all caps (2) either at the beginning of the
    # line or following regular punctuation (like quotes) or whitespace (1),
    # and followed by either similar punctuation, an em-dash, or the end of
    # the line (3).
    #
    # Allow the text we're changing to small caps to include double quotes,
    # commas, newlines, and periods as long as it doesn't otherwise interrupt
    # the string of small caps and still fits the criteria.  This lets us turn
    # entire warranty disclaimers in man page output into small caps.
    if ($$self{MAGIC_SMALLCAPS}) {
        s{
            ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                     # (1)
            ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- | [.,\"\s] )* )  # (2)
            (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )      # (3)
        } {
            $1 . '\s-1' . $2 . '\s0'
        }egx;
    }

    # Note that from this point forward, we have to adjust for \s-1 and \s-0
    # strings inserted around things that we've made small-caps if later
    # transforms should work on those strings.

    # Italicize functions in the form func(), including functions that are in
    # all capitals, but don't italize if there's anything between the parens.
    # The function must start with an alphabetic character or underscore and
    # then consist of word characters or colons.
    if ($$self{MAGIC_FUNC}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE'
        }egx;
    }

    # Change references to manual pages to put the page name in italics but
    # the number in the regular font, with a thin space between the name and
    # the number.  Only recognize func(n) where func starts with an alphabetic
    # character or underscore and contains only word characters, periods (for
    # configuration file man pages), or colons, and n is a single digit,
    # optionally followed by some number of lowercase letters.  Note that this
    # does not recognize man page references like perl(l) or socket(3SOCKET).
    if ($$self{MAGIC_MANREF}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
            ( \( \d [a-z]* \) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE\|' . $3
        }egx;
    }

    # Convert simple Perl variable references to a fixed-width font.  Be
    # careful not to convert functions, though; there are too many subtleties
    # with them to want to perform this transformation.
    if ($$self{MAGIC_VARS}) {
        s{
           ( ^ | \s+ )
           ( [\$\@%] [\w:]+ )
           (?! \( )
        } {
            $1 . '\f(FS' . $2 . '\f(FE'
        }egx;
    }

    # Fix up double quotes.  Unfortunately, we miss this transformation if the
    # quoted text contains any code with formatting codes and there's not much
    # we can effectively do about that, which makes it somewhat unclear if
    # this is really a good idea.
    s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;

    # Make C++ into \*(C+, which is a squinched version.
    if ($$self{MAGIC_CPP}) {
        s{ \b C\+\+ } {\\*\(C+}gx;
    }

    # Done.
    DEBUG > 5 and print "   Guesswork returning [$_]\n";
    return $_;
}

##############################################################################
# Output
##############################################################################

# When building up the *roff code, we don't use real *roff fonts.  Instead, we
# embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
# F, S stands for start, and E stands for end.  This method turns these into
# the right start and end codes.
#
# We add this level of complexity because the old pod2man didn't get code like
# B<someI<thing> else> right; after I<> it switched back to normal text rather
# than bold.  We take care of this by using variables that state whether bold,
# italic, or fixed are turned on as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.
#
# \fP changes to the previous font, but only one previous font is kept.  We
# don't know what the outside level font is; normally it's R, but if we're
# inside a heading it could be something else.  So arrange things so that the
# outside font is always the "previous" font and end with \fP instead of \fR.
# Idea from Zack Weinberg.
sub mapfonts {
    my ($self, $text) = @_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    my $last = '\fR';
    $text =~ s<
        \\f\((.)(.)
    > <
        my $sequence = '';
        my $f;
        if ($last ne '\fR') { $sequence = '\fP' }
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
        if ($f eq $last) {
            '';
        } else {
            if ($f ne '\fR') { $sequence .= $f }
            $last = $f;
            $sequence;
        }
    >gxe;
    return $text;
}

# Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
# groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
# than R, presumably because \f(CW doesn't actually do a font change.  To work
# around this, use a separate textmapfonts for text blocks where the default
# font is always R and only use the smart mapfonts for headings.
sub textmapfonts {
    my ($self, $text) = @_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    $text =~ s<
        \\f\((.)(.)
    > <
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
    >gxe;
    return $text;
}

# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my ($self, $command, $text, $extra) = @_;
    $text =~ s/\\\*\([LR]\"/\"/g;

    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    my $fixedpat = join '|', @{ $$self{FONTS} }{'100', '101', '110', '111'};
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
        $text =~ s/\"/\"\"/g;
        my $nroff = $text;
        my $troff = $text;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');

        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)\\f([PR])/\\f\(BI$1\\f$2/g;

        # Now finally output the command.  Bother with .ie only if the nroff
        # and troff output aren't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
    } else {
        $text = qq("$text") . ($extra ? " $extra" : '');
        return "$command $text\n";
    }
}

# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
sub protect {
    my ($self, $text) = @_;
    $text =~ s/^([.\'\\])/\\&$1/mg;
    return $text;
}

# Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
# level the situation.  This function is needed since in *roff one has to
# create vertical whitespace after paragraphs and between some things, but
# other macros create their own whitespace.  Also close out a sequence of
# repeated =items, since calling makespace means we're about to begin the item
# body.
sub makespace {
    my ($self) = @_;
    $self->output (".PD\n") if $$self{ITEMS} > 1;
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
}

# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
sub outindex {
    my ($self, $section, $index) = @_;
    my @entries = map { split m%\s*/\s*% } @{ $$self{INDEX} };
    return unless ($section || @entries);

    # We're about to output all pending entries, so clear our pending queue.
    $$self{INDEX} = [];

    # Build the output.  Regular index entries are marked Xref, and headings
    # pass in their own section.  Undo some *roff formatting on headings.
    my @output;
    if (@entries) {
        push @output, [ 'Xref', join (' ', @entries) ];
    }
    if ($section) {
        $index =~ s/\\-/-/g;
        $index =~ s/\\(?:s-?\d|.\(..|.)//g;
        push @output, [ $section, $index ];
    }

    # Print out the .IX commands.
    for (@output) {
        my ($type, $entry) = @$_;
        $entry =~ s/\s+/ /g;
        $entry =~ s/\"/\"\"/g;
        $entry =~ s/\\/\\\\/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
    }
}

# Output some text, without any additional changes.
sub output {
    my ($self, @text) = @_;
    if ($$self{ENCODE}) {
        print { $$self{output_fh} } encode ('UTF-8', join ('', @text));
    } else {
        print { $$self{output_fh} } @text;
    }
}

##############################################################################
# Document initialization
##############################################################################

# Handle the start of the document.  Here we handle empty documents, as well
# as setting up our basic macros in a preamble and building the page title.
sub start_document {
    my ($self, $attrs) = @_;
    if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
        DEBUG and print "Document is contentless\n";
        $$self{CONTENTLESS} = 1;
    } else {
        delete $$self{CONTENTLESS};
    }

    # When UTF-8 output is set, check whether our output file handle already
    # has a PerlIO encoding layer set.  If it does not, we'll need to encode
    # our output before printing it (handled in the output() sub).  Wrap the
    # check in an eval to handle versions of Perl without PerlIO.
    $$self{ENCODE} = 0;
    if ($$self{utf8}) {
        $$self{ENCODE} = 1;
        eval {
            my @options = (output => 1, details => 1);
            my $flag = (PerlIO::get_layers ($$self{output_fh}, @options))[-1];
            if ($flag & PerlIO::F_UTF8 ()) {
                $$self{ENCODE} = 0;
            }
        }
    }

    # Determine information for the preamble and then output it unless the
    # document was content-free.
    if (!$$self{CONTENTLESS}) {
        my ($name, $section);
        if (defined $$self{name}) {
            $name = $$self{name};
            $section = $$self{section} || 1;
        } else {
            ($name, $section) = $self->devise_title;
        }
        my $date = $$self{date} || $self->devise_date;
        $self->preamble ($name, $section, $date)
            unless $self->bare_output or DEBUG > 9;
    }

    # Initialize a few per-document variables.
    $$self{INDENT}    = 0;      # Current indentation level.
    $$self{INDENTS}   = [];     # Stack of indentations.
    $$self{INDEX}     = [];     # Index keys waiting to be printed.
    $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
    $$self{ITEMS}     = 0;      # The number of consecutive =items.
    $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
    $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
    $$self{SHIFTS}    = [];     # Stack of .RS shifts.
    $$self{PENDING}   = [[]];   # Pending output.
}

# Handle the end of the document.  This handles dying on POD errors, since
# Pod::Parser currently doesn't.  Otherwise, does nothing but print out a
# final comment at the end of the document under debugging.
sub end_document {
    my ($self) = @_;
    if ($$self{complain_die} && $self->errors_seen) {
        croak ("POD document had syntax errors");
    }
    return if $self->bare_output;
    return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
    $self->output (q(.\" [End document]) . "\n") if DEBUG;
}

# Try to figure out the name and section from the file name and return them as
# a list, returning an empty name and section 1 if we can't find any better
# information.  Uses File::Basename and File::Spec as necessary.
sub devise_title {
    my ($self) = @_;
    my $name = $self->source_filename || '';
    my $section = $$self{section} || 1;
    $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
    $name =~ s/\.p(od|[lm])\z//i;

    # If the section isn't 3, then the name defaults to just the basename of
    # the file.  Otherwise, assume we're dealing with a module.  We want to
    # figure out the full module name from the path to the file, but we don't
    # want to include too much of the path into the module name.  Lose
    # anything up to the first off:
    #
    #     */lib/*perl*/         standard or site_perl module
    #     */*perl*/lib/         from -Dprefix=/opt/perl
    #     */*perl*/             random module hierarchy
    #
    # which works.  Also strip off a leading site, site_perl, or vendor_perl
    # component, any OS-specific component, and any version number component,
    # and strip off an initial component of "lib" or "blib/lib" since that's
    # what ExtUtils::MakeMaker creates.  splitdir requires at least File::Spec
    # 0.8.
    if ($section !~ /^3/) {
        require File::Basename;
        $name = uc File::Basename::basename ($name);
    } else {
        require File::Spec;
        my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
        my @dirs = File::Spec->splitdir ($dirs);
        my $cut = 0;
        my $i;
        for ($i = 0; $i < @dirs; $i++) {
            if ($dirs[$i] =~ /perl/) {
                $cut = $i + 1;
                $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                last;
            }
        }
        if ($cut > 0) {
            splice (@dirs, 0, $cut);
            shift @dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
            shift @dirs if ($dirs[0] =~ /^[\d.]+$/);
            shift @dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
        }
        shift @dirs if $dirs[0] eq 'lib';
        splice (@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');

        # Remove empty directories when building the module name; they
        # occur too easily on Unix by doubling slashes.
        $name = join ('::', (grep { $_ ? $_ : () } @dirs), $file);
    }
    return ($name, $section);
}

# Determine the modification date and return that, properly formatted in ISO
# format.
#
# If POD_MAN_DATE is set, that overrides anything else.  This can be used for
# reproducible generation of the same file even if the input file timestamps
# are unpredictable or the POD coms from standard input.
#
# Otherwise, use the modification date of the input if we can stat it.  Be
# aware that Pod::Simple returns the stringification of the file handle as
# source_filename for input from a file handle, so we'll stat some random ref
# string in that case.  If that fails, instead use the current time.
#
# $self - Pod::Man object, used to get the source file
#
# Returns: YYYY-MM-DD date suitable for the left-hand footer
sub devise_date {
    my ($self) = @_;

    # If POD_MAN_DATE is set, always use it.
    if ($ENV{POD_MAN_DATE}) {
        return $ENV{POD_MAN_DATE};
    }

    # Otherwise, get the input filename and try to stat it.  If that fails,
    # use the current time.
    my $input = $self->source_filename;
    my $time;
    if ($input) {
        $time = (stat($input))[9] || time();
    } else {
        $time = time();
    }

    # Can't use POSIX::strftime(), which uses Fcntl, because MakeMaker uses
    # this and it has to work in the core which can't load dynamic libraries.
    my ($year, $month, $day) = (localtime($time))[5,4,3];
    return sprintf("%04d-%02d-%02d", $year + 1900, $month + 1, $day);
}

# Print out the preamble and the title.  The meaning of the arguments to .TH
# unfortunately vary by system; some systems consider the fourth argument to
# be a "source" and others use it as a version number.  Generally it's just
# presented as the left-side footer, though, so it doesn't matter too much if
# a particular system gives it another interpretation.
#
# The order of date and release used to be reversed in older versions of this
# module, but this order is correct for both Solaris and Linux.
sub preamble {
    my ($self, $name, $section, $date) = @_;
    my $preamble = $self->preamble_template (!$$self{utf8});

    # Build the index line and make sure that it will be syntactically valid.
    my $index = "$name $section";
    $index =~ s/\"/\"\"/g;

    # If name or section contain spaces, quote them (section really never
    # should, but we may as well be cautious).
    for ($name, $section) {
        if (/\s/) {
            s/\"/\"\"/g;
            $_ = '"' . $_ . '"';
        }
    }

    # Double quotes in date, since it will be quoted.
    $date =~ s/\"/\"\"/g;

    # Substitute into the preamble the configuration options.
    $preamble =~ s/\@CFONT\@/$$self{fixed}/;
    $preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;
    $preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;
    chomp $preamble;

    # Get the version information.
    my $version = $self->version_report;

    # Finally output everything.
    $self->output (<<"----END OF HEADER----");
.\\" Automatically generated by $version
.\\"
.\\" Standard preamble:
.\\" ========================================================================
$preamble
.\\" ========================================================================
.\\"
.IX Title "$index"
.TH $name $section "$date" "$$self{release}" "$$self{center}"
.\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\\" way too many mistakes in technical documents.
.if n .ad l
.nh
----END OF HEADER----
    $self->output (".\\\" [End of preamble]\n") if DEBUG;
}

##############################################################################
# Text blocks
##############################################################################

# Handle a basic block of text.  The only tricky part of this is if this is
# the first paragraph of text after an =over, in which case we have to change
# indentations for *roff.
sub cmd_para {
    my ($self, $attrs, $text) = @_;
    my $line = $$attrs{start_line};

    # Output the paragraph.  We also have to handle =over without =item.  If
    # there's an =over without =item, SHIFTWAIT will be set, and we need to
    # handle creation of the indent here.  Add the shift to SHIFTS so that it
    # will be cleaned up on =back.
    $self->makespace;
    if ($$self{SHIFTWAIT}) {
        $self->output (".RS $$self{INDENT}\n");
        push (@{ $$self{SHIFTS} }, $$self{INDENT});
        $$self{SHIFTWAIT} = 0;
    }

    # Add the line number for debugging, but not in the NAME section just in
    # case the comment would confuse apropos.
    $self->output (".\\\" [At source line $line]\n")
        if defined ($line) && DEBUG && !$$self{IN_NAME};

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end, but leave "\ " backslashed space from an S< > at
    # the end of a line.  Reverse the text first, to avoid having to scan the
    # entire paragraph.
    $text = reverse $text;
    $text =~ s/\A\s*?(?= \\|\S|\z)/\n/;
    $text = reverse $text;

    # Output the paragraph.
    $self->output ($self->protect ($self->textmapfonts ($text)));
    $self->outindex;
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle a verbatim paragraph.  Put a null token at the beginning of each line
# to protect against commands and wrap in .Vb/.Ve (which we define in our
# prelude).
sub cmd_verbatim {
    my ($self, $attrs, $text) = @_;

    # Ignore an empty verbatim paragraph.
    return unless $text =~ /\S/;

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.  Reverse the text first, to avoid having to scan
    # the entire paragraph.
    $text = reverse $text;
    $text =~ s/\A\s*/\n/;
    $text = reverse $text;

    # Get a count of the number of lines before the first blank line, which
    # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
    # lines together.  We don't want to tell *roff to keep huge blocks
    # together.
    my @lines = split (/\n/, $text);
    my $unbroken = 0;
    for (@lines) {
        last if /^\s*$/;
        $unbroken++;
    }
    $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});

    # Prepend a null token to each line.
    $text =~ s/^/\\&/gm;

    # Output the results.
    $self->makespace;
    $self->output (".Vb $unbroken\n$text.Ve\n");
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle literal text (produced by =for and similar constructs).  Just output
# it with the minimum of changes.
sub cmd_data {
    my ($self, $attrs, $text) = @_;
    $text =~ s/^\n+//;
    $text =~ s/\n{0,2}$/\n/;
    $self->output ($text);
    return '';
}

##############################################################################
# Headings
##############################################################################

# Common code for all headings.  This is called before the actual heading is
# output.  It returns the cleaned up heading text (putting the heading all on
# one line) and may do other things, like closing bad =item blocks.
sub heading_common {
    my ($self, $text, $line) = @_;
    $text =~ s/\s+$//;
    $text =~ s/\s*\n\s*/ /g;

    # This should never happen; it means that we have a heading after =item
    # without an intervening =back.  But just in case, handle it anyway.
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }

    # Output the current source line.
    $self->output ( ".\\\" [At source line $line]\n" )
        if defined ($line) && DEBUG;
    return $text;
}

# First level heading.  We can't output .IX in the NAME section due to a bug
# in some versions of catman, so don't output a .IX for that section.  .SH
# already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
# appropriate.
sub cmd_head1 {
    my ($self, $attrs, $text) = @_;
    $text =~ s/\\s-?\d//g;
    $text = $self->heading_common ($text, $$attrs{start_line});
    my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
    $self->output ($self->switchquotes ('.SH', $self->mapfonts ($text)));
    $self->outindex ('Header', $text) unless $isname;
    $$self{NEEDSPACE} = 0;
    $$self{IN_NAME} = $isname;
    return '';
}

# Second level heading.
sub cmd_head2 {
    my ($self, $attrs, $text) = @_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->output ($self->switchquotes ('.SS', $self->mapfonts ($text)));
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 0;
    return '';
}

# Third level heading.  *roff doesn't have this concept, so just put the
# heading in italics as a normal paragraph.
sub cmd_head3 {
    my ($self, $attrs, $text) = @_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ('\f(IS' . $text . '\f(IE') . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

# Fourth level heading.  *roff doesn't have this concept, so just put the
# heading as a normal paragraph.
sub cmd_head4 {
    my ($self, $attrs, $text) = @_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ($text) . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

##############################################################################
# Formatting codes
##############################################################################

# All of the formatting codes that aren't handled internally by the parser,
# other than L<> and X<>.
sub cmd_b { return $_[0]->{IN_NAME} ? $_[2] : '\f(BS' . $_[2] . '\f(BE' }
sub cmd_i { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
sub cmd_f { return $_[0]->{IN_NAME} ? $_[2] : '\f(IS' . $_[2] . '\f(IE' }
sub cmd_c { return $_[0]->quote_literal ($_[2]) }

# Index entries are just added to the pending entries.
sub cmd_x {
    my ($self, $attrs, $text) = @_;
    push (@{ $$self{INDEX} }, $text);
    return '';
}

# Links reduce to the text that we're given, wrapped in angle brackets if it's
# a URL, followed by the URL.  We take an option to suppress the URL if anchor
# text is given.  We need to format the "to" value of the link before
# comparing it to the text since we may escape hyphens.
sub cmd_l {
    my ($self, $attrs, $text) = @_;
    if ($$attrs{type} eq 'url') {
        my $to = $$attrs{to};
        if (defined $to) {
            my $tag = $$self{PENDING}[-1];
            $to = $self->format_text ($$tag[1], $to);
        }
        if (not defined ($to) or $to eq $text) {
            return "<$text>";
        } elsif ($$self{nourls}) {
            return $text;
        } else {
            return "$text <$$attrs{to}>";
        }
    } else {
        return $text;
    }
}

##############################################################################
# List handling
##############################################################################

# Handle the beginning of an =over block.  Takes the type of the block as the
# first argument, and then the attr hash.  This is called by the handlers for
# the four different types of lists (bullet, number, text, and block).
sub over_common_start {
    my ($self, $type, $attrs) = @_;
    my $line = $$attrs{start_line};
    my $indent = $$attrs{indent};
    DEBUG > 3 and print " Starting =over $type (line $line, indent ",
        ($indent || '?'), "\n";

    # Find the indentation level.
    unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
        $indent = $$self{indent};
    }

    # If we've gotten multiple indentations in a row, we need to emit the
    # pending indentation for the last level that we saw and haven't acted on
    # yet.  SHIFTS is the stack of indentations that we've actually emitted
    # code for.
    if (@{ $$self{SHIFTS} } < @{ $$self{INDENTS} }) {
        $self->output (".RS $$self{INDENT}\n");
        push (@{ $$self{SHIFTS} }, $$self{INDENT});
    }

    # Now, do record-keeping.  INDENTS is a stack of indentations that we've
    # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
    # is a stack of list types that we've seen.
    push (@{ $$self{INDENTS} }, $$self{INDENT});
    push (@{ $$self{ITEMTYPES} }, $type);
    $$self{INDENT} = $indent + 0;
    $$self{SHIFTWAIT} = 1;
}

# End an =over block.  Takes no options other than the class pointer.
# Normally, once we close a block and therefore remove something from INDENTS,
# INDENTS will now be longer than SHIFTS, indicating that we also need to emit
# *roff code to close the indent.  This isn't *always* true, depending on the
# circumstance.  If we're still inside an indentation, we need to emit another
# .RE and then a new .RS to unconfuse *roff.
sub over_common_end {
    my ($self) = @_;
    DEBUG > 3 and print " Ending =over\n";
    $$self{INDENT} = pop @{ $$self{INDENTS} };
    pop @{ $$self{ITEMTYPES} };

    # If we emitted code for that indentation, end it.
    if (@{ $$self{SHIFTS} } > @{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @{ $$self{SHIFTS} };
    }

    # If we're still in an indentation, *roff will have now lost track of the
    # right depth of that indentation, so fix that.
    if (@{ $$self{INDENTS} } > 0) {
        $self->output (".RE\n");
        $self->output (".RS $$self{INDENT}\n");
    }
    $$self{NEEDSPACE} = 1;
    $$self{SHIFTWAIT} = 0;
}

# Dispatch the start and end calls as appropriate.
sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @_) }
sub start_over_number { my $s = shift; $s->over_common_start ('number', @_) }
sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @_) }
sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @_) }
sub end_over_bullet { $_[0]->over_common_end }
sub end_over_number { $_[0]->over_common_end }
sub end_over_text   { $_[0]->over_common_end }
sub end_over_block  { $_[0]->over_common_end }

# The common handler for all item commands.  Takes the type of the item, the
# attributes, and then the text of the item.
#
# Emit an index entry for anything that's interesting, but don't emit index
# entries for things like bullets and numbers.  Newlines in an item title are
# turned into spaces since *roff can't handle them embedded.
sub item_common {
    my ($self, $type, $attrs, $text) = @_;
    my $line = $$attrs{start_line};
    DEBUG > 3 and print "  $type item (line $line): $text\n";

    # Clean up the text.  We want to end up with two variables, one ($text)
    # which contains any body text after taking out the item portion, and
    # another ($item) which contains the actual item text.
    $text =~ s/\s+$//;
    my ($item, $index);
    if ($type eq 'bullet') {
        $item = "\\\(bu";
        $text =~ s/\n*$/\n/;
    } elsif ($type eq 'number') {
        $item = $$attrs{number} . '.';
    } else {
        $item = $text;
        $item =~ s/\s*\n\s*/ /g;
        $text = '';
        $index = $item if ($item =~ /\w/);
    }

    # Take care of the indentation.  If shifts and indents are equal, close
    # the top shift, since we're about to create an indentation with .IP.
    # Also output .PD 0 to turn off spacing between items if this item is
    # directly following another one.  We only have to do that once for a
    # whole chain of items so do it for the second item in the change.  Note
    # that makespace is what undoes this.
    if (@{ $$self{SHIFTS} } == @{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @{ $$self{SHIFTS} };
    }
    $self->output (".PD 0\n") if ($$self{ITEMS} == 1);

    # Now, output the item tag itself.
    $item = $self->textmapfonts ($item);
    $self->output ($self->switchquotes ('.IP', $item, $$self{INDENT}));
    $$self{NEEDSPACE} = 0;
    $$self{ITEMS}++;
    $$self{SHIFTWAIT} = 0;

    # If body text for this item was included, go ahead and output that now.
    if ($text) {
        $text =~ s/\s*$/\n/;
        $self->makespace;
        $self->output ($self->protect ($self->textmapfonts ($text)));
        $$self{NEEDSPACE} = 1;
    }
    $self->outindex ($index ? ('Item', $index) : ());
}

# Dispatch the item commands to the appropriate place.
sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @_) }
sub cmd_item_number { my $self = shift; $self->item_common ('number', @_) }
sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @_) }
sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @_) }

##############################################################################
# Backward compatibility
##############################################################################

# Reset the underlying Pod::Simple object between calls to parse_from_file so
# that the same object can be reused to convert multiple pages.
sub parse_from_file {
    my $self = shift;
    $self->reinit;

    # Fake the old cutting option to Pod::Parser.  This fiddings with internal
    # Pod::Simple state and is quite ugly; we need a better approach.
    if (ref ($_[0]) eq 'HASH') {
        my $opts = shift @_;
        if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
            $$self{in_pod} = 1;
            $$self{last_was_blank} = 1;
        }
    }

    # Do the work.
    my $retval = $self->SUPER::parse_from_file (@_);

    # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
    # close the file descriptor if we had to open one, but we can't easily
    # figure this out.
    my $fh = $self->output_fh ();
    my $oldfh = select $fh;
    my $oldflush = $|;
    $| = 1;
    print $fh '';
    $| = $oldflush;
    select $oldfh;
    return $retval;
}

# Pod::Simple failed to provide this backward compatibility function, so
# implement it ourselves.  File handles are one of the inputs that
# parse_from_file supports.
sub parse_from_filehandle {
    my $self = shift;
    return $self->parse_from_file (@_);
}

# Pod::Simple's parse_file doesn't set output_fh.  Wrap the call and do so
# ourself unless it was already set by the caller, since our documentation has
# always said that this should work.
sub parse_file {
    my ($self, $in) = @_;
    unless (defined $$self{output_fh}) {
        $self->output_fh (\*STDOUT);
    }
    return $self->SUPER::parse_file ($in);
}

# Do the same for parse_lines, just to be polite.  Pod::Simple's man page
# implies that the caller is responsible for setting this, but I don't see any
# reason not to set a default.
sub parse_lines {
    my ($self, @lines) = @_;
    unless (defined $$self{output_fh}) {
        $self->output_fh (\*STDOUT);
    }
    return $self->SUPER::parse_lines (@lines);
}

# Likewise for parse_string_document.
sub parse_string_document {
    my ($self, $doc) = @_;
    unless (defined $$self{output_fh}) {
        $self->output_fh (\*STDOUT);
    }
    return $self->SUPER::parse_string_document ($doc);
}

##############################################################################
# Translation tables
##############################################################################

# The following table is adapted from Tom Christiansen's pod2man.  It assumes
# that the standard preamble has already been printed, since that's what
# defines all of the accent marks.  We really want to do something better than
# this when *roff actually supports other character sets itself, since these
# results are pretty poor.
#
# This only works in an ASCII world.  What to do in a non-ASCII world is very
# unclear -- hopefully we can assume UTF-8 and just leave well enough alone.
@ESCAPES{0xA0 .. 0xFF} = (
    "\\ ", undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, "\\%", undef, undef,

    undef, undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, undef, undef, undef,

    "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(Ae", "C\\*,",
    "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",

    "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
    "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",

    "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
    "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",

    "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
    "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
) if ASCII;

##############################################################################
# Premable
##############################################################################

# The following is the static preamble which starts all *roff output we
# generate.  Most is static except for the font to use as a fixed-width font,
# which is designed by @CFONT@, and the left and right quotes to use for C<>
# text, designated by @LQOUTE@ and @RQUOTE@.  However, the second part, which
# defines the accent marks, is only used if $escapes is set to true.
sub preamble_template {
    my ($self, $accents) = @_;
    my $preamble = <<'----END OF PREAMBLE----';
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft @CFONT@
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` @LQUOTE@
.    ds C' @RQUOTE@
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
----END OF PREAMBLE----
#'# for cperl-mode

    if ($accents) {
        $preamble .= <<'----END OF PREAMBLE----'
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
----END OF PREAMBLE----
#`# for cperl-mode
    }
    return $preamble;
}

##############################################################################
# Module return value and documentation
##############################################################################

1;
__END__

=for stopwords
en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8
UTF-8 Allbery Sean Burke Ossanna Solaris formatters troff uppercased
Christiansen nourls parsers

=head1 NAME

Pod::Man - Convert POD data to formatted *roff input

=head1 SYNOPSIS

    use Pod::Man;
    my $parser = Pod::Man->new (release => $VERSION, section => 8);

    # Read POD from STDIN and write to STDOUT.
    $parser->parse_file (\*STDIN);

    # Read POD from file.pod and write to file.1.
    $parser->parse_from_file ('file.pod', 'file.1');

=head1 DESCRIPTION

Pod::Man is a module to convert documentation in the POD format (the
preferred language for documenting Perl) into *roff input using the man
macro set.  The resulting *roff code is suitable for display on a terminal
using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
It is conventionally invoked using the driver script B<pod2man>, but it can
also be used directly.

As a derived class from Pod::Simple, Pod::Man supports the same methods and
interfaces.  See L<Pod::Simple> for all the details.

new() can take options, in the form of key/value pairs that control the
behavior of the parser.  See below for details.

If no options are given, Pod::Man uses the name of the input file with any
trailing C<.pod>, C<.pm>, or C<.pl> stripped as the man page title, to
section 1 unless the file ended in C<.pm> in which case it defaults to
section 3, to a centered title of "User Contributed Perl Documentation", to
a centered footer of the Perl version it is run with, and to a left-hand
footer of the modification date of its input (or the current date if given
C<STDIN> for input).

Pod::Man assumes that your *roff formatters have a fixed-width font named
C<CW>.  If yours is called something else (like C<CR>), use the C<fixed>
option to specify it.  This generally only matters for troff output for
printing.  Similarly, you can set the fonts used for bold, italic, and
bold italic fixed-width output.

Besides the obvious pod conversions, Pod::Man also takes care of
formatting func(), func(3), and simple variable references like $foo or
@bar so you don't have to use code escapes for them; complex expressions
like C<$fred{'stuff'}> will still need to be escaped, though.  It also
translates dashes that aren't used as hyphens into en dashes, makes long
dashes--like this--into proper em dashes, fixes "paired quotes," makes C++
look right, puts a little space between double underscores, makes ALLCAPS
a teeny bit smaller in B<troff>, and escapes stuff that *roff treats as
special so that you don't have to.

The recognized options to new() are as follows.  All options take a single
argument.

=over 4

=item center

Sets the centered page header to use instead of "User Contributed Perl
Documentation".

=item date

Sets the left-hand footer.  If this option is not set, the contents of the
environment variable POD_MAN_DATE, if set, will be used.  Failing that,
the modification date of the input file will be used, or the current time
if stat() can't find that file (which will be the case if the input is
from C<STDIN>).  If obtained from the file modification date or the
current time, he date will be formatted as C<YYYY-MM-DD>.

=item errors

How to report errors.  C<die> says to throw an exception on any POD
formatting error.  C<stderr> says to report errors on standard error, but
not to throw an exception.  C<pod> says to include a POD ERRORS section
in the resulting documentation summarizing the errors.  C<none> ignores
POD errors entirely, as much as possible.

The default is C<pod>.

=item fixed

The fixed-width font to use for verbatim text and code.  Defaults to
C<CW>.  Some systems may want C<CR> instead.  Only matters for B<troff>
output.

=item fixedbold

Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
for B<troff> output.

=item fixeditalic

Italic version of the fixed-width font (actually, something of a misnomer,
since most fixed-width fonts only have an oblique version, not an italic
version).  Defaults to C<CI>.  Only matters for B<troff> output.

=item fixedbolditalic

Bold italic (probably actually oblique) version of the fixed-width font.
Pod::Man doesn't assume you have this, and defaults to C<CB>.  Some
systems (such as Solaris) have this font available as C<CX>.  Only matters
for B<troff> output.

=item name

Set the name of the manual page.  Without this option, the manual name is
set to the uppercased base name of the file being converted unless the
manual section is 3, in which case the path is parsed to see if it is a Perl
module path.  If it is, a path like C<.../lib/Pod/Man.pm> is converted into
a name like C<Pod::Man>.  This option, if given, overrides any automatic
determination of the name.

=item nourls

Normally, LZ<><> formatting codes with a URL but anchor text are formatted
to show both the anchor text and the URL.  In other words:

    L<foo|http://example.com/>

is formatted as:

    foo <http://example.com/>

This option, if set to a true value, suppresses the URL when anchor text
is given, so this example would be formatted as just C<foo>.  This can
produce less cluttered output in cases where the URLs are not particularly
important.

=item quotes

Sets the quote marks used to surround CE<lt>> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.

This may also be set to the special value C<none>, in which case no quote
marks are added around CE<lt>> text (but the font is still changed for troff
output).

=item release

Set the centered footer.  By default, this is the version of Perl you run
Pod::Man under.  Note that some system an macro sets assume that the
centered footer will be a modification date and will prepend something like
"Last modified: "; if this is the case, you may want to set C<release> to
the last modified date and C<date> to the version number.

=item section

Set the section for the C<.TH> macro.  The standard section numbering
convention is to use 1 for user commands, 2 for system calls, 3 for
functions, 4 for devices, 5 for file formats, 6 for games, 7 for
miscellaneous information, and 8 for administrator commands.  There is a lot
of variation here, however; some systems (like Solaris) use 4 for file
formats, 5 for miscellaneous information, and 7 for devices.  Still others
use 1m instead of 8, or some mix of both.  About the only section numbers
that are reliably consistent are 1, 2, and 3.

By default, section 1 will be used unless the file ends in C<.pm> in which
case section 3 will be selected.

=item stderr

Send error messages about invalid POD to standard error instead of
appending a POD ERRORS section to the generated *roff output.  This is
equivalent to setting C<errors> to C<stderr> if C<errors> is not already
set.  It is supported for backward compatibility.

=item utf8

By default, Pod::Man produces the most conservative possible *roff output
to try to ensure that it will work with as many different *roff
implementations as possible.  Many *roff implementations cannot handle
non-ASCII characters, so this means all non-ASCII characters are converted
either to a *roff escape sequence that tries to create a properly accented
character (at least for troff output) or to C<X>.

If this option is set, Pod::Man will instead output UTF-8.  If your *roff
implementation can handle it, this is the best output format to use and
avoids corruption of documents containing non-ASCII characters.  However,
be warned that *roff source with literal UTF-8 characters is not supported
by many implementations and may even result in segfaults and other bad
behavior.

Be aware that, when using this option, the input encoding of your POD
source must be properly declared unless it is US-ASCII or Latin-1.  POD
input without an C<=encoding> command will be assumed to be in Latin-1,
and if it's actually in UTF-8, the output will be double-encoded.  See
L<perlpod(1)> for more information on the C<=encoding> command.

=back

The standard Pod::Simple method parse_file() takes one argument naming the
POD file to read from.  By default, the output is sent to C<STDOUT>, but
this can be changed with the output_fh() method.

The standard Pod::Simple method parse_from_file() takes up to two
arguments, the first being the input file to read POD from and the second
being the file to write the formatted output to.

You can also call parse_lines() to parse an array of lines or
parse_string_document() to parse a document already in memory.  As with
parse_file(), parse_lines() and parse_string_document() default to sending
their output to C<STDOUT> unless changed with the output_fh() method.

To put the output from any parse method into a string instead of a file
handle, call the output_string() method instead of output_fh().

See L<Pod::Simple> for more specific details on the methods available to
all derived parsers.

=head1 DIAGNOSTICS

=over 4

=item roff font should be 1 or 2 chars, not "%s"

(F) You specified a *roff font (using C<fixed>, C<fixedbold>, etc.) that
wasn't either one or two characters.  Pod::Man doesn't support *roff fonts
longer than two characters, although some *roff extensions do (the
canonical versions of B<nroff> and B<troff> don't either).

=item Invalid errors setting "%s"

(F) The C<errors> parameter to the constructor was set to an unknown value.

=item Invalid quote specification "%s"

(F) The quote specification given (the C<quotes> option to the
constructor) was invalid.  A quote specification must be one, two, or four
characters long.

=item POD document had syntax errors

(F) The POD document being formatted had syntax errors and the C<errors>
option was set to C<die>.

=back

=head1 ENVIRONMENT

=over 4

=item POD_MAN_DATE

If set, this will be used as the value of the left-hand footer unless the
C<date> option is explicitly set, overriding the timestamp of the input
file or the current time.  This is primarily useful to ensure reproducible
builds of the same output file given the same souce and Pod::Man version,
even when file timestamps may not be consistent.

=back

=head1 BUGS

Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The C<utf8> option is therefore not supported
unless Perl is built with PerlIO support.

There is currently no way to turn off the guesswork that tries to format
unmarked text appropriately, and sometimes it isn't wanted (particularly
when using POD to document something other than Perl).  Most of the work
toward fixing this has now been done, however, and all that's still needed
is a user interface.

The NAME section should be recognized specially and index entries emitted
for everything in that section.  This would have to be deferred until the
next section, since extraneous things in NAME tends to confuse various man
page processors.  Currently, no index entries are emitted for anything in
NAME.

Pod::Man doesn't handle font names longer than two characters.  Neither do
most B<troff> implementations, but GNU troff does as an extension.  It would
be nice to support as an option for those who want to use it.

The preamble added to each output file is rather verbose, and most of it
is only necessary in the presence of non-ASCII characters.  It would
ideally be nice if all of those definitions were only output if needed,
perhaps on the fly as the characters are used.

Pod::Man is excessively slow.

=head1 CAVEATS

If Pod::Man is given the C<utf8> option, the encoding of its output file
handle will be forced to UTF-8 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Man and was passed in from outside.  This maintains consistency
regardless of PERL_UNICODE and other settings.

The handling of hyphens and em dashes is somewhat fragile, and one may get
the wrong one under some circumstances.  This should only matter for
B<troff> output.

When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
necessarily get it right.

Converting neutral double quotes to properly matched double quotes doesn't
work unless there are no formatting codes between the quote marks.  This
only matters for troff output.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>, based I<very> heavily on the original
B<pod2man> by Tom Christiansen <tchrist@mox.perl.com>.  The modifications to
work with Pod::Simple instead of Pod::Parser were originally contributed by
Sean Burke (but I've since hacked them beyond recognition and all bugs are
mine).

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
2009, 2010, 2012, 2013 Russ Allbery <rra@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
L<man(1)>, L<man(7)>

Ossanna, Joseph F., and Brian W. Kernighan.  "Troff User's Manual,"
Computing Science Technical Report No. 54, AT&T Bell Laboratories.  This is
the best documentation of standard B<nroff> and B<troff>.  At the time of
this writing, it's available at
L<http://www.cs.bell-labs.com/cm/cs/cstr.html>.

The man page documenting the man macro set may be L<man(5)> instead of
L<man(7)> on your system.  Also, please see L<pod2man(1)> for extensive
documentation on writing manual pages if you've not done it before and
aren't familiar with the conventions.

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.

=cut
                                                                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Pod/ParseLink.pm                                                              0100644 0000000 0000000 00000015035 12744441327 015632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Pod::ParseLink -- Parse an L<> formatting code in POD text.
#
# Copyright 2001, 2008, 2009 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This module implements parsing of the text of an L<> formatting code as
# defined in perlpodspec.  It should be suitable for any POD formatter.  It
# exports only one function, parselink(), which returns the five-item parse
# defined in perlpodspec.
#
# Perl core hackers, please note that this module is also separately
# maintained outside of the Perl core as part of the podlators.  Please send
# me any patches at the address above in addition to sending them to the
# standard Perl mailing lists.

##############################################################################
# Modules and declarations
##############################################################################

package Pod::ParseLink;

require 5.004;

use strict;
use vars qw(@EXPORT @ISA $VERSION);

use Exporter;
@ISA    = qw(Exporter);
@EXPORT = qw(parselink);

$VERSION = '1.10';

##############################################################################
# Implementation
##############################################################################

# Parse the name and section portion of a link into a name and section.
sub _parse_section {
    my ($link) = @_;
    $link =~ s/^\s+//;
    $link =~ s/\s+$//;

    # If the whole link is enclosed in quotes, interpret it all as a section
    # even if it contains a slash.
    return (undef, $1) if ($link =~ /^"\s*(.*?)\s*"$/);

    # Split into page and section on slash, and then clean up quoting in the
    # section.  If there is no section and the name contains spaces, also
    # guess that it's an old section link.
    my ($page, $section) = split (/\s*\/\s*/, $link, 2);
    $section =~ s/^"\s*(.*?)\s*"$/$1/ if $section;
    if ($page && $page =~ / / && !defined ($section)) {
        $section = $page;
        $page = undef;
    } else {
        $page = undef unless $page;
        $section = undef unless $section;
    }
    return ($page, $section);
}

# Infer link text from the page and section.
sub _infer_text {
    my ($page, $section) = @_;
    my $inferred;
    if ($page && !$section) {
        $inferred = $page;
    } elsif (!$page && $section) {
        $inferred = '"' . $section . '"';
    } elsif ($page && $section) {
        $inferred = '"' . $section . '" in ' . $page;
    }
    return $inferred;
}

# Given the contents of an L<> formatting code, parse it into the link text,
# the possibly inferred link text, the name or URL, the section, and the type
# of link (pod, man, or url).
sub parselink {
    my ($link) = @_;
    $link =~ s/\s+/ /g;
    my $text;
    if ($link =~ /\|/) {
        ($text, $link) = split (/\|/, $link, 2);
    }
    if ($link =~ /\A\w+:[^:\s]\S*\Z/) {
        my $inferred;
        if (defined ($text) && length ($text) > 0) {
            return ($text, $text, $link, undef, 'url');
        } else {
            return ($text, $link, $link, undef, 'url');
        }
    } else {
        my ($name, $section) = _parse_section ($link);
        my $inferred;
        if (defined ($text) && length ($text) > 0) {
            $inferred = $text;
        } else {
            $inferred = _infer_text ($name, $section);
        }
        my $type = ($name && $name =~ /\(\S*\)/) ? 'man' : 'pod';
        return ($text, $inferred, $name, $section, $type);
    }
}

##############################################################################
# Module return value and documentation
##############################################################################

# Ensure we evaluate to true.
1;
__END__

=head1 NAME

Pod::ParseLink - Parse an LE<lt>E<gt> formatting code in POD text

=for stopwords
markup Allbery URL

=head1 SYNOPSIS

    use Pod::ParseLink;
    my ($text, $inferred, $name, $section, $type) = parselink ($link);

=head1 DESCRIPTION

This module only provides a single function, parselink(), which takes the
text of an LE<lt>E<gt> formatting code and parses it.  It returns the
anchor text for the link (if any was given), the anchor text possibly
inferred from the name and section, the name or URL, the section if any,
and the type of link.  The type will be one of C<url>, C<pod>, or C<man>,
indicating a URL, a link to a POD page, or a link to a Unix manual page.

Parsing is implemented per L<perlpodspec>.  For backward compatibility,
links where there is no section and name contains spaces, or links where the
entirety of the link (except for the anchor text if given) is enclosed in
double-quotes are interpreted as links to a section (LE<lt>/sectionE<gt>).

The inferred anchor text is implemented per L<perlpodspec>:

    L<name>         =>  L<name|name>
    L</section>     =>  L<"section"|/section>
    L<name/section> =>  L<"section" in name|name/section>

The name may contain embedded EE<lt>E<gt> and ZE<lt>E<gt> formatting codes,
and the section, anchor text, and inferred anchor text may contain any
formatting codes.  Any double quotes around the section are removed as part
of the parsing, as is any leading or trailing whitespace.

If the text of the LE<lt>E<gt> escape is entirely enclosed in double
quotes, it's interpreted as a link to a section for backward
compatibility.

No attempt is made to resolve formatting codes.  This must be done after
calling parselink() (since EE<lt>E<gt> formatting codes can be used to
escape characters that would otherwise be significant to the parser and
resolving them before parsing would result in an incorrect parse of a
formatting code like:

    L<verticalE<verbar>barE<sol>slash>

which should be interpreted as a link to the C<vertical|bar/slash> POD page
and not as a link to the C<slash> section of the C<bar> POD page with an
anchor text of C<vertical>.  Note that not only the anchor text will need to
have formatting codes expanded, but so will the target of the link (to deal
with EE<lt>E<gt> and ZE<lt>E<gt> formatting codes), and special handling of
the section may be necessary depending on whether the translator wants to
consider markup in sections to be significant when resolving links.  See
L<perlpodspec> for more information.

=head1 SEE ALSO

L<Pod::Parser>

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/podlators/>.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>.

=head1 COPYRIGHT AND LICENSE

Copyright 2001, 2008, 2009 Russ Allbery <rra@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/Pod/ParseUtils.pm                                                             0100644 0000000 0000000 00000051266 12744441327 016043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #############################################################################
# Pod/ParseUtils.pm -- helpers for POD parsing and conversion
#
# Copyright (C) 1999-2000 by Marek Rouchal. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::ParseUtils;
use strict;

use vars qw($VERSION);
$VERSION = '1.62'; ## Current version of this package
require  5.005;    ## requires this Perl version or later

=head1 NAME

Pod::ParseUtils - helpers for POD parsing and conversion

=head1 SYNOPSIS

  use Pod::ParseUtils;

  my $list = new Pod::List;
  my $link = Pod::Hyperlink->new('Pod::Parser');

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

B<Pod::ParseUtils> contains a few object-oriented helper packages for
POD parsing and processing (i.e. in POD formatters and translators).

=cut

#-----------------------------------------------------------------------------
# Pod::List
#
# class to hold POD list info (=over, =item, =back)
#-----------------------------------------------------------------------------

package Pod::List;

use Carp;

=head2 Pod::List

B<Pod::List> can be used to hold information about POD lists
(written as =over ... =item ... =back) for further processing.
The following methods are available:

=over 4

=item Pod::List-E<gt>new()

Create a new list object. Properties may be specified through a hash
reference like this:

  my $list = Pod::List->new({ -start => $., -indent => 4 });

See the individual methods/properties for details.

=cut

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my %params = @_;
    my $self = {%params};
    bless $self, $class;
    $self->initialize();
    return $self;
}

sub initialize {
    my $self = shift;
    $self->{-file} ||= 'unknown';
    $self->{-start} ||= 'unknown';
    $self->{-indent} ||= 4; # perlpod: "should be the default"
    $self->{_items} = [];
    $self->{-type} ||= '';
}

=item $list-E<gt>file()

Without argument, retrieves the file name the list is in. This must
have been set before by either specifying B<-file> in the B<new()>
method or by calling the B<file()> method with a scalar argument.

=cut

# The POD file name the list appears in
sub file {
   return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
}

=item $list-E<gt>start()

Without argument, retrieves the line number where the list started.
This must have been set before by either specifying B<-start> in the
B<new()> method or by calling the B<start()> method with a scalar
argument.

=cut

# The line in the file the node appears
sub start {
   return (@_ > 1) ? ($_[0]->{-start} = $_[1]) : $_[0]->{-start};
}

=item $list-E<gt>indent()

Without argument, retrieves the indent level of the list as specified
in C<=over n>. This must have been set before by either specifying
B<-indent> in the B<new()> method or by calling the B<indent()> method
with a scalar argument.

=cut

# indent level
sub indent {
   return (@_ > 1) ? ($_[0]->{-indent} = $_[1]) : $_[0]->{-indent};
}

=item $list-E<gt>type()

Without argument, retrieves the list type, which can be an arbitrary value,
e.g. C<OL>, C<UL>, ... when thinking the HTML way.
This must have been set before by either specifying
B<-type> in the B<new()> method or by calling the B<type()> method
with a scalar argument.

=cut

# The type of the list (UL, OL, ...)
sub type {
   return (@_ > 1) ? ($_[0]->{-type} = $_[1]) : $_[0]->{-type};
}

=item $list-E<gt>rx()

Without argument, retrieves a regular expression for simplifying the 
individual item strings once the list type has been determined. Usage:
E.g. when converting to HTML, one might strip the leading number in
an ordered list as C<E<lt>OLE<gt>> already prints numbers itself.
This must have been set before by either specifying
B<-rx> in the B<new()> method or by calling the B<rx()> method
with a scalar argument.

=cut

# The regular expression to simplify the items
sub rx {
   return (@_ > 1) ? ($_[0]->{-rx} = $_[1]) : $_[0]->{-rx};
}

=item $list-E<gt>item()

Without argument, retrieves the array of the items in this list.
The items may be represented by any scalar.
If an argument has been given, it is pushed on the list of items.

=cut

# The individual =items of this list
sub item {
    my ($self,$item) = @_;
    if(defined $item) {
        push(@{$self->{_items}}, $item);
        return $item;
    }
    else {
        return @{$self->{_items}};
    }
}

=item $list-E<gt>parent()

Without argument, retrieves information about the parent holding this
list, which is represented as an arbitrary scalar.
This must have been set before by either specifying
B<-parent> in the B<new()> method or by calling the B<parent()> method
with a scalar argument.

=cut

# possibility for parsers/translators to store information about the
# lists's parent object
sub parent {
   return (@_ > 1) ? ($_[0]->{-parent} = $_[1]) : $_[0]->{-parent};
}

=item $list-E<gt>tag()

Without argument, retrieves information about the list tag, which can be
any scalar.
This must have been set before by either specifying
B<-tag> in the B<new()> method or by calling the B<tag()> method
with a scalar argument.

=back

=cut

# possibility for parsers/translators to store information about the
# list's object
sub tag {
   return (@_ > 1) ? ($_[0]->{-tag} = $_[1]) : $_[0]->{-tag};
}

#-----------------------------------------------------------------------------
# Pod::Hyperlink
#
# class to manipulate POD hyperlinks (L<>)
#-----------------------------------------------------------------------------

package Pod::Hyperlink;

=head2 Pod::Hyperlink

B<Pod::Hyperlink> is a class for manipulation of POD hyperlinks. Usage:

  my $link = Pod::Hyperlink->new('alternative text|page/"section in page"');

The B<Pod::Hyperlink> class is mainly designed to parse the contents of the
C<LE<lt>...E<gt>> sequence, providing a simple interface for accessing the
different parts of a POD hyperlink for further processing. It can also be
used to construct hyperlinks.

=over 4

=item Pod::Hyperlink-E<gt>new()

The B<new()> method can either be passed a set of key/value pairs or a single
scalar value, namely the contents of a C<LE<lt>...E<gt>> sequence. An object
of the class C<Pod::Hyperlink> is returned. The value C<undef> indicates a
failure, the error message is stored in C<$@>.

=cut

use Carp;

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = +{};
    bless $self, $class;
    $self->initialize();
    if(defined $_[0]) {
        if(ref($_[0])) {
            # called with a list of parameters
            %$self = %{$_[0]};
            $self->_construct_text();
        }
        else {
            # called with L<> contents
            return unless($self->parse($_[0]));
        }
    }
    return $self;
}

sub initialize {
    my $self = shift;
    $self->{-line} ||= 'undef';
    $self->{-file} ||= 'undef';
    $self->{-page} ||= '';
    $self->{-node} ||= '';
    $self->{-alttext} ||= '';
    $self->{-type} ||= 'undef';
    $self->{_warnings} = [];
}

=item $link-E<gt>parse($string)

This method can be used to (re)parse a (new) hyperlink, i.e. the contents
of a C<LE<lt>...E<gt>> sequence. The result is stored in the current object.
Warnings are stored in the B<warnings> property.
E.g. sections like C<LE<lt>open(2)E<gt>> are deprecated, as they do not point
to Perl documents. C<LE<lt>DBI::foo(3p)E<gt>> is wrong as well, the manpage
section can simply be dropped.

=cut

sub parse {
    my $self = shift;
    local($_) = $_[0];
    # syntax check the link and extract destination
    my ($alttext,$page,$node,$type,$quoted) = (undef,'','','',0);

    $self->{_warnings} = [];

    # collapse newlines with whitespace
    s/\s*\n+\s*/ /g;

    # strip leading/trailing whitespace
    if(s/^[\s\n]+//) {
        $self->warning('ignoring leading whitespace in link');
    }
    if(s/[\s\n]+$//) {
        $self->warning('ignoring trailing whitespace in link');
    }
    unless(length($_)) {
        _invalid_link('empty link');
        return;
    }

    ## Check for different possibilities. This is tedious and error-prone
    # we match all possibilities (alttext, page, section/item)
    #warn "DEBUG: link=$_\n";

    # only page
    # problem: a lot of people use (), or (1) or the like to indicate
    # man page sections. But this collides with L<func()> that is supposed
    # to point to an internal function...
    my $page_rx = '[\w.-]+(?:::[\w.-]+)*(?:[(](?:\d\w*|)[)]|)';
    # page name only
    if(/^($page_rx)$/o) {
        $page = $1;
        $type = 'page';
    }
    # alttext, page and "section"
    elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*"(.+)"$}o) {
        ($alttext, $page, $node) = ($1, $2, $3);
        $type = 'section';
        $quoted = 1; #... therefore | and / are allowed
    }
    # alttext and page
    elsif(/^(.*?)\s*[|]\s*($page_rx)$/o) {
        ($alttext, $page) = ($1, $2);
        $type = 'page';
    }
    # alttext and "section"
    elsif(m{^(.*?)\s*[|]\s*(?:/\s*|)"(.+)"$}) {
        ($alttext, $node) = ($1,$2);
        $type = 'section';
        $quoted = 1;
    }
    # page and "section"
    elsif(m{^($page_rx)\s*/\s*"(.+)"$}o) {
        ($page, $node) = ($1, $2);
        $type = 'section';
        $quoted = 1;
    }
    # page and item
    elsif(m{^($page_rx)\s*/\s*(.+)$}o) {
        ($page, $node) = ($1, $2);
        $type = 'item';
    }
    # only "section"
    elsif(m{^/?"(.+)"$}) {
        $node = $1;
        $type = 'section';
        $quoted = 1;
    }
    # only item
    elsif(m{^\s*/(.+)$}) {
        $node = $1;
        $type = 'item';
    }

    # non-standard: Hyperlink with alt-text - doesn't remove protocol prefix, maybe it should?
    elsif(/^ \s* (.*?) \s* [|] \s* (\w+:[^:\s] [^\s|]*?) \s* $/ix) {
      ($alttext,$node) = ($1,$2);
      $type = 'hyperlink';
    }

    # non-standard: Hyperlink
    elsif(/^(\w+:[^:\s]\S*)$/i) {
        $node = $1;
        $type = 'hyperlink';
    }
    # alttext, page and item
    elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*(.+)$}o) {
        ($alttext, $page, $node) = ($1, $2, $3);
        $type = 'item';
    }
    # alttext and item
    elsif(m{^(.*?)\s*[|]\s*/(.+)$}) {
        ($alttext, $node) = ($1,$2);
    }
    # must be an item or a "malformed" section (without "")
    else {
        $node = $_;
        $type = 'item';
    }
    # collapse whitespace in nodes
    $node =~ s/\s+/ /gs;

    # empty alternative text expands to node name
    if(defined $alttext) {
        if(!length($alttext)) {
          $alttext = $node || $page;
        }
    }
    else {
        $alttext = '';
    }

    if($page =~ /[(]\w*[)]$/) {
        $self->warning("(section) in '$page' deprecated");
    }
    if(!$quoted && $node =~ m{[|/]} && $type ne 'hyperlink') {
        $self->warning("node '$node' contains non-escaped | or /");
    }
    if($alttext =~ m{[|/]}) {
        $self->warning("alternative text '$node' contains non-escaped | or /");
    }
    $self->{-page} = $page;
    $self->{-node} = $node;
    $self->{-alttext} = $alttext;
    #warn "DEBUG: page=$page section=$section item=$item alttext=$alttext\n";
    $self->{-type} = $type;
    $self->_construct_text();
    1;
}

sub _construct_text {
    my $self = shift;
    my $alttext = $self->alttext();
    my $type = $self->type();
    my $section = $self->node();
    my $page = $self->page();
    my $page_ext = '';
    $page =~ s/([(]\w*[)])$// && ($page_ext = $1);
    if($alttext) {
        $self->{_text} = $alttext;
    }
    elsif($type eq 'hyperlink') {
        $self->{_text} = $section;
    }
    else {
        $self->{_text} = ($section || '') .
            (($page && $section) ? ' in ' : '') .
            "$page$page_ext";
    }
    # for being marked up later
    # use the non-standard markers P<> and Q<>, so that the resulting
    # text can be parsed by the translators. It's their job to put
    # the correct hypertext around the linktext
    if($alttext) {
        $self->{_markup} = "Q<$alttext>";
    }
    elsif($type eq 'hyperlink') {
        $self->{_markup} = "Q<$section>";
    }
    else {
        $self->{_markup} = (!$section ? '' : "Q<$section>") .
            ($page ? ($section ? ' in ':'') . "P<$page>$page_ext" : '');
    }
}

=item $link-E<gt>markup($string)

Set/retrieve the textual value of the link. This string contains special
markers C<PE<lt>E<gt>> and C<QE<lt>E<gt>> that should be expanded by the
translator's interior sequence expansion engine to the
formatter-specific code to highlight/activate the hyperlink. The details
have to be implemented in the translator.

=cut

#' retrieve/set markuped text
sub markup {
    return (@_ > 1) ? ($_[0]->{_markup} = $_[1]) : $_[0]->{_markup};
}

=item $link-E<gt>text()

This method returns the textual representation of the hyperlink as above,
but without markers (read only). Depending on the link type this is one of
the following alternatives (the + and * denote the portions of the text
that are marked up):

  +perl+                    L<perl>
  *$|* in +perlvar+         L<perlvar/$|>
  *OPTIONS* in +perldoc+    L<perldoc/"OPTIONS">
  *DESCRIPTION*             L<"DESCRIPTION">

=cut

# The complete link's text
sub text {
    return $_[0]->{_text};
}

=item $link-E<gt>warning()

After parsing, this method returns any warnings encountered during the
parsing process.

=cut

# Set/retrieve warnings
sub warning {
    my $self = shift;
    if(@_) {
        push(@{$self->{_warnings}}, @_);
        return @_;
    }
    return @{$self->{_warnings}};
}

=item $link-E<gt>file()

=item $link-E<gt>line()

Just simple slots for storing information about the line and the file
the link was encountered in. Has to be filled in manually.

=cut

# The line in the file the link appears
sub line {
    return (@_ > 1) ? ($_[0]->{-line} = $_[1]) : $_[0]->{-line};
}

# The POD file name the link appears in
sub file {
    return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
}

=item $link-E<gt>page()

This method sets or returns the POD page this link points to.

=cut

# The POD page the link appears on
sub page {
    if (@_ > 1) {
        $_[0]->{-page} = $_[1];
        $_[0]->_construct_text();
    }
    return $_[0]->{-page};
}

=item $link-E<gt>node()

As above, but the destination node text of the link.

=cut

# The link destination
sub node {
    if (@_ > 1) {
        $_[0]->{-node} = $_[1];
        $_[0]->_construct_text();
    }
    return $_[0]->{-node};
}

=item $link-E<gt>alttext()

Sets or returns an alternative text specified in the link.

=cut

# Potential alternative text
sub alttext {
    if (@_ > 1) {
        $_[0]->{-alttext} = $_[1];
        $_[0]->_construct_text();
    }
    return $_[0]->{-alttext};
}

=item $link-E<gt>type()

The node type, either C<section> or C<item>. As an unofficial type,
there is also C<hyperlink>, derived from e.g. C<LE<lt>http://perl.comE<gt>>

=cut

# The type: item or headn
sub type {
    return (@_ > 1) ? ($_[0]->{-type} = $_[1]) : $_[0]->{-type};
}

=item $link-E<gt>link()

Returns the link as contents of C<LE<lt>E<gt>>. Reciprocal to B<parse()>.

=back

=cut

# The link itself
sub link {
    my $self = shift;
    my $link = $self->page() || '';
    if($self->node()) {
        my $node = $self->node();
        $node =~ s/\|/E<verbar>/g;
        $node =~ s{/}{E<sol>}g;
        if($self->type() eq 'section') {
            $link .= ($link ? '/' : '') . '"' . $node . '"';
        }
        elsif($self->type() eq 'hyperlink') {
            $link = $self->node();
        }
        else { # item
            $link .= '/' . $node;
        }
    }
    if($self->alttext()) {
        my $text = $self->alttext();
        $text =~ s/\|/E<verbar>/g;
        $text =~ s{/}{E<sol>}g;
        $link = "$text|$link";
    }
    return $link;
}

sub _invalid_link {
    my ($msg) = @_;
    # this sets @_
    #eval { die "$msg\n" };
    #chomp $@;
    $@ = $msg; # this seems to work, too!
    return;
}

#-----------------------------------------------------------------------------
# Pod::Cache
#
# class to hold POD page details
#-----------------------------------------------------------------------------

package Pod::Cache;

=head2 Pod::Cache

B<Pod::Cache> holds information about a set of POD documents,
especially the nodes for hyperlinks.
The following methods are available:

=over 4

=item Pod::Cache-E<gt>new()

Create a new cache object. This object can hold an arbitrary number of
POD documents of class Pod::Cache::Item.

=cut

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = [];
    bless $self, $class;
    return $self;
}

=item $cache-E<gt>item()

Add a new item to the cache. Without arguments, this method returns a
list of all cache elements.

=cut

sub item {
    my ($self,%param) = @_;
    if(%param) {
        my $item = Pod::Cache::Item->new(%param);
        push(@$self, $item);
        return $item;
    }
    else {
        return @{$self};
    }
}

=item $cache-E<gt>find_page($name)

Look for a POD document named C<$name> in the cache. Returns the
reference to the corresponding Pod::Cache::Item object or undef if
not found.

=back

=cut

sub find_page {
    my ($self,$page) = @_;
    foreach(@$self) {
        if($_->page() eq $page) {
            return $_;
        }
    }
    return;
}

package Pod::Cache::Item;

=head2 Pod::Cache::Item

B<Pod::Cache::Item> holds information about individual POD documents,
that can be grouped in a Pod::Cache object.
It is intended to hold information about the hyperlink nodes of POD
documents.
The following methods are available:

=over 4

=item Pod::Cache::Item-E<gt>new()

Create a new object.

=cut

sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my %params = @_;
    my $self = {%params};
    bless $self, $class;
    $self->initialize();
    return $self;
}

sub initialize {
    my $self = shift;
    $self->{-nodes} = [] unless(defined $self->{-nodes});
}

=item $cacheitem-E<gt>page()

Set/retrieve the POD document name (e.g. "Pod::Parser").

=cut

# The POD page
sub page {
   return (@_ > 1) ? ($_[0]->{-page} = $_[1]) : $_[0]->{-page};
}

=item $cacheitem-E<gt>description()

Set/retrieve the POD short description as found in the C<=head1 NAME>
section.

=cut

# The POD description, taken out of NAME if present
sub description {
   return (@_ > 1) ? ($_[0]->{-description} = $_[1]) : $_[0]->{-description};
}

=item $cacheitem-E<gt>path()

Set/retrieve the POD file storage path.

=cut

# The file path
sub path {
   return (@_ > 1) ? ($_[0]->{-path} = $_[1]) : $_[0]->{-path};
}

=item $cacheitem-E<gt>file()

Set/retrieve the POD file name.

=cut

# The POD file name
sub file {
   return (@_ > 1) ? ($_[0]->{-file} = $_[1]) : $_[0]->{-file};
}

=item $cacheitem-E<gt>nodes()

Add a node (or a list of nodes) to the document's node list. Note that
the order is kept, i.e. start with the first node and end with the last.
If no argument is given, the current list of nodes is returned in the
same order the nodes have been added.
A node can be any scalar, but usually is a pair of node string and
unique id for the C<find_node> method to work correctly.

=cut

# The POD nodes
sub nodes {
    my ($self,@nodes) = @_;
    if(@nodes) {
        push(@{$self->{-nodes}}, @nodes);
        return @nodes;
    }
    else {
        return @{$self->{-nodes}};
    }
}

=item $cacheitem-E<gt>find_node($name)

Look for a node or index entry named C<$name> in the object.
Returns the unique id of the node (i.e. the second element of the array
stored in the node array) or undef if not found.

=cut

sub find_node {
    my ($self,$node) = @_;
    my @search;
    push(@search, @{$self->{-nodes}}) if($self->{-nodes});
    push(@search, @{$self->{-idx}}) if($self->{-idx});
    foreach(@search) {
        if($_->[0] eq $node) {
            return $_->[1]; # id
        }
    }
    return;
}

=item $cacheitem-E<gt>idx()

Add an index entry (or a list of them) to the document's index list. Note that
the order is kept, i.e. start with the first node and end with the last.
If no argument is given, the current list of index entries is returned in the
same order the entries have been added.
An index entry can be any scalar, but usually is a pair of string and
unique id.

=back

=cut

# The POD index entries
sub idx {
    my ($self,@idx) = @_;
    if(@idx) {
        push(@{$self->{-idx}}, @idx);
        return @idx;
    }
    else {
        return @{$self->{-idx}};
    }
}

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Marek Rouchal E<lt>marekr@cpan.orgE<gt>, borrowing
a lot of things from L<pod2man> and L<pod2roff> as well as other POD
processing tools by Tom Christiansen, Brad Appleton and Russ Allbery.

B<Pod::ParseUtils> is part of the L<Pod::Parser> distribution.

=head1 SEE ALSO

L<pod2man>, L<pod2roff>, L<Pod::Parser>, L<Pod::Checker>,
L<pod2html>

=cut

1;
                                                                                                                                                                                                                                                                                                                                          usr/share/perl/5.20.2/Pod/Parser.pm                                                                 0100644 0000000 0000000 00000200353 12744441327 015175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #############################################################################
# Pod/Parser.pm -- package which defines a base class for parsing POD docs.
#
# Copyright (C) 1996-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Parser;
use strict;

## These "variables" are used as local "glob aliases" for performance
use vars qw($VERSION @ISA %myData %myOpts @input_stack);
$VERSION = '1.62';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

#############################################################################

=head1 NAME

Pod::Parser - base class for creating POD filters and translators

=head1 SYNOPSIS

    use Pod::Parser;

    package MyParser;
    @ISA = qw(Pod::Parser);

    sub command { 
        my ($parser, $command, $paragraph, $line_num) = @_;
        ## Interpret the command and its text; sample actions might be:
        if ($command eq 'head1') { ... }
        elsif ($command eq 'head2') { ... }
        ## ... other commands and their actions
        my $out_fh = $parser->output_handle();
        my $expansion = $parser->interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num) = @_;
        ## Format verbatim paragraph; sample actions might be:
        my $out_fh = $parser->output_handle();
        print $out_fh $paragraph;
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num) = @_;
        ## Translate/Format this block of text; sample actions might be:
        my $out_fh = $parser->output_handle();
        my $expansion = $parser->interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }

    sub interior_sequence { 
        my ($parser, $seq_command, $seq_argument) = @_;
        ## Expand an interior sequence; sample actions might be:
        return "*$seq_argument*"     if ($seq_command eq 'B');
        return "`$seq_argument'"     if ($seq_command eq 'C');
        return "_${seq_argument}_'"  if ($seq_command eq 'I');
        ## ... other sequence commands and their resulting text
    }

    package main;

    ## Create a parser object and have it parse file whose name was
    ## given on the command-line (use STDIN if no files were given).
    $parser = new MyParser();
    $parser->parse_from_filehandle(\*STDIN)  if (@ARGV == 0);
    for (@ARGV) { $parser->parse_from_file($_); }

=head1 REQUIRES

perl5.005, Pod::InputObjects, Exporter, Symbol, Carp

=head1 EXPORTS

Nothing.

=head1 DESCRIPTION

B<NOTE: This module is considered legacy; modern Perl releases (5.18 and
higher) are going to remove Pod-Parser from core and use L<Pod-Simple>
for all things POD.>

B<Pod::Parser> is a base class for creating POD filters and translators.
It handles most of the effort involved with parsing the POD sections
from an input stream, leaving subclasses free to be concerned only with
performing the actual translation of text.

B<Pod::Parser> parses PODs, and makes method calls to handle the various
components of the POD. Subclasses of B<Pod::Parser> override these methods
to translate the POD into whatever output format they desire.

=head1 QUICK OVERVIEW

To create a POD filter for translating POD documentation into some other
format, you create a subclass of B<Pod::Parser> which typically overrides
just the base class implementation for the following methods:

=over 2

=item *

B<command()>

=item *

B<verbatim()>

=item *

B<textblock()>

=item *

B<interior_sequence()>

=back

You may also want to override the B<begin_input()> and B<end_input()>
methods for your subclass (to perform any needed per-file and/or
per-document initialization or cleanup).

If you need to perform any preprocessing of input before it is parsed
you may want to override one or more of B<preprocess_line()> and/or
B<preprocess_paragraph()>.

Sometimes it may be necessary to make more than one pass over the input
files. If this is the case you have several options. You can make the
first pass using B<Pod::Parser> and override your methods to store the
intermediate results in memory somewhere for the B<end_pod()> method to
process. You could use B<Pod::Parser> for several passes with an
appropriate state variable to control the operation for each pass. If
your input source can't be reset to start at the beginning, you can
store it in some other structure as a string or an array and have that
structure implement a B<getline()> method (which is all that
B<parse_from_filehandle()> uses to read input).

Feel free to add any member data fields you need to keep track of things
like current font, indentation, horizontal or vertical position, or
whatever else you like. Be sure to read L<"PRIVATE METHODS AND DATA">
to avoid name collisions.

For the most part, the B<Pod::Parser> base class should be able to
do most of the input parsing for you and leave you free to worry about
how to interpret the commands and translate the result.

Note that all we have described here in this quick overview is the
simplest most straightforward use of B<Pod::Parser> to do stream-based
parsing. It is also possible to use the B<Pod::Parser::parse_text> function
to do more sophisticated tree-based parsing. See L<"TREE-BASED PARSING">.

=head1 PARSING OPTIONS

A I<parse-option> is simply a named option of B<Pod::Parser> with a
value that corresponds to a certain specified behavior. These various
behaviors of B<Pod::Parser> may be enabled/disabled by setting
or unsetting one or more I<parse-options> using the B<parseopts()> method.
The set of currently accepted parse-options is as follows:

=over 3

=item B<-want_nonPODs> (default: unset)

Normally (by default) B<Pod::Parser> will only provide access to
the POD sections of the input. Input paragraphs that are not part
of the POD-format documentation are not made available to the caller
(not even using B<preprocess_paragraph()>). Setting this option to a
non-empty, non-zero value will allow B<preprocess_paragraph()> to see
non-POD sections of the input as well as POD sections. The B<cutting()>
method can be used to determine if the corresponding paragraph is a POD
paragraph, or some other input paragraph.

=item B<-process_cut_cmd> (default: unset)

Normally (by default) B<Pod::Parser> handles the C<=cut> POD directive
by itself and does not pass it on to the caller for processing. Setting
this option to a non-empty, non-zero value will cause B<Pod::Parser> to
pass the C<=cut> directive to the caller just like any other POD command
(and hence it may be processed by the B<command()> method).

B<Pod::Parser> will still interpret the C<=cut> directive to mean that
"cutting mode" has been (re)entered, but the caller will get a chance
to capture the actual C<=cut> paragraph itself for whatever purpose
it desires.

=item B<-warnings> (default: unset)

Normally (by default) B<Pod::Parser> recognizes a bare minimum of
pod syntax errors and warnings and issues diagnostic messages
for errors, but not for warnings. (Use B<Pod::Checker> to do more
thorough checking of POD syntax.) Setting this option to a non-empty,
non-zero value will cause B<Pod::Parser> to issue diagnostics for
the few warnings it recognizes as well as the errors.

=back

Please see L<"parseopts()"> for a complete description of the interface
for the setting and unsetting of parse-options.

=cut

#############################################################################

#use diagnostics;
use Pod::InputObjects;
use Carp;
use Exporter;
BEGIN {
   if ($] < 5.006) {
      require Symbol;
      import Symbol;
   }
}
@ISA = qw(Exporter);

#############################################################################

=head1 RECOMMENDED SUBROUTINE/METHOD OVERRIDES

B<Pod::Parser> provides several methods which most subclasses will probably
want to override. These methods are as follows:

=cut

##---------------------------------------------------------------------------

=head1 B<command()>

            $parser->command($cmd,$text,$line_num,$pod_para);

This method should be overridden by subclasses to take the appropriate
action when a POD command paragraph (denoted by a line beginning with
"=") is encountered. When such a POD directive is seen in the input,
this method is called and is passed:

=over 3

=item C<$cmd>

the name of the command for this POD paragraph

=item C<$text>

the paragraph text for the given POD paragraph command.

=item C<$line_num>

the line-number of the beginning of the paragraph

=item C<$pod_para>

a reference to a C<Pod::Paragraph> object which contains further
information about the paragraph command (see L<Pod::InputObjects>
for details).

=back

B<Note> that this method I<is> called for C<=pod> paragraphs.

The base class implementation of this method simply treats the raw POD
command as normal block of paragraph text (invoking the B<textblock()>
method with the command paragraph).

=cut

sub command {
    my ($self, $cmd, $text, $line_num, $pod_para)  = @_;
    ## Just treat this like a textblock
    $self->textblock($pod_para->raw_text(), $line_num, $pod_para);
}

##---------------------------------------------------------------------------

=head1 B<verbatim()>

            $parser->verbatim($text,$line_num,$pod_para);

This method may be overridden by subclasses to take the appropriate
action when a block of verbatim text is encountered. It is passed the
following parameters:

=over 3

=item C<$text>

the block of text for the verbatim paragraph

=item C<$line_num>

the line-number of the beginning of the paragraph

=item C<$pod_para>

a reference to a C<Pod::Paragraph> object which contains further
information about the paragraph (see L<Pod::InputObjects>
for details).

=back

The base class implementation of this method simply prints the textblock
(unmodified) to the output filehandle.

=cut

sub verbatim {
    my ($self, $text, $line_num, $pod_para) = @_;
    my $out_fh = $self->{_OUTPUT};
    print $out_fh $text;
}

##---------------------------------------------------------------------------

=head1 B<textblock()>

            $parser->textblock($text,$line_num,$pod_para);

This method may be overridden by subclasses to take the appropriate
action when a normal block of POD text is encountered (although the base
class method will usually do what you want). It is passed the following
parameters:

=over 3

=item C<$text>

the block of text for the a POD paragraph

=item C<$line_num>

the line-number of the beginning of the paragraph

=item C<$pod_para>

a reference to a C<Pod::Paragraph> object which contains further
information about the paragraph (see L<Pod::InputObjects>
for details).

=back

In order to process interior sequences, subclasses implementations of
this method will probably want to invoke either B<interpolate()> or
B<parse_text()>, passing it the text block C<$text>, and the corresponding
line number in C<$line_num>, and then perform any desired processing upon
the returned result.

The base class implementation of this method simply prints the text block
as it occurred in the input stream).

=cut

sub textblock {
    my ($self, $text, $line_num, $pod_para) = @_;
    my $out_fh = $self->{_OUTPUT};
    print $out_fh $self->interpolate($text, $line_num);
}

##---------------------------------------------------------------------------

=head1 B<interior_sequence()>

            $parser->interior_sequence($seq_cmd,$seq_arg,$pod_seq);

This method should be overridden by subclasses to take the appropriate
action when an interior sequence is encountered. An interior sequence is
an embedded command within a block of text which appears as a command
name (usually a single uppercase character) followed immediately by a
string of text which is enclosed in angle brackets. This method is
passed the sequence command C<$seq_cmd> and the corresponding text
C<$seq_arg>. It is invoked by the B<interpolate()> method for each interior
sequence that occurs in the string that it is passed. It should return
the desired text string to be used in place of the interior sequence.
The C<$pod_seq> argument is a reference to a C<Pod::InteriorSequence>
object which contains further information about the interior sequence.
Please see L<Pod::InputObjects> for details if you need to access this
additional information.

Subclass implementations of this method may wish to invoke the 
B<nested()> method of C<$pod_seq> to see if it is nested inside
some other interior-sequence (and if so, which kind).

The base class implementation of the B<interior_sequence()> method
simply returns the raw text of the interior sequence (as it occurred
in the input) to the caller.

=cut

sub interior_sequence {
    my ($self, $seq_cmd, $seq_arg, $pod_seq) = @_;
    ## Just return the raw text of the interior sequence
    return  $pod_seq->raw_text();
}

#############################################################################

=head1 OPTIONAL SUBROUTINE/METHOD OVERRIDES

B<Pod::Parser> provides several methods which subclasses may want to override
to perform any special pre/post-processing. These methods do I<not> have to
be overridden, but it may be useful for subclasses to take advantage of them.

=cut

##---------------------------------------------------------------------------

=head1 B<new()>

            my $parser = Pod::Parser->new();

This is the constructor for B<Pod::Parser> and its subclasses. You
I<do not> need to override this method! It is capable of constructing
subclass objects as well as base class objects, provided you use
any of the following constructor invocation styles:

    my $parser1 = MyParser->new();
    my $parser2 = new MyParser();
    my $parser3 = $parser2->new();

where C<MyParser> is some subclass of B<Pod::Parser>.

Using the syntax C<MyParser::new()> to invoke the constructor is I<not>
recommended, but if you insist on being able to do this, then the
subclass I<will> need to override the B<new()> constructor method. If
you do override the constructor, you I<must> be sure to invoke the
B<initialize()> method of the newly blessed object.

Using any of the above invocations, the first argument to the
constructor is always the corresponding package name (or object
reference). No other arguments are required, but if desired, an
associative array (or hash-table) my be passed to the B<new()>
constructor, as in:

    my $parser1 = MyParser->new( MYDATA => $value1, MOREDATA => $value2 );
    my $parser2 = new MyParser( -myflag => 1 );

All arguments passed to the B<new()> constructor will be treated as
key/value pairs in a hash-table. The newly constructed object will be
initialized by copying the contents of the given hash-table (which may
have been empty). The B<new()> constructor for this class and all of its
subclasses returns a blessed reference to the initialized object (hash-table).

=cut

sub new {
    ## Determine if we were called via an object-ref or a classname
    my ($this,%params) = @_;
    my $class = ref($this) || $this;
    ## Any remaining arguments are treated as initial values for the
    ## hash that is used to represent this object.
    my $self = { %params };
    ## Bless ourselves into the desired class and perform any initialization
    bless $self, $class;
    $self->initialize();
    return $self;
}

##---------------------------------------------------------------------------

=head1 B<initialize()>

            $parser->initialize();

This method performs any necessary object initialization. It takes no
arguments (other than the object instance of course, which is typically
copied to a local variable named C<$self>). If subclasses override this
method then they I<must> be sure to invoke C<$self-E<gt>SUPER::initialize()>.

=cut

sub initialize {
    #my $self = shift;
    #return;
}

##---------------------------------------------------------------------------

=head1 B<begin_pod()>

            $parser->begin_pod();

This method is invoked at the beginning of processing for each POD
document that is encountered in the input. Subclasses should override
this method to perform any per-document initialization.

=cut

sub begin_pod {
    #my $self = shift;
    #return;
}

##---------------------------------------------------------------------------

=head1 B<begin_input()>

            $parser->begin_input();

This method is invoked by B<parse_from_filehandle()> immediately I<before>
processing input from a filehandle. The base class implementation does
nothing, however, subclasses may override it to perform any per-file
initializations.

Note that if multiple files are parsed for a single POD document
(perhaps the result of some future C<=include> directive) this method
is invoked for every file that is parsed. If you wish to perform certain
initializations once per document, then you should use B<begin_pod()>.

=cut

sub begin_input {
    #my $self = shift;
    #return;
}

##---------------------------------------------------------------------------

=head1 B<end_input()>

            $parser->end_input();

This method is invoked by B<parse_from_filehandle()> immediately I<after>
processing input from a filehandle. The base class implementation does
nothing, however, subclasses may override it to perform any per-file
cleanup actions.

Please note that if multiple files are parsed for a single POD document
(perhaps the result of some kind of C<=include> directive) this method
is invoked for every file that is parsed. If you wish to perform certain
cleanup actions once per document, then you should use B<end_pod()>.

=cut

sub end_input {
    #my $self = shift;
    #return;
}

##---------------------------------------------------------------------------

=head1 B<end_pod()>

            $parser->end_pod();

This method is invoked at the end of processing for each POD document
that is encountered in the input. Subclasses should override this method
to perform any per-document finalization.

=cut

sub end_pod {
    #my $self = shift;
    #return;
}

##---------------------------------------------------------------------------

=head1 B<preprocess_line()>

          $textline = $parser->preprocess_line($text, $line_num);

This method should be overridden by subclasses that wish to perform
any kind of preprocessing for each I<line> of input (I<before> it has
been determined whether or not it is part of a POD paragraph). The
parameter C<$text> is the input line; and the parameter C<$line_num> is
the line number of the corresponding text line.

The value returned should correspond to the new text to use in its
place.  If the empty string or an undefined value is returned then no
further processing will be performed for this line.

Please note that the B<preprocess_line()> method is invoked I<before>
the B<preprocess_paragraph()> method. After all (possibly preprocessed)
lines in a paragraph have been assembled together and it has been
determined that the paragraph is part of the POD documentation from one
of the selected sections, then B<preprocess_paragraph()> is invoked.

The base class implementation of this method returns the given text.

=cut

sub preprocess_line {
    my ($self, $text, $line_num) = @_;
    return  $text;
}

##---------------------------------------------------------------------------

=head1 B<preprocess_paragraph()>

            $textblock = $parser->preprocess_paragraph($text, $line_num);

This method should be overridden by subclasses that wish to perform any
kind of preprocessing for each block (paragraph) of POD documentation
that appears in the input stream. The parameter C<$text> is the POD
paragraph from the input file; and the parameter C<$line_num> is the
line number for the beginning of the corresponding paragraph.

The value returned should correspond to the new text to use in its
place If the empty string is returned or an undefined value is
returned, then the given C<$text> is ignored (not processed).

This method is invoked after gathering up all the lines in a paragraph
and after determining the cutting state of the paragraph,
but before trying to further parse or interpret them. After
B<preprocess_paragraph()> returns, the current cutting state (which
is returned by C<$self-E<gt>cutting()>) is examined. If it evaluates
to true then input text (including the given C<$text>) is cut (not
processed) until the next POD directive is encountered.

Please note that the B<preprocess_line()> method is invoked I<before>
the B<preprocess_paragraph()> method. After all (possibly preprocessed)
lines in a paragraph have been assembled together and either it has been
determined that the paragraph is part of the POD documentation from one
of the selected sections or the C<-want_nonPODs> option is true,
then B<preprocess_paragraph()> is invoked.

The base class implementation of this method returns the given text.

=cut

sub preprocess_paragraph {
    my ($self, $text, $line_num) = @_;
    return  $text;
}

#############################################################################

=head1 METHODS FOR PARSING AND PROCESSING

B<Pod::Parser> provides several methods to process input text. These
methods typically won't need to be overridden (and in some cases they
can't be overridden), but subclasses may want to invoke them to exploit
their functionality.

=cut

##---------------------------------------------------------------------------

=head1 B<parse_text()>

            $ptree1 = $parser->parse_text($text, $line_num);
            $ptree2 = $parser->parse_text({%opts}, $text, $line_num);
            $ptree3 = $parser->parse_text(\%opts, $text, $line_num);

This method is useful if you need to perform your own interpolation 
of interior sequences and can't rely upon B<interpolate> to expand
them in simple bottom-up order.

The parameter C<$text> is a string or block of text to be parsed
for interior sequences; and the parameter C<$line_num> is the
line number corresponding to the beginning of C<$text>.

B<parse_text()> will parse the given text into a parse-tree of "nodes."
and interior-sequences.  Each "node" in the parse tree is either a
text-string, or a B<Pod::InteriorSequence>.  The result returned is a
parse-tree of type B<Pod::ParseTree>. Please see L<Pod::InputObjects>
for more information about B<Pod::InteriorSequence> and B<Pod::ParseTree>.

If desired, an optional hash-ref may be specified as the first argument
to customize certain aspects of the parse-tree that is created and
returned. The set of recognized option keywords are:

=over 3

=item B<-expand_seq> =E<gt> I<code-ref>|I<method-name>

Normally, the parse-tree returned by B<parse_text()> will contain an
unexpanded C<Pod::InteriorSequence> object for each interior-sequence
encountered. Specifying B<-expand_seq> tells B<parse_text()> to "expand"
every interior-sequence it sees by invoking the referenced function
(or named method of the parser object) and using the return value as the
expanded result.

If a subroutine reference was given, it is invoked as:

  &$code_ref( $parser, $sequence )

and if a method-name was given, it is invoked as:

  $parser->method_name( $sequence )

where C<$parser> is a reference to the parser object, and C<$sequence>
is a reference to the interior-sequence object.
[I<NOTE>: If the B<interior_sequence()> method is specified, then it is
invoked according to the interface specified in L<"interior_sequence()">].

=item B<-expand_text> =E<gt> I<code-ref>|I<method-name>

Normally, the parse-tree returned by B<parse_text()> will contain a
text-string for each contiguous sequence of characters outside of an
interior-sequence. Specifying B<-expand_text> tells B<parse_text()> to
"preprocess" every such text-string it sees by invoking the referenced
function (or named method of the parser object) and using the return value
as the preprocessed (or "expanded") result. [Note that if the result is
an interior-sequence, then it will I<not> be expanded as specified by the
B<-expand_seq> option; Any such recursive expansion needs to be handled by
the specified callback routine.]

If a subroutine reference was given, it is invoked as:

  &$code_ref( $parser, $text, $ptree_node )

and if a method-name was given, it is invoked as:

  $parser->method_name( $text, $ptree_node )

where C<$parser> is a reference to the parser object, C<$text> is the
text-string encountered, and C<$ptree_node> is a reference to the current
node in the parse-tree (usually an interior-sequence object or else the
top-level node of the parse-tree).

=item B<-expand_ptree> =E<gt> I<code-ref>|I<method-name>

Rather than returning a C<Pod::ParseTree>, pass the parse-tree as an
argument to the referenced subroutine (or named method of the parser
object) and return the result instead of the parse-tree object.

If a subroutine reference was given, it is invoked as:

  &$code_ref( $parser, $ptree )

and if a method-name was given, it is invoked as:

  $parser->method_name( $ptree )

where C<$parser> is a reference to the parser object, and C<$ptree>
is a reference to the parse-tree object.

=back

=cut

sub parse_text {
    my $self = shift;
    local $_ = '';

    ## Get options and set any defaults
    my %opts = (ref $_[0]) ? %{ shift() } : ();
    my $expand_seq   = $opts{'-expand_seq'}   || undef;
    my $expand_text  = $opts{'-expand_text'}  || undef;
    my $expand_ptree = $opts{'-expand_ptree'} || undef;

    my $text = shift;
    my $line = shift;
    my $file = $self->input_file();
    my $cmd  = "";

    ## Convert method calls into closures, for our convenience
    my $xseq_sub   = $expand_seq;
    my $xtext_sub  = $expand_text;
    my $xptree_sub = $expand_ptree;
    if (defined $expand_seq  and  $expand_seq eq 'interior_sequence') {
        ## If 'interior_sequence' is the method to use, we have to pass
        ## more than just the sequence object, we also need to pass the
        ## sequence name and text.
        $xseq_sub = sub {
            my ($sself, $iseq) = @_;
            my $args = join('', $iseq->parse_tree->children);
            return  $sself->interior_sequence($iseq->name, $args, $iseq);
        };
    }
    ref $xseq_sub    or  $xseq_sub   = sub { shift()->$expand_seq(@_) };
    ref $xtext_sub   or  $xtext_sub  = sub { shift()->$expand_text(@_) };
    ref $xptree_sub  or  $xptree_sub = sub { shift()->$expand_ptree(@_) };

    ## Keep track of the "current" interior sequence, and maintain a stack
    ## of "in progress" sequences.
    ##
    ## NOTE that we push our own "accumulator" at the very beginning of the
    ## stack. It's really a parse-tree, not a sequence; but it implements
    ## the methods we need so we can use it to gather-up all the sequences
    ## and strings we parse. Thus, by the end of our parsing, it should be
    ## the only thing left on our stack and all we have to do is return it!
    ##
    my $seq       = Pod::ParseTree->new();
    my @seq_stack = ($seq);
    my ($ldelim, $rdelim) = ('', '');

    ## Iterate over all sequence starts text (NOTE: split with
    ## capturing parens keeps the delimiters)
    $_ = $text;
    my @tokens = split /([A-Z]<(?:<+(?:\r?\n|[ \t]))?)/;
    while ( @tokens ) {
        $_ = shift @tokens;
        ## Look for the beginning of a sequence
        if ( /^([A-Z])(<(?:<+(?:\r?\n|[ \t]))?)$/ ) {
            ## Push a new sequence onto the stack of those "in-progress"
            my $ldelim_orig;
            ($cmd, $ldelim_orig) = ($1, $2);
            ($ldelim = $ldelim_orig) =~ s/\s+$//;
            ($rdelim = $ldelim) =~ tr/</>/;
            $seq = Pod::InteriorSequence->new(
                       -name   => $cmd,
                       -ldelim => $ldelim_orig,  -rdelim => $rdelim,
                       -file   => $file,    -line   => $line
                   );
            (@seq_stack > 1)  and  $seq->nested($seq_stack[-1]);
            push @seq_stack, $seq;
        }
        ## Look for sequence ending
        elsif ( @seq_stack > 1 ) {
            ## Make sure we match the right kind of closing delimiter
            my ($seq_end, $post_seq) = ('', '');
            if ( ($ldelim eq '<'   and  /\A(.*?)(>)/s)
                 or  /\A(.*?)(\s+$rdelim)/s )
            {
                ## Found end-of-sequence, capture the interior and the
                ## closing the delimiter, and put the rest back on the
                ## token-list
                $post_seq = substr($_, length($1) + length($2));
                ($_, $seq_end) = ($1, $2);
                (length $post_seq)  and  unshift @tokens, $post_seq;
            }
            if (length) {
                ## In the middle of a sequence, append this text to it, and
                ## don't forget to "expand" it if that's what the caller wanted
                $seq->append($expand_text ? &$xtext_sub($self,$_,$seq) : $_);
                $_ .= $seq_end;
            }
            if (length $seq_end) {
                ## End of current sequence, record terminating delimiter
                $seq->rdelim($seq_end);
                ## Pop it off the stack of "in progress" sequences
                pop @seq_stack;
                ## Append result to its parent in current parse tree
                $seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq)
                                                   : $seq);
                ## Remember the current cmd-name and left-delimiter
                if(@seq_stack > 1) {
                    $cmd = $seq_stack[-1]->name;
                    $ldelim = $seq_stack[-1]->ldelim;
                    $rdelim = $seq_stack[-1]->rdelim;
                } else {
                    $cmd = $ldelim = $rdelim = '';
                }
            }
        }
        elsif (length) {
            ## In the middle of a sequence, append this text to it, and
            ## don't forget to "expand" it if that's what the caller wanted
            $seq->append($expand_text ? &$xtext_sub($self,$_,$seq) : $_);
        }
        ## Keep track of line count
        $line += /\n/;
        ## Remember the "current" sequence
        $seq = $seq_stack[-1];
    }

    ## Handle unterminated sequences
    my $errorsub = (@seq_stack > 1) ? $self->errorsub() : undef;
    while (@seq_stack > 1) {
       ($cmd, $file, $line) = ($seq->name, $seq->file_line);
       $ldelim  = $seq->ldelim;
       ($rdelim = $ldelim) =~ tr/</>/;
       $rdelim  =~ s/^(\S+)(\s*)$/$2$1/;
       pop @seq_stack;
       my $errmsg = "*** ERROR: unterminated ${cmd}${ldelim}...${rdelim}".
                    " at line $line in file $file\n";
       (ref $errorsub) and &{$errorsub}($errmsg)
           or (defined $errorsub) and $self->$errorsub($errmsg)
               or  carp($errmsg);
       $seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq) : $seq);
       $seq = $seq_stack[-1];
    }

    ## Return the resulting parse-tree
    my $ptree = (pop @seq_stack)->parse_tree;
    return  $expand_ptree ? &$xptree_sub($self, $ptree) : $ptree;
}

##---------------------------------------------------------------------------

=head1 B<interpolate()>

            $textblock = $parser->interpolate($text, $line_num);

This method translates all text (including any embedded interior sequences)
in the given text string C<$text> and returns the interpolated result. The
parameter C<$line_num> is the line number corresponding to the beginning
of C<$text>.

B<interpolate()> merely invokes a private method to recursively expand
nested interior sequences in bottom-up order (innermost sequences are
expanded first). If there is a need to expand nested sequences in
some alternate order, use B<parse_text> instead.

=cut

sub interpolate {
    my($self, $text, $line_num) = @_;
    my %parse_opts = ( -expand_seq => 'interior_sequence' );
    my $ptree = $self->parse_text( \%parse_opts, $text, $line_num );
    return  join '', $ptree->children();
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head1 B<parse_paragraph()>

            $parser->parse_paragraph($text, $line_num);

This method takes the text of a POD paragraph to be processed, along
with its corresponding line number, and invokes the appropriate method
(one of B<command()>, B<verbatim()>, or B<textblock()>).

For performance reasons, this method is invoked directly without any
dynamic lookup; Hence subclasses may I<not> override it!

=end __PRIVATE__

=cut

sub parse_paragraph {
    my ($self, $text, $line_num) = @_;
    local *myData = $self;  ## alias to avoid deref-ing overhead
    local *myOpts = ($myData{_PARSEOPTS} ||= {});  ## get parse-options
    local $_;

    ## See if we want to preprocess nonPOD paragraphs as well as POD ones.
    my $wantNonPods = $myOpts{'-want_nonPODs'};

    ## Update cutting status
    $myData{_CUTTING} = 0 if $text =~ /^={1,2}\S/;

    ## Perform any desired preprocessing if we wanted it this early
    $wantNonPods  and  $text = $self->preprocess_paragraph($text, $line_num);

    ## Ignore up until next POD directive if we are cutting
    return if $myData{_CUTTING};

    ## Now we know this is block of text in a POD section!

    ##-----------------------------------------------------------------
    ## This is a hook (hack ;-) for Pod::Select to do its thing without
    ## having to override methods, but also without Pod::Parser assuming
    ## $self is an instance of Pod::Select (if the _SELECTED_SECTIONS
    ## field exists then we assume there is an is_selected() method for
    ## us to invoke (calling $self->can('is_selected') could verify this
    ## but that is more overhead than I want to incur)
    ##-----------------------------------------------------------------

    ## Ignore this block if it isn't in one of the selected sections
    if (exists $myData{_SELECTED_SECTIONS}) {
        $self->is_selected($text)  or  return ($myData{_CUTTING} = 1);
    }

    ## If we haven't already, perform any desired preprocessing and
    ## then re-check the "cutting" state
    unless ($wantNonPods) {
       $text = $self->preprocess_paragraph($text, $line_num);
       return 1  unless ((defined $text) and (length $text));
       return 1  if ($myData{_CUTTING});
    }

    ## Look for one of the three types of paragraphs
    my ($pfx, $cmd, $arg, $sep) = ('', '', '', '');
    my $pod_para = undef;
    if ($text =~ /^(={1,2})(?=\S)/) {
        ## Looks like a command paragraph. Capture the command prefix used
        ## ("=" or "=="), as well as the command-name, its paragraph text,
        ## and whatever sequence of characters was used to separate them
        $pfx = $1;
        $_ = substr($text, length $pfx);
        ($cmd, $sep, $text) = split /(\s+)/, $_, 2;
        $sep = '' unless defined $sep;
        $text = '' unless defined $text;
        ## If this is a "cut" directive then we don't need to do anything
        ## except return to "cutting" mode.
        if ($cmd eq 'cut') {
           $myData{_CUTTING} = 1;
           return  unless $myOpts{'-process_cut_cmd'};
        }
    }
    ## Save the attributes indicating how the command was specified.
    $pod_para = new Pod::Paragraph(
          -name      => $cmd,
          -text      => $text,
          -prefix    => $pfx,
          -separator => $sep,
          -file      => $myData{_INFILE},
          -line      => $line_num
    );
    # ## Invoke appropriate callbacks
    # if (exists $myData{_CALLBACKS}) {
    #    ## Look through the callback list, invoke callbacks,
    #    ## then see if we need to do the default actions
    #    ## (invoke_callbacks will return true if we do).
    #    return  1  unless $self->invoke_callbacks($cmd, $text, $line_num, $pod_para);
    # }

    # If the last paragraph ended in whitespace, and we're not between verbatim blocks, carp
    if ($myData{_WHITESPACE} and $myOpts{'-warnings'}
            and not ($text =~ /^\s+/ and ($myData{_PREVIOUS}||"") eq "verbatim")) {
        my $errorsub = $self->errorsub();
        my $line = $line_num - 1;
        my $errmsg = "*** WARNING: line containing nothing but whitespace".
                     " in paragraph at line $line in file $myData{_INFILE}\n";
        (ref $errorsub) and &{$errorsub}($errmsg)
            or (defined $errorsub) and $self->$errorsub($errmsg)
                or  carp($errmsg);
    }

    if (length $cmd) {
        ## A command paragraph
        $self->command($cmd, $text, $line_num, $pod_para);
        $myData{_PREVIOUS} = $cmd;
    }
    elsif ($text =~ /^\s+/) {
        ## Indented text - must be a verbatim paragraph
        $self->verbatim($text, $line_num, $pod_para);
        $myData{_PREVIOUS} = "verbatim";
    }
    else {
        ## Looks like an ordinary block of text
        $self->textblock($text, $line_num, $pod_para);
        $myData{_PREVIOUS} = "textblock";
    }

    # Update the whitespace for the next time around
    #$myData{_WHITESPACE} = $text =~ /^[^\S\r\n]+\Z/m ? 1 : 0;
    $myData{_WHITESPACE} = $text =~ /^[^\S\r\n]+\r*\Z/m ? 1 : 0;

    return  1;
}

##---------------------------------------------------------------------------

=head1 B<parse_from_filehandle()>

            $parser->parse_from_filehandle($in_fh,$out_fh);

This method takes an input filehandle (which is assumed to already be
opened for reading) and reads the entire input stream looking for blocks
(paragraphs) of POD documentation to be processed. If no first argument
is given the default input filehandle C<STDIN> is used.

The C<$in_fh> parameter may be any object that provides a B<getline()>
method to retrieve a single line of input text (hence, an appropriate
wrapper object could be used to parse PODs from a single string or an
array of strings).

Using C<$in_fh-E<gt>getline()>, input is read line-by-line and assembled
into paragraphs or "blocks" (which are separated by lines containing
nothing but whitespace). For each block of POD documentation
encountered it will invoke a method to parse the given paragraph.

If a second argument is given then it should correspond to a filehandle where
output should be sent (otherwise the default output filehandle is
C<STDOUT> if no output filehandle is currently in use).

B<NOTE:> For performance reasons, this method caches the input stream at
the top of the stack in a local variable. Any attempts by clients to
change the stack contents during processing when in the midst executing
of this method I<will not affect> the input stream used by the current
invocation of this method.

This method does I<not> usually need to be overridden by subclasses.

=cut

sub parse_from_filehandle {
    my $self = shift;
    my %opts = (ref $_[0] eq 'HASH') ? %{ shift() } : ();
    my ($in_fh, $out_fh) = @_;
    $in_fh = \*STDIN  unless ($in_fh);
    local *myData = $self;  ## alias to avoid deref-ing overhead
    local *myOpts = ($myData{_PARSEOPTS} ||= {});  ## get parse-options
    local $_;

    ## Put this stream at the top of the stack and do beginning-of-input
    ## processing. NOTE that $in_fh might be reset during this process.
    my $topstream = $self->_push_input_stream($in_fh, $out_fh);
    (exists $opts{-cutting})  and  $self->cutting( $opts{-cutting} );

    ## Initialize line/paragraph
    my ($textline, $paragraph) = ('', '');
    my ($nlines, $plines) = (0, 0);

    ## Use <$fh> instead of $fh->getline where possible (for speed)
    $_ = ref $in_fh;
    my $tied_fh = (/^(?:GLOB|FileHandle|IO::\w+)$/  or  tied $in_fh);

    ## Read paragraphs line-by-line
    while (defined ($textline = $tied_fh ? <$in_fh> : $in_fh->getline)) {
        $textline = $self->preprocess_line($textline, ++$nlines);
        next  unless ((defined $textline)  &&  (length $textline));

        if ((! length $paragraph) && ($textline =~ /^==/)) {
            ## '==' denotes a one-line command paragraph
            $paragraph = $textline;
            $plines    = 1;
            $textline  = '';
        } else {
            ## Append this line to the current paragraph
            $paragraph .= $textline;
            ++$plines;
        }

        ## See if this line is blank and ends the current paragraph.
        ## If it isn't, then keep iterating until it is.
        next unless (($textline =~ /^[^\S\r\n]*[\r\n]*$/)
                                     && (length $paragraph));

        ## Now process the paragraph
        parse_paragraph($self, $paragraph, ($nlines - $plines) + 1);
        $paragraph = '';
        $plines = 0;
    }
    ## Don't forget about the last paragraph in the file
    if (length $paragraph) {
       parse_paragraph($self, $paragraph, ($nlines - $plines) + 1)
    }

    ## Now pop the input stream off the top of the input stack.
    $self->_pop_input_stream();
}

##---------------------------------------------------------------------------

=head1 B<parse_from_file()>

            $parser->parse_from_file($filename,$outfile);

This method takes a filename and does the following:

=over 2

=item *

opens the input and output files for reading
(creating the appropriate filehandles)

=item *

invokes the B<parse_from_filehandle()> method passing it the
corresponding input and output filehandles.

=item *

closes the input and output files.

=back

If the special input filename "", "-" or "<&STDIN" is given then the STDIN
filehandle is used for input (and no open or close is performed). If no
input filename is specified then "-" is implied. Filehandle references,
or objects that support the regular IO operations (like C<E<lt>$fhE<gt>>
or C<$fh-<Egt>getline>) are also accepted; the handles must already be 
opened.

If a second argument is given then it should be the name of the desired
output file. If the special output filename "-" or ">&STDOUT" is given
then the STDOUT filehandle is used for output (and no open or close is
performed). If the special output filename ">&STDERR" is given then the
STDERR filehandle is used for output (and no open or close is
performed). If no output filehandle is currently in use and no output
filename is specified, then "-" is implied.
Alternatively, filehandle references or objects that support the regular
IO operations (like C<print>, e.g. L<IO::String>) are also accepted;
the object must already be opened.

This method does I<not> usually need to be overridden by subclasses.

=cut

sub parse_from_file {
    my $self = shift;
    my %opts = (ref $_[0] eq 'HASH') ? %{ shift() } : ();
    my ($infile, $outfile) = @_;
    my ($in_fh,  $out_fh);
    if ($] < 5.006) {
      ($in_fh,  $out_fh) = (gensym(), gensym());
    }
    my ($close_input, $close_output) = (0, 0);
    local *myData = $self;
    local *_;

    ## Is $infile a filename or a (possibly implied) filehandle
    if (defined $infile && ref $infile) {
        if (ref($infile) =~ /^(SCALAR|ARRAY|HASH|CODE|REF)$/) {
            croak "Input from $1 reference not supported!\n";
        }
        ## Must be a filehandle-ref (or else assume its a ref to an object
        ## that supports the common IO read operations).
        $myData{_INFILE} = ${$infile};
        $in_fh = $infile;
    }
    elsif (!defined($infile) || !length($infile) || ($infile eq '-')
        || ($infile =~ /^<&(?:STDIN|0)$/i))
    {
        ## Not a filename, just a string implying STDIN
        $infile ||= '-';
        $myData{_INFILE} = '<standard input>';
        $in_fh = \*STDIN;
    }
    else {
        ## We have a filename, open it for reading
        $myData{_INFILE} = $infile;
        open($in_fh, "< $infile")  or
             croak "Can't open $infile for reading: $!\n";
        $close_input = 1;
    }

    ## NOTE: we need to be *very* careful when "defaulting" the output
    ## file. We only want to use a default if this is the beginning of
    ## the entire document (but *not* if this is an included file). We
    ## determine this by seeing if the input stream stack has been set-up
    ## already

    ## Is $outfile a filename, a (possibly implied) filehandle, maybe a ref?
    if (ref $outfile) {
        ## we need to check for ref() first, as other checks involve reading
        if (ref($outfile) =~ /^(ARRAY|HASH|CODE)$/) {
            croak "Output to $1 reference not supported!\n";
        }
        elsif (ref($outfile) eq 'SCALAR') {
#           # NOTE: IO::String isn't a part of the perl distribution,
#           #       so probably we shouldn't support this case...
#           require IO::String;
#           $myData{_OUTFILE} = "$outfile";
#           $out_fh = IO::String->new($outfile);
            croak "Output to SCALAR reference not supported!\n";
        }
        else {
            ## Must be a filehandle-ref (or else assume its a ref to an
            ## object that supports the common IO write operations).
            $myData{_OUTFILE} = ${$outfile};
            $out_fh = $outfile;
        }
    }
    elsif (!defined($outfile) || !length($outfile) || ($outfile eq '-')
        || ($outfile =~ /^>&?(?:STDOUT|1)$/i))
    {
        if (defined $myData{_TOP_STREAM}) {
            $out_fh = $myData{_OUTPUT};
        }
        else {
            ## Not a filename, just a string implying STDOUT
            $outfile ||= '-';
            $myData{_OUTFILE} = '<standard output>';
            $out_fh  = \*STDOUT;
        }
    }
    elsif ($outfile =~ /^>&(STDERR|2)$/i) {
        ## Not a filename, just a string implying STDERR
        $myData{_OUTFILE} = '<standard error>';
        $out_fh  = \*STDERR;
    }
    else {
        ## We have a filename, open it for writing
        $myData{_OUTFILE} = $outfile;
        (-d $outfile) and croak "$outfile is a directory, not POD input!\n";
        open($out_fh, "> $outfile")  or
             croak "Can't open $outfile for writing: $!\n";
        $close_output = 1;
    }

    ## Whew! That was a lot of work to set up reasonably/robust behavior
    ## in the case of a non-filename for reading and writing. Now we just
    ## have to parse the input and close the handles when we're finished.
    $self->parse_from_filehandle(\%opts, $in_fh, $out_fh);

    $close_input  and
        close($in_fh) || croak "Can't close $infile after reading: $!\n";
    $close_output  and
        close($out_fh) || croak "Can't close $outfile after writing: $!\n";
}

#############################################################################

=head1 ACCESSOR METHODS

Clients of B<Pod::Parser> should use the following methods to access
instance data fields:

=cut

##---------------------------------------------------------------------------

=head1 B<errorsub()>

            $parser->errorsub("method_name");
            $parser->errorsub(\&warn_user);
            $parser->errorsub(sub { print STDERR, @_ });

Specifies the method or subroutine to use when printing error messages
about POD syntax. The supplied method/subroutine I<must> return TRUE upon
successful printing of the message. If C<undef> is given, then the B<carp>
builtin is used to issue error messages (this is the default behavior).

            my $errorsub = $parser->errorsub()
            my $errmsg = "This is an error message!\n"
            (ref $errorsub) and &{$errorsub}($errmsg)
                or (defined $errorsub) and $parser->$errorsub($errmsg)
                    or  carp($errmsg);

Returns a method name, or else a reference to the user-supplied subroutine
used to print error messages. Returns C<undef> if the B<carp> builtin
is used to issue error messages (this is the default behavior).

=cut

sub errorsub {
   return (@_ > 1) ? ($_[0]->{_ERRORSUB} = $_[1]) : $_[0]->{_ERRORSUB};
}

##---------------------------------------------------------------------------

=head1 B<cutting()>

            $boolean = $parser->cutting();

Returns the current C<cutting> state: a boolean-valued scalar which
evaluates to true if text from the input file is currently being "cut"
(meaning it is I<not> considered part of the POD document).

            $parser->cutting($boolean);

Sets the current C<cutting> state to the given value and returns the
result.

=cut

sub cutting {
   return (@_ > 1) ? ($_[0]->{_CUTTING} = $_[1]) : $_[0]->{_CUTTING};
}

##---------------------------------------------------------------------------

##---------------------------------------------------------------------------

=head1 B<parseopts()>

When invoked with no additional arguments, B<parseopts> returns a hashtable
of all the current parsing options.

            ## See if we are parsing non-POD sections as well as POD ones
            my %opts = $parser->parseopts();
            $opts{'-want_nonPODs}' and print "-want_nonPODs\n";

When invoked using a single string, B<parseopts> treats the string as the
name of a parse-option and returns its corresponding value if it exists
(returns C<undef> if it doesn't).

            ## Did we ask to see '=cut' paragraphs?
            my $want_cut = $parser->parseopts('-process_cut_cmd');
            $want_cut and print "-process_cut_cmd\n";

When invoked with multiple arguments, B<parseopts> treats them as
key/value pairs and the specified parse-option names are set to the
given values. Any unspecified parse-options are unaffected.

            ## Set them back to the default
            $parser->parseopts(-warnings => 0);

When passed a single hash-ref, B<parseopts> uses that hash to completely
reset the existing parse-options, all previous parse-option values
are lost.

            ## Reset all options to default 
            $parser->parseopts( { } );

See L<"PARSING OPTIONS"> for more information on the name and meaning of each
parse-option currently recognized.

=cut

sub parseopts {
   local *myData = shift;
   local *myOpts = ($myData{_PARSEOPTS} ||= {});
   return %myOpts  if (@_ == 0);
   if (@_ == 1) {
      local $_ = shift;
      return  ref($_)  ?  $myData{_PARSEOPTS} = $_  :  $myOpts{$_};
   }
   my @newOpts = (%myOpts, @_);
   $myData{_PARSEOPTS} = { @newOpts };
}

##---------------------------------------------------------------------------

=head1 B<output_file()>

            $fname = $parser->output_file();

Returns the name of the output file being written.

=cut

sub output_file {
   return $_[0]->{_OUTFILE};
}

##---------------------------------------------------------------------------

=head1 B<output_handle()>

            $fhandle = $parser->output_handle();

Returns the output filehandle object.

=cut

sub output_handle {
   return $_[0]->{_OUTPUT};
}

##---------------------------------------------------------------------------

=head1 B<input_file()>

            $fname = $parser->input_file();

Returns the name of the input file being read.

=cut

sub input_file {
   return $_[0]->{_INFILE};
}

##---------------------------------------------------------------------------

=head1 B<input_handle()>

            $fhandle = $parser->input_handle();

Returns the current input filehandle object.

=cut

sub input_handle {
   return $_[0]->{_INPUT};
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head1 B<input_streams()>

            $listref = $parser->input_streams();

Returns a reference to an array which corresponds to the stack of all
the input streams that are currently in the middle of being parsed.

While parsing an input stream, it is possible to invoke
B<parse_from_file()> or B<parse_from_filehandle()> to parse a new input
stream and then return to parsing the previous input stream. Each input
stream to be parsed is pushed onto the end of this input stack
before any of its input is read. The input stream that is currently
being parsed is always at the end (or top) of the input stack. When an
input stream has been exhausted, it is popped off the end of the
input stack.

Each element on this input stack is a reference to C<Pod::InputSource>
object. Please see L<Pod::InputObjects> for more details.

This method might be invoked when printing diagnostic messages, for example,
to obtain the name and line number of the all input files that are currently
being processed.

=end __PRIVATE__

=cut

sub input_streams {
   return $_[0]->{_INPUT_STREAMS};
}

##---------------------------------------------------------------------------

=begin __PRIVATE__

=head1 B<top_stream()>

            $hashref = $parser->top_stream();

Returns a reference to the hash-table that represents the element
that is currently at the top (end) of the input stream stack
(see L<"input_streams()">). The return value will be the C<undef>
if the input stack is empty.

This method might be used when printing diagnostic messages, for example,
to obtain the name and line number of the current input file.

=end __PRIVATE__

=cut

sub top_stream {
   return $_[0]->{_TOP_STREAM} || undef;
}

#############################################################################

=head1 PRIVATE METHODS AND DATA

B<Pod::Parser> makes use of several internal methods and data fields
which clients should not need to see or use. For the sake of avoiding
name collisions for client data and methods, these methods and fields
are briefly discussed here. Determined hackers may obtain further
information about them by reading the B<Pod::Parser> source code.

Private data fields are stored in the hash-object whose reference is
returned by the B<new()> constructor for this class. The names of all
private methods and data-fields used by B<Pod::Parser> begin with a
prefix of "_" and match the regular expression C</^_\w+$/>.

=cut

##---------------------------------------------------------------------------

=begin _PRIVATE_

=head1 B<_push_input_stream()>

            $hashref = $parser->_push_input_stream($in_fh,$out_fh);

This method will push the given input stream on the input stack and
perform any necessary beginning-of-document or beginning-of-file
processing. The argument C<$in_fh> is the input stream filehandle to
push, and C<$out_fh> is the corresponding output filehandle to use (if
it is not given or is undefined, then the current output stream is used,
which defaults to standard output if it doesnt exist yet).

The value returned will be reference to the hash-table that represents
the new top of the input stream stack. I<Please Note> that it is
possible for this method to use default values for the input and output
file handles. If this happens, you will need to look at the C<INPUT>
and C<OUTPUT> instance data members to determine their new values.

=end _PRIVATE_

=cut

sub _push_input_stream {
    my ($self, $in_fh, $out_fh) = @_;
    local *myData = $self;

    ## Initialize stuff for the entire document if this is *not*
    ## an included file.
    ##
    ## NOTE: we need to be *very* careful when "defaulting" the output
    ## filehandle. We only want to use a default value if this is the
    ## beginning of the entire document (but *not* if this is an included
    ## file).
    unless (defined  $myData{_TOP_STREAM}) {
        $out_fh  = \*STDOUT  unless (defined $out_fh);
        $myData{_CUTTING}       = 1;   ## current "cutting" state
        $myData{_INPUT_STREAMS} = [];  ## stack of all input streams
    }

    ## Initialize input indicators
    $myData{_OUTFILE} = '(unknown)'  unless (defined  $myData{_OUTFILE});
    $myData{_OUTPUT}  = $out_fh      if (defined  $out_fh);
    $in_fh            = \*STDIN      unless (defined  $in_fh);
    $myData{_INFILE}  = '(unknown)'  unless (defined  $myData{_INFILE});
    $myData{_INPUT}   = $in_fh;
    my $input_top     = $myData{_TOP_STREAM}
                      = new Pod::InputSource(
                            -name        => $myData{_INFILE},
                            -handle      => $in_fh,
                            -was_cutting => $myData{_CUTTING}
                        );
    local *input_stack = $myData{_INPUT_STREAMS};
    push(@input_stack, $input_top);

    ## Perform beginning-of-document and/or beginning-of-input processing
    $self->begin_pod()  if (@input_stack == 1);
    $self->begin_input();

    return  $input_top;
}

##---------------------------------------------------------------------------

=begin _PRIVATE_

=head1 B<_pop_input_stream()>

            $hashref = $parser->_pop_input_stream();

This takes no arguments. It will perform any necessary end-of-file or
end-of-document processing and then pop the current input stream from
the top of the input stack.

The value returned will be reference to the hash-table that represents
the new top of the input stream stack.

=end _PRIVATE_

=cut

sub _pop_input_stream {
    my ($self) = @_;
    local *myData = $self;
    local *input_stack = $myData{_INPUT_STREAMS};

    ## Perform end-of-input and/or end-of-document processing
    $self->end_input()  if (@input_stack > 0);
    $self->end_pod()    if (@input_stack == 1);

    ## Restore cutting state to whatever it was before we started
    ## parsing this file.
    my $old_top = pop(@input_stack);
    $myData{_CUTTING} = $old_top->was_cutting();

    ## Don't forget to reset the input indicators
    my $input_top = undef;
    if (@input_stack > 0) {
       $input_top = $myData{_TOP_STREAM} = $input_stack[-1];
       $myData{_INFILE}  = $input_top->name();
       $myData{_INPUT}   = $input_top->handle();
    } else {
       delete $myData{_TOP_STREAM};
       delete $myData{_INPUT_STREAMS};
    }

    return  $input_top;
}

#############################################################################

=head1 TREE-BASED PARSING

If straightforward stream-based parsing wont meet your needs (as is
likely the case for tasks such as translating PODs into structured
markup languages like HTML and XML) then you may need to take the
tree-based approach. Rather than doing everything in one pass and
calling the B<interpolate()> method to expand sequences into text, it
may be desirable to instead create a parse-tree using the B<parse_text()>
method to return a tree-like structure which may contain an ordered
list of children (each of which may be a text-string, or a similar
tree-like structure).

Pay special attention to L<"METHODS FOR PARSING AND PROCESSING"> and
to the objects described in L<Pod::InputObjects>. The former describes
the gory details and parameters for how to customize and extend the
parsing behavior of B<Pod::Parser>. B<Pod::InputObjects> provides
several objects that may all be used interchangeably as parse-trees. The
most obvious one is the B<Pod::ParseTree> object. It defines the basic
interface and functionality that all things trying to be a POD parse-tree
should do. A B<Pod::ParseTree> is defined such that each "node" may be a
text-string, or a reference to another parse-tree.  Each B<Pod::Paragraph>
object and each B<Pod::InteriorSequence> object also supports the basic
parse-tree interface.

The B<parse_text()> method takes a given paragraph of text, and
returns a parse-tree that contains one or more children, each of which
may be a text-string, or an InteriorSequence object. There are also
callback-options that may be passed to B<parse_text()> to customize
the way it expands or transforms interior-sequences, as well as the
returned result. These callbacks can be used to create a parse-tree
with custom-made objects (which may or may not support the parse-tree
interface, depending on how you choose to do it).

If you wish to turn an entire POD document into a parse-tree, that process
is fairly straightforward. The B<parse_text()> method is the key to doing
this successfully. Every paragraph-callback (i.e. the polymorphic methods
for B<command()>, B<verbatim()>, and B<textblock()> paragraphs) takes
a B<Pod::Paragraph> object as an argument. Each paragraph object has a
B<parse_tree()> method that can be used to get or set a corresponding
parse-tree. So for each of those paragraph-callback methods, simply call
B<parse_text()> with the options you desire, and then use the returned
parse-tree to assign to the given paragraph object.

That gives you a parse-tree for each paragraph - so now all you need is
an ordered list of paragraphs. You can maintain that yourself as a data
element in the object/hash. The most straightforward way would be simply
to use an array-ref, with the desired set of custom "options" for each
invocation of B<parse_text>. Let's assume the desired option-set is
given by the hash C<%options>. Then we might do something like the
following:

    package MyPodParserTree;

    @ISA = qw( Pod::Parser );

    ...

    sub begin_pod {
        my $self = shift;
        $self->{'-paragraphs'} = [];  ## initialize paragraph list
    }

    sub command { 
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser->parse_text({%options}, $paragraph, ...);
        $pod_para->parse_tree( $ptree );
        push @{ $self->{'-paragraphs'} }, $pod_para;
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        push @{ $self->{'-paragraphs'} }, $pod_para;
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser->parse_text({%options}, $paragraph, ...);
        $pod_para->parse_tree( $ptree );
        push @{ $self->{'-paragraphs'} }, $pod_para;
    }

    ...

    package main;
    ...
    my $parser = new MyPodParserTree(...);
    $parser->parse_from_file(...);
    my $paragraphs_ref = $parser->{'-paragraphs'};

Of course, in this module-author's humble opinion, I'd be more inclined to
use the existing B<Pod::ParseTree> object than a simple array. That way
everything in it, paragraphs and sequences, all respond to the same core
interface for all parse-tree nodes. The result would look something like:

    package MyPodParserTree2;

    ...

    sub begin_pod {
        my $self = shift;
        $self->{'-ptree'} = new Pod::ParseTree;  ## initialize parse-tree
    }

    sub parse_tree {
        ## convenience method to get/set the parse-tree for the entire POD
        (@_ > 1)  and  $_[0]->{'-ptree'} = $_[1];
        return $_[0]->{'-ptree'};
    }

    sub command { 
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser->parse_text({<<options>>}, $paragraph, ...);
        $pod_para->parse_tree( $ptree );
        $parser->parse_tree()->append( $pod_para );
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        $parser->parse_tree()->append( $pod_para );
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser->parse_text({<<options>>}, $paragraph, ...);
        $pod_para->parse_tree( $ptree );
        $parser->parse_tree()->append( $pod_para );
    }

    ...

    package main;
    ...
    my $parser = new MyPodParserTree2(...);
    $parser->parse_from_file(...);
    my $ptree = $parser->parse_tree;
    ...

Now you have the entire POD document as one great big parse-tree. You
can even use the B<-expand_seq> option to B<parse_text> to insert
whole different kinds of objects. Just don't expect B<Pod::Parser>
to know what to do with them after that. That will need to be in your
code. Or, alternatively, you can insert any object you like so long as
it conforms to the B<Pod::ParseTree> interface.

One could use this to create subclasses of B<Pod::Paragraphs> and
B<Pod::InteriorSequences> for specific commands (or to create your own
custom node-types in the parse-tree) and add some kind of B<emit()>
method to each custom node/subclass object in the tree. Then all you'd
need to do is recursively walk the tree in the desired order, processing
the children (most likely from left to right) by formatting them if
they are text-strings, or by calling their B<emit()> method if they
are objects/references.

=head1 CAVEATS

Please note that POD has the notion of "paragraphs": this is something
starting I<after> a blank (read: empty) line, with the single exception
of the file start, which is also starting a paragraph. That means that
especially a command (e.g. C<=head1>) I<must> be preceded with a blank
line; C<__END__> is I<not> a blank line.

=head1 SEE ALSO

L<Pod::InputObjects>, L<Pod::Select>

B<Pod::InputObjects> defines POD input objects corresponding to
command paragraphs, parse-trees, and interior-sequences.

B<Pod::Select> is a subclass of B<Pod::Parser> which provides the ability
to selectively include and/or exclude sections of a POD document from being
translated based upon the current heading, subheading, subsubheading, etc.

=for __PRIVATE__
B<Pod::Callbacks> is a subclass of B<Pod::Parser> which gives its users
the ability the employ I<callback functions> instead of, or in addition
to, overriding methods of the base class.

=for __PRIVATE__
B<Pod::Select> and B<Pod::Callbacks> do not override any
methods nor do they define any new methods with the same name. Because
of this, they may I<both> be used (in combination) as a base class of
the same subclass in order to combine their functionality without
causing any namespace clashes due to multiple inheritance.

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@enteract.comE<gt>

Based on code for B<Pod::Text> written by
Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>

=head1 LICENSE

Pod-Parser is free software; you can redistribute it and/or modify it
under the terms of the Artistic License distributed with Perl version
5.000 or (at your option) any later version. Please refer to the
Artistic License that came with your Perl distribution for more
details. If your version of Perl was not distributed under the
terms of the Artistic License, than you may distribute PodParser
under the same terms as Perl itself.

=cut

1;
# vim: ts=4 sw=4 et
                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Pod/Perldoc/                                                                  0040755 0000000 0000000 00000000000 13077704254 014774  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Pod/Perldoc/BaseTo.pm                                                         0100644 0000000 0000000 00000006743 12744441327 016515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::BaseTo;
use strict;
use warnings;

use vars qw($VERSION);
$VERSION = '3.23';

use Carp                  qw(croak carp);
use Config                qw(%Config);
use File::Spec::Functions qw(catfile);

sub is_pageable        { '' }
sub write_with_binmode {  1 }

sub output_extension   { 'txt' }  # override in subclass!

# sub new { my $self = shift; ...  }
# sub parse_from_file( my($class, $in, $out) = ...; ... }

#sub new { return bless {}, ref($_[0]) || $_[0] }

# this is also in Perldoc.pm, but why look there when you're a
# subclass of this?
sub TRUE  () {1}
sub FALSE () {return}

BEGIN {
 *is_vms     = $^O eq 'VMS'      ? \&TRUE : \&FALSE unless defined &is_vms;
 *is_mswin32 = $^O eq 'MSWin32'  ? \&TRUE : \&FALSE unless defined &is_mswin32;
 *is_dos     = $^O eq 'dos'      ? \&TRUE : \&FALSE unless defined &is_dos;
 *is_os2     = $^O eq 'os2'      ? \&TRUE : \&FALSE unless defined &is_os2;
 *is_cygwin  = $^O eq 'cygwin'   ? \&TRUE : \&FALSE unless defined &is_cygwin;
 *is_linux   = $^O eq 'linux'    ? \&TRUE : \&FALSE unless defined &is_linux;
 *is_hpux    = $^O =~ m/hpux/    ? \&TRUE : \&FALSE unless defined &is_hpux;
 *is_openbsd = $^O =~ m/openbsd/ ? \&TRUE : \&FALSE unless defined &is_openbsd;
 *is_bitrig = $^O =~ m/bitrig/ ? \&TRUE : \&FALSE unless defined &is_bitrig;
}

sub _perldoc_elem {
  my($self, $name) = splice @_,0,2;
  if(@_) {
    $self->{$name} = $_[0];
  } else {
    $self->{$name};
  }
}

sub debugging {
	my( $self, @messages ) = @_;

    ( defined(&Pod::Perldoc::DEBUG) and &Pod::Perldoc::DEBUG() )
	}

sub debug {
	my( $self, @messages ) = @_;
	return unless $self->debugging;
	print STDERR map { "DEBUG $_" } @messages;
	}

sub warn {
	my( $self, @messages ) = @_;
	carp join "\n", @messages, '';
	}

sub die {
	my( $self, @messages ) = @_;
	croak join "\n", @messages, '';
	}

sub _get_path_components {
	my( $self ) = @_;

	my @paths = split /\Q$Config{path_sep}/, $ENV{PATH};

	return @paths;
	}

sub _find_executable_in_path {
	my( $self, $program ) = @_;

	my @found = ();
	foreach my $dir ( $self->_get_path_components ) {
		my $binary = catfile( $dir, $program );
		$self->debug( "Looking for $binary\n" );
		next unless -e $binary;
		unless( -x $binary ) {
			$self->warn( "Found $binary but it's not executable. Skipping.\n" );
			next;
			}
		$self->debug( "Found $binary\n" );
		push @found, $binary;
		}

	return @found;
	}

1;

__END__

=head1 NAME

Pod::Perldoc::BaseTo - Base for Pod::Perldoc formatters

=head1 SYNOPSIS

    package Pod::Perldoc::ToMyFormat;

    use base qw( Pod::Perldoc::BaseTo );
    ...

=head1 DESCRIPTION

This package is meant as a base of Pod::Perldoc formatters,
like L<Pod::Perldoc::ToText>, L<Pod::Perldoc::ToMan>, etc.

It provides default implementations for the methods

    is_pageable
    write_with_binmode
    output_extension
    _perldoc_elem

The concrete formatter must implement

    new
    parse_from_file

=head1 SEE ALSO

L<perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002-2007 Sean M. Burke.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut
                             usr/share/perl/5.20.2/Pod/Perldoc/GetOptsOO.pm                                                      0100644 0000000 0000000 00000007460 12744441327 017160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::GetOptsOO;
use strict;

use vars qw($VERSION);
$VERSION = '3.23';

BEGIN { # Make a DEBUG constant ASAP
  *DEBUG = defined( &Pod::Perldoc::DEBUG )
   ? \&Pod::Perldoc::DEBUG
   : sub(){10};
}


sub getopts {
  my($target, $args, $truth) = @_;

  $args ||= \@ARGV;

  $target->aside(
    "Starting switch processing.  Scanning arguments [@$args]\n"
  ) if $target->can('aside');

  return unless @$args;

  $truth = 1 unless @_ > 2;

  DEBUG > 3 and print "   Truth is $truth\n";


  my $error_count = 0;

  while( @$args  and  ($_ = $args->[0]) =~ m/^-(.)(.*)/s ) {
    my($first,$rest) = ($1,$2);
    if ($_ eq '--') {	# early exit if "--"
      shift @$args;
      last;
    }
    if ($first eq '-' and $rest) {      # GNU style long param names
      ($first, $rest) = split '=', $rest, 2;
    }
    my $method = "opt_${first}_with";
    if( $target->can($method) ) {  # it's argumental
      if($rest eq '') {   # like -f bar
        shift @$args;
        $target->warn( "Option $first needs a following argument!\n" ) unless @$args;
        $rest = shift @$args;
      } else {            # like -fbar  (== -f bar)
        shift @$args;
      }

      DEBUG > 3 and print " $method => $rest\n";
      $target->$method( $rest );

    # Otherwise, it's not argumental...
    } else {

      if( $target->can( $method = "opt_$first" ) ) {
        DEBUG > 3 and print " $method is true ($truth)\n";
        $target->$method( $truth );

      # Otherwise it's an unknown option...

      } elsif( $target->can('handle_unknown_option') ) {
        DEBUG > 3
         and print " calling handle_unknown_option('$first')\n";

        $error_count += (
          $target->handle_unknown_option( $first ) || 0
        );

      } else {
        ++$error_count;
        $target->warn( "Unknown option: $first\n" );
      }

      if($rest eq '') {   # like -f
        shift @$args
      } else {            # like -fbar  (== -f -bar )
        DEBUG > 2 and print "   Setting args->[0] to \"-$rest\"\n";
        $args->[0] = "-$rest";
      }
    }
  }


  $target->aside(
    "Ending switch processing.  Args are [@$args] with $error_count errors.\n"
  ) if $target->can('aside');

  $error_count == 0;
}

1;

__END__

=head1 NAME

Pod::Perldoc::GetOptsOO - Customized option parser for Pod::Perldoc

=head1 SYNOPSIS

    use Pod::Perldoc::GetOptsOO ();

    Pod::Perldoc::GetOptsOO::getopts( $obj, \@args, $truth )
       or die "wrong usage";


=head1 DESCRIPTION

Implements a customized option parser used for
L<Pod::Perldoc>.

Rather like Getopt::Std's getopts:

=over

=item Call Pod::Perldoc::GetOptsOO::getopts($object, \@ARGV, $truth)

=item Given -n, if there's a opt_n_with, it'll call $object->opt_n_with( ARGUMENT )
   (e.g., "-n foo" => $object->opt_n_with('foo').  Ditto "-nfoo")

=item Otherwise (given -n) if there's an opt_n, we'll call it $object->opt_n($truth)
   (Truth defaults to 1)

=item Otherwise we try calling $object->handle_unknown_option('n')
   (and we increment the error count by the return value of it)

=item If there's no handle_unknown_option, then we just warn, and then increment
   the error counter

=back

The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors,
otherwise it's false.

=head1 SEE ALSO

L<Pod::Perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002-2007 Sean M. Burke.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut
                                                                                                                                                                                                                usr/share/perl/5.20.2/Pod/Perldoc/ToANSI.pm                                                         0100644 0000000 0000000 00000004377 12744441327 016376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToANSI;
use strict;
use warnings;
use parent qw(Pod::Perldoc::BaseTo);

use vars qw($VERSION);
$VERSION = '3.23';

sub is_pageable        { 1 }
sub write_with_binmode { 0 }
sub output_extension   { 'txt' }

use Pod::Text::Color ();

sub alt       { shift->_perldoc_elem('alt'     , @_) }
sub indent    { shift->_perldoc_elem('indent'  , @_) }
sub loose     { shift->_perldoc_elem('loose'   , @_) }
sub quotes    { shift->_perldoc_elem('quotes'  , @_) }
sub sentence  { shift->_perldoc_elem('sentence', @_) }
sub width     { shift->_perldoc_elem('width'   , @_) }

sub new { return bless {}, ref($_[0]) || $_[0] }

sub parse_from_file {
  my $self = shift;

  my @options =
    map {; $_, $self->{$_} }
      grep !m/^_/s,
        keys %$self
  ;

  defined(&Pod::Perldoc::DEBUG)
   and Pod::Perldoc::DEBUG()
   and print "About to call new Pod::Text::Color ",
    $Pod::Text::VERSION ? "(v$Pod::Text::VERSION) " : '',
    "with options: ",
    @options ? "[@options]" : "(nil)", "\n";
  ;

  Pod::Text::Color->new(@options)->parse_from_file(@_);
}

1;

=head1 NAME

Pod::Perldoc::ToANSI - render Pod with ANSI color escapes 

=head1 SYNOPSIS

  perldoc -o ansi Some::Modulename

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to use
Pod::Text as a formatter class.

It supports the following options, which are explained in
L<Pod::Text>: alt, indent, loose, quotes, sentence, width

For example:

  perldoc -o term -w indent:5 Some::Modulename

=head1 CAVEAT

This module may change to use a different text formatter class in the
future, and this may change what options are supported.

=head1 SEE ALSO

L<Pod::Text>, L<Pod::Text::Color>, L<Pod::Perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2011 Mark Allen.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>


=cut
                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Pod/Perldoc/ToChecker.pm                                                      0100644 0000000 0000000 00000003233 12744441327 017176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToChecker;
use strict;
use warnings;
use vars qw(@ISA);

use vars qw($VERSION);
$VERSION = '3.23';

# Pick our superclass...
#
eval 'require Pod::Simple::Checker';
if($@) {
  require Pod::Checker;
  @ISA = ('Pod::Checker');
} else {
  @ISA = ('Pod::Simple::Checker');
}

sub is_pageable        { 1 }
sub write_with_binmode { 0 }
sub output_extension   { 'txt' }

sub if_zero_length {
  my( $self, $file, $tmp, $tmpfd ) = @_;
  print "No Pod errors in $file\n";
}


1;

__END__

=head1 NAME

Pod::Perldoc::ToChecker - let Perldoc check Pod for errors

=head1 SYNOPSIS

  % perldoc -o checker SomeFile.pod
  No Pod errors in SomeFile.pod
  (or an error report)

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to use
Pod::Simple::Checker as a "formatter" class (or if that is
not available, then Pod::Checker), to check for errors in a given
Pod file.

This is actually a Pod::Simple::Checker (or Pod::Checker) subclass, and
inherits all its options.

=head1 SEE ALSO

L<Pod::Simple::Checker>, L<Pod::Simple>, L<Pod::Checker>, L<Pod::Perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut

                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Pod/Perldoc/ToMan.pm                                                          0100644 0000000 0000000 00000033623 12744441327 016353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        require 5.006;
package Pod::Perldoc::ToMan;
use strict;
use warnings;
use parent qw(Pod::Perldoc::BaseTo);

use vars qw($VERSION);
$VERSION = '3.23';

use File::Spec::Functions qw(catfile);
use Pod::Man 2.18;
# This class is unlike ToText.pm et al, because we're NOT paging thru
# the output in our particular format -- we make the output and
# then we run nroff (or whatever) on it, and then page thru the
# (plaintext) output of THAT!

sub SUCCESS () { 1 }
sub FAILED  () { 0 }

sub is_pageable        { 1 }
sub write_with_binmode { 0 }
sub output_extension   { 'txt' }

sub __filter_nroff  { shift->_perldoc_elem('__filter_nroff'  , @_) }
sub __nroffer       { shift->_perldoc_elem('__nroffer'       , @_) }
sub __bindir        { shift->_perldoc_elem('__bindir'        , @_) }
sub __pod2man       { shift->_perldoc_elem('__pod2man'       , @_) }
sub __output_file   { shift->_perldoc_elem('__output_file'   , @_) }

sub center          { shift->_perldoc_elem('center'         , @_) }
sub date            { shift->_perldoc_elem('date'           , @_) }
sub fixed           { shift->_perldoc_elem('fixed'          , @_) }
sub fixedbold       { shift->_perldoc_elem('fixedbold'      , @_) }
sub fixeditalic     { shift->_perldoc_elem('fixeditalic'    , @_) }
sub fixedbolditalic { shift->_perldoc_elem('fixedbolditalic', @_) }
sub name            { shift->_perldoc_elem('name'           , @_) }
sub quotes          { shift->_perldoc_elem('quotes'         , @_) }
sub release         { shift->_perldoc_elem('release'        , @_) }
sub section         { shift->_perldoc_elem('section'        , @_) }

sub new {
	my( $either ) = shift;
	my $self = bless {}, ref($either) || $either;
	$self->init( @_ );
	return $self;
	}

sub init {
	my( $self, @args ) = @_;

	unless( $self->__nroffer ) {
		my $roffer = $self->_find_roffer( $self->_roffer_candidates );
		$self->debug( "Using $roffer\n" );
		$self->__nroffer( $roffer );
		}
    else {
	    $self->debug( "__nroffer is " . $self->__nroffer() . "\n" );
        }

	$self->_check_nroffer;
	}

sub _roffer_candidates {
	my( $self ) = @_;

	if( $self->is_openbsd || $self->is_bitrig ) { qw( mandoc groff nroff ) }
	else                    { qw( groff nroff mandoc ) }
	}

sub _find_roffer {
	my( $self, @candidates ) = @_;

	my @found = ();
	foreach my $candidate ( @candidates ) {
		push @found, $self->_find_executable_in_path( $candidate );
		}

	return wantarray ? @found : $found[0];
	}

sub _check_nroffer {
	return 1;
	# where is it in the PATH?

	# is it executable?

	# what is its real name?

	# what is its version?

	# does it support the flags we need?

	# is it good enough for us?
	}

sub _get_stty { `stty -a` }

sub _get_columns_from_stty {
	my $output = $_[0]->_get_stty;

	if(    $output =~ /\bcolumns\s+(\d+)/ )    { return $1 }
	elsif( $output =~ /;\s*(\d+)\s+columns;/ ) { return $1 }
	else                                       { return  0 }
	}

sub _get_columns_from_manwidth {
	my( $self ) = @_;

	return 0 unless defined $ENV{MANWIDTH};

	unless( $ENV{MANWIDTH} =~ m/\A\d+\z/ ) {
		$self->warn( "Ignoring non-numeric MANWIDTH ($ENV{MANWIDTH})\n" );
		return 0;
		}

	if( $ENV{MANWIDTH} == 0 ) {
		$self->warn( "Ignoring MANWIDTH of 0. Really? Why even run the program? :)\n" );
		return 0;
		}

	if( $ENV{MANWIDTH} =~ m/\A(\d+)\z/ ) { return $1 }

	return 0;
	}

sub _get_default_width {
	73
	}

sub _get_columns {
	$_[0]->_get_columns_from_manwidth ||
	$_[0]->_get_columns_from_stty     ||
	$_[0]->_get_default_width;
	}

sub _get_podman_switches {
	my( $self ) = @_;

	my @switches = map { $_, $self->{$_} } grep !m/^_/s, keys %$self;

    # There needs to be a cleaner way to handle setting
    # the UTF-8 flag, but for now, comment out this
    # line because it often does the wrong thing.
    #
    # See RT #77465
    #
    #push @switches, 'utf8' => 1;

	$self->debug( "Pod::Man switches are [@switches]\n" );

	return @switches;
	}

sub _parse_with_pod_man {
	my( $self, $file ) = @_;

	#->output_fh and ->output_string from Pod::Simple aren't
	# working, apparently, so there's this ugly hack:
	local *STDOUT;
	open STDOUT, '>', $self->{_text_ref};
	my $parser = Pod::Man->new( $self->_get_podman_switches );
	$self->debug( "Parsing $file\n" );
	$parser->parse_from_file( $file );
	$self->debug( "Done parsing $file\n" );
	close STDOUT;

	$self->die( "No output from Pod::Man!\n" )
		unless length $self->{_text_ref};

	$self->_save_pod_man_output if $self->debugging;

	return SUCCESS;
	}

sub _save_pod_man_output {
	my( $self, $fh ) = @_;

	$fh = do {
		my $file = "podman.out.$$.txt";
		$self->debug( "Writing $file with Pod::Man output\n" );
		open my $fh2, '>', $file;
		$fh2;
		} unless $fh;

	print { $fh } ${ $self->{_text_ref} };
	}

sub _have_groff_with_utf8 {
	my( $self ) = @_;

	return 0 unless $self->_is_groff;
	my $roffer = $self->__nroffer;

	my $minimum_groff_version = '1.20.1';

	my $version_string = `$roffer -v`;
	my( $version ) = $version_string =~ /\(?groff\)? version (\d+\.\d+(?:\.\d+)?)/;
	$self->debug( "Found groff $version\n" );

	# is a string comparison good enough?
	if( $version lt $minimum_groff_version ) {
		$self->warn(
			"You have an old groff." .
			" Update to version $minimum_groff_version for good Unicode support.\n" .
			"If you don't upgrade, wide characters may come out oddly.\n"
			 );
		}

	$version ge $minimum_groff_version;
	}

sub _have_mandoc_with_utf8 {
	my( $self ) = @_;

       $self->_is_mandoc and not system 'mandoc -Tlocale -V > /dev/null 2>&1';
	}

sub _collect_nroff_switches {
	my( $self ) = shift;

    my @render_switches = ('-man', $self->_get_device_switches);

	# Thanks to Brendan O'Dea for contributing the following block
	if( $self->_is_roff and -t STDOUT and my ($cols) = $self->_get_columns ) {
		my $c = $cols * 39 / 40;
		$cols = $c > $cols - 2 ? $c : $cols -2;
		push @render_switches, '-rLL=' . (int $c) . 'n' if $cols > 80;
		}

	# I hear persistent reports that adding a -c switch to $render
	# solves many people's problems.  But I also hear that some mans
	# don't have a -c switch, so that unconditionally adding it here
	# would presumably be a Bad Thing   -- sburke@cpan.org
    push @render_switches, '-c' if( $self->_is_roff and $self->is_cygwin );

	return @render_switches;
	}

sub _get_device_switches {
	my( $self ) = @_;

	   if( $self->_is_nroff  )             { qw()              }
	elsif( $self->_have_groff_with_utf8 )  { qw(-Kutf8 -Tutf8) }
	elsif( $self->_is_ebcdic )             { qw(-Tcp1047)      }
	elsif( $self->_have_mandoc_with_utf8 ) { qw(-Tlocale)      }
	elsif( $self->_is_mandoc )             { qw()              }
	else                                   { qw(-Tlatin1)      }
	}

sub _is_roff {
	my( $self ) = @_;

	$self->_is_nroff or $self->_is_groff;
	}

sub _is_nroff {
	my( $self ) = @_;

	$self->__nroffer =~ /\bnroff\b/;
	}

sub _is_groff {
	my( $self ) = @_;

	$self->__nroffer =~ /\bgroff\b/;
	}

sub _is_mandoc {
	my ( $self ) = @_;

	$self->__nroffer =~ /\bmandoc\b/;
	}

sub _is_ebcdic {
	my( $self ) = @_;

	return 0;
	}
	
sub _filter_through_nroff {
	my( $self ) = shift;
	$self->debug( "Filtering through " . $self->__nroffer() . "\n" );

    # Maybe someone set rendering switches as part of the opt_n value
    # Deal with that here.

    my ($render, $switches) = $self->__nroffer() =~ /\A([\/a-zA-Z0-9_\.-]+)\b(.+)?\z/;

    $self->die("no nroffer!?") unless $render;
    my @render_switches = $self->_collect_nroff_switches;

    if ( $switches ) {
        # Eliminate whitespace 
        $switches =~ s/\s//g;

        # Then separate the switches with a zero-width positive 
        # lookahead on the dash.
        #
        # See:
        # http://www.effectiveperlprogramming.com/blog/1411
        # for a good discussion of this technique

        push @render_switches, split(/(?=-)/, $switches);
        }

	$self->debug( "render is $render\n" );
	$self->debug( "render options are @render_switches\n" );

	require Symbol;
	require IPC::Open3;
	require IO::Handle;

	my $pid = IPC::Open3::open3(
		my $writer,
		my $reader,
		my $err = Symbol::gensym(),
		$render,
		@render_switches
		);

	$reader->autoflush(1);

	use IO::Select;
	my $selector = IO::Select->new( $reader );

	$self->debug( "Writing to pipe to $render\n" );

	my $offset = 0;
	my $chunk_size = 4096;
	my $length = length( ${ $self->{_text_ref} } );
	my $chunks = $length / $chunk_size;
	my $done;
	my $buffer;
	while( $offset <= $length ) {
		$self->debug( "Writing chunk $chunks\n" ); $chunks++;
		syswrite $writer, ${ $self->{_text_ref} }, $chunk_size, $offset
			or $self->die( $! );
		$offset += $chunk_size;
		$self->debug( "Checking read\n" );
		READ: {
			last READ unless $selector->can_read( 0.01 );
			$self->debug( "Reading\n" );
			my $bytes = sysread $reader, $buffer, 4096;
			$self->debug( "Read $bytes bytes\n" );
			$done .= $buffer;
			$self->debug( sprintf "Output is %d bytes\n",
				length $done
				);
			next READ;
			}
		}
	close $writer;
	$self->debug( "Done writing\n" );

	# read any leftovers
	$done .= do { local $/; <$reader> };
	$self->debug( sprintf "Done reading. Output is %d bytes\n",
		length $done
		);

	if( $? ) {
		$self->warn( "Error from pipe to $render!\n" );
		$self->debug( 'Error: ' . do { local $/; <$err> } );
		}


	close $reader;
	if( my $err = $? ) {
		$self->debug(
			"Nonzero exit ($?) while running `$render @render_switches`.\n" .
			"Falling back to Pod::Perldoc::ToPod\n"
			);
		return $self->_fallback_to_pod( @_ );
		}

	$self->debug( "Output:\n----\n$done\n----\n" );

	${ $self->{_text_ref} } = $done;

	return length ${ $self->{_text_ref} } ? SUCCESS : FAILED;
	}

sub parse_from_file {
	my( $self, $file, $outfh) = @_;

	# We have a pipeline of filters each affecting the reference
	# in $self->{_text_ref}
	$self->{_text_ref} = \my $output;

	$self->_parse_with_pod_man( $file );
	# so far, nroff is an external command so we ensure it worked
	my $result = $self->_filter_through_nroff;
	return $self->_fallback_to_pod( @_ ) unless $result == SUCCESS;

	$self->_post_nroff_processing;

	print { $outfh } $output or
		$self->die( "Can't print to $$self{__output_file}: $!" );

	return;
	}

sub _fallback_to_pod {
	my( $self, @args ) = @_;
	$self->warn( "Falling back to Pod because there was a problem!\n" );
	require Pod::Perldoc::ToPod;
	return  Pod::Perldoc::ToPod->new->parse_from_file(@_);
	}

# maybe there's a user setting we should check?
sub _get_tab_width { 4 }

sub _expand_tabs {
	my( $self ) = @_;

	my $tab_width = ' ' x $self->_get_tab_width;

	${ $self->{_text_ref} } =~ s/\t/$tab_width/g;
	}

sub _post_nroff_processing {
	my( $self ) = @_;

	if( $self->is_hpux ) {
	    $self->debug( "On HP-UX, I'm going to expand tabs for you\n" );
		# this used to be a pipe to `col -x` for HP-UX
		$self->_expand_tabs;
		}

	if( $self->{'__filter_nroff'} ) {
		$self->debug( "filter_nroff is set, so filtering\n" );
		$self->_remove_nroff_header;
		$self->_remove_nroff_footer;
		}
	else {
		$self->debug( "filter_nroff is not set, so not filtering\n" );
		}

	$self->_handle_unicode;

	return 1;
	}

# I don't think this does anything since there aren't two consecutive
# newlines in the Pod::Man output
sub _remove_nroff_header {
	my( $self ) = @_;
	$self->debug( "_remove_nroff_header is still a stub!\n" );
	return 1;

#  my @data = split /\n{2,}/, shift;
#  shift @data while @data and $data[0] !~ /\S/; # Go to header
#  shift @data if @data and $data[0] =~ /Contributed\s+Perl/; # Skip header
	}

# I don't think this does anything since there aren't two consecutive
# newlines in the Pod::Man output
sub _remove_nroff_footer {
	my( $self ) = @_;
	$self->debug( "_remove_nroff_footer is still a stub!\n" );
	return 1;
	${ $self->{_text_ref} } =~ s/\n\n+.*\w.*\Z//m;

#  my @data = split /\n{2,}/, shift;
#  pop @data if @data and $data[-1] =~ /^\w/; # Skip footer, like
        # 28/Jan/99 perl 5.005, patch 53 1
	}

sub _unicode_already_handled {
	my( $self ) = @_;

	$self->_have_groff_with_utf8 ||
	1  # so, we don't have a case that needs _handle_unicode
	;
	}

sub _handle_unicode {
# this is the job of preconv
# we don't need this with groff 1.20 and later.
	my( $self ) = @_;

	return 1 if $self->_unicode_already_handled;

	require Encode;

	# it's UTF-8 here, but we need character data
	my $text = Encode::decode( 'UTF-8', ${ $self->{_text_ref} } ) ;

# http://www.mail-archive.com/groff@gnu.org/msg01378.html
# http://linux.die.net/man/7/groff_char
# http://www.gnu.org/software/groff/manual/html_node/Using-Symbols.html
# http://lists.gnu.org/archive/html/groff/2011-05/msg00007.html
# http://www.simplicidade.org/notes/archives/2009/05/fixing_the_pod.html
# http://lists.freebsd.org/pipermail/freebsd-questions/2011-July/232239.html
	$text =~ s/(\P{ASCII})/
		sprintf '\\[u%04X]', ord $1
	     /eg;

	# should we encode?
	${ $self->{_text_ref} } = $text;
	}

1;

__END__

=head1 NAME

Pod::Perldoc::ToMan - let Perldoc render Pod as man pages

=head1 SYNOPSIS

  perldoc -o man Some::Modulename

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to use
Pod::Man and C<groff> for reading Pod pages.

The following options are supported:  center, date, fixed, fixedbold,
fixeditalic, fixedbolditalic, quotes, release, section

(Those options are explained in L<Pod::Man>.)

For example:

  perldoc -o man -w center:Pod Some::Modulename

=head1 CAVEAT

This module may change to use a different pod-to-nroff formatter class
in the future, and this may change what options are supported.

=head1 SEE ALSO

L<Pod::Man>, L<Pod::Perldoc>, L<Pod::Perldoc::ToNroff>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2011 brian d foy. All rights reserved.

Copyright (c) 2002,3,4 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut

                                                                                                             usr/share/perl/5.20.2/Pod/Perldoc/ToNroff.pm                                                        0100644 0000000 0000000 00000005336 12744441327 016712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToNroff;
use strict;
use warnings;
use parent qw(Pod::Perldoc::BaseTo);

use vars qw($VERSION);
$VERSION = '3.23';

# This is unlike ToMan.pm in that it emits the raw nroff source!

sub is_pageable        { 1 }  # well, if you ask for it...
sub write_with_binmode { 0 }
sub output_extension   { 'man' }

use Pod::Man ();

sub center          { shift->_perldoc_elem('center'         , @_) }
sub date            { shift->_perldoc_elem('date'           , @_) }
sub fixed           { shift->_perldoc_elem('fixed'          , @_) }
sub fixedbold       { shift->_perldoc_elem('fixedbold'      , @_) }
sub fixeditalic     { shift->_perldoc_elem('fixeditalic'    , @_) }
sub fixedbolditalic { shift->_perldoc_elem('fixedbolditalic', @_) }
sub quotes          { shift->_perldoc_elem('quotes'         , @_) }
sub release         { shift->_perldoc_elem('release'        , @_) }
sub section         { shift->_perldoc_elem('section'        , @_) }

sub new { return bless {}, ref($_[0]) || $_[0] }

sub parse_from_file {
  my $self = shift;
  my $file = $_[0];

  my @options =
    map {; $_, $self->{$_} }
      grep !m/^_/s,
        keys %$self
  ;

  defined(&Pod::Perldoc::DEBUG)
   and Pod::Perldoc::DEBUG()
   and print "About to call new Pod::Man ",
    $Pod::Man::VERSION ? "(v$Pod::Man::VERSION) " : '',
    "with options: ",
    @options ? "[@options]" : "(nil)", "\n";
  ;

  Pod::Man->new(@options)->parse_from_file(@_);
}

1;
__END__

=head1 NAME

Pod::Perldoc::ToNroff - let Perldoc convert Pod to nroff

=head1 SYNOPSIS

  perldoc -o nroff -d something.3 Some::Modulename

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to use
Pod::Man as a formatter class.

The following options are supported:  center, date, fixed, fixedbold,
fixeditalic, fixedbolditalic, quotes, release, section

Those options are explained in L<Pod::Man>.

For example:

  perldoc -o nroff -w center:Pod -d something.3 Some::Modulename

=head1 CAVEAT

This module may change to use a different pod-to-nroff formatter class
in the future, and this may change what options are supported.

=head1 SEE ALSO

L<Pod::Man>, L<Pod::Perldoc>, L<Pod::Perldoc::ToMan>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut

                                                                                                                                                                                                                                                                                                  usr/share/perl/5.20.2/Pod/Perldoc/ToPod.pm                                                          0100644 0000000 0000000 00000003647 12744441327 016365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToPod;
use strict;
use warnings;
use parent qw(Pod::Perldoc::BaseTo);

use vars qw($VERSION);
$VERSION = '3.23';

sub is_pageable        { 1 }
sub write_with_binmode { 0 }
sub output_extension   { 'pod' }

sub new { return bless {}, ref($_[0]) || $_[0] }

sub parse_from_file {
  my( $self, $in, $outfh ) = @_;

  open(IN, "<", $in) or $self->die( "Can't read-open $in: $!\nAborting" );

  my $cut_mode = 1;

  # A hack for finding things between =foo and =cut, inclusive
  local $_;
  while (<IN>) {
    if(  m/^=(\w+)/s ) {
      if($cut_mode = ($1 eq 'cut')) {
        print $outfh "\n=cut\n\n";
         # Pass thru the =cut line with some harmless
         #  (and occasionally helpful) padding
      }
    }
    next if $cut_mode;
    print $outfh $_ or $self->die( "Can't print to $outfh: $!" );
  }

  close IN or $self->die( "Can't close $in: $!" );
  return;
}

1;
__END__

=head1 NAME

Pod::Perldoc::ToPod - let Perldoc render Pod as ... Pod!

=head1 SYNOPSIS

  perldoc -opod Some::Modulename

(That's currently the same as the following:)

  perldoc -u Some::Modulename

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to display Pod source as
itself!  Pretty Zen, huh?

Currently this class works by just filtering out the non-Pod stuff from
a given input file.

=head1 SEE ALSO

L<Pod::Perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallencpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut

                                                                                         usr/share/perl/5.20.2/Pod/Perldoc/ToRtf.pm                                                          0100644 0000000 0000000 00000004145 12744441327 016370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToRtf;
use strict;
use warnings;
use parent qw( Pod::Simple::RTF );

use vars qw($VERSION);
$VERSION = '3.23';

sub is_pageable        { 0 }
sub write_with_binmode { 0 }
sub output_extension   { 'rtf' }

sub page_for_perldoc {
  my($self, $tempfile, $perldoc) = @_;
  return unless $perldoc->IS_MSWin32;

  my $rtf_pager = $ENV{'RTFREADER'} || 'write.exe';

  $perldoc->aside( "About to launch <\"$rtf_pager\" \"$tempfile\">\n" );

  return 1 if system( qq{"$rtf_pager"}, qq{"$tempfile"} ) == 0;
  return 0;
}

1;
__END__

=head1 NAME

Pod::Perldoc::ToRtf - let Perldoc render Pod as RTF

=head1 SYNOPSIS

  perldoc -o rtf Some::Modulename

=head1 DESCRIPTION

This is a "plug-in" class that allows Perldoc to use
Pod::Simple::RTF as a formatter class.

This is actually a Pod::Simple::RTF subclass, and inherits
all its options.

You have to have Pod::Simple::RTF installed (from the Pod::Simple dist),
or this module won't work.

If Perldoc is running under MSWin and uses this class as a formatter,
the output will be opened with F<write.exe> or whatever program is
specified in the environment variable C<RTFREADER>. For example, to
specify that RTF files should be opened the same as they are when you
double-click them, you would do C<set RTFREADER=start.exe> in your
F<autoexec.bat>.

Handy tip: put C<set PERLDOC=-ortf> in your F<autoexec.bat>
and that will set this class as the default formatter to run when
you do C<perldoc whatever>.

=head1 SEE ALSO

L<Pod::Simple::RTF>, L<Pod::Simple>, L<Pod::Perldoc>

=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Current maintainer: Mark Allen C<< <mallen@cpan.org> >>

Past contributions from:
brian d foy C<< <bdfoy@cpan.org> >>
Adriano R. Ferreira C<< <ferreira@cpan.org> >>,
Sean M. Burke C<< <sburke@cpan.org> >>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/perl/5.20.2/Pod/Perldoc/ToTerm.pm                                                         0100644 0000000 0000000 00000005661 12744441327 016550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Pod::Perldoc::ToTerm;
use strict;
use warnings;

use vars qw($VERSION);
$VERSION = '3.23';

use parent qw(Pod::Perldoc::BaseTo);

sub is_pageable        { 1 }
sub write_with_binmode { 0 }
sub output_extension   { 'txt' }

use Pod::Text::Termcap ();

sub alt       { shift->_perldoc_elem('alt'     , @_) }
sub indent    { shift->_perldoc_elem('indent'  , @_) }
sub loose     { shift->_perldoc_elem('loose'   , @_) }
sub quotes    { shift->_perldoc_elem('quotes'  , @_) }
sub sentence  { shift->_perldoc_elem('sentence', @_) }
sub width     { 
    my $self = shift;
    $self->_perldoc_elem('width' , @_) ||
    $self->_get_columns_from_manwidth  ||
	$self->_get_columns_from_stty      ||
	$self->_get_default_width;
}

sub _get_stty { `stty -a` }

sub _get_columns_from_stty {
	my $output = $_[0]->_get_stty;

	if(    $output =~ /\bcolumns\s+(\d+)/ )    { return $1; }
	elsif( $output =~ /;\s*(\d+)\s+columns;/ ) { return $1; }
	else                                       { return  0 }
	}

sub _get_columns_from_manwidth {
	my( $self ) = @_;

	return 0 unless defined $ENV{MANWIDTH};

	unless( $ENV{MANWIDTH} =~ m/\A\d+\z/ ) {
		$self->warn( "Ignoring non-numeric MANWIDTH ($ENV{MANWIDTH})\n" );
		return 0;
		}

	if( $ENV{MANWIDTH} == 0 ) {
		$self->warn( "Ignoring MANWIDTH of 0. Really? Why even run the program? :)\n" );
		return 0;
		}

	if( $ENV{MANWIDTH} =~ m/\A(\d+)\z/ ) { return $1 }

	return 0;
	}

sub _get_default_width {
	76
	}


sub new { return bless {}, ref($_[0]) || $_[0] }

sub parse_from_file {
  my $self = 