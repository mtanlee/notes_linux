nt_tree_output is true.  If :indent is set to false,
 * then both indentation and line feeds are removed from the result.
 *
 * :level  - Specifies the indentation level.  The amount of indentation
 * is equal to the (level * number_spaces) + number_spaces, where libxml
 * defaults the number of spaces to 2.  Thus a level of 0 results in
 * 2 spaces, level 1 results in 4 spaces, level 2 results in 6 spaces, etc.
 *
 * :encoding - Specifies the output encoding of the string.  It
 * defaults to XML::Encoding::UTF8.  To change it, use one of the
 * XML::Encoding encoding constants. */

static VALUE rxml_node_to_s(int argc, VALUE *argv, VALUE self)
{
  VALUE result = Qnil;
  VALUE options = Qnil;
  xmlNodePtr xnode;
  xmlCharEncodingHandlerPtr encodingHandler;
  xmlOutputBufferPtr output;

  int level = 0;
  int indent = 1;
  const char *xencoding = "UTF-8";

  rb_scan_args(argc, argv, "01", &options);

  if (!NIL_P(options))
  {
    VALUE rencoding, rindent, rlevel;
    Check_Type(options, T_HASH);
    rencoding = rb_hash_aref(options, ID2SYM(rb_intern("encoding")));
    rindent = rb_hash_aref(options, ID2SYM(rb_intern("indent")));
    rlevel = rb_hash_aref(options, ID2SYM(rb_intern("level")));

    if (rindent == Qfalse)
      indent = 0;

    if (rlevel != Qnil)
      level = NUM2INT(rlevel);

    if (rencoding != Qnil)
    {
      xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(rencoding));
      if (!xencoding)
        rb_raise(rb_eArgError, "Unknown encoding value: %d", NUM2INT(rencoding));
    }
  }

  encodingHandler = xmlFindCharEncodingHandler(xencoding);
  output = xmlAllocOutputBuffer(encodingHandler);

  xnode = rxml_get_xnode(self);

  xmlNodeDumpOutput(output, xnode->doc, xnode, level, indent, xencoding);
  xmlOutputBufferFlush(output);

#ifdef LIBXML2_NEW_BUFFER
  if (output->conv)
    result = rxml_new_cstr((const char*) xmlBufContent(output->conv), xencoding);
  else
    result = rxml_new_cstr((const char*) xmlBufContent(output->buffer), xencoding);
#else
  if (output->conv)
    result = rxml_new_cstr((const char*) output->conv->content, xencoding);
  else
    result = rxml_new_cstr((const char*) output->buffer->content, xencoding);
#endif

  xmlOutputBufferClose(output);
  
  return result;
}


/*
 * call-seq:
 *    node.each -> XML::Node
 *
 * Iterates over this node's children, including text
 * nodes, element nodes, etc.  If you wish to iterate
 * only over child elements, use XML::Node#each_element.
 *
 *  doc = XML::Document.new('model/books.xml')
 *  doc.root.each {|node| puts node}
 */
static VALUE rxml_node_each(VALUE self)
{
  xmlNodePtr xnode;
  xmlNodePtr xcurrent;
  xnode = rxml_get_xnode(self);

  xcurrent = xnode->children;

  while (xcurrent)
  {
    /* The user could remove this node, so first stache
       away the next node. */
    xmlNodePtr xnext = xcurrent->next;

    rb_yield(rxml_node_wrap(xcurrent));
    xcurrent = xnext;
  }
  return Qnil;
}

/*
 * call-seq:
 *    node.empty? -> (true|false)
 *
 * Determine whether this node is an empty or whitespace only text-node.
 */
static VALUE rxml_node_empty_q(VALUE self)
{
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);
  if (xnode == NULL)
    return (Qnil);

  return ((xmlIsBlankNode(xnode) == 1) ? Qtrue : Qfalse);
}


/*
 * call-seq:
 *    node.eql?(other_node) => (true|false)
 *
 * Test equality between the two nodes. Two nodes are equal
 * if they are the same node or have the same XML representation.*/
static VALUE rxml_node_eql_q(VALUE self, VALUE other)
{
  if(self == other)
  {
    return Qtrue;
  }
  else if (NIL_P(other))
  {
    return Qfalse;
  }
  else
  {
    VALUE self_xml;
    VALUE other_xml;

    if (rb_obj_is_kind_of(other, cXMLNode) == Qfalse)
      rb_raise(rb_eTypeError, "Nodes can only be compared against other nodes");

    self_xml = rxml_node_to_s(0, NULL, self);
    other_xml = rxml_node_to_s(0, NULL, other);
    return(rb_funcall(self_xml, rb_intern("=="), 1, other_xml));
  }
}

/*
 * call-seq:
 *    node.lang -> "string"
 *
 * Obtain the language set for this node, if any.
 * This is set in XML via the xml:lang attribute.
 */
static VALUE rxml_node_lang_get(VALUE self)
{
  xmlNodePtr xnode;
  xmlChar *lang;
  VALUE result = Qnil;

  xnode = rxml_get_xnode(self);
  lang = xmlNodeGetLang(xnode);

  if (lang)
  {
    result = rxml_new_cstr((const char*) lang, NULL);
    xmlFree(lang);
  }

  return (result);
}

// TODO node_lang_set should support setting back to nil

/*
 * call-seq:
 *    node.lang = "string"
 *
 * Set the language for this node. This affects the value
 * of the xml:lang attribute.
 */
static VALUE rxml_node_lang_set(VALUE self, VALUE lang)
{
  xmlNodePtr xnode;

  Check_Type(lang, T_STRING);
  xnode = rxml_get_xnode(self);
  xmlNodeSetLang(xnode, (xmlChar*) StringValuePtr(lang));

  return (Qtrue);
}

/*
 * call-seq:
 *    node.last -> XML::Node
 *
 * Obtain the last child node of this node, if any.
 */
static VALUE rxml_node_last_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);

  if (xnode->last)
    return (rxml_node_wrap(xnode->last));
  else
    return (Qnil);
}

/*
 * call-seq:
 *    node.line_num -> num
 *
 * Obtain the line number (in the XML document) that this
 * node was read from. If +default_line_numbers+ is set
 * false (the default), this method returns zero.
 */
static VALUE rxml_node_line_num(VALUE self)
{
  xmlNodePtr xnode;
  long line_num;
  xnode = rxml_get_xnode(self);

  if (!xmlLineNumbersDefaultValue)
    rb_warn(
        "Line numbers were not retained: use XML::Parser::default_line_numbers=true");

  line_num = xmlGetLineNo(xnode);
  if (line_num == -1)
    return (Qnil);
  else
    return (INT2NUM((long) line_num));
}

/*
 * call-seq:
 *    node.xlink? -> (true|false)
 *
 * Determine whether this node is an xlink node.
 */
static VALUE rxml_node_xlink_q(VALUE self)
{
  xmlNodePtr xnode;
  xlinkType xlt;

  xnode = rxml_get_xnode(self);
  xlt = xlinkIsLink(xnode->doc, xnode);

  if (xlt == XLINK_TYPE_NONE)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    node.xlink_type -> num
 *
 * Obtain the type identifier for this xlink, if applicable.
 * If this is not an xlink node (see +xlink?+), will return
 * nil.
 */
static VALUE rxml_node_xlink_type(VALUE self)
{
  xmlNodePtr xnode;
  xlinkType xlt;

  xnode = rxml_get_xnode(self);
  xlt = xlinkIsLink(xnode->doc, xnode);

  if (xlt == XLINK_TYPE_NONE)
    return (Qnil);
  else
    return (INT2NUM(xlt));
}

/*
 * call-seq:
 *    node.xlink_type_name -> "string"
 *
 * Obtain the type name for this xlink, if applicable.
 * If this is not an xlink node (see +xlink?+), will return
 * nil.
 */
static VALUE rxml_node_xlink_type_name(VALUE self)
{
  xmlNodePtr xnode;
  xlinkType xlt;

  xnode = rxml_get_xnode(self);
  xlt = xlinkIsLink(xnode->doc, xnode);

  switch (xlt)
  {
  case XLINK_TYPE_NONE:
    return (Qnil);
  case XLINK_TYPE_SIMPLE:
    return (rxml_new_cstr("simple", NULL));
  case XLINK_TYPE_EXTENDED:
    return (rxml_new_cstr("extended", NULL));
  case XLINK_TYPE_EXTENDED_SET:
    return (rxml_new_cstr("extended_set", NULL));
  default:
    rb_fatal("Unknowng xlink type, %d", xlt);
  }
}

/*
 * call-seq:
 *    node.name -> "string"
 *
 * Obtain this node's name.
 */
static VALUE rxml_node_name_get(VALUE self)
{
  xmlNodePtr xnode;
  const xmlChar *name;

  xnode = rxml_get_xnode(self);

  switch (xnode->type)
  {
  case XML_DOCUMENT_NODE:
#ifdef LIBXML_DOCB_ENABLED
    case XML_DOCB_DOCUMENT_NODE:
#endif
  case XML_HTML_DOCUMENT_NODE:
  {
    xmlDocPtr doc = (xmlDocPtr) xnode;
    name = doc->URL;
    break;
  }
  case XML_ATTRIBUTE_NODE:
  {
    xmlAttrPtr attr = (xmlAttrPtr) xnode;
    name = attr->name;
    break;
  }
  case XML_NAMESPACE_DECL:
  {
    xmlNsPtr ns = (xmlNsPtr) xnode;
    name = ns->prefix;
    break;
  }
  default:
    name = xnode->name;
    break;
  }

  if (xnode->name == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) name, NULL));
}

/*
 * call-seq:
 *    node.name = "string"
 *
 * Set this node's name.
 */
static VALUE rxml_node_name_set(VALUE self, VALUE name)
{
  xmlNodePtr xnode;
  const xmlChar *xname;

  Check_Type(name, T_STRING);
  xnode = rxml_get_xnode(self);
  xname = (const xmlChar*)StringValuePtr(name);

	/* Note: calling xmlNodeSetName() for a text node is ignored by libXML. */
  xmlNodeSetName(xnode, xname);

  return (Qtrue);
}

/*
 * call-seq:
 *    node.next -> XML::Node
 *
 * Returns the next sibling node if one exists.
 */
static VALUE rxml_node_next_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);

  if (xnode->next)
    return (rxml_node_wrap(xnode->next));
  else
    return (Qnil);
}

/*
 * call-seq:
 *    curr_node.next = node
 *
 * Adds the specified node as the next sibling of the current node.
 * If the node already exists in the document, it is first removed
 * from its existing context.  Any adjacent text nodes will be 
 * merged together, meaning the returned node may be different 
 * than the original node.
 */
static VALUE rxml_node_next_set(VALUE self, VALUE next)
{
  return rxml_node_modify_dom(self, next, xmlAddNextSibling);
}

/*
 * call-seq:
 *    node.parent -> XML::Node
 *
 * Obtain this node's parent node, if any.
 */
static VALUE rxml_node_parent_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);

  if (xnode->parent)
    return (rxml_node_wrap(xnode->parent));
  else
    return (Qnil);
}

/*
 * call-seq:
 *    node.path -> path
 *
 * Obtain this node's path.
 */
static VALUE rxml_node_path(VALUE self)
{
  xmlNodePtr xnode;
  xmlChar *path;

  xnode = rxml_get_xnode(self);
  path = xmlGetNodePath(xnode);

  if (path == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) path, NULL));
}

/*
 * call-seq:
 *    node.pointer -> XML::NodeSet
 *
 * Evaluates an XPointer expression relative to this node.
 */
static VALUE rxml_node_pointer(VALUE self, VALUE xptr_str)
{
  return (rxml_xpointer_point2(self, xptr_str));
}

/*
 * call-seq:
 *    node.prev -> XML::Node
 *
 * Obtain the previous sibling, if any.
 */
static VALUE rxml_node_prev_get(VALUE self)
{
  xmlNodePtr xnode;
  xmlNodePtr node;
  xnode = rxml_get_xnode(self);

  switch (xnode->type)
  {
  case XML_DOCUMENT_NODE:
#ifdef LIBXML_DOCB_ENABLED
    case XML_DOCB_DOCUMENT_NODE:
#endif
  case XML_HTML_DOCUMENT_NODE:
  case XML_NAMESPACE_DECL:
    node = NULL;
    break;
  case XML_ATTRIBUTE_NODE:
  {
    xmlAttrPtr attr = (xmlAttrPtr) xnode;
    node = (xmlNodePtr) attr->prev;
  }
    break;
  default:
    node = xnode->prev;
    break;
  }

  if (node == NULL)
    return (Qnil);
  else
    return (rxml_node_wrap(node));
}

/*
 * call-seq:
 *    curr_node.prev = node
 *
 * Adds the specified node as the previous sibling of the current node.
 * If the node already exists in the document, it is first removed
 * from its existing context.  Any adjacent text nodes will be 
 * merged together, meaning the returned node may be different 
 * than the original node.
 */
static VALUE rxml_node_prev_set(VALUE self, VALUE prev)
{
  return rxml_node_modify_dom(self, prev, xmlAddPrevSibling);
}

/*
 * call-seq:
 *    node.attributes -> attributes
 *
 * Returns the XML::Attributes for this node.
 */
static VALUE rxml_node_attributes_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);
  return rxml_attributes_new(xnode);
}

/*
 * call-seq:
 *    node.property("name") -> "string"
 *    node["name"]          -> "string"
 *
 * Obtain the named property.
 */
static VALUE rxml_node_attribute_get(VALUE self, VALUE name)
{
  VALUE attributes = rxml_node_attributes_get(self);
  return rxml_attributes_attribute_get(attributes, name);
}

/*
 * call-seq:
 *    node["name"] = "string"
 *
 * Set the named property.
 */
static VALUE rxml_node_property_set(VALUE self, VALUE name, VALUE value)
{
  VALUE attributes = rxml_node_attributes_get(self);
  return rxml_attributes_attribute_set(attributes, name, value);
}

/*
 * call-seq:
 *    node.remove! -> node
 *
 * Removes this node and its children from the document tree by setting its document,
 * parent and siblings to nil.  You can add the returned node back into a document.
 * Otherwise, the node will be freed once any references to it go out of scope. 
 */

static VALUE rxml_node_remove_ex(VALUE self)
{
  xmlNodePtr xnode, xresult;
  xnode = rxml_get_xnode(self);

  /* First unlink the node from its parent. */
  xmlUnlinkNode(xnode);

  /* Now copy the node we want to remove and make the
     current Ruby object point to it.  We do this because
     a node has a number of dependencies on its parent
     document - its name (if using a dictionary), entities,
     namespaces, etc.  For a node to live on its own, it
     needs to get its own copies of this information.*/
  xresult = xmlDocCopyNode(xnode, NULL, 1);
  
  /* Now free the original node. */
  xmlFreeNode(xnode);

  /* Now wrap the new node */
  RDATA(self)->data = xresult;
  xresult->_private = (void*) self;

  /* Now return the removed node so the user can
     do something with it.*/
  return self;
}

/*
 * call-seq:
 *    curr_node.sibling = node
 *
 * Adds the specified node as the end of the current node's list
 * of siblings.  If the node already exists in the document, it 
 * is first removed from its existing context.  Any adjacent text
 * nodes will be  merged together, meaning the returned node may
 * be different than the original node.
 */
static VALUE rxml_node_sibling_set(VALUE self, VALUE sibling)
{
  return rxml_node_modify_dom(self, sibling, xmlAddSibling);
}

/*
 * call-seq:
 *    text_node.output_escaping?      -> (true|false)
 *    element_node.output_escaping?   -> (true|false|nil)
 *    attribute_node.output_escaping? -> (true|false|nil)
 *    other_node.output_escaping?     -> (nil)
 *
 * Determine whether this node escapes it's output or not.
 *
 * Text nodes return only +true+ or +false+.  Element and attribute nodes
 * examine their immediate text node children to determine the value.
 * Any other type of node always returns +nil+.
 *
 * If an element or attribute node has at least one immediate child text node 
 * and all the immediate text node children have the same +output_escaping?+
 * value, that value is returned.  Otherwise, +nil+ is returned.
 */
static VALUE rxml_node_output_escaping_q(VALUE self)
{
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);

  switch (xnode->type) {
  case XML_TEXT_NODE:
    return xnode->name==xmlStringTextNoenc ? Qfalse : Qtrue;
  case XML_ELEMENT_NODE:
  case XML_ATTRIBUTE_NODE:
    {
      xmlNodePtr tmp = xnode->children;
      const xmlChar *match = NULL;

      /* Find the first text node and use it as the reference. */
      while (tmp && tmp->type != XML_TEXT_NODE)
        tmp = tmp->next;
      if (! tmp)
        return Qnil;
      match = tmp->name;

      /* Walk the remaining text nodes until we run out or one doesn't match. */
      while (tmp && (tmp->type != XML_TEXT_NODE || match == tmp->name))
        tmp = tmp->next;

      /* We're left with either the mismatched node or the aggregate result. */
      return tmp ? Qnil : (match==xmlStringTextNoenc ? Qfalse : Qtrue);
    }
    break;
  default:
    return Qnil;
  }
}

/*
 * call-seq:
 *    text_node.output_escaping = true|false
 *    element_node.output_escaping = true|false
 *    attribute_node.output_escaping = true|false
 *
 * Controls whether this text node or the immediate text node children of an
 * element or attribute node escapes their output.  Any other type of node
 * will simply ignore this operation.
 *
 * Text nodes which are added to an element or attribute node will be affected
 * by any previous setting of this property.
 */
static VALUE rxml_node_output_escaping_set(VALUE self, VALUE bool)
{
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);

  switch (xnode->type) {
  case XML_TEXT_NODE:
    xnode->name = (bool!=Qfalse && bool!=Qnil) ? xmlStringText : xmlStringTextNoenc;
    break;
  case XML_ELEMENT_NODE:
  case XML_ATTRIBUTE_NODE:
    {
      const xmlChar *name = (bool!=Qfalse && bool!=Qnil) ? xmlStringText : xmlStringTextNoenc;
      xmlNodePtr tmp;
      for (tmp = xnode->children; tmp; tmp = tmp->next)
        if (tmp->type == XML_TEXT_NODE)
          tmp->name = name;
    }
    break;
  default:
    return Qnil;
  }

  return (bool!=Qfalse && bool!=Qnil) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    node.space_preserve -> (true|false)
 *
 * Determine whether this node preserves whitespace.
 */
static VALUE rxml_node_space_preserve_get(VALUE self)
{
  xmlNodePtr xnode;

  xnode = rxml_get_xnode(self);
  return (INT2NUM(xmlNodeGetSpacePreserve(xnode)));
}

/*
 * call-seq:
 *    node.space_preserve = true|false
 *
 * Control whether this node preserves whitespace.
 */
static VALUE rxml_node_space_preserve_set(VALUE self, VALUE bool)
{
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);

  if (TYPE(bool) == T_FALSE)
    xmlNodeSetSpacePreserve(xnode, 0);
  else
    xmlNodeSetSpacePreserve(xnode, 1);

  return (Qnil);
}

/*
 * call-seq:
 *    node.type -> num
 *
 * Obtain this node's type identifier.
 */
static VALUE rxml_node_type(VALUE self)
{
  xmlNodePtr xnode;
  xnode = rxml_get_xnode(self);
  return (INT2NUM(xnode->type));
}

/*
 * call-seq:
 *    node.copy -> XML::Node
 *
 * Creates a copy of this node.  To create a
 * shallow copy set the deep parameter to false.
 * To create a deep copy set the deep parameter
 * to true.
 *
 */
static VALUE rxml_node_copy(VALUE self, VALUE deep)
{
  xmlNodePtr xnode;
  xmlNodePtr xcopy;
  int recursive = (deep == Qnil || deep == Qfalse) ? 0 : 1;
  xnode = rxml_get_xnode(self);

  xcopy = xmlCopyNode(xnode, recursive);

  if (xcopy)
    return rxml_node_wrap(xcopy);
  else
    return Qnil;
}

void rxml_init_node(void)
{
  /* Register callback for main thread */
  xmlDeregisterNodeDefault(rxml_node_deregisterNode);

  /* Register callback for all other threads */
  xmlThrDefDeregisterNodeDefault(rxml_node_deregisterNode);

  cXMLNode = rb_define_class_under(mXML, "Node", rb_cObject);

  rb_define_const(cXMLNode, "SPACE_DEFAULT", INT2NUM(0));
  rb_define_const(cXMLNode, "SPACE_PRESERVE", INT2NUM(1));
  rb_define_const(cXMLNode, "SPACE_NOT_INHERIT", INT2NUM(-1));
  rb_define_const(cXMLNode, "XLINK_ACTUATE_AUTO", INT2NUM(1));
  rb_define_const(cXMLNode, "XLINK_ACTUATE_NONE", INT2NUM(0));
  rb_define_const(cXMLNode, "XLINK_ACTUATE_ONREQUEST", INT2NUM(2));
  rb_define_const(cXMLNode, "XLINK_SHOW_EMBED", INT2NUM(2));
  rb_define_const(cXMLNode, "XLINK_SHOW_NEW", INT2NUM(1));
  rb_define_const(cXMLNode, "XLINK_SHOW_NONE", INT2NUM(0));
  rb_define_const(cXMLNode, "XLINK_SHOW_REPLACE", INT2NUM(3));
  rb_define_const(cXMLNode, "XLINK_TYPE_EXTENDED", INT2NUM(2));
  rb_define_const(cXMLNode, "XLINK_TYPE_EXTENDED_SET", INT2NUM(3));
  rb_define_const(cXMLNode, "XLINK_TYPE_NONE", INT2NUM(0));
  rb_define_const(cXMLNode, "XLINK_TYPE_SIMPLE", INT2NUM(1));

  rb_define_const(cXMLNode, "ELEMENT_NODE", INT2FIX(XML_ELEMENT_NODE));
  rb_define_const(cXMLNode, "ATTRIBUTE_NODE", INT2FIX(XML_ATTRIBUTE_NODE));
  rb_define_const(cXMLNode, "TEXT_NODE", INT2FIX(XML_TEXT_NODE));
  rb_define_const(cXMLNode, "CDATA_SECTION_NODE", INT2FIX(XML_CDATA_SECTION_NODE));
  rb_define_const(cXMLNode, "ENTITY_REF_NODE", INT2FIX(XML_ENTITY_REF_NODE));
  rb_define_const(cXMLNode, "ENTITY_NODE", INT2FIX(XML_ENTITY_NODE));
  rb_define_const(cXMLNode, "PI_NODE", INT2FIX(XML_PI_NODE));
  rb_define_const(cXMLNode, "COMMENT_NODE", INT2FIX(XML_COMMENT_NODE));
  rb_define_const(cXMLNode, "DOCUMENT_NODE", INT2FIX(XML_DOCUMENT_NODE));
  rb_define_const(cXMLNode, "DOCUMENT_TYPE_NODE", INT2FIX(XML_DOCUMENT_TYPE_NODE));
  rb_define_const(cXMLNode, "DOCUMENT_FRAG_NODE", INT2FIX(XML_DOCUMENT_FRAG_NODE));
  rb_define_const(cXMLNode, "NOTATION_NODE", INT2FIX(XML_NOTATION_NODE));
  rb_define_const(cXMLNode, "HTML_DOCUMENT_NODE", INT2FIX(XML_HTML_DOCUMENT_NODE));
  rb_define_const(cXMLNode, "DTD_NODE", INT2FIX(XML_DTD_NODE));
  rb_define_const(cXMLNode, "ELEMENT_DECL", INT2FIX(XML_ELEMENT_DECL));
  rb_define_const(cXMLNode, "ATTRIBUTE_DECL", INT2FIX(XML_ATTRIBUTE_DECL));
  rb_define_const(cXMLNode, "ENTITY_DECL", INT2FIX(XML_ENTITY_DECL));
  rb_define_const(cXMLNode, "NAMESPACE_DECL", INT2FIX(XML_NAMESPACE_DECL));
  rb_define_const(cXMLNode, "XINCLUDE_START", INT2FIX(XML_XINCLUDE_START));
  rb_define_const(cXMLNode, "XINCLUDE_END", INT2FIX(XML_XINCLUDE_END));

#ifdef LIBXML_DOCB_ENABLED
  rb_define_const(cXMLNode, "DOCB_DOCUMENT_NODE", INT2FIX(XML_DOCB_DOCUMENT_NODE));
#else
  rb_define_const(cXMLNode, "DOCB_DOCUMENT_NODE", Qnil);
#endif

  rb_define_singleton_method(cXMLNode, "new_cdata", rxml_node_new_cdata, -1);
  rb_define_singleton_method(cXMLNode, "new_comment", rxml_node_new_comment, -1);
  rb_define_singleton_method(cXMLNode, "new_pi", rxml_node_new_pi, -1);
  rb_define_singleton_method(cXMLNode, "new_text", rxml_node_new_text, 1);

  /* Initialization */
  rb_define_alloc_func(cXMLNode, rxml_node_alloc);
  rb_define_method(cXMLNode, "initialize", rxml_node_initialize, -1);

  /* Traversal */
  rb_include_module(cXMLNode, rb_mEnumerable);
  rb_define_method(cXMLNode, "[]", rxml_node_attribute_get, 1);
  rb_define_method(cXMLNode, "each", rxml_node_each, 0);
  rb_define_method(cXMLNode, "first", rxml_node_first_get, 0);
  rb_define_method(cXMLNode, "last", rxml_node_last_get, 0);
  rb_define_method(cXMLNode, "next", rxml_node_next_get, 0);
  rb_define_method(cXMLNode, "parent", rxml_node_parent_get, 0);
  rb_define_method(cXMLNode, "prev", rxml_node_prev_get, 0);

  /* Modification */
  rb_define_method(cXMLNode, "[]=", rxml_node_property_set, 2);
  rb_define_method(cXMLNode, "<<", rxml_node_content_add, 1);
  rb_define_method(cXMLNode, "sibling=", rxml_node_sibling_set, 1);
  rb_define_method(cXMLNode, "next=", rxml_node_next_set, 1);
  rb_define_method(cXMLNode, "prev=", rxml_node_prev_set, 1);

  /* Rest of the node api */
  rb_define_method(cXMLNode, "attributes", rxml_node_attributes_get, 0);
  rb_define_method(cXMLNode, "base_uri", rxml_node_base_uri_get, 0);
  rb_define_method(cXMLNode, "base_uri=", rxml_node_base_uri_set, 1);
  rb_define_method(cXMLNode, "blank?", rxml_node_empty_q, 0);
  rb_define_method(cXMLNode, "copy", rxml_node_copy, 1);
  rb_define_method(cXMLNode, "content", rxml_node_content_get, 0);
  rb_define_method(cXMLNode, "content=", rxml_node_content_set, 1);
  rb_define_method(cXMLNode, "content_stripped", rxml_node_content_stripped_get, 0);
  rb_define_method(cXMLNode, "debug", rxml_node_debug, 0);
  rb_define_method(cXMLNode, "doc", rxml_node_doc, 0);
  rb_define_method(cXMLNode, "empty?", rxml_node_empty_q, 0);
  rb_define_method(cXMLNode, "eql?", rxml_node_eql_q, 1);
  rb_define_method(cXMLNode, "lang", rxml_node_lang_get, 0);
  rb_define_method(cXMLNode, "lang=", rxml_node_lang_set, 1);
  rb_define_method(cXMLNode, "line_num", rxml_node_line_num, 0);
  rb_define_method(cXMLNode, "name", rxml_node_name_get, 0);
  rb_define_method(cXMLNode, "name=", rxml_node_name_set, 1);
  rb_define_method(cXMLNode, "node_type", rxml_node_type, 0);
  rb_define_method(cXMLNode, "output_escaping?", rxml_node_output_escaping_q, 0);
  rb_define_method(cXMLNode, "output_escaping=", rxml_node_output_escaping_set, 1);
  rb_define_method(cXMLNode, "path", rxml_node_path, 0);
  rb_define_method(cXMLNode, "pointer", rxml_node_pointer, 1);
  rb_define_method(cXMLNode, "remove!", rxml_node_remove_ex, 0);
  rb_define_method(cXMLNode, "space_preserve", rxml_node_space_preserve_get, 0);
  rb_define_method(cXMLNode, "space_preserve=", rxml_node_space_preserve_set, 1);
  rb_define_method(cXMLNode, "to_s", rxml_node_to_s, -1);
  rb_define_method(cXMLNode, "xlink?", rxml_node_xlink_q, 0);
  rb_define_method(cXMLNode, "xlink_type", rxml_node_xlink_type, 0);
  rb_define_method(cXMLNode, "xlink_type_name", rxml_node_xlink_type_name, 0);

  rb_define_alias(cXMLNode, "==", "eql?");
}
                                                                                                                              ruby_xml_node.h                                                                                     0100644 0001750 0001750 00000000404 12566211276 044207  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_NODE__
#define __RXML_NODE__

extern VALUE cXMLNode;

void rxml_init_node(void);
void rxml_node_mark(xmlNodePtr xnode);
VALUE rxml_node_wrap(xmlNodePtr xnode);
#endif
                                                                                                                                                                                                                                                            ruby_xml_parser.c                                                                                   0100644 0001750 0001750 00000005040 12566211276 044552  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include <stdarg.h>
#include "ruby_libxml.h"

/*
 * Document-class: LibXML::XML::Parser
 *
 * The XML::Parser provides a tree based API for processing
 * xml documents, in contract to XML::Reader's stream
 * based api and XML::SaxParser callback based API.
 *
 * As a result, parsing a document creates an in-memory document object
 * that consist of any number of XML::Node instances.  This is simple
 * and powerful model, but has the major limitation that the size of
 * the document that can be processed is limited by the amount of
 * memory available.  In such cases, it is better to use the XML::Reader.
 *
 * Using the parser is simple:
 *
 *   parser = XML::Parser.file('my_file')
 *   doc = parser.parse
 *
 * You can also parse documents (see XML::Parser.document), 
 * strings (see XML::Parser.string) and io objects (see
 * XML::Parser.io).
 */

VALUE cXMLParser;
static ID CONTEXT_ATTR;

/*
 * call-seq:
 *    parser.initialize(context) -> XML::Parser
 *
 * Creates a new XML::Parser from the specified 
 * XML::Parser::Context.
 */
static VALUE rxml_parser_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE context = Qnil;

  rb_scan_args(argc, argv, "01", &context);

  if (context == Qnil)
  {
    rb_warn("Passing no parameters to XML::Parser.new is deprecated.  Pass an instance of XML::Parser::Context instead.");
    context = rb_class_new_instance(0, NULL, cXMLParserContext);
  }

  rb_ivar_set(self, CONTEXT_ATTR, context);
  return self;
}

/*
 * call-seq:
 *    parser.parse -> XML::Document
 *
 * Parse the input XML and create an XML::Document with
 * it's content. If an error occurs, XML::Parser::ParseError
 * is thrown.
 */
static VALUE rxml_parser_parse(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  VALUE context = rb_ivar_get(self, CONTEXT_ATTR);
  
  Data_Get_Struct(context, xmlParserCtxt, ctxt);

  if ((xmlParseDocument(ctxt) == -1 || !ctxt->wellFormed) && ! ctxt->recovery)
  {
    if (ctxt->myDoc)
      xmlFreeDoc(ctxt->myDoc);
    rxml_raise(&ctxt->lastError);
  }

  rb_funcall(context, rb_intern("close"), 0);

  return rxml_document_wrap(ctxt->myDoc);
}

void rxml_init_parser(void)
{
  cXMLParser = rb_define_class_under(mXML, "Parser", rb_cObject);

  /* Atributes */
  CONTEXT_ATTR = rb_intern("@context");
  rb_define_attr(cXMLParser, "input", 1, 0);
  rb_define_attr(cXMLParser, "context", 1, 0);

  /* Instance Methods */
  rb_define_method(cXMLParser, "initialize", rxml_parser_initialize, -1);
  rb_define_method(cXMLParser, "parse", rxml_parser_parse, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ruby_xml_parser.h                                                                                   0100644 0001750 0001750 00000000336 12566211276 044562  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_PARSER__
#define __RXML_PARSER__

#define MAX_LIBXML_FEATURES_LEN 50

extern VALUE cXMLParser;

void rxml_init_parser();

#endif
                                                                                                                                                                                                                                                                                                  ruby_xml_parser_context.c                                                                           0100644 0001750 0001750 00000062433 12566211276 046327  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_parser_context.h"

VALUE cXMLParserContext;
static ID IO_ATTR;

/*
 * Document-class: LibXML::XML::Parser::Context
 *
 * The XML::Parser::Context class provides in-depth control over how
 * a document is parsed.
 */

static void rxml_parser_context_free(xmlParserCtxtPtr ctxt)
{
  xmlFreeParserCtxt(ctxt);
}

static VALUE rxml_parser_context_wrap(xmlParserCtxtPtr ctxt)
{
  return Data_Wrap_Struct(cXMLParserContext, NULL, rxml_parser_context_free, ctxt);
}


static VALUE rxml_parser_context_alloc(VALUE klass)
{
  xmlParserCtxtPtr ctxt = xmlNewParserCtxt();
  return Data_Wrap_Struct(klass, NULL, rxml_parser_context_free, ctxt);
}

/* call-seq:
 *    XML::Parser::Context.document(document) -> XML::Parser::Context
 *
 * Creates a new parser context based on the specified document.
 *
 * Parameters:
 *
 *  document - An XML::Document instance.
 */
static VALUE rxml_parser_context_document(VALUE klass, VALUE document)
{
  xmlParserCtxtPtr ctxt;
  xmlDocPtr xdoc;
  xmlChar *buffer; 
  int length;

  if (rb_obj_is_kind_of(document, cXMLDocument) == Qfalse)
    rb_raise(rb_eTypeError, "Must pass an XML::Document object");

  Data_Get_Struct(document, xmlDoc, xdoc);
  xmlDocDumpFormatMemoryEnc(xdoc, &buffer, &length, xdoc->encoding, 0);

  ctxt = xmlCreateDocParserCtxt(buffer);

  if (!ctxt)
    rxml_raise(&xmlLastError);

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  xmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  return rxml_parser_context_wrap(ctxt);
}

/* call-seq:
 *    XML::Parser::Context.file(file) -> XML::Parser::Context
 *
 * Creates a new parser context based on the specified file or uri.
 *
 * Parameters:
 *
 *  file - A filename or uri.
*/
static VALUE rxml_parser_context_file(VALUE klass, VALUE file)
{
  xmlParserCtxtPtr ctxt = xmlCreateURLParserCtxt(StringValuePtr(file), 0);

  if (!ctxt)
    rxml_raise(&xmlLastError);

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  xmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  return rxml_parser_context_wrap(ctxt);
}

/* call-seq:
 *    XML::Parser::Context.string(string) -> XML::Parser::Context
 *
 * Creates a new parser context based on the specified string.
 *
 * Parameters:
 *
 *  string - A string that contains the data to parse.
*/
static VALUE rxml_parser_context_string(VALUE klass, VALUE string)
{
  xmlParserCtxtPtr ctxt;
  Check_Type(string, T_STRING);

  if (RSTRING_LEN(string) == 0)
    rb_raise(rb_eArgError, "Must specify a string with one or more characters");

  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(string),
                                   RSTRING_LEN(string));
  
  if (!ctxt)
    rxml_raise(&xmlLastError);

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  xmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  return rxml_parser_context_wrap(ctxt);
}

/* call-seq:
 *    XML::Parser::Context.io(io) -> XML::Parser::Context
 *
 * Creates a new parser context based on the specified io object.
 *
 * Parameters:
 *
 *  io - A ruby IO object.
*/
static VALUE rxml_parser_context_io(VALUE klass, VALUE io)
{
  VALUE result;
  xmlParserCtxtPtr ctxt;
  xmlParserInputBufferPtr input;
  xmlParserInputPtr stream;

  if (NIL_P(io))
    rb_raise(rb_eTypeError, "Must pass in an IO object");

  input = xmlParserInputBufferCreateIO((xmlInputReadCallback) rxml_read_callback, NULL,
                                       (void*)io, XML_CHAR_ENCODING_NONE);
    
  ctxt = xmlNewParserCtxt();

  if (!ctxt)
  {
    xmlFreeParserInputBuffer(input);
    rxml_raise(&xmlLastError);
  }

  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and 
     xmlCtxtUseOptionsInternal (called below) initialize slightly different
     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt
     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */
  xmlCtxtUseOptions(ctxt, rxml_libxml_default_options());

  stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);

  if (!stream)
  {
    xmlFreeParserInputBuffer(input);
    xmlFreeParserCtxt(ctxt);
    rxml_raise(&xmlLastError);
  }
  inputPush(ctxt, stream);
  result = rxml_parser_context_wrap(ctxt);

  /* Attach io object to parser so it won't get freed.*/
  rb_ivar_set(result, IO_ATTR, io);

  return result;
}

/*
 * call-seq:
 *    context.base_uri -> "http:://libxml.org"
 *
 * Obtain the base url for this parser context.
 */
static VALUE rxml_parser_context_base_uri_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->input && ctxt->input->filename)
    return rxml_new_cstr(ctxt->input->filename, ctxt->encoding);
  else
    return Qnil;
}

/*
 * call-seq:
 *    context.base_uri = "http:://libxml.org"
 *
 * Sets the base url for this parser context.
 */
static VALUE rxml_parser_context_base_uri_set(VALUE self, VALUE url)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  Check_Type(url, T_STRING);

  if (ctxt->input && !ctxt->input->filename)
  {
    const xmlChar * xurl = StringValuePtr(url);
    ctxt->input->filename = (char *) xmlStrdup(xurl);
  }
  return self;
}

/*
 * call-seq:
 *    context.close -> nil
 *
 * Closes the underlying input streams.  This is useful when parsing a large amount of
 * files and you want to close the files without relying on Ruby's garbage collector
 * to run.
 */
static VALUE rxml_parser_context_close(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  xmlParserInputPtr xinput;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  while ((xinput = inputPop(ctxt)) != NULL)
  {
	 xmlFreeInputStream(xinput);
  }
  return Qnil;
}

/*
 * call-seq:
 *    context.data_directory -> "dir"
 *
 * Obtain the data directory associated with this context.
 */
static VALUE rxml_parser_context_data_directory_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->directory == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr(ctxt->directory, ctxt->encoding));
}

/*
 * call-seq:
 *    context.depth -> num
 *
 * Obtain the depth of this context.
 */
static VALUE rxml_parser_context_depth_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->depth));
}

/*
 * call-seq:
 *    context.disable_cdata? -> (true|false)
 *
 * Determine whether CDATA nodes will be created in this context.
 */
static VALUE rxml_parser_context_disable_cdata_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  /* LibXML controls this internally with the default SAX handler. */
  if (ctxt->sax && ctxt->sax->cdataBlock)
    return (Qfalse);
  else
    return (Qtrue);
}

/*
 * call-seq:
 *    context.disable_cdata = (true|false)
 *
 * Control whether CDATA nodes will be created in this context.
 */
static VALUE rxml_parser_context_disable_cdata_set(VALUE self, VALUE bool)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->sax == NULL)
    rb_raise(rb_eRuntimeError, "Sax handler is not yet set");

  /* LibXML controls this internally with the default SAX handler. */ 
  if (bool)
    ctxt->sax->cdataBlock = NULL;
  else
    ctxt->sax->cdataBlock = xmlDefaultSAXHandler.cdataBlock;

  return bool;
}

/*
 * call-seq:
 *    context.disable_sax? -> (true|false)
 *
 * Determine whether SAX-based processing is disabled
 * in this context.
 */
static VALUE rxml_parser_context_disable_sax_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->disableSAX)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.docbook? -> (true|false)
 *
 * Determine whether this is a docbook context.
 */
static VALUE rxml_parser_context_docbook_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->html == 2) // TODO check this
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.encoding -> XML::Encoding::UTF_8
 *
 * Obtain the character encoding identifier used in
 * this context.
 */
static VALUE rxml_parser_context_encoding_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);
  return INT2NUM(xmlParseCharEncoding(ctxt->encoding));
}

/*
 * call-seq:
 *    context.encoding = XML::Encoding::UTF_8
 *
 * Sets the character encoding for this context.
 */
static VALUE rxml_parser_context_encoding_set(VALUE self, VALUE encoding)
{
  xmlParserCtxtPtr ctxt;
  int result;
  const char* xencoding = xmlGetCharEncodingName((xmlCharEncoding)NUM2INT(encoding));
  xmlCharEncodingHandlerPtr hdlr = xmlFindCharEncodingHandler(xencoding);
  
  if (!hdlr)
    rb_raise(rb_eArgError, "Unknown encoding: %i", NUM2INT(encoding));

  Data_Get_Struct(self, xmlParserCtxt, ctxt);
  result = xmlSwitchToEncoding(ctxt, hdlr);

  if (result != 0)
    rxml_raise(&xmlLastError);

  if (ctxt->encoding != NULL)
    xmlFree((xmlChar *) ctxt->encoding);

  ctxt->encoding = xmlStrdup((const xmlChar *) xencoding);
  return self;
}

/*
 * call-seq:
 *    context.errno -> num
 *
 * Obtain the last-error number in this context.
 */
static VALUE rxml_parser_context_errno_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->errNo));
}

/*
 * call-seq:
 *    context.html? -> (true|false)
 *
 * Determine whether this is an html context.
 */
static VALUE rxml_parser_context_html_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->html == 1)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.max_num_streams -> num
 *
 * Obtain the limit on the number of IO streams opened in
 * this context.
 */
static VALUE rxml_parser_context_io_max_num_streams_get(VALUE self)
{
  // TODO alias to max_streams and dep this?
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->inputMax));
}

/*
 * call-seq:
 *    context.num_streams -> "dir"
 *
 * Obtain the actual number of IO streams in this
 * context.
 */
static VALUE rxml_parser_context_io_num_streams_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->inputNr));
}

/*
 * call-seq:
 *    context.keep_blanks? -> (true|false)
 *
 * Determine whether parsers in this context retain
 * whitespace.
 */
static VALUE rxml_parser_context_keep_blanks_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->keepBlanks)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.name_depth -> num
 *
 * Obtain the name depth for this context.
 */
static VALUE rxml_parser_context_name_depth_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->nameNr));
}

/*
 * call-seq:
 *    context.name_depth_max -> num
 *
 * Obtain the maximum name depth for this context.
 */
static VALUE rxml_parser_context_name_depth_max_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->nameMax));
}

/*
 * call-seq:
 *    context.name_node -> "name"
 *
 * Obtain the name node for this context.
 */
static VALUE rxml_parser_context_name_node_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->name == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) ctxt->name, ctxt->encoding));
}

/*
 * call-seq:
 *    context.name_tab -> ["name", ..., "name"]
 *
 * Obtain the name table for this context.
 */
static VALUE rxml_parser_context_name_tab_get(VALUE self)
{
  int i;
  xmlParserCtxtPtr ctxt;
  VALUE tab_ary;

  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->nameTab == NULL)
    return (Qnil);

  tab_ary = rb_ary_new();

  for (i = (ctxt->nameNr - 1); i >= 0; i--)
  {
    if (ctxt->nameTab[i] == NULL)
      continue;
    else
      rb_ary_push(tab_ary, rxml_new_cstr((const char*) ctxt->nameTab[i], ctxt->encoding));
  }

  return (tab_ary);
}

/*
 * call-seq:
 *    context.node_depth -> num
 *
 * Obtain the node depth for this context.
 */
static VALUE rxml_parser_context_node_depth_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->nodeNr));
}

/*
 * call-seq:
 *    context.node -> node
 *
 * Obtain the root node of this context.
 */
static VALUE rxml_parser_context_node_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->node == NULL)
    return (Qnil);
  else
    return (rxml_node_wrap(ctxt->node));
}

/*
 * call-seq:
 *    context.node_depth_max -> num
 *
 * Obtain the maximum node depth for this context.
 */
static VALUE rxml_parser_context_node_depth_max_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->nodeMax));
}

/*
 * call-seq:
 *    context.num_chars -> num
 *
 * Obtain the number of characters in this context.
 */
static VALUE rxml_parser_context_num_chars_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (LONG2NUM(ctxt->nbChars));
}


/*
 * call-seq:
 *    context.options > XML::Parser::Options::NOENT
 *
 * Returns the parser options for this context.  Multiple
 * options can be combined by using Bitwise OR (|).
 */
static VALUE rxml_parser_context_options_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return INT2NUM(ctxt->options);
}

/*
 * call-seq:
 *    context.options = XML::Parser::Options::NOENT |
                        XML::Parser::Options::NOCDATA
 *
 * Provides control over the execution of a parser.  Valid values 
 * are the constants defined on XML::Parser::Options.  Multiple
 * options can be combined by using Bitwise OR (|).
 */
static VALUE rxml_parser_context_options_set(VALUE self, VALUE options)
{
  int result;
  xmlParserCtxtPtr ctxt;
  Check_Type(options, T_FIXNUM);

  Data_Get_Struct(self, xmlParserCtxt, ctxt);
  result = xmlCtxtUseOptions(ctxt, NUM2INT(options));

  return self;
}

/*
 * call-seq:
 *    context.recovery? -> (true|false)
 *
 * Determine whether recovery mode is enabled in this
 * context.
 */
static VALUE rxml_parser_context_recovery_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->recovery)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.recovery = true|false
 *
 * Control whether recovery mode is enabled in this
 * context.
 */
static VALUE rxml_parser_context_recovery_set(VALUE self, VALUE bool)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (TYPE(bool) == T_FALSE)
  {
    ctxt->recovery = 0;
    return (Qfalse);
  }
  else
  {
    ctxt->recovery = 1;
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    context.replace_entities? -> (true|false)
 *
 * Determine whether external entity replacement is enabled in this
 * context.
 */
static VALUE rxml_parser_context_replace_entities_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->replaceEntities)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.replace_entities = true|false
 *
 * Control whether external entity replacement is enabled in this
 * context.
 */
static VALUE rxml_parser_context_replace_entities_set(VALUE self, VALUE bool)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (TYPE(bool) == T_FALSE)
  {
    ctxt->replaceEntities = 0;
    return (Qfalse);
  }
  else
  {
    ctxt->replaceEntities = 1;
    return (Qtrue);
  }
}

/*
 * call-seq:
 *    context.space_depth -> num
 *
 * Obtain the space depth for this context.
 */
static VALUE rxml_parser_context_space_depth_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->spaceNr));
}

/*
 * call-seq:
 *    context.space_depth -> num
 *
 * Obtain the maximum space depth for this context.
 */
static VALUE rxml_parser_context_space_depth_max_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  return (INT2NUM(ctxt->spaceMax));
}

/*
 * call-seq:
 *    context.subset_external? -> (true|false)
 *
 * Determine whether this context is a subset of an
 * external context.
 */
static VALUE rxml_parser_context_subset_external_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->inSubset == 2)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.subset_internal? -> (true|false)
 *
 * Determine whether this context is a subset of an
 * internal context.
 */
static VALUE rxml_parser_context_subset_internal_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->inSubset == 1)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.subset_internal_name -> "name"
 *
 * Obtain this context's subset name (valid only if
 * either of subset_external? or subset_internal?
 * is true).
 */
static VALUE rxml_parser_context_subset_name_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->intSubName == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) ctxt->intSubName, ctxt->encoding));
}

/*
 * call-seq:
 *    context.subset_external_uri -> "uri"
 *
 * Obtain this context's external subset URI. (valid only if
 * either of subset_external? or subset_internal?
 * is true).
 */
static VALUE rxml_parser_context_subset_external_uri_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->extSubURI == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) ctxt->extSubURI, ctxt->encoding));
}

/*
 * call-seq:
 *    context.subset_external_system_id -> "system_id"
 *
 * Obtain this context's external subset system identifier.
 * (valid only if either of subset_external? or subset_internal?
 * is true).
 */
static VALUE rxml_parser_context_subset_external_system_id_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->extSubSystem == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) ctxt->extSubSystem, ctxt->encoding));
}

/*
 * call-seq:
 *    context.standalone? -> (true|false)
 *
 * Determine whether this is a standalone context.
 */
static VALUE rxml_parser_context_standalone_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->standalone)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.stats? -> (true|false)
 *
 * Determine whether this context maintains statistics.
 */
static VALUE rxml_parser_context_stats_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->record_info)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.valid? -> (true|false)
 *
 * Determine whether this context is valid.
 */
static VALUE rxml_parser_context_valid_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->valid)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.validate? -> (true|false)
 *
 * Determine whether validation is enabled in this context.
 */
static VALUE rxml_parser_context_validate_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->validate)
    return (Qtrue);
  else
    return (Qfalse);
}

/*
 * call-seq:
 *    context.version -> "version"
 *
 * Obtain this context's version identifier.
 */
static VALUE rxml_parser_context_version_get(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->version == NULL)
    return (Qnil);
  else
    return (rxml_new_cstr((const char*) ctxt->version, ctxt->encoding));
}

/*
 * call-seq:
 *    context.well_formed? -> (true|false)
 *
 * Determine whether this context contains well-formed XML.
 */
static VALUE rxml_parser_context_well_formed_q(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if (ctxt->wellFormed)
    return (Qtrue);
  else
    return (Qfalse);
}

void rxml_init_parser_context(void)
{
  IO_ATTR = ID2SYM(rb_intern("@io"));

  cXMLParserContext = rb_define_class_under(cXMLParser, "Context", rb_cObject);
  rb_define_alloc_func(cXMLParserContext, rxml_parser_context_alloc);

  rb_define_singleton_method(cXMLParserContext, "document", rxml_parser_context_document, 1);
  rb_define_singleton_method(cXMLParserContext, "file", rxml_parser_context_file, 1);
  rb_define_singleton_method(cXMLParserContext, "io", rxml_parser_context_io, 1);
  rb_define_singleton_method(cXMLParserContext, "string", rxml_parser_context_string, 1);

  rb_define_method(cXMLParserContext, "base_uri", rxml_parser_context_base_uri_get, 0);
  rb_define_method(cXMLParserContext, "base_uri=", rxml_parser_context_base_uri_set, 1);
  rb_define_method(cXMLParserContext, "close", rxml_parser_context_close, 0);
  rb_define_method(cXMLParserContext, "data_directory", rxml_parser_context_data_directory_get, 0);
  rb_define_method(cXMLParserContext, "depth", rxml_parser_context_depth_get, 0);
  rb_define_method(cXMLParserContext, "disable_cdata?", rxml_parser_context_disable_cdata_q, 0);
  rb_define_method(cXMLParserContext, "disable_cdata=", rxml_parser_context_disable_cdata_set, 1);
  rb_define_method(cXMLParserContext, "disable_sax?", rxml_parser_context_disable_sax_q, 0);
  rb_define_method(cXMLParserContext, "docbook?", rxml_parser_context_docbook_q, 0);
  rb_define_method(cXMLParserContext, "encoding", rxml_parser_context_encoding_get, 0);
  rb_define_method(cXMLParserContext, "encoding=", rxml_parser_context_encoding_set, 1);
  rb_define_method(cXMLParserContext, "errno", rxml_parser_context_errno_get, 0);
  rb_define_method(cXMLParserContext, "html?", rxml_parser_context_html_q, 0);
  rb_define_method(cXMLParserContext, "io_max_num_streams", rxml_parser_context_io_max_num_streams_get, 0);
  rb_define_method(cXMLParserContext, "io_num_streams", rxml_parser_context_io_num_streams_get, 0);
  rb_define_method(cXMLParserContext, "keep_blanks?", rxml_parser_context_keep_blanks_q, 0);
  rb_define_method(cXMLParserContext, "name_node", rxml_parser_context_name_node_get, 0);
  rb_define_method(cXMLParserContext, "name_depth", rxml_parser_context_name_depth_get, 0);
  rb_define_method(cXMLParserContext, "name_depth_max", rxml_parser_context_name_depth_max_get, 0);
  rb_define_method(cXMLParserContext, "name_tab", rxml_parser_context_name_tab_get, 0);
  rb_define_method(cXMLParserContext, "node", rxml_parser_context_node_get, 0);
  rb_define_method(cXMLParserContext, "node_depth", rxml_parser_context_node_depth_get, 0);
  rb_define_method(cXMLParserContext, "node_depth_max", rxml_parser_context_node_depth_max_get, 0);
  rb_define_method(cXMLParserContext, "num_chars", rxml_parser_context_num_chars_get, 0);
  rb_define_method(cXMLParserContext, "options", rxml_parser_context_options_get, 0);
  rb_define_method(cXMLParserContext, "options=", rxml_parser_context_options_set, 1);
  rb_define_method(cXMLParserContext, "recovery?", rxml_parser_context_recovery_q, 0);
  rb_define_method(cXMLParserContext, "recovery=", rxml_parser_context_recovery_set, 1);
  rb_define_method(cXMLParserContext, "replace_entities?", rxml_parser_context_replace_entities_q, 0);
  rb_define_method(cXMLParserContext, "replace_entities=", rxml_parser_context_replace_entities_set, 1);
  rb_define_method(cXMLParserContext, "space_depth", rxml_parser_context_space_depth_get, 0);
  rb_define_method(cXMLParserContext, "space_depth_max", rxml_parser_context_space_depth_max_get, 0);
  rb_define_method(cXMLParserContext, "subset_external?", rxml_parser_context_subset_external_q, 0);
  rb_define_method(cXMLParserContext, "subset_external_system_id", rxml_parser_context_subset_external_system_id_get, 0);
  rb_define_method(cXMLParserContext, "subset_external_uri", rxml_parser_context_subset_external_uri_get, 0);
  rb_define_method(cXMLParserContext, "subset_internal?", rxml_parser_context_subset_internal_q, 0);
  rb_define_method(cXMLParserContext, "subset_internal_name", rxml_parser_context_subset_name_get, 0);
  rb_define_method(cXMLParserContext, "stats?", rxml_parser_context_stats_q, 0);
  rb_define_method(cXMLParserContext, "standalone?", rxml_parser_context_standalone_q, 0);
  rb_define_method(cXMLParserContext, "valid", rxml_parser_context_valid_q, 0);
  rb_define_method(cXMLParserContext, "validate?", rxml_parser_context_validate_q, 0);
  rb_define_method(cXMLParserContext, "version", rxml_parser_context_version_get, 0);
  rb_define_method(cXMLParserContext, "well_formed?", rxml_parser_context_well_formed_q, 0);
}
                                                                                                                                                                                                                                     ruby_xml_parser_context.h                                                                           0100644 0001750 0001750 00000000335 12566211276 046325  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_PARSER_CONTEXT__
#define __RXML_PARSER_CONTEXT__

extern VALUE cXMLParserContext;

void rxml_init_parser_context(void);

#endif
                                                                                                                                                                                                                                                                                                   ruby_xml_parser_options.c                                                                           0100644 0001750 0001750 00000005577 12566211276 046344  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include <stdarg.h>
#include "ruby_libxml.h"

/* Document-class: LibXML::XML::Parser::Options
 *
 * Options that control the operation of the HTMLParser.  The easiest
 * way to set a parser's options is to use the methods
 * XML::Parser.file, XML::Parser.io or XML::Parser.string.
 * For additional control, see XML::Parser::Context#options=.
*/

VALUE mXMLParserOptions;

void rxml_init_parser_options(void)
{
  mXMLParserOptions = rb_define_module_under(cXMLParser, "Options");

  /* recover on errors */  
  rb_define_const(mXMLParserOptions, "RECOVER", INT2NUM(XML_PARSE_RECOVER));
  /* substitute entities */
  rb_define_const(mXMLParserOptions, "NOENT", INT2NUM(XML_PARSE_NOENT));
  /* load the external subset */
  rb_define_const(mXMLParserOptions, "DTDLOAD", INT2NUM(XML_PARSE_DTDLOAD));
  /* default DTD attributes */
  rb_define_const(mXMLParserOptions, "DTDATTR", INT2NUM(XML_PARSE_DTDATTR));
  /* validate with the DTD */
  rb_define_const(mXMLParserOptions, "DTDVALID", INT2NUM(XML_PARSE_DTDVALID));
  /* suppress error reports */
  rb_define_const(mXMLParserOptions, "NOERROR", INT2NUM(XML_PARSE_NOERROR));
  /* suppress warning reports */
  rb_define_const(mXMLParserOptions, "NOWARNING", INT2NUM(XML_PARSE_NOWARNING));
  /* pedantic error reporting */
  rb_define_const(mXMLParserOptions, "PEDANTIC", INT2NUM(XML_PARSE_PEDANTIC));
  /* remove blank nodes */
  rb_define_const(mXMLParserOptions, "NOBLANKS", INT2NUM(XML_PARSE_NOBLANKS));
  /* use the SAX1 interface internally */
  rb_define_const(mXMLParserOptions, "SAX1", INT2NUM(XML_PARSE_SAX1));
  /* Implement XInclude substitition  */
  rb_define_const(mXMLParserOptions, "XINCLUDE", INT2NUM(XML_PARSE_XINCLUDE));
  /* Forbid network access */
  rb_define_const(mXMLParserOptions, "NONET", INT2NUM(XML_PARSE_NONET));
  /* Do not reuse the context dictionnary */
  rb_define_const(mXMLParserOptions, "NODICT", INT2NUM(XML_PARSE_NODICT));
  /* remove redundant namespaces declarations */
  rb_define_const(mXMLParserOptions, "NSCLEAN", INT2NUM(XML_PARSE_NSCLEAN));
  /* merge CDATA as text nodes */
  rb_define_const(mXMLParserOptions, "NOCDATA", INT2NUM(XML_PARSE_NOCDATA));
#if LIBXML_VERSION >= 20621
  /* do not generate XINCLUDE START/END nodes */
  rb_define_const(mXMLParserOptions, "NOXINCNODE", INT2NUM(XML_PARSE_NOXINCNODE));
#endif
#if LIBXML_VERSION >= 20700
  /* compact small text nodes */
  rb_define_const(mXMLParserOptions, "COMPACT", INT2NUM(XML_PARSE_COMPACT));
  /* parse using XML-1.0 before update 5 */
  rb_define_const(mXMLParserOptions, "PARSE_OLD10", INT2NUM(XML_PARSE_OLD10));
  /* do not fixup XINCLUDE xml:base uris */
  rb_define_const(mXMLParserOptions, "NOBASEFIX", INT2NUM(XML_PARSE_NOBASEFIX));
#endif
#if LIBXML_VERSION >= 20703
  /* relax any hardcoded limit from the parser */
  rb_define_const(mXMLParserOptions, "HUGE", INT2NUM(XML_PARSE_HUGE));
#endif
}
                                                                                                                                 ruby_xml_parser_options.h                                                                           0100644 0001750 0001750 00000000375 12566211276 046340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_PARSER_OPTIONS__
#define __RXML_PARSER_OPTIONS__

#define MAX_LIBXML_FEATURES_LEN 50

extern VALUE mXMLParserOptions;

void rxml_init_parser_options();

#endif
                                                                                                                                                                                                                                                                   ruby_xml_reader.c                                                                                   0100644 0001750 0001750 00000111336 12566211276 044526  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Copyright (c) 2006-2007 Apple Inc.
 * Please see the LICENSE file for copyright and distribution information. */

#include "ruby_libxml.h"
#include "ruby_xml_reader.h"

/*
 * Document-class: LibXML::XML::Reader
 *
 * The XML::Reader class provides a simpler, alternative way of parsing an XML
 * document in contrast to XML::Parser or XML::SaxParser.  A XML::Reader instance
 * acts like a cursor going forward in a document stream, stopping at each node
 * it encounters.  To advance to the next node, simply cadd XML::Reader#read.
 *
 * The XML::Reader API closely matches the DOM Core specification and supports
 * namespaces, xml:base, entity handling and DTDs.
 *
 * To summarize, XML::Reader provides a far simpler API to use versus XML::SaxParser
 * and is more memory efficient than using XML::Parser to create a DOM tree.
 *
 * Example:
 *
 *  reader = XML::Reader.string("<foo><bar>1</bar><bar>2</bar><bar>3</bar></foo>")
 *  reader.read
 *  assert_equal('foo', reader.name)
 *  assert_equal(nil, reader.value)
 *
 *  3.times do |i|
 *    reader.read
 *    assert_equal(XML::Reader::TYPE_ELEMENT, reader.node_type)
 *    assert_equal('bar', reader.name)
 *    reader.read
 *    assert_equal(XML::Reader::TYPE_TEXT, reader.node_type)
 *    assert_equal((i + 1).to_s, reader.value)
 *    reader.read
 *    assert_equal(XML::Reader::TYPE_END_ELEMENT, reader.node_type)
 *  end
 *
 * You can also parse documents (see XML::Reader.document), 
 * strings (see XML::Parser.string) and io objects (see
 * XML::Parser.io).
 *
 * For a more in depth tutorial, albeit in C, see http://xmlsoft.org/xmlreader.html.*/


  /* NOTE - We need to wrap the readers document to support Reader.read.node.find('/').
     To do this we need to use xmlTextReaderCurrentDoc which means we have to free the
     document ourselves. Annoying... */

VALUE cXMLReader;

static ID BASE_URI_SYMBOL;
static ID ENCODING_SYMBOL;
static ID IO_ATTR;
static ID OPTIONS_SYMBOL;

static void rxml_reader_free(xmlTextReaderPtr xreader)
{
  xmlFreeTextReader(xreader);
}

static void rxml_reader_mark(xmlTextReaderPtr xreader)
{
  xmlDocPtr xdoc = xmlTextReaderCurrentDoc(xreader);

  if (xdoc && xdoc->_private)
    rb_gc_mark((VALUE) xdoc->_private);
}

static VALUE rxml_reader_wrap(xmlTextReaderPtr xreader)
{
  return Data_Wrap_Struct(cXMLReader, NULL, rxml_reader_free, xreader);
}


static xmlTextReaderPtr rxml_text_reader_get(VALUE obj)
{
  xmlTextReaderPtr xreader;
  Data_Get_Struct(obj, xmlTextReader, xreader);
  return xreader;
}

/*
 * call-seq:
 *    XML::Reader.document(doc) -> XML::Reader
 *
 * Create an new reader for the specified document.
 */
VALUE rxml_reader_document(VALUE klass, VALUE doc)
{
  xmlDocPtr xdoc;
  xmlTextReaderPtr xreader;

  Data_Get_Struct(doc, xmlDoc, xdoc);

  xreader = xmlReaderWalker(xdoc);

  if (xreader == NULL)
    rxml_raise(&xmlLastError);

  return rxml_reader_wrap(xreader);
}

/* call-seq:
 *    XML::Reader.file(path) -> XML::Reader
 *    XML::Reader.file(path, :encoding => XML::Encoding::UTF_8,
 *                           :options => XML::Parser::Options::NOENT) -> XML::Parser
 *
 * Creates a new reader by parsing the specified file or uri.
 *
 * You may provide an optional hash table to control how the
 * parsing is performed.  Valid options are:
 *
 *  encoding - The document encoding, defaults to nil. Valid values
 *             are the encoding constants defined on XML::Encoding.
 *  options - Controls the execution of the parser, defaults to 0.
 *            Valid values are the constants defined on
 *            XML::Parser::Options.  Mutliple options can be combined
 *            by using Bitwise OR (|). 
 */
static VALUE rxml_reader_file(int argc, VALUE *argv, VALUE klass)
{
  xmlTextReaderPtr xreader;
  VALUE path;
  VALUE options;

  const char *xencoding = NULL;
  int xoptions = 0;

  rb_scan_args(argc, argv, "11", &path, &options);
  Check_Type(path, T_STRING);

  if (!NIL_P(options))
  {
    VALUE encoding = Qnil;
    VALUE parserOptions = Qnil;

    Check_Type(options, T_HASH);

    encoding = rb_hash_aref(options, BASE_URI_SYMBOL);
    xencoding = NIL_P(encoding) ? NULL : xmlGetCharEncodingName(NUM2INT(encoding));

    parserOptions = rb_hash_aref(options, OPTIONS_SYMBOL);
    xoptions = NIL_P(parserOptions) ? 0 : NUM2INT(parserOptions);
  }

  xreader = xmlReaderForFile(StringValueCStr(path), xencoding, xoptions);

  if (xreader == NULL)
    rxml_raise(&xmlLastError);

  return rxml_reader_wrap(xreader);
}

/* call-seq:
 *    XML::Reader.io(io) -> XML::Reader
 *    XML::Reader.io(io, :encoding => XML::Encoding::UTF_8,
 *                       :options => XML::Parser::Options::NOENT) -> XML::Parser
 *
 * Creates a new reader by parsing the specified io object.
 *
 * You may provide an optional hash table to control how the
 * parsing is performed.  Valid options are:
 *
 *  base_uri - The base url for the parsed document.
 *  encoding - The document encoding, defaults to nil. Valid values
 *             are the encoding constants defined on XML::Encoding.
 *  options - Controls the execution of the parser, defaults to 0.
 *            Valid values are the constants defined on
 *            XML::Parser::Options.  Mutliple options can be combined
 *            by using Bitwise OR (|). 
 */
static VALUE rxml_reader_io(int argc, VALUE *argv, VALUE klass)
{
  xmlTextReaderPtr xreader;
  VALUE result;
  VALUE io;
  VALUE options;
  char *xbaseurl = NULL;
  const char *xencoding = NULL;
  int xoptions = 0;

  rb_scan_args(argc, argv, "11", &io, &options);

  if (!NIL_P(options))
  {
    VALUE baseurl = Qnil;
    VALUE encoding = Qnil;
    VALUE parserOptions = Qnil;

    Check_Type(options, T_HASH);

    baseurl = rb_hash_aref(options, BASE_URI_SYMBOL);
    xbaseurl = NIL_P(baseurl) ? NULL : StringValueCStr(baseurl);

    encoding = rb_hash_aref(options, ENCODING_SYMBOL);
    xencoding = NIL_P(encoding) ? NULL : xmlGetCharEncodingName(NUM2INT(encoding));

    parserOptions = rb_hash_aref(options, OPTIONS_SYMBOL);
    xoptions = NIL_P(parserOptions) ? 0 : NUM2INT(parserOptions);
  }
  
  xreader = xmlReaderForIO((xmlInputReadCallback) rxml_read_callback, NULL,
                           (void *) io, 
                           xbaseurl, xencoding, xoptions);

  if (xreader == NULL)
    rxml_raise(&xmlLastError);

  result = rxml_reader_wrap(xreader);

  /* Attach io object to parser so it won't get freed.*/
  rb_ivar_set(result, IO_ATTR, io);

  return result;
}

/* call-seq:
 *    XML::Reader.string(io) -> XML::Reader
 *    XML::Reader.string(io, :encoding => XML::Encoding::UTF_8,
 *                           :options => XML::Parser::Options::NOENT) -> XML::Parser
 *
 * Creates a new reader by parsing the specified string.
 *
 * You may provide an optional hash table to control how the
 * parsing is performed.  Valid options are:
 *
 *  base_uri - The base url for the parsed document.
 *  encoding - The document encoding, defaults to nil. Valid values
 *             are the encoding constants defined on XML::Encoding.
 *  options - Controls the execution of the parser, defaults to 0.
 *            Valid values are the constants defined on
 *            XML::Parser::Options.  Mutliple options can be combined
 *            by using Bitwise OR (|).
 */
static VALUE rxml_reader_string(int argc, VALUE *argv, VALUE klass)
{
  xmlTextReaderPtr xreader;
  VALUE string;
  VALUE options;
  char *xbaseurl = NULL;
  const char *xencoding = NULL;
  int xoptions = 0;

  rb_scan_args(argc, argv, "11", &string, &options);
  Check_Type(string, T_STRING);

  if (!NIL_P(options))
  {
    VALUE baseurl = Qnil;
    VALUE encoding = Qnil;
    VALUE parserOptions = Qnil;

    Check_Type(options, T_HASH);

    baseurl = rb_hash_aref(options, BASE_URI_SYMBOL);
    xbaseurl = NIL_P(baseurl) ? NULL : StringValueCStr(baseurl);

    encoding = rb_hash_aref(options, ENCODING_SYMBOL);
    xencoding = NIL_P(encoding) ? NULL : xmlGetCharEncodingName(NUM2INT(encoding));
      
    parserOptions = rb_hash_aref(options, OPTIONS_SYMBOL);
    xoptions = NIL_P(parserOptions) ? 0 : NUM2INT(parserOptions);
  }
  
  xreader = xmlReaderForMemory(StringValueCStr(string), RSTRING_LEN(string), 
                               xbaseurl, xencoding, xoptions);

  if (xreader == NULL)
    rxml_raise(&xmlLastError);

  return rxml_reader_wrap(xreader);
}

/*
 * call-seq:
 *    reader.close -> code
 *
 * This method releases any resources allocated by the current instance
 * changes the state to Closed and close any underlying input.
 */
static VALUE rxml_reader_close(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderClose(xreader));
}

/*
 * call-seq:
 *   reader.move_to_attribute_no(index) -> code
 *
 * Move the position of the current instance to the attribute with the
 * specified index relative to the containing element.
 */
static VALUE rxml_reader_move_to_attr_no(VALUE self, VALUE index)
{
  int ret;
  xmlTextReaderPtr xreader;

  xreader = rxml_text_reader_get(self);
  ret = xmlTextReaderMoveToAttributeNo(xreader, FIX2INT(index));

  return INT2FIX(ret);
}

/*
 * call-seq:
 *   reader.move_to_attribute(localName) -> code
 *
 * Move the position of the current instance to the attribute with the
 * specified name relative to the containing element.
 */
static VALUE rxml_reader_move_to_attr(VALUE self, VALUE val)
{
  if (TYPE(val) == T_FIXNUM)
  {
    rb_warn("%s::move_to_attribute with a Fixnum argument is deprecated. "
      "Please, consider move_to_attribute_no method instead.",
      rb_class2name(cXMLReader));
    return rxml_reader_move_to_attr_no(self, val);
  }
  else
  {
    int ret;
    xmlTextReaderPtr xreader;

    xreader = rxml_text_reader_get(self);
    ret = xmlTextReaderMoveToAttribute(xreader,
        (const xmlChar *) StringValueCStr(val));

    return INT2FIX(ret);
  }
}

/*
 * call-seq:
 *   reader.move_to_attribute_ns(localName, namespaceURI) -> code
 *
 * Move the position of the current instance to the attribute with the
 * specified name and namespace relative to the containing element.
 */
static VALUE rxml_reader_move_to_attr_ns(VALUE self, VALUE name, VALUE ns)
{
  int ret;
  xmlTextReaderPtr xreader;

  xreader = rxml_text_reader_get(self);
  ret = xmlTextReaderMoveToAttributeNs(xreader,
      (const xmlChar *) StringValueCStr(name),
      (const xmlChar *) StringValueCStr(ns));

  return INT2FIX(ret);
}

/*
 * call-seq:
 *    reader.move_to_first_attribute -> code
 *
 * Move the position of the current instance to the first attribute associated
 * with the current node.
 */
static VALUE rxml_reader_move_to_first_attr(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderMoveToFirstAttribute(xreader));
}

/*
 * call-seq:
 *    reader.move_to_next_attribute -> code
 *
 * Move the position of the current instance to the next attribute associated
 * with the current node.
 */
static VALUE rxml_reader_move_to_next_attr(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderMoveToNextAttribute(xreader));
}

/*
 * call-seq:
 *    reader.move_to_element -> code
 *
 * Move the position of the current instance to the node that contains the
 * current attribute node.
 */
static VALUE rxml_reader_move_to_element(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderMoveToElement(xreader));
}

/*
 * call-seq:
 *    reader.next -> code
 *
 * Skip to the node following the current one in document order while avoiding
 * the subtree if any.
 */
static VALUE rxml_reader_next(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderNext(xreader));
}

/*
 * call-seq:
 *    reader.next_sibling -> code
 *
 * Skip to the node following the current one in document order while avoiding
 * the subtree if any. Currently implemented only for Readers built on a
 * document.
 */
static VALUE rxml_reader_next_sibling(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderNextSibling(xreader));
}

/*
 * call-seq:
 *    reader.node -> XML::Node
 *
 * Returns the reader's current node.  It will return
 * nil if Reader#read has not yet been called.
 * WARNING - Using this method is dangerous because the
 * the node may be destroyed on the next #read.
 */
static VALUE rxml_reader_node(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  xmlNodePtr xnode = xmlTextReaderCurrentNode(xreader);
  return xnode ? rxml_node_wrap(xnode) : Qnil;
}

/*
 * call-seq:
 *    reader.node_type -> type
 *
 * Get the node type of the current node. Reference:
 * http://dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html
 */
static VALUE rxml_reader_node_type(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderNodeType(xreader));
}

/*
 * call-seq:
 *    reader.normalization -> value
 *
 * The value indicating whether to normalize white space and attribute values.
 * Since attribute value and end of line normalizations are a MUST in the XML
 * specification only the value true is accepted. The broken bahaviour of
 * accepting out of range character entities like &#0; is of course not
 * supported either.
 *
 * Return 1 or -1 in case of error.
 */
static VALUE rxml_reader_normalization(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderNormalization(xreader));
}

/*
 * call-seq:
 *    reader.read -> nil|true|false
 *
 * Causes the reader to move to the next node in the stream, exposing its properties.
 *
 * Returns true if a node was successfully read or false if there are no more
 * nodes to read.  On errors, an exception is raised.*/
static VALUE rxml_reader_read(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  int result = xmlTextReaderRead(xreader);
  switch(result)
  {
    case -1:
      rxml_raise(&xmlLastError);
      return Qnil;
      break;
    case 0:
      return Qfalse;
    case 1:
      return Qtrue;
    default:
      rb_raise(rb_eRuntimeError,
               "xmlTextReaderRead did not return -1, 0 or 1.  Return value was: %d", result);
  }
}

/*
 * call-seq:
 *    reader.read_attribute_value -> code
 *
 * Parse an attribute value into one or more Text and EntityReference nodes.
 *
 * Return 1 in case of success, 0 if the reader was not positionned on an
 * attribute node or all the attribute values have been read, or -1 in case of
 * error.
 */
static VALUE rxml_reader_read_attr_value(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderReadAttributeValue(xreader));
}

/*
 * call-seq:
 *    reader.read_inner_xml -> data
 *
 * Read the contents of the current node, including child nodes and markup.
 *
 * Return a string containing the XML content, or nil if the current node is
 * neither an element nor attribute, or has no child nodes.
 */
static VALUE rxml_reader_read_inner_xml(VALUE self)
{
  VALUE result = Qnil;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);

  xmlChar *xml = xmlTextReaderReadInnerXml(xReader);

  if (xml)
  {
    const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);
    result = rxml_new_cstr((const char*) xml, xencoding);
    xmlFree(xml);
  }

  return result;
}

/*
 * call-seq:
 *    reader.read_outer_xml -> data
 *
 * Read the contents of the current node, including child nodes and markup.
 *
 * Return a string containing the XML content, or nil if the current node is
 * neither an element nor attribute, or has no child nodes.
 */
static VALUE rxml_reader_read_outer_xml(VALUE self)
{
  VALUE result = Qnil;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);

  xmlChar *xml = xmlTextReaderReadOuterXml(xReader);

  if (xml)
  {
    const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);
    result = rxml_new_cstr((const char*) xml, xencoding);
    xmlFree(xml);
  }

  return result;
}

/*
 * call-seq:
 *    reader.read_state -> state
 *
 * Get the read state of the reader.
 */
static VALUE rxml_reader_read_state(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderReadState(xreader));
}

/*
 * call-seq:
 *    reader.read_string -> string
 *
 * Read the contents of an element or a text node as a string.
 *
 * Return a string containing the contents of the Element or Text node, or nil
 * if the reader is positioned on any other type of node.
 */
static VALUE rxml_reader_read_string(VALUE self)
{
  VALUE result = Qnil;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);

  xmlChar *xml = xmlTextReaderReadString(xReader);

  if (xml)
  {
    const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);
    result = rxml_new_cstr((const char*) xml, xencoding);
    xmlFree(xml);
  }

  return result;
}

/*
 * call-seq:
 *    reader.relax_ng_validate(rng) -> boolean
 *
 * Use RelaxNG to validate the document as it is processed. Activation is only
 * possible before the first read. If +rng+ is nil, the RelaxNG validation is
 * desactivated.
 *
 * Return true in case the RelaxNG validation could be (des)activated and false in
 * case of error.
 */
static VALUE rxml_reader_relax_ng_validate(VALUE self, VALUE rng)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  xmlRelaxNGPtr xrelax;
  int status;
  Data_Get_Struct(rng, xmlRelaxNG, xrelax);
  
  status = xmlTextReaderRelaxNGSetSchema(xreader, xrelax);
  return (status == 0 ? Qtrue : Qfalse);
}

#if LIBXML_VERSION >= 20620
/*
 * call-seq:
 *    reader.schema_validate(schema) -> boolean
 *
 * Use W3C XSD schema to validate the document as it is processed. Activation
 * is only possible before the first read. If +schema+ is nil, then XML Schema
 * validation is deactivated.
 *
 * Return false if if the schema's validation could be (de)activated and true
 * otherwise.
 */
static VALUE
rxml_reader_schema_validate(VALUE self, VALUE xsd)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  xmlSchemaPtr xschema;
  int status;

  Data_Get_Struct(xsd, xmlSchema, xschema);
  status = xmlTextReaderSetSchema(xreader, xschema);
  return (status == 0 ? Qtrue : Qfalse);
}
#endif

/*
 * call-seq:
 *    reader.name -> name
 *
 * Return the qualified name of the node.
 */
static VALUE rxml_reader_name(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstName(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.local_name -> name
 *
 * Return the local name of the node.
 */
static VALUE rxml_reader_local_name(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstLocalName(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.attribute_count -> count
 *
 * Provide the number of attributes of the current node.
 */
static VALUE rxml_reader_attr_count(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderAttributeCount(xreader));
}

/*
 * call-seq:
 *    reader.encoding -> XML::Encoding::UTF_8
 *
 * Returns the encoding of the document being read.  Note you
 * first have to read data from the reader for encoding
 * to return a value
 *
 *   reader = XML::Reader.file(XML_FILE)
 *   assert_nil(reader.encoding)
 *   reader.read
 *   assert_equal(XML::Encoding::UTF_8, reader.encoding)
 *
 * In addition, libxml always appears to return nil for the encoding
 * when parsing strings.
 */
static VALUE rxml_reader_encoding(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xreader);
  if (xencoding)
    return INT2NUM(xmlParseCharEncoding(xencoding));
  else
    return INT2NUM(XML_CHAR_ENCODING_NONE);
}

/*
 * call-seq:
 *    reader.base_uri -> URI
 *
 * Determine the base URI of the node.
 */
static VALUE rxml_reader_base_uri(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstBaseUri(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.namespace_uri -> URI
 *
 * Determine the namespace URI of the node.
 */
static VALUE rxml_reader_namespace_uri(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstNamespaceUri(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.value -> text
 *
 * Provide the text value of the node if present.
 */
static VALUE rxml_reader_value(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstValue(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.prefix -> prefix
 *
 * Get a shorthand reference to the namespace associated with the node.
 */
static VALUE rxml_reader_prefix(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstPrefix(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.depth -> depth
 *
 * Get the depth of the node in the tree.
 */
static VALUE rxml_reader_depth(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderDepth(xreader));
}

/*
 * call-seq:
 *    reader.quote_char -> char
 *
 * Get the quotation mark character used to enclose the value of an attribute,
 * as an integer value (and -1 in case of error).
 */
static VALUE rxml_reader_quote_char(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderQuoteChar(xreader));
}

/*
 * call-seq:
 *    reader.standalone -> code
 *
 * Determine the standalone status of the document being read.
 *
 * Return 1 if the document was declared to be standalone, 0 if it was
 * declared to be not standalone, or -1 if the document did not specify its
 * standalone status or in case of error.
 */
static VALUE rxml_reader_standalone(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2FIX(xmlTextReaderStandalone(xreader));
}

/*
 * call-seq:
 *    reader.xml_lang -> value
 *
 * Get the xml:lang scope within which the node resides.
 */
static VALUE rxml_reader_xml_lang(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstXmlLang(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.xml_version -> version
 *
 * Determine the XML version of the document being read.
 */
static VALUE rxml_reader_xml_version(VALUE self)
{
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *result = xmlTextReaderConstXmlVersion(xReader);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  return (result == NULL ? Qnil : rxml_new_cstr(result, xencoding));
}

/*
 * call-seq:
 *    reader.has_attributes? -> bool
 *
 * Get whether the node has attributes.
 */
static VALUE rxml_reader_has_attributes(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderHasAttributes(xreader) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    reader.has_value? -> bool
 *
 * Get whether the node can have a text value.
 */
static VALUE rxml_reader_has_value(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderHasValue(xreader) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    reader[key] -> value
 *
 * Provide the value of the attribute with the specified index (if +key+ is an
 * integer) or with the specified name (if +key+ is a string) relative to the
 * containing element, as a string.
 */
static VALUE rxml_reader_attribute(VALUE self, VALUE key)
{
  VALUE result = Qnil;
  xmlChar *xattr;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  if (TYPE(key) == T_FIXNUM)
  {
    xattr = xmlTextReaderGetAttributeNo(xReader, FIX2INT(key));
  }
  else
  {
    xattr = xmlTextReaderGetAttribute(xReader, (const xmlChar *) StringValueCStr(key));
  }

  if (xattr)
  {
    result = rxml_new_cstr(xattr, xencoding);
    xmlFree(xattr);
  }
  return result;
}

/*
 * call-seq:
 *    reader.get_attribute(localName) -> value
 *
 * Provide the value of the attribute with the specified name
 * relative to the containing element.
 */
static VALUE rxml_reader_get_attribute(VALUE self, VALUE name)
{
  VALUE result = Qnil;
  xmlChar *xattr;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  xattr = xmlTextReaderGetAttribute(xReader,
    (const xmlChar *) StringValueCStr(name));
  if (xattr)
  {
    result = rxml_new_cstr(xattr, xencoding);
    xmlFree(xattr);
  }
  return result;
}

/*
 * call-seq:
 *    reader.get_attribute_no(index) -> value
 *
 * Provide the value of the attribute with the specified index
 * relative to the containing element.
 */
static VALUE rxml_reader_get_attribute_no(VALUE self, VALUE index)
{
  VALUE result = Qnil;
  xmlChar *xattr;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  xattr = xmlTextReaderGetAttributeNo(xReader, FIX2INT(index));
  if (xattr)
  {
    result = rxml_new_cstr(xattr, xencoding);
    xmlFree(xattr);
  }
  return result;
}

static VALUE rxml_reader_get_attribute_ns(VALUE self, VALUE name, VALUE ns)
{
  VALUE result = Qnil;
  xmlChar *xattr;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  xattr = xmlTextReaderGetAttributeNs(xReader,
    (const xmlChar *) StringValueCStr(name),
    (const xmlChar *) StringValueCStr(ns));
  if (xattr)
  {
    result = rxml_new_cstr(xattr, xencoding);
    xmlFree(xattr);
  }
  return result;
}

/*
 * call-seq:
 *    reader.lookup_namespace(prefix) -> value
 *
 * Resolve a namespace prefix in the scope of the current element.
 * To return the default namespace, specify nil as +prefix+.
 */
static VALUE rxml_reader_lookup_namespace(VALUE self, VALUE prefix)
{
  VALUE result = Qnil;
  xmlTextReaderPtr xReader = rxml_text_reader_get(self);
  const xmlChar *xnamespace = xmlTextReaderLookupNamespace(xReader, (const xmlChar *) StringValueCStr(prefix));
  const xmlChar *xencoding = xmlTextReaderConstEncoding(xReader);

  if (xnamespace)
  {
    result = rxml_new_cstr((const char*)xnamespace, (const char*)xencoding);
    xmlFree((void *)xnamespace);
  }
  return result;
}

/*
 * call-seq:
 *    reader.expand -> node
 *
 * Returns the current node and its full subtree. Note the returned node
 * is valid ONLY until the next read call.  
 */
static VALUE rxml_reader_expand(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  xmlNodePtr xnode = NULL;

  /* At this point we need to wrap the reader's document as explained above. */
  xmlDocPtr xdoc = xmlTextReaderCurrentDoc(xreader);

  if (!xdoc)
    rb_raise(rb_eRuntimeError, "The reader does not have a document.  Did you forget to call read?");

  rxml_document_wrap(xdoc);

  /* And now hook in a mark function */
  RDATA(self)->dmark = (RUBY_DATA_FUNC)rxml_reader_mark;

  xnode = xmlTextReaderExpand(xreader);
  
  if (!xnode)
  {
    return Qnil;
  }
  else
  {
    return rxml_node_wrap(xnode);
  }
}

#if LIBXML_VERSION >= 20618
/*
 * call-seq:
 *    reader.byte_consumed -> value
 *
 * This method provides the current index of the parser used by the reader,
 * relative to the start of the current entity.
 */
static VALUE
rxml_reader_byte_consumed(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2NUM(xmlTextReaderByteConsumed(xreader));
}
#endif

#if LIBXML_VERSION >= 20617
/*
 * call-seq:
 *    reader.column_number -> number
 *
 * Provide the column number of the current parsing point.
 */
static VALUE
rxml_reader_column_number(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2NUM(xmlTextReaderGetParserColumnNumber(xreader));
}

/*
 * call-seq:
 *    reader.line_number -> number
 *
 * Provide the line number of the current parsing point.
 */
static VALUE
rxml_reader_line_number(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return INT2NUM(xmlTextReaderGetParserLineNumber(xreader));
}
#endif

/*
 * call-seq:
 *    reader.default? -> bool
 *
 * Return whether an Attribute node was generated from the default value
 * defined in the DTD or schema.
 */
static VALUE rxml_reader_default(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderIsDefault(xreader) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    reader.namespace_declaration? -> bool
 *
 * Determine whether the current node is a namespace declaration rather than a
 * regular attribute.
 */
static VALUE rxml_reader_namespace_declaration(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderIsNamespaceDecl(xreader) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    reader.empty_element? -> bool
 *
 * Check if the current node is empty.
 */
static VALUE rxml_reader_empty_element(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderIsEmptyElement(xreader) ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *    reader.valid? -> bool
 *
 * Retrieve the validity status from the parser context.
 */
static VALUE rxml_reader_valid(VALUE self)
{
  xmlTextReaderPtr xreader = rxml_text_reader_get(self);
  return xmlTextReaderIsValid(xreader) ? Qtrue : Qfalse;
}

void rxml_init_reader(void)
{
  BASE_URI_SYMBOL = ID2SYM(rb_intern("base_uri"));
  ENCODING_SYMBOL = ID2SYM(rb_intern("encoding"));
  IO_ATTR = rb_intern("@io");
  OPTIONS_SYMBOL = ID2SYM(rb_intern("options"));

  cXMLReader = rb_define_class_under(mXML, "Reader", rb_cObject);

  rb_define_singleton_method(cXMLReader, "document", rxml_reader_document, 1);
  rb_define_singleton_method(cXMLReader, "file", rxml_reader_file, -1);
  rb_define_singleton_method(cXMLReader, "io", rxml_reader_io, -1);
  rb_define_singleton_method(cXMLReader, "string", rxml_reader_string, -1);

  rb_define_method(cXMLReader, "[]", rxml_reader_attribute, 1);
  rb_define_method(cXMLReader, "attribute_count", rxml_reader_attr_count, 0);
  rb_define_method(cXMLReader, "base_uri", rxml_reader_base_uri, 0);
#if LIBXML_VERSION >= 20618
  rb_define_method(cXMLReader, "byte_consumed", rxml_reader_byte_consumed, 0);
#endif
  rb_define_method(cXMLReader, "close", rxml_reader_close, 0);
#if LIBXML_VERSION >= 20617
  rb_define_method(cXMLReader, "column_number", rxml_reader_column_number, 0);
#endif
  rb_define_method(cXMLReader, "depth", rxml_reader_depth, 0);
  rb_define_method(cXMLReader, "encoding", rxml_reader_encoding, 0);
  rb_define_method(cXMLReader, "expand", rxml_reader_expand, 0);
  rb_define_method(cXMLReader, "get_attribute", rxml_reader_get_attribute, 1);
  rb_define_method(cXMLReader, "get_attribute_no", rxml_reader_get_attribute_no, 1);
  rb_define_method(cXMLReader, "get_attribute_ns", rxml_reader_get_attribute_ns, 2);
  rb_define_method(cXMLReader, "has_attributes?", rxml_reader_has_attributes, 0);
  rb_define_method(cXMLReader, "has_value?", rxml_reader_has_value, 0);
#if LIBXML_VERSION >= 20617
  rb_define_method(cXMLReader, "line_number", rxml_reader_line_number, 0);
#endif
  rb_define_method(cXMLReader, "local_name", rxml_reader_local_name, 0);
  rb_define_method(cXMLReader, "lookup_namespace",       rxml_reader_lookup_namespace, 1);
  rb_define_method(cXMLReader, "move_to_attribute", rxml_reader_move_to_attr, 1);
  rb_define_method(cXMLReader, "move_to_attribute_no", rxml_reader_move_to_attr_no, 1);
  rb_define_method(cXMLReader, "move_to_attribute_ns", rxml_reader_move_to_attr_ns, 2);
  rb_define_method(cXMLReader, "move_to_first_attribute",       rxml_reader_move_to_first_attr, 0);
  rb_define_method(cXMLReader, "move_to_next_attribute",       rxml_reader_move_to_next_attr, 0);
  rb_define_method(cXMLReader, "move_to_element", rxml_reader_move_to_element,       0);
  rb_define_method(cXMLReader, "name", rxml_reader_name, 0);
  rb_define_method(cXMLReader, "namespace_uri", rxml_reader_namespace_uri, 0);
  rb_define_method(cXMLReader, "next", rxml_reader_next, 0);
  rb_define_method(cXMLReader, "next_sibling", rxml_reader_next_sibling, 0);
  rb_define_method(cXMLReader, "node", rxml_reader_node, 0);
  rb_define_method(cXMLReader, "node_type", rxml_reader_node_type, 0);
  rb_define_method(cXMLReader, "normalization", rxml_reader_normalization, 0);
  rb_define_method(cXMLReader, "prefix", rxml_reader_prefix, 0);
  rb_define_method(cXMLReader, "quote_char", rxml_reader_quote_char, 0);
  rb_define_method(cXMLReader, "read", rxml_reader_read, 0);
  rb_define_method(cXMLReader, "read_attribute_value", rxml_reader_read_attr_value, 0);
  rb_define_method(cXMLReader, "read_inner_xml", rxml_reader_read_inner_xml, 0);
  rb_define_method(cXMLReader, "read_outer_xml", rxml_reader_read_outer_xml, 0);
  rb_define_method(cXMLReader, "read_state", rxml_reader_read_state, 0);
  rb_define_method(cXMLReader, "read_string", rxml_reader_read_string, 0);
  rb_define_method(cXMLReader, "relax_ng_validate",       rxml_reader_relax_ng_validate, 1);
  rb_define_method(cXMLReader, "standalone", rxml_reader_standalone, 0);
#if LIBXML_VERSION >= 20620
  rb_define_method(cXMLReader, "schema_validate", rxml_reader_schema_validate, 1);
#endif
  rb_define_method(cXMLReader, "value", rxml_reader_value, 0);
  rb_define_method(cXMLReader, "xml_lang", rxml_reader_xml_lang, 0);
  rb_define_method(cXMLReader, "xml_version", rxml_reader_xml_version, 0);
  rb_define_method(cXMLReader, "default?", rxml_reader_default, 0);
  rb_define_method(cXMLReader, "empty_element?", rxml_reader_empty_element, 0);
  rb_define_method(cXMLReader, "namespace_declaration?", rxml_reader_namespace_declaration, 0);
  rb_define_method(cXMLReader, "valid?", rxml_reader_valid, 0);

  /* Constants */
  rb_define_const(cXMLReader, "LOADDTD", INT2FIX(XML_PARSER_LOADDTD));
  rb_define_const(cXMLReader, "DEFAULTATTRS", INT2FIX(XML_PARSER_DEFAULTATTRS));
  rb_define_const(cXMLReader, "VALIDATE", INT2FIX(XML_PARSER_VALIDATE));
  rb_define_const(cXMLReader, "SUBST_ENTITIES", INT2FIX(XML_PARSER_SUBST_ENTITIES));

  rb_define_const(cXMLReader, "SEVERITY_VALIDITY_WARNING", INT2FIX(XML_PARSER_SEVERITY_VALIDITY_WARNING));
  rb_define_const(cXMLReader, "SEVERITY_VALIDITY_ERROR", INT2FIX(XML_PARSER_SEVERITY_VALIDITY_ERROR));
  rb_define_const(cXMLReader, "SEVERITY_WARNING", INT2FIX(XML_PARSER_SEVERITY_WARNING));
  rb_define_const(cXMLReader, "SEVERITY_ERROR", INT2FIX(XML_PARSER_SEVERITY_ERROR));

  rb_define_const(cXMLReader, "TYPE_NONE", INT2FIX(XML_READER_TYPE_NONE));
  rb_define_const(cXMLReader, "TYPE_ELEMENT", INT2FIX(XML_READER_TYPE_ELEMENT));
  rb_define_const(cXMLReader, "TYPE_ATTRIBUTE", INT2FIX(XML_READER_TYPE_ATTRIBUTE));
  rb_define_const(cXMLReader, "TYPE_TEXT", INT2FIX(XML_READER_TYPE_TEXT));
  rb_define_const(cXMLReader, "TYPE_CDATA", INT2FIX(XML_READER_TYPE_CDATA));
  rb_define_const(cXMLReader, "TYPE_ENTITY_REFERENCE", INT2FIX(XML_READER_TYPE_ENTITY_REFERENCE));
  rb_define_const(cXMLReader, "TYPE_ENTITY", INT2FIX(XML_READER_TYPE_ENTITY));
  rb_define_const(cXMLReader, "TYPE_PROCESSING_INSTRUCTION", INT2FIX(XML_READER_TYPE_PROCESSING_INSTRUCTION));
  rb_define_const(cXMLReader, "TYPE_COMMENT", INT2FIX(XML_READER_TYPE_COMMENT));
  rb_define_const(cXMLReader, "TYPE_DOCUMENT",       INT2FIX(XML_READER_TYPE_DOCUMENT));
  rb_define_const(cXMLReader, "TYPE_DOCUMENT_TYPE", INT2FIX(XML_READER_TYPE_DOCUMENT_TYPE));
  rb_define_const(cXMLReader, "TYPE_DOCUMENT_FRAGMENT", INT2FIX(XML_READER_TYPE_DOCUMENT_FRAGMENT));
  rb_define_const(cXMLReader, "TYPE_NOTATION",       INT2FIX(XML_READER_TYPE_NOTATION));
  rb_define_const(cXMLReader, "TYPE_WHITESPACE", INT2FIX(XML_READER_TYPE_WHITESPACE));
  rb_define_const(cXMLReader, "TYPE_SIGNIFICANT_WHITESPACE", INT2FIX(XML_READER_TYPE_SIGNIFICANT_WHITESPACE));
  rb_define_const(cXMLReader, "TYPE_END_ELEMENT", INT2FIX(XML_READER_TYPE_END_ELEMENT));
  rb_define_const(cXMLReader, "TYPE_END_ENTITY", INT2FIX(XML_READER_TYPE_END_ENTITY));
  rb_define_const(cXMLReader, "TYPE_XML_DECLARATION", INT2FIX(XML_READER_TYPE_XML_DECLARATION));

  /* Read states */
  rb_define_const(cXMLReader, "MODE_INITIAL", INT2FIX(XML_TEXTREADER_MODE_INITIAL));
  rb_define_const(cXMLReader, "MODE_INTERACTIVE", INT2FIX(XML_TEXTREADER_MODE_INTERACTIVE));
  rb_define_const(cXMLReader, "MODE_ERROR", INT2FIX(XML_TEXTREADER_MODE_ERROR));
  rb_define_const(cXMLReader, "MODE_EOF", INT2FIX(XML_TEXTREADER_MODE_EOF));
  rb_define_const(cXMLReader, "MODE_CLOSED",       INT2FIX(XML_TEXTREADER_MODE_CLOSED));
  rb_define_const(cXMLReader, "MODE_READING", INT2FIX(XML_TEXTREADER_MODE_READING));
}
                                                                                                                                                                                                                                                                                                  ruby_xml_reader.h                                                                                   0100644 0001750 0001750 00000000645 12566211276 044533  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Copyright (c) 2006 Apple Computer Inc.
 * Please see the LICENSE file for copyright and distribution information. */

#ifndef __RXML_READER__
#define __RXML_READER__

#include <libxml/xmlreader.h>
#include <libxml/xmlschemas.h>

extern VALUE cXMLReader;

void rxml_init_reader(void);

/* Exported to be used by XML::Document#reader */
VALUE rxml_reader_new_walker(VALUE self, VALUE doc);

#endif /* __rxml_READER__ */
                                                                                           ruby_xml_relaxng.c                                                                                  0100644 0001750 0001750 00000005664 12566211276 044732  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_relaxng.h"

/*
 * Document-class: LibXML::XML::RelaxNG
 *
 * The XML::RelaxNG class is used to prepare RelaxNG schemas for validation
 * of xml documents.
 *
 * Schemas can be created from XML documents, strings or URIs using the
 * corresponding methods (new for URIs).
 *
 * Once a schema is prepared, an XML document can be validated by the
 * XML::Document#validate_relaxng method providing the XML::RelaxNG object
 * as parameter. The method will raise an exception if the document is
 * not valid.
 *
 * Basic Usage:
 *
 *  # parse schema as xml document
 *  relaxng_document = XML::Document.file('schema.rng')
 *
 *  # prepare schema for validation
 *  relaxng_schema = XML::RelaxNG.document(relaxng_document)
 *
 *  # parse xml document to be validated
 *  instance = XML::Document.file('instance.xml')
 *
 *  # validate
 *  instance.validate_relaxng(relaxng_schema)
 */

VALUE cXMLRelaxNG;

static void rxml_relaxng_free(xmlRelaxNGPtr xrelaxng)
{
  xmlRelaxNGFree(xrelaxng);
}

/*
 * call-seq:
 *    XML::Relaxng.new(relaxng_uri) -> relaxng
 *
 * Create a new relaxng from the specified URI.
 */
static VALUE rxml_relaxng_init_from_uri(VALUE class, VALUE uri)
{
  xmlRelaxNGParserCtxtPtr xparser;
  xmlRelaxNGPtr xrelaxng;

  Check_Type(uri, T_STRING);

  xparser = xmlRelaxNGNewParserCtxt(StringValuePtr(uri));
  xrelaxng = xmlRelaxNGParse(xparser);
  xmlRelaxNGFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);
}

/*
 * call-seq:
 *    XML::RelaxNG.document(document) -> relaxng
 *
 * Create a new relaxng from the specified document.
 */
static VALUE rxml_relaxng_init_from_document(VALUE class, VALUE document)
{
  xmlDocPtr xdoc;
  xmlRelaxNGPtr xrelaxng;
  xmlRelaxNGParserCtxtPtr xparser;

  Data_Get_Struct(document, xmlDoc, xdoc);

  xparser = xmlRelaxNGNewDocParserCtxt(xdoc);
  xrelaxng = xmlRelaxNGParse(xparser);
  xmlRelaxNGFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);
}

/*
 * call-seq:
 *    XML::RelaxNG.string("relaxng_data") -> "value"
 *
 * Create a new relaxng using the specified string.
 */
static VALUE rxml_relaxng_init_from_string(VALUE self, VALUE relaxng_str)
{
  xmlRelaxNGParserCtxtPtr xparser;
  xmlRelaxNGPtr xrelaxng;

  Check_Type(relaxng_str, T_STRING);

  xparser = xmlRelaxNGNewMemParserCtxt(StringValuePtr(relaxng_str), strlen(
      StringValuePtr(relaxng_str)));
  xrelaxng = xmlRelaxNGParse(xparser);
  xmlRelaxNGFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLRelaxNG, NULL, rxml_relaxng_free, xrelaxng);
}

void rxml_init_relaxng(void)
{
  cXMLRelaxNG = rb_define_class_under(mXML, "RelaxNG", rb_cObject);
  rb_define_singleton_method(cXMLRelaxNG, "new", rxml_relaxng_init_from_uri, 1);
  rb_define_singleton_method(cXMLRelaxNG, "from_string",
      rxml_relaxng_init_from_string, 1);
  rb_define_singleton_method(cXMLRelaxNG, "document",
      rxml_relaxng_init_from_document, 1);
}

                                                                            ruby_xml_relaxng.h                                                                                  0100644 0001750 0001750 00000000222 12566211276 044720  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_RELAXNG__
#define __RXML_RELAXNG__

#include <libxml/relaxng.h>

extern VALUE cXMLRelaxNG;

void  rxml_init_relaxng(void);
#endif

                                                                                                                                                                                                                                                                                                                                                                              ruby_xml_sax2_handler.c                                                                             0100644 0001750 0001750 00000022077 12566211276 045641  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_sax2_handler.h"


VALUE cbidOnCdataBlock;
VALUE cbidOnCharacters;
VALUE cbidOnComment;
VALUE cbidOnEndDocument;
VALUE cbidOnEndElement;
VALUE cbidOnEndElementNs;
VALUE cbidOnExternalSubset;
VALUE cbidOnHasExternalSubset;
VALUE cbidOnHasInternalSubset;
VALUE cbidOnInternalSubset;
VALUE cbidOnIsStandalone;
VALUE cbidOnError;
VALUE cbidOnProcessingInstruction;
VALUE cbidOnReference;
VALUE cbidOnStartElement;
VALUE cbidOnStartElementNs;
VALUE cbidOnStartDocument;

/* ======  Callbacks  =========== */
static void cdata_block_callback(void *ctx,
const char *value, int len)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnCdataBlock,1, rxml_new_cstr_len(value, len, NULL));
  }
}

static void characters_callback(void *ctx, const char *chars, int len)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    VALUE rchars = rxml_new_cstr_len(chars, len, NULL);
    rb_funcall(handler, cbidOnCharacters, 1, rchars);
  }
}

static void comment_callback(void *ctx, const char *msg)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnComment,1,rxml_new_cstr(msg, NULL));
  }
}

static void end_document_callback(void *ctx)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnEndDocument, 0);
  }
}

static void end_element_ns_callback(void *ctx,
  					                        const xmlChar *xlocalname, const xmlChar *xprefix, const xmlChar *xURI)
{
  VALUE handler = (VALUE) ctx;

  if (handler == Qnil)
    return;

  /* Call end element for old-times sake */
  if (rb_respond_to(handler, cbidOnEndElement))
  {
    VALUE name;
    if (xprefix)
    {
      name = rxml_new_cstr(xprefix, NULL);
      rb_str_cat2(name, ":"); 
      rb_str_cat2(name, xlocalname); 
    }
    else
    {
      name = rxml_new_cstr(xlocalname, NULL);
    }
    rb_funcall(handler, cbidOnEndElement, 1, name);
  }

  rb_funcall(handler, cbidOnEndElementNs, 3, 
             rxml_new_cstr(xlocalname, NULL),
             xprefix ? rxml_new_cstr(xprefix, NULL) : Qnil,
             xURI ? rxml_new_cstr(xURI, NULL) : Qnil);
}

static void external_subset_callback(void *ctx, const char *name, const char *extid, const char *sysid)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    VALUE rname = name ? rxml_new_cstr(name, NULL) : Qnil;
    VALUE rextid = extid ? rxml_new_cstr(extid, NULL) : Qnil;
    VALUE rsysid = sysid ? rxml_new_cstr(sysid, NULL) : Qnil;
    rb_funcall(handler, cbidOnExternalSubset, 3, rname, rextid, rsysid);
  }
}

static void has_external_subset_callback(void *ctx)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnHasExternalSubset, 0);
  }
}

static void has_internal_subset_callback(void *ctx)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnHasInternalSubset, 0);
  }
}

static void internal_subset_callback(void *ctx, const char *name, const char *extid, const char *sysid)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    VALUE rname = name ? rxml_new_cstr(name, NULL) : Qnil;
    VALUE rextid = extid ? rxml_new_cstr(extid, NULL) : Qnil;
    VALUE rsysid = sysid ? rxml_new_cstr(sysid, NULL) : Qnil;
    rb_funcall(handler, cbidOnInternalSubset, 3, rname, rextid, rsysid);
  }
}

static void is_standalone_callback(void *ctx)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnIsStandalone,0);
  }
}

static void processing_instruction_callback(void *ctx, const char *target, const char *data)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    VALUE rtarget = target ? rxml_new_cstr(target, NULL) : Qnil;
    VALUE rdata = data ? rxml_new_cstr(data, NULL) : Qnil;
    rb_funcall(handler, cbidOnProcessingInstruction, 2, rtarget, rdata);
  }
}

static void reference_callback(void *ctx, const char *name)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnReference,1,rxml_new_cstr(name, NULL));
  }
}

static void start_document_callback(void *ctx)
{
  VALUE handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    rb_funcall(handler, cbidOnStartDocument, 0);
  }
}

static void start_element_ns_callback(void *ctx, 
                                      const xmlChar *xlocalname, const xmlChar *xprefix, const xmlChar *xURI,
                            		  int nb_namespaces, const xmlChar **xnamespaces,
					                  int nb_attributes, int nb_defaulted, const xmlChar **xattributes)
{
  VALUE handler = (VALUE) ctx;
  VALUE attributes = rb_hash_new();
  VALUE namespaces = rb_hash_new();

  if (handler == Qnil)
    return;

  if (xattributes)
  {
    /* Each attribute is an array of [localname, prefix, URI, value, end] */
    int i;
    for (i = 0;i < nb_attributes * 5; i+=5) 
    {
      VALUE attrName = rxml_new_cstr(xattributes[i+0], NULL);
      VALUE attrValue = rxml_new_cstr_len(xattributes[i+3], xattributes[i+4] - xattributes[i+3], NULL);

      rb_hash_aset(attributes, attrName, attrValue);
    }
  }

  if (xnamespaces)
  {
    int i;
    for (i = 0;i < nb_namespaces * 2; i+=2) 
    {
      VALUE nsPrefix = xnamespaces[i+0] ? rxml_new_cstr(xnamespaces[i+0], NULL) : Qnil;
      VALUE nsURI = xnamespaces[i+1] ? rxml_new_cstr(xnamespaces[i+1], NULL) : Qnil;
      rb_hash_aset(namespaces, nsPrefix, nsURI);
    }
  }

  /* Call start element for old-times sake */
  if (rb_respond_to(handler, cbidOnStartElement))
  {
    VALUE name;
    if (xprefix)
    {
      name = rxml_new_cstr(xprefix, NULL);
      rb_str_cat2(name, ":"); 
      rb_str_cat2(name, xlocalname); 
    }
    else
    {
      name = rxml_new_cstr(xlocalname, NULL);
    }
    rb_funcall(handler, cbidOnStartElement, 2, name, attributes);
  }

  rb_funcall(handler, cbidOnStartElementNs, 5, 
             rxml_new_cstr(xlocalname, NULL),
             attributes,
             xprefix ? rxml_new_cstr(xprefix, NULL) : Qnil,
             xURI ? rxml_new_cstr(xURI, NULL) : Qnil,
             namespaces);
}

static void structured_error_callback(void *ctx, xmlErrorPtr xerror)
{
  /* Older versions of Libxml will pass a NULL context from the sax parser.  Fixed on
     Feb 23, 2011.  See:

     http://git.gnome.org/browse/libxml2/commit/?id=241d4a1069e6bedd0ee2295d7b43858109c1c6d1 */

  VALUE handler;

  #if LIBXML_VERSION <= 20708
    xmlParserCtxtPtr ctxt = (xmlParserCtxt*)(xerror->ctxt);
    ctx = ctxt->userData;
  #endif

  handler = (VALUE) ctx;

  if (handler != Qnil)
  {
    VALUE error = rxml_error_wrap(xerror);
    rb_funcall(handler, cbidOnError, 1, error);
  }
}

/* ======  Handler  =========== */
xmlSAXHandler rxml_sax_handler = {
  (internalSubsetSAXFunc) internal_subset_callback,
  (isStandaloneSAXFunc) is_standalone_callback,
  (hasInternalSubsetSAXFunc) has_internal_subset_callback,
  (hasExternalSubsetSAXFunc) has_external_subset_callback,
  0, /* resolveEntity */
  0, /* getEntity */
  0, /* entityDecl */
  0, /* notationDecl */
  0, /* attributeDecl */
  0, /* elementDecl */
  0, /* unparsedEntityDecl */
  0, /* setDocumentLocator */
  (startDocumentSAXFunc) start_document_callback,
  (endDocumentSAXFunc) end_document_callback,
  0, /* Use start_element_ns_callback instead */
  0, /* Use end_element_ns_callback instead */
  (referenceSAXFunc) reference_callback,
  (charactersSAXFunc) characters_callback,
  0, /* ignorableWhitespace */
  (processingInstructionSAXFunc) processing_instruction_callback,
  (commentSAXFunc) comment_callback,
  0, /* xmlStructuredErrorFunc is used instead */
  0, /* xmlStructuredErrorFunc is used instead */
  0, /* xmlStructuredErrorFunc is used instead */
  0, /* xmlGetParameterEntity */
  (cdataBlockSAXFunc) cdata_block_callback,
  (externalSubsetSAXFunc) external_subset_callback,
  XML_SAX2_MAGIC, /* force SAX2 */
  0, /* _private */
  (startElementNsSAX2Func) start_element_ns_callback,
  (endElementNsSAX2Func) end_element_ns_callback,
  (xmlStructuredErrorFunc) structured_error_callback
};

void rxml_init_sax2_handler(void)
{

  /* SaxCallbacks */
  cbidOnCdataBlock =            rb_intern("on_cdata_block");
  cbidOnCharacters =            rb_intern("on_characters");
  cbidOnComment =               rb_intern("on_comment");
  cbidOnEndDocument =           rb_intern("on_end_document");
  cbidOnEndElement =            rb_intern("on_end_element");
  cbidOnEndElementNs =          rb_intern("on_end_element_ns");
  cbidOnError =                 rb_intern("on_error");
  cbidOnExternalSubset =        rb_intern("on_external_subset");
  cbidOnHasExternalSubset =     rb_intern("on_has_external_subset");
  cbidOnHasInternalSubset =     rb_intern("on_has_internal_subset");
  cbidOnInternalSubset =        rb_intern("on_internal_subset");
  cbidOnIsStandalone =          rb_intern("on_is_standalone");
  cbidOnProcessingInstruction = rb_intern("on_processing_instruction");
  cbidOnReference =             rb_intern("on_reference");
  cbidOnStartElement =          rb_intern("on_start_element");
  cbidOnStartElementNs =        rb_intern("on_start_element_ns");
  cbidOnStartDocument =         rb_intern("on_start_document");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ruby_xml_sax2_handler.h                                                                             0100644 0001750 0001750 00000000336 12566211276 045640  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_SAX2_HANDLER__
#define __RXML_SAX2_HANDLER__

extern xmlSAXHandler rxml_sax_handler;

void rxml_init_sax2_handler(void);

#endif
                                                                                                                                                                                                                                                                                                  ruby_xml_sax_parser.c                                                                               0100644 0001750 0001750 00000006266 12566211276 045440  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_sax_parser.h"

/*
 * Document-class: LibXML::XML::SaxParser
 *
 * XML::SaxParser provides a callback based API for parsing documents,
 * in contrast to XML::Parser's tree based API and XML::Reader's stream
 * based API.
 *
 * The XML::SaxParser API is fairly complex, not well standardized,
 * and does not directly support validation making entity, namespace and
 * base processing relatively hard.
 *
 * To use the XML::SaxParser, register a callback class via the
 * XML::SaxParser#callbacks=.  It is easiest to include the
 * XML::SaxParser::Callbacks module in your class and override
 * the methods as needed.
 *
 * Basic example:
 *
 *   class MyCallbacks
 *     include XML::SaxParser::Callbacks
 *     def on_start_element(element, attributes)
 *       puts #Element started: #{element}"
 *     end
 *   end
 *
 *   parser = XML::SaxParser.string(my_string)
 *   parser.callbacks = MyCallbacks.new
 *   parser.parse
 *
 * You can also parse strings (see XML::SaxParser.string) and
 * io objects (see XML::SaxParser.io).
 */

VALUE cXMLSaxParser;
static ID CALLBACKS_ATTR;
static ID CONTEXT_ATTR;


/* ======  Parser  =========== */

/*
 * call-seq:
 *    parser.initialize(context) -> XML::Parser
 *
 * Creates a new XML::Parser from the specified 
 * XML::Parser::Context.
 */
static VALUE rxml_sax_parser_initialize(int argc, VALUE *argv, VALUE self)
{
  VALUE context = Qnil;

  rb_scan_args(argc, argv, "01", &context);

  if (context == Qnil)
  {
    rb_warn("Passing no parameters to XML::SaxParser.new is deprecated.  Pass an instance of XML::Parser::Context instead.");
    context = rb_class_new_instance(0, NULL, cXMLParserContext);
  }

  rb_ivar_set(self, CONTEXT_ATTR, context);
  return self;
}

/*
 * call-seq:
 *    parser.parse -> (true|false)
 *
 * Parse the input XML, generating callbacks to the object
 * registered via the +callbacks+ attributesibute.
 */
static VALUE rxml_sax_parser_parse(VALUE self)
{
  int status;
  VALUE context = rb_ivar_get(self, CONTEXT_ATTR);
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(context, xmlParserCtxt, ctxt);

  ctxt->sax2 = 1;
	ctxt->userData = (void*)rb_ivar_get(self, CALLBACKS_ATTR);

  if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)
    xmlFree(ctxt->sax);
    
  ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(rxml_sax_handler));
  if (ctxt->sax == NULL)
    rb_fatal("Not enough memory.");
  memcpy(ctxt->sax, &rxml_sax_handler, sizeof(rxml_sax_handler));
    
  status = xmlParseDocument(ctxt);

  /* Now check the parsing result*/
  if (status == -1 || !ctxt->wellFormed)
  {
    if (ctxt->myDoc)
      xmlFreeDoc(ctxt->myDoc);

    rxml_raise(&ctxt->lastError);
  }
  return Qtrue;
}

void rxml_init_sax_parser(void)
{
  /* SaxParser */
  cXMLSaxParser = rb_define_class_under(mXML, "SaxParser", rb_cObject);

  /* Atributes */
  CALLBACKS_ATTR = rb_intern("@callbacks");
  CONTEXT_ATTR = rb_intern("@context");
  rb_define_attr(cXMLSaxParser, "callbacks", 1, 1);

  /* Instance Methods */
  rb_define_method(cXMLSaxParser, "initialize", rxml_sax_parser_initialize, -1);
  rb_define_method(cXMLSaxParser, "parse", rxml_sax_parser_parse, 0);
}
                                                                                                                                                                                                                                                                                                                                          ruby_xml_sax_parser.h                                                                               0100644 0001750 0001750 00000000315 12566211276 045432  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_SAX_PARSER__
#define __RXML_SAX_PARSER__

extern VALUE cXMLSaxParser;

void rxml_init_sax_parser(void);

#endif
                                                                                                                                                                                                                                                                                                                   ruby_xml_schema.c                                                                                   0100644 0001750 0001750 00000016427 12566211276 044531  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#define LIBXML_OUTPUT_ENABLED
#define DUMP_CONTENT_MODEL
#include "ruby_xml_schema.h"

#include "ruby_xml_schema_type.h"
#include "ruby_xml_schema_element.h"
#include "ruby_xml_schema_attribute.h"
#include "ruby_xml_schema_facet.h"


/*
 * Document-class: LibXML::XML::Schema
 *
 * The XML::Schema class is used to prepare XML Schemas for validation of xml
 * documents.
 *
 * Schemas can be created from XML documents, strinings or URIs using the
 * corresponding methods (new for URIs).
 *
 * Once a schema is prepared, an XML document can be validated by the
 * XML::Document#validate_schema method providing the XML::Schema object
 * as parameter. The method return true if the document validates, false
 * otherwise.
 *
 * Basic usage:
 *
 *  # parse schema as xml document
 *  schema_document = XML::Document.file('schema.rng')
 *
 *  # prepare schema for validation
 *  schema = XML::Schema.document(schema_document)
 *
 *  # parse xml document to be validated
 *  instance = XML::Document.file('instance.xml')
 *
 *  # validate
 *  instance.validate_schema(schema)
 */

VALUE cXMLSchema;

static void rxml_schema_free(xmlSchemaPtr xschema)
{
  xmlSchemaFree(xschema);
}

VALUE rxml_wrap_schema(xmlSchemaPtr xschema)
{
  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);
}


/*
 * call-seq:
 *    XML::Schema.initialize(schema_uri) -> schema
 *
 * Create a new schema from the specified URI.
 */
static VALUE rxml_schema_init_from_uri(VALUE class, VALUE uri)
{
  xmlSchemaParserCtxtPtr xparser;
  xmlSchemaPtr xschema;

  Check_Type(uri, T_STRING);

  xparser = xmlSchemaNewParserCtxt(StringValuePtr(uri));
  xschema = xmlSchemaParse(xparser);
  xmlSchemaFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);
}

/*
 * call-seq:
 *    XML::Schema.document(document) -> schema
 *
 * Create a new schema from the specified document.
 */
static VALUE rxml_schema_init_from_document(VALUE class, VALUE document)
{
  xmlDocPtr xdoc;
  xmlSchemaPtr xschema;
  xmlSchemaParserCtxtPtr xparser;

  Data_Get_Struct(document, xmlDoc, xdoc);

  xparser = xmlSchemaNewDocParserCtxt(xdoc);
  xschema = xmlSchemaParse(xparser);
  xmlSchemaFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);
}

/*
 * call-seq:
 *    XML::Schema.string("schema_data") -> "value"
 *
 * Create a new schema using the specified string.
 */
static VALUE rxml_schema_init_from_string(VALUE self, VALUE schema_str)
{
  xmlSchemaParserCtxtPtr xparser;
  xmlSchemaPtr xschema;

  Check_Type(schema_str, T_STRING);

  xparser = xmlSchemaNewMemParserCtxt(StringValuePtr(schema_str), strlen(
      StringValuePtr(schema_str)));
  xschema = xmlSchemaParse(xparser);
  xmlSchemaFreeParserCtxt(xparser);

  return Data_Wrap_Struct(cXMLSchema, NULL, rxml_schema_free, xschema);
}


static VALUE rxml_schema_target_namespace(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  QNIL_OR_STRING(xschema->targetNamespace)
}

static VALUE rxml_schema_name(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  QNIL_OR_STRING(xschema->name)
}

static VALUE rxml_schema_version(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  QNIL_OR_STRING(xschema->version)
}

static VALUE rxml_schema_id(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  QNIL_OR_STRING(xschema->id)
}


static VALUE rxml_schema_document(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  return rxml_node_wrap(xmlDocGetRootElement(xschema->doc));
}

static void storeNs(xmlSchemaImportPtr import, VALUE self, xmlChar *nsname)
{
  VALUE schemas;
  xmlNodePtr xnode;
  xmlNsPtr xns;

  schemas = rb_iv_get(self, "@namespaces");
  if (import->doc) {
    xnode = xmlDocGetRootElement(import->doc);

    xns = xnode->nsDef;

    while (xns) {
      VALUE anamespace = rxml_namespace_wrap(xns);
      rb_ary_push(schemas, anamespace);
      xns = xns->next;
    }
  }
}

static VALUE rxml_schema_namespaces(VALUE self)
{
  VALUE schemas;
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  if (rb_iv_get(self, "@namespaces") == Qnil) {
    schemas = rb_ary_new();
    rb_iv_set(self, "@namespaces", schemas);
    xmlHashScan(xschema->schemasImports, (xmlHashScanner) storeNs, (void *)self);
  }

  return rb_iv_get(self, "@namespaces");
}

static void storeType(xmlSchemaTypePtr type, VALUE self, xmlChar *name)
{
  VALUE types;
  VALUE rtype;

  types = rb_iv_get(self, "@types");
  rtype = rxml_wrap_schema_type(type);

  rb_hash_aset(types, rb_str_new2(name), rtype);
}

static VALUE rxml_schema_collect_types(VALUE self);

static VALUE rxml_schema_types(VALUE self)
{
  VALUE types;
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  if (rb_iv_get(self, "@types") == Qnil) {
    types = rb_hash_new();
    rb_iv_set(self, "@types", types);
    rxml_schema_collect_types(self);
    if(xschema != NULL && xschema->typeDecl != NULL)
      xmlHashScan(xschema->typeDecl, (xmlHashScanner) storeType, (void *)self);
  }

  return rb_iv_get(self, "@types");
}

static void storeElement(xmlSchemaElementPtr element, VALUE self, xmlChar *name)
{
  VALUE elements;
  VALUE relement;

  elements = rb_iv_get(self, "@elements");
  relement = rxml_wrap_schema_element(element);
  rb_hash_aset(elements, rb_str_new2(name), relement);
}

static VALUE rxml_schema_elements(VALUE self)
{
  VALUE elements;
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  if (rb_iv_get(self, "@elements") == Qnil) {
    elements = rb_hash_new();
    rb_iv_set(self, "@elements", elements);
    xmlHashScan(xschema->elemDecl, (xmlHashScanner) storeElement, (void *)self);
  }

  return rb_iv_get(self, "@elements");
}

static void collectSchemaTypes(xmlSchemaImportPtr import, VALUE self)
{
  if (import->imported && import->schema) {
    xmlHashScan(import->schema->typeDecl, (xmlHashScanner) storeType, (void *)self);
  }
}

static VALUE rxml_schema_collect_types(VALUE self)
{
  xmlSchemaPtr xschema;

  Data_Get_Struct(self, xmlSchema, xschema);

  if(xschema){
    xmlHashScan(xschema->schemasImports, (xmlHashScanner) collectSchemaTypes, (void *)self);
  }

  return Qnil;
}

void rxml_init_schema(void)
{
  cXMLSchema = rb_define_class_under(mXML, "Schema", rb_cObject);
  rb_define_singleton_method(cXMLSchema, "new", rxml_schema_init_from_uri, 1);
  rb_define_singleton_method(cXMLSchema, "from_string", rxml_schema_init_from_string, 1);
  rb_define_singleton_method(cXMLSchema, "document", rxml_schema_init_from_document, 1);

  rb_define_method(cXMLSchema, "target_namespace", rxml_schema_target_namespace, 0);
  rb_define_method(cXMLSchema, "name", rxml_schema_name, 0);
  rb_define_method(cXMLSchema, "id", rxml_schema_id, 0);
  rb_define_method(cXMLSchema, "version", rxml_schema_version, 0);
  rb_define_method(cXMLSchema, "document", rxml_schema_document, 0);

  rb_define_method(cXMLSchema, "_namespaces", rxml_schema_namespaces, 0);
  rb_define_method(cXMLSchema, "_collect_types", rxml_schema_collect_types, 0);
  rb_define_method(cXMLSchema, "types", rxml_schema_types, 0);
  rb_define_method(cXMLSchema, "elements", rxml_schema_elements, 0);

  rxml_init_schema_facet();
  rxml_init_schema_element();
  rxml_init_schema_attribute();
  rxml_init_schema_type();
}
                                                                                                                                                                                                                                         ruby_xml_schema.h                                                                                   0100644 0001750 0001750 00000052055 12566211276 044533  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_SCHEMA__
#define __RXML_SCHEMA__

#include <libxml/schemasInternals.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>

extern VALUE cXMLSchema;

void rxml_init_schema(void);

#define QNIL_OR_STRING(slot)			\
    if (slot == NULL) \
      return Qnil; \
    else \
	    return rb_str_new2((const char *)slot);

#define SUBSET_RESTRICTION  1<<0
#define SUBSET_EXTENSION    1<<1
#define SUBSET_SUBSTITUTION 1<<2
#define SUBSET_LIST         1<<3
#define SUBSET_UNION        1<<4

typedef struct _xmlSchemaNodeInfo xmlSchemaNodeInfo;
typedef xmlSchemaNodeInfo *xmlSchemaNodeInfoPtr;

typedef struct _xmlSchemaItemList xmlSchemaItemList;
typedef xmlSchemaItemList *xmlSchemaItemListPtr;
struct _xmlSchemaItemList {
    void **items;
    /* used for dynamic addition of schemata */
    int nbItems;
    /* used for dynamic addition of schemata */
    int sizeItems; /* used for dynamic addition of schemata */
};

#define XML_SCHEMA_CTXT_PARSER 1
#define XML_SCHEMA_CTXT_VALIDATOR 2

typedef struct _xmlSchemaAbstractCtxt xmlSchemaAbstractCtxt;
typedef xmlSchemaAbstractCtxt *xmlSchemaAbstractCtxtPtr;
struct _xmlSchemaAbstractCtxt {
    int type; /* E.g. XML_SCHEMA_CTXT_VALIDATOR */
};

typedef struct _xmlSchemaBucket xmlSchemaBucket;
typedef xmlSchemaBucket *xmlSchemaBucketPtr;

#define XML_SCHEMA_SCHEMA_MAIN 0
#define XML_SCHEMA_SCHEMA_IMPORT 1
#define XML_SCHEMA_SCHEMA_INCLUDE 2
#define XML_SCHEMA_SCHEMA_REDEFINE 3

/**
 * xmlSchemaSchemaRelation:
 *
 * Used to create a graph of schema relationships.
 */
typedef struct _xmlSchemaSchemaRelation xmlSchemaSchemaRelation;
typedef xmlSchemaSchemaRelation *xmlSchemaSchemaRelationPtr;
struct _xmlSchemaSchemaRelation {
    xmlSchemaSchemaRelationPtr next;
    int type;
    /* E.g. XML_SCHEMA_SCHEMA_IMPORT */
    const xmlChar *importNamespace;
    xmlSchemaBucketPtr bucket;
};

#define XML_SCHEMA_BUCKET_MARKED 1<<0
#define XML_SCHEMA_BUCKET_COMPS_ADDED 1<<1

struct _xmlSchemaBucket {
    int type;
    int flags;
    const xmlChar *schemaLocation;
    const xmlChar *origTargetNamespace;
    const xmlChar *targetNamespace;
    xmlDocPtr doc;
    xmlSchemaSchemaRelationPtr relations;
    int located;
    int parsed;
    int imported;
    int preserveDoc;
    xmlSchemaItemListPtr globals;
    /* Global components. */
    xmlSchemaItemListPtr locals; /* Local components. */
};

/**
 * xmlSchemaImport:
 * (extends xmlSchemaBucket)
 *
 * Reflects a schema. Holds some information
 * about the schema and its toplevel components. Duplicate
 * toplevel components are not checked at this level.
 */
typedef struct _xmlSchemaImport xmlSchemaImport;
typedef xmlSchemaImport *xmlSchemaImportPtr;
struct _xmlSchemaImport {
    int type;
    /* Main OR import OR include. */
    int flags;
    const xmlChar *schemaLocation; /* The URI of the schema document. */
    /* For chameleon includes, @origTargetNamespace will be NULL */
    const xmlChar *origTargetNamespace;
    /*
    * For chameleon includes, @targetNamespace will be the
    * targetNamespace of the including schema.
    */
    const xmlChar *targetNamespace;
    xmlDocPtr doc; /* The schema node-tree. */
    /* @relations will hold any included/imported/redefined schemas. */
    xmlSchemaSchemaRelationPtr relations;
    int located;
    int parsed;
    int imported;
    int preserveDoc;
    xmlSchemaItemListPtr globals;
    xmlSchemaItemListPtr locals;
    /* The imported schema. */
    xmlSchemaPtr schema;
};

/*
* (extends xmlSchemaBucket)
*/
typedef struct _xmlSchemaInclude xmlSchemaInclude;
typedef xmlSchemaInclude *xmlSchemaIncludePtr;
struct _xmlSchemaInclude {
    int type;
    int flags;
    const xmlChar *schemaLocation;
    const xmlChar *origTargetNamespace;
    const xmlChar *targetNamespace;
    xmlDocPtr doc;
    xmlSchemaSchemaRelationPtr relations;
    int located;
    int parsed;
    int imported;
    int preserveDoc;
    xmlSchemaItemListPtr globals;
    /* Global components. */
    xmlSchemaItemListPtr locals; /* Local components. */

    /* The owning main or import schema bucket. */
    xmlSchemaImportPtr ownerImport;
};

/**
 * xmlSchemaBasicItem:
 *
 * The abstract base type for schema components.
 */
typedef struct _xmlSchemaBasicItem xmlSchemaBasicItem;
typedef xmlSchemaBasicItem *xmlSchemaBasicItemPtr;
struct _xmlSchemaBasicItem {
    xmlSchemaTypeType type;
};

/**
 * xmlSchemaAnnotItem:
 *
 * The abstract base type for annotated schema components.
 * (Extends xmlSchemaBasicItem)
 */
typedef struct _xmlSchemaAnnotItem xmlSchemaAnnotItem;
typedef xmlSchemaAnnotItem *xmlSchemaAnnotItemPtr;
struct _xmlSchemaAnnotItem {
    xmlSchemaTypeType type;
    xmlSchemaAnnotPtr annot;
};

/**
 * xmlSchemaTreeItem:
 *
 * The abstract base type for tree-like structured schema components.
 * (Extends xmlSchemaAnnotItem)
 */
typedef struct _xmlSchemaTreeItem xmlSchemaTreeItem;
typedef xmlSchemaTreeItem *xmlSchemaTreeItemPtr;
struct _xmlSchemaTreeItem {
    xmlSchemaTypeType type;
    xmlSchemaAnnotPtr annot;
    xmlSchemaTreeItemPtr next;
    xmlSchemaTreeItemPtr children;
};


#define XML_SCHEMA_ATTR_USE_FIXED 1<<0
/**
 * xmlSchemaAttributeUsePtr:
 *
 * The abstract base type for tree-like structured schema components.
 * (Extends xmlSchemaTreeItem)
 */
typedef struct _xmlSchemaAttributeUse xmlSchemaAttributeUse;
typedef xmlSchemaAttributeUse *xmlSchemaAttributeUsePtr;
struct _xmlSchemaAttributeUse {
    xmlSchemaTypeType type;
    xmlSchemaAnnotPtr annot;
    xmlSchemaAttributeUsePtr next; /* The next attr. use. */
    /*
    * The attr. decl. OR a QName-ref. to an attr. decl. OR
    * a QName-ref. to an attribute group definition.
    */
    xmlSchemaAttributePtr attrDecl;

    int flags;
    xmlNodePtr node;
    int occurs;
    /* required, optional */
    const xmlChar *defValue;
    xmlSchemaValPtr defVal;
};

/**
 * xmlSchemaAttributeUseProhibPtr:
 *
 * A helper component to reflect attribute prohibitions.
 * (Extends xmlSchemaBasicItem)
 */
typedef struct _xmlSchemaAttributeUseProhib xmlSchemaAttributeUseProhib;
typedef xmlSchemaAttributeUseProhib *xmlSchemaAttributeUseProhibPtr;
struct _xmlSchemaAttributeUseProhib {
    xmlSchemaTypeType type;
    /* == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB */
    xmlNodePtr node;
    const xmlChar *name;
    const xmlChar *targetNamespace;
    int isRef;
};

/**
 * xmlSchemaRedef:
 */
typedef struct _xmlSchemaRedef xmlSchemaRedef;
typedef xmlSchemaRedef *xmlSchemaRedefPtr;
struct _xmlSchemaRedef {
    xmlSchemaRedefPtr next;
    xmlSchemaBasicItemPtr item;
    /* The redefining component. */
    xmlSchemaBasicItemPtr reference;
    /* The referencing component. */
    xmlSchemaBasicItemPtr target;
    /* The to-be-redefined component. */
    const xmlChar *refName;
    /* The name of the to-be-redefined component. */
    const xmlChar *refTargetNs;
    /* The target namespace of the
  to-be-redefined comp. */
    xmlSchemaBucketPtr targetBucket; /* The redefined schema. */
};

/**
 * xmlSchemaConstructionCtxt:
 */
typedef struct _xmlSchemaConstructionCtxt xmlSchemaConstructionCtxt;
typedef xmlSchemaConstructionCtxt *xmlSchemaConstructionCtxtPtr;
struct _xmlSchemaConstructionCtxt {
    xmlSchemaPtr mainSchema;
    /* The main schema. */
    xmlSchemaBucketPtr mainBucket;
    /* The main schema bucket */
    xmlDictPtr dict;
    xmlSchemaItemListPtr buckets; /* List of schema buckets. */
    /* xmlSchemaItemListPtr relations; */ /* List of schema relations. */
xmlSchemaBucketPtr bucket;
    /* The current schema bucket */
    xmlSchemaItemListPtr pending;
    /* All Components of all schemas that
need to be fixed. */
    xmlHashTablePtr substGroups;
    xmlSchemaRedefPtr redefs;
    xmlSchemaRedefPtr lastRedef;
};

#define XML_SCHEMAS_PARSE_ERROR        1
#define SCHEMAS_PARSE_OPTIONS XML_PARSE_NOENT

struct _xmlSchemaParserCtxt {
    int type;
    void *errCtxt;
    /* user specific error context */
    xmlSchemaValidityErrorFunc error;
    /* the callback in case of errors */
    xmlSchemaValidityWarningFunc warning;
    /* the callback in case of warning */
    int err;
    int nberrors;
    xmlStructuredErrorFunc serror;

    xmlSchemaConstructionCtxtPtr constructor;
    int ownsConstructor; /* TODO: Move this to parser *flags*. */

    /* xmlSchemaPtr topschema;	*/
    /* xmlHashTablePtr namespaces;  */

    xmlSchemaPtr schema;
    /* The main schema in use */
    int counter;

    const xmlChar *URL;
    xmlDocPtr doc;
    int preserve;
    /* Whether the doc should be freed  */

    const char *buffer;
    int size;

    /*
     * Used to build complex element content models
     */
    xmlAutomataPtr am;
    xmlAutomataStatePtr start;
    xmlAutomataStatePtr end;
    xmlAutomataStatePtr state;

    xmlDictPtr dict;
    /* dictionnary for interned string names */
    xmlSchemaTypePtr ctxtType;
    /* The current context simple/complex type */
    int options;
    xmlSchemaValidCtxtPtr vctxt;
    int isS4S;
    int isRedefine;
    int xsiAssemble;
    int stop;
    /* If the parser should stop; i.e. a critical error. */
    const xmlChar *targetNamespace;
    xmlSchemaBucketPtr redefined;
    /* The schema to be redefined. */

    xmlSchemaRedefPtr redef;
    /* Used for redefinitions. */
    int redefCounter;
    /* Used for redefinitions. */
    xmlSchemaItemListPtr attrProhibs;
};

/**
 * xmlSchemaQNameRef:
 *
 * A component reference item (not a schema component)
 * (Extends xmlSchemaBasicItem)
 */
typedef struct _xmlSchemaQNameRef xmlSchemaQNameRef;
typedef xmlSchemaQNameRef *xmlSchemaQNameRefPtr;
struct _xmlSchemaQNameRef {
    xmlSchemaTypeType type;
    xmlSchemaBasicItemPtr item;
    /* The resolved referenced item. */
    xmlSchemaTypeType itemType;
    const xmlChar *name;
    const xmlChar *targetNamespace;
    xmlNodePtr node;
};

/**
 * xmlSchemaParticle:
 *
 * A particle component.
 * (Extends xmlSchemaTreeItem)
 */
typedef struct _xmlSchemaParticle xmlSchemaParticle;
typedef xmlSchemaParticle *xmlSchemaParticlePtr;
struct _xmlSchemaParticle {
    xmlSchemaTypeType type;
    xmlSchemaAnnotPtr annot;
    xmlSchemaTreeItemPtr next;
    /* next particle */
    xmlSchemaTreeItemPtr children;
    /* the "term" (e.g. a model group,
a group definition, a XML_SCHEMA_EXTRA_QNAMEREF (if a reference),
   etc.) */
    int minOccurs;
    int maxOccurs;
    xmlNodePtr node;
};

/**
 * xmlSchemaModelGroup:
 *
 * A model group component.
 * (Extends xmlSchemaTreeItem)
 */
typedef struct _xmlSchemaModelGroup xmlSchemaModelGroup;
typedef xmlSchemaModelGroup *xmlSchemaModelGroupPtr;
struct _xmlSchemaModelGroup {
    xmlSchemaTypeType type;
    /* XML_SCHEMA_TYPE_SEQUENCE, XML_SCHEMA_TYPE_CHOICE, XML_SCHEMA_TYPE_ALL */
    xmlSchemaAnnotPtr annot;
    xmlSchemaTreeItemPtr next;
    /* not used */
    xmlSchemaTreeItemPtr children;
    /* first particle (OR "element decl" OR "wildcard") */
    xmlNodePtr node;
};

#define XML_SCHEMA_MODEL_GROUP_DEF_MARKED 1<<0
#define XML_SCHEMA_MODEL_GROUP_DEF_REDEFINED 1<<1
/**
 * xmlSchemaModelGroupDef:
 *
 * A model group definition component.
 * (Extends xmlSchemaTreeItem)
 */
typedef struct _xmlSchemaModelGroupDef xmlSchemaModelGroupDef;
typedef xmlSchemaModelGroupDef *xmlSchemaModelGroupDefPtr;
struct _xmlSchemaModelGroupDef {
    xmlSchemaTypeType type;
    /* XML_SCHEMA_TYPE_GROUP */
    xmlSchemaAnnotPtr annot;
    xmlSchemaTreeItemPtr next;
    /* not used */
    xmlSchemaTreeItemPtr children;
    /* the "model group" */
    const xmlChar *name;
    const xmlChar *targetNamespace;
    xmlNodePtr node;
    int flags;
};

typedef struct _xmlSchemaIDC xmlSchemaIDC;
typedef xmlSchemaIDC *xmlSchemaIDCPtr;

/**
 * xmlSchemaIDCSelect:
 *
 * The identity-constraint "field" and "selector" item, holding the
 * XPath expression.
 */
typedef struct _xmlSchemaIDCSelect xmlSchemaIDCSelect;
typedef xmlSchemaIDCSelect *xmlSchemaIDCSelectPtr;
struct _xmlSchemaIDCSelect {
    xmlSchemaIDCSelectPtr next;
    xmlSchemaIDCPtr idc;
    int index;
    /* an index position if significant for IDC key-sequences */
    const xmlChar *xpath;
    /* the XPath expression */
    void *xpathComp; /* the compiled XPath expression */
};

/**
 * xmlSchemaIDC:
 *
 * The identity-constraint definition component.
 * (Extends xmlSchemaAnnotItem)
 */

struct _xmlSchemaIDC {
    xmlSchemaTypeType type;
    xmlSchemaAnnotPtr annot;
    xmlSchemaIDCPtr next;
    xmlNodePtr node;
    const xmlChar *name;
    const xmlChar *targetNamespace;
    xmlSchemaIDCSelectPtr selector;
    xmlSchemaIDCSelectPtr fields;
    int nbFields;
    xmlSchemaQNameRefPtr ref;
};

/**
 * xmlSchemaIDCAug:
 *
 * The augmented IDC information used for validation.
 */
typedef struct _xmlSchemaIDCAug xmlSchemaIDCAug;
typedef xmlSchemaIDCAug *xmlSchemaIDCAugPtr;
struct _xmlSchemaIDCAug {
    xmlSchemaIDCAugPtr next;
    /* next in a list */
    xmlSchemaIDCPtr def;
    /* the IDC definition */
    int keyrefDepth; /* the lowest tree level to which IDC
                        tables need to be bubbled upwards */
};

/**
 * xmlSchemaPSVIIDCKeySequence:
 *
 * The key sequence of a node table item.
 */
typedef struct _xmlSchemaPSVIIDCKey xmlSchemaPSVIIDCKey;
typedef xmlSchemaPSVIIDCKey *xmlSchemaPSVIIDCKeyPtr;
struct _xmlSchemaPSVIIDCKey {
    xmlSchemaTypePtr type;
    xmlSchemaValPtr val;
};

/**
 * xmlSchemaPSVIIDCNode:
 *
 * The node table item of a node table.
 */
typedef struct _xmlSchemaPSVIIDCNode xmlSchemaPSVIIDCNode;
typedef xmlSchemaPSVIIDCNode *xmlSchemaPSVIIDCNodePtr;
struct _xmlSchemaPSVIIDCNode {
    xmlNodePtr node;
    xmlSchemaPSVIIDCKeyPtr *keys;
    int nodeLine;
    int nodeQNameID;

};

/**
 * xmlSchemaPSVIIDCBinding:
 *
 * The identity-constraint binding item of the [identity-constraint table].
 */
typedef struct _xmlSchemaPSVIIDCBinding xmlSchemaPSVIIDCBinding;
typedef xmlSchemaPSVIIDCBinding *xmlSchemaPSVIIDCBindingPtr;
struct _xmlSchemaPSVIIDCBinding {
    xmlSchemaPSVIIDCBindingPtr next;
    /* next binding of a specific node */
    xmlSchemaIDCPtr definition;
    /* the IDC definition */
    xmlSchemaPSVIIDCNodePtr *nodeTable;
    /* array of key-sequences */
    int nbNodes;
    /* number of entries in the node table */
    int sizeNodes;
    /* size of the node table */
    xmlSchemaItemListPtr dupls;
};


#define XPATH_STATE_OBJ_TYPE_IDC_SELECTOR 1
#define XPATH_STATE_OBJ_TYPE_IDC_FIELD 2

#define XPATH_STATE_OBJ_MATCHES -2
#define XPATH_STATE_OBJ_BLOCKED -3

typedef struct _xmlSchemaIDCMatcher xmlSchemaIDCMatcher;
typedef xmlSchemaIDCMatcher *xmlSchemaIDCMatcherPtr;

/**
 * xmlSchemaIDCStateObj:
 *
 * The state object used to evaluate XPath expressions.
 */
typedef struct _xmlSchemaIDCStateObj xmlSchemaIDCStateObj;
typedef xmlSchemaIDCStateObj *xmlSchemaIDCStateObjPtr;
struct _xmlSchemaIDCStateObj {
    int type;
    xmlSchemaIDCStateObjPtr next;
    /* next if in a list */
    int depth;
    /* depth of creation */
    int *history;
    /* list of (depth, state-id) tuples */
    int nbHistory;
    int sizeHistory;
    xmlSchemaIDCMatcherPtr matcher;
    /* the correspondent field/selector
   matcher */
    xmlSchemaIDCSelectPtr sel;
    void *xpathCtxt;
};

#define IDC_MATCHER 0

/**
 * xmlSchemaIDCMatcher:
 *
 * Used to evaluate IDC selectors (and fields).
 */
struct _xmlSchemaIDCMatcher {
    int type;
    int depth;
    /* the tree depth at creation time */
    xmlSchemaIDCMatcherPtr next;
    /* next in the list */
    xmlSchemaIDCMatcherPtr nextCached;
    /* next in the cache list */
    xmlSchemaIDCAugPtr aidc;
    /* the augmented IDC item */
    int idcType;
    xmlSchemaPSVIIDCKeyPtr **keySeqs;
    /* the key-sequences of the target
   elements */
    int sizeKeySeqs;
    xmlSchemaItemListPtr targets; /* list of target-node
                                     (xmlSchemaPSVIIDCNodePtr) entries */
};

/*
* Element info flags.
*/
#define XML_SCHEMA_NODE_INFO_FLAG_OWNED_NAMES  1<<0
#define XML_SCHEMA_NODE_INFO_FLAG_OWNED_VALUES 1<<1
#define XML_SCHEMA_ELEM_INFO_NILLED           1<<2
#define XML_SCHEMA_ELEM_INFO_LOCAL_TYPE           1<<3

#define XML_SCHEMA_NODE_INFO_VALUE_NEEDED      1<<4
#define XML_SCHEMA_ELEM_INFO_EMPTY             1<<5
#define XML_SCHEMA_ELEM_INFO_HAS_CONTENT       1<<6

#define XML_SCHEMA_ELEM_INFO_HAS_ELEM_CONTENT  1<<7
#define XML_SCHEMA_ELEM_INFO_ERR_BAD_CONTENT  1<<8
#define XML_SCHEMA_NODE_INFO_ERR_NOT_EXPECTED  1<<9
#define XML_SCHEMA_NODE_INFO_ERR_BAD_TYPE  1<<10

/**
 * xmlSchemaNodeInfo:
 *
 * Holds information of an element node.
 */
struct _xmlSchemaNodeInfo {
    int nodeType;
    xmlNodePtr node;
    int nodeLine;
    const xmlChar *localName;
    const xmlChar *nsName;
    const xmlChar *value;
    xmlSchemaValPtr val;
    /* the pre-computed value if any */
    xmlSchemaTypePtr typeDef;
    /* the complex/simple type definition if any */

    int flags;
    /* combination of node info flags */

    int valNeeded;
    int normVal;

    xmlSchemaElementPtr decl;
    /* the element/attribute declaration */
    int depth;
    xmlSchemaPSVIIDCBindingPtr idcTable;
    /* the table of PSVI IDC bindings
 for the scope element*/
    xmlSchemaIDCMatcherPtr idcMatchers;
    /* the IDC matchers for the scope
   element */
    xmlRegExecCtxtPtr regexCtxt;

    const xmlChar **nsBindings;
    /* Namespace bindings on this element */
    int nbNsBindings;
    int sizeNsBindings;

    int hasKeyrefs;
    int appliedXPath; /* Indicates that an XPath has been applied. */
};

#define XML_SCHEMAS_ATTR_UNKNOWN 1
#define XML_SCHEMAS_ATTR_ASSESSED 2
#define XML_SCHEMAS_ATTR_PROHIBITED 3
#define XML_SCHEMAS_ATTR_ERR_MISSING 4
#define XML_SCHEMAS_ATTR_INVALID_VALUE 5
#define XML_SCHEMAS_ATTR_ERR_NO_TYPE 6
#define XML_SCHEMAS_ATTR_ERR_FIXED_VALUE 7
#define XML_SCHEMAS_ATTR_DEFAULT 8
#define XML_SCHEMAS_ATTR_VALIDATE_VALUE 9
#define XML_SCHEMAS_ATTR_ERR_WILD_STRICT_NO_DECL 10
#define XML_SCHEMAS_ATTR_HAS_ATTR_USE 11
#define XML_SCHEMAS_ATTR_HAS_ATTR_DECL 12
#define XML_SCHEMAS_ATTR_WILD_SKIP 13
#define XML_SCHEMAS_ATTR_WILD_LAX_NO_DECL 14
#define XML_SCHEMAS_ATTR_ERR_WILD_DUPLICATE_ID 15
#define XML_SCHEMAS_ATTR_ERR_WILD_AND_USE_ID 16
#define XML_SCHEMAS_ATTR_META 17
/*
* @metaType values of xmlSchemaAttrInfo.
*/
#define XML_SCHEMA_ATTR_INFO_META_XSI_TYPE 1
#define XML_SCHEMA_ATTR_INFO_META_XSI_NIL 2
#define XML_SCHEMA_ATTR_INFO_META_XSI_SCHEMA_LOC 3
#define XML_SCHEMA_ATTR_INFO_META_XSI_NO_NS_SCHEMA_LOC 4
#define XML_SCHEMA_ATTR_INFO_META_XMLNS 5

typedef struct _xmlSchemaAttrInfo xmlSchemaAttrInfo;
typedef xmlSchemaAttrInfo *xmlSchemaAttrInfoPtr;
struct _xmlSchemaAttrInfo {
    int nodeType;
    xmlNodePtr node;
    int nodeLine;
    const xmlChar *localName;
    const xmlChar *nsName;
    const xmlChar *value;
    xmlSchemaValPtr val;
    /* the pre-computed value if any */
    xmlSchemaTypePtr typeDef;
    /* the complex/simple type definition if any */
    int flags;
    /* combination of node info flags */

    xmlSchemaAttributePtr decl;
    /* the attribute declaration */
    xmlSchemaAttributeUsePtr use;
    /* the attribute use */
    int state;
    int metaType;
    const xmlChar *vcValue;
    /* the value constraint value */
    xmlSchemaNodeInfoPtr parent;
};


#define XML_SCHEMA_VALID_CTXT_FLAG_STREAM 1
/**
 * xmlSchemaValidCtxt:
 *
 * A Schemas validation context
 */
struct _xmlSchemaValidCtxt {
    int type;
    void *errCtxt;
    /* user specific data block */
    xmlSchemaValidityErrorFunc error;
    /* the callback in case of errors */
    xmlSchemaValidityWarningFunc warning;
    /* the callback in case of warning */
    xmlStructuredErrorFunc serror;

    xmlSchemaPtr schema;
    /* The schema in use */
    xmlDocPtr doc;
    xmlParserInputBufferPtr input;
    xmlCharEncoding enc;
    xmlSAXHandlerPtr sax;
    xmlParserCtxtPtr parserCtxt;
    void *user_data;
    /* TODO: What is this for? */

    int err;
    int nberrors;

    xmlNodePtr node;
    xmlNodePtr cur;
    /* xmlSchemaTypePtr type; */

    xmlRegExecCtxtPtr regexp;
    xmlSchemaValPtr value;

    int valueWS;
    int options;
    xmlNodePtr validationRoot;
    xmlSchemaParserCtxtPtr pctxt;
    int xsiAssemble;

    int depth;
    xmlSchemaNodeInfoPtr *elemInfos;
    /* array of element informations */
    int sizeElemInfos;
    xmlSchemaNodeInfoPtr inode;
    /* the current element information */

    xmlSchemaIDCAugPtr aidcs;
    /* a list of augmented IDC informations */

    xmlSchemaIDCStateObjPtr xpathStates;
    /* first active state object. */
    xmlSchemaIDCStateObjPtr xpathStatePool;
    /* first stored state object. */
    xmlSchemaIDCMatcherPtr idcMatcherCache;
    /* Cache for IDC matcher objects. */

    xmlSchemaPSVIIDCNodePtr *idcNodes;
    /* list of all IDC node-table entries*/
    int nbIdcNodes;
    int sizeIdcNodes;

    xmlSchemaPSVIIDCKeyPtr *idcKeys;
    /* list of all IDC node-table entries */
    int nbIdcKeys;
    int sizeIdcKeys;

    int flags;

    xmlDictPtr dict;

#ifdef LIBXML_READER_ENABLED
    xmlTextReaderPtr reader;
#endif

    xmlSchemaAttrInfoPtr *attrInfos;
    int nbAttrInfos;
    int sizeAttrInfos;

    int skipDepth;
    xmlSchemaItemListPtr nodeQNames;
    int hasKeyrefs;
    int createIDCNodeTables;
    int psviExposeIDCNodeTables;
};

/**
 * xmlSchemaSubstGroup:
 *
 *
 */
typedef struct _xmlSchemaSubstGroup xmlSchemaSubstGroup;
typedef xmlSchemaSubstGroup *xmlSchemaSubstGroupPtr;
struct _xmlSchemaSubstGroup {
    xmlSchemaElementPtr head;
    xmlSchemaItemListPtr members;
};

/*static xmlSchemaQNameRefPtr
        xmlSchemaParseAttributeGroupRef(xmlSchemaParserCtxtPtr pctxt,
        xmlSchemaPtr schema,
        xmlNodePtr node);*/


#endif

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ruby_xml_schema_attribute.c                                                                         0100644 0001750 0001750 00000005665 12566211276 046616  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_schema_attribute.h"
#include "ruby_xml_schema_type.h"

VALUE cXMLSchemaAttribute;

static void rxml_schema_attribute_free(xmlSchemaAttributeUsePtr attr)
{
  attr = NULL;
  xmlFree(attr);
}

VALUE rxml_wrap_schema_attribute(xmlSchemaAttributeUsePtr attr)
{
  return Data_Wrap_Struct(cXMLSchemaAttribute, NULL, rxml_schema_attribute_free, attr);
}

static VALUE rxml_schema_attribute_namespace(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;
  const xmlChar *tns;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  if (attr == NULL)
    return Qnil;

  if (attr->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
      tns = ((xmlSchemaAttributeUseProhibPtr) attr)->targetNamespace;
  } else if (attr->type == XML_SCHEMA_EXTRA_QNAMEREF) {
      tns = ((xmlSchemaQNameRefPtr) attr)->targetNamespace;
  } else {
      tns = ((xmlSchemaAttributePtr) ((xmlSchemaAttributeUsePtr) (attr))->attrDecl)->targetNamespace;
  }

  QNIL_OR_STRING(tns)
}

static VALUE rxml_schema_attribute_name(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;
  const xmlChar *name;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  if (attr == NULL)
    return Qnil;

  if (attr->type == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB) {
      name = ((xmlSchemaAttributeUseProhibPtr) attr)->name;
  } else if (attr->type == XML_SCHEMA_EXTRA_QNAMEREF) {
      name = ((xmlSchemaQNameRefPtr) attr)->name;
  } else {
      xmlSchemaAttributePtr attrDecl = ((xmlSchemaAttributeUsePtr) attr)->attrDecl;
      name = attrDecl->name;
  }

  QNIL_OR_STRING(name)
}

static VALUE rxml_schema_attribute_type(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  xtype = attr->attrDecl->subtypes;

  return rxml_wrap_schema_type((xmlSchemaTypePtr) xtype);
}

static VALUE rxml_schema_attribute_node(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  return rxml_node_wrap(attr->node);
}

static VALUE rxml_schema_attribute_value(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  QNIL_OR_STRING(attr->defValue)
}

static VALUE rxml_schema_attribute_occurs(VALUE self)
{
  xmlSchemaAttributeUsePtr attr;

  Data_Get_Struct(self, xmlSchemaAttributeUse, attr);

  return INT2NUM(attr->occurs);
}

void rxml_init_schema_attribute(void)
{
  cXMLSchemaAttribute = rb_define_class_under(cXMLSchema, "Attribute", rb_cObject);
  rb_define_method(cXMLSchemaAttribute, "namespace", rxml_schema_attribute_namespace, 0);
  rb_define_method(cXMLSchemaAttribute, "name", rxml_schema_attribute_name, 0);
  rb_define_method(cXMLSchemaAttribute, "type", rxml_schema_attribute_type, 0);
  rb_define_method(cXMLSchemaAttribute, "node", rxml_schema_attribute_node, 0);
  rb_define_method(cXMLSchemaAttribute, "value", rxml_schema_attribute_value, 0);
  rb_define_method(cXMLSchemaAttribute, "occurs", rxml_schema_attribute_occurs, 0);
}
                                                                           ruby_xml_schema_attribute.h                                                                         0100644 0001750 0001750 00000000537 12566211276 046614  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_SCHEMA_ATTRIBUTE__
#define __RXML_SCHEMA_ATTRIBUTE__

#include "ruby_xml_schema.h"
#include <libxml/schemasInternals.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>

extern VALUE cXMLSchemaAttribute;


void rxml_init_schema_attribute(void);
VALUE rxml_wrap_schema_attribute(xmlSchemaAttributeUsePtr attr);

#endif
                                                                                                                                                                 ruby_xml_schema_element.c                                                                           0100644 0001750 0001750 00000004550 12566211276 046234  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_schema_element.h"
#include "ruby_xml_schema_type.h"

VALUE cXMLSchemaElement;

static void rxml_schema_element_free(xmlSchemaElementPtr xschema_element)
{
  xschema_element = NULL;
  xmlFree(xschema_element);
}

VALUE rxml_wrap_schema_element(xmlSchemaElementPtr xelement)
{
  return Data_Wrap_Struct(cXMLSchemaElement, NULL, rxml_schema_element_free, xelement);
}

static VALUE rxml_schema_element_namespace(VALUE self)
{
  xmlSchemaElementPtr xelem;

  Data_Get_Struct(self, xmlSchemaElement, xelem);

  QNIL_OR_STRING(xelem->targetNamespace)
}

static VALUE rxml_schema_element_name(VALUE self)
{
  xmlSchemaElementPtr xelem;

  Data_Get_Struct(self, xmlSchemaElement, xelem);


  QNIL_OR_STRING(xelem->name)
}

static VALUE rxml_schema_element_type(VALUE self)
{
  xmlSchemaElementPtr xelem;
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaElement, xelem);

  xtype = xelem->subtypes;

  return rxml_wrap_schema_type((xmlSchemaTypePtr) xtype);
}

static VALUE rxml_schema_element_node(VALUE self)
{
  xmlSchemaElementPtr xelem;

  Data_Get_Struct(self, xmlSchemaElement, xelem);

  return rxml_node_wrap(xelem->node);
}

static VALUE rxml_schema_element_value(VALUE self)
{
  xmlSchemaElementPtr xelem;

  Data_Get_Struct(self, xmlSchemaElement, xelem);

  QNIL_OR_STRING(xelem->value)
}

static VALUE rxml_schema_element_min_occurs(VALUE self)
{
  return rb_iv_get(self, "@min");
}

static VALUE rxml_schema_element_max_occurs(VALUE self)
{
  return rb_iv_get(self, "@max");
}

static VALUE rxml_schema_element_annot(VALUE self)
{
  return rb_iv_get(self, "@annotation");
}


void rxml_init_schema_element(void)
{
  cXMLSchemaElement = rb_define_class_under(cXMLSchema, "Element", rb_cObject);
  rb_define_method(cXMLSchemaElement, "namespace", rxml_schema_element_namespace, 0);
  rb_define_method(cXMLSchemaElement, "name", rxml_schema_element_name, 0);
  rb_define_method(cXMLSchemaElement, "type", rxml_schema_element_type, 0);
  rb_define_method(cXMLSchemaElement, "node", rxml_schema_element_node, 0);
  rb_define_method(cXMLSchemaElement, "value", rxml_schema_element_value, 0);
  rb_define_method(cXMLSchemaElement, "min_occurs", rxml_schema_element_min_occurs, 0);
  rb_define_method(cXMLSchemaElement, "max_occurs", rxml_schema_element_max_occurs, 0);
  rb_define_method(cXMLSchemaElement, "annotation", rxml_schema_element_annot, 0);
}
                                                                                                                                                        ruby_xml_schema_element.h                                                                           0100644 0001750 0001750 00000000523 12566211276 046235  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_SCHEMA_ELEMENT__
#define __RXML_SCHEMA_ELEMENT__

#include "ruby_xml_schema.h"
#include <libxml/schemasInternals.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>

extern VALUE cXMLSchemaElement;

VALUE rxml_wrap_schema_element(xmlSchemaElementPtr xelement);
void rxml_init_schema_element(void);

#endif
                                                                                                                                                                             ruby_xml_schema_facet.c                                                                             0100644 0001750 0001750 00000002242 12566211276 045661  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_schema_facet.h"

VALUE cXMLSchemaFacet;

static void rxml_schema_facet_free(xmlSchemaFacetPtr xschema_type)
{
  xschema_type = NULL;
  xmlFree(xschema_type);
}

/* START FACET*/

static VALUE rxml_schema_facet_node(VALUE self)
{
  xmlSchemaFacetPtr facet;

  Data_Get_Struct(self, xmlSchemaFacet, facet);

  return rxml_node_wrap(facet->node);
}

static VALUE rxml_schema_facet_value(VALUE self)
{
  xmlSchemaFacetPtr facet;

  Data_Get_Struct(self, xmlSchemaFacet, facet);

  QNIL_OR_STRING(facet->value)
}

static VALUE rxml_schema_facet_kind(VALUE self)
{
  xmlSchemaFacetPtr facet;

  Data_Get_Struct(self, xmlSchemaFacet, facet);

  return INT2NUM(facet->type);
}

VALUE rxml_wrap_schema_facet(xmlSchemaFacetPtr facet)
{
  return Data_Wrap_Struct(cXMLSchemaFacet, NULL, rxml_schema_facet_free, facet);
}

void rxml_init_schema_facet(void)
{
  cXMLSchemaFacet = rb_define_class_under(cXMLSchema, "Facet", rb_cObject);
  rb_define_method(cXMLSchemaFacet, "value", rxml_schema_facet_value, 0);
  rb_define_method(cXMLSchemaFacet, "node", rxml_schema_facet_node, 0);
  rb_define_method(cXMLSchemaFacet, "kind", rxml_schema_facet_kind, 0);
}
                                                                                                                                                                                                                                                                                                                                                              ruby_xml_schema_facet.h                                                                             0100644 0001750 0001750 00000000447 12566211276 045673  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_SCHEMA_FACET__
#define __RXML_SCHEMA_FACET__

#include <libxml/schemasInternals.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>

extern VALUE cXMLSchemaFacet;

VALUE rxml_wrap_schema_facet(xmlSchemaFacetPtr facet);
void rxml_init_schema_facet(void);

#endif
                                                                                                                                                                                                                         ruby_xml_schema_type.c                                                                              0100644 0001750 0001750 00000014414 12566211276 045564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_schema_type.h"
#include "ruby_xml_schema_element.h"
#include "ruby_xml_schema_attribute.h"
#include "ruby_xml_schema_facet.h"

#define UNBOUNDED 1 << 30
#define FREE_AND_NULL(str) if ((str) != NULL) { xmlFree((xmlChar *) (str)); str = NULL; }

VALUE cXMLSchemaType;

static void rxml_schema_type_free(xmlSchemaTypePtr xschema_type)
{
  xschema_type = NULL;
  xmlFree(xschema_type);
}

VALUE rxml_wrap_schema_type(xmlSchemaTypePtr xtype)
{
  return Data_Wrap_Struct(cXMLSchemaType, NULL, rxml_schema_type_free, xtype);
}

static VALUE rxml_schema_type_namespace(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  QNIL_OR_STRING(xtype->targetNamespace)
}

static VALUE rxml_schema_type_name(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  QNIL_OR_STRING(xtype->name)
}

static VALUE rxml_schema_type_base(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  return Data_Wrap_Struct(cXMLSchemaType, NULL, rxml_schema_type_free, xtype->baseType);
}

static VALUE rxml_schema_type_facets(VALUE self)
{
  xmlSchemaTypePtr xtype;
  xmlSchemaFacetPtr facet;
  VALUE facets;
  VALUE rfacet;

  facets = rb_iv_get(self, "@facets");

  if (facets == Qnil) {
    facets = rb_ary_new();
    Data_Get_Struct(self, xmlSchemaType, xtype);

    facet = xtype->facets;

    while (facet != NULL) {
      rfacet = rxml_wrap_schema_facet((xmlSchemaFacetPtr) facet);
      rb_ary_push(facets, rfacet);
      facet = facet->next;
    }

    rb_iv_set(self, "@facets", facets);
  }

  return facets;
}

static VALUE rxml_schema_type_node(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  if(xtype->node != NULL)
    return rxml_node_wrap(xtype->node);
  else
    return Qnil;
}

static VALUE rxml_schema_type_kind(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  return INT2NUM(xtype->type);
}

static VALUE get_annotation(xmlSchemaAnnotPtr annot)
{
  if(annot != NULL && annot->content != NULL && annot->content->content != NULL)
    return rb_str_new2((const char *) annot->content->content);
  else
    return Qnil;
}

static VALUE rxml_schema_type_annot(VALUE self)
{
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  if(xtype != NULL && xtype->annot != NULL)
    return get_annotation(xtype->annot);
  else
    return Qnil;
}

static void rxmlSchemaCollectElements(xmlSchemaParticlePtr particle, VALUE self)
{
  VALUE elements;
  VALUE relement;
  xmlSchemaTreeItemPtr term;

  if (particle == NULL)
    return;

  term = particle->children;

  if (term != NULL) {
    elements = rb_iv_get(self, "@elements");

    switch (term->type) {
      case XML_SCHEMA_TYPE_ELEMENT:
        relement = rxml_wrap_schema_element((xmlSchemaElementPtr) term);


        rb_iv_set(relement, "@min", INT2NUM(particle->minOccurs));

        if (particle->maxOccurs >= UNBOUNDED)
          rb_iv_set(relement, "@max", rb_const_get(rb_path2class("Float"), rb_intern("INFINITY")));
        else
          rb_iv_set(relement, "@max", INT2NUM(particle->maxOccurs));

        if (particle->annot != NULL)
        {
          xmlChar *content;

          content = xmlNodeGetContent(particle->annot->content);

          if (content != NULL)
          {
            rb_iv_set(relement, "@annotation", rb_str_new2((const char *) content));
            xmlFree(content);
          }
        }

        rb_hash_aset(elements, rb_str_new2((const char *) ((xmlSchemaElementPtr) term)->name), relement);

        break;

      case XML_SCHEMA_TYPE_SEQUENCE:
        break;

      case XML_SCHEMA_TYPE_CHOICE:
        break;

      case XML_SCHEMA_TYPE_ALL:
        break;

      case XML_SCHEMA_TYPE_ANY:
        break;

      default:

        return;
    }
  }

  if (term &&
      ((term->type == XML_SCHEMA_TYPE_SEQUENCE) ||
          (term->type == XML_SCHEMA_TYPE_CHOICE) ||
          (term->type == XML_SCHEMA_TYPE_ALL)) &&
      (term->children != NULL)) {

    rxmlSchemaCollectElements((xmlSchemaParticlePtr) term->children, self);
  }

  if (particle->next != NULL)
    rxmlSchemaCollectElements((xmlSchemaParticlePtr) particle->next, self);
}

static VALUE
rxml_schema_type_elements(VALUE self)
{
  VALUE elements;
  xmlSchemaTypePtr xtype;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  if (rb_iv_get(self, "@elements") == Qnil) {
    elements = rb_hash_new();
    rb_iv_set(self, "@elements", elements);
    rxmlSchemaCollectElements((xmlSchemaParticlePtr) xtype->subtypes, self);
  }

  return rb_iv_get(self, "@elements");
}

static VALUE
rxml_schema_type_attributes(VALUE self)
{
  VALUE attributes;
  xmlSchemaTypePtr xtype;
  xmlSchemaAttributeUsePtr use;
  xmlSchemaItemListPtr uses;
  int i;

  Data_Get_Struct(self, xmlSchemaType, xtype);

  if (rb_iv_get(self, "@attributes") == Qnil) {
    attributes = rb_ary_new();
    rb_iv_set(self, "@attributes", attributes);

    uses = xtype->attrUses;

    if ((uses == NULL) || (uses->nbItems == 0))
      return rb_iv_get(self, "@attributes");

    for (i = 0; i < uses->nbItems; i++) {
      use = (xmlSchemaAttributeUsePtr) uses->items[i];
      rb_ary_push(attributes, rxml_wrap_schema_attribute(use));
    }
  }

  return rb_iv_get(self, "@attributes");
}


void rxml_init_schema_type(void)
{
  /* Add in infinity support for ruby 1.8.7 */
  #if !defined(RUBY_VM) && defined(INFINITY)
  ID infinityId = rb_intern("INFINITY");
  if (rb_const_defined(rb_cFloat, infinityId) == Qfalse)
    rb_define_const(rb_cFloat, "INFINITY", rb_float_new(INFINITY));
  #endif

  cXMLSchemaType = rb_define_class_under(cXMLSchema, "Type", rb_cObject);

  rb_define_method(cXMLSchemaType, "namespace", rxml_schema_type_namespace, 0);
  rb_define_method(cXMLSchemaType, "name", rxml_schema_type_name, 0);
  rb_define_method(cXMLSchemaType, "elements", rxml_schema_type_elements, 0);
  rb_define_method(cXMLSchemaType, "attributes", rxml_schema_type_attributes, 0);
  rb_define_method(cXMLSchemaType, "base", rxml_schema_type_base, 0);
  rb_define_method(cXMLSchemaType, "kind", rxml_schema_type_kind, 0);
  rb_define_method(cXMLSchemaType, "node", rxml_schema_type_node, 0);
  rb_define_method(cXMLSchemaType, "facets", rxml_schema_type_facets, 0);
  rb_define_method(cXMLSchemaType, "annotation", rxml_schema_type_annot, 0);
}
                                                                                                                                                                                                                                                    ruby_xml_schema_type.h                                                                              0100644 0001750 0001750 00000000270 12566211276 045564  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_SCHEMA_TYPE__
#define __RXML_SCHEMA_TYPE__

extern VALUE cXMLSchemaType;

VALUE rxml_wrap_schema_type(xmlSchemaTypePtr xtype);
void rxml_init_schema_type(void);

#endif
                                                                                                                                                                                                                                                                                                                                        ruby_xml_version.h                                                                                  0100644 0001750 0001750 00000000615 12566211276 044753  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Don't nuke this block!  It is used for automatically updating the
 * versions below. VERSION = string formatting, VERNUM = numbered
 * version for inline testing: increment both or none at all.*/
#define RUBY_LIBXML_VERSION  "2.6.0"
#define RUBY_LIBXML_VERNUM   260
#define RUBY_LIBXML_VER_MAJ   2
#define RUBY_LIBXML_VER_MIN   6
#define RUBY_LIBXML_VER_MIC   0
#define RUBY_LIBXML_VER_PATCH 0
                                                                                                                   ruby_xml_writer.c                                                                                   0100644 0001750 0001750 00000110243 12566211276 044574  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include <libxml/xmlversion.h>

#ifdef LIBXML_WRITER_ENABLED

/*
 * Document-class: LibXML::XML::Writer
 *
 * The XML::Writer class provides a simpler, alternative way to build a valid
 * XML document from scratch (forward-only) compared to a DOM approach (based
 * on XML::Document class).
 *
 * For a more in depth tutorial, albeit in C, see http://xmlsoft.org/xmlwriter.html
 */

# include <libxml/xmlwriter.h>

# include "ruby_libxml.h"
# include "ruby_xml_writer.h"

VALUE cXMLWriter;
static VALUE sEncoding, sStandalone;

typedef enum {
    RXMLW_OUTPUT_NONE,
    RXMLW_OUTPUT_IO,
    RXMLW_OUTPUT_DOC,
    RXMLW_OUTPUT_STRING
} rxmlw_output_type;

typedef struct {
    VALUE output;
# ifdef HAVE_RUBY_ENCODING_H
    rb_encoding *encoding;
# endif /* HAVE_RUBY_ENCODING_H */
    xmlBufferPtr buffer;
    xmlTextWriterPtr writer;
    rxmlw_output_type output_type;
} rxml_writer_object;

# ifdef HAVE_RUBY_ENCODING_H

#  define /*VALUE*/ rxml_writer_c_to_ruby_string(/*const xmlChar **/ string, /*long*/ string_len) \
    rb_external_str_new_with_enc(string, string_len, rb_utf8_encoding())

#  define /*VALUE*/ rxml_writer_ruby_string_to_utf8(/*VALUE*/ string) \
    rb_str_conv_enc(string, rb_enc_get(string), rb_utf8_encoding())
// rb_str_export_to_enc(string, rb_utf8_encoding())

#  define /*void*/ rxml_writer_free_utf8_string(/*VALUE*/ orig, /*VALUE*/ utf8) \
    do {                       \
        if (orig != utf8) {    \
            rb_str_free(utf8); \
        }                      \
    } while (0);

# else

#  define /*VALUE*/ rxml_writer_c_to_ruby_string(/*const xmlChar **/ string, /*long*/ string_len) \
    rb_str_new(string, string_len)

#  define /*VALUE*/ rxml_writer_ruby_string_to_utf8(/*VALUE*/ string) \
    string

#  define /*void*/ rxml_writer_free_utf8_string(/*VALUE*/ orig, /*VALUE*/ utf8) \
    /* NOP */

# endif /* HAVE_RUBY_ENCODING_H */

static void rxml_writer_free(rxml_writer_object *rwo)
{
#if 0 /* seems to be done by xmlFreeTextWriter */
    if (NULL != rwo->buffer) {
        xmlBufferFree(rwo->buffer);
    }
#endif
    xmlFreeTextWriter(rwo->writer);
    xfree(rwo);
}

static void rxml_writer_mark(rxml_writer_object *rwo)
{
    if (!NIL_P(rwo->output)) {
        rb_gc_mark(rwo->output);
    }
}

static VALUE rxml_writer_wrap(rxml_writer_object *rwo)
{
    return Data_Wrap_Struct(cXMLWriter, rxml_writer_mark, rxml_writer_free, rwo);
}

static rxml_writer_object *rxml_textwriter_get(VALUE obj)
{
    rxml_writer_object *rwo;

    Data_Get_Struct(obj, rxml_writer_object, rwo);

    return rwo;
}

/* ===== public class methods ===== */

/* call-seq:
 *    XML::Writer::io(io) -> XML::Writer
 *
 * Creates a XML::Writer which will write XML directly into an IO object.
 */
static VALUE rxml_writer_io(VALUE klass, VALUE io)
{
#if 0
typedef int (*xmlOutputCloseCallback)(void * context);
typedef int (*xmlOutputWriteCallback)(void * context, const char * buffer, int len);

ssize_t rb_io_bufwrite(VALUE io, const void *buf, size_t size);

xmlOutputBufferPtr xmlOutputBufferCreateIO(xmlOutputWriteCallback iowrite, xmlOutputCloseCallback ioclose, void * ioctx, xmlCharEncodingHandlerPtr encoder)

xmlCharEncodingHandlerPtr xmlFindCharEncodingHandler(const char * name);
#endif
    xmlOutputBufferPtr out;
    rxml_writer_object *rwo;

    rwo = ALLOC(rxml_writer_object);
    rwo->output = io;
    rwo->buffer = NULL;
# ifdef HAVE_RUBY_ENCODING_H
    rwo->encoding = NULL;
# endif /* HAVE_RUBY_ENCODING_H */
    rwo->output_type = RXMLW_OUTPUT_IO;
    if (NULL == (out = xmlOutputBufferCreateIO(rxml_write_callback, NULL, (void *) io, NULL))) {
        rxml_raise(&xmlLastError);
    }
    if (NULL == (rwo->writer = xmlNewTextWriter(out))) {
        rxml_raise(&xmlLastError);
    }

    return rxml_writer_wrap(rwo);
}


/* call-seq:
 *    XML::Writer::file(path) -> XML::Writer
 *
 * Creates a XML::Writer object which will write XML into the file with
 * the given name.
 */
static VALUE rxml_writer_file(VALUE klass, VALUE filename)
{
    rxml_writer_object *rwo;

    rwo = ALLOC(rxml_writer_object);
    rwo->output = Qnil;
    rwo->buffer = NULL;
# ifdef HAVE_RUBY_ENCODING_H
    rwo->encoding = NULL;
# endif /* HAVE_RUBY_ENCODING_H */
    rwo->output_type = RXMLW_OUTPUT_NONE;
    if (NULL == (rwo->writer = xmlNewTextWriterFilename(StringValueCStr(filename), 0))) {
        rxml_raise(&xmlLastError);
    }

    return rxml_writer_wrap(rwo);
}

/* call-seq:
 *    XML::Writer::string -> XML::Writer
 *
 * Creates a XML::Writer which will write XML into memory, as string.
 */
static VALUE rxml_writer_string(VALUE klass)
{
    rxml_writer_object *rwo;

    rwo = ALLOC(rxml_writer_object);
    rwo->output = Qnil;
# ifdef HAVE_RUBY_ENCODING_H
    rwo->encoding = NULL;
# endif /* HAVE_RUBY_ENCODING_H */
    rwo->output_type = RXMLW_OUTPUT_STRING;
    if (NULL == (rwo->buffer = xmlBufferCreate())) {
        rxml_raise(&xmlLastError);
    }
    if (NULL == (rwo->writer = xmlNewTextWriterMemory(rwo->buffer, 0))) {
        xmlBufferFree(rwo->buffer);
        rxml_raise(&xmlLastError);
    }

    return rxml_writer_wrap(rwo);
}

/* call-seq:
 *    XML::Writer::document -> XML::Writer
 *
 * Creates a XML::Writer which will write into an in memory XML::Document
 */
static VALUE rxml_writer_doc(VALUE klass)
{
    xmlDocPtr doc;
    rxml_writer_object *rwo;

    rwo = ALLOC(rxml_writer_object);
    rwo->buffer = NULL;
    rwo->output = Qnil;
# ifdef HAVE_RUBY_ENCODING_H
    rwo->encoding = NULL;
# endif /* HAVE_RUBY_ENCODING_H */
    rwo->output_type = RXMLW_OUTPUT_DOC;
    if (NULL == (rwo->writer = xmlNewTextWriterDoc(&doc, 0))) {
        rxml_raise(&xmlLastError);
    }
    rwo->output = rxml_document_wrap(doc);

    return rxml_writer_wrap(rwo);
}

/* ===== public instance methods ===== */

/* call-seq:
 *    writer.flush(empty? = true) -> (num|string)
 *
 * Flushes the output buffer. Returns the number of written bytes or
 * the current content of the internal buffer for a in memory XML::Writer.
 * If +empty?+ is +true+, and for a in memory XML::Writer, this internel
 * buffer is empty.
 */
static VALUE rxml_writer_flush(int argc, VALUE *argv, VALUE self)
{
    int ret;
    VALUE empty;
    rxml_writer_object *rwo;

    rb_scan_args(argc, argv, "01", &empty);

    rwo = rxml_textwriter_get(self);
    if (-1 == (ret = xmlTextWriterFlush(rwo->writer))) {
        rxml_raise(&xmlLastError);
    }
    if (NULL != rwo->buffer) {
        VALUE content;

# ifdef HAVE_RUBY_ENCODING_H
        content = rb_external_str_new_with_enc(rwo->buffer->content, rwo->buffer->use, rwo->encoding);
# else
        content = rb_str_new(rwo->buffer->content, rwo->buffer->use);
# endif /* HAVE_RUBY_ENCODING_H */
        if (NIL_P(empty) || RTEST(empty)) { /* nil = default value = true */
            xmlBufferEmpty(rwo->buffer);
        }

        return content;
    } else {
        return INT2NUM(ret);
    }
}

/* call-seq:
 *    writer.result -> (XML::Document|"string"|nil)
 *
 * Returns the associated result object to the XML::Writer creation.
 * A String for a XML::Writer object created with XML::Writer::string,
 * a XML::Document with XML::Writer::document, etc.
 */
static VALUE rxml_writer_result(VALUE self)
{
    VALUE ret;
    rxml_writer_object *rwo;

    ret = Qnil;
    rwo = rxml_textwriter_get(self);
    if (-1 == (ret = xmlTextWriterFlush(rwo->writer))) {
        rxml_raise(&xmlLastError);
    }
    switch (rwo->output_type) {
        case RXMLW_OUTPUT_DOC:
            ret = rwo->output;
            break;
        case RXMLW_OUTPUT_STRING:
            ret = rxml_writer_c_to_ruby_string(rwo->buffer->content, rwo->buffer->use);
            break;
        case RXMLW_OUTPUT_IO:
        case RXMLW_OUTPUT_NONE:
            break;
        default:
            rb_bug("unexpected output");
            break;
    }

    return ret;
}

/* ===== private helpers ===== */

static VALUE numeric_rxml_writer_void(VALUE obj, int (*fn)(xmlTextWriterPtr))
{
    int ret;
    rxml_writer_object *rwo;

    rwo = rxml_textwriter_get(obj);
    ret = fn(rwo->writer);

    return (-1 == ret ? Qfalse : Qtrue);
}

# define numeric_rxml_writer_string(/*VALUE*/ obj, /*VALUE*/ name_or_content, /*int (**/fn/*)(xmlTextWriterPtr, const xmlChar *)*/) \
    numeric_rxml_writer_va_strings(obj, Qundef, 1, fn, name_or_content)

/**
 * This is quite ugly but thanks to libxml2 coding style, all xmlTextWriter*
 * calls can be redirected to a single function. This can be convenient to:
 * - avoid repeating yourself
 * - convert strings to UTF-8
 * - validate names
 * and so on
 **/
# define XMLWRITER_MAX_STRING_ARGS 5
static VALUE numeric_rxml_writer_va_strings(VALUE obj, VALUE pe, size_t strings_count, int (*fn)(ANYARGS), ...)
{
    va_list ap;
    int argc, ret;
    rxml_writer_object *rwo;
    const xmlChar *argv[XMLWRITER_MAX_STRING_ARGS];
    VALUE utf8[XMLWRITER_MAX_STRING_ARGS], orig[XMLWRITER_MAX_STRING_ARGS];

    if (strings_count > XMLWRITER_MAX_STRING_ARGS) {
        rb_bug("more arguments than expected");
    }
    ret = -1;
    va_start(ap, fn);
    rwo = rxml_textwriter_get(obj);
    for (argc = 0; argc < strings_count; argc++) {
        VALUE arg;

        arg = va_arg(ap, VALUE);
        orig[argc] = arg;
        if (NIL_P(arg)) {
            utf8[argc] = Qnil;
            argv[argc] = NULL;
        } else {
            utf8[argc] = rxml_writer_ruby_string_to_utf8(orig[argc]);
            argv[argc] = BAD_CAST StringValueCStr(utf8[argc]);
        }
    }
    va_end(ap);

    if (Qundef == pe) {
        switch (strings_count) {
            case 0:
                ret = fn(rwo->writer);
                break;
            case 1:
                ret = fn(rwo->writer, argv[0]);
                break;
            case 2:
                ret = fn(rwo->writer, argv[0], argv[1]);
                break;
            case 3:
                ret = fn(rwo->writer, argv[0], argv[1], argv[2]);
                break;
            case 4:
                ret = fn(rwo->writer, argv[0], argv[1], argv[2], argv[3]);
                break;
            case 5:
                ret = fn(rwo->writer, argv[0], argv[1], argv[2], argv[3], argv[4]);
                break;
            default:
                break;
        }
    } else {
        int xpe;

        xpe = RTEST(pe);
        switch (strings_count) { /* strings_count doesn't include pe */
            case 0:
                ret = fn(rwo->writer, xpe);
                break;
            case 1:
                ret = fn(rwo->writer, xpe, argv[0]);
                break;
            case 2:
                ret = fn(rwo->writer, xpe, argv[0], argv[1]);
                break;
            case 3:
                ret = fn(rwo->writer, xpe, argv[0], argv[1], argv[2]);
                break;
            case 4:
                ret = fn(rwo->writer, xpe, argv[0], argv[1], argv[2], argv[3]);
                break;
            case 5:
                ret = fn(rwo->writer, xpe, argv[0], argv[1], argv[2], argv[3], argv[4]);
                break;
            default:
                break;
        }
    }
# ifdef HAVE_RUBY_ENCODING_H
    while (--strings_count > 0) {
        if (!NIL_P(orig[strings_count])) {
            rxml_writer_free_utf8_string(orig[strings_count], utf8[strings_count]);
        }
    }
# endif /* HAVE_RUBY_ENCODING_H */

    return (-1 == ret ? Qfalse : Qtrue);
}

/* ===== public instance methods ===== */

# if LIBXML_VERSION >= 20605
/* call-seq:
 *    writer.set_indent(indentation) -> (true|false)
 *
 * Toggles indentation on or off. Returns +false+ on failure.
 *
 * Availability: libxml2 >= 2.6.5
 */
static VALUE rxml_writer_set_indent(VALUE self, VALUE indentation)
{
    int ret;
    rxml_writer_object *rwo;

    rwo = rxml_textwriter_get(self);
    ret = xmlTextWriterSetIndent(rwo->writer, RTEST(indentation));

    return (-1 == ret ? Qfalse : Qtrue);
}

/* call-seq:
 *    writer.set_indent_string(string) -> (true|false)
 *
 * Sets the string to use to indent each element of the document.
 * Don't forget to enable indentation with set_indent. Returns
 * +false+ on failure.
 *
 * Availability: libxml2 >= 2.6.5
 */
static VALUE rxml_writer_set_indent_string(VALUE self, VALUE indentation)
{
    return numeric_rxml_writer_string(self, indentation, xmlTextWriterSetIndentString);
}
# endif /* LIBXML_VERSION >= 20605 */

/* ===== public full tag interface ===== */

/* write_<X> = start_<X> + write_string + end_<X> */

/* call-seq:
 *    writer.write_comment(content) -> (true|false)
 *
 * Writes a full comment tag, all at once. Returns +false+ on failure.
 * This is equivalent to start_comment + write_string(content) + end_comment.
 */
static VALUE rxml_writer_write_comment(VALUE self, VALUE content)
{
    return numeric_rxml_writer_string(self, content, xmlTextWriterWriteComment);
}

/* call-seq:
 *    writer.write_cdata(content) -> (true|false)
 *
 * Writes a full CDATA section, all at once. Returns +false+ on failure.
 * This is equivalent to start_cdata + write_string(content) + end_cdata.
 */
static VALUE rxml_writer_write_cdata(VALUE self, VALUE content)
{
    return numeric_rxml_writer_string(self, content, xmlTextWriterWriteCDATA);
}

static VALUE rxml_writer_start_element(VALUE, VALUE);
static VALUE rxml_writer_start_element_ns(int, VALUE *, VALUE);
static VALUE rxml_writer_end_element(VALUE);

/* call-seq:
 *    writer.write_element(name, content) -> (true|false)
 *
 * Writes a full element tag, all at once. Returns +false+ on failure.
 * This is equivalent to start_element(name) + write_string(content) +
 * end_element.
 */
static VALUE rxml_writer_write_element(int argc, VALUE *argv, VALUE self)
{
    VALUE name, content;

    rb_scan_args(argc, argv, "11", &name, &content);
    if (Qnil == content) {
        if (Qfalse == rxml_writer_start_element(self, name)) {
            return Qfalse;
        }
        return rxml_writer_end_element(self);
    } else {
        return numeric_rxml_writer_va_strings(self, Qundef, 2, xmlTextWriterWriteElement, name, content);
    }
}

# define ARRAY_SIZE(array) \
    (sizeof(array) / sizeof((array)[0]))

/* call-seq:
 *    writer.write_element_ns(prefix, name, namespaceURI, content) -> (true|false)
 *
 * Writes a full namespaced element tag, all at once. Returns +false+ on failure.
 * This is a shortcut for start_element_ns(prefix, name, namespaceURI) +
 * write_string(content) + end_element.
 *
 * Notes:
 * - by default, the xmlns: definition is repeated on every element. If you want
 * the prefix, but don't want the xmlns: declaration repeated, set +namespaceURI+
 * to nil or omit it. Don't forget to declare the namespace prefix somewhere
 * earlier.
 * - +content+ can be omitted for an empty tag
 */
static VALUE rxml_writer_write_element_ns(int argc, VALUE *argv, VALUE self)
{
    VALUE prefix, name, namespaceURI, content;

    rb_scan_args(argc, argv, "22", &prefix, &name, &namespaceURI, &content);
    if (Qnil == content) {
        VALUE argv[3] = { prefix, name, namespaceURI };

        if (Qfalse == rxml_writer_start_element_ns(ARRAY_SIZE(argv), argv, self)) {
            return Qfalse;
        }
        return rxml_writer_end_element(self);
    } else {
        return numeric_rxml_writer_va_strings(self, Qundef, 4, xmlTextWriterWriteElementNS, prefix, name, namespaceURI, content);
    }
}

/* call-seq:
 *    writer.write_attribute(name, content) -> (true|false)
 *
 * Writes a full attribute, all at once. Returns +false+ on failure.
 * Same as start_attribute(name) + write_string(content) + end_attribute.
 */
static VALUE rxml_writer_write_attribute(VALUE self, VALUE name, VALUE content)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 2, xmlTextWriterWriteAttribute, name, content);
}

/* call-seq:
 *    writer.write_attribute_ns(prefix, name, namespaceURI, content) -> (true|false)
 *
 * Writes a full namespaced attribute, all at once. Returns +false+ on failure.
 * Same as start_attribute_ns(prefix, name, namespaceURI) +
 * write_string(content) + end_attribute.
 *
 * Notes:
 * - by default, the xmlns: definition is repeated on every element. If you want
 * the prefix, but don't want the xmlns: declaration repeated, set +namespaceURI+
 * to nil or omit it. Don't forget to declare the namespace prefix somewhere
 * earlier.
 * - +content+ can be omitted too for an empty attribute
 */
static VALUE rxml_writer_write_attribute_ns(int argc, VALUE *argv, VALUE self)
{
    VALUE prefix, name, namespaceURI, content;

    rb_scan_args(argc, argv, "22", &prefix, &name, &namespaceURI, &content);

    return numeric_rxml_writer_va_strings(self, Qundef, 4, xmlTextWriterWriteAttributeNS, prefix, name, namespaceURI, content);
}

/* call-seq:
 *    writer.write_pi(target, content) -> (true|false)
 *
 * Writes a full CDATA tag, all at once. Returns +false+ on failure.
 * This is a shortcut for start_pi(target) + write_string(content) + end_pi.
 */
static VALUE rxml_writer_write_pi(VALUE self, VALUE target, VALUE content)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 2, xmlTextWriterWritePI, target, content);
}

/* ===== public start/end interface ===== */

/* call-seq:
 *    writer.write_string(content) -> (true|false)
 *
 * Safely (problematic characters are internally translated to their
 * associated named entities) writes a string into the current node
 * (attribute, element, comment, ...). Returns +false+ on failure.
 */
static VALUE rxml_writer_write_string(VALUE self, VALUE content)
{
    return numeric_rxml_writer_string(self, content, xmlTextWriterWriteString);
}

/* call-seq:
 *    writer.write_raw(content) -> (true|false)
 *
 * Writes the string +content+ as is, reserved characters are not
 * translated to their associated entities. Returns +false+ on failure.
 * Consider write_string to handle them.
 */
static VALUE rxml_writer_write_raw(VALUE self, VALUE content)
{
    return numeric_rxml_writer_string(self, content, xmlTextWriterWriteRaw);
}

/* call-seq:
 *    writer.start_attribute(name) -> (true|false)
 *
 * Starts an attribute. Returns +false+ on failure.
 */
static VALUE rxml_writer_start_attribute(VALUE self, VALUE name)
{
    return numeric_rxml_writer_string(self, name, xmlTextWriterStartAttribute);
}

/* call-seq:
 *    writer.start_attribute_ns(prefix, name, namespaceURI) -> (true|false)
 *
 * Starts a namespaced attribute. Returns +false+ on failure.
 *
 * Note: by default, the xmlns: definition is repeated on every element. If
 * you want the prefix, but don't want the xmlns: declaration repeated, set
 * +namespaceURI+ to nil or omit it. Don't forget to declare the namespace
 * prefix somewhere earlier.
 */
static VALUE rxml_writer_start_attribute_ns(int argc, VALUE *argv, VALUE self)
{
    VALUE prefix, name, namespaceURI;

    rb_scan_args(argc, argv, "21", &prefix, &name, &namespaceURI);

    return numeric_rxml_writer_va_strings(self, Qundef, 3, xmlTextWriterStartAttributeNS, prefix, name, namespaceURI);
}

/* call-seq:
 *    writer.end_attribute -> (true|false)
 *
 * Ends an attribute, namespaced or not. Returns +false+ on failure.
 */
static VALUE rxml_writer_end_attribute(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndAttribute);
}

# if LIBXML_VERSION >= 20607
/* call-seq:
 *    writer.start_comment -> (true|false)
 *
 * Starts a comment. Returns +false+ on failure.
 * Note: libxml2 >= 2.6.7 required
 */
static VALUE rxml_writer_start_comment(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterStartComment);
}

/* call-seq:
 *    writer.end_comment -> (true|false)
 *
 * Ends current comment, returns +false+ on failure.
 * Note: libxml2 >= 2.6.7 required
 */
static VALUE rxml_writer_end_comment(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndComment);
}
# endif /* LIBXML_VERSION >= 20607 */

/* call-seq:
 *    writer.start_element(name) -> (true|false)
 *
 * Starts a new element. Returns +false+ on failure.
 */
static VALUE rxml_writer_start_element(VALUE self, VALUE name)
{
    return numeric_rxml_writer_string(self, name, xmlTextWriterStartElement);
}

/* call-seq:
 *    writer.start_element_ns(prefix, name, namespaceURI) -> (true|false)
 *
 * Starts a new namespaced element. Returns +false+ on failure.
 *
 * Note: by default, the xmlns: definition is repeated on every element. If
 * you want the prefix, but don't want the xmlns: declaration repeated, set
 * +namespaceURI+ to nil or omit it. Don't forget to declare the namespace
 * prefix somewhere earlier.
 */
static VALUE rxml_writer_start_element_ns(int argc, VALUE *argv, VALUE self)
{
    VALUE prefix, name, namespaceURI;

    rb_scan_args(argc, argv, "21", &prefix, &name, &namespaceURI);

    return numeric_rxml_writer_va_strings(self, Qundef, 3, xmlTextWriterStartElementNS, prefix, name, namespaceURI);
}

/* call-seq:
 *    writer.end_element -> (true|false)
 *
 * Ends current element, namespaced or not. Returns +false+ on failure.
 */
static VALUE rxml_writer_end_element(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndElement);
}

/* call-seq:
 *    writer.write_full_end_element -> (true|false)
 *
 * Ends current element, namespaced or not. Returns +false+ on failure.
 * This method writes an end tag even if the element is empty (<foo></foo>),
 * end_element does not (<foo/>).
 */
static VALUE rxml_writer_full_end_element(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterFullEndElement);
}

/* call-seq:
 *    writer.start_cdata -> (true|false)
 *
 * Starts a new CDATA section. Returns +false+ on failure.
 */
static VALUE rxml_writer_start_cdata(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterStartCDATA);
}

/* call-seq:
 *    writer.end_cdata -> (true|false)
 *
 * Ends current CDATA section. Returns +false+ on failure.
 */
static VALUE rxml_writer_end_cdata(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndCDATA);
}

/* call-seq:
 *    writer.start_document -> (true|false)
 *    writer.start_document(:encoding => XML::Encoding::UTF_8,
 *    :standalone => true) -> (true|false)
 *
 * Starts a new document. Returns +false+ on failure.
 *
 * You may provide an optional hash table to control XML header that will be
 * generated. Valid options are:
 * - encoding: the output document encoding, defaults to nil (= UTF-8). Valid
 * values are the encoding constants defined on XML::Encoding
 * - standalone: nil (default) or a boolean to indicate if the document is
 * standalone or not
 */
static VALUE rxml_writer_start_document(int argc, VALUE *argv, VALUE self)
{
    int ret;
    VALUE options;
    rxml_writer_object *rwo;
    const char *xencoding, *xstandalone;

    options = Qnil;
    xstandalone = xencoding = NULL;
    rb_scan_args(argc, argv, "01", &options);
    if (!NIL_P(options)) {
        VALUE encoding, standalone;

        encoding = standalone = Qnil;
        Check_Type(options, T_HASH);
        encoding = rb_hash_aref(options, sEncoding);
        xencoding = NIL_P(encoding) ? NULL : xmlGetCharEncodingName(NUM2INT(encoding));
        standalone = rb_hash_aref(options, sStandalone);
        if (NIL_P(standalone)) {
            xstandalone = NULL;
        } else {
            xstandalone = RTEST(standalone) ? "yes" : "no";
        }
    }
    rwo = rxml_textwriter_get(self);
# ifdef HAVE_RUBY_ENCODING_H
    rwo->encoding = rxml_figure_encoding(xencoding);
# endif /* !HAVE_RUBY_ENCODING_H */
    ret = xmlTextWriterStartDocument(rwo->writer, NULL, xencoding, xstandalone);

    return (-1 == ret ? Qfalse : Qtrue);
}

/* call-seq:
 *    writer.end_document -> (true|false)
 *
 * Ends current document. Returns +false+ on failure.
 */
static VALUE rxml_writer_end_document(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndDocument);
}

/* call-seq:
 *    writer.start_pi(target) -> (true|false)
 *
 * Starts a new processing instruction. Returns +false+ on failure.
 */
static VALUE rxml_writer_start_pi(VALUE self, VALUE target)
{
    return numeric_rxml_writer_string(self, target, xmlTextWriterStartPI);
}

/* call-seq:
 *    writer.end_pi -> (true|false)
 *
 * Ends current processing instruction. Returns +false+ on failure.
 */
static VALUE rxml_writer_end_pi(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndPI);
}

/* call-seq:
 *    writer.start_dtd(qualifiedName, publicId, systemId) -> (true|false)
 *
 * Starts a DTD. Returns +false+ on failure.
 */
static VALUE rxml_writer_start_dtd(int argc, VALUE *argv, VALUE self)
{
    VALUE name, pubid, sysid;

    rb_scan_args(argc, argv, "12", &name, &pubid, &sysid);

    return numeric_rxml_writer_va_strings(self, Qundef, 3, xmlTextWriterStartDTD, name, pubid, sysid);
}

/* call-seq:
 *    writer.start_dtd_element(qualifiedName) -> (true|false)
 *
 * Starts a DTD element (<!ELEMENT ... >). Returns +false+ on failure.
 */
static VALUE rxml_writer_start_dtd_element(VALUE self, VALUE name)
{
    return numeric_rxml_writer_string(self, name, xmlTextWriterStartDTDElement);
}

/* call-seq:
 *    writer.start_dtd_entity(name, pe = false) -> (true|false)
 *
 * Starts a DTD entity (<!ENTITY ... >). Returns +false+ on failure.
 */
static VALUE rxml_writer_start_dtd_entity(int argc, VALUE *argv, VALUE self)
{
    VALUE name, pe;

    rb_scan_args(argc, argv, "11", &name, &pe);
    if (NIL_P(pe)) {
        pe = Qfalse;
    }

    return numeric_rxml_writer_va_strings(self, pe, 1, xmlTextWriterStartDTDEntity, name);
}

/* call-seq:
 *    writer.start_dtd_attlist(name) -> (true|false)
 *
 * Starts a DTD attribute list (<!ATTLIST ... >). Returns +false+ on failure.
 */
static VALUE rxml_writer_start_dtd_attlist(VALUE self, VALUE name)
{
    return numeric_rxml_writer_string(self, name, xmlTextWriterStartDTDAttlist);
}

/* call-seq:
 *    writer.end_dtd -> (true|false)
 *
 * Ends current DTD, returns +false+ on failure.
 */
static VALUE rxml_writer_end_dtd(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndDTD);
}

/* call-seq:
 *    writer.end_dtd_entity -> (true|false)
 *
 * Ends current DTD entity, returns +false+ on failure.
 */
static VALUE rxml_writer_end_dtd_entity(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndDTDEntity);
}

/* call-seq:
 *    writer.end_dtd_attlist -> (true|false)
 *
 * Ends current DTD attribute list, returns +false+ on failure.
 */
static VALUE rxml_writer_end_dtd_attlist(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndDTDAttlist);
}

/* call-seq:
 *    writer.end_dtd_element -> (true|false)
 *
 * Ends current DTD element, returns +false+ on failure.
 */
static VALUE rxml_writer_end_dtd_element(VALUE self)
{
    return numeric_rxml_writer_void(self, xmlTextWriterEndDTDElement);
}

/* call-seq:
 *    writer.write_dtd(name [ [ [, publicId ], systemId ], subset ]) -> (true|false)
 *
 * Writes a DTD, all at once. Returns +false+ on failure.
 * - name: dtd name
 * - publicId: external subset public identifier, use nil for a SYSTEM doctype
 * - systemId: external subset system identifier
 * - subset: content
 *
 * Examples:
 *   writer.write_dtd 'html'
 *     # => <!DOCTYPE html>
 *   writer.write_dtd 'docbook', nil, 'http://www.docbook.org/xml/5.0/dtd/docbook.dtd'
 *     # => <!DOCTYPE docbook SYSTEM "http://www.docbook.org/xml/5.0/dtd/docbook.dtd">
 *   writer.write_dtd 'html', '-//W3C//DTD XHTML 1.1//EN', 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'
 *     # => <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
 *   writer.write_dtd 'person', nil, nil, '<!ELEMENT person (firstname,lastname)><!ELEMENT firstname (#PCDATA)><!ELEMENT lastname (#PCDATA)>'
 *     # => <!DOCTYPE person [<!ELEMENT person (firstname,lastname)><!ELEMENT firstname (#PCDATA)><!ELEMENT lastname (#PCDATA)>]>
 */
static VALUE rxml_writer_write_dtd(int argc, VALUE *argv, VALUE self)
{
    VALUE name, pubid, sysid, subset;

    rb_scan_args(argc, argv, "13", &name, &pubid, &sysid, &subset);

    return numeric_rxml_writer_va_strings(self, Qundef, 4, xmlTextWriterWriteDTD, name, pubid, sysid, subset);
}

/* call-seq:
 *    writer.write_dtd_attlist(name, content) -> (true|false)
 *
 * Writes a DTD attribute list, all at once. Returns +false+ on failure.
 *   writer.write_dtd_attlist 'id', 'ID #IMPLIED'
 *     # => <!ATTLIST id ID #IMPLIED>
 */
static VALUE rxml_writer_write_dtd_attlist(VALUE self, VALUE name, VALUE content)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 2, xmlTextWriterWriteDTDAttlist, name, content);
}

/* call-seq:
 *    writer.write_dtd_element(name, content) -> (true|false)
 *
 * Writes a full DTD element, all at once. Returns +false+ on failure.
 *   writer.write_dtd_element 'person', '(firstname,lastname)'
 *     # => <!ELEMENT person (firstname,lastname)>
 */
static VALUE rxml_writer_write_dtd_element(VALUE self, VALUE name, VALUE content)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 2, xmlTextWriterWriteDTDElement, name, content);
}

/* call-seq:
 *    writer.write_dtd_entity(name, publicId, systemId, ndataid, content, pe) -> (true|false)
 *
 * Writes a DTD entity, all at once. Returns +false+ on failure.
 */
static VALUE rxml_writer_write_dtd_entity(VALUE self, VALUE name, VALUE pubid, VALUE sysid, VALUE ndataid, VALUE content, VALUE pe)
{
    return numeric_rxml_writer_va_strings(self, pe, 5, xmlTextWriterWriteDTDEntity, name, pubid, sysid, ndataid, content);
}

/* call-seq:
 *    writer.write_dtd_external_entity(name, publicId, systemId, ndataid, pe) -> (true|false)
 *
 * Writes a DTD external entity. The entity must have been started
 * with start_dtd_entity. Returns +false+ on failure.
 * - name: the name of the DTD entity
 * - publicId: the public identifier, which is an alternative to the system identifier
 * - systemId: the system identifier, which is the URI of the DTD
 * - ndataid: the xml notation name
 * - pe: +true+ if this is a parameter entity (to be used only in the DTD
 * itself), +false+ if not
 */
static VALUE rxml_writer_write_dtd_external_entity(VALUE self, VALUE name, VALUE pubid, VALUE sysid, VALUE ndataid, VALUE pe)
{
    return numeric_rxml_writer_va_strings(self, pe, 4, xmlTextWriterWriteDTDExternalEntity, name, pubid, sysid, ndataid);
}

/* call-seq:
 *    writer.write_dtd_external_entity_contents(publicId, systemId, ndataid) -> (true|false)
 *
 * Writes the contents of a DTD external entity, all at once. Returns +false+ on failure.
 */
static VALUE rxml_writer_write_dtd_external_entity_contents(VALUE self, VALUE pubid, VALUE sysid, VALUE ndataid)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 3, xmlTextWriterWriteDTDExternalEntityContents, pubid, sysid, ndataid);
}

/* call-seq:
 *    writer.write_dtd_internal_entity(name, content, pe) -> (true|false)
 *
 * Writes a DTD internal entity, all at once. Returns +false+ on failure.
 *
 * Examples:
 *   writer.write_dtd_entity 'Shape', '(rect|circle|poly|default)', true
 *     # => <!ENTITY % Shape "(rect|circle|poly|default)">
 *   writer.write_dtd_entity 'delta', '&#948;', false
 *     # => <!ENTITY delta "&#948;">
 */
static VALUE rxml_writer_write_dtd_internal_entity(VALUE self, VALUE name, VALUE content, VALUE pe)
{
    return numeric_rxml_writer_va_strings(self, pe, 2, xmlTextWriterWriteDTDInternalEntity, name, content);
}

/* call-seq:
 *    writer.write_dtd_notation(name, publicId, systemId) -> (true|false)
 *
 * Writes a DTD entity, all at once. Returns +false+ on failure.
 */
static VALUE rxml_writer_write_dtd_notation(VALUE self, VALUE name, VALUE pubid, VALUE sysid)
{
    return numeric_rxml_writer_va_strings(self, Qundef, 3, xmlTextWriterWriteDTDNotation, name, pubid, sysid);
}

# if LIBXML_VERSION >= 20900
/* call-seq:
 *    writer.set_quote_char(...) -> (true|false)
 *
 * Sets the character used to quote attributes. Returns +false+ on failure.
 *
 * Notes:
 * - only " (default) and ' characters are valid
 * - availability: libxml2 >= 2.9.0
 */
static VALUE rxml_writer_set_quote_char(VALUE self, VALUE quotechar)
{
    int ret;
    const char *xquotechar;
    rxml_writer_object *rwo;

    rwo = rxml_textwriter_get(self);
    xquotechar = StringValueCStr(quotechar);
    ret = xmlTextWriterSetQuoteChar(rwo->writer, (xmlChar) xquotechar[0]);

    return (-1 == ret ? Qfalse : Qtrue);
}
# endif /* LIBXML_VERSION >= 20900 */

/* grep -P 'xmlTextWriter(Start|End|Write)(?!DTD|V?Format)[^(]+' /usr/include/libxml2/libxml/xmlwriter.h */
void rxml_init_writer(void)
{
    sEncoding = ID2SYM(rb_intern("encoding"));
    sStandalone = ID2SYM(rb_intern("standalone"));

    cXMLWriter = rb_define_class_under(mXML, "Writer", rb_cObject);

    rb_define_singleton_method(cXMLWriter, "io", rxml_writer_io, 1);
    rb_define_singleton_method(cXMLWriter, "file", rxml_writer_file, 1);
    rb_define_singleton_method(cXMLWriter, "document", rxml_writer_doc, 0);
    rb_define_singleton_method(cXMLWriter, "string", rxml_writer_string, 0);

    /* misc */
# if LIBXML_VERSION >= 20605
    rb_define_method(cXMLWriter, "set_indent", rxml_writer_set_indent, 1);
    rb_define_method(cXMLWriter, "set_indent_string", rxml_writer_set_indent_string, 1);
# endif /* LIBXML_VERSION >= 20605 */
# if LIBXML_VERSION >= 20900
    rb_define_method(cXMLWriter, "set_quote_char", rxml_writer_set_quote_char, 1);
# endif  /* LIBXML_VERSION >= 20900 */
    rb_define_method(cXMLWriter, "flush", rxml_writer_flush, -1);
    rb_define_method(cXMLWriter, "start_dtd", rxml_writer_start_dtd, -1);
    rb_define_method(cXMLWriter, "start_dtd_entity", rxml_writer_start_dtd_entity, -1);
    rb_define_method(cXMLWriter, "start_dtd_attlist", rxml_writer_start_dtd_attlist, 1);
    rb_define_method(cXMLWriter, "start_dtd_element", rxml_writer_start_dtd_element, 1);
    rb_define_method(cXMLWriter, "write_dtd", rxml_writer_write_dtd, -1);
    rb_define_method(cXMLWriter, "write_dtd_attlist", rxml_writer_write_dtd_attlist, 2);
    rb_define_method(cXMLWriter, "write_dtd_element", rxml_writer_write_dtd_element, 2);
    rb_define_method(cXMLWriter, "write_dtd_entity", rxml_writer_write_dtd_entity, 6);
    rb_define_method(cXMLWriter, "write_dtd_external_entity", rxml_writer_write_dtd_external_entity, 5);
    rb_define_method(cXMLWriter, "write_dtd_external_entity_contents", rxml_writer_write_dtd_external_entity_contents, 3);
    rb_define_method(cXMLWriter, "write_dtd_internal_entity", rxml_writer_write_dtd_internal_entity, 3);
    rb_define_method(cXMLWriter, "write_dtd_notation", rxml_writer_write_dtd_notation, 3);
    rb_define_method(cXMLWriter, "end_dtd", rxml_writer_end_dtd, 0);
    rb_define_method(cXMLWriter, "end_dtd_entity", rxml_writer_end_dtd_entity, 0);
    rb_define_method(cXMLWriter, "end_dtd_attlist", rxml_writer_end_dtd_attlist, 0);
    rb_define_method(cXMLWriter, "end_dtd_element", rxml_writer_end_dtd_element, 0);

    /* tag by parts */
    rb_define_method(cXMLWriter, "write_raw", rxml_writer_write_raw, 1);
    rb_define_method(cXMLWriter, "write_string", rxml_writer_write_string, 1);

    rb_define_method(cXMLWriter, "start_cdata", rxml_writer_start_cdata, 0);
    rb_define_method(cXMLWriter, "end_cdata", rxml_writer_end_cdata, 0);
    rb_define_method(cXMLWriter, "start_attribute", rxml_writer_start_attribute, 1);
    rb_define_method(cXMLWriter, "start_attribute_ns", rxml_writer_start_attribute_ns, -1);
    rb_define_method(cXMLWriter, "end_attribute", rxml_writer_end_attribute, 0);
    rb_define_method(cXMLWriter, "start_element", rxml_writer_start_element, 1);
    rb_define_method(cXMLWriter, "start_element_ns", rxml_writer_start_element_ns, -1);
    rb_define_method(cXMLWriter, "end_element", rxml_writer_end_element, 0);
    rb_define_method(cXMLWriter, "full_end_element", rxml_writer_full_end_element, 0);
    rb_define_method(cXMLWriter, "start_document", rxml_writer_start_document, -1);
    rb_define_method(cXMLWriter, "end_document", rxml_writer_end_document, 0);
# if LIBXML_VERSION >= 20607
    rb_define_method(cXMLWriter, "start_comment", rxml_writer_start_comment, 0);
    rb_define_method(cXMLWriter, "end_comment", rxml_writer_end_comment, 0);
# endif /* LIBXML_VERSION >= 20607 */
    rb_define_method(cXMLWriter, "start_pi", rxml_writer_start_pi, 1);
    rb_define_method(cXMLWriter, "end_pi", rxml_writer_end_pi, 0);

    /* full tag at once */
    rb_define_method(cXMLWriter, "write_attribute", rxml_writer_write_attribute, 2);
    rb_define_method(cXMLWriter, "write_attribute_ns", rxml_writer_write_attribute_ns, -1);
    rb_define_method(cXMLWriter, "write_comment", rxml_writer_write_comment, 1);
    rb_define_method(cXMLWriter, "write_cdata", rxml_writer_write_cdata, 1);
    rb_define_method(cXMLWriter, "write_element", rxml_writer_write_element, -1);
    rb_define_method(cXMLWriter, "write_element_ns", rxml_writer_write_element_ns, -1);
    rb_define_method(cXMLWriter, "write_pi", rxml_writer_write_pi, 2);

    rb_define_method(cXMLWriter, "result", rxml_writer_result, 0);

    rb_undef_method(CLASS_OF(cXMLWriter), "new");
}

#endif /* LIBXML_WRITER_ENABLED */
                                                                                                                                                                                                                                                                                                                                                             ruby_xml_writer.h                                                                                   0100644 0001750 0001750 00000000415 12566211276 044600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_WRITER__
# define __RXML_WRITER__

# include <libxml/xmlversion.h>

# ifdef LIBXML_WRITER_ENABLED

#  include <libxml/xmlwriter.h>

extern VALUE cXMLWriter;

void rxml_init_writer(void);

# endif /* LIBXML_WRITER_ENABLED */

#endif /* __RXML_WRITER__ */
                                                                                                                                                                                                                                                   ruby_xml_xinclude.c                                                                                 0100644 0001750 0001750 00000000472 12566211276 045075  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"
#include "ruby_xml_xinclude.h"

VALUE cXMLXInclude;

/*
 * Document-class: LibXML::XML::XInclude
 *
 * The ruby bindings do not currently expose libxml's
 * XInclude fuctionality.
 */

void rxml_init_xinclude(void)
{
  cXMLXInclude = rb_define_class_under(mXML, "XInclude", rb_cObject);
}
                                                                                                                                                                                                      ruby_xml_xinclude.h                                                                                 0100644 0001750 0001750 00000000346 12566211276 045102  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_XINCLUDE__
#define __RXML_XINCLUDE__

extern VALUE cXMLXInclude;
extern VALUE eXMLXIncludeError;

void rxml_init_xinclude(void);

#endif
                                                                                                                                                                                                                                                                                          ruby_xml_xpath.c                                                                                    0100644 0001750 0001750 00000013605 12566211276 044410  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /*
 * Document-class: LibXML::XML::XPath
 *
 * The XML::XPath module is used to query XML documents. It is
 * usually accessed via the XML::Document#find or
 * XML::Node#find methods.  For example:
 *
 *  document.find('/foo', namespaces) -> XML::XPath::Object
 *
 * The optional namespaces parameter can be a string, array or
 * hash table.
 *
 *   document.find('/foo', 'xlink:http://www.w3.org/1999/xlink')
 *   document.find('/foo', ['xlink:http://www.w3.org/1999/xlink',
 *                          'xi:http://www.w3.org/2001/XInclude')
 *   document.find('/foo', 'xlink' => 'http://www.w3.org/1999/xlink',
 *                             'xi' => 'http://www.w3.org/2001/XInclude')
 *
 *
 * === Working With Default Namespaces
 *
 * Finding namespaced elements and attributes can be tricky.
 * Lets work through an example of a document with a default
 * namespace:
 *
 *  <?xml version="1.0" encoding="utf-8"?>
 *  <feed xmlns="http://www.w3.org/2005/Atom">
 *    <title type="text">Phil Bogle's Contacts</title>
 *  </feed>
 *
 * To find nodes you must define the atom namespace for
 * libxml.  One way to do this is:
 *
 *   node = doc.find('atom:title', 'atom:http://www.w3.org/2005/Atom')
 *
 * Alternatively, you can register the default namespace like this:
 *
 *   doc.root.namespaces.default_prefix = 'atom'
 *   node = doc.find('atom:title')
 *
 * === More Complex Namespace Examples
 *
 * Lets work through some more complex examples using the
 * following xml document:
 *
 *  <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
 *    <soap:Body>
 *      <getManufacturerNamesResponse xmlns="http://services.somewhere.com">
 *        <IDAndNameList xmlns="http://services.somewhere.com">
 *          <ns1:IdAndName xmlns:ns1="http://domain.somewhere.com"/>
 *        </IDAndNameList>
 *      </getManufacturerNamesResponse>
 *  </soap:Envelope>
 *
 *  # Since the soap namespace is defined on the root
 *  # node we can directly use it.
 *  doc.find('/soap:Envelope')
 *
 *  # Since the ns1 namespace is not defined on the root node
 *  # we have to first register it with the xpath engine.
 *  doc.find('//ns1:IdAndName',
 *           'ns1:http://domain.somewhere.com')
 *
 *  # Since the getManufacturerNamesResponse element uses a default
 *  # namespace we first have to give it a prefix and register
 *  # it with the xpath engine.
 *  doc.find('//ns:getManufacturerNamesResponse',
 *            'ns:http://services.somewhere.com')
 *
 *  # Here is an example showing a complex namespace aware
 *  # xpath expression.
 *  doc.find('/soap:Envelope/soap:Body/ns0:getManufacturerNamesResponse/ns0:IDAndNameList/ns1:IdAndName',
 *  ['ns0:http://services.somewhere.com', 'ns1:http://domain.somewhere.com'])
*/


#include "ruby_libxml.h"

VALUE mXPath;

VALUE
rxml_xpath_to_value(xmlXPathContextPtr xctxt, xmlXPathObjectPtr xobject) {
  VALUE result;
  int type;

  if (xobject == NULL) {
    /* xmlLastError is different than xctxt->lastError.  Use
     xmlLastError since it has the message set while xctxt->lastError
     does not. */
    xmlErrorPtr xerror = xmlGetLastError();
    rxml_raise(xerror);
  }

  switch (type = xobject->type) {
    case XPATH_NODESET:
      result = rxml_xpath_object_wrap(xctxt->doc, xobject);
      break;
    case XPATH_BOOLEAN:
      result = (xobject->boolval != 0) ? Qtrue : Qfalse;
      xmlXPathFreeObject(xobject);
      break;
    case XPATH_NUMBER:
      result = rb_float_new(xobject->floatval);
      xmlXPathFreeObject(xobject);
      break;
    case XPATH_STRING:
      result = rxml_new_cstr((const char*)xobject->stringval, xctxt->doc->encoding);
      xmlXPathFreeObject(xobject);
      break;
    default:
      xmlXPathFreeObject(xobject);
      rb_raise(rb_eTypeError,
        "can't convert XPath object of type %d to Ruby value", type
      );
  }

  return result;
}

xmlXPathObjectPtr
rxml_xpath_from_value(VALUE value) {
  xmlXPathObjectPtr result = NULL;

  switch (TYPE(value)) {
    case T_TRUE:
    case T_FALSE:
      result = xmlXPathNewBoolean(RTEST(value));
      break;
    case T_FIXNUM:
    case T_FLOAT:
      result = xmlXPathNewFloat(NUM2DBL(value));
      break;
    case T_STRING:
      result = xmlXPathWrapString(xmlStrdup((const xmlChar *)StringValuePtr(value)));
      break;
    case T_NIL:
      result = xmlXPathNewNodeSet(NULL);
      break;
    case T_ARRAY: {
      int i, j;
      result = xmlXPathNewNodeSet(NULL);

      for (i = RARRAY_LEN(value); i > 0; i--) {
        xmlXPathObjectPtr obj = rxml_xpath_from_value(rb_ary_shift(value));

        if ((obj->nodesetval != NULL) && (obj->nodesetval->nodeNr != 0)) {
          for (j = 0; j < obj->nodesetval->nodeNr; j++) {
            xmlXPathNodeSetAdd(result->nodesetval, obj->nodesetval->nodeTab[j]);
          }
        }
      }
      break;
    }
    default:
      rb_raise(rb_eTypeError,
        "can't convert object of type %s to XPath object", rb_obj_classname(value)
      );
  }

  return result;
}

void rxml_init_xpath(void)
{
  mXPath = rb_define_module_under(mXML, "XPath");

  /* 0: Undefined value. */
  rb_define_const(mXPath, "UNDEFINED", INT2NUM(XPATH_UNDEFINED));
  /* 1: A nodeset, will be wrapped by XPath Object. */
  rb_define_const(mXPath, "NODESET", INT2NUM(XPATH_NODESET));
  /* 2: A boolean value. */
  rb_define_const(mXPath, "BOOLEAN", INT2NUM(XPATH_BOOLEAN));
  /* 3: A numeric value. */
  rb_define_const(mXPath, "NUMBER", INT2NUM(XPATH_NUMBER));
  /* 4: A string value. */
  rb_define_const(mXPath, "STRING", INT2NUM(XPATH_STRING));
  /* 5: An xpointer point */
  rb_define_const(mXPath, "POINT", INT2NUM(XPATH_POINT));
  /* 6: An xpointer range */
  rb_define_const(mXPath, "RANGE", INT2NUM(XPATH_RANGE));
  /* 7: An xpointer location set */
  rb_define_const(mXPath, "LOCATIONSET", INT2NUM(XPATH_LOCATIONSET));
  /* 8: XPath user type */
  rb_define_const(mXPath, "USERS", INT2NUM(XPATH_USERS));
  /* 9: An XSLT value tree, non modifiable */
  rb_define_const(mXPath, "XSLT_TREE", INT2NUM(XPATH_XSLT_TREE));
}
                                                                                                                           ruby_xml_xpath.h                                                                                    0100644 0001750 0001750 00000000452 12566211276 044411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_XPATH__
#define __RXML_XPATH__

extern VALUE mXPath;

void rxml_init_xpath(void);

VALUE rxml_xpath_to_value(xmlXPathContextPtr, xmlXPathObjectPtr);
xmlXPathObjectPtr rxml_xpath_from_value(VALUE);

#endif
                                                                                                                                                                                                                      ruby_xml_xpath_context.c                                                                            0100644 0001750 0001750 00000023500 12566211276 046147  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_xpath_context.h"
#include "ruby_xml_xpath_expression.h"

#if RUBY_ST_H
#include <ruby/st.h>
#else
#include <st.h>
#endif

/*
 * Document-class: LibXML::XML::XPath::Context
 *
 * The XML::XPath::Context class is used to evaluate XPath
 * expressions.  Generally, you should not directly use this class,
 * but instead use the XML::Document#find and XML::Node#find methods.
 *
 *  doc = XML::Document.string('<header>content</header>')
 *  context = XPath::Context.new(doc)
 *  context.node = doc.root
 *  context.register_namespaces_from_node(doc.root)
 *  nodes = context.find('/header')
 */

VALUE cXMLXPathContext;

static void rxml_xpath_context_free(xmlXPathContextPtr ctxt)
{
  xmlXPathFreeContext(ctxt);
}

static void rxml_xpath_context_mark(xmlXPathContextPtr ctxt)
{
  if (ctxt && ctxt->doc->_private)
    rb_gc_mark((VALUE) ctxt->doc->_private);
}

static VALUE rxml_xpath_context_alloc(VALUE klass)
{
  return Data_Wrap_Struct(cXMLXPathContext, rxml_xpath_context_mark, rxml_xpath_context_free, NULL);
}

/* call-seq:
 *    XPath::Context.new(doc) -> XPath::Context
 *
 * Creates a new XPath context for the specified document.  The
 * context can then be used to evaluate an XPath expression.
 *
 *  doc = XML::Document.string('<header><first>hi</first></header>')
 *  context = XPath::Context.new(doc)
 *  nodes = XPath::Object.new('//first', context)
 *  nodes.length == 1
 */
static VALUE rxml_xpath_context_initialize(VALUE self, VALUE document)
{
  xmlDocPtr xdoc;

  if (rb_obj_is_kind_of(document, cXMLDocument) != Qtrue)
  {
    rb_raise(rb_eTypeError, "Supplied argument must be a document or node.");
  }

  Data_Get_Struct(document, xmlDoc, xdoc);
  DATA_PTR(self) = xmlXPathNewContext(xdoc);

  return self;
}

/*
 * call-seq:
 *    context.doc -> document
 *
 * Obtain the XML::Document this node belongs to.
 */
static VALUE rxml_xpath_context_doc(VALUE self)
{
  xmlDocPtr xdoc = NULL;
  xmlXPathContextPtr ctxt;
  Data_Get_Struct(self, xmlXPathContext, ctxt);
  
  xdoc = ctxt->doc;
  return rxml_document_wrap(xdoc);
}

/*
 * call-seq:
 *    context.register_namespace(prefix, uri) -> (true|false)
 *
 * Register the specified namespace URI with the specified prefix
 * in this context.

 *   context.register_namespace('xi', 'http://www.w3.org/2001/XInclude')
 */
static VALUE rxml_xpath_context_register_namespace(VALUE self, VALUE prefix, VALUE uri)
{
  xmlXPathContextPtr ctxt;
  Data_Get_Struct(self, xmlXPathContext, ctxt);

  /* Prefix could be a symbol. */
  prefix = rb_obj_as_string(prefix);
  
  if (xmlXPathRegisterNs(ctxt, (xmlChar*) StringValuePtr(prefix),
      (xmlChar*) StringValuePtr(uri)) == 0)
  {
    return (Qtrue);
  }
  else
  {
    /* Should raise an exception, IMHO (whose?, why shouldnt it? -danj)*/
    rb_warning("register namespace failed");
    return (Qfalse);
  }
}

/* call-seq:
 *    context.register_namespaces_from_node(node) -> self
 *
 * Helper method to read in namespaces defined on a node.
 *
 *  doc = XML::Document.string('<header><first>hi</first></header>')
 *  context = XPath::Context.new(doc)
 *  context.register_namespaces_from_node(doc.root)
 */
static VALUE rxml_xpath_context_register_namespaces_from_node(VALUE self,
    VALUE node)
{
  xmlXPathContextPtr xctxt;
  xmlNodePtr xnode;
  xmlNsPtr *xnsArr;

  Data_Get_Struct(self, xmlXPathContext, xctxt);

  if (rb_obj_is_kind_of(node, cXMLDocument) == Qtrue)
  {
    xmlDocPtr xdoc;
    Data_Get_Struct(node, xmlDoc, xdoc);
    xnode = xmlDocGetRootElement(xdoc);
  }
  else if (rb_obj_is_kind_of(node, cXMLNode) == Qtrue)
  {
    Data_Get_Struct(node, xmlNode, xnode);
  }
  else
  {
    rb_raise(rb_eTypeError, "The first argument must be a document or node.");
  }

  xnsArr = xmlGetNsList(xnode->doc, xnode);

  if (xnsArr)
  {
    xmlNsPtr xns = *xnsArr;

    while (xns)
    {
      /* If there is no prefix, then this is the default namespace.
       Skip it for now. */
      if (xns->prefix)
      {
        VALUE prefix = rxml_new_cstr((const char*)xns->prefix, xctxt->doc->encoding);
        VALUE uri = rxml_new_cstr((const char*)xns->href, xctxt->doc->encoding);
        rxml_xpath_context_register_namespace(self, prefix, uri);
      }
      xns = xns->next;
    }
    xmlFree(xnsArr);
  }

  return self;
}

static int iterate_ns_hash(VALUE prefix, VALUE uri, VALUE self)
{
  rxml_xpath_context_register_namespace(self, prefix, uri);
  return ST_CONTINUE;
}

/*
 * call-seq:
 *    context.register_namespaces(["prefix:uri"]) -> self
 *
 * Register the specified namespaces in this context.  There are
 * three different forms that libxml accepts.  These include
 * a string, an array of strings, or a hash table:
 *
 *   context.register_namespaces('xi:http://www.w3.org/2001/XInclude')
 *   context.register_namespaces(['xlink:http://www.w3.org/1999/xlink',
 *                                'xi:http://www.w3.org/2001/XInclude')
 *   context.register_namespaces('xlink' => 'http://www.w3.org/1999/xlink',
 *                                  'xi' => 'http://www.w3.org/2001/XInclude')
 */
static VALUE rxml_xpath_context_register_namespaces(VALUE self, VALUE nslist)
{
  char *cp;
  long i;
  VALUE rprefix, ruri;
  xmlXPathContextPtr xctxt;

  Data_Get_Struct(self, xmlXPathContext, xctxt);

  /* Need to loop through the 2nd argument and iterate through the
   * list of namespaces that we want to allow */
  switch (TYPE(nslist))
  {
  case T_STRING:
    cp = strchr(StringValuePtr(nslist), (int) ':');
    if (cp == NULL)
    {
      rprefix = nslist;
      ruri = Qnil;
    }
    else
    {
      rprefix = rb_str_new(StringValuePtr(nslist), (int) ((long) cp
          - (long) StringValuePtr(nslist)));
      ruri = rxml_new_cstr(&cp[1], xctxt->doc->encoding);
    }
    /* Should test the results of this */
    rxml_xpath_context_register_namespace(self, rprefix, ruri);
    break;
  case T_ARRAY:
    for (i = 0; i < RARRAY_LEN(nslist); i++)
    {
      rxml_xpath_context_register_namespaces(self, RARRAY_PTR(nslist)[i]);
    }
    break;
  case T_HASH:
    rb_hash_foreach(nslist, iterate_ns_hash, self);
    break;
  default:
    rb_raise(
        rb_eArgError,
        "Invalid argument type, only accept string, array of strings, or an array of arrays");
  }
  return self;
}

/*
 * call-seq:
 *    context.node = node
 *
 * Set the current node used by the XPath engine

 *  doc = XML::Document.string('<header><first>hi</first></header>')
 *  context.node = doc.root.first
 */
static VALUE rxml_xpath_context_node_set(VALUE self, VALUE node)
{
  xmlXPathContextPtr xctxt;
  xmlNodePtr xnode;

  Data_Get_Struct(self, xmlXPathContext, xctxt);
  Data_Get_Struct(node, xmlNode, xnode);
  xctxt->node = xnode;
  return node;
}

/*
 * call-seq:
 *    context.find("xpath") -> true|false|number|string|XML::XPath::Object
 *
 * Executes the provided xpath function.  The result depends on the execution
 * of the xpath statement.  It may be true, false, a number, a string or 
 * a node set.
 */
static VALUE rxml_xpath_context_find(VALUE self, VALUE xpath_expr)
{
  xmlXPathContextPtr xctxt;
  xmlXPathObjectPtr xobject;
  xmlXPathCompExprPtr xcompexpr;

  Data_Get_Struct(self, xmlXPathContext, xctxt);

  if (TYPE(xpath_expr) == T_STRING)
  {
    VALUE expression = rb_check_string_type(xpath_expr);
    xobject = xmlXPathEval((xmlChar*) StringValueCStr(expression), xctxt);
  }
  else if (rb_obj_is_kind_of(xpath_expr, cXMLXPathExpression))
  {
    Data_Get_Struct(xpath_expr, xmlXPathCompExpr, xcompexpr);
    xobject = xmlXPathCompiledEval(xcompexpr, xctxt);
  }
  else
  {
    rb_raise(rb_eTypeError,
        "Argument should be an intance of a String or XPath::Expression");
  }

  return rxml_xpath_to_value(xctxt, xobject);
}

#if LIBXML_VERSION >= 20626
/*
 * call-seq:
 *    context.enable_cache(size = nil)
 *
 * Enables an XPath::Context's built-in cache.  If the cache is
 * enabled then XPath objects will be cached internally for reuse.
 * The size parameter controls sets the maximum number of XPath objects 
 * that will be cached per XPath object type (node-set, string, number,
 * boolean, and misc objects).  Set size to nil to use the default
 * cache size of 100.
 */
static VALUE
rxml_xpath_context_enable_cache(int argc,  VALUE *argv, VALUE self)
{
  xmlXPathContextPtr xctxt;
  VALUE size;
  int value = -1;

  Data_Get_Struct(self, xmlXPathContext, xctxt);

  if (rb_scan_args(argc, argv, "01", &size) == 1)
  {
	  value = NUM2INT(size);
  }

  if (xmlXPathContextSetCache(xctxt, 1, value, 0) == -1)
    rxml_raise(&xmlLastError);

  return self;
}

/*
 * call-seq:
 *    context.disable_cache
 * 
 * Disables an XPath::Context's built-in cache.
 */
static VALUE
rxml_xpath_context_disable_cache(VALUE self)
{
  xmlXPathContextPtr xctxt;
  Data_Get_Struct(self, xmlXPathContext, xctxt);

  if (xmlXPathContextSetCache(xctxt, 0, 0, 0) == -1)
    rxml_raise(&xmlLastError);

  return self;
}
#endif

void rxml_init_xpath_context(void)
{
  cXMLXPathContext = rb_define_class_under(mXPath, "Context", rb_cObject);
  rb_define_alloc_func(cXMLXPathContext, rxml_xpath_context_alloc);
  rb_define_method(cXMLXPathContext, "doc", rxml_xpath_context_doc, 0);
  rb_define_method(cXMLXPathContext, "initialize", rxml_xpath_context_initialize, 1);
  rb_define_method(cXMLXPathContext, "register_namespaces", rxml_xpath_context_register_namespaces, 1);
  rb_define_method(cXMLXPathContext, "register_namespaces_from_node", rxml_xpath_context_register_namespaces_from_node, 1);
  rb_define_method(cXMLXPathContext, "register_namespace", rxml_xpath_context_register_namespace, 2);
  rb_define_method(cXMLXPathContext, "node=", rxml_xpath_context_node_set, 1);
  rb_define_method(cXMLXPathContext, "find", rxml_xpath_context_find, 1);
#if LIBXML_VERSION >= 20626
  rb_define_method(cXMLXPathContext, "enable_cache", rxml_xpath_context_enable_cache, -1);
  rb_define_method(cXMLXPathContext, "disable_cache", rxml_xpath_context_disable_cache, 0);
#endif
}
                                                                                                                                                                                                ruby_xml_xpath_context.h                                                                            0100644 0001750 0001750 00000000330 12566211276 046150  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_XPATH_CONTEXT__
#define __RXML_XPATH_CONTEXT__

extern VALUE cXMLXPathContext;
void rxml_init_xpath_context(void);

#endif
                                                                                                                                                                                                                                                                                                        ruby_xml_xpath_expression.c                                                                         0100644 0001750 0001750 00000004561 12566211276 046670  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_xpath.h"
#include "ruby_xml_xpath_expression.h"

/*
 * Document-class: LibXML::XML::XPath::Expression
 *
 * The XML::XPath::Expression class is used to compile
 * XPath expressions so they can be parsed only once
 * but reused multiple times.
 *
 *  doc = XML::Document.string(IO.read('some xml file'))
 *  expr = XPath::Expression.new('//first')
 *  doc.root.each do |node|
 *   result = node.find(expr) # many, many, many times
 *   # ...
 *  end
 */

VALUE cXMLXPathExpression;

static void rxml_xpath_expression_free(xmlXPathCompExprPtr expr)
{
  xmlXPathFreeCompExpr(expr);
}

static VALUE rxml_xpath_expression_alloc(VALUE klass)
{
  return Data_Wrap_Struct(cXMLXPathExpression, NULL,
      rxml_xpath_expression_free, NULL);
}

/* call-seq:
 *    XPath::Expression.compile(expression) -> XPath::Expression
 *
 * Compiles an XPatch expression. This improves performance
 * when an XPath expression is called multiple times.
 *
 *  doc = XML::Document.string('<header><first>hi</first></header>')
 *  expr = XPath::Expression.new('//first')
 *  nodes = doc.find(expr)
 */
static VALUE rxml_xpath_expression_compile(VALUE klass, VALUE expression)
{
  VALUE args[] = {expression};
  return rb_class_new_instance(1, args, cXMLXPathExpression);
}

/* call-seq:
 *    XPath::Expression.new(expression) -> XPath::Expression
 *
 * Compiles an XPatch expression. This improves performance
 * when an XPath expression is called multiple times.
 *
 *  doc = XML::Document.string('<header><first>hi</first></header>')
 *  expr = XPath::Expression.new('//first')
 *  nodes = doc.find(expr)
 */
static VALUE rxml_xpath_expression_initialize(VALUE self, VALUE expression)
{
  xmlXPathCompExprPtr compexpr = xmlXPathCompile((const xmlChar*)StringValueCStr(expression));

  if (compexpr == NULL)
  {
    xmlErrorPtr xerror = xmlGetLastError();
    rxml_raise(xerror);
  }

  DATA_PTR( self) = compexpr;
  return self;
}

void rxml_init_xpath_expression(void)
{
  cXMLXPathExpression = rb_define_class_under(mXPath, "Expression", rb_cObject);
  rb_define_alloc_func(cXMLXPathExpression, rxml_xpath_expression_alloc);
  rb_define_singleton_method(cXMLXPathExpression, "compile", rxml_xpath_expression_compile, 1);
  rb_define_method(cXMLXPathExpression, "initialize", rxml_xpath_expression_initialize, 1);
}
                                                                                                                                               ruby_xml_xpath_expression.h                                                                         0100644 0001750 0001750 00000000345 12566211276 046671  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_XPATH_EXPRESSION__
#define __RXML_XPATH_EXPRESSION__

extern VALUE cXMLXPathExpression;

void rxml_init_xpath_expression(void);

#endif
                                                                                                                                                                                                                                                                                           ruby_xml_xpath_object.c                                                                             0100644 0001750 0001750 00000021515 12566211276 045735  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #include "ruby_libxml.h"

/*
 * Document-class: LibXML::XML::XPath::Object
 *
 * A collection of nodes returned from the evaluation of an XML::XPath
 * or XML::XPointer expression.
 */

VALUE cXMLXPathObject;


/* Memory management of xpath results is tricky.  If a nodeset is
   returned, it generally consists of pointers to nodes in the 
   original document.  However, namespace nodes are handled differently - 
   libxml creates copies of them instead.  Thus, when an xmlXPathObjectPtr
   is freed, libxml iterates over the results to find the copied namespace 
   nodes to free them.

   This causes problems for the bindings because the underlying document
   may be freed before the xmlXPathObjectPtr instance.  This might seem
   counterintuitive since the xmlXPathObjectPtr marks the document.
   However, once both objects go out of scope, the order of their 
   destruction is random.

   To deal with this, the wrapper code searches for the namespace nodes
   and wraps them in Ruby objects.  When the Ruby objects go out of scope
   then the namespace nodes are freed. */

static void rxml_xpath_object_free(rxml_xpath_object *rxpop)
{
  /* We positively, absolutely cannot let libxml iterate over
     the nodeTab since if the underlying document has been
     freed the majority of entries are invalid, resulting in
     segmentation faults.*/
  if (rxpop->xpop->nodesetval && rxpop->xpop->nodesetval->nodeTab)
  {
    xmlFree(rxpop->xpop->nodesetval->nodeTab);
    rxpop->xpop->nodesetval->nodeTab = NULL;
  }
  xmlXPathFreeObject(rxpop->xpop);
  xfree(rxpop);
}

/* Custom free function for copied namespace nodes */
static void rxml_xpath_namespace_free(xmlNsPtr xns)
{
  xmlFreeNs(xns);
}

static void rxml_xpath_object_mark(rxml_xpath_object *rxpop)
{
  rb_gc_mark(rxpop->nsnodes);
  if (rxpop->xdoc->_private)
    rb_gc_mark((VALUE)rxpop->xdoc->_private);
}

VALUE rxml_xpath_object_wrap(xmlDocPtr xdoc, xmlXPathObjectPtr xpop)
{
  int i;
  rxml_xpath_object *rxpop = ALLOC(rxml_xpath_object);
  rxpop->xdoc =xdoc;
  rxpop->xpop = xpop;
  rxpop->nsnodes = rb_ary_new();

  /* Find all the extra namespace nodes and wrap them. */
  if (xpop->nodesetval && xpop->nodesetval->nodeNr)
  {
    for (i = 0;i < xpop->nodesetval->nodeNr; i++)
    {
      xmlNodePtr xnode = xpop->nodesetval->nodeTab[i];
      if (xnode != NULL && xnode->type == XML_NAMESPACE_DECL)
      {
        VALUE ns = Qnil;
        xmlNsPtr xns = (xmlNsPtr)xnode;

        /* Get rid of libxml's -> next hack.  The issue here is
           the rxml_namespace code assumes that ns->next refers
           to another namespace. */
        xns->next = NULL;

        /* Specify a custom free function here since by default
           namespace nodes will not be freed */
        ns = rxml_namespace_wrap((xmlNsPtr)xnode);
        RDATA(ns)->dfree = (RUBY_DATA_FUNC)rxml_xpath_namespace_free;
        rb_ary_push(rxpop->nsnodes, ns);
      }
    }
  }

  return Data_Wrap_Struct(cXMLXPathObject, rxml_xpath_object_mark, rxml_xpath_object_free, rxpop);
}

static VALUE rxml_xpath_object_tabref(xmlXPathObjectPtr xpop, int index)
{
  if (index < 0)
    index = xpop->nodesetval->nodeNr + index;

  if (index < 0 || index + 1 > xpop->nodesetval->nodeNr)
    return Qnil;

  switch (xpop->nodesetval->nodeTab[index]->type)
  {
  case XML_ATTRIBUTE_NODE:
    return rxml_attr_wrap((xmlAttrPtr) xpop->nodesetval->nodeTab[index]);
    break;
  case XML_NAMESPACE_DECL:
    return rxml_namespace_wrap((xmlNsPtr)xpop->nodesetval->nodeTab[index]);
    break;
  default:
    return rxml_node_wrap(xpop->nodesetval->nodeTab[index]);
  }
}

/*
 * call-seq:
 *    xpath_object.to_a -> [node, ..., node]
 *
 * Obtain an array of the nodes in this set.
 */
static VALUE rxml_xpath_object_to_a(VALUE self)
{
  VALUE set_ary, nodeobj;
  rxml_xpath_object *rxpop;
  xmlXPathObjectPtr xpop;
  int i;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  xpop = rxpop->xpop;

  set_ary = rb_ary_new();

  if (!((xpop->nodesetval == NULL) || (xpop->nodesetval->nodeNr == 0)))
  {
    for (i = 0; i < xpop->nodesetval->nodeNr; i++)
    {
      nodeobj = rxml_xpath_object_tabref(xpop, i);
      rb_ary_push(set_ary, nodeobj);
    }
  }

  return (set_ary);
}

/*
 * call-seq:
 *    xpath_object.empty? -> (true|false)
 *
 * Determine whether this nodeset is empty (contains no nodes).
 */
static VALUE rxml_xpath_object_empty_q(VALUE self)
{
  rxml_xpath_object *rxpop;
  Data_Get_Struct(self, rxml_xpath_object, rxpop);

  if (rxpop->xpop->type != XPATH_NODESET)
    return Qnil;

  return (rxpop->xpop->nodesetval == NULL || rxpop->xpop->nodesetval->nodeNr <= 0) ? Qtrue
      : Qfalse;
}

/*
 * call-seq:
 *    xpath_object.each { |node| ... } -> self
 *
 * Call the supplied block for each node in this set.
 */
static VALUE rxml_xpath_object_each(VALUE self)
{
  rxml_xpath_object *rxpop;
  int i;

  if (rxml_xpath_object_empty_q(self) == Qtrue)
    return Qnil;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);

  for (i = 0; i < rxpop->xpop->nodesetval->nodeNr; i++)
  {
    rb_yield(rxml_xpath_object_tabref(rxpop->xpop, i));
  }
  return (self);
}

/*
 * call-seq:
 *    xpath_object.first -> node
 *
 * Returns the first node in this node set, or nil if none exist.
 */
static VALUE rxml_xpath_object_first(VALUE self)
{
  rxml_xpath_object *rxpop;

  if (rxml_xpath_object_empty_q(self) == Qtrue)
    return Qnil;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  return rxml_xpath_object_tabref(rxpop->xpop, 0);
}

/*
 * call-seq:
 *    xpath_object.last -> node
 *
 * Returns the last node in this node set, or nil if none exist.
 */
static VALUE rxml_xpath_object_last(VALUE self)
{
  rxml_xpath_object *rxpop;

  if (rxml_xpath_object_empty_q(self) == Qtrue)
    return Qnil;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  return rxml_xpath_object_tabref(rxpop->xpop, -1);
}

/*
 * call-seq:
 * xpath_object[i] -> node
 *
 * array index into set of nodes
 */
static VALUE rxml_xpath_object_aref(VALUE self, VALUE aref)
{
  rxml_xpath_object *rxpop;

  if (rxml_xpath_object_empty_q(self) == Qtrue)
    return Qnil;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  return rxml_xpath_object_tabref(rxpop->xpop, NUM2INT(aref));
}

/*
 * call-seq:
 *    xpath_object.length -> num
 *
 * Obtain the length of the nodesetval node list.
 */
static VALUE rxml_xpath_object_length(VALUE self)
{
  rxml_xpath_object *rxpop;

  if (rxml_xpath_object_empty_q(self) == Qtrue)
    return INT2FIX(0);

  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  return INT2NUM(rxpop->xpop->nodesetval->nodeNr);
}

/*
 * call-seq:
 *    xpath_object.xpath_type -> int
 *
 * Returns the XPath type of the result object.
 * Possible values are defined as constants
 * on the XML::XPath class and include:
 *
 * * XML::XPath::UNDEFINED
 * * XML::XPath::NODESET
 * * XML::XPath::BOOLEAN
 * * XML::XPath::NUMBER
 * * XML::XPath::STRING
 * * XML::XPath::POINT
 * * XML::XPath::RANGE
 * * XML::XPath::LOCATIONSET
 * * XML::XPath::USERS
 * * XML::XPath::XSLT_TREE
 */
static VALUE rxml_xpath_object_get_type(VALUE self)
{
  rxml_xpath_object *rxpop;
  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  return INT2FIX(rxpop->xpop->type);
}

/*
 * call-seq:
 *    xpath_object.string -> String
 *
 * Returns the original XPath expression as a string.
 */
static VALUE rxml_xpath_object_string(VALUE self)
{
  rxml_xpath_object *rxpop;

  Data_Get_Struct(self, rxml_xpath_object, rxpop);

  if (rxpop->xpop->stringval == NULL)
    return Qnil;

  return rxml_new_cstr((const char*) rxpop->xpop->stringval, rxpop->xdoc->encoding);
}

/*
 * call-seq:
 *    nodes.debug -> (true|false)
 *
 * Dump libxml debugging information to stdout.
 * Requires Libxml be compiled with debugging enabled.
 */
static VALUE rxml_xpath_object_debug(VALUE self)
{
#ifdef LIBXML_DEBUG_ENABLED
  rxml_xpath_object *rxpop;
  Data_Get_Struct(self, rxml_xpath_object, rxpop);
  xmlXPathDebugDumpObject(stdout, rxpop->xpop, 0);
  return Qtrue;
#else
  rb_warn("libxml was compiled without debugging support.")
  return Qfalse;
#endif
}

void rxml_init_xpath_object(void)
{
  cXMLXPathObject = rb_define_class_under(mXPath, "Object", rb_cObject);
  rb_include_module(cXMLXPathObject, rb_mEnumerable);
  rb_define_attr(cXMLXPathObject, "context", 1, 0);
  rb_define_method(cXMLXPathObject, "each", rxml_xpath_object_each, 0);
  rb_define_method(cXMLXPathObject, "xpath_type", rxml_xpath_object_get_type, 0);
  rb_define_method(cXMLXPathObject, "empty?", rxml_xpath_object_empty_q, 0);
  rb_define_method(cXMLXPathObject, "first", rxml_xpath_object_first, 0);
  rb_define_method(cXMLXPathObject, "last", rxml_xpath_object_last, 0);
  rb_define_method(cXMLXPathObject, "length", rxml_xpath_object_length, 0);
  rb_define_method(cXMLXPathObject, "to_a", rxml_xpath_object_to_a, 0);
  rb_define_method(cXMLXPathObject, "[]", rxml_xpath_object_aref, 1);
  rb_define_method(cXMLXPathObject, "string", rxml_xpath_object_string, 0);
  rb_define_method(cXMLXPathObject, "debug", rxml_xpath_object_debug, 0);
}
                                                                                                                                                                                   ruby_xml_xpath_object.h                                                                             0100644 0001750 0001750 00000000504 12566211276 045735  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    #ifndef __RXML_XPATH_OBJECT__
#define __RXML_XPATH_OBJECT__

extern VALUE cXMLXPathObject;

typedef struct rxml_xpath_object
{
  xmlDocPtr xdoc;
  xmlXPathObjectPtr xpop;
  VALUE nsnodes;
} rxml_xpath_object;


void rxml_init_xpath_object(void);
VALUE rxml_xpath_object_wrap(xmlDocPtr xdoc, xmlXPathObjectPtr xpop);

#endif
                                                                                                                                                                                            ruby_xml_xpointer.c                                                                                 0100644 0001750 0001750 00000005130 12566211276 045126  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#include "ruby_libxml.h"
#include "ruby_xml_xpointer.h"

VALUE cXMLXPointer;

/*
 * Document-class: LibXML::XML::XPointer
 *
 * The XML::Pointer class provides a standards based API for searching an xml document.
 * XPointer is based on the XML Path Language (XML::XPath) and is documented
 * at http://www.w3.org/TR/WD-xptr.
 */

static VALUE rxml_xpointer_point(VALUE class, VALUE rnode, VALUE xptr_str)
{
#ifdef LIBXML_XPTR_ENABLED
  xmlNodePtr xnode;
  xmlXPathContextPtr xctxt;
  xmlXPathObjectPtr xpop;

  VALUE context;
  VALUE result;
  VALUE argv[1];

  Check_Type(xptr_str, T_STRING);
  if (rb_obj_is_kind_of(rnode, cXMLNode) == Qfalse)
  rb_raise(rb_eTypeError, "require an XML::Node object");

  Data_Get_Struct(rnode, xmlNode, xnode);

  argv[0] = rb_funcall(rnode, rb_intern("doc"), 0);
  context = rb_class_new_instance(1, argv, cXMLXPathContext);
  Data_Get_Struct(context, xmlXPathContext, xctxt);

  xpop = xmlXPtrEval((xmlChar*)StringValuePtr(xptr_str), xctxt);
  if (!xpop)
  rxml_raise(&xmlLastError);

  result = rxml_xpath_object_wrap(xnode->doc, xpop);
  rb_iv_set(result, "@context", context);

  return(result);
#else
  rb_warn("libxml was compiled without XPointer support");
  return (Qfalse);
#endif
}

VALUE rxml_xpointer_point2(VALUE node, VALUE xptr_str)
{
  return (rxml_xpointer_point(cXMLXPointer, node, xptr_str));
}

/*
 * call-seq:
 *    XML::XPointer.range(start_node, end_node) -> xpath
 *
 * Create an xpath representing the range between the supplied
 * start and end node.
 */
static VALUE rxml_xpointer_range(VALUE class, VALUE rstart, VALUE rend)
{
#ifdef LIBXML_XPTR_ENABLED
  xmlNodePtr start, end;
  VALUE rxxp;
  xmlXPathObjectPtr xpath;

  if (rb_obj_is_kind_of(rstart, cXMLNode) == Qfalse)
  rb_raise(rb_eTypeError, "require an XML::Node object as a starting point");
  if (rb_obj_is_kind_of(rend, cXMLNode) == Qfalse)
  rb_raise(rb_eTypeError, "require an XML::Node object as an ending point");

  Data_Get_Struct(rstart, xmlNode, start);
  if (start == NULL)
  return(Qnil);

  Data_Get_Struct(rend, xmlNode, end);
  if (end == NULL)
  return(Qnil);

  xpath = xmlXPtrNewRangeNodes(start, end);
  if (xpath == NULL)
  rb_fatal("You shouldn't be able to have this happen");

  rxxp = rxml_xpath_object_wrap(start->doc, xpath);
  return(rxxp);
#else
  rb_warn("libxml was compiled without XPointer support");
  return (Qfalse);
#endif
}

void rxml_init_xpointer(void)
{
  cXMLXPointer = rb_define_class_under(mXML, "XPointer", rb_cObject);
  rb_define_singleton_method(cXMLXPointer, "range", rxml_xpointer_range, 2);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                        ruby_xml_xpointer.h                                                                                 0100644 0001750 0001750 00000000376 12566211276 045142  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/ext/libxml                    /* Please see the LICENSE file for copyright and distribution information */

#ifndef __RXML_XPOINTER__
#define __RXML_XPOINTER__

extern VALUE cXMLXPointer;

void rxml_init_xpointer(void);
VALUE rxml_xpointer_point2(VALUE node, VALUE xptr_str);

#endif
                                                                                                                                                                                                                                                                  lib/                                                                                                0040755 0001750 0001750 00000000000 12612224746 037652  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0                               libxml/                                                                                             0040755 0001750 0001750 00000000000 12612224746 041141  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib                           attr.rb                                                                                             0100644 0001750 0001750 00000005157 12566211276 042447  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Attr 
      include Enumerable

      # call-seq:
      #    attr.child? -> (true|false)
      #
      # Returns whether this attribute has child attributes.
      #
      def child?
        not self.children.nil?
      end

      # call-seq:
      #    attr.doc? -> (true|false)
      #
      # Determine whether this attribute is associated with an
      # XML::Document.
      def doc?
        not self.doc.nil?
      end

      # call-seq:
      #    attr.last? -> (true|false)
      #
      # Determine whether this is the last attribute.
      def last?
        self.last.nil?
      end

      # call-seq:
      #    attr.next? -> (true|false)
      #
      # Determine whether there is a next attribute.
      def next?
        not self.next.nil?
      end

      # call-seq:
      #    attr.ns? -> (true|false)
      #
      # Determine whether this attribute has an associated
      # namespace.
      def ns?
        not self.ns.nil?
      end

      # call-seq:
      #   attr.namespacess -> XML::Namespaces
      #
      # Returns this node's XML::Namespaces object,
      # which is used to access the namespaces
      # associated with this node.
      def namespaces
        @namespaces ||= XML::Namespaces.new(self)
      end
      
      #
      # call-seq:
      #    attr.parent? -> (true|false)
      #
      # Determine whether this attribute has a parent.
      def parent?
        not self.parent.nil?
      end

      # call-seq:
      #    attr.prev? -> (true|false)
      #
      # Determine whether there is a previous attribute.
      def prev?
        not self.prev.nil?
      end

      # Returns this node's type name
      def node_type_name
        if node_type == Node::ATTRIBUTE_NODE
          'attribute'
        else
          raise(UnknownType, "Unknown node type: %n", node.node_type);
        end
      end

      # Iterates nodes and attributes
      def siblings(node, &blk)
        if n = node
          loop do
            blk.call(n)
            break unless n = n.next
          end
        end
      end

      def each_sibling(&blk)
        siblings(self,&blk)
      end
  
      alias :each_attr :each_sibling
      alias :each :each_sibling
  
      def to_h
        inject({}) do |h,a|
          h[a.name] = a.value
          h
        end
      end

      def to_a
        inject([]) do |ary,a| 
          ary << [a.name, a.value]
          ary
        end
      end
  
      def to_s
        "#{name} = #{value}"
      end
    end
  end
end                                                                                                                                                                                                                                                                                                                                                                                                                 attr_decl.rb                                                                                        0100644 0001750 0001750 00000003617 12566211276 043435  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class AttrDecl
      include Enumerable

      # call-seq:
      #   attr_decl.child -> nil
      #
      # Obtain this attribute declaration's child attribute(s).
      # It will always be nil.
      def child
        nil
      end

      # call-seq:
      #    attr_decl.child? -> (true|false)
      #
      # Returns whether this attribute declaration has child attributes.
      #
      def child?
        not self.children.nil?
      end

      # call-seq:
      #    attr_decl.doc? -> (true|false)
      #
      # Determine whether this attribute declaration is associated with an
      # XML::Document.
      def doc?
        not self.doc.nil?
      end

      # call-seq:
      #    attr_decl.next? -> (true|false)
      #
      # Determine whether there is a next attribute declaration.
      def next?
        not self.next.nil?
      end

      # call-seq:
      #    attr_decl.parent? -> (true|false)
      #
      # Determine whether this attribute declaration has a parent .
      def parent?
        not self.parent.nil?
      end

      # call-seq:
      #    attr_decl.prev? -> (true|false)
      #
      # Determine whether there is a previous attribute declaration.
      def prev?
        not self.prev.nil?
      end

      # call-seq:
      #    attr_decl.node_type_name -> 'attribute declaration'
      #
      # Returns this attribute declaration's node type name.
      def node_type_name
        if node_type == Node::ATTRIBUTE_DECL
          'attribute declaration'
        else
          raise(UnknownType, "Unknown node type: %n", node.node_type);
        end
      end

      # call-seq:
      #    attr_decl.to_s -> string
      #
      # Returns a string representation of this attribute declaration.
      def to_s
        "#{name} = #{value}"
      end
    end
  end
end
                                                                                                                 attributes.rb                                                                                       0100644 0001750 0001750 00000000337 12566211276 043656  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Attributes
      def to_h
        inject({}) do |hash, attr|
          hash[attr.name] = attr.value
          hash
        end
      end
    end
  end
end                                                                                                                                                                                                                                                                                                 document.rb                                                                                         0100644 0001750 0001750 00000015777 12566211276 043324  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Document
      # call-seq:
      #    XML::Document.document(document) -> XML::Document
      #
      # Creates a new document based on the specified document.
      #
      # Parameters:
      #
      #  document - A preparsed document.
      def self.document(value)
        Parser.document(value).parse
      end

      # call-seq:
      #    XML::Document.file(path) -> XML::Document
      #    XML::Document.file(path, :encoding => XML::Encoding::UTF_8,
      #                             :options => XML::Parser::Options::NOENT) -> XML::Document
      #
      # Creates a new document from the specified file or uri.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::Parser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.file(value, options = {})
        Parser.file(value, options).parse
      end

      # call-seq:
      #    XML::Document.io(io) -> XML::Document
      #    XML::Document.io(io, :encoding => XML::Encoding::UTF_8,
      #                         :options => XML::Parser::Options::NOENT
      #                         :base_uri="http://libxml.org") -> XML::Document
      #
      # Creates a new document from the specified io object.
      #
      # Parameters:
      #
      #  io - io object that contains the xml to parser
      #  base_uri - The base url for the parsed document.
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::Parser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.io(value, options = {})
        Parser.io(value, options).parse
      end

      # call-seq:
      #    XML::Document.string(string) -> XML::Document
      #    XML::Document.string(string, :encoding => XML::Encoding::UTF_8,
      #                               :options => XML::Parser::Options::NOENT
      #                               :base_uri="http://libxml.org") -> XML::Document
      #
      # Creates a new document from the specified string.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #   base_uri - The base url for the parsed document.
      #   encoding - The document encoding, defaults to nil. Valid values
      #              are the encoding constants defined on XML::Encoding.
      #   options  - Parser options.  Valid values are the constants defined on
      #              XML::Parser::Options.  Mutliple options can be combined
      #              by using Bitwise OR (|).
      def self.string(value, options = {})
        Parser.string(value, options).parse
      end

      # Returns a new XML::XPathContext for the document.
      #
      # call-seq:
      #   document.context(namespaces=nil) -> XPath::Context
      #
      # Namespaces is an optional array of XML::NS objects
      def context(nslist = nil)
        context = XPath::Context.new(self)
        context.node = self.root
        context.register_namespaces_from_node(self.root)
        context.register_namespaces(nslist) if nslist
        context
      end

      # Return the nodes matching the specified xpath expression, 
      # optionally using the specified namespace.  For more 
      # information about working with namespaces, please refer
      # to the XML::XPath documentation.
      #
      # call-seq:
      #   document.find(xpath, nslist=nil) -> XML::XPath::Object
      # 
      # Parameters:
      # * xpath - The xpath expression as a string
      # * namespaces - An optional list of namespaces (see XML::XPath for information).
      #
      #  document.find('/foo', 'xlink:http://www.w3.org/1999/xlink')
      #
      # IMPORTANT - The returned XML::Node::Set must be freed before
      # its associated document.  In a running Ruby program this will
      # happen automatically via Ruby's mark and sweep garbage collector.
      # However, if the program exits, Ruby does not guarantee the order
      # in which objects are freed
      # (see http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/17700).
      # As a result, the associated document may be freed before the node
      # list, which will cause a segmentation fault.
      # To avoid this, use the following (non-ruby like) coding style:
      #
      #  nodes = doc.find('/header')
      #  nodes.each do |node|
      #    ... do stuff ...
      #  end
      # #  nodes = nil #  GC.start
      def find(xpath, nslist = nil)
        self.context(nslist).find(xpath)
      end
    
      # Return the first node matching the specified xpath expression.
      # For more information, please refer to the documentation
      # for XML::Document#find.
      def find_first(xpath, nslist = nil)
        find(xpath, nslist).first
      end
      
      # Returns this node's type name    
      def node_type_name
        case node_type
        when XML::Node::DOCUMENT_NODE
          'document_xml'
        when XML::Node::DOCB_DOCUMENT_NODE
          'document_docbook'
        when XML::Node::HTML_DOCUMENT_NODE
          'document_html'
        else
          raise(UnknownType, "Unknown node type: %n", node.node_type);
        end
      end
      # :enddoc:

      # Specifies if this is an document node
      def document?
        node_type == XML::Node::DOCUMENT_NODE
      end

      # Specifies if this is an docbook node
      def docbook_doc?
        node_type == XML::Node::DOCB_DOCUMENT_NODE
      end

      # Specifies if this is an html node
      def html_doc?
        node_type == XML::Node::HTML_DOCUMENT_NODE
      end

      def dump
        warn('Document#dump is deprecated.  Use Document#to_s instead.')
        self.to_s
      end

      def format_dump
        warn('Document#format_dump is deprecated.  Use Document#to_s instead.')
        self.to_s
      end

      def debug_dump
        warn('Document#debug_dump is deprecated.  Use Document#debug instead.')
        self.debug
      end

      def debug_dump_head
        warn('Document#debug_dump_head is deprecated.  Use Document#debug instead.')
        self.debug
      end

      def debug_format_dump
        warn('Document#debug_format_dump is deprecated.  Use Document#to_s instead.')
        self.to_s
      end

      def reader
        warn('Document#reader is deprecated.  Use XML::Reader.document(self) instead.')
        XML::Reader.document(self)
      end
    end
  end
end  
 error.rb                                                                                            0100644 0001750 0001750 00000005026 12566211276 042621  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Error
      # Create mapping from domain constant value to keys
      DOMAIN_CODE_MAP = [:NO_ERROR, :PARSER, :TREE, :NAMESPACE, :DTD, :HTML, :MEMORY,
                         :OUTPUT, :IO, :FTP, :HTTP, :XINCLUDE, :XPATH, :XPOINTER, :REGEXP,
                         :DATATYPE, :SCHEMASP, :SCHEMASV, :RELAXNGP, :RELAXNGV, :CATALOG,
                         :C14N, :XSLT, :VALID, :CHECK, :WRITER, :MODULE, :I18N, :SCHEMATRONV].inject(Hash.new) do |hash, code|
        if const_defined?(code)
          hash[const_get(code)] = code.to_s
        end
        hash
      end

      # Create mapping from domain constant value to keys
      ERROR_CODE_MAP = Hash.new.tap do |map|
        (constants -
         DOMAIN_CODE_MAP.values - #Domains
         [:NONE, :WARNING, :ERROR, :FATAL] # Levels
         ).each do |code|
          map[const_get(code)] = code.to_s
        end
      end
      
      # Verbose error handler
      VERBOSE_HANDLER = lambda do |error|
        STDERR << error.to_s << "\n"
        STDERR.flush
      end

      # Quiet error handler
      QUIET_HANDLER = lambda do |error|
      end
      
      def ==(other)
        eql?(other)
      end
      
      def eql?(other)
        self.code == other.code and
        self.domain == other.domain and
        self.message == other.message and
        self.level == other.level and
        self.file == other.file and
        self.line == other.line and
        self.str1 == other.str1 and
        self.str2 == other.str2 and
        self.str3 == other.str3 and
        self.int1 == other.int1 and
        self.int2 == other.int2 and
        self.ctxt == other.ctxt and
        self.node == other.node
      end

      def level_to_s
        case self.level
          when NONE
            ''
          when WARNING
            'Warning:'
          when ERROR
            'Error:'
          when FATAL
            'Fatal error:'
        end
      end

      def domain_to_s
        DOMAIN_CODE_MAP[self.domain]
      end

      def code_to_s
        ERROR_CODE_MAP[self.code]
      end

      def to_s
        msg = super
        msg = msg ? msg.strip: ''

        if self.line
          sprintf("%s %s at %s:%d.", self.level_to_s, msg,
                                     self.file, self.line)
        else
          sprintf("%s %s.", self.level_to_s, msg)
        end
      end
    end
  end
end

LibXML::XML::Error.set_handler(&LibXML::XML::Error::VERBOSE_HANDLER)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          hpricot.rb                                                                                          0100644 0001750 0001750 00000003651 12566211276 043142  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

## Provide hpricot API for libxml.  Provided by Michael Guterl,
## inspired by http://thebogles.com/blog/an-hpricot-style-interface-to-libxml
#
#class String
#  def to_libxml_doc
#    xp = XML::Parser.new
#    xp.string = self
#    xp.parse
#  end
#end
#
#module LibXML
#  module XML
#    class Document
#      alias :search :find
#    end
#
#    class Node
#      # find the child node with the given xpath
#      def at(xpath)
#        self.find_first(xpath)
#      end
#
#      # find the array of child nodes matching the given xpath
#      def search(xpath)
#        results = self.find(xpath).to_a
#        if block_given?
#          results.each do |result|
#            yield result
#          end
#        end
#        return results
#      end
#
#      def /(xpath)
#        search(xpath)
#      end
#
#      # return the inner contents of this node as a string
#      def inner_xml
#        child.to_s
#      end
#
#      # alias for inner_xml
#      def inner_html
#        inner_xml
#      end
#
#      # return this node and its contents as an xml string
#      def to_xml
#        self.to_s
#      end
#
#      # alias for path
#      def xpath
#        self.path
#      end
#
#      def find_with_default_ns(xpath_expr, namespace=nil)
#        find_base(xpath_expr, namespace || default_namespaces)
#      end
#
#      def find_first_with_default_ns(xpath_expr, namespace=nil)
#        find_first_base(xpath_expr, namespace || default_namespaces)
#      end
#
##      alias_method :find_base, :find unless method_defined?(:find_base)
##      alias_method :find, :find_with_default_ns
##      alias_method :find_first_base, :find_first unless method_defined?(:find_first_base)
##      alias_method :find_first, :find_first_with_default_ns
##      alias :child? :first?
##      alias :children? :first?
##      alias :child :first
#    end
#  end
#end                                                                                       html_parser.rb                                                                                      0100644 0001750 0001750 00000010210 12566211276 043777  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class HTMLParser
      # call-seq:
      #    XML::HTMLParser.file(path) -> XML::HTMLParser
      #    XML::HTMLParser.file(path, :encoding => XML::Encoding::UTF_8,
      #                           :options => XML::HTMLParser::Options::NOENT) -> XML::HTMLParser
      #
      # Creates a new parser by parsing the specified file or uri.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::HTMLParser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.file(path, options = {})
        context = XML::HTMLParser::Context.file(path)
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      # call-seq:
      #    XML::HTMLParser.io(io) -> XML::HTMLParser
      #    XML::HTMLParser.io(io, :encoding => XML::Encoding::UTF_8,
      #                       :options => XML::HTMLParser::Options::NOENT
      #                       :base_uri="http://libxml.org") -> XML::HTMLParser
      #
      # Creates a new reader by parsing the specified io object.
      #
      # Parameters:
      #
      #  io - io object that contains the xml to parser
      #  base_uri - The base url for the parsed document.
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::HTMLParser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.io(io, options = {})
        context = XML::HTMLParser::Context.io(io)
        context.base_uri = options[:base_uri] if options[:base_uri]
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      # call-seq:
      #    XML::HTMLParser.string(string)
      #    XML::HTMLParser.string(string, :encoding => XML::Encoding::UTF_8,
      #                               :options => XML::HTMLParser::Options::NOENT
      #                               :base_uri="http://libxml.org") -> XML::HTMLParser
      #
      # Creates a new parser by parsing the specified string.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #  base_uri - The base url for the parsed document.
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::HTMLParser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.string(string, options = {})
        context = XML::HTMLParser::Context.string(string)
        context.base_uri = options[:base_uri] if options[:base_uri]
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      # :enddoc:

      def file=(value)
        warn("XML::HTMLParser#file is deprecated.  Use XML::HTMLParser.file instead")
        @context = XML::HTMLParser::Context.file(value)
      end

      def io=(value)
        warn("XML::HTMLParser#io is deprecated.  Use XML::HTMLParser.io instead")
        @context = XML::HTMLParser::Context.io(value)
      end

      def string=(value)
        warn("XML::HTMLParser#string is deprecated.  Use XML::HTMLParser.string instead")
        @context = XML::HTMLParser::Context.string(value)
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                        namespace.rb                                                                                        0100644 0001750 0001750 00000002577 12566211276 043434  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Namespace
      include Comparable
      include Enumerable

      # call-seq:
      #   namespace1 <=> namespace2
      #
      # Compares two namespace objects.  Namespace objects are
      # considered equal if their prefixes and hrefs are the same.
      def <=>(other)
        if self.prefix.nil? and other.prefix.nil?
          self.href <=> other.href
        elsif self.prefix.nil?
          -1
        elsif other.prefix.nil?
          1
        else
          self.prefix <=> other.prefix
        end
      end

      # call-seq:
      #   namespace.each {|ns| .. }
      #
      # libxml stores namespaces in memory as a linked list.
      # Use the each method to iterate over the list.  Note
      # the first namespace in the loop is the current namespace.
      #
      # Usage:
      #   namespace.each do |ns|
      #     ..
      #   end
      def each
        ns = self

        while ns
          yield ns
          ns = ns.next
        end
      end

      # call-seq:
      #   namespace.to_s -> "string"
      #
      # Returns the string represenation of a namespace.
      #
      # Usage:
      #   namespace.to_s
      def to_s
        if self.prefix
          "#{self.prefix}:#{self.href}"
        else
          self.href
        end
      end
    end
  end
end                                                                                                                                 namespaces.rb                                                                                       0100644 0001750 0001750 00000002320 12566211276 043601  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Namespaces
      # call-seq:
      #   namespace.default -> XML::Namespace
      #
      # Returns the default namespace for this node or nil.
      #
      # Usage:
      #   doc = XML::Document.string('<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"/>')
      #   ns = doc.root.namespaces.default_namespace
      #   assert_equal(ns.href, 'http://schemas.xmlsoap.org/soap/envelope/')
      def default
        find_by_prefix(nil)
      end

      # call-seq:
      #   namespace.default_prefix = "string"
      #
      # Assigns a name (prefix) to the default namespace.
      # This makes it much easier to perform XML::XPath
      # searches.
      #
      # Usage:
      #   doc = XML::Document.string('<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"/>')
      #   doc.root.namespaces.default_prefix = 'soap'
      #   node = doc.root.find_first('soap:Envelope')
      def default_prefix=(prefix)
        # Find default prefix
        ns = find_by_prefix(nil)
        raise(ArgumentError, "No default namespace was found") unless ns
        Namespace.new(self.node, prefix, ns.href)
      end
    end
  end
end                                                                                                                                                                                                                                                                                                                node.rb                                                                                             0100644 0001750 0001750 00000025205 12566211276 042416  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

require 'stringio'

module LibXML
  module XML
    class Node
      # Determines whether this node has attributes
      def attributes?
        attributes.length > 0
      end
      
      # Create a shallow copy of the node.  To create
      # a deep copy call Node#copy(true)
      def clone
        copy(false)
      end

      # call-seq:
      #    node.inner_xml -> "string"
      #    node.inner_xml(:indent => true, :encoding => 'UTF-8', :level => 0) -> "string"
      #
      # Converts a node's children, to a string representation.  To include
      # the node, use XML::Node#to_s.  For more information about
      # the supported options, see XML::Node#to_s.
      def inner_xml(options = Hash.new)
        io = nil
        self.each do |node|
          xml = node.to_s(options)
          # Create the string IO here since we now know the encoding
          io = create_string_io(xml) unless io
          io << xml
        end

        io ? io.string : nil
      end
      
      # :call-seq:
      #   node.dup -> XML::Node
      #
      # Create a shallow copy of the node.  To create
      # a deep copy call Node#copy(true)
      def dup
        copy(false)
      end
    
      # call-seq:
      #   node.context(namespaces=nil) -> XPath::Context
      #
      # Returns a new XML::XPathContext for the current node.
      #
      # Namespaces is an optional array of XML::NS objects
      def context(nslist = nil)
        if not self.doc
          raise(TypeError, "A node must belong to a document before a xpath context can be created")
        end

        context = XPath::Context.new(self.doc)
        context.node = self
        context.register_namespaces_from_node(self)
        context.register_namespaces_from_node(self.doc.root)
        context.register_namespaces(nslist) if nslist
        context
      end

      # call-seq:
      #   node.find(namespaces=nil) -> XPath::XPathObject
      #
      # Return nodes matching the specified xpath expression.
      # For more information, please refer to the documentation
      # for XML::Document#find.
      #
      # Namespaces is an optional array of XML::NS objects
      def find(xpath, nslist = nil)
        self.context(nslist).find(xpath)
      end
    
      # call-seq:
      #   node.find_first(namespaces=nil) -> XML::Node
      #
      # Return the first node matching the specified xpath expression.
      # For more information, please refer to the documentation
      # for the #find method.
      def find_first(xpath, nslist = nil)
        find(xpath, nslist).first
      end

      # call-seq:
      #   node.namespacess -> XML::Namespaces
      #   
      # Returns this node's XML::Namespaces object,
      # which is used to access the namespaces
      # associated with this node.
      def namespaces
        @namespaces ||= XML::Namespaces.new(self)
      end
      
      # -------  Traversal  ----------------
      # Iterates over this node's attributes.
      #
      #  doc = XML::Document.new('model/books.xml')
      #  doc.root.each_attr {|attr| puts attr}
      def each_attr
        attributes.each do |attr|
          yield(attr)
        end
      end
      
      # Iterates over this node's child elements (nodes
      # that have a node_type == ELEMENT_NODE).
      #
      #  doc = XML::Document.new('model/books.xml')
      #  doc.root.each_element {|element| puts element}
      def each_element
        each do |node|
          yield(node) if node.node_type == ELEMENT_NODE
        end
      end
      
      # Determines whether this node has a parent node
      def parent?
        not parent.nil?
      end
    
      # Determines whether this node has a first node
      def first?
        not first.nil?
      end
    
      # Returns this node's children as an array.
      def children
        entries
      end
    
      # Determines whether this node has a next node
      def next?
        not self.next.nil?
      end
    
      # Determines whether this node has a previous node
      def prev?
        not prev.nil?
      end
    
      # Determines whether this node has a last node
      def last?
        not last.nil?
      end


      # -------  Node Types  ----------------
      
      # Returns this node's type name    
      def node_type_name
        case node_type
          # Most common choices first
          when ATTRIBUTE_NODE
            'attribute'
          when DOCUMENT_NODE
            'document_xml'
          when ELEMENT_NODE
            'element'
          when TEXT_NODE
            'text'
          
          # Now the rest  
          when ATTRIBUTE_DECL
            'attribute_decl'
          when CDATA_SECTION_NODE
            'cdata'
          when COMMENT_NODE
            'comment'
          when DOCB_DOCUMENT_NODE
            'document_docbook'
          when DOCUMENT_FRAG_NODE
            'fragment'
          when DOCUMENT_TYPE_NODE
            'doctype'
          when DTD_NODE
            'dtd'
          when ELEMENT_DECL
            'elem_decl'
          when ENTITY_DECL
            'entity_decl'
          when ENTITY_NODE
            'entity'
          when ENTITY_REF_NODE
            'entity_ref'
          when HTML_DOCUMENT_NODE
            'document_html'
          when NAMESPACE_DECL
            'namespace'
          when NOTATION_NODE
            'notation'
          when PI_NODE
            'pi'
          when XINCLUDE_START
            'xinclude_start'
          when XINCLUDE_END
            'xinclude_end'
          else
            raise(UnknownType, "Unknown node type: %n", node.node_type);
        end
      end
      
      # Specifies if this is an attribute node
      def attribute?
        node_type == ATTRIBUTE_NODE
      end
      
      # Specifies if this is an attribute declaration node
      def attribute_decl?
        node_type == ATTRIBUTE_DECL
      end

      # Specifies if this is an CDATA node
      def cdata?
        node_type == CDATA_SECTION_NODE
      end

      # Specifies if this is an comment node
      def comment?
        node_type == COMMENT_NODE
      end

      # Specifies if this is an docbook node
      def docbook_doc?
        node_type == DOCB_DOCUMENT_NODE
      end

      # Specifies if this is an doctype node
      def doctype?
        node_type == DOCUMENT_TYPE_NODE
      end

      # Specifies if this is an document node
      def document?
        node_type == DOCUMENT_NODE
      end

      # Specifies if this is an DTD node
      def dtd?
        node_type == DTD_NODE
      end

      # Specifies if this is an element node
      def element?
        node_type == ELEMENT_NODE
      end

      # Specifies if this is an entity node
      def entity?
        node_type == ENTITY_NODE
      end

      # Specifies if this is an element declaration node
      def element_decl?
        node_type == ELEMENT_DECL
      end

      # Specifies if this is an entity reference node
      def entity_ref?
        node_type == ENTITY_REF_NODE
      end

      # Specifies if this is a fragment node
      def fragment?
        node_type == DOCUMENT_FRAG_NODE
      end

      # Specifies if this is a html document node
      def html_doc?
        node_type == HTML_DOCUMENT_NODE
      end

      # Specifies if this is a namespace node (not if it
      # has a namepsace)
      def namespace?
        node_type == NAMESPACE_DECL
      end

      # Specifies if this is a notation node
      def notation?
        node_type == NOTATION_NODE
      end

      # Specifies if this is a processiong instruction node
      def pi?
        node_type == PI_NODE
      end

      # Specifies if this is a text node
      def text?
        node_type == TEXT_NODE
      end
      
      # Specifies if this is an xinclude end node
      def xinclude_end?
        node_type == XINCLUDE_END
      end
      
      # Specifies if this is an xinclude start node
      def xinclude_start?
        node_type == XINCLUDE_START
      end

      alias :child? :first?  
      alias :children? :first?  
      alias :child :first
      alias :each_child :each

      # --- Deprecated Output ---
      # :stopdoc:
      def dump
        warn('Node#dump is deprecated.  Use Node#to_s instead.')
        self.to_s
      end

      # --- Deprecated DOM Manipulation ---
      def child_add(node)
        warn('Node#child_add is deprecated.  Use Node#<< instead.')
        self << node
      end

      def child=(node)
        warn('Node#child= is deprecated.  Use Node#<< instead.')
        self << node
      end

      # --- Deprecated Namespaces ---
      def namespace
        warn('Node#namespace is deprecated.  Use Node#namespaces instead.')
        self.namespaces.entries
      end

      def namespace=(value)
        warn('Node#namespace= is deprecated.  Use Node#namespaces.namespace= instead.')
        self.namespaces.namespace = value
      end

      def namespace_node
        warn('Node#namespace_node is deprecated.  Use Node#namespaces.namespace instead.')
        self.namespaces.namespace
      end

      def ns
        warn('Node#ns is deprecated.  Use Node#namespaces.namespace instead.')
        self.namespaces.namespace
      end

      def ns?
        warn('Node#ns? is deprecated.  Use !Node#namespaces.namespace.nil? instead.')
        !self.namespaces.namespace.nil?
      end

      def ns_def
        warn('Node#ns_def is deprecated.  Use Node#namespaces.definitions instead.')
        self.namespaces.definitions
      end

      def ns_def?
        warn('Node#ns_def? is deprecated.  Use !Node#namespaces.definitions.nil? instead.')
        !self.namespaces.definitions.nil?
      end

      def base
        warn('Node#base is deprecated.  Use Node#base_uri.')
        self.base_uri
      end

      def base=(value)
        warn('Node#base= is deprecated.  Use Node#base_uri=.')
        self.base_uri = value
      end

      def search_ns(prefix)
        warn('Node#search_ns is deprecated.  Use Node#namespaces.find_by_prefix instead.')
        self.namespaces.find_by_prefix(prefix)
      end

      def search_href(href)
        warn('Node#search_href is deprecated.  Use Node#namespaces.find_by_href instead.')
        self.namespaces.find_by_href(href)
      end

      # :startdoc:

      private

      def create_string_io(xml)
        result = StringIO.new("")
        if defined?(::Encoding)
          result.set_encoding(xml.encoding)
        end
        result
      end
    end
  end
end                                                                                                                                                                                                                                                                                                                                                                                           ns.rb                                                                                               0100644 0001750 0001750 00000001054 12566211276 042105  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class NS < Namespace # :nodoc: 
      def initialize(node, prefix, href)
        warn('The XML::NS class is deprecated.  Use XML::Namespace instead.')
        super(node, href, prefix)
      end

      def href?
        warn('XML::NS#href? is deprecated.  Use !XML::NS#href.nil? instead.')
        not self.href.nil?
      end

      def prefix?
        warn('XML::NS#prefix? is deprecated.  Use !XML::NS#prefix?.nil? instead.')
        not self.previx.nil?
      end
    end
  end
end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    parser.rb                                                                                           0100644 0001750 0001750 00000033433 12566211276 042767  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Parser
      # call-seq:
      #    XML::Parser.document(document) -> XML::Parser
      #
      # Creates a new parser for the specified document.
      #
      # Parameters:
      #
      #  document - A preparsed document.
      def self.document(doc)
        context = XML::Parser::Context.document(doc)
        self.new(context)
      end

      # call-seq:
      #    XML::Parser.file(path) -> XML::Parser
      #    XML::Parser.file(path, :encoding => XML::Encoding::UTF_8,
      #                           :options => XML::Parser::Options::NOENT) -> XML::Parser
      #
      # Creates a new parser for the specified file or uri.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::Parser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.file(path, options = {})
        context = XML::Parser::Context.file(path)
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      # call-seq:
      #    XML::Parser.io(io) -> XML::Parser
      #    XML::Parser.io(io, :encoding => XML::Encoding::UTF_8,
      #                       :options => XML::Parser::Options::NOENT
      #                       :base_uri="http://libxml.org") -> XML::Parser
      #
      # Creates a new parser for the specified io object.
      #
      # Parameters:
      #
      #  io - io object that contains the xml to parser
      #  base_uri - The base url for the parsed document.
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::Parser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.io(io, options = {})
        context = XML::Parser::Context.io(io)
        context.base_uri = options[:base_uri] if options[:base_uri]
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      # call-seq:
      #    XML::Parser.string(string)
      #    XML::Parser.string(string, :encoding => XML::Encoding::UTF_8,
      #                               :options => XML::Parser::Options::NOENT
      #                               :base_uri="http://libxml.org") -> XML::Parser
      #
      # Creates a new parser by parsing the specified string.
      #
      # You may provide an optional hash table to control how the
      # parsing is performed.  Valid options are:
      #
      #  base_uri - The base url for the parsed document.
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      #  options - Parser options.  Valid values are the constants defined on
      #            XML::Parser::Options.  Mutliple options can be combined
      #            by using Bitwise OR (|).
      def self.string(string, options = {})
        context = XML::Parser::Context.string(string)
        context.base_uri = options[:base_uri] if options[:base_uri]
        context.encoding = options[:encoding] if options[:encoding]
        context.options = options[:options] if options[:options]
        self.new(context)
      end

      def self.register_error_handler(proc)
        warn('Parser.register_error_handler is deprecated.  Use Error.set_handler instead')
        if proc.nil?
          Error.reset_handler
        else
          Error.set_handler(&proc)
        end
      end

      # :enddoc:

      # Bunch of deprecated methods that have moved to the XML module
      VERSION = XML::VERSION
      VERNUM = XML::VERNUM

      def document=(value)
        warn("XML::Parser#document= is deprecated.  Use XML::Parser.document= instead")
        @context = XML::Parser::Context.document(value)
      end

      def file=(value)
        warn("XML::Parser#file is deprecated.  Use XML::Parser.file instead")
        @context = XML::Parser::Context.file(value)
      end

      def filename=(value)
        warn("XML::Parser#filename is deprecated.  Use XML::Parser.file instead")
        self.file = value
      end

      def io=(value)
        warn("XML::Parser#io is deprecated.  Use XML::Parser.io instead")
        @context = XML::Parser::Context.io(value)
      end

      def string=(value)
        warn("XML::Parser#string is deprecated.  Use XML::Parser.string instead")
        @context = XML::Parser::Context.string(value)
      end

      def self.enabled_automata?
        warn("XML::Parser.enabled_automata? has been deprecated.  Use XML.enabled_automata? instead")
        XML.enabled_automata?
      end

      def self.enabled_c14n?
        warn("XML::Parser.enabled_c14n? has been deprecated.  Use XML.enabled_c14n? instead")
        XML.enabled_c14n?
      end

      def self.enabled_catalog?
        warn("XML::Parser.enabled_catalog? has been deprecated.  Use XML.enabled_catalog? instead")
        XML.enabled_catalog?
      end

      def self.enabled_debug?
        warn("XML::Parser.enabled_debug? has been deprecated.  Use XML.enabled_debug? instead")
        XML.enabled_debug?
      end

      def self.enabled_docbook?
        warn("XML::Parser.enabled_docbook? has been deprecated.  Use XML.enabled_docbook? instead")
        XML.enabled_docbook?
      end

      def self.enabled_ftp?
        warn("XML::Parser.enabled_ftp? has been deprecated.  Use XML.enabled_ftp? instead")
        XML.enabled_ftp?
      end

      def self.enabled_http?
        warn("XML::Parser.enabled_http? has been deprecated.  Use XML.enabled_http? instead")
        XML.enabled_http?
      end

      def self.enabled_html?
        warn("XML::Parser.enabled_html? has been deprecated.  Use XML.enabled_html? instead")
        XML.enabled_html?
      end

      def self.enabled_iconv?
        warn("XML::Parser.enabled_iconv? has been deprecated.  Use XML.enabled_iconv? instead")
        XML.enabled_iconv?
      end

      def self.enabled_memory_debug?
        warn("XML::Parser.enabled_memory_debug_location? has been deprecated.  Use XML.enabled_memory_debug_location? instead")
        XML.enabled_memory_debug_location?
      end

      def self.enabled_regexp?
        warn("XML::Parser.enabled_regexp? has been deprecated.  Use XML.enabled_regexp? instead")
        XML.enabled_regexp?
      end

      def self.enabled_schemas?
        warn("XML::Parser.enabled_schemas? has been deprecated.  Use XML.enabled_schemas? instead")
        XML.enabled_schemas?
      end

      def self.enabled_thread?
        warn("XML::Parser.enabled_thread? has been deprecated.  Use XML.enabled_thread? instead")
        XML.enabled_thread?
      end

      def self.enabled_unicode?
        warn("XML::Parser.enabled_unicode? has been deprecated.  Use XML.enabled_unicode? instead")
        XML.enabled_unicode?
      end

      def self.enabled_xinclude?
        warn("XML::Parser.enabled_xinclude? has been deprecated.  Use XML.enabled_xinclude? instead")
        XML.enabled_xinclude?
      end

      def self.enabled_xpath?
        warn("XML::Parser.enabled_xpath? has been deprecated.  Use XML.enabled_xpath? instead")
        XML.enabled_xpath?
      end

      def self.enabled_xpointer?
        warn("XML::Parser.enabled_xpointer? has been deprecated.  Use XML.enabled_xpointer? instead")
        XML.enabled_xpointer?
      end

      def self.enabled_zlib?
        warn("XML::Parser.enabled_zlib? has been deprecated.  Use XML.enabled_zlib? instead")
        XML.enabled_zlib?
      end

      def self.catalog_dump
        warn("XML::Parser.catalog_dump has been deprecated.  Use XML.catalog_dump instead")
        XML.catalog_dump
      end

      def self.catalog_remove
        warn("XML::Parser.catalog_remove has been deprecated.  Use XML.catalog_remove instead")
        XML.catalog_remove
      end

      def self.check_lib_versions
        warn("XML::Parser.check_lib_versions has been deprecated.  Use XML.check_lib_versions instead")
        XML.check_lib_versions
      end

      def self.debug_entities
        warn("XML::Parser.debug_entities has been deprecated.  Use XML.debug_entities instead")
        XML.debug_entities
      end

      def self.debug_entities=(value)
        warn("XML::Parser.debug_entities_set has been deprecated.  Use XML.debug_entities= value instead")
        XML.debug_entities= value
      end

      def self.default_compression
        warn("XML::Parser.default_compression has been deprecated.  Use XML.default_compression instead")
        XML.default_compression
      end

      def self.default_compression=(value)
        warn("XML::Parser.default_compression= value has been deprecated.  Use XML.default_compression= value instead")
        XML.default_compression= value
      end

      def self.default_keep_blanks
        warn("XML::Parser.default_keep_blanks has been deprecated.  Use XML.default_keep_blanks instead")
        XML.default_keep_blanks
      end

      def self.default_keep_blanks=(value)
        warn("XML::Parser.default_keep_blanks= value has been deprecated.  Use XML.default_keep_blanks= value instead")
        XML.default_keep_blanks= value
      end

      def self.default_load_external_dtd
        warn("XML::Parser.default_load_external_dtd has been deprecated.  Use XML.default_load_external_dtd instead")
        XML.default_load_external_dtd
      end

      def self.default_load_external_dtd=(value)
        warn("XML::Parser.default_load_external_dtd= value has been deprecated.  Use XML.default_load_external_dtd= value instead")
        XML.default_load_external_dtd= value
      end

      def self.default_line_numbers
        warn("XML::Parser.default_line_numbers has been deprecated.  Use XML.default_line_numbers instead")
        XML.default_line_numbers
      end

      def self.default_line_numbers=(value)
        warn("XML::Parser.default_line_numbers= value has been deprecated.  Use XML.default_line_numbers= value instead")
        XML.default_line_numbers= value
      end

      def self.default_pedantic_parser
        warn("XML::Parser.default_pedantic_parser has been deprecated.  Use XML.default_pedantic_parser instead")
        XML.default_pedantic_parser
      end

      def self.default_pedantic_parser=(value)
        warn("XML::Parser.default_pedantic_parser= value has been deprecated.  Use XML.default_pedantic_parser= value instead")
        XML.default_pedantic_parser= value
      end

      def self.default_substitute_entities
        warn("XML::Parser.default_substitute_entities has been deprecated.  Use XML.default_substitute_entities instead")
        XML.default_substitute_entities
      end

      def self.default_substitute_entities=(value)
        warn("XML::Parser.default_substitute_entities= value has been deprecated.  Use XML.default_substitute_entities= value instead")
        XML.default_substitute_entities= value
      end

      def self.default_tree_indent_string
        warn("XML::Parser.default_tree_indent_string has been deprecated.  Use XML.default_tree_indent_string instead")
        XML.default_tree_indent_string
      end

      def self.default_tree_indent_string=(value)
        warn("XML::Parser.default_tree_indent_string= value has been deprecated.  Use XML.default_tree_indent_string= value instead")
        XML.default_tree_indent_string= value
      end

      def self.default_validity_checking
        warn("XML::Parser.default_validity_checking has been deprecated.  Use XML.default_validity_checking instead")
        XML.default_validity_checking
      end

      def self.default_validity_checking=(value)
        warn("XML::Parser.default_validity_checking= value has been deprecated.  Use XML.default_validity_checking= value instead")
        XML.default_validity_checking= value
      end

      def self.default_warnings
        warn("XML::Parser.default_warnings has been deprecated.  Use XML.default_warnings instead")
        XML.default_warnings
      end

      def self.default_warnings=(value)
        warn("XML::Parser.default_warnings= value has been deprecated.  Use XML.default_warnings= value instead")
        XML.default_warnings= value
      end

      def self.features
        warn("XML::Parser.features has been deprecated.  Use XML.features instead")
        XML.features
      end

      def self.indent_tree_output
        warn("XML::Parser.indent_tree_output has been deprecated.  Use XML.indent_tree_output instead")
        XML.indent_tree_output
      end

      def self.indent_tree_output=(value)
        warn("XML::Parser.indent_tree_output= value has been deprecated.  Use XML.indent_tree_output= value instead")
        XML.indent_tree_output= value
      end

      def self.filename(value)
        warn("Parser.filename is deprecated.  Use Parser.file instead")
        self.file(value)
      end

      def self.memory_dump
        warn("XML::Parser.memory_dump has been deprecated.  Use XML.memory_dump instead")
        XML.memory_dump
      end

      def self.memory_used
        warn("XML::Parser.memory_used has been deprecated.  Use XML.memory_used instead")
        XML.memory_used
      end
    end
  end
end                                                                                                                                                                                                                                     properties.rb                                                                                       0100644 0001750 0001750 00000000756 12566211276 043671  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Node
      def property(name)
        warn('Node#properties is deprecated.  Use Node#[] instead.')
        self[name]
      end

      def properties
        warn('Node#properties is deprecated.  Use Node#attributes instead.')
        self.attributes
      end

      def properties?
        warn('Node#properties? is deprecated.  Use Node#attributes? instead.')
        self.attributes?
      end
    end

  end
end                  reader.rb                                                                                           0100644 0001750 0001750 00000001367 12566211276 042736  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Reader
      def reset_error_handler
        warn('reset_error_handler is deprecated.  Use Error.reset_handler instead')
        Error.reset_handler
      end

      def set_error_handler(&block)
        warn('set_error_handler is deprecated.  Use Error.set_handler instead')
        Error.set_handler(&block)
      end

      # :enddoc:

      def self.walker(doc)
        warn("XML::Reader.walker is deprecated.  Use XML::Reader.document instead")
        self.document(doc)
      end

      def self.data(string, options = nil)
        warn("XML::Reader.data is deprecated.  Use XML::Reader.string instead")
        self.string(string, options)
      end
    end
  end
end                                                                                                                                                                                                                                                                         sax_callbacks.rb                                                                                    0100644 0001750 0001750 00000012415 12566211276 044262  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class SaxParser
      module Callbacks
        # Called for a CDATA block event.
        def on_cdata_block(cdata)
        end

        # Called for a characters event.
        def on_characters(chars)
        end

        # Called for a comment event.
        def on_comment(msg)
        end

        # Called for a end document event.
        def on_end_document
        end

        # Called for a end element event.
        def on_end_element_ns(name, prefix, uri)
        end

        # Called for parser errors.
        def on_error(msg)
        end

        # Called for an external subset event.
        def on_external_subset(name, external_id, system_id)
        end

        # Called for an external subset notification event.
        def on_has_external_subset
        end

        # Called for an internal subset notification event.
        def on_has_internal_subset
        end

        # Called for an internal subset event.
        def on_internal_subset(name, external_id, system_id)
        end

        # Called for 'is standalone' event.
        def on_is_standalone
        end

        # Called for an processing instruction event.
        def on_processing_instruction(target, data)
        end

        # Called for a reference event.
        def on_reference(name)
        end

        # Called for a start document event.
        def on_start_document
        end

        # Called for a start element event.
        def on_start_element_ns(name, attributes, prefix, uri, namespaces)
        end
      end

      module VerboseCallbacks
        # Called for a CDATA block event.
        def on_cdata_block(cdata)
          STDOUT << "on_cdata_block" << "\n" <<
                    "  cdata " << cdata << "\n"
          STDOUT.flush
        end

        # Called for a characters event.
        def on_characters(chars)
          STDOUT << "on_characters" << "\n" <<
                    "  chars " << chars << "\n" 
          STDOUT.flush
        end

        # Called for a comment event.
        def on_comment(comment)
          STDOUT << "on_comment" << "\n" <<
                    "  comment: " << comment << "\n"
          STDOUT.flush
        end

        # Called for a end document event.
        def on_end_document
          STDOUT << "on_end_document\n"
          STDOUT.flush
        end

        # Called for a end element event.
        def on_end_element_ns(name, prefix, uri)
          STDOUT << "on_end_element_ns" << "\n" <<
                    "  name: " << name << "\n" <<
                    "  prefix: " << prefix << "\n" <<
                    "  uri: " << uri << "\n"
          STDOUT.flush
        end

        # Called for parser errors.
        def on_error(error)
          STDOUT << "on_error" << "\n"
                    "  error " << error << "\n"
          STDOUT.flush
        end

        # Called for an external subset event.
        def on_external_subset(name, external_id, system_id)
          STDOUT << "on_external_subset" << "\n"
                    "  external_id " << external_id << "\n" <<
                    "  system_id   " << system_id << "\n"
          STDOUT.flush
        end

        # Called for an external subset notification event.
        def on_has_external_subset
          STDOUT << "on_has_internal_subset\n"
          STDOUT.flush
        end

        # Called for an internal subset notification event.
        def on_has_internal_subset
          STDOUT << "on_has_internal_subset\n"
          STDOUT.flush
        end

        # Called for an internal subset event.
        def on_internal_subset(name, external_id, system_id)
          STDOUT << "on_internal_subset" << "\n"
                    "  external_id " << external_id << "\n" <<
                    "  system_id   " << system_id << "\n"
          STDOUT.flush
        end

        # Called for 'is standalone' event.
        def on_is_standalone
          STDOUT << "on_is_standalone\n"
          STDOUT.flush
        end

        # Called for an processing instruction event.
        def on_processing_instruction(target, data)
          STDOUT << "on_characters" << "\n"
                    "  target: " << target << "\n" <<
                    "  data:   " << data << "\n"
          STDOUT.flush
        end

        # Called for a reference event.
        def on_reference(name)
          STDOUT << "on_reference:" << "\n" <<
                    "  name:" << name << "\n"
          STDOUT.flush
        end

        # Called for a start document event.
        def on_start_document
          STDOUT << "on_start_document\n"
          STDOUT.flush
        end

        # Called for a start element event.
        def on_start_element_ns(name, attributes, prefix, uri, namespaces)
          STDOUT << "on_start_element_ns" << "\n" <<
                    "  name: " << name << "\n" <<
                    "  attr: " << (attributes || Hash.new).inspect << "\n" <<
                    "  prefix: " << prefix << "\n" <<
                    "  uri: " << uri << "\n" <<
                    "  ns_defs: " << (namespaces || Hash.new).inspect << "\n"
          STDOUT.flush
        end
      end
    end
  end
end                                                                                                                                                                                                                                                   sax_parser.rb                                                                                       0100644 0001750 0001750 00000003357 12566211276 043644  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class SaxParser
      # call-seq:
      #    XML::SaxParser.file(path) -> XML::SaxParser
      #
      # Creates a new parser by parsing the specified file or uri.
      def self.file(path)
        context = XML::Parser::Context.file(path)
        self.new(context)
      end

      # call-seq:
      #    XML::SaxParser.io(io) -> XML::SaxParser
      #    XML::SaxParser.io(io, :encoding => XML::Encoding::UTF_8) -> XML::SaxParser
      #
      # Creates a new reader by parsing the specified io object.
      #
      # Parameters:
      #
      #  encoding - The document encoding, defaults to nil. Valid values
      #             are the encoding constants defined on XML::Encoding.
      def self.io(io, options = {})
        context = XML::Parser::Context.io(io)
        context.encoding = options[:encoding] if options[:encoding]
        self.new(context)
      end

      # call-seq:
      #    XML::SaxParser.string(string)
      #
      # Creates a new parser by parsing the specified string.
      def self.string(string)
        context = XML::Parser::Context.string(string)
        self.new(context)
      end

      # :enddoc:

      def file=(value)
        warn("XML::SaxParser#file is deprecated.  Use XML::SaxParser.file instead")
        @context = XML::Parser::Context.file(value)
      end

      def io=(value)
        warn("XML::SaxParser#io is deprecated.  Use XML::SaxParser.io instead")
        @context = XML::Parser::Context.io(value)
      end

      def string=(value)
        warn("XML::SaxParser#string is deprecated.  Use XML::SaxParser.string instead")
        @context = XML::Parser::Context.string(value)
      end
    end
  end
end                                                                                                                                                                                                                                                                                 schema/                                                                                             0040755 0001750 0001750 00000000000 12612224746 042401  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    attribute.rb                                                                                        0100644 0001750 0001750 00000000362 12566211276 044731  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml/schema             # encoding: UTF-8

module LibXML
  module XML
    class Schema::Attribute
      REQUIRED = 1
      OPTIONAL = 2

      def default
        node['default']
      end

      def required?
        occurs == REQUIRED
      end

    end
  end
end
                                                                                                                                                                                                                                                                              element.rb                                                                                          0100644 0001750 0001750 00000000766 12566211276 044367  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml/schema             # encoding: UTF-8

module LibXML
  module XML
    class Schema::Element
      def required?
        !min_occurs.zero?
      end

      def array?
        max_occurs > 1
      end

      def elements
        type.elements
      end

      def annotation
        return if node.nil?
        annotations = node.children.select { |n| n.name == 'annotation' }
        annotations.map do |annotation|
          annotation.children.map(&:content).join("\n")
        end.join("\n")
      end
    end
  end
end
          type.rb                                                                                             0100644 0001750 0001750 00000001426 12566211276 043711  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml/schema             module LibXML
  module XML
    class Schema::Type
      def kind_name
        Schema::Types.constants.find { |k| Schema::Types.const_get(k) == kind }
      end

      def annotation
        return if node.nil?
        annotations = node.children.select { |n| n.name == 'annotation' }
        annotations.map do |annotation|
          annotation.children.map(&:content).join("\n")
        end.join("\n")
      end

      def annonymus_subtypes
        elements.select { |_, e| e.type.name.nil? }
      end

      def annonymus_subtypes_recursively(parent=nil)
        annonymus_subtypes.map do |element_name, e|
          [{[parent, element_name].compact.join('::') => e.type},
           e.type.annonymus_subtypes_recursively(element_name)]
        end.flatten
      end

    end
  end
end
                                                                                                                                                                                                                                          schema.rb                                                                                           0100644 0001750 0001750 00000004522 12566211276 042730  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    module LibXML
  module XML
    class Schema
      module Types
        XML_SCHEMA_TYPE_BASIC            = 1 # A built-in datatype
        XML_SCHEMA_TYPE_ANY              = 2
        XML_SCHEMA_TYPE_FACET            = 3
        XML_SCHEMA_TYPE_SIMPLE           = 4
        XML_SCHEMA_TYPE_COMPLEX          = 5
        XML_SCHEMA_TYPE_SEQUENCE         = 6
        XML_SCHEMA_TYPE_CHOICE           = 7
        XML_SCHEMA_TYPE_ALL              = 8
        XML_SCHEMA_TYPE_SIMPLE_CONTENT   = 9
        XML_SCHEMA_TYPE_COMPLEX_CONTENT  = 10
        XML_SCHEMA_TYPE_UR               = 11
        XML_SCHEMA_TYPE_RESTRICTION      = 12
        XML_SCHEMA_TYPE_EXTENSION        = 13
        XML_SCHEMA_TYPE_ELEMENT          = 14
        XML_SCHEMA_TYPE_ATTRIBUTE        = 15
        XML_SCHEMA_TYPE_ATTRIBUTEGROUP   = 16
        XML_SCHEMA_TYPE_GROUP            = 17
        XML_SCHEMA_TYPE_NOTATION         = 18
        XML_SCHEMA_TYPE_LIST             = 19
        XML_SCHEMA_TYPE_UNION            = 20
        XML_SCHEMA_TYPE_ANY_ATTRIBUTE    = 21
        XML_SCHEMA_TYPE_IDC_UNIQUE       = 22
        XML_SCHEMA_TYPE_IDC_KEY          = 23
        XML_SCHEMA_TYPE_IDC_KEYREF       = 24
        XML_SCHEMA_TYPE_PARTICLE         = 25
        XML_SCHEMA_TYPE_ATTRIBUTE_USE    = 26
        XML_SCHEMA_FACET_MININCLUSIVE    = 1000
        XML_SCHEMA_FACET_MINEXCLUSIVE    = 1001
        XML_SCHEMA_FACET_MAXINCLUSIVE    = 1002
        XML_SCHEMA_FACET_MAXEXCLUSIVE    = 1003
        XML_SCHEMA_FACET_TOTALDIGITS     = 1004
        XML_SCHEMA_FACET_FRACTIONDIGITS  = 1005
        XML_SCHEMA_FACET_PATTERN         = 1006
        XML_SCHEMA_FACET_ENUMERATION     = 1007
        XML_SCHEMA_FACET_WHITESPACE      = 1008
        XML_SCHEMA_FACET_LENGTH          = 1009
        XML_SCHEMA_FACET_MAXLENGTH       = 1010
        XML_SCHEMA_FACET_MINLENGTH       = 1011
        XML_SCHEMA_EXTRA_QNAMEREF        = 2000
        XML_SCHEMA_EXTRA_ATTR_USE_PROHIB = 2001
      end

      class Namespaces < Array
        def find_by_href(href)
          find { |n| n.href == href }
        end

        def find_by_prefix(prefix)
          find { |n| n.prefix == prefix }
        end
      end

      def namespaces
        Namespaces.new(_namespaces.uniq { |n| n.href })
      end

      def self.cached(location)
        @_schemas ||= {}
        @_schemas[location] ||= new(location)
      end
    end
  end
end                                                                                                                                                                              tree.rb                                                                                             0100644 0001750 0001750 00000001770 12566211276 042431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    class Tree # :nodoc:
      ELEMENT_NODE = Node::ELEMENT_NODE
      ATTRIBUTE_NODE = Node::ATTRIBUTE_NODE
      TEXT_NODE = Node::TEXT_NODE
      CDATA_SECTION_NODE = Node::CDATA_SECTION_NODE
      ENTITY_REF_NODE = Node::ENTITY_REF_NODE
      ENTITY_NODE = Node::ENTITY_NODE
      PI_NODE = Node::PI_NODE
      COMMENT_NODE = Node::COMMENT_NODE
      DOCUMENT_NODE = Node::DOCUMENT_NODE
      DOCUMENT_TYPE_NODE = Node::DOCUMENT_TYPE_NODE
      DOCUMENT_FRAG_NODE = Node::DOCUMENT_FRAG_NODE
      NOTATION_NODE = Node::NOTATION_NODE
      HTML_DOCUMENT_NODE = Node::HTML_DOCUMENT_NODE
      DTD_NODE = Node::DTD_NODE
      ELEMENT_DECL = Node::ELEMENT_DECL
      ATTRIBUTE_DECL = Node::ATTRIBUTE_DECL
      ENTITY_DECL = Node::ENTITY_DECL
      NAMESPACE_DECL = Node::NAMESPACE_DECL
      XINCLUDE_START = Node::XINCLUDE_START
      XINCLUDE_END = Node::XINCLUDE_END
      DOCB_DOCUMENT_NODE = Node::DOCB_DOCUMENT_NODE
    end  
  end
end        xpath_object.rb                                                                                     0100644 0001750 0001750 00000000441 12566211276 044136  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/libxml                    # encoding: UTF-8

module LibXML
  module XML
    module XPath
      class Object
        alias :size :length

        def set
          warn("XPath::Object#set is deprecated.  Simply use the XPath::Object API instead")
          self
        end
      end
    end
  end
end                                                                                                                                                                                                                               libxml.rb                                                                                           0100644 0001750 0001750 00000001453 12566211276 041470  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib                           # encoding: UTF-8

# Load the C-based binding.
begin
  RUBY_VERSION =~ /(\d+.\d+)/
  require "#{$1}/libxml_ruby"
rescue LoadError
  require "libxml_ruby"
end
# Load Ruby supporting code.
require 'libxml/error'
require 'libxml/parser'
require 'libxml/document'
require 'libxml/namespaces'
require 'libxml/namespace'
require 'libxml/node'
require 'libxml/ns'
require 'libxml/attributes'
require 'libxml/attr'
require 'libxml/attr_decl'
require 'libxml/tree'
require 'libxml/reader'
require 'libxml/html_parser'
require 'libxml/sax_parser'
require 'libxml/sax_callbacks'
require 'libxml/xpath_object'

#Schema Interface
require 'libxml/schema'
require 'libxml/schema/type'
require 'libxml/schema/element'
require 'libxml/schema/attribute'

# Deprecated
require 'libxml/properties'                                                                                                                                                                                                                     xml/                                                                                                0040755 0001750 0001750 00000000000 12612224746 040452  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib                           libxml.rb                                                                                           0100644 0001750 0001750 00000000203 12566211276 042260  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib/xml                       # encoding: UTF-8

# This is here for backward compatibility.
#
# TODO: DEPRECATE!

require 'libxml.rb'

include LibXML

                                                                                                                                                                                                                                                                                                                                                                                             xml.rb                                                                                              0100644 0001750 0001750 00000000720 12566211276 040775  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0/lib                           # encoding: UTF-8

# This file loads libxml and adds the LibXML namespace
# to the toplevel for conveneience. The end result
# is to have XML:: universally exposed.
#
# It is recommend that you only load this file for libs
# that do not have their own namespace, eg. administrative
# scripts, personal programs, etc. For other applications
# require 'libxml' instead and include LibXML into your 
# app/libs namespace.

require 'libxml'
include LibXML                                                setup.rb                                                                                            0100644 0001750 0001750 00000111563 12566211276 040577  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/libxml-ruby-2.6.0                               #
# setup.rb
#
# Copyright (c) 2000-2005 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the terms of
# the GNU LGPL, Lesser General Public License version 2.1.
#

unless Enumerable.method_defined?(:map)   # Ruby 1.4.6
  module Enumerable
    alias map collect
  end
end

unless File.respond_to?(:read)   # Ruby 1.6
  def File.read(fname)
    open(fname) {|f|
      return f.read
    }
  end
end

unless Errno.const_defined?(:ENOTEMPTY)   # Windows?
  module Errno
    class ENOTEMPTY
      # We do not raise this exception, implementation is not needed.
    end
  end
end

def File.binread(fname)
  open(fname, 'rb') {|f|
    return f.read
  }
end

# for corrupted Windows' stat(2)
def File.dir?(path)
  File.directory?((path[-1,1] == '/') ? path : path + '/')
end


class ConfigTable

  include Enumerable

  def initialize(rbconfig)
    @rbconfig = rbconfig
    @items = []
    @table = {}
    # options
    @install_prefix = nil
    @config_opt = nil
    @verbose = true
    @no_harm = false
  end

  attr_accessor :install_prefix
  attr_accessor :config_opt

  attr_writer :verbose

  def verbose?
    @verbose
  end

  attr_writer :no_harm

  def no_harm?
    @no_harm
  end

  def [](key)
    lookup(key).resolve(self)
  end

  def []=(key, val)
    lookup(key).set val
  end

  def names
    @items.map {|i| i.name }
  end

  def each(&block)
    @items.each(&block)
  end

  def key?(name)
    @table.key?(name)
  end

  def lookup(name)
    @table[name] or setup_rb_error "no such config item: #{name}"
  end

  def add(item)
    @items.push item
    @table[item.name] = item
  end

  def remove(name)
    item = lookup(name)
    @items.delete_if {|i| i.name == name }
    @table.delete_if {|name, i| i.name == name }
    item
  end

  def load_script(path, inst = nil)
    if File.file?(path)
      MetaConfigEnvironment.new(self, inst).instance_eval File.read(path), path
    end
  end

  def savefile
    '.config'
  end

  def load_savefile
    begin
      File.foreach(savefile()) do |line|
        k, v = *line.split(/=/, 2)
        self[k] = v.strip
      end
    rescue Errno::ENOENT
      setup_rb_error $!.message + "\n#{File.basename($0)} config first"
    end
  end

  def save
    @items.each {|i| i.value }
    File.open(savefile(), 'w') {|f|
      @items.each do |i|
        f.printf "%s=%s\n", i.name, i.value if i.value? and i.value
      end
    }
  end

  def load_standard_entries
    standard_entries(@rbconfig).each do |ent|
      add ent
    end
  end

  def standard_entries(rbconfig)
    c = rbconfig

    rubypath = File.join(c['bindir'], c['ruby_install_name'] + c['EXEEXT'])

    major = c['MAJOR'].to_i
    minor = c['MINOR'].to_i
    teeny = c['TEENY'].to_i
    version = "#{major}.#{minor}"

    # ruby ver. >= 1.4.4?
    newpath_p = ((major >= 2) or
                 ((major == 1) and
                  ((minor >= 5) or
                   ((minor == 4) and (teeny >= 4)))))

    if c['rubylibdir']
      # V > 1.6.3
      libruby         = "#{c['prefix']}/lib/ruby"
      librubyver      = c['rubylibdir']
      librubyverarch  = c['archdir']
      siteruby        = c['sitedir']
      siterubyver     = c['sitelibdir']
      siterubyverarch = c['sitearchdir']
    elsif newpath_p
      # 1.4.4 <= V <= 1.6.3
      libruby         = "#{c['prefix']}/lib/ruby"
      librubyver      = "#{c['prefix']}/lib/ruby/#{version}"
      librubyverarch  = "#{c['prefix']}/lib/ruby/#{version}/#{c['arch']}"
      siteruby        = c['sitedir']
      siterubyver     = "$siteruby/#{version}"
      siterubyverarch = "$siterubyver/#{c['arch']}"
    else
      # V < 1.4.4
      libruby         = "#{c['prefix']}/lib/ruby"
      librubyver      = "#{c['prefix']}/lib/ruby/#{version}"
      librubyverarch  = "#{c['prefix']}/lib/ruby/#{version}/#{c['arch']}"
      siteruby        = "#{c['prefix']}/lib/ruby/#{version}/site_ruby"
      siterubyver     = siteruby
      siterubyverarch = "$siterubyver/#{c['arch']}"
    end
    parameterize = lambda {|path|
      path.sub(/\A#{Regexp.quote(c['prefix'])}/, '$prefix')
    }

    if arg = c['configure_args'].split.detect {|arg| /--with-make-prog=/ =~ arg }
      makeprog = arg.sub(/'/, '').split(/=/, 2)[1]
    else
      makeprog = 'make'
    end

    [
      ExecItem.new('installdirs', 'std/site/home',
                   'std: install under libruby; site: install under site_ruby; home: install under $HOME')\
          {|val, table|
            case val
            when 'std'
              table['rbdir'] = '$librubyver'
              table['sodir'] = '$librubyverarch'
            when 'site'
              table['rbdir'] = '$siterubyver'
              table['sodir'] = '$siterubyverarch'
            when 'home'
              setup_rb_error '$HOME was not set' unless ENV['HOME']
              table['prefix'] = ENV['HOME']
              table['rbdir'] = '$libdir/ruby'
              table['sodir'] = '$libdir/ruby'
            end
          },
      PathItem.new('prefix', 'path', c['prefix'],
                   'path prefix of target environment'),
      PathItem.new('bindir', 'path', parameterize.call(c['bindir']),
                   'the directory for commands'),
      PathItem.new('libdir', 'path', parameterize.call(c['libdir']),
                   'the directory for libraries'),
      PathItem.new('datadir', 'path', parameterize.call(c['datadir']),
                   'the directory for shared data'),
      PathItem.new('mandir', 'path', parameterize.call(c['mandir']),
                   'the directory for man pages'),
      PathItem.new('sysconfdir', 'path', parameterize.call(c['sysconfdir']),
                   'the directory for system configuration files'),
      PathItem.new('localstatedir', 'path', parameterize.call(c['localstatedir']),
                   'the directory for local state data'),
      PathItem.new('libruby', 'path', libruby,
                   'the directory for ruby libraries'),
      PathItem.new('librubyver', 'path', librubyver,
                   'the directory for standard ruby libraries'),
      PathItem.new('librubyverarch', 'path', librubyverarch,
                   'the directory for standard ruby extensions'),
      PathItem.new('siteruby', 'path', siteruby,
          'the directory for version-independent aux ruby libraries'),
      PathItem.new('siterubyver', 'path', siterubyver,
                   'the directory for aux ruby libraries'),
      PathItem.new('siterubyverarch', 'path', siterubyverarch,
                   'the directory for aux ruby binaries'),
      PathItem.new('rbdir', 'path', '$siterubyver',
                   'the directory for ruby scripts'),
      PathItem.new('sodir', 'path', '$siterubyverarch',
                   'the directory for ruby extentions'),
      PathItem.new('rubypath', 'path', rubypath,
                   'the path to set to #! line'),
      ProgramItem.new('rubyprog', 'name', rubypath,
                      'the ruby program using for installation'),
      ProgramItem.new('makeprog', 'name', makeprog,
                      'the make program to compile ruby extentions'),
      SelectItem.new('shebang', 'all/ruby/never', 'ruby',
                     'shebang line (#!) editing mode'),
      BoolItem.new('without-ext', 'yes/no', 'no',
                   'does not compile/install ruby extentions')
    ]
  end
  private :standard_entries

  def load_multipackage_entries
    multipackage_entries().each do |ent|
      add ent
    end
  end

  def multipackage_entries
    [
      PackageSelectionItem.new('with', 'name,name...', '', 'ALL',
                               'package names that you want to install'),
      PackageSelectionItem.new('without', 'name,name...', '', 'NONE',
                               'package names that you do not want to install')
    ]
  end
  private :multipackage_entries

  ALIASES = {
    'std-ruby'         => 'librubyver',
    'stdruby'          => 'librubyver',
    'rubylibdir'       => 'librubyver',
    'archdir'          => 'librubyverarch',
    'site-ruby-common' => 'siteruby',     # For backward compatibility
    'site-ruby'        => 'siterubyver',  # For backward compatibility
    'bin-dir'          => 'bindir',
    'bin-dir'          => 'bindir',
    'rb-dir'           => 'rbdir',
    'so-dir'           => 'sodir',
    'data-dir'         => 'datadir',
    'ruby-path'        => 'rubypath',
    'ruby-prog'        => 'rubyprog',
    'ruby'             => 'rubyprog',
    'make-prog'        => 'makeprog',
    'make'             => 'makeprog'
  }

  def fixup
    ALIASES.each do |ali, name|
      @table[ali] = @table[name]
    end
    @items.freeze
    @table.freeze
    @options_re = /\A--(#{@table.keys.join('|')})(?:=(.*))?\z/
  end

  def parse_opt(opt)
    m = @options_re.match(opt) or setup_rb_error "config: unknown option #{opt}"
    m.to_a[1,2]
  end

  def dllext
    @rbconfig['DLEXT']
  end

  def value_config?(name)
    lookup(name).value?
  end

  class Item
    def initialize(name, template, default, desc)
      @name = name.freeze
      @template = template
      @value = default
      @default = default
      @description = desc
    end

    attr_reader :name
    attr_reader :description

    attr_accessor :default
    alias help_default default

    def help_opt
      "--#{@name}=#{@template}"
    end

    def value?
      true
    end

    def value
      @value
    end

    def resolve(table)
      @value.gsub(%r<\$([^/]+)>) { table[$1] }
    end

    def set(val)
      @value = check(val)
    end

    private

    def check(val)
      setup_rb_error "config: --#{name} requires argument" unless val
      val
    end
  end

  class BoolItem < Item
    def config_type
      'bool'
    end

    def help_opt
      "--#{@name}"
    end

    private

    def check(val)
      return 'yes' unless val
      case val
      when /\Ay(es)?\z/i, /\At(rue)?\z/i then 'yes'
      when /\An(o)?\z/i, /\Af(alse)\z/i  then 'no'
      else
        setup_rb_error "config: --#{@name} accepts only yes/no for argument"
      end
    end
  end

  class PathItem < Item
    def config_type
      'path'
    end

    private

    def check(path)
      setup_rb_error "config: --#{@name} requires argument"  unless path
      path[0,1] == '$' ? path : File.expand_path(path)
    end
  end

  class ProgramItem < Item
    def config_type
      'program'
    end
  end

  class SelectItem < Item
    def initialize(name, selection, default, desc)
      super
      @ok = selection.split('/')
    end

    def config_type
      'select'
    end

    private

    def check(val)
      unless @ok.include?(val.strip)
        setup_rb_error "config: use --#{@name}=#{@template} (#{val})"
      end
      val.strip
    end
  end

  class ExecItem < Item
    def initialize(name, selection, desc, &block)
      super name, selection, nil, desc
      @ok = selection.split('/')
      @action = block
    end

    def config_type
      'exec'
    end

    def value?
      false
    end

    def resolve(table)
      setup_rb_error "$#{name()} wrongly used as option value"
    end

    undef set

    def evaluate(val, table)
      v = val.strip.downcase
      unless @ok.include?(v)
        setup_rb_error "invalid option --#{@name}=#{val} (use #{@template})"
      end
      @action.call v, table
    end
  end

  class PackageSelectionItem < Item
    def initialize(name, template, default, help_default, desc)
      super name, template, default, desc
      @help_default = help_default
    end

    attr_reader :help_default

    def config_type
      'package'
    end

    private

    def check(val)
      unless File.dir?("packages/#{val}")
        setup_rb_error "config: no such package: #{val}"
      end
      val
    end
  end

  class MetaConfigEnvironment
    def initialize(config, installer)
      @config = config
      @installer = installer
    end

    def config_names
      @config.names
    end

    def config?(name)
      @config.key?(name)
    end

    def bool_config?(name)
      @config.lookup(name).config_type == 'bool'
    end

    def path_config?(name)
      @config.lookup(name).config_type == 'path'
    end

    def value_config?(name)
      @config.lookup(name).config_type != 'exec'
    end

    def add_config(item)
      @config.add item
    end

    def add_bool_config(name, default, desc)
      @config.add BoolItem.new(name, 'yes/no', default ? 'yes' : 'no', desc)
    end

    def add_path_config(name, default, desc)
      @config.add PathItem.new(name, 'path', default, desc)
    end

    def set_config_default(name, default)
      @config.lookup(name).default = default
    end

    def remove_config(name)
      @config.remove(name)
    end

    # For only multipackage
    def packages
      raise '[setup.rb fatal] multi-package metaconfig API packages() called for single-package; contact application package vendor' unless @installer
      @installer.packages
    end

    # For only multipackage
    def declare_packages(list)
      raise '[setup.rb fatal] multi-package metaconfig API declare_packages() called for single-package; contact application package vendor' unless @installer
      @installer.packages = list
    end
  end

end   # class ConfigTable


# This module requires: #verbose?, #no_harm?
module FileOperations

  def mkdir_p(dirname, prefix = nil)
    dirname = prefix + File.expand_path(dirname) if prefix
    $stderr.puts "mkdir -p #{dirname}" if verbose?
    return if no_harm?

    # Does not check '/', it's too abnormal.
    dirs = File.expand_path(dirname).split(%r<(?=/)>)
    if /\A[a-z]:\z/i =~ dirs[0]
      disk = dirs.shift
      dirs[0] = disk + dirs[0]
    end
    dirs.each_index do |idx|
      path = dirs[0..idx].join('')
      Dir.mkdir path unless File.dir?(path)
    end
  end

  def rm_f(path)
    $stderr.puts "rm -f #{path}" if verbose?
    return if no_harm?
    force_remove_file path
  end

  def rm_rf(path)
    $stderr.puts "rm -rf #{path}" if verbose?
    return if no_harm?
    remove_tree path
  end

  def remove_tree(path)
    if File.symlink?(path)
      remove_file path
    elsif File.dir?(path)
      remove_tree0 path
    else
      force_remove_file path
    end
  end

  def remove_tree0(path)
    Dir.foreach(path) do |ent|
      next if ent == '.'
      next if ent == '..'
      entpath = "#{path}/#{ent}"
      if File.symlink?(entpath)
        remove_file entpath
      elsif File.dir?(entpath)
        remove_tree0 entpath
      else
        force_remove_file entpath
      end
    end
    begin
      Dir.rmdir path
    rescue Errno::ENOTEMPTY
      # directory may not be empty
    end
  end

  def move_file(src, dest)
    force_remove_file dest
    begin
      File.rename src, dest
    rescue
      File.open(dest, 'wb') {|f|
        f.write File.binread(src)
      }
      File.chmod File.stat(src).mode, dest
      File.unlink src
    end
  end

  def force_remove_file(path)
    begin
      remove_file path
    rescue
    end
  end

  def remove_file(path)
    File.chmod 0777, path
    File.unlink path
  end

  def install(from, dest, mode, prefix = nil)
    $stderr.puts "install #{from} #{dest}" if verbose?
    return if no_harm?

    realdest = prefix ? prefix + File.expand_path(dest) : dest
    realdest = File.join(realdest, File.basename(from)) if File.dir?(realdest)
    str = File.binread(from)
    if diff?(str, realdest)
      verbose_off {
        rm_f realdest if File.exist?(realdest)
      }
      File.open(realdest, 'wb') {|f|
        f.write str
      }
      File.chmod mode, realdest

      File.open("#{objdir_root()}/InstalledFiles", 'a') {|f|
        if prefix
          f.puts realdest.sub(prefix, '')
        else
          f.puts realdest
        end
      }
    end
  end

  def diff?(new_content, path)
    return true unless File.exist?(path)
    new_content != File.binread(path)
  end

  def command(*args)
    $stderr.puts args.join(' ') if verbose?
    system(*args) or raise RuntimeError,
        "system(#{args.map{|a| a.inspect }.join(' ')}) failed"
  end

  def ruby(*args)
    command config('rubyprog'), *args
  end
  
  def make(task = nil)
    command(*[config('makeprog'), task].compact)
  end

  def extdir?(dir)
    File.exist?("#{dir}/MANIFEST") or File.exist?("#{dir}/extconf.rb")
  end

  def files_of(dir)
    Dir.open(dir) {|d|
      return d.select {|ent| File.file?("#{dir}/#{ent}") }
    }
  end

  DIR_REJECT = %w( . .. CVS SCCS RCS CVS.adm .svn )

  def directories_of(dir)
    Dir.open(dir) {|d|
      return d.select {|ent| File.dir?("#{dir}/#{ent}") } - DIR_REJECT
    }
  end

end


# This module requires: #srcdir_root, #objdir_root, #relpath
module HookScriptAPI

  def get_config(key)
    @config[key]
  end

  alias config get_config

  # obsolete: use metaconfig to change configuration
  def set_config(key, val)
    @config[key] = val
  end

  #
  # srcdir/objdir (works only in the package directory)
  #

  def curr_srcdir
    "#{srcdir_root()}/#{relpath()}"
  end

  def curr_objdir
    "#{objdir_root()}/#{relpath()}"
  end

  def srcfile(path)
    "#{curr_srcdir()}/#{path}"
  end

  def srcexist?(path)
    File.exist?(srcfile(path))
  end

  def srcdirectory?(path)
    File.dir?(srcfile(path))
  end
  
  def srcfile?(path)
    File.file?(srcfile(path))
  end

  def srcentries(path = '.')
    Dir.open("#{curr_srcdir()}/#{path}") {|d|
      return d.to_a - %w(. ..)
    }
  end

  def srcfiles(path = '.')
    srcentries(path).select {|fname|
      File.file?(File.join(curr_srcdir(), path, fname))
    }
  end

  def srcdirectories(path = '.')
    srcentries(path).select {|fname|
      File.dir?(File.join(curr_srcdir(), path, fname))
    }
  end

end


class ToplevelInstaller

  Version   = '3.4.1'
  Copyright = 'Copyright (c) 2000-2005 Minero Aoki'

  TASKS = [
    [ 'all',      'do config, setup, then install' ],
    [ 'config',   'saves your configurations' ],
    [ 'show',     'shows current configuration' ],
    [ 'setup',    'compiles ruby extentions and others' ],
    [ 'install',  'installs files' ],
    [ 'test',     'run all tests in test/' ],
    [ 'clean',    "does `make clean' for each extention" ],
    [ 'distclean',"does `make distclean' for each extention" ]
  ]

  def ToplevelInstaller.invoke
    config = ConfigTable.new(load_rbconfig())
    config.load_standard_entries
    config.load_multipackage_entries if multipackage?
    config.fixup
    klass = (multipackage?() ? ToplevelInstallerMulti : ToplevelInstaller)
    klass.new(File.dirname($0), config).invoke
  end

  def ToplevelInstaller.multipackage?
    File.dir?(File.dirname($0) + '/packages')
  end

  def ToplevelInstaller.load_rbconfig
    if arg = ARGV.detect {|arg| /\A--rbconfig=/ =~ arg }
      ARGV.delete(arg)
      load File.expand_path(arg.split(/=/, 2)[1])
      $".push 'rbconfig.rb'
    else
      require 'rbconfig'
    end
    ::Config::CONFIG
  end

  def initialize(ardir_root, config)
    @ardir = File.expand_path(ardir_root)
    @config = config
    # cache
    @valid_task_re = nil
  end

  def config(key)
    @config[key]
  end

  def inspect
    "#<#{self.class} #{__id__()}>"
  end

  def invoke
    run_metaconfigs
    case task = parsearg_global()
    when nil, 'all'
      parsearg_config
      init_installers
      exec_config
      exec_setup
      exec_install
    else
      case task
      when 'config', 'test'
        ;
      when 'clean', 'distclean'
        @config.load_savefile if File.exist?(@config.savefile)
      else
        @config.load_savefile
      end
      __send__ "parsearg_#{task}"
      init_installers
      __send__ "exec_#{task}"
    end
  end
  
  def run_metaconfigs
    @config.load_script "#{@ardir}/metaconfig"
  end

  def init_installers
    @installer = Installer.new(@config, @ardir, File.expand_path('.'))
  end

  #
  # Hook Script API bases
  #

  def srcdir_root
    @ardir
  end

  def objdir_root
    '.'
  end

  def relpath
    '.'
  end

  #
  # Option Parsing
  #

  def parsearg_global
    while arg = ARGV.shift
      case arg
      when /\A\w+\z/
        setup_rb_error "invalid task: #{arg}" unless valid_task?(arg)
        return arg
      when '-q', '--quiet'
        @config.verbose = false
      when '--verbose'
        @config.verbose = true
      when '--help'
        print_usage $stdout
        exit 0
      when '--version'
        puts "#{File.basename($0)} version #{Version}"
        exit 0
      when '--copyright'
        puts Copyright
        exit 0
      else
        setup_rb_error "unknown global option '#{arg}'"
      end
    end
    nil
  end

  def valid_task?(t)
    valid_task_re() =~ t
  end

  def valid_task_re
    @valid_task_re ||= /\A(?:#{TASKS.map {|task,desc| task }.join('|')})\z/
  end

  def parsearg_no_options
    unless ARGV.empty?
      task = caller(0).first.slice(%r<`parsearg_(\w+)'>, 1)
      setup_rb_error "#{task}: unknown options: #{ARGV.join(' ')}"
    end
  end

  alias parsearg_show       parsearg_no_options
  alias parsearg_setup      parsearg_no_options
  alias parsearg_test       parsearg_no_options
  alias parsearg_clean      parsearg_no_options
  alias parsearg_distclean  parsearg_no_options

  def parsearg_config
    evalopt = []
    set = []
    @config.config_opt = []
    while i = ARGV.shift
      if /\A--?\z/ =~ i
        @config.config_opt = ARGV.dup
        break
      end
      name, value = *@config.parse_opt(i)
      if @config.value_config?(name)
        @config[name] = value
      else
        evalopt.push [name, value]
      end
      set.push name
    end
    evalopt.each do |name, value|
      @config.lookup(name).evaluate value, @config
    end
    # Check if configuration is valid
    set.each do |n|
      @config[n] if @config.value_config?(n)
    end
  end

  def parsearg_install
    @config.no_harm = false
    @config.install_prefix = ''
    while a = ARGV.shift
      case a
      when '--no-harm'
        @config.no_harm = true
      when /\A--prefix=/
        path = a.split(/=/, 2)[1]
        path = File.expand_path(path) unless path[0,1] == '/'
        @config.install_prefix = path
      else
        setup_rb_error "install: unknown option #{a}"
      end
    end
  end

  def print_usage(out)
    out.puts 'Typical Installation Procedure:'
    out.puts "  $ ruby #{File.basename $0} config"
    out.puts "  $ ruby #{File.basename $0} setup"
    out.puts "  # ruby #{File.basename $0} install (may require root privilege)"
    out.puts
    out.puts 'Detailed Usage:'
    out.puts "  ruby #{File.basename $0} <global option>"
    out.puts "  ruby #{File.basename $0} [<global options>] <task> [<task options>]"

    fmt = "  %-24s %s\n"
    out.puts
    out.puts 'Global options:'
    out.printf fmt, '-q,--quiet',   'suppress message outputs'
    out.printf fmt, '   --verbose', 'output messages verbosely'
    out.printf fmt, '   --help',    'print this message'
    out.printf fmt, '   --version', 'print version and quit'
    out.printf fmt, '   --copyright',  'print copyright and quit'
    out.puts
    out.puts 'Tasks:'
    TASKS.each do |name, desc|
      out.printf fmt, name, desc
    end

    fmt = "  %-24s %s [%s]\n"
    out.puts
    out.puts 'Options for CONFIG or ALL:'
    @config.each do |item|
      out.printf fmt, item.help_opt, item.description, item.help_default
    end
    out.printf fmt, '--rbconfig=path', 'rbconfig.rb to load',"running ruby's"
    out.puts
    out.puts 'Options for INSTALL:'
    out.printf fmt, '--no-harm', 'only display what to do if given', 'off'
    out.printf fmt, '--prefix=path',  'install path prefix', ''
    out.puts
  end

  #
  # Task Handlers
  #

  def exec_config
    @installer.exec_config
    @config.save   # must be final
  end

  def exec_setup
    @installer.exec_setup
  end

  def exec_install
    @installer.exec_install
  end

  def exec_test
    @installer.exec_test
  end

  def exec_show
    @config.each do |i|
      printf "%-20s %s\n", i.name, i.value if i.value?
    end
  end

  def exec_clean
    @installer.exec_clean
  end

  def exec_distclean
    @installer.exec_distclean
  end

end   # class ToplevelInstaller


class ToplevelInstallerMulti < ToplevelInstaller

  include FileOperations

  def initialize(ardir_root, config)
    super
    @packages = directories_of("#{@ardir}/packages")
    raise 'no package exists' if @packages.empty?
    @root_installer = Installer.new(@config, @ardir, File.expand_path('.'))
  end

  def run_metaconfigs
    @config.load_script "#{@ardir}/metaconfig", self
    @packages.each do |name|
      @config.load_script "#{@ardir}/packages/#{name}/metaconfig"
    end
  end

  attr_reader :packages

  def packages=(list)
    raise 'package list is empty' if list.empty?
    list.each do |name|
      raise "directory packages/#{name} does not exist"\
              unless File.dir?("#{@ardir}/packages/#{name}")
    end
    @packages = list
  end

  def init_installers
    @installers = {}
    @packages.each do |pack|
      @installers[pack] = Installer.new(@config,
                                       "#{@ardir}/packages/#{pack}",
                                       "packages/#{pack}")
    end
    with    = extract_selection(config('with'))
    without = extract_selection(config('without'))
    @selected = @installers.keys.select {|name|
                  (with.empty? or with.include?(name)) \
                      and not without.include?(name)
                }
  end

  def extract_selection(list)
    a = list.split(/,/)
    a.each do |name|
      setup_rb_error "no such package: #{name}"  unless @installers.key?(name)
    end
    a
  end

  def print_usage(f)
    super
    f.puts 'Inluded packages:'
    f.puts '  ' + @packages.sort.join(' ')
    f.puts
  end

  #
  # Task Handlers
  #

  def exec_config
    run_hook 'pre-config'
    each_selected_installers {|inst| inst.exec_config }
    run_hook 'post-config'
    @config.save   # must be final
  end

  def exec_setup
    run_hook 'pre-setup'
    each_selected_installers {|inst| inst.exec_setup }
    run_hook 'post-setup'
  end

  def exec_install
    run_hook 'pre-install'
    each_selected_installers {|inst| inst.exec_install }
    run_hook 'post-install'
  end

  def exec_test
    run_hook 'pre-test'
    each_selected_installers {|inst| inst.exec_test }
    run_hook 'post-test'
  end

  def exec_clean
    rm_f @config.savefile
    run_hook 'pre-clean'
    each_selected_installers {|inst| inst.exec_clean }
    run_hook 'post-clean'
  end

  def exec_distclean
    rm_f @config.savefile
    run_hook 'pre-distclean'
    each_selected_installers {|inst| inst.exec_distclean }
    run_hook 'post-distclean'
  end

  #
  # lib
  #

  def each_selected_installers
    Dir.mkdir 'packages' unless File.dir?('packages')
    @selected.each do |pack|
      $stderr.puts "Processing the package `#{pack}' ..." if verbose?
      Dir.mkdir "packages/#{pack}" unless File.dir?("packages/#{pack}")
      Dir.chdir "packages/#{pack}"
      yield @installers[pack]
      Dir.chdir '../..'
    end
  end

  def run_hook(id)
    @root_installer.run_hook id
  end

  # module FileOperations requires this
  def verbose?
    @config.verbose?
  end

  # module FileOperations requires this
  def no_harm?
    @config.no_harm?
  end

end   # class ToplevelInstallerMulti


class Installer

  FILETYPES = %w( bin lib ext data conf man )

  include FileOperations
  include HookScriptAPI

  def initialize(config, srcroot, objroot)
    @config = config
    @srcdir = File.expand_path(srcroot)
    @objdir = File.expand_path(objroot)
    @currdir = '.'
  end

  def inspect
    "#<#{self.class} #{File.basename(@srcdir)}>"
  end

  def noop(rel)
  end

  #
  # Hook Script API base methods
  #

  def srcdir_root
    @srcdir
  end

  def objdir_root
    @objdir
  end

  def relpath
    @currdir
  end

  #
  # Config Access
  #

  # module FileOperations requires this
  def verbose?
    @config.verbose?
  end

  # module FileOperations requires this
  def no_harm?
    @config.no_harm?
  end

  def verbose_off
    begin
      save, @config.verbose = @config.verbose?, false
      yield
    ensure
      @config.verbose = save
    end
  end

  #
  # TASK config
  #

  def exec_config
    exec_task_traverse 'config'
  end

  alias config_dir_bin noop
  alias config_dir_lib noop

  def config_dir_ext(rel)
    extconf if extdir?(curr_srcdir())
  end

  alias config_dir_data noop
  alias config_dir_conf noop
  alias config_dir_man noop

  def extconf
    ruby "#{curr_srcdir()}/extconf.rb", *@config.config_opt
  end

  #
  # TASK setup
  #

  def exec_setup
    exec_task_traverse 'setup'
  end

  def setup_dir_bin(rel)
    files_of(curr_srcdir()).each do |fname|
      update_shebang_line "#{curr_srcdir()}/#{fname}"
    end
  end

  alias setup_dir_lib noop

  def setup_dir_ext(rel)
    make if extdir?(curr_srcdir())
  end

  alias setup_dir_data noop
  alias setup_dir_conf noop
  alias setup_dir_man noop

  def update_shebang_line(path)
    return if no_harm?
    return if config('shebang') == 'never'
    old = Shebang.load(path)
    if old
      $stderr.puts "warning: #{path}: Shebang line includes too many args.  It is not portable and your program may not work." if old.args.size > 1
      new = new_shebang(old)
      return if new.to_s == old.to_s
    else
      return unless config('shebang') == 'all'
      new = Shebang.new(config('rubypath'))
    end
    $stderr.puts "updating shebang: #{File.basename(path)}" if verbose?
    open_atomic_writer(path) {|output|
      File.open(path, 'rb') {|f|
        f.gets if old   # discard
        output.puts new.to_s
        output.print f.read
      }
    }
  end

  def new_shebang(old)
    if /\Aruby/ =~ File.basename(old.cmd)
      Shebang.new(config('rubypath'), old.args)
    elsif File.basename(old.cmd) == 'env' and old.args.first == 'ruby'
      Shebang.new(config('rubypath'), old.args[1..-1])
    else
      return old unless config('shebang') == 'all'
      Shebang.new(config('rubypath'))
    end
  end

  def open_atomic_writer(path, &block)
    tmpfile = File.basename(path) + '.tmp'
    begin
      File.open(tmpfile, 'wb', &block)
      File.rename tmpfile, File.basename(path)
    ensure
      File.unlink tmpfile if File.exist?(tmpfile)
    end
  end

  class Shebang
    def Shebang.load(path)
      line = nil
      File.open(path) {|f|
        line = f.gets
      }
      return nil unless /\A#!/ =~ line
      parse(line)
    end

    def Shebang.parse(line)
      cmd, *args = *line.strip.sub(/\A\#!/, '').split(' ')
      new(cmd, args)
    end

    def initialize(cmd, args = [])
      @cmd = cmd
      @args = args
    end

    attr_reader :cmd
    attr_reader :args

    def to_s
      "#! #{@cmd}" + (@args.empty? ? '' : " #{@args.join(' ')}")
    end
  end

  #
  # TASK install
  #

  def exec_install
    rm_f 'InstalledFiles'
    exec_task_traverse 'install'
  end

  def install_dir_bin(rel)
    install_files targetfiles(), "#{config('bindir')}/#{rel}", 0755
  end

  def install_dir_lib(rel)
    install_files libfiles(), "#{config('rbdir')}/#{rel}", 0644
  end

  def install_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    install_files rubyextentions('.'),
                  "#{config('sodir')}/#{File.dirname(rel)}",
                  0555
  end

  def install_dir_data(rel)
    install_files targetfiles(), "#{config('datadir')}/#{rel}", 0644
  end

  def install_dir_conf(rel)
    # FIXME: should not remove current config files
    # (rename previous file to .old/.org)
    install_files targetfiles(), "#{config('sysconfdir')}/#{rel}", 0644
  end

  def install_dir_man(rel)
    install_files targetfiles(), "#{config('mandir')}/#{rel}", 0644
  end

  def install_files(list, dest, mode)
    mkdir_p dest, @config.install_prefix
    list.each do |fname|
      install fname, dest, mode, @config.install_prefix
    end
  end

  def libfiles
    glob_reject(%w(*.y *.output), targetfiles())
  end

  def rubyextentions(dir)
    ents = glob_select("*.#{@config.dllext}", targetfiles())
    if ents.empty?
      setup_rb_error "no ruby extention exists: 'ruby #{$0} setup' first"
    end
    ents
  end

  def targetfiles
    mapdir(existfiles() - hookfiles())
  end

  def mapdir(ents)
    ents.map {|ent|
      if File.exist?(ent)
      then ent                         # objdir
      else "#{curr_srcdir()}/#{ent}"   # srcdir
      end
    }
  end

  # picked up many entries from cvs-1.11.1/src/ignore.c
  JUNK_FILES = %w( 
    core RCSLOG tags TAGS .make.state
    .nse_depinfo #* .#* cvslog.* ,* .del-* *.olb
    *~ *.old *.bak *.BAK *.orig *.rej _$* *$

    *.org *.in .*
  )

  def existfiles
    glob_reject(JUNK_FILES, (files_of(curr_srcdir()) | files_of('.')))
  end

  def hookfiles
    %w( pre-%s post-%s pre-%s.rb post-%s.rb ).map {|fmt|
      %w( config setup install clean ).map {|t| sprintf(fmt, t) }
    }.flatten
  end

  def glob_select(pat, ents)
    re = globs2re([pat])
    ents.select {|ent| re =~ ent }
  end

  def glob_reject(pats, ents)
    re = globs2re(pats)
    ents.reject {|ent| re =~ ent }
  end

  GLOB2REGEX = {
    '.' => '\.',
    '$' => '\$',
    '#' => '\#',
    '*' => '.*'
  }

  def globs2re(pats)
    /\A(?:#{
      pats.map {|pat| pat.gsub(/[\.\$\#\*]/) {|ch| GLOB2REGEX[ch] } }.join('|')
    })\z/
  end

  #
  # TASK test
  #

  TESTDIR = 'test'

  def exec_test
    unless File.directory?('test')
      $stderr.puts 'no test in this package' if verbose?
      return
    end
    $stderr.puts 'Running tests...' if verbose?
    begin
      require 'test/unit'
    rescue LoadError
      setup_rb_error 'test/unit cannot loaded.  You need Ruby 1.8 or later to invoke this task.'
    end
    runner = Test::Unit::AutoRunner.new(true)
    runner.to_run << TESTDIR
    runner.run
  end

  #
  # TASK clean
  #

  def exec_clean
    exec_task_traverse 'clean'
    rm_f @config.savefile
    rm_f 'InstalledFiles'
  end

  alias clean_dir_bin noop
  alias clean_dir_lib noop
  alias clean_dir_data noop
  alias clean_dir_conf noop
  alias clean_dir_man noop

  def clean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'clean' if File.file?('Makefile')
  end

  #
  # TASK distclean
  #

  def exec_distclean
    exec_task_traverse 'distclean'
    rm_f @config.savefile
    rm_f 'InstalledFiles'
  end

  alias distclean_dir_bin noop
  alias distclean_dir_lib noop

  def distclean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'distclean' if File.file?('Makefile')
  end

  alias distclean_dir_data noop
  alias distclean_dir_conf noop
  alias distclean_dir_man noop

  #
  # Traversing
  #

  def exec_task_traverse(task)
    run_hook "pre-#{task}"
    FILETYPES.each do |type|
      if type == 'ext' and config('without-ext') == 'yes'
        $stderr.puts 'skipping ext/* by user option' if verbose?
        next
      end
      traverse task, type, "#{task}_dir_#{type}"
    end
    run_hook "post-#{task}"
  end

  def traverse(task, rel, mid)
    dive_into(rel) {
      run_hook "pre-#{task}"
      __send__ mid, rel.sub(%r[\A.*?(?:/|\z)], '')
      directories_of(curr_srcdir()).each do |d|
        traverse task, "#{rel}/#{d}", mid
      end
      run_hook "post-#{task}"
    }
  end

  def dive_into(rel)
    return unless File.dir?("#{@srcdir}/#{rel}")

    dir = File.basename(rel)
    Dir.mkdir dir unless File.dir?(dir)
    prevdir = Dir.pwd
    Dir.chdir dir
    $stderr.puts '---> ' + rel if verbose?
    @currdir = rel
    yield
    Dir.chdir prevdir
    $stderr.puts '<--- ' + rel if verbose?
    @currdir = File.dirname(rel)
  end

  def run_hook(id)
    path = [ "#{curr_srcdir()}/#{id}",
             "#{curr_srcdir()}/#{id}.rb" ].detect {|cand| File.file?(cand) }
    return unless path
    begin
      instance_eval File.read(path), path, 1
    rescue
      raise if $DEBUG
      setup_rb_error "hook #{path} failed:\n" + $!.message
    end
  end

end   # class Installer


class SetupError < StandardError; end

def setup_rb_error(msg)
  raise SetupError, msg
end

if $0 == __FILE__
  begin
    ToplevelInstaller.invoke
  rescue SetupError
    raise if $DEBUG
    $stderr.puts $!.message
    $stderr.puts "Try 'ruby #{$0} --help' for detailed usage."
    exit 1
  end
end
                                                                                                                                             nokogiri-1.5.6/                                                                                     0040755 0001750 0001750 00000000000 12612224746 036463  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems                                                 ext/                                                                                                0040755 0001750 0001750 00000000000 12612224746 037263  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6                                  nokogiri/                                                                                           0040755 0001750 0001750 00000000000 12612224746 041104  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext                              extconf.rb                                                                                          0100644 0001750 0001750 00000010470 12566211316 043073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     ENV['RC_ARCHS'] = '' if RUBY_PLATFORM =~ /darwin/

# :stopdoc:

require 'mkmf'

RbConfig::MAKEFILE_CONFIG['CC'] = ENV['CC'] if ENV['CC']

ROOT = File.expand_path(File.join(File.dirname(__FILE__), '..', '..'))
LIBDIR = RbConfig::CONFIG['libdir']
INCLUDEDIR = RbConfig::CONFIG['includedir']

if defined?(RUBY_ENGINE) && RUBY_ENGINE == 'macruby'
  $LIBRUBYARG_STATIC.gsub!(/-static/, '')
end

$CFLAGS << " #{ENV["CFLAGS"]}"
$LIBS << " #{ENV["LIBS"]}"

if RbConfig::CONFIG['target_os'] == 'mingw32' || RbConfig::CONFIG['target_os'] =~ /mswin/
  $CFLAGS << " -DXP_WIN -DXP_WIN32 -DUSE_INCLUDED_VASPRINTF"
elsif RbConfig::CONFIG['target_os'] =~ /solaris/
  $CFLAGS << " -DUSE_INCLUDED_VASPRINTF"
else
  $CFLAGS << " -g -DXP_UNIX"
end

if RbConfig::MAKEFILE_CONFIG['CC'] =~ /mingw/
  $CFLAGS << " -DIN_LIBXML"
  $LIBS << " -lz" # TODO why is this necessary?
end

if RbConfig::MAKEFILE_CONFIG['CC'] =~ /gcc/
  $CFLAGS << " -O3" unless $CFLAGS[/-O\d/]
  $CFLAGS << " -Wall -Wcast-qual -Wwrite-strings -Wconversion -Wmissing-noreturn -Winline"
end

if RbConfig::CONFIG['target_os'] =~ /mswin/
  lib_prefix = 'lib'

  # There's no default include/lib dir on Windows. Let's just add the Ruby ones
  # and resort on the search path specified by INCLUDE and LIB environment
  # variables
  HEADER_DIRS = [INCLUDEDIR]
  LIB_DIRS = [LIBDIR]
  XML2_HEADER_DIRS = [File.join(INCLUDEDIR, "libxml2"), INCLUDEDIR]

else
  lib_prefix = ''

  HEADER_DIRS = [
    # First search /opt/local for macports
    '/opt/local/include',

    # Then search /usr/local for people that installed from source
    '/usr/local/include',

    # Check the ruby install locations
    INCLUDEDIR,

    # Finally fall back to /usr
    '/usr/include',
    '/usr/include/libxml2',
  ]

  LIB_DIRS = [
    # First search /opt/local for macports
    '/opt/local/lib',

    # Then search /usr/local for people that installed from source
    '/usr/local/lib',

    # Check the ruby install locations
    LIBDIR,

    # Finally fall back to /usr
    '/usr/lib',
  ]

  XML2_HEADER_DIRS = [
    '/opt/local/include/libxml2',
    '/usr/local/include/libxml2',
    File.join(INCLUDEDIR, "libxml2")
  ] + HEADER_DIRS

  # If the user has homebrew installed, use the libxml2 inside homebrew
  brew_prefix = `brew --prefix libxml2 2> /dev/null`.chomp
  unless brew_prefix.empty?
    LIB_DIRS.unshift File.join(brew_prefix, 'lib')
    XML2_HEADER_DIRS.unshift File.join(brew_prefix, 'include/libxml2')
  end
end

dir_config('zlib', HEADER_DIRS, LIB_DIRS)
dir_config('iconv', HEADER_DIRS, LIB_DIRS)
dir_config('xml2', XML2_HEADER_DIRS, LIB_DIRS)
dir_config('xslt', HEADER_DIRS, LIB_DIRS)

def asplode(lib)
  abort "-----\n#{lib} is missing.  please visit http://nokogiri.org/tutorials/installing_nokogiri.html for help with installing dependencies.\n-----"
end

pkg_config('libxslt')
pkg_config('libxml-2.0')
pkg_config('libiconv')

def have_iconv?
  %w{ iconv_open libiconv_open }.any? do |method|
    have_func(method, 'iconv.h') or
      have_library('iconv', method, 'iconv.h') or
      find_library('iconv', method, 'iconv.h')
  end
end

asplode "libxml2"  unless find_header('libxml/parser.h')
asplode "libxslt"  unless find_header('libxslt/xslt.h')
asplode "libexslt" unless find_header('libexslt/exslt.h')
asplode "libiconv" unless have_iconv?
asplode "libxml2"  unless find_library("#{lib_prefix}xml2", 'xmlParseDoc')
asplode "libxslt"  unless find_library("#{lib_prefix}xslt", 'xsltParseStylesheetDoc')
asplode "libexslt" unless find_library("#{lib_prefix}exslt", 'exsltFuncRegister')

unless have_func('xmlHasFeature')
  abort "-----\nThe function 'xmlHasFeature' is missing from your installation of libxml2.  Likely this means that your installed version of libxml2 is old enough that nokogiri will not work well.  To get around this problem, please upgrade your installation of libxml2.

Please visit http://nokogiri.org/tutorials/installing_nokogiri.html for more help!"
end

have_func 'xmlFirstElementChild'
have_func('xmlRelaxNGSetParserStructuredErrors')
have_func('xmlRelaxNGSetParserStructuredErrors')
have_func('xmlRelaxNGSetValidStructuredErrors')
have_func('xmlSchemaSetValidStructuredErrors')
have_func('xmlSchemaSetParserStructuredErrors')

if ENV['CPUPROFILE']
  unless find_library('profiler', 'ProfilerEnable', *LIB_DIRS)
    abort "google performance tools are not installed"
  end
end

create_makefile('nokogiri/nokogiri')
# :startdoc:
                                                                                                                                                                                                        html_document.c                                                                                     0100644 0001750 0001750 00000010650 12566211316 044106  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <html_document.h>

static ID id_encoding_found;

/*
 * call-seq:
 *  new
 *
 * Create a new document
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  VALUE uri, external_id, rest, rb_doc;
  htmlDocPtr doc;

  rb_scan_args(argc, argv, "0*", &rest);
  uri         = rb_ary_entry(rest, (long)0);
  external_id = rb_ary_entry(rest, (long)1);

  doc = htmlNewDoc(
      RTEST(uri) ? (const xmlChar *)StringValuePtr(uri) : NULL,
      RTEST(external_id) ? (const xmlChar *)StringValuePtr(external_id) : NULL
  );
  rb_doc = Nokogiri_wrap_xml_document(klass, doc);
  rb_obj_call_init(rb_doc, argc, argv);
  return rb_doc ;
}

/*
 * call-seq:
 *  read_io(io, url, encoding, options)
 *
 * Read the HTML document from +io+ with given +url+, +encoding+,
 * and +options+.  See Nokogiri::HTML.parse
 */
static VALUE read_io( VALUE klass,
                      VALUE io,
                      VALUE url,
                      VALUE encoding,
                      VALUE options )
{
  const char * c_url    = NIL_P(url)      ? NULL : StringValuePtr(url);
  const char * c_enc    = NIL_P(encoding) ? NULL : StringValuePtr(encoding);
  VALUE error_list      = rb_ary_new();
  VALUE document;
  htmlDocPtr doc;

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  doc = htmlReadIO(
      io_read_callback,
      io_close_callback,
      (void *)io,
      c_url,
      c_enc,
      (int)NUM2INT(options)
  );
  xmlSetStructuredErrorFunc(NULL, NULL);

  /*
   * If EncodingFound has occurred in EncodingReader, make sure to do
   * a cleanup and propagate the error.
   */
  if (rb_respond_to(io, id_encoding_found)) {
    VALUE encoding_found = rb_funcall(io, id_encoding_found, 0);
    if (!NIL_P(encoding_found)) {
      xmlFreeDoc(doc);
      rb_exc_raise(encoding_found);
    }
  }

  if(doc == NULL) {
    xmlErrorPtr error;

    xmlFreeDoc(doc);

    error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  document = Nokogiri_wrap_xml_document(klass, doc);
  rb_iv_set(document, "@errors", error_list);
  return document;
}

/*
 * call-seq:
 *  read_memory(string, url, encoding, options)
 *
 * Read the HTML document contained in +string+ with given +url+, +encoding+,
 * and +options+.  See Nokogiri::HTML.parse
 */
static VALUE read_memory( VALUE klass,
                          VALUE string,
                          VALUE url,
                          VALUE encoding,
                          VALUE options )
{
  const char * c_buffer = StringValuePtr(string);
  const char * c_url    = NIL_P(url)      ? NULL : StringValuePtr(url);
  const char * c_enc    = NIL_P(encoding) ? NULL : StringValuePtr(encoding);
  int len               = (int)RSTRING_LEN(string);
  VALUE error_list      = rb_ary_new();
  VALUE document;
  htmlDocPtr doc;

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  doc = htmlReadMemory(c_buffer, len, c_url, c_enc, (int)NUM2INT(options));
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlErrorPtr error;

    xmlFreeDoc(doc);

    error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  document = Nokogiri_wrap_xml_document(klass, doc);
  rb_iv_set(document, "@errors", error_list);
  return document;
}

/*
 * call-seq:
 *  type
 *
 * The type for this document
 */
static VALUE type(VALUE self)
{
  htmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);
  return INT2NUM((long)doc->type);
}

VALUE cNokogiriHtmlDocument ;
void init_html_document()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE html      = rb_define_module_under(nokogiri, "HTML");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE node      = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE xml_doc   = rb_define_class_under(xml, "Document", node);
  VALUE klass     = rb_define_class_under(html, "Document", xml_doc);

  cNokogiriHtmlDocument = klass;

  rb_define_singleton_method(klass, "read_memory", read_memory, 4);
  rb_define_singleton_method(klass, "read_io", read_io, 4);
  rb_define_singleton_method(klass, "new", new, -1);

  rb_define_method(klass, "type", type, 0);

  id_encoding_found = rb_intern("encoding_found");
}
                                                                                        html_document.h                                                                                     0100644 0001750 0001750 00000000237 12566211316 044113  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_HTML_DOCUMENT
#define NOKOGIRI_HTML_DOCUMENT

#include <nokogiri.h>

void init_html_document();

extern VALUE cNokogiriHtmlDocument ;

#endif
                                                                                                                                                                                                                                                                                                                                                                 html_element_description.c                                                                          0100644 0001750 0001750 00000013330 12566211316 046322  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <html_element_description.h>

/*
 * call-seq:
 *  required_attributes
 *
 * A list of required attributes for this element
 */
static VALUE required_attributes(VALUE self)
{
  htmlElemDesc * description;
  VALUE list;
  int i;

  Data_Get_Struct(self, htmlElemDesc, description);

  list = rb_ary_new();

  if(NULL == description->attrs_req) return list;

  for(i = 0; description->attrs_depr[i]; i++) {
    rb_ary_push(list, NOKOGIRI_STR_NEW2(description->attrs_req[i]));
  }

  return list;
}

/*
 * call-seq:
 *  deprecated_attributes
 *
 * A list of deprecated attributes for this element
 */
static VALUE deprecated_attributes(VALUE self)
{
  htmlElemDesc * description;
  VALUE list;
  int i;

  Data_Get_Struct(self, htmlElemDesc, description);

  list = rb_ary_new();

  if(NULL == description->attrs_depr) return list;

  for(i = 0; description->attrs_depr[i]; i++) {
    rb_ary_push(list, NOKOGIRI_STR_NEW2(description->attrs_depr[i]));
  }

  return list;
}

/*
 * call-seq:
 *  optional_attributes
 *
 * A list of optional attributes for this element
 */
static VALUE optional_attributes(VALUE self)
{
  htmlElemDesc * description;
  VALUE list;
  int i;

  Data_Get_Struct(self, htmlElemDesc, description);

  list = rb_ary_new();

  if(NULL == description->attrs_opt) return list;

  for(i = 0; description->attrs_opt[i]; i++) {
    rb_ary_push(list, NOKOGIRI_STR_NEW2(description->attrs_opt[i]));
  }

  return list;
}

/*
 * call-seq:
 *  default_sub_element
 *
 * The default sub element for this element
 */
static VALUE default_sub_element(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  return NOKOGIRI_STR_NEW2(description->defaultsubelt);
}

/*
 * call-seq:
 *  sub_elements
 *
 * A list of allowed sub elements for this element.
 */
static VALUE sub_elements(VALUE self)
{
  htmlElemDesc * description;
  VALUE list;
  int i;

  Data_Get_Struct(self, htmlElemDesc, description);

  list = rb_ary_new();

  if(NULL == description->subelts) return list;

  for(i = 0; description->subelts[i]; i++) {
    rb_ary_push(list, NOKOGIRI_STR_NEW2(description->subelts[i]));
  }

  return list;
}

/*
 * call-seq:
 *  description
 *
 * The description for this element
 */
static VALUE description(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  return NOKOGIRI_STR_NEW2(description->desc);
}

/*
 * call-seq:
 *  inline?
 *
 * Is this element an inline element?
 */
static VALUE inline_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->isinline) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  deprecated?
 *
 * Is this element deprecated?
 */
static VALUE deprecated_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->depr) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  empty?
 *
 * Is this an empty element?
 */
static VALUE empty_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->empty) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  save_end_tag?
 *
 * Should the end tag be saved?
 */
static VALUE save_end_tag_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->saveEndTag) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  implied_end_tag?
 *
 * Can the end tag be implied for this tag?
 */
static VALUE implied_end_tag_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->endTag) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  implied_start_tag?
 *
 * Can the start tag be implied for this tag?
 */
static VALUE implied_start_tag_eh(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(description->startTag) return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  name
 *
 * Get the tag name for this ElemementDescription
 */
static VALUE name(VALUE self)
{
  htmlElemDesc * description;
  Data_Get_Struct(self, htmlElemDesc, description);

  if(NULL == description->name) return Qnil;
  return NOKOGIRI_STR_NEW2(description->name);
}

/*
 * call-seq:
 *  [](tag_name)
 *
 * Get ElemementDescription for +tag_name+
 */
static VALUE get_description(VALUE klass, VALUE tag_name)
{
  const htmlElemDesc * description = htmlTagLookup(
      (const xmlChar *)StringValuePtr(tag_name)
  );

  if(NULL == description) return Qnil;
  return Data_Wrap_Struct(klass, 0, 0, (void *)description);
}

VALUE cNokogiriHtmlElementDescription ;
void init_html_element_description()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE html     = rb_define_module_under(nokogiri, "HTML");
  VALUE klass    = rb_define_class_under(html, "ElementDescription",rb_cObject);

  cNokogiriHtmlElementDescription = klass;

  rb_define_singleton_method(klass, "[]", get_description, 1);

  rb_define_method(klass, "name", name, 0);
  rb_define_method(klass, "implied_start_tag?", implied_start_tag_eh, 0);
  rb_define_method(klass, "implied_end_tag?", implied_end_tag_eh, 0);
  rb_define_method(klass, "save_end_tag?", save_end_tag_eh, 0);
  rb_define_method(klass, "empty?", empty_eh, 0);
  rb_define_method(klass, "deprecated?", deprecated_eh, 0);
  rb_define_method(klass, "inline?", inline_eh, 0);
  rb_define_method(klass, "description", description, 0);
  rb_define_method(klass, "sub_elements", sub_elements, 0);
  rb_define_method(klass, "default_sub_element", default_sub_element, 0);
  rb_define_method(klass, "optional_attributes", optional_attributes, 0);
  rb_define_method(klass, "deprecated_attributes", deprecated_attributes, 0);
  rb_define_method(klass, "required_attributes", required_attributes, 0);
}
                                                                                                                                                                                                                                                                                                        html_element_description.h                                                                          0100644 0001750 0001750 00000000312 12566211316 046323  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_HTML_ELEMENT_DESCRIPTION
#define NOKOGIRI_HTML_ELEMENT_DESCRIPTION

#include <nokogiri.h>

void init_html_element_description();

extern VALUE cNokogiriHtmlElementDescription ;

#endif
                                                                                                                                                                                                                                                                                                                      html_entity_lookup.c                                                                                0100644 0001750 0001750 00000001454 12566211316 045177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <html_entity_lookup.h>

/*
 * call-seq:
 *  get(key)
 *
 * Get the HTML::EntityDescription for +key+
 */
static VALUE get(VALUE self, VALUE key)
{
  const htmlEntityDesc * desc =
    htmlEntityLookup((const xmlChar *)StringValuePtr(key));
  VALUE klass, args[3];

  if(NULL == desc) return Qnil;
  klass = rb_const_get(mNokogiriHtml, rb_intern("EntityDescription"));

  args[0] = INT2NUM((long)desc->value);
  args[1] = NOKOGIRI_STR_NEW2(desc->name);
  args[2] = NOKOGIRI_STR_NEW2(desc->desc);

  return rb_class_new_instance(3, args, klass);
}

void init_html_entity_lookup()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE html = rb_define_module_under(nokogiri, "HTML");
  VALUE klass = rb_define_class_under(html, "EntityLookup", rb_cObject);

  rb_define_method(klass, "get", get, 1);
}
                                                                                                                                                                                                                    html_entity_lookup.h                                                                                0100644 0001750 0001750 00000000210 12566211316 045171  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_HTML_ENTITY_LOOKUP
#define NOKOGIRI_HTML_ENTITY_LOOKUP

#include <nokogiri.h>

void init_html_entity_lookup();

#endif
                                                                                                                                                                                                                                                                                                                                                                                        html_sax_parser_context.c                                                                           0100644 0001750 0001750 00000006003 12566211316 046200  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <html_sax_parser_context.h>

VALUE cNokogiriHtmlSaxParserContext ;

static void deallocate(xmlParserCtxtPtr ctxt)
{
  NOKOGIRI_DEBUG_START(handler);

  ctxt->sax = NULL;

  htmlFreeParserCtxt(ctxt);

  NOKOGIRI_DEBUG_END(handler);
}

static VALUE
parse_memory(VALUE klass, VALUE data, VALUE encoding)
{
    htmlParserCtxtPtr ctxt;

    if (NIL_P(data))
	rb_raise(rb_eArgError, "data cannot be nil");
    if (!(int)RSTRING_LEN(data))
	rb_raise(rb_eRuntimeError, "data cannot be empty");

    ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),
				      (int)RSTRING_LEN(data));
    if (ctxt->sax) {
	xmlFree(ctxt->sax);
	ctxt->sax = NULL;
    }

    if (RTEST(encoding)) {
	xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValuePtr(encoding));
	if (enc != NULL) {
	    xmlSwitchToEncoding(ctxt, enc);
	    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
		rb_raise(rb_eRuntimeError, "Unsupported encoding %s",
			 StringValuePtr(encoding));
	    }
	}
    }

    return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

static VALUE parse_file(VALUE klass, VALUE filename, VALUE encoding)
{
  htmlParserCtxtPtr ctxt = htmlCreateFileParserCtxt(
      StringValuePtr(filename),
      StringValuePtr(encoding)
  );
  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

static VALUE
parse_doc(VALUE ctxt_val)
{
    htmlParserCtxtPtr ctxt = (htmlParserCtxtPtr)ctxt_val;
    htmlParseDocument(ctxt);
    return Qnil;
}

static VALUE
parse_doc_finalize(VALUE ctxt_val)
{
    htmlParserCtxtPtr ctxt = (htmlParserCtxtPtr)ctxt_val;

    if (ctxt->myDoc)
	xmlFreeDoc(ctxt->myDoc);

    NOKOGIRI_SAX_TUPLE_DESTROY(ctxt->userData);
    return Qnil;
}

static VALUE
parse_with(VALUE self, VALUE sax_handler)
{
    htmlParserCtxtPtr ctxt;
    htmlSAXHandlerPtr sax;

    if (!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser))
	rb_raise(rb_eArgError, "argument must be a Nokogiri::XML::SAX::Parser");

    Data_Get_Struct(self, htmlParserCtxt, ctxt);
    Data_Get_Struct(sax_handler, htmlSAXHandler, sax);

    /* Free the sax handler since we'll assign our own */
    if (ctxt->sax && ctxt->sax != (xmlSAXHandlerPtr)&xmlDefaultSAXHandler)
	xmlFree(ctxt->sax);

    ctxt->sax = sax;
    ctxt->userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);

    rb_ensure(parse_doc, (VALUE)ctxt, parse_doc_finalize, (VALUE)ctxt);

    return self;
}

void init_html_sax_parser_context()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE html      = rb_define_module_under(nokogiri, "HTML");
  VALUE sax       = rb_define_module_under(xml, "SAX");
  VALUE hsax      = rb_define_module_under(html, "SAX");
  VALUE pc        = rb_define_class_under(sax, "ParserContext", rb_cObject);
  VALUE klass     = rb_define_class_under(hsax, "ParserContext", pc);

  cNokogiriHtmlSaxParserContext = klass;

  rb_define_singleton_method(klass, "memory", parse_memory, 2);
  rb_define_singleton_method(klass, "file", parse_file, 2);

  rb_define_method(klass, "parse_with", parse_with, 1);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             html_sax_parser_context.h                                                                           0100644 0001750 0001750 00000000305 12566211316 046204  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_HTML_SAX_PARSER_CONTEXT
#define NOKOGIRI_HTML_SAX_PARSER_CONTEXT

#include <nokogiri.h>

extern VALUE cNokogiriHtmlSaxParserContext;

void init_html_sax_parser_context();

#endif

                                                                                                                                                                                                                                                                                                                           html_sax_push_parser.c                                                                              0100644 0001750 0001750 00000004175 12566211316 045503  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <html_sax_push_parser.h>

/*
 * call-seq:
 *  native_write(chunk, last_chunk)
 *
 * Write +chunk+ to PushParser. +last_chunk+ triggers the end_document handle
 */
static VALUE native_write(VALUE self, VALUE _chunk, VALUE _last_chunk)
{
  xmlParserCtxtPtr ctx;
  const char * chunk  = NULL;
  int size            = 0;


  Data_Get_Struct(self, xmlParserCtxt, ctx);

  if(Qnil != _chunk) {
    chunk = StringValuePtr(_chunk);
    size = (int)RSTRING_LEN(_chunk);
  }

  if(htmlParseChunk(ctx, chunk, size, Qtrue == _last_chunk ? 1 : 0)) {
    if (!(ctx->options & XML_PARSE_RECOVER)) {
      xmlErrorPtr e = xmlCtxtGetLastError(ctx);
      Nokogiri_error_raise(NULL, e);
    }
  }

  return self;
}

/*
 * call-seq:
 *  initialize_native(xml_sax, filename)
 *
 * Initialize the push parser with +xml_sax+ using +filename+
 */
static VALUE initialize_native(VALUE self, VALUE _xml_sax, VALUE _filename,
			       VALUE encoding)
{
  htmlSAXHandlerPtr sax;
  const char * filename = NULL;
  htmlParserCtxtPtr ctx;
  xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;

  Data_Get_Struct(_xml_sax, xmlSAXHandler, sax);

  if(_filename != Qnil) filename = StringValuePtr(_filename);

  if (!NIL_P(encoding)) {
    enc = xmlParseCharEncoding(StringValuePtr(encoding));
    if (enc == XML_CHAR_ENCODING_ERROR)
      rb_raise(rb_eArgError, "Unsupported Encoding");
  }

  ctx = htmlCreatePushParserCtxt(
      sax,
      NULL,
      NULL,
      0,
      filename,
      enc
  );
  if(ctx == NULL)
    rb_raise(rb_eRuntimeError, "Could not create a parser context");

  ctx->userData = NOKOGIRI_SAX_TUPLE_NEW(ctx, self);

  ctx->sax2 = 1;
  DATA_PTR(self) = ctx;
  return self;
}

VALUE cNokogiriHtmlSaxPushParser;
void init_html_sax_push_parser()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE html = rb_define_module_under(nokogiri, "HTML");
  VALUE sax = rb_define_module_under(html, "SAX");
  VALUE klass = rb_define_class_under(sax, "PushParser", cNokogiriXmlSaxPushParser);

  cNokogiriHtmlSaxPushParser = klass;

  rb_define_private_method(klass, "initialize_native", initialize_native, 3);
  rb_define_private_method(klass, "native_write", native_write, 2);
}
                                                                                                                                                                                                                                                                                                                                                                                                   html_sax_push_parser.h                                                                              0100644 0001750 0001750 00000000270 12566211316 045500  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_HTML_SAX_PUSH_PARSER
#define NOKOGIRI_HTML_SAX_PUSH_PARSER

#include <nokogiri.h>

void init_html_sax_push_parser();

extern VALUE cNokogiriHtmlSaxPushParser ;
#endif
                                                                                                                                                                                                                                                                                                                                        nokogiri.c                                                                                          0100644 0001750 0001750 00000006374 12566211316 043075  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <nokogiri.h>

VALUE mNokogiri ;
VALUE mNokogiriXml ;
VALUE mNokogiriHtml ;
VALUE mNokogiriXslt ;
VALUE mNokogiriXmlSax ;
VALUE mNokogiriHtmlSax ;

#ifdef USE_INCLUDED_VASPRINTF
/*
 * I srsly hate windows.  it doesn't have vasprintf.
 * Thank you Geoffroy Couprie for this implementation of vasprintf!
 */
int vasprintf (char **strp, const char *fmt, va_list ap)
{
  int len = vsnprintf (NULL, 0, fmt, ap) + 1;
  char *res = (char *)malloc((unsigned int)len);
  if (res == NULL)
      return -1;
  *strp = res;
  return vsnprintf(res, (unsigned int)len, fmt, ap);
}
#endif

#ifdef USING_SYSTEM_ALLOCATOR_LIBRARY /* Ruby Enterprise Edition with tcmalloc */
void vasprintf_free (void *p)
{
  system_free(p);
}
#else
void vasprintf_free (void *p)
{
  free(p);
}
#endif

#ifdef HAVE_RUBY_UTIL_H
#include "ruby/util.h"
#else
#ifndef __MACRUBY__
#include "util.h"
#endif
#endif

void nokogiri_root_node(xmlNodePtr node)
{
  xmlDocPtr doc;
  nokogiriTuplePtr tuple;

  doc = node->doc;
  if (doc->type == XML_DOCUMENT_FRAG_NODE) doc = doc->doc;
  tuple = (nokogiriTuplePtr)doc->_private;
  st_insert(tuple->unlinkedNodes, (st_data_t)node, (st_data_t)node);
}

void nokogiri_root_nsdef(xmlNsPtr ns, xmlDocPtr doc)
{
  nokogiriTuplePtr tuple;

  if (doc->type == XML_DOCUMENT_FRAG_NODE) doc = doc->doc;
  tuple = (nokogiriTuplePtr)doc->_private;
  st_insert(tuple->unlinkedNodes, (st_data_t)ns, (st_data_t)ns);
}

void Init_nokogiri()
{
#ifndef __MACRUBY__
  xmlMemSetup(
      (xmlFreeFunc)ruby_xfree,
      (xmlMallocFunc)ruby_xmalloc,
      (xmlReallocFunc)ruby_xrealloc,
      ruby_strdup
  );
#endif

  mNokogiri         = rb_define_module("Nokogiri");
  mNokogiriXml      = rb_define_module_under(mNokogiri, "XML");
  mNokogiriHtml     = rb_define_module_under(mNokogiri, "HTML");
  mNokogiriXslt     = rb_define_module_under(mNokogiri, "XSLT");
  mNokogiriXmlSax   = rb_define_module_under(mNokogiriXml, "SAX");
  mNokogiriHtmlSax  = rb_define_module_under(mNokogiriHtml, "SAX");

  rb_const_set( mNokogiri,
                rb_intern("LIBXML_VERSION"),
                NOKOGIRI_STR_NEW2(LIBXML_DOTTED_VERSION)
              );
  rb_const_set( mNokogiri,
                rb_intern("LIBXML_PARSER_VERSION"),
                NOKOGIRI_STR_NEW2(xmlParserVersion)
              );

#ifdef LIBXML_ICONV_ENABLED
  rb_const_set(mNokogiri, rb_intern("LIBXML_ICONV_ENABLED"), Qtrue);
#else
  rb_const_set(mNokogiri, rb_intern("LIBXML_ICONV_ENABLED"), Qfalse);
#endif

  xmlInitParser();

  init_xml_document();
  init_html_document();
  init_xml_node();
  init_xml_document_fragment();
  init_xml_text();
  init_xml_cdata();
  init_xml_processing_instruction();
  init_xml_attr();
  init_xml_entity_reference();
  init_xml_comment();
  init_xml_node_set();
  init_xml_xpath_context();
  init_xml_sax_parser_context();
  init_xml_sax_parser();
  init_xml_sax_push_parser();
  init_xml_reader();
  init_xml_dtd();
  init_xml_element_content();
  init_xml_attribute_decl();
  init_xml_element_decl();
  init_xml_entity_decl();
  init_xml_namespace();
  init_html_sax_parser_context();
  init_html_sax_push_parser();
  init_xslt_stylesheet();
  init_xml_syntax_error();
  init_html_entity_lookup();
  init_html_element_description();
  init_xml_schema();
  init_xml_relax_ng();
  init_nokogiri_io();
  init_xml_encoding_handler();
}
                                                                                                                                                                                                                                                                    nokogiri.h                                                                                          0100644 0001750 0001750 00000007221 12566211316 043072  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_NATIVE
#define NOKOGIRI_NATIVE

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>

#ifdef USE_INCLUDED_VASPRINTF
int vasprintf (char **strp, const char *fmt, va_list ap);
#else

#define _GNU_SOURCE
#  include <stdio.h>
#undef _GNU_SOURCE

#endif

#include <libxml/parser.h>
#include <libxml/entities.h>
#include <libxml/parserInternals.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/relaxng.h>
#include <libxml/xinclude.h>
#include <libxslt/extensions.h>
#include <libxml/c14n.h>
#include <ruby.h>

#ifdef HAVE_RUBY_ENCODING_H
#include <ruby/st.h>
#else
#include <st.h>
#endif

#ifndef UNUSED
# if defined(__GNUC__)
#  define MAYBE_UNUSED(name) name __attribute__((unused))
#  define UNUSED(name) MAYBE_UNUSED(UNUSED_ ## name)
# else
#  define MAYBE_UNUSED(name) name
#  define UNUSED(name) name
# endif
#endif

#ifndef NORETURN
# if defined(__GNUC__)
#  define NORETURN(name) __attribute__((noreturn)) name
# else
#  define NORETURN(name) name
# endif
#endif

#ifdef HAVE_RUBY_ENCODING_H

#include <ruby/encoding.h>

#define NOKOGIRI_STR_NEW2(str) \
  NOKOGIRI_STR_NEW(str, strlen((const char *)(str)))

#define NOKOGIRI_STR_NEW(str, len) \
  rb_external_str_new_with_enc((const char *)(str), (long)(len), rb_utf8_encoding())

#else

#define NOKOGIRI_STR_NEW2(str) \
  rb_str_new2((const char *)(str))

#define NOKOGIRI_STR_NEW(str, len) \
  rb_str_new((const char *)(str), (long)(len))
#endif

#define RBSTR_OR_QNIL(_str) \
  (_str ? NOKOGIRI_STR_NEW2(_str) : Qnil)

#include <xml_libxml2_hacks.h>

#include <xml_io.h>
#include <xml_document.h>
#include <html_entity_lookup.h>
#include <html_document.h>
#include <xml_node.h>
#include <xml_text.h>
#include <xml_cdata.h>
#include <xml_attr.h>
#include <xml_processing_instruction.h>
#include <xml_entity_reference.h>
#include <xml_document_fragment.h>
#include <xml_comment.h>
#include <xml_node_set.h>
#include <xml_dtd.h>
#include <xml_attribute_decl.h>
#include <xml_element_decl.h>
#include <xml_entity_decl.h>
#include <xml_xpath_context.h>
#include <xml_element_content.h>
#include <xml_sax_parser_context.h>
#include <xml_sax_parser.h>
#include <xml_sax_push_parser.h>
#include <xml_reader.h>
#include <html_sax_parser_context.h>
#include <html_sax_push_parser.h>
#include <xslt_stylesheet.h>
#include <xml_syntax_error.h>
#include <xml_schema.h>
#include <xml_relax_ng.h>
#include <html_element_description.h>
#include <xml_namespace.h>
#include <xml_encoding_handler.h>

extern VALUE mNokogiri ;
extern VALUE mNokogiriXml ;
extern VALUE mNokogiriXmlSax ;
extern VALUE mNokogiriHtml ;
extern VALUE mNokogiriHtmlSax ;
extern VALUE mNokogiriXslt ;

void nokogiri_root_node(xmlNodePtr);
void nokogiri_root_nsdef(xmlNsPtr, xmlDocPtr);

#ifdef DEBUG

#define NOKOGIRI_DEBUG_START(p) if (getenv("NOKOGIRI_NO_FREE")) return ; if (getenv("NOKOGIRI_DEBUG")) fprintf(stderr,"nokogiri: %s:%d %p start\n", __FILE__, __LINE__, p);
#define NOKOGIRI_DEBUG_END(p) if (getenv("NOKOGIRI_DEBUG")) fprintf(stderr,"nokogiri: %s:%d %p end\n", __FILE__, __LINE__, p);

#else

#define NOKOGIRI_DEBUG_START(p)
#define NOKOGIRI_DEBUG_END(p)

#endif

#ifndef RSTRING_PTR
#define RSTRING_PTR(s) (RSTRING(s)->ptr)
#endif

#ifndef RSTRING_LEN
#define RSTRING_LEN(s) (RSTRING(s)->len)
#endif

#ifndef RARRAY_PTR
#define RARRAY_PTR(a) RARRAY(a)->ptr
#endif

#ifndef RARRAY_LEN
#define RARRAY_LEN(a) RARRAY(a)->len
#endif

#ifndef __builtin_expect
# if defined(__GNUC__)
#  define __builtin_expect(expr, c) __builtin_expect((long)(expr), (long)(c))
# endif
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                               xml_attr.c                                                                                          0100644 0001750 0001750 00000003774 12566211316 043107  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_attr.h>

/*
 * call-seq:
 *  value=(content)
 *
 * Set the value for this Attr to +content+
 */
static VALUE set_value(VALUE self, VALUE content)
{
  xmlAttrPtr attr;
  Data_Get_Struct(self, xmlAttr, attr);

  if(attr->children) xmlFreeNodeList(attr->children);

  attr->children = attr->last = NULL;

  if(content) {
    xmlChar *buffer;
    xmlNode *tmp;

    /* Encode our content */
    buffer = xmlEncodeEntitiesReentrant(attr->doc, (unsigned char *)StringValuePtr(content));

    attr->children = xmlStringGetNodeList(attr->doc, buffer);
    attr->last = NULL;
    tmp = attr->children;

    /* Loop through the children */
    for(tmp = attr->children; tmp; tmp = tmp->next) {
      tmp->parent = (xmlNode *)attr;
      tmp->doc = attr->doc;
      if(tmp->next == NULL) attr->last = tmp;
    }

    /* Free up memory */
    xmlFree(buffer);
  }

  return content;
}

/*
 * call-seq:
 *  new(document, name)
 *
 * Create a new Attr element on the +document+ with +name+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  VALUE document;
  VALUE name;
  VALUE rest;
  xmlAttrPtr node;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &document, &name, &rest);

  Data_Get_Struct(document, xmlDoc, xml_doc);

  node = xmlNewDocProp(
      xml_doc,
      (const xmlChar *)StringValuePtr(name),
      NULL
  );

  nokogiri_root_node((xmlNodePtr)node);

  rb_node = Nokogiri_wrap_xml_node(klass, (xmlNodePtr)node);
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlAttr;
void init_xml_attr()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * Attr represents a Attr node in an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "Attr", node);

  cNokogiriXmlAttr = klass;

  rb_define_singleton_method(klass, "new", new, -1);
  rb_define_method(klass, "value=", set_value, 1);
}
    xml_attr.h                                                                                          0100644 0001750 0001750 00000000211 12566211316 043073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ATTR
#define NOKOGIRI_XML_ATTR

#include <nokogiri.h>

void init_xml_attr();

extern VALUE cNokogiriXmlAttr;
#endif
                                                                                                                                                                                                                                                                                                                                                                                       xml_attribute_decl.c                                                                                0100644 0001750 0001750 00000002624 12566211316 045120  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_attribute_decl.h>

/*
 * call-seq:
 *  attribute_type
 *
 * The attribute_type for this AttributeDecl
 */
static VALUE attribute_type(VALUE self)
{
  xmlAttributePtr node;
  Data_Get_Struct(self, xmlAttribute, node);
  return INT2NUM((long)node->atype);
}

/*
 * call-seq:
 *  default
 *
 * The default value
 */
static VALUE default_value(VALUE self)
{
  xmlAttributePtr node;
  Data_Get_Struct(self, xmlAttribute, node);

  if(node->defaultValue) return NOKOGIRI_STR_NEW2(node->defaultValue);
  return Qnil;
}

/*
 * call-seq:
 *  enumeration
 *
 * An enumeration of possible values
 */
static VALUE enumeration(VALUE self)
{
  xmlAttributePtr node;
  xmlEnumerationPtr enm;
  VALUE list;

  Data_Get_Struct(self, xmlAttribute, node);

  list = rb_ary_new();
  enm = node->tree;

  while(enm) {
    rb_ary_push(list, NOKOGIRI_STR_NEW2(enm->name));
    enm = enm->next;
  }

  return list;
}

VALUE cNokogiriXmlAttributeDecl;

void init_xml_attribute_decl()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE klass = rb_define_class_under(xml, "AttributeDecl", node);

  cNokogiriXmlAttributeDecl = klass;

  rb_define_method(klass, "attribute_type", attribute_type, 0);
  rb_define_method(klass, "default", default_value, 0);
  rb_define_method(klass, "enumeration", enumeration, 0);
}
                                                                                                            xml_attribute_decl.h                                                                                0100644 0001750 0001750 00000000260 12566211316 045117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ATTRIBUTE_DECL
#define NOKOGIRI_XML_ATTRIBUTE_DECL

#include <nokogiri.h>

void init_xml_attribute_decl();

extern VALUE cNokogiriXmlAttributeDecl;
#endif
                                                                                                                                                                                                                                                                                                                                                xml_cdata.c                                                                                         0100644 0001750 0001750 00000002450 12566211316 043177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_cdata.h>

/*
 * call-seq:
 *  new(document, content)
 *
 * Create a new CDATA element on the +document+ with +content+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  xmlNodePtr node;
  VALUE doc;
  VALUE content;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &doc, &content, &rest);

  Data_Get_Struct(doc, xmlDoc, xml_doc);

  node = xmlNewCDataBlock(
      xml_doc->doc,
      NIL_P(content) ? NULL : (const xmlChar *)StringValuePtr(content),
      NIL_P(content) ? 0 : (int)RSTRING_LEN(content)
  );

  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(klass, node);
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlCData;
void init_xml_cdata()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE char_data = rb_define_class_under(xml, "CharacterData", node);
  VALUE text = rb_define_class_under(xml, "Text", char_data);

  /*
   * CData represents a CData node in an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "CDATA", text);


  cNokogiriXmlCData = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                                        xml_cdata.h                                                                                         0100644 0001750 0001750 00000000215 12566211316 043201  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_CDATA
#define NOKOGIRI_XML_CDATA

#include <nokogiri.h>

void init_xml_cdata();

extern VALUE cNokogiriXmlCData;
#endif
                                                                                                                                                                                                                                                                                                                                                                                   xml_comment.c                                                                                       0100644 0001750 0001750 00000002273 12566211316 043570  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_comment.h>

/*
 * call-seq:
 *  new(document, content)
 *
 * Create a new Comment element on the +document+ with +content+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  xmlNodePtr node;
  VALUE document;
  VALUE content;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &document, &content, &rest);

  Data_Get_Struct(document, xmlDoc, xml_doc);

  node = xmlNewDocComment(
      xml_doc,
      (const xmlChar *)StringValuePtr(content)
  );

  rb_node = Nokogiri_wrap_xml_node(klass, node);
  rb_obj_call_init(rb_node, argc, argv);

  nokogiri_root_node(node);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlComment;
void init_xml_comment()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE char_data = rb_define_class_under(xml, "CharacterData", node);

  /*
   * Comment represents a comment node in an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "Comment", char_data);


  cNokogiriXmlComment = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                                                                                                                                                     xml_comment.h                                                                                       0100644 0001750 0001750 00000000225 12566211316 043570  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_COMMENT
#define NOKOGIRI_XML_COMMENT

#include <nokogiri.h>

void init_xml_comment();

extern VALUE cNokogiriXmlComment;
#endif
                                                                                                                                                                                                                                                                                                                                                                           xml_document.c                                                                                      0100644 0001750 0001750 00000035037 12566211316 043750  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_document.h>

static int dealloc_node_i(xmlNodePtr key, xmlNodePtr node, xmlDocPtr doc)
{
  switch(node->type) {
  case XML_ATTRIBUTE_NODE:
    xmlFreePropList((xmlAttrPtr)node);
    break;
  case XML_NAMESPACE_DECL:
    xmlFree(node);
    break;
  default:
    if(node->parent == NULL) {
      xmlAddChild((xmlNodePtr)doc, node);
    }
  }
  return ST_CONTINUE;
}

static void dealloc(xmlDocPtr doc)
{
  xmlDeregisterNodeFunc func;
  st_table *node_hash;

  NOKOGIRI_DEBUG_START(doc);
  func = xmlDeregisterNodeDefault(NULL);

  node_hash  = DOC_UNLINKED_NODE_HASH(doc);

  st_foreach(node_hash, dealloc_node_i, (st_data_t)doc);
  st_free_table(node_hash);

  free(doc->_private);
  doc->_private = NULL;
  xmlFreeDoc(doc);

  xmlDeregisterNodeDefault(func);
  NOKOGIRI_DEBUG_END(doc);
}

static void recursively_remove_namespaces_from_node(xmlNodePtr node)
{
  xmlNodePtr child ;
  xmlAttrPtr property ;

  xmlSetNs(node, NULL);

  for (child = node->children ; child ; child = child->next)
    recursively_remove_namespaces_from_node(child);

  if (((node->type == XML_ELEMENT_NODE) ||
       (node->type == XML_XINCLUDE_START) ||
       (node->type == XML_XINCLUDE_END)) &&
      node->nsDef) {
    xmlFreeNsList(node->nsDef);
    node->nsDef = NULL;
  }

  if (node->type == XML_ELEMENT_NODE && node->properties != NULL) {
    property = node->properties ;
    while (property != NULL) {
      if (property->ns) property->ns = NULL ;
      property = property->next ;
    }
  }
}

/*
 * call-seq:
 *  url
 *
 * Get the url name for this document.
 */
static VALUE url(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if(doc->URL) return NOKOGIRI_STR_NEW2(doc->URL);

  return Qnil;
}

/*
 * call-seq:
 *  root=
 *
 * Set the root element on this document
 */
static VALUE set_root(VALUE self, VALUE root)
{
  xmlDocPtr doc;
  xmlNodePtr new_root;
  xmlNodePtr old_root;

  Data_Get_Struct(self, xmlDoc, doc);

  old_root = NULL;

  if(NIL_P(root)) {
    old_root = xmlDocGetRootElement(doc);

    if(old_root) {
      xmlUnlinkNode(old_root);
      nokogiri_root_node(old_root);
    }

    return root;
  }

  Data_Get_Struct(root, xmlNode, new_root);


  /* If the new root's document is not the same as the current document,
   * then we need to dup the node in to this document. */
  if(new_root->doc != doc) {
    old_root = xmlDocGetRootElement(doc);
    if (!(new_root = xmlDocCopyNode(new_root, doc, 1))) {
      rb_raise(rb_eRuntimeError, "Could not reparent node (xmlDocCopyNode)");
    }
  }

  xmlDocSetRootElement(doc, new_root);
  if(old_root) nokogiri_root_node(old_root);
  return root;
}

/*
 * call-seq:
 *  root
 *
 * Get the root node for this document.
 */
static VALUE root(VALUE self)
{
  xmlDocPtr doc;
  xmlNodePtr root;

  Data_Get_Struct(self, xmlDoc, doc);

  root = xmlDocGetRootElement(doc);

  if(!root) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, root) ;
}

/*
 * call-seq:
 *  encoding= encoding
 *
 * Set the encoding string for this Document
 */
static VALUE set_encoding(VALUE self, VALUE encoding)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if (doc->encoding)
      free((char *) doc->encoding); /* this may produce a gcc cast warning */

  doc->encoding = xmlStrdup((xmlChar *)StringValuePtr(encoding));

  return encoding;
}

/*
 * call-seq:
 *  encoding
 *
 * Get the encoding for this Document
 */
static VALUE encoding(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if(!doc->encoding) return Qnil;
  return NOKOGIRI_STR_NEW2(doc->encoding);
}

/*
 * call-seq:
 *  version
 *
 * Get the XML version for this Document
 */
static VALUE version(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if(!doc->version) return Qnil;
  return NOKOGIRI_STR_NEW2(doc->version);
}

/*
 * call-seq:
 *  read_io(io, url, encoding, options)
 *
 * Create a new document from an IO object
 */
static VALUE read_io( VALUE klass,
                      VALUE io,
                      VALUE url,
                      VALUE encoding,
                      VALUE options )
{
  const char * c_url    = NIL_P(url)      ? NULL : StringValuePtr(url);
  const char * c_enc    = NIL_P(encoding) ? NULL : StringValuePtr(encoding);
  VALUE error_list      = rb_ary_new();
  VALUE document;
  xmlDocPtr doc;

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  doc = xmlReadIO(
      (xmlInputReadCallback)io_read_callback,
      (xmlInputCloseCallback)io_close_callback,
      (void *)io,
      c_url,
      c_enc,
      (int)NUM2INT(options)
  );
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlErrorPtr error;

    xmlFreeDoc(doc);

    error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  document = Nokogiri_wrap_xml_document(klass, doc);
  rb_iv_set(document, "@errors", error_list);
  return document;
}

/*
 * call-seq:
 *  read_memory(string, url, encoding, options)
 *
 * Create a new document from a String
 */
static VALUE read_memory( VALUE klass,
                          VALUE string,
                          VALUE url,
                          VALUE encoding,
                          VALUE options )
{
  const char * c_buffer = StringValuePtr(string);
  const char * c_url    = NIL_P(url)      ? NULL : StringValuePtr(url);
  const char * c_enc    = NIL_P(encoding) ? NULL : StringValuePtr(encoding);
  int len               = (int)RSTRING_LEN(string);
  VALUE error_list      = rb_ary_new();
  VALUE document;
  xmlDocPtr doc;

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
  doc = xmlReadMemory(c_buffer, len, c_url, c_enc, (int)NUM2INT(options));
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlErrorPtr error;

    xmlFreeDoc(doc);

    error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  document = Nokogiri_wrap_xml_document(klass, doc);
  rb_iv_set(document, "@errors", error_list);
  return document;
}

/*
 * call-seq:
 *  dup
 *
 * Copy this Document.  An optional depth may be passed in, but it defaults
 * to a deep copy.  0 is a shallow copy, 1 is a deep copy.
 */
static VALUE duplicate_node(int argc, VALUE *argv, VALUE self)
{
  xmlDocPtr doc, dup;
  VALUE level;

  if(rb_scan_args(argc, argv, "01", &level) == 0)
    level = INT2NUM((long)1);

  Data_Get_Struct(self, xmlDoc, doc);

  dup = xmlCopyDoc(doc, (int)NUM2INT(level));
  if(dup == NULL) return Qnil;

  dup->type = doc->type;
  return Nokogiri_wrap_xml_document(rb_obj_class(self), dup);
}

/*
 * call-seq:
 *  new(version = default)
 *
 * Create a new document with +version+ (defaults to "1.0")
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr doc;
  VALUE version, rest, rb_doc ;

  rb_scan_args(argc, argv, "0*", &rest);
  version = rb_ary_entry(rest, (long)0);
  if (NIL_P(version)) version = rb_str_new2("1.0");

  doc = xmlNewDoc((xmlChar *)StringValuePtr(version));
  rb_doc = Nokogiri_wrap_xml_document(klass, doc);
  rb_obj_call_init(rb_doc, argc, argv);
  return rb_doc ;
}

/*
 *  call-seq:
 *    remove_namespaces!
 *
 *  Remove all namespaces from all nodes in the document.
 *
 *  This could be useful for developers who either don't understand namespaces
 *  or don't care about them.
 *
 *  The following example shows a use case, and you can decide for yourself
 *  whether this is a good thing or not:
 *
 *    doc = Nokogiri::XML <<-EOXML
 *       <root>
 *         <car xmlns:part="http://general-motors.com/">
 *           <part:tire>Michelin Model XGV</part:tire>
 *         </car>
 *         <bicycle xmlns:part="http://schwinn.com/">
 *           <part:tire>I'm a bicycle tire!</part:tire>
 *         </bicycle>
 *       </root>
 *       EOXML
 *    
 *    doc.xpath("//tire").to_s # => ""
 *    doc.xpath("//part:tire", "part" => "http://general-motors.com/").to_s # => "<part:tire>Michelin Model XGV</part:tire>"
 *    doc.xpath("//part:tire", "part" => "http://schwinn.com/").to_s # => "<part:tire>I'm a bicycle tire!</part:tire>"
 *    
 *    doc.remove_namespaces!
 *    
 *    doc.xpath("//tire").to_s # => "<tire>Michelin Model XGV</tire><tire>I'm a bicycle tire!</tire>"
 *    doc.xpath("//part:tire", "part" => "http://general-motors.com/").to_s # => ""
 *    doc.xpath("//part:tire", "part" => "http://schwinn.com/").to_s # => ""
 *
 *  For more information on why this probably is *not* a good thing in general,
 *  please direct your browser to
 *  http://tenderlovemaking.com/2009/04/23/namespaces-in-xml.html
 */
VALUE remove_namespaces_bang(VALUE self)
{
  xmlDocPtr doc ;
  Data_Get_Struct(self, xmlDoc, doc);

  recursively_remove_namespaces_from_node((xmlNodePtr)doc);
  return self;
}

/* call-seq: doc.create_entity(name, type, external_id, system_id, content)
 *
 * Create a new entity named +name+.
 *
 * +type+ is an integer representing the type of entity to be created, and it
 * defaults to Nokogiri::XML::EntityDecl::INTERNAL_GENERAL.  See
 * the constants on Nokogiri::XML::EntityDecl for more information.
 *
 * +external_id+, +system_id+, and +content+ set the External ID, System ID,
 * and content respectively.  All of these parameters are optional.
 */
static VALUE create_entity(int argc, VALUE *argv, VALUE self)
{
  VALUE name;
  VALUE type;
  VALUE external_id;
  VALUE system_id;
  VALUE content;
  xmlEntityPtr ptr;
  xmlDocPtr doc ;

  Data_Get_Struct(self, xmlDoc, doc);

  rb_scan_args(argc, argv, "14", &name, &type, &external_id, &system_id,
      &content);

  xmlResetLastError();
  ptr = xmlAddDocEntity(
      doc,
      (xmlChar *)(NIL_P(name)        ? NULL                        : StringValuePtr(name)),
      (int)      (NIL_P(type)        ? XML_INTERNAL_GENERAL_ENTITY : NUM2INT(type)),
      (xmlChar *)(NIL_P(external_id) ? NULL                        : StringValuePtr(external_id)),
      (xmlChar *)(NIL_P(system_id)   ? NULL                        : StringValuePtr(system_id)),
      (xmlChar *)(NIL_P(content)     ? NULL                        : StringValuePtr(content))
    );

  if(NULL == ptr) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not create entity");

    return Qnil;
  }

  return Nokogiri_wrap_xml_node(cNokogiriXmlEntityDecl, (xmlNodePtr)ptr);
}

static int block_caller(void * ctx, xmlNodePtr _node, xmlNodePtr _parent)
{
  VALUE block;
  VALUE node;
  VALUE parent;
  VALUE ret;

  if(_node->type == XML_NAMESPACE_DECL){
    node = Nokogiri_wrap_xml_namespace(_parent->doc, (xmlNsPtr) _node);
  }
  else{
    node   = Nokogiri_wrap_xml_node(Qnil, _node);
  }
  parent = _parent ? Nokogiri_wrap_xml_node(Qnil, _parent) : Qnil;
  block  = (VALUE)ctx;

  ret = rb_funcall(block, rb_intern("call"), 2, node, parent);

  if(Qfalse == ret || Qnil == ret) return 0;

  return 1;
}

/* call-seq:
 *  doc.canonicalize(mode=XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)
 *  doc.canonicalize { |obj, parent| ... }
 *
 * Canonicalize a document and return the results.  Takes an optional block
 * that takes two parameters: the +obj+ and that node's +parent+.  
 * The  +obj+ will be either a Nokogiri::XML::Node, or a Nokogiri::XML::Namespace
 * The block must return a non-nil, non-false value if the +obj+ passed in 
 * should be included in the canonicalized document.
 */
static VALUE canonicalize(int argc, VALUE* argv, VALUE self)
{
  VALUE mode;
  VALUE incl_ns;
  VALUE with_comments;
  xmlChar **ns;
  long ns_len, i;

  xmlDocPtr doc;
  xmlOutputBufferPtr buf;
  xmlC14NIsVisibleCallback cb = NULL;
  void * ctx = NULL;

  VALUE rb_cStringIO;
  VALUE io;

  rb_scan_args(argc, argv, "03", &mode, &incl_ns, &with_comments);

  Data_Get_Struct(self, xmlDoc, doc);

  rb_cStringIO = rb_const_get_at(rb_cObject, rb_intern("StringIO"));
  io           = rb_class_new_instance(0, 0, rb_cStringIO);
  buf          = xmlAllocOutputBuffer(NULL);

  buf->writecallback = (xmlOutputWriteCallback)io_write_callback;
  buf->closecallback = (xmlOutputCloseCallback)io_close_callback;
  buf->context       = (void *)io;

  if(rb_block_given_p()) {
    cb = block_caller;
    ctx = (void *)rb_block_proc();
  }

  if(NIL_P(incl_ns)){
    ns = NULL;
  }
  else{
    ns_len = RARRAY_LEN(incl_ns);
    ns = calloc((size_t)ns_len+1, sizeof(xmlChar *));
    for (i = 0 ; i < ns_len ; i++) {
      VALUE entry = rb_ary_entry(incl_ns, i);
      const char * ptr = StringValuePtr(entry);
      ns[i] = (xmlChar*) ptr;
    }
  }


  xmlC14NExecute(doc, cb, ctx, 
    (int)      (NIL_P(mode)        ? 0 : NUM2INT(mode)), 
    ns,
    (int)      (NIL_P(with_comments)        ? 0 : 1),
    buf);

  xmlOutputBufferClose(buf);

  return rb_funcall(io, rb_intern("string"), 0);
}

VALUE cNokogiriXmlDocument ;
void init_xml_document()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE node      = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * Nokogiri::XML::Document wraps an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "Document", node);

  cNokogiriXmlDocument = klass;

  rb_define_singleton_method(klass, "read_memory", read_memory, 4);
  rb_define_singleton_method(klass, "read_io", read_io, 4);
  rb_define_singleton_method(klass, "new", new, -1);

  rb_define_method(klass, "root", root, 0);
  rb_define_method(klass, "root=", set_root, 1);
  rb_define_method(klass, "encoding", encoding, 0);
  rb_define_method(klass, "encoding=", set_encoding, 1);
  rb_define_method(klass, "version", version, 0);
  rb_define_method(klass, "canonicalize", canonicalize, -1);
  rb_define_method(klass, "dup", duplicate_node, -1);
  rb_define_method(klass, "url", url, 0);
  rb_define_method(klass, "create_entity", create_entity, -1);
  rb_define_method(klass, "remove_namespaces!", remove_namespaces_bang, 0);
}


/* this takes klass as a param because it's used for HtmlDocument, too. */
VALUE Nokogiri_wrap_xml_document(VALUE klass, xmlDocPtr doc)
{
  nokogiriTuplePtr tuple = (nokogiriTuplePtr)malloc(sizeof(nokogiriTuple));

  VALUE rb_doc = Data_Wrap_Struct(
      klass ? klass : cNokogiriXmlDocument,
      0,
      dealloc,
      doc
  );

  VALUE cache = rb_ary_new();
  rb_iv_set(rb_doc, "@decorators", Qnil);
  rb_iv_set(rb_doc, "@node_cache", cache);

  tuple->doc = rb_doc;
  tuple->unlinkedNodes = st_init_numtable_with_size(128);
  tuple->node_cache = cache;
  doc->_private = tuple ;

  rb_obj_call_init(rb_doc, 0, NULL);

  return rb_doc ;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 xml_document.h                                                                                      0100644 0001750 0001750 00000001301 12566211316 043740  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_DOCUMENT
#define NOKOGIRI_XML_DOCUMENT

#include <nokogiri.h>

struct _nokogiriTuple {
  VALUE         doc;
  st_table     *unlinkedNodes;
  VALUE         node_cache;
};
typedef struct _nokogiriTuple nokogiriTuple;
typedef nokogiriTuple * nokogiriTuplePtr;

void init_xml_document();
VALUE Nokogiri_wrap_xml_document(VALUE klass, xmlDocPtr doc);

#define DOC_RUBY_OBJECT_TEST(x) ((nokogiriTuplePtr)(x->_private))
#define DOC_RUBY_OBJECT(x) (((nokogiriTuplePtr)(x->_private))->doc)
#define DOC_UNLINKED_NODE_HASH(x) (((nokogiriTuplePtr)(x->_private))->unlinkedNodes)
#define DOC_NODE_CACHE(x) (((nokogiriTuplePtr)(x->_private))->node_cache)

extern VALUE cNokogiriXmlDocument ;
#endif
                                                                                                                                                                                                                                                                                                                               xml_document_fragment.c                                                                             0100644 0001750 0001750 00000002121 12566211316 045617  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_document_fragment.h>

/*
 * call-seq:
 *  new(document)
 *
 * Create a new DocumentFragment element on the +document+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  xmlNodePtr node;
  VALUE document;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "1*", &document, &rest);

  Data_Get_Struct(document, xmlDoc, xml_doc);

  node = xmlNewDocFragment(xml_doc->doc);

  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(klass, node);
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlDocumentFragment;
void init_xml_document_fragment()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * DocumentFragment represents a DocumentFragment node in an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "DocumentFragment", node);

  cNokogiriXmlDocumentFragment = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                               xml_document_fragment.h                                                                             0100644 0001750 0001750 00000000275 12566211316 045634  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_DOCUMENT_FRAGMENT
#define NOKOGIRI_XML_DOCUMENT_FRAGMENT

#include <nokogiri.h>

void init_xml_document_fragment();

extern VALUE cNokogiriXmlDocumentFragment;
#endif

                                                                                                                                                                                                                                                                                                                                   xml_dtd.c                                                                                           0100644 0001750 0001750 00000010031 12566211316 042670  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_dtd.h>

static void notation_copier(void *payload, void *data, xmlChar *name)
{
  VALUE hash = (VALUE)data;
  VALUE klass = rb_const_get(mNokogiriXml, rb_intern("Notation"));

  xmlNotationPtr c_notation = (xmlNotationPtr)payload;
  VALUE notation;
  VALUE argv[3];
  argv[0] = (c_notation->name ? NOKOGIRI_STR_NEW2(c_notation->name) : Qnil);
  argv[1] = (c_notation->PublicID ? NOKOGIRI_STR_NEW2(c_notation->PublicID) : Qnil);
  argv[2] = (c_notation->SystemID ? NOKOGIRI_STR_NEW2(c_notation->SystemID) : Qnil);

  notation = rb_class_new_instance(3, argv, klass);

  rb_hash_aset(hash, NOKOGIRI_STR_NEW2(name),notation);
}

static void element_copier(void *_payload, void *data, xmlChar *name)
{
  VALUE hash = (VALUE)data;
  xmlNodePtr payload = (xmlNodePtr)_payload;

  VALUE element = Nokogiri_wrap_xml_node(Qnil, payload);

  rb_hash_aset(hash, NOKOGIRI_STR_NEW2(name), element);
}

/*
 * call-seq:
 *   entities
 *
 * Get a hash of the elements for this DTD.
 */
static VALUE entities(VALUE self)
{
  xmlDtdPtr dtd;
  VALUE hash;

  Data_Get_Struct(self, xmlDtd, dtd);

  if(!dtd->entities) return Qnil;

  hash = rb_hash_new();

  xmlHashScan((xmlHashTablePtr)dtd->entities, element_copier, (void *)hash);

  return hash;
}

/*
 * call-seq:
 *   notations
 *
 * Get a hash of the notations for this DTD.
 */
static VALUE notations(VALUE self)
{
  xmlDtdPtr dtd;
  VALUE hash;

  Data_Get_Struct(self, xmlDtd, dtd);

  if(!dtd->notations) return Qnil;

  hash = rb_hash_new();

  xmlHashScan((xmlHashTablePtr)dtd->notations, notation_copier, (void *)hash);

  return hash;
}

/*
 * call-seq:
 *   attributes
 *
 * Get a hash of the attributes for this DTD.
 */
static VALUE attributes(VALUE self)
{
  xmlDtdPtr dtd;
  VALUE hash;

  Data_Get_Struct(self, xmlDtd, dtd);

  hash = rb_hash_new();

  if(!dtd->attributes) return hash;

  xmlHashScan((xmlHashTablePtr)dtd->attributes, element_copier, (void *)hash);

  return hash;
}

/*
 * call-seq:
 *   elements
 *
 * Get a hash of the elements for this DTD.
 */
static VALUE elements(VALUE self)
{
  xmlDtdPtr dtd;
  VALUE hash;

  Data_Get_Struct(self, xmlDtd, dtd);

  if(!dtd->elements) return Qnil;

  hash = rb_hash_new();

  xmlHashScan((xmlHashTablePtr)dtd->elements, element_copier, (void *)hash);

  return hash;
}

/*
 * call-seq:
 *   validate(document)
 *
 * Validate +document+ returning a list of errors
 */
static VALUE validate(VALUE self, VALUE document)
{
  xmlDocPtr doc;
  xmlDtdPtr dtd;
  xmlValidCtxtPtr ctxt;
  VALUE error_list;

  Data_Get_Struct(self, xmlDtd, dtd);
  Data_Get_Struct(document, xmlDoc, doc);
  error_list = rb_ary_new();

  ctxt = xmlNewValidCtxt();

  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  xmlValidateDtd(ctxt, doc, dtd);

  xmlSetStructuredErrorFunc(NULL, NULL);

  xmlFreeValidCtxt(ctxt);

  return error_list;
}

/*
 * call-seq:
 *   system_id
 *
 * Get the System ID for this DTD
 */
static VALUE system_id(VALUE self)
{
  xmlDtdPtr dtd;
  Data_Get_Struct(self, xmlDtd, dtd);

  if(!dtd->SystemID) return Qnil;

  return NOKOGIRI_STR_NEW2(dtd->SystemID);
}

/*
 * call-seq:
 *   external_id
 *
 * Get the External ID for this DTD
 */
static VALUE external_id(VALUE self)
{
  xmlDtdPtr dtd;
  Data_Get_Struct(self, xmlDtd, dtd);

  if(!dtd->ExternalID) return Qnil;

  return NOKOGIRI_STR_NEW2(dtd->ExternalID);
}

VALUE cNokogiriXmlDtd;

void init_xml_dtd()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * Nokogiri::XML::DTD wraps DTD nodes in an XML document
   */
  VALUE klass = rb_define_class_under(xml, "DTD", node);

  cNokogiriXmlDtd = klass;

  rb_define_method(klass, "notations", notations, 0);
  rb_define_method(klass, "elements", elements, 0);
  rb_define_method(klass, "entities", entities, 0);
  rb_define_method(klass, "validate", validate, 1);
  rb_define_method(klass, "attributes", attributes, 0);
  rb_define_method(klass, "system_id", system_id, 0);
  rb_define_method(klass, "external_id", external_id, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       xml_dtd.h                                                                                           0100644 0001750 0001750 00000000206 12566211316 042700  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_DTD
#define NOKOGIRI_XML_DTD

#include <nokogiri.h>

extern VALUE cNokogiriXmlDtd;

void init_xml_dtd();

#endif
                                                                                                                                                                                                                                                                                                                                                                                          xml_element_content.c                                                                               0100644 0001750 0001750 00000005043 12566211316 045307  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_element_content.h>

VALUE cNokogiriXmlElementContent;

/*
 * call-seq:
 *  name
 *
 * Get the require element +name+
 */
static VALUE get_name(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  if(!elem->name) return Qnil;
  return NOKOGIRI_STR_NEW2(elem->name);
}

/*
 * call-seq:
 *  type
 *
 * Get the element content +type+.  Possible values are PCDATA, ELEMENT, SEQ,
 * or OR.
 */
static VALUE get_type(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  return INT2NUM((long)elem->type);
}

/*
 * call-seq:
 *  c1
 *
 * Get the first child.
 */
static VALUE get_c1(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  if(!elem->c1) return Qnil;
  return Nokogiri_wrap_element_content(rb_iv_get(self, "@document"), elem->c1);
}

/*
 * call-seq:
 *  c2
 *
 * Get the first child.
 */
static VALUE get_c2(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  if(!elem->c2) return Qnil;
  return Nokogiri_wrap_element_content(rb_iv_get(self, "@document"), elem->c2);
}

/*
 * call-seq:
 *  occur
 *
 * Get the element content +occur+ flag.  Possible values are ONCE, OPT, MULT
 * or PLUS.
 */
static VALUE get_occur(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  return INT2NUM((long)elem->ocur);
}

/*
 * call-seq:
 *  prefix
 *
 * Get the element content namespace +prefix+.
 */
static VALUE get_prefix(VALUE self)
{
  xmlElementContentPtr elem;
  Data_Get_Struct(self, xmlElementContent, elem);

  if(!elem->prefix) return Qnil;

  return NOKOGIRI_STR_NEW2(elem->prefix);
}

VALUE Nokogiri_wrap_element_content(VALUE doc, xmlElementContentPtr element)
{
  VALUE elem = Data_Wrap_Struct(cNokogiriXmlElementContent, 0, 0, element);

  /* Setting the document is necessary so that this does not get GC'd until */
  /* the document is GC'd */
  rb_iv_set(elem, "@document", doc);

  return elem;
}

void init_xml_element_content()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");

  VALUE klass = rb_define_class_under(xml, "ElementContent", rb_cObject);

  cNokogiriXmlElementContent = klass;

  rb_define_method(klass, "name", get_name, 0);
  rb_define_method(klass, "type", get_type, 0);
  rb_define_method(klass, "occur", get_occur, 0);
  rb_define_method(klass, "prefix", get_prefix, 0);

  rb_define_private_method(klass, "c1", get_c1, 0);
  rb_define_private_method(klass, "c2", get_c2, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             xml_element_content.h                                                                               0100644 0001750 0001750 00000000332 12566211316 045310  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ELEMENT_CONTENT
#define NOKOGIRI_XML_ELEMENT_CONTENT

#include <nokogiri.h>


VALUE Nokogiri_wrap_element_content(VALUE doc, xmlElementContentPtr element);
void init_xml_element_content();

#endif
                                                                                                                                                                                                                                                                                                      xml_element_decl.c                                                                                  0100644 0001750 0001750 00000002535 12566211316 044547  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_element_decl.h>

static ID id_document;

/*
 * call-seq:
 *  element_type
 *
 * The element_type
 */
static VALUE element_type(VALUE self)
{
  xmlElementPtr node;
  Data_Get_Struct(self, xmlElement, node);
  return INT2NUM((long)node->etype);
}

/*
 * call-seq:
 *  content
 *
 * The allowed content for this ElementDecl
 */
static VALUE content(VALUE self)
{
  xmlElementPtr node;
  Data_Get_Struct(self, xmlElement, node);

  if(!node->content) return Qnil;

  return Nokogiri_wrap_element_content(
      rb_funcall(self, id_document, 0),
      node->content
  );
}

/*
 * call-seq:
 *  prefix
 *
 * The namespace prefix for this ElementDecl
 */
static VALUE prefix(VALUE self)
{
  xmlElementPtr node;
  Data_Get_Struct(self, xmlElement, node);

  if(!node->prefix) return Qnil;

  return NOKOGIRI_STR_NEW2(node->prefix);
}

VALUE cNokogiriXmlElementDecl;

void init_xml_element_decl()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE klass = rb_define_class_under(xml, "ElementDecl", node);

  cNokogiriXmlElementDecl = klass;

  rb_define_method(klass, "element_type", element_type, 0);
  rb_define_method(klass, "content", content, 0);
  rb_define_method(klass, "prefix", prefix, 0);

  id_document = rb_intern("document");
}
                                                                                                                                                                   xml_element_decl.h                                                                                  0100644 0001750 0001750 00000000250 12566211316 044544  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ELEMENT_DECL
#define NOKOGIRI_XML_ELEMENT_DECL

#include <nokogiri.h>

void init_xml_element_decl();

extern VALUE cNokogiriXmlElementDecl;
#endif
                                                                                                                                                                                                                                                                                                                                                        xml_encoding_handler.c                                                                              0100644 0001750 0001750 00000003310 12566211316 045402  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_encoding_handler.h>

/*
 * call-seq: Nokogiri::EncodingHandler.[](name)
 *
 * Get the encoding handler for +name+
 */
static VALUE get(VALUE klass, VALUE key)
{
  xmlCharEncodingHandlerPtr handler;

  handler = xmlFindCharEncodingHandler(StringValuePtr(key));
  if(handler)
    return Data_Wrap_Struct(klass, NULL, NULL, handler);

  return Qnil;
}

/*
 * call-seq: Nokogiri::EncodingHandler.delete(name)
 *
 * Delete the encoding alias named +name+
 */
static VALUE delete(VALUE klass, VALUE name)
{
  if(xmlDelEncodingAlias(StringValuePtr(name))) return Qnil;

  return Qtrue;
}

/*
 * call-seq: Nokogiri::EncodingHandler.alias(from, to)
 *
 * Alias encoding handler with name +from+ to name +to+
 */
static VALUE alias(VALUE klass, VALUE from, VALUE to)
{
  xmlAddEncodingAlias(StringValuePtr(from), StringValuePtr(to));

  return to;
}

/*
 * call-seq: Nokogiri::EncodingHandler.clear_aliases!
 *
 * Remove all encoding aliases.
 */
static VALUE clear_aliases(VALUE klass)
{
  xmlCleanupEncodingAliases();

  return klass;
}

/*
 * call-seq: name
 *
 * Get the name of this EncodingHandler
 */
static VALUE name(VALUE self)
{
  xmlCharEncodingHandlerPtr handler;

  Data_Get_Struct(self, xmlCharEncodingHandler, handler);

  return NOKOGIRI_STR_NEW2(handler->name);
}

void init_xml_encoding_handler()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE klass = rb_define_class_under(nokogiri, "EncodingHandler", rb_cObject);

  rb_define_singleton_method(klass, "[]", get, 1);
  rb_define_singleton_method(klass, "delete", delete, 1);
  rb_define_singleton_method(klass, "alias", alias, 2);
  rb_define_singleton_method(klass, "clear_aliases!", clear_aliases, 0);
  rb_define_method(klass, "name", name, 0);
}
                                                                                                                                                                                                                                                                                                                        xml_encoding_handler.h                                                                              0100644 0001750 0001750 00000000216 12566211316 045411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ENCODING_HANDLER
#define NOKOGIRI_XML_ENCODING_HANDLER

#include <nokogiri.h>

void init_xml_encoding_handler();

#endif
                                                                                                                                                                                                                                                                                                                                                                                  xml_entity_decl.c                                                                                   0100644 0001750 0001750 00000005144 12566211316 044431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_entity_decl.h>

/*
 * call-seq:
 *  original_content
 *
 * Get the original_content before ref substitution
 */
static VALUE original_content(VALUE self)
{
  xmlEntityPtr node;
  Data_Get_Struct(self, xmlEntity, node);

  if(!node->orig) return Qnil;

  return NOKOGIRI_STR_NEW2(node->orig);
}

/*
 * call-seq:
 *  content
 *
 * Get the content
 */
static VALUE get_content(VALUE self)
{
  xmlEntityPtr node;
  Data_Get_Struct(self, xmlEntity, node);

  if(!node->content) return Qnil;

  return NOKOGIRI_STR_NEW(node->content, node->length);
}

/*
 * call-seq:
 *  entity_type
 *
 * Get the entity type
 */
static VALUE entity_type(VALUE self)
{
  xmlEntityPtr node;
  Data_Get_Struct(self, xmlEntity, node);

  return INT2NUM((int)node->etype);
}

/*
 * call-seq:
 *  external_id
 *
 * Get the external identifier for PUBLIC
 */
static VALUE external_id(VALUE self)
{
  xmlEntityPtr node;
  Data_Get_Struct(self, xmlEntity, node);

  if(!node->ExternalID) return Qnil;

  return NOKOGIRI_STR_NEW2(node->ExternalID);
}

/*
 * call-seq:
 *  system_id
 *
 * Get the URI for a SYSTEM or PUBLIC Entity
 */
static VALUE system_id(VALUE self)
{
  xmlEntityPtr node;
  Data_Get_Struct(self, xmlEntity, node);

  if(!node->SystemID) return Qnil;

  return NOKOGIRI_STR_NEW2(node->SystemID);
}

VALUE cNokogiriXmlEntityDecl;

void init_xml_entity_decl()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE klass = rb_define_class_under(xml, "EntityDecl", node);

  cNokogiriXmlEntityDecl = klass;

  rb_define_method(klass, "original_content", original_content, 0);
  rb_define_method(klass, "content", get_content, 0);
  rb_define_method(klass, "entity_type", entity_type, 0);
  rb_define_method(klass, "external_id", external_id, 0);
  rb_define_method(klass, "system_id", system_id, 0);

  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("INTERNAL_GENERAL"),
      INT2NUM(XML_INTERNAL_GENERAL_ENTITY));
  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("EXTERNAL_GENERAL_PARSED"),
      INT2NUM(XML_EXTERNAL_GENERAL_PARSED_ENTITY));
  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("EXTERNAL_GENERAL_UNPARSED"),
      INT2NUM(XML_EXTERNAL_GENERAL_UNPARSED_ENTITY));
  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("INTERNAL_PARAMETER"),
      INT2NUM(XML_INTERNAL_PARAMETER_ENTITY));
  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("EXTERNAL_PARAMETER"),
      INT2NUM(XML_EXTERNAL_PARAMETER_ENTITY));
  rb_const_set(cNokogiriXmlEntityDecl, rb_intern("INTERNAL_PREDEFINED"),
      INT2NUM(XML_INTERNAL_PREDEFINED_ENTITY));
}
                                                                                                                                                                                                                                                                                                                                                                                                                            xml_entity_decl.h                                                                                   0100644 0001750 0001750 00000000245 12566211316 044433  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ENTITY_DECL
#define NOKOGIRI_XML_ENTITY_DECL

#include <nokogiri.h>

void init_xml_entity_decl();

extern VALUE cNokogiriXmlEntityDecl;
#endif

                                                                                                                                                                                                                                                                                                                                                           xml_entity_reference.c                                                                              0100644 0001750 0001750 00000002244 12566211316 045456  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_entity_reference.h>

/*
 * call-seq:
 *  new(document, content)
 *
 * Create a new EntityReference element on the +document+ with +name+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  xmlNodePtr node;
  VALUE document;
  VALUE name;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &document, &name, &rest);

  Data_Get_Struct(document, xmlDoc, xml_doc);

  node = xmlNewReference(
      xml_doc,
      (const xmlChar *)StringValuePtr(name)
  );

  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(klass, node);
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlEntityReference;
void init_xml_entity_reference()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * EntityReference represents an EntityReference node in an xml document.
   */
  VALUE klass = rb_define_class_under(xml, "EntityReference", node);

  cNokogiriXmlEntityReference = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                                                                                                                                                                            xml_entity_reference.h                                                                              0100644 0001750 0001750 00000000270 12566211316 045460  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_ENTITY_REFERENCE
#define NOKOGIRI_XML_ENTITY_REFERENCE

#include <nokogiri.h>

void init_xml_entity_reference();

extern VALUE cNokogiriXmlEntityReference;
#endif
                                                                                                                                                                                                                                                                                                                                        xml_io.c                                                                                            0100644 0001750 0001750 00000002132 12566211316 042527  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_io.h>

static ID id_read, id_write;

VALUE read_check(VALUE *args) {
  return rb_funcall(args[0], id_read, 1, args[1]);
}

VALUE read_failed(void) {
	return Qnil;
}

int io_read_callback(void * ctx, char * buffer, int len) {
  VALUE string, args[2];
  size_t str_len, safe_len;

  args[0] = (VALUE)ctx;
  args[1] = INT2NUM(len);

  string = rb_rescue(read_check, (VALUE)args, read_failed, 0);

  if(NIL_P(string)) return 0;

  str_len = (size_t)RSTRING_LEN(string);
  safe_len = str_len > (size_t)len ? (size_t)len : str_len;
  memcpy(buffer, StringValuePtr(string), safe_len);

  return (int)safe_len;
}

VALUE write_check(VALUE *args) {
  return rb_funcall(args[0], id_write, 1, args[1]);
}

VALUE write_failed(void) {
	return Qnil;
}

int io_write_callback(void * ctx, char * buffer, int len) {
  VALUE args[2];

  args[0] = (VALUE)ctx;
  args[1] = rb_str_new(buffer, (long)len);

  rb_rescue(write_check, (VALUE)args, write_failed, 0);
  return len;
}

int io_close_callback(void * ctx) {
  return 0;
}

void init_nokogiri_io() {
  id_read = rb_intern("read");
  id_write = rb_intern("write");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                      xml_io.h                                                                                            0100644 0001750 0001750 00000000401 12566211316 042531  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_IO
#define NOKOGIRI_XML_IO

#include <nokogiri.h>

int io_read_callback(void * ctx, char * buffer, int len);
int io_write_callback(void * ctx, char * buffer, int len);
int io_close_callback(void * ctx);
void init_nokogiri_io();

#endif
                                                                                                                                                                                                                                                               xml_libxml2_hacks.c                                                                                 0100644 0001750 0001750 00000005633 12566211316 044653  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef HAVE_XMLFIRSTELEMENTCHILD
#include <libxml/tree.h>
/**
 * xmlFirstElementChild:
 * @parent: the parent node
 *
 * Finds the first child node of that element which is a Element node
 * Note the handling of entities references is different than in
 * the W3C DOM element traversal spec since we don't have back reference
 * from entities content to entities references.
 *
 * Returns the first element child or NULL if not available
 */
xmlNodePtr
xmlFirstElementChild(xmlNodePtr parent) {
    xmlNodePtr cur = NULL;

    if (parent == NULL)
        return(NULL);
    switch (parent->type) {
        case XML_ELEMENT_NODE:
        case XML_ENTITY_NODE:
        case XML_DOCUMENT_NODE:
        case XML_HTML_DOCUMENT_NODE:
            cur = parent->children;
            break;
        default:
            return(NULL);
    }
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE)
            return(cur);
        cur = cur->next;
    }
    return(NULL);
}

/**
 * xmlNextElementSibling:
 * @node: the current node
 *
 * Finds the first closest next sibling of the node which is an
 * element node.
 * Note the handling of entities references is different than in
 * the W3C DOM element traversal spec since we don't have back reference
 * from entities content to entities references.
 *
 * Returns the next element sibling or NULL if not available
 */
xmlNodePtr
xmlNextElementSibling(xmlNodePtr node) {
    if (node == NULL)
        return(NULL);
    switch (node->type) {
        case XML_ELEMENT_NODE:
        case XML_TEXT_NODE:
        case XML_CDATA_SECTION_NODE:
        case XML_ENTITY_REF_NODE:
        case XML_ENTITY_NODE:
        case XML_PI_NODE:
        case XML_COMMENT_NODE:
        case XML_DTD_NODE:
        case XML_XINCLUDE_START:
        case XML_XINCLUDE_END:
            node = node->next;
            break;
        default:
            return(NULL);
    }
    while (node != NULL) {
        if (node->type == XML_ELEMENT_NODE)
            return(node);
        node = node->next;
    }
    return(NULL);
}

/**
 * xmlLastElementChild:
 * @parent: the parent node
 *
 * Finds the last child node of that element which is a Element node
 * Note the handling of entities references is different than in
 * the W3C DOM element traversal spec since we don't have back reference
 * from entities content to entities references.
 *
 * Returns the last element child or NULL if not available
 */
xmlNodePtr
xmlLastElementChild(xmlNodePtr parent) {
    xmlNodePtr cur = NULL;

    if (parent == NULL)
        return(NULL);
    switch (parent->type) {
        case XML_ELEMENT_NODE:
        case XML_ENTITY_NODE:
        case XML_DOCUMENT_NODE:
        case XML_HTML_DOCUMENT_NODE:
            cur = parent->last;
            break;
        default:
            return(NULL);
    }
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE)
            return(cur);
        cur = cur->prev;
    }
    return(NULL);
}
#endif
                                                                                                     xml_libxml2_hacks.h                                                                                 0100644 0001750 0001750 00000000402 12566211316 044645  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef HAVE_XMLFIRSTELEMENTCHILD

#ifndef XML_LIBXML2_HACKS
#define XML_LIBXML2_HACKS

xmlNodePtr xmlFirstElementChild(xmlNodePtr parent);
xmlNodePtr xmlNextElementSibling(xmlNodePtr node);
xmlNodePtr xmlLastElementChild(xmlNodePtr parent);

#endif

#endif
                                                                                                                                                                                                                                                              xml_namespace.c                                                                                     0100644 0001750 0001750 00000003002 12566211316 044051  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_namespace.h>

VALUE cNokogiriXmlNamespace ;

/*
 * call-seq:
 *  prefix
 *
 * Get the prefix for this namespace.  Returns +nil+ if there is no prefix.
 */
static VALUE prefix(VALUE self)
{
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNs, ns);
  if(!ns->prefix) return Qnil;

  return NOKOGIRI_STR_NEW2(ns->prefix);
}

/*
 * call-seq:
 *  href
 *
 * Get the href for this namespace
 */
static VALUE href(VALUE self)
{
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNs, ns);
  if(!ns->href) return Qnil;

  return NOKOGIRI_STR_NEW2(ns->href);
}

VALUE Nokogiri_wrap_xml_namespace(xmlDocPtr doc, xmlNsPtr node)
{
  VALUE ns, document, node_cache;

  assert(doc->_private);

  if(node->_private)
    return (VALUE)node->_private;

  ns = Data_Wrap_Struct(cNokogiriXmlNamespace, 0, 0, node);

  document = DOC_RUBY_OBJECT(doc);

  node_cache = rb_iv_get(document, "@node_cache");
  rb_ary_push(node_cache, ns);

  rb_iv_set(ns, "@document", DOC_RUBY_OBJECT(doc));

  node->_private = (void *)ns;

  return ns;
}

VALUE Nokogiri_wrap_xml_namespace2(VALUE document, xmlNsPtr node)
{
  xmlDocPtr doc;
  Data_Get_Struct(document, xmlDoc, doc) ;
  return Nokogiri_wrap_xml_namespace(doc, node);
}


void init_xml_namespace()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE klass     = rb_define_class_under(xml, "Namespace", rb_cObject);

  cNokogiriXmlNamespace = klass;

  rb_define_method(klass, "prefix", prefix, 0);
  rb_define_method(klass, "href", href, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              xml_namespace.h                                                                                     0100644 0001750 0001750 00000000446 12566211316 044067  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_NAMESPACE
#define NOKOGIRI_XML_NAMESPACE

#include <nokogiri.h>

void init_xml_namespace();

extern VALUE cNokogiriXmlNamespace ;

VALUE Nokogiri_wrap_xml_namespace(xmlDocPtr doc, xmlNsPtr node) ;
VALUE Nokogiri_wrap_xml_namespace2(VALUE document, xmlNsPtr node) ;

#endif
                                                                                                                                                                                                                          xml_node.c                                                                                          0100644 0001750 0001750 00000107745 12566211316 043065  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_node.h>

static ID decorate, decorate_bang;

#ifdef DEBUG
static void debug_node_dealloc(xmlNodePtr x)
{
  NOKOGIRI_DEBUG_START(x)
  NOKOGIRI_DEBUG_END(x)
}
#else
#  define debug_node_dealloc 0
#endif

static void mark(xmlNodePtr node)
{
  rb_gc_mark(DOC_RUBY_OBJECT(node->doc));
}

/* :nodoc: */
typedef xmlNodePtr (*pivot_reparentee_func)(xmlNodePtr, xmlNodePtr);

/* :nodoc: */
static void relink_namespace(xmlNodePtr reparented)
{
  xmlNodePtr child;

  /* Avoid segv when relinking against unlinked nodes. */
  if(!reparented->parent) return;

  /* Make sure that our reparented node has the correct namespaces */
  if(!reparented->ns && reparented->doc != (xmlDocPtr)reparented->parent)
    xmlSetNs(reparented, reparented->parent->ns);

  /* Search our parents for an existing definition */
  if(reparented->nsDef) {
    xmlNsPtr curr = reparented->nsDef;
    xmlNsPtr prev = NULL;

    while(curr) {
      xmlNsPtr ns = xmlSearchNsByHref(
          reparented->doc,
          reparented->parent,
          curr->href
      );
      /* If we find the namespace is already declared, remove it from this
       * definition list. */
      if(ns && ns != curr) {
        if (prev) {
          prev->next = curr->next;
        } else {
          reparented->nsDef = curr->next;
        }
        nokogiri_root_nsdef(curr, reparented->doc);
      } else {
        prev = curr;
      }
      curr = curr->next;
    }
  }

  /* Only walk all children if there actually is a namespace we need to */
  /* reparent. */
  if(NULL == reparented->ns) return;

  /* When a node gets reparented, walk it's children to make sure that */
  /* their namespaces are reparented as well. */
  child = reparented->children;
  while(NULL != child) {
    relink_namespace(child);
    child = child->next;
  }
}

/* :nodoc: */
static xmlNodePtr xmlReplaceNodeWrapper(xmlNodePtr pivot, xmlNodePtr new_node)
{
  xmlNodePtr retval ;

  retval = xmlReplaceNode(pivot, new_node) ;

  if (retval == pivot) {
    retval = new_node ; /* return semantics for reparent_node_with */
  }

  /* work around libxml2 issue: https://bugzilla.gnome.org/show_bug.cgi?id=615612 */
  if (retval && retval->type == XML_TEXT_NODE) {
    if (retval->prev && retval->prev->type == XML_TEXT_NODE) {
      retval = xmlTextMerge(retval->prev, retval);
    }
    if (retval->next && retval->next->type == XML_TEXT_NODE) {
      retval = xmlTextMerge(retval, retval->next);
    }
  }

  return retval ;
}

/* :nodoc: */
static VALUE reparent_node_with(VALUE pivot_obj, VALUE reparentee_obj, pivot_reparentee_func prf)
{
  VALUE reparented_obj ;
  xmlNodePtr reparentee, pivot, reparented, next_text, new_next_text ;

  if(!rb_obj_is_kind_of(reparentee_obj, cNokogiriXmlNode))
    rb_raise(rb_eArgError, "node must be a Nokogiri::XML::Node");
  if(rb_obj_is_kind_of(reparentee_obj, cNokogiriXmlDocument))
    rb_raise(rb_eArgError, "node must be a Nokogiri::XML::Node");

  Data_Get_Struct(reparentee_obj, xmlNode, reparentee);
  Data_Get_Struct(pivot_obj, xmlNode, pivot);

  if(XML_DOCUMENT_NODE == reparentee->type || XML_HTML_DOCUMENT_NODE == reparentee->type)
    rb_raise(rb_eArgError, "cannot reparent a document node");

  xmlUnlinkNode(reparentee);

  if (reparentee->doc != pivot->doc || reparentee->type == XML_TEXT_NODE) {
    /*
     *  if the reparentee is a text node, there's a very good chance it will be
     *  merged with an adjacent text node after being reparented, and in that case
     *  libxml will free the underlying C struct.
     *
     *  since we clearly have a ruby object which references the underlying
     *  memory, we can't let the C struct get freed. let's pickle the original
     *  reparentee by rooting it; and then we'll reparent a duplicate of the
     *  node that we don't care about preserving.
     *
     *  alternatively, if the reparentee is from a different document than the
     *  pivot node, libxml2 is going to get confused about which document's
     *  "dictionary" the node's strings belong to (this is an otherwise
     *  uninteresting libxml2 implementation detail). as a result, we cannot
     *  reparent the actual reparentee, so we reparent a duplicate.
     */
    nokogiri_root_node(reparentee);
    if (!(reparentee = xmlDocCopyNode(reparentee, pivot->doc, 1))) {
      rb_raise(rb_eRuntimeError, "Could not reparent node (xmlDocCopyNode)");
    }
  }

  if (prf != xmlAddPrevSibling && prf != xmlAddNextSibling
      && reparentee->type == XML_TEXT_NODE && pivot->next && pivot->next->type == XML_TEXT_NODE) {
    /*
     *  libxml merges text nodes in a right-to-left fashion, meaning that if
     *  there are two text nodes who would be adjacent, the right (or following,
     *  or next) node will be merged into the left (or preceding, or previous)
     *  node.
     *
     *  and by "merged" I mean the string contents will be concatenated onto the
     *  left node's contents, and then the node will be freed.
     *
     *  which means that if we have a ruby object wrapped around the right node,
     *  its memory would be freed out from under it.
     *
     *  so, we detect this edge case and unlink-and-root the text node before it gets
     *  merged. then we dup the node and insert that duplicate back into the
     *  document where the real node was.
     *
     *  yes, this is totally lame.
     */
    next_text     = pivot->next ;
    new_next_text = xmlDocCopyNode(next_text, pivot->doc, 1) ;

    xmlUnlinkNode(next_text);
    nokogiri_root_node(next_text);

    xmlAddNextSibling(pivot, new_next_text);
  }

  if(!(reparented = (*prf)(pivot, reparentee))) {
    rb_raise(rb_eRuntimeError, "Could not reparent node");
  }

  /*
   *  make sure the ruby object is pointed at the just-reparented node, which
   *  might be a duplicate (see above) or might be the result of merging
   *  adjacent text nodes.
   */
  DATA_PTR(reparentee_obj) = reparented ;

  relink_namespace(reparented);

  reparented_obj = Nokogiri_wrap_xml_node(Qnil, reparented);

  rb_funcall(reparented_obj, decorate_bang, 0);

  return reparented_obj ;
}


/*
 * call-seq:
 *  document
 *
 * Get the document for this Node
 */
static VALUE document(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node->doc);
}

/*
 * call-seq:
 *  pointer_id
 *
 * Get the internal pointer number
 */
static VALUE pointer_id(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM((long)(node));
}

/*
 * call-seq:
 *  encode_special_chars(string)
 *
 * Encode any special characters in +string+
 */
static VALUE encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Data_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
      node->doc,
      (const xmlChar *)StringValuePtr(string)
  );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}

/*
 * call-seq:
 *  create_internal_subset(name, external_id, system_id)
 *
 * Create the internal subset of a document.
 *
 *   doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
 *   # => <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd">
 *
 *   doc.create_internal_subset("chapter", nil, "chapter.dtd")
 *   # => <!DOCTYPE chapter SYSTEM "chapter.dtd">
 */
static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node->doc;

  if(xmlGetIntSubset(doc))
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");

  dtd = xmlCreateIntSubset(
      doc,
      NIL_P(name)        ? NULL : (const xmlChar *)StringValuePtr(name),
      NIL_P(external_id) ? NULL : (const xmlChar *)StringValuePtr(external_id),
      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValuePtr(system_id)
  );

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}

/*
 * call-seq:
 *  create_external_subset(name, external_id, system_id)
 *
 * Create an external subset
 */
static VALUE create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node->doc;

  if(doc->extSubset)
    rb_raise(rb_eRuntimeError, "Document already has an external subset");

  dtd = xmlNewDtd(
      doc,
      NIL_P(name)        ? NULL : (const xmlChar *)StringValuePtr(name),
      NIL_P(external_id) ? NULL : (const xmlChar *)StringValuePtr(external_id),
      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValuePtr(system_id)
  );

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}

/*
 * call-seq:
 *  external_subset
 *
 * Get the external subset
 */
static VALUE external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node->doc) return Qnil;

  doc = node->doc;
  dtd = doc->extSubset;

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}

/*
 * call-seq:
 *  internal_subset
 *
 * Get the internal subset
 */
static VALUE internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node->doc) return Qnil;

  doc = node->doc;
  dtd = xmlGetIntSubset(doc);

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}

/*
 * call-seq:
 *  dup
 *
 * Copy this node.  An optional depth may be passed in, but it defaults
 * to a deep copy.  0 is a shallow copy, 1 is a deep copy.
 */
static VALUE duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE level;
  xmlNodePtr node, dup;

  if(rb_scan_args(argc, argv, "01", &level) == 0)
    level = INT2NUM((long)1);

  Data_Get_Struct(self, xmlNode, node);

  dup = xmlDocCopyNode(node, node->doc, (int)NUM2INT(level));
  if(dup == NULL) return Qnil;

  nokogiri_root_node(dup);

  return Nokogiri_wrap_xml_node(rb_obj_class(self), dup);
}

/*
 * call-seq:
 *  unlink
 *
 * Unlink this node from its current context.
 */
static VALUE unlink_node(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  nokogiri_root_node(node);
  return self;
}

/*
 * call-seq:
 *  blank?
 *
 * Is this node blank?
 */
static VALUE blank_eh(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}

/*
 * call-seq:
 *  next_sibling
 *
 * Returns the next sibling node
 */
static VALUE next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node->next;
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling) ;
}

/*
 * call-seq:
 *  previous_sibling
 *
 * Returns the previous sibling node
 */
static VALUE previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node->prev;
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}

/*
 * call-seq:
 *  next_element
 *
 * Returns the next Nokogiri::XML::Element type sibling node.
 */
static VALUE next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}

/*
 * call-seq:
 *  previous_element
 *
 * Returns the previous Nokogiri::XML::Element type sibling node.
 */
static VALUE previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node->prev;
  if(!sibling) return Qnil;

  while(sibling && sibling->type != XML_ELEMENT_NODE)
    sibling = sibling->prev;

  return sibling ? Nokogiri_wrap_xml_node(Qnil, sibling) : Qnil ;
}

/* :nodoc: */
static VALUE replace(VALUE self, VALUE new_node)
{
    VALUE reparent = reparent_node_with(self, new_node, xmlReplaceNodeWrapper);

    xmlNodePtr pivot;
    Data_Get_Struct(self, xmlNode, pivot);
    nokogiri_root_node(pivot);

    return reparent;
}

/*
 * call-seq:
 *  children
 *
 * Get the list of children for this node as a NodeSet
 */
static VALUE children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = node->children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node->doc);

  if(!child) return Nokogiri_wrap_xml_node_set(set, document);

  child = child->next;
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child->next;
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}

/*
 * call-seq:
 *  element_children
 *
 * Get the list of children for this node as a NodeSet.  All nodes will be
 * element nodes.
 *
 * Example:
 *
 *   @doc.root.element_children.all? { |x| x.element? } # => true
 */
static VALUE element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node->doc);

  if(!child) return Nokogiri_wrap_xml_node_set(set, document);

  child = xmlNextElementSibling(child);
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}

/*
 * call-seq:
 *  child
 *
 * Returns the child node
 */
static VALUE child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = node->children;
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}

/*
 * call-seq:
 *  first_element_child
 *
 * Returns the first child node of this node that is an element.
 *
 * Example:
 *
 *   @doc.root.first_element_child.element? # => true
 */
static VALUE first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}

/*
 * call-seq:
 *  last_element_child
 *
 * Returns the last child node of this node that is an element.
 *
 * Example:
 *
 *   @doc.root.last_element_child.element? # => true
 */
static VALUE last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}

/*
 * call-seq:
 *  key?(attribute)
 *
 * Returns true if +attribute+ is set
 */
static VALUE key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasProp(node, (xmlChar *)StringValuePtr(attribute)))
    return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  namespaced_key?(attribute, namespace)
 *
 * Returns true if +attribute+ is set with +namespace+
 */
static VALUE namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasNsProp(node, (xmlChar *)StringValuePtr(attribute),
        NIL_P(namespace) ? NULL : (xmlChar *)StringValuePtr(namespace)))
    return Qtrue;
  return Qfalse;
}

/*
 * call-seq:
 *  []=(property, value)
 *
 * Set the +property+ to +value+
 */
static VALUE set(VALUE self, VALUE property, VALUE value)
{
  xmlNodePtr node, cur;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);

  /* If a matching attribute node already exists, then xmlSetProp will destroy
   * the existing node's children. However, if Nokogiri has a node object
   * pointing to one of those children, we are left with a broken reference.
   *
   * We can avoid this by unlinking these nodes first.
   */
  if (node->type != XML_ELEMENT_NODE)
    return(Qnil);
  prop = xmlHasProp(node, (xmlChar *)StringValuePtr(property));
  if (prop && prop->children) {
    for (cur = prop->children; cur; cur = cur->next) {
      if (cur->_private) {
        nokogiri_root_node(cur);
        xmlUnlinkNode(cur);
      }
    }
  }

  xmlSetProp(node, (xmlChar *)StringValuePtr(property),
      (xmlChar *)StringValuePtr(value));

  return value;
}

/*
 * call-seq:
 *   get(attribute)
 *
 * Get the value for +attribute+
 */
static VALUE get(VALUE self, VALUE rattribute)
{
  xmlNodePtr node;
  xmlChar* value = 0;
  VALUE rvalue ;
  char* attribute = 0;
  char *colon = 0, *attr_name = 0, *prefix = 0;
  xmlNsPtr ns;

  if (NIL_P(rattribute)) return Qnil;

  Data_Get_Struct(self, xmlNode, node);
  attribute = strdup(StringValuePtr(rattribute));

  colon = strchr(attribute, ':');
  if (colon) {
    (*colon) = 0 ; /* create two null-terminated strings of the prefix and attribute name */
    prefix = attribute ;
    attr_name = colon + 1 ;
    ns = xmlSearchNs(node->doc, node, (const xmlChar *)(prefix));
    if (ns) {
      value = xmlGetNsProp(node, (xmlChar*)(attr_name), ns->href);
    }
  } else {
    value = xmlGetNoNsProp(node, (xmlChar*)attribute);
  }

  free(attribute);
  if (!value) return Qnil;

  rvalue = NOKOGIRI_STR_NEW2(value);
  xmlFree(value);

  return rvalue ;
}

/*
 * call-seq:
 *   set_namespace(namespace)
 *
 * Set the namespace to +namespace+
 */
static VALUE set_namespace(VALUE self, VALUE namespace)
{
  xmlNodePtr node;
  xmlNsPtr ns = NULL;

  Data_Get_Struct(self, xmlNode, node);

  if(!NIL_P(namespace))
    Data_Get_Struct(namespace, xmlNs, ns);

  xmlSetNs(node, ns);

  return self;
}

/*
 * call-seq:
 *   attribute(name)
 *
 * Get the attribute node with +name+
 */
static VALUE attr(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValuePtr(name));

  if(! prop) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}

/*
 * call-seq:
 *   attribute_with_ns(name, namespace)
 *
 * Get the attribute node with +name+ and +namespace+
 */
static VALUE attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValuePtr(name),
      NIL_P(namespace) ? NULL : (xmlChar *)StringValuePtr(namespace));

  if(! prop) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}

/*
 *  call-seq:
 *    attribute_nodes()
 *
 *  returns a list containing the Node attributes.
 */
static VALUE attribute_nodes(VALUE self)
{
    /* this code in the mode of xmlHasProp() */
    xmlNodePtr node;
    VALUE attr;

    Data_Get_Struct(self, xmlNode, node);

    attr = rb_ary_new();
    Nokogiri_xml_node_properties(node, attr);

    return attr ;
}


/*
 *  call-seq:
 *    namespace()
 *
 *  returns the default namespace set on this node (as with an "xmlns="
 *  attribute), as a Namespace object.
 */
static VALUE namespace(VALUE self)
{
  xmlNodePtr node ;
  Data_Get_Struct(self, xmlNode, node);

  if (node->ns)
    return Nokogiri_wrap_xml_namespace(node->doc, node->ns);

  return Qnil ;
}

/*
 *  call-seq:
 *    namespace_definitions()
 *
 *  returns namespaces defined on self element directly, as an array of Namespace objects. Includes both a default namespace (as in"xmlns="), and prefixed namespaces (as in "xmlns:prefix=").
 */
static VALUE namespace_definitions(VALUE self)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();

  ns = node->nsDef;

  if(!ns) return list;

  while(NULL != ns) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node->doc, ns));
    ns = ns->next;
  }

  return list;
}

/*
 *  call-seq:
 *    namespace_scopes()
 *
 * returns namespaces in scope for self -- those defined on self element
 * directly or any ancestor node -- as an array of Namespace objects.  Default
 * namespaces ("xmlns=" style) for self are included in this array; Default
 * namespaces for  ancestors, however, are not. See also #namespaces
 */
static VALUE namespace_scopes(VALUE self)
{
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr *ns_list;
  int j;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();
  ns_list = xmlGetNsList(node->doc, node);

  if(!ns_list) return list;

  for (j = 0 ; ns_list[j] != NULL ; ++j) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node->doc, ns_list[j]));
  }

  xmlFree(ns_list);
  return list;
}

/*
 * call-seq:
 *  node_type
 *
 * Get the type for this Node
 */
static VALUE node_type(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return INT2NUM((long)node->type);
}

/*
 * call-seq:
 *  content=
 *
 * Set the content for this Node
 */
static VALUE native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Data_Get_Struct(self, xmlNode, node);

  child = node->children;
  while (NULL != child) {
    next = child->next ;
    xmlUnlinkNode(child) ;
    nokogiri_root_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValuePtr(content));
  return content;
}

/*
 * call-seq:
 *  content
 *
 * Returns the content for this Node
 */
static VALUE get_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar * content;

  Data_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if(content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}

/* :nodoc: */
static VALUE add_child(VALUE self, VALUE new_child)
{
  return reparent_node_with(self, new_child, xmlAddChild);
}

/*
 * call-seq:
 *  parent
 *
 * Get the parent Node for this Node
 */
static VALUE get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Data_Get_Struct(self, xmlNode, node);

  parent = node->parent;
  if(!parent) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, parent) ;
}

/*
 * call-seq:
 *  name=(new_name)
 *
 * Set the name for this Node
 */
static VALUE set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar*)StringValuePtr(new_name));
  return new_name;
}

/*
 * call-seq:
 *  name
 *
 * Returns the name for this Node
 */
static VALUE get_name(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(node->name)
    return NOKOGIRI_STR_NEW2(node->name);
  return Qnil;
}

/*
 * call-seq:
 *  path
 *
 * Returns the path associated with this Node
 */
static VALUE path(VALUE self)
{
  xmlNodePtr node;
  xmlChar *path ;
  VALUE rval;

  Data_Get_Struct(self, xmlNode, node);

  path = xmlGetNodePath(node);
  rval = NOKOGIRI_STR_NEW2(path);
  xmlFree(path);
  return rval ;
}

/* :nodoc: */
static VALUE add_next_sibling(VALUE self, VALUE new_sibling)
{
  return reparent_node_with(self, new_sibling, xmlAddNextSibling) ;
}

/* :nodoc: */
static VALUE add_previous_sibling(VALUE self, VALUE new_sibling)
{
  return reparent_node_with(self, new_sibling, xmlAddPrevSibling) ;
}

/*
 * call-seq:
 *  native_write_to(io, encoding, options)
 *
 * Write this Node to +io+ with +encoding+ and +options+
 */
static VALUE native_write_to(
    VALUE self,
    VALUE io,
    VALUE encoding,
    VALUE indent_string,
    VALUE options
) {
  xmlNodePtr node;
  const char * before_indent;
  xmlSaveCtxtPtr savectx;

  Data_Get_Struct(self, xmlNode, node);

  xmlIndentTreeOutput = 1;

  before_indent = xmlTreeIndentString;

  xmlTreeIndentString = StringValuePtr(indent_string);

  savectx = xmlSaveToIO(
      (xmlOutputWriteCallback)io_write_callback,
      (xmlOutputCloseCallback)io_close_callback,
      (void *)io,
      RTEST(encoding) ? StringValuePtr(encoding) : NULL,
      (int)NUM2INT(options)
  );

  xmlSaveTree(savectx, node);
  xmlSaveClose(savectx);

  xmlTreeIndentString = before_indent;
  return io;
}

/*
 * call-seq:
 *  line
 *
 * Returns the line for this Node
 */
static VALUE line(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM(xmlGetLineNo(node));
}

/*
 * call-seq:
 *  add_namespace_definition(prefix, href)
 *
 * Adds a namespace definition with +prefix+ using +href+ value. The result is
 * as if parsed XML for this node had included an attribute
 * 'xmlns:prefix=value'.  A default namespace for this node ("xmlns=") can be
 * added by passing 'nil' for prefix. Namespaces added this way will not
 * show up in #attributes, but they will be included as an xmlns attribute
 * when the node is serialized to XML.
 */
static VALUE add_namespace_definition(VALUE self, VALUE prefix, VALUE href)
{
  xmlNodePtr node, namespacee;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);
  namespacee = node ;

  ns = xmlSearchNs(
      node->doc,
      node,
      (const xmlChar *)(NIL_P(prefix) ? NULL : StringValuePtr(prefix))
  );

  if(!ns) {
    if (node->type != XML_ELEMENT_NODE) {
      namespacee = node->parent;
    }
    ns = xmlNewNs(
        namespacee,
        (const xmlChar *)StringValuePtr(href),
        (const xmlChar *)(NIL_P(prefix) ? NULL : StringValuePtr(prefix))
    );
  }

  if (!ns) return Qnil ;

  if(NIL_P(prefix) || node != namespacee) xmlSetNs(node, ns);

  return Nokogiri_wrap_xml_namespace(node->doc, ns);
}

/*
 * call-seq:
 *   new(name, document)
 *
 * Create a new node with +name+ sharing GC lifecycle with +document+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  VALUE name;
  VALUE document;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &name, &document, &rest);

  Data_Get_Struct(document, xmlDoc, doc);

  node = xmlNewNode(NULL, (xmlChar *)StringValuePtr(name));
  node->doc = doc->doc;
  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(
      klass == cNokogiriXmlNode ? (VALUE)NULL : klass,
      node
  );
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

/*
 * call-seq:
 *  dump_html
 *
 * Returns the Node as html.
 */
static VALUE dump_html(VALUE self)
{
  xmlBufferPtr buf ;
  xmlNodePtr node ;
  VALUE html;

  Data_Get_Struct(self, xmlNode, node);

  buf = xmlBufferCreate() ;
  htmlNodeDump(buf, node->doc, node);
  html = NOKOGIRI_STR_NEW2(buf->content);
  xmlBufferFree(buf);
  return html ;
}

/*
 * call-seq:
 *  compare(other)
 *
 * Compare this Node to +other+ with respect to their Document
 */
static VALUE compare(VALUE self, VALUE _other)
{
  xmlNodePtr node, other;
  Data_Get_Struct(self, xmlNode, node);
  Data_Get_Struct(_other, xmlNode, other);

  return INT2NUM((long)xmlXPathCmpNodes(other, node));
}


/*
 * call-seq:
 *   process_xincludes(options)
 *
 * Loads and substitutes all xinclude elements below the node. The
 * parser context will be initialized with +options+.
 */
static VALUE process_xincludes(VALUE self, VALUE options)
{
  int rcode ;
  xmlNodePtr node;
  VALUE error_list = rb_ary_new();

  Data_Get_Struct(self, xmlNode, node);

  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
  rcode = xmlXIncludeProcessTreeFlags(node, (int)NUM2INT(options));
  xmlSetStructuredErrorFunc(NULL, NULL);

  if (rcode < 0) {
    xmlErrorPtr error;

    error = xmlGetLastError();
    if(error)
      rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
    else
      rb_raise(rb_eRuntimeError, "Could not perform xinclude substitution");
  }

  return self;
}


/* TODO: DOCUMENT ME */
static VALUE in_context(VALUE self, VALUE _str, VALUE _options)
{
    xmlNodePtr node, list = 0, child_iter, node_children, doc_children;
    xmlNodeSetPtr set;
    xmlParserErrors error;
    VALUE doc, err;
    int doc_is_empty;

    Data_Get_Struct(self, xmlNode, node);

    doc = DOC_RUBY_OBJECT(node->doc);
    err = rb_iv_get(doc, "@errors");
    doc_is_empty = (node->doc->children == NULL) ? 1 : 0;
    node_children = node->children;
    doc_children  = node->doc->children;

    xmlSetStructuredErrorFunc((void *)err, Nokogiri_error_array_pusher);

    /* Twiddle global variable because of a bug in libxml2.
     * http://git.gnome.org/browse/libxml2/commit/?id=e20fb5a72c83cbfc8e4a8aa3943c6be8febadab7
     */
#ifndef HTML_PARSE_NOIMPLIED
    htmlHandleOmittedElem(0);
#endif

    /* This function adds a fake node to the child of +node+.  If the parser
     * does not exit cleanly with XML_ERR_OK, the list is freed.  This can
     * leave the child pointers in a bad state if they were originally empty.
     *
     * http://git.gnome.org/browse/libxml2/tree/parser.c#n13177
     * */
    error = xmlParseInNodeContext(node, StringValuePtr(_str),
				  (int)RSTRING_LEN(_str),
				  (int)NUM2INT(_options), &list);

    /* xmlParseInNodeContext should not mutate the original document or node,
     * so reassigning these pointers should be OK.  The reason we're reassigning
     * is because if there were errors, it's possible for the child pointers
     * to be manipulated. */
    if (error != XML_ERR_OK) {
      node->doc->children = doc_children;
      node->children = node_children;
    }

    /* make sure parent/child pointers are coherent so an unlink will work
     * properly (#331)
     */
    child_iter = node->doc->children ;
    while (child_iter) {
      if (child_iter->parent != (xmlNodePtr)node->doc)
        child_iter->parent = (xmlNodePtr)node->doc;
      child_iter = child_iter->next;
    }

#ifndef HTML_PARSE_NOIMPLIED
    htmlHandleOmittedElem(1);
#endif

    xmlSetStructuredErrorFunc(NULL, NULL);

    /* Workaround for a libxml2 bug where a parsing error may leave a broken
     * node reference in node->doc->children.
     * This workaround is limited to when a parse error occurs, the document
     * went from having no children to having children, and the context node is
     * part of a document fragment.
     * https://bugzilla.gnome.org/show_bug.cgi?id=668155
     */
    if (error != XML_ERR_OK && doc_is_empty && node->doc->children != NULL) {
      child_iter = node;
      while (child_iter->parent)
        child_iter = child_iter->parent;

      if (child_iter->type == XML_DOCUMENT_FRAG_NODE)
        node->doc->children = NULL;
    }

    /* FIXME: This probably needs to handle more constants... */
    switch (error) {
      case XML_ERR_INTERNAL_ERROR:
      case XML_ERR_NO_MEMORY:
	rb_raise(rb_eRuntimeError, "error parsing fragment (%d)", error);
	break;
      default:
	break;
    }

    set = xmlXPathNodeSetCreate(NULL);

    while (list) {
      xmlXPathNodeSetAddUnique(set, list);
      list = list->next;
    }

    return Nokogiri_wrap_xml_node_set(set, doc);
}


VALUE Nokogiri_wrap_xml_node(VALUE klass, xmlNodePtr node)
{
  VALUE document = Qnil ;
  VALUE node_cache = Qnil ;
  VALUE rb_node = Qnil ;
  nokogiriTuplePtr node_has_a_document;
  xmlDocPtr doc;
  void (*mark_method)(xmlNodePtr) = NULL ;

  assert(node);

  if(node->type == XML_DOCUMENT_NODE || node->type == XML_HTML_DOCUMENT_NODE)
      return DOC_RUBY_OBJECT(node->doc);

  /* It's OK if the node doesn't have a fully-realized document (as in XML::Reader). */
  /* see https://github.com/sparklemotion/nokogiri/issues/95 */
  /* and https://github.com/sparklemotion/nokogiri/issues/439 */
  doc = node->doc;
  if (doc->type == XML_DOCUMENT_FRAG_NODE) doc = doc->doc;
  node_has_a_document = DOC_RUBY_OBJECT_TEST(doc);

  if(node->_private && node_has_a_document)
    return (VALUE)node->_private;

  if(!RTEST(klass)) {
    switch(node->type)
    {
    case XML_ELEMENT_NODE:
      klass = cNokogiriXmlElement;
      break;
    case XML_TEXT_NODE:
      klass = cNokogiriXmlText;
      break;
    case XML_ATTRIBUTE_NODE:
      klass = cNokogiriXmlAttr;
      break;
    case XML_ENTITY_REF_NODE:
      klass = cNokogiriXmlEntityReference;
      break;
    case XML_COMMENT_NODE:
      klass = cNokogiriXmlComment;
      break;
    case XML_DOCUMENT_FRAG_NODE:
      klass = cNokogiriXmlDocumentFragment;
      break;
    case XML_PI_NODE:
      klass = cNokogiriXmlProcessingInstruction;
      break;
    case XML_ENTITY_DECL:
      klass = cNokogiriXmlEntityDecl;
      break;
    case XML_CDATA_SECTION_NODE:
      klass = cNokogiriXmlCData;
      break;
    case XML_DTD_NODE:
      klass = cNokogiriXmlDtd;
      break;
    case XML_ATTRIBUTE_DECL:
      klass = cNokogiriXmlAttributeDecl;
      break;
    case XML_ELEMENT_DECL:
      klass = cNokogiriXmlElementDecl;
      break;
    default:
      klass = cNokogiriXmlNode;
    }
  }

  mark_method = node_has_a_document ? mark : NULL ;

  rb_node = Data_Wrap_Struct(klass, mark_method, debug_node_dealloc, node) ;
  node->_private = (void *)rb_node;

  if (node_has_a_document) {
    document = DOC_RUBY_OBJECT(doc);
    node_cache = DOC_NODE_CACHE(doc);
    rb_ary_push(node_cache, rb_node);
    rb_funcall(document, decorate, 1, rb_node);
  }

  return rb_node ;
}


void Nokogiri_xml_node_properties(xmlNodePtr node, VALUE attr_list)
{
  xmlAttrPtr prop;
  prop = node->properties ;
  while (prop != NULL) {
    rb_ary_push(attr_list, Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop));
    prop = prop->next ;
  }
}

VALUE cNokogiriXmlNode ;
VALUE cNokogiriXmlElement ;

void init_xml_node()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE klass = rb_define_class_under(xml, "Node", rb_cObject);

  cNokogiriXmlNode = klass;

  cNokogiriXmlElement = rb_define_class_under(xml, "Element", klass);

  rb_define_singleton_method(klass, "new", new, -1);

  rb_define_method(klass, "add_namespace_definition", add_namespace_definition, 2);
  rb_define_method(klass, "node_name", get_name, 0);
  rb_define_method(klass, "document", document, 0);
  rb_define_method(klass, "node_name=", set_name, 1);
  rb_define_method(klass, "parent", get_parent, 0);
  rb_define_method(klass, "child", child, 0);
  rb_define_method(klass, "first_element_child", first_element_child, 0);
  rb_define_method(klass, "last_element_child", last_element_child, 0);
  rb_define_method(klass, "children", children, 0);
  rb_define_method(klass, "element_children", element_children, 0);
  rb_define_method(klass, "next_sibling", next_sibling, 0);
  rb_define_method(klass, "previous_sibling", previous_sibling, 0);
  rb_define_method(klass, "next_element", next_element, 0);
  rb_define_method(klass, "previous_element", previous_element, 0);
  rb_define_method(klass, "node_type", node_type, 0);
  rb_define_method(klass, "content", get_content, 0);
  rb_define_method(klass, "path", path, 0);
  rb_define_method(klass, "key?", key_eh, 1);
  rb_define_method(klass, "namespaced_key?", namespaced_key_eh, 2);
  rb_define_method(klass, "blank?", blank_eh, 0);
  rb_define_method(klass, "attribute_nodes", attribute_nodes, 0);
  rb_define_method(klass, "attribute", attr, 1);
  rb_define_method(klass, "attribute_with_ns", attribute_with_ns, 2);
  rb_define_method(klass, "namespace", namespace, 0);
  rb_define_method(klass, "namespace_definitions", namespace_definitions, 0);
  rb_define_method(klass, "namespace_scopes", namespace_scopes, 0);
  rb_define_method(klass, "encode_special_chars", encode_special_chars, 1);
  rb_define_method(klass, "dup", duplicate_node, -1);
  rb_define_method(klass, "unlink", unlink_node, 0);
  rb_define_method(klass, "internal_subset", internal_subset, 0);
  rb_define_method(klass, "external_subset", external_subset, 0);
  rb_define_method(klass, "create_internal_subset", create_internal_subset, 3);
  rb_define_method(klass, "create_external_subset", create_external_subset, 3);
  rb_define_method(klass, "pointer_id", pointer_id, 0);
  rb_define_method(klass, "line", line, 0);
  rb_define_method(klass, "native_content=", native_content, 1);

  rb_define_private_method(klass, "process_xincludes", process_xincludes, 1);
  rb_define_private_method(klass, "in_context", in_context, 2);
  rb_define_private_method(klass, "add_child_node", add_child, 1);
  rb_define_private_method(klass, "add_previous_sibling_node", add_previous_sibling, 1);
  rb_define_private_method(klass, "add_next_sibling_node", add_next_sibling, 1);
  rb_define_private_method(klass, "replace_node", replace, 1);
  rb_define_private_method(klass, "dump_html", dump_html, 0);
  rb_define_private_method(klass, "native_write_to", native_write_to, 4);
  rb_define_private_method(klass, "get", get, 1);
  rb_define_private_method(klass, "set", set, 2);
  rb_define_private_method(klass, "set_namespace", set_namespace, 1);
  rb_define_private_method(klass, "compare", compare, 1);

  decorate      = rb_intern("decorate");
  decorate_bang = rb_intern("decorate!");
}

/* vim: set noet sw=4 sws=4 */
                           xml_node.h                                                                                          0100644 0001750 0001750 00000000461 12566211316 043055  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_NODE
#define NOKOGIRI_XML_NODE

#include <nokogiri.h>

void init_xml_node();

extern VALUE cNokogiriXmlNode ;
extern VALUE cNokogiriXmlElement ;

VALUE Nokogiri_wrap_xml_node(VALUE klass, xmlNodePtr node) ;
void Nokogiri_xml_node_properties(xmlNodePtr node, VALUE attr_hash) ;
#endif
                                                                                                                                                                                                               xml_node_set.c                                                                                      0100644 0001750 0001750 00000030713 12566211316 043726  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_node_set.h>
#include <libxml/xpathInternals.h>

static ID decorate ;

static int dealloc_namespace(xmlNsPtr ns)
{
  if (ns->href)
    xmlFree((xmlChar *)ns->href);
  if (ns->prefix)
    xmlFree((xmlChar *)ns->prefix);
  xmlFree(ns);
  return ST_CONTINUE;
}

static void deallocate(nokogiriNodeSetTuple *tuple)
{
  /*
   *  xmlXPathFreeNodeSet() contains an implicit assumption that it is being
   *  called before any of its pointed-to nodes have been free()d. this
   *  assumption lies in the operation where it dereferences nodeTab pointers
   *  while searching for namespace nodes to free.
   *
   *  however, since Ruby's GC mechanism cannot guarantee the strict order in
   *  which ruby objects will be GC'd, nodes may be garbage collected before a
   *  nodeset containing pointers to those nodes. (this is true regardless of
   *  how we declare dependencies between objects with rb_gc_mark().)
   *
   *  as a result, xmlXPathFreeNodeSet() will perform unsafe memory operations,
   *  and calling it would be evil.
   *
   *  so here, we *manually* free the set of namespace nodes that was
   *  constructed at initialization time (see Nokogiri_wrap_xml_node_set()), as
   *  well as the NodeSet, without using the official xmlXPathFreeNodeSet().
   *
   *  there's probably a lesson in here somewhere about intermingling, within a
   *  single array, structs with different memory-ownership semantics. or more
   *  generally, a lesson about building an API in C/C++ that does not contain
   *  assumptions about the strict order in which memory will be released. hey,
   *  that sounds like a great idea for a blog post! get to it!
   *
   *  "In Valgrind We Trust." seriously.
   */
  xmlNodeSetPtr node_set;

  node_set = tuple->node_set;

  if (!node_set)
    return;

  NOKOGIRI_DEBUG_START(node_set) ;
  st_foreach(tuple->namespaces, dealloc_namespace, 0);

  if (node_set->nodeTab != NULL)
    xmlFree(node_set->nodeTab);

  xmlFree(node_set);
  st_free_table(tuple->namespaces);
  free(tuple);
  NOKOGIRI_DEBUG_END(node_set) ;
}

static VALUE allocate(VALUE klass)
{
  return Nokogiri_wrap_xml_node_set(xmlXPathNodeSetCreate(NULL), Qnil);
}


/*
 * call-seq:
 *  dup
 *
 * Duplicate this node set
 */
static VALUE duplicate(VALUE self)
{
  nokogiriNodeSetTuple *tuple;
  xmlNodeSetPtr dupl;

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);

  dupl = xmlXPathNodeSetMerge(NULL, tuple->node_set);

  return Nokogiri_wrap_xml_node_set(dupl, rb_iv_get(self, "@document"));
}

/*
 * call-seq:
 *  length
 *
 * Get the length of the node set
 */
static VALUE length(VALUE self)
{
  nokogiriNodeSetTuple *tuple;
  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);

  return tuple->node_set ? INT2NUM(tuple->node_set->nodeNr) : INT2NUM(0);
}

/*
 * call-seq:
 *  push(node)
 *
 * Append +node+ to the NodeSet.
 */
static VALUE push(VALUE self, VALUE rb_node)
{
  nokogiriNodeSetTuple *tuple;
  xmlNodePtr node;

  if(!(rb_obj_is_kind_of(rb_node, cNokogiriXmlNode) || rb_obj_is_kind_of(rb_node, cNokogiriXmlNamespace)))
    rb_raise(rb_eArgError, "node must be a Nokogiri::XML::Node or Nokogiri::XML::Namespace");

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  Data_Get_Struct(rb_node, xmlNode, node);
  xmlXPathNodeSetAdd(tuple->node_set, node);
  return self;
}

/*
 *  call-seq:
 *    delete(node)
 *
 *  Delete +node+ from the Nodeset, if it is a member. Returns the deleted node
 *  if found, otherwise returns nil.
 */
static VALUE
delete(VALUE self, VALUE rb_node)
{
    nokogiriNodeSetTuple *tuple;
    xmlNodePtr node;
    xmlNodeSetPtr cur;
    int i;

    if (!(rb_obj_is_kind_of(rb_node, cNokogiriXmlNode) || rb_obj_is_kind_of(rb_node, cNokogiriXmlNamespace)))
	rb_raise(rb_eArgError, "node must be a Nokogiri::XML::Node or Nokogiri::XML::Namespace");

    Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
    Data_Get_Struct(rb_node, xmlNode, node);
    cur = tuple->node_set;

    if (xmlXPathNodeSetContains(cur, node)) {
	for (i = 0; i < cur->nodeNr; i++)
	    if (cur->nodeTab[i] == node) break;

	cur->nodeNr--;
	for (;i < cur->nodeNr;i++)
	    cur->nodeTab[i] = cur->nodeTab[i + 1];
	cur->nodeTab[cur->nodeNr] = NULL;
	return rb_node;
    }
    return Qnil ;
}


/*
 * call-seq:
 *  &(node_set)
 *
 * Set Intersection  Returns a new NodeSet containing nodes common to the two NodeSets.
 */
static VALUE intersection(VALUE self, VALUE rb_other)
{
  nokogiriNodeSetTuple *tuple, *other;
  xmlNodeSetPtr intersection;

  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))
    rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  Data_Get_Struct(rb_other, nokogiriNodeSetTuple, other);

  intersection = xmlXPathIntersection(tuple->node_set, other->node_set);
  return Nokogiri_wrap_xml_node_set(intersection, rb_iv_get(self, "@document"));
}


/*
 * call-seq:
 *  include?(node)
 *
 *  Returns true if any member of node set equals +node+.
 */
static VALUE include_eh(VALUE self, VALUE rb_node)
{
  nokogiriNodeSetTuple *tuple;
  xmlNodePtr node;

  if(!(rb_obj_is_kind_of(rb_node, cNokogiriXmlNode) || rb_obj_is_kind_of(rb_node, cNokogiriXmlNamespace)))
    rb_raise(rb_eArgError, "node must be a Nokogiri::XML::Node or Nokogiri::XML::Namespace");

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  Data_Get_Struct(rb_node, xmlNode, node);

  return (xmlXPathNodeSetContains(tuple->node_set, node) ? Qtrue : Qfalse);
}


/*
 * call-seq:
 *  |(node_set)
 *
 * Returns a new set built by merging the set and the elements of the given
 * set.
 */
static VALUE set_union(VALUE self, VALUE rb_other)
{
  nokogiriNodeSetTuple *tuple, *other;
  xmlNodeSetPtr new;

  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))
    rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  Data_Get_Struct(rb_other, nokogiriNodeSetTuple, other);

  new = xmlXPathNodeSetMerge(NULL, tuple->node_set);
  new = xmlXPathNodeSetMerge(new, other->node_set);

  return Nokogiri_wrap_xml_node_set(new, rb_iv_get(self, "@document"));
}

/*
 * call-seq:
 *  -(node_set)
 *
 *  Difference - returns a new NodeSet that is a copy of this NodeSet, removing
 *  each item that also appears in +node_set+
 */
static VALUE minus(VALUE self, VALUE rb_other)
{
  nokogiriNodeSetTuple *tuple, *other;
  xmlNodeSetPtr new;
  int j ;

  if(!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet))
    rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  Data_Get_Struct(rb_other, nokogiriNodeSetTuple, other);

  new = xmlXPathNodeSetMerge(NULL, tuple->node_set);
  for (j = 0 ; j < other->node_set->nodeNr ; ++j) {
    xmlXPathNodeSetDel(new, other->node_set->nodeTab[j]);
  }

  return Nokogiri_wrap_xml_node_set(new, rb_iv_get(self, "@document"));
}


static VALUE index_at(VALUE self, long offset)
{
  xmlNodeSetPtr node_set;
  nokogiriNodeSetTuple *tuple;

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  node_set = tuple->node_set;

  if (offset >= node_set->nodeNr || abs((int)offset) > node_set->nodeNr)
    return Qnil;

  if (offset < 0)
    offset += node_set->nodeNr;

  if (XML_NAMESPACE_DECL == node_set->nodeTab[offset]->type)
    return Nokogiri_wrap_xml_namespace2(rb_iv_get(self, "@document"), (xmlNsPtr)(node_set->nodeTab[offset]));
  return Nokogiri_wrap_xml_node(Qnil, node_set->nodeTab[offset]);
}

static VALUE subseq(VALUE self, long beg, long len)
{
  long j;
  nokogiriNodeSetTuple *tuple;
  xmlNodeSetPtr node_set;
  xmlNodeSetPtr new_set ;

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  node_set = tuple->node_set;

  if (beg > node_set->nodeNr) return Qnil ;
  if (beg < 0 || len < 0) return Qnil ;

  if ((beg + len) > node_set->nodeNr) {
    len = node_set->nodeNr - beg ;
  }

  new_set = xmlXPathNodeSetCreate(NULL);
  for (j = beg ; j < beg+len ; ++j) {
    xmlXPathNodeSetAddUnique(new_set, node_set->nodeTab[j]);
  }
  return Nokogiri_wrap_xml_node_set(new_set, rb_iv_get(self, "@document"));
}

/*
 * call-seq:
 *  [index] -> Node or nil
 *  [start, length] -> NodeSet or nil
 *  [range] -> NodeSet or nil
 *  slice(index) -> Node or nil
 *  slice(start, length) -> NodeSet or nil
 *  slice(range) -> NodeSet or nil
 *
 * Element reference - returns the node at +index+, or returns a NodeSet
 * containing nodes starting at +start+ and continuing for +length+ elements, or
 * returns a NodeSet containing nodes specified by +range+. Negative +indices+
 * count backward from the end of the +node_set+ (-1 is the last node). Returns
 * nil if the +index+ (or +start+) are out of range.
 */
static VALUE slice(int argc, VALUE *argv, VALUE self)
{
  VALUE arg ;
  long beg, len ;
  xmlNodeSetPtr node_set;
  nokogiriNodeSetTuple *tuple;
  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  node_set = tuple->node_set;

  if (argc == 2) {
    beg = NUM2LONG(argv[0]);
    len = NUM2LONG(argv[1]);
    if (beg < 0) {
      beg += node_set->nodeNr ;
    }
    return subseq(self, beg, len);
  }

  if (argc != 1) {
    rb_scan_args(argc, argv, "11", NULL, NULL);
  }
  arg = argv[0];

  if (FIXNUM_P(arg)) {
    return index_at(self, FIX2LONG(arg));
  }
  
  /* if arg is Range */
  switch (rb_range_beg_len(arg, &beg, &len, (long)node_set->nodeNr, 0)) {
  case Qfalse:
    break;
  case Qnil:
    return Qnil;
  default:
    return subseq(self, beg, len);
  }

  return index_at(self, NUM2LONG(arg));
}


/*
 * call-seq:
 *  to_a
 *
 * Return this list as an Array
 */
static VALUE to_array(VALUE self, VALUE rb_node)
{
  xmlNodeSetPtr set;
  VALUE *elts;
  VALUE list;
  int i;
  nokogiriNodeSetTuple *tuple;

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  set = tuple->node_set;

  elts = calloc((size_t)set->nodeNr, sizeof(VALUE *));
  for(i = 0; i < set->nodeNr; i++) {
    if (XML_NAMESPACE_DECL == set->nodeTab[i]->type)
      elts[i] = Nokogiri_wrap_xml_namespace2(rb_iv_get(self, "@document"), (xmlNsPtr)(set->nodeTab[i]));
    else
      elts[i] = Nokogiri_wrap_xml_node(Qnil, set->nodeTab[i]);
  }

  list = rb_ary_new4((long)set->nodeNr, elts);

  /*free(elts); */

  return list;
}

/*
 *  call-seq:
 *    unlink
 *
 * Unlink this NodeSet and all Node objects it contains from their current context.
 */
static VALUE unlink_nodeset(VALUE self)
{
  xmlNodeSetPtr node_set;
  int j, nodeNr ;
  nokogiriNodeSetTuple *tuple;

  Data_Get_Struct(self, nokogiriNodeSetTuple, tuple);
  node_set = tuple->node_set;
  nodeNr = node_set->nodeNr ;
  for (j = 0 ; j < nodeNr ; j++) {
    if (XML_NAMESPACE_DECL != node_set->nodeTab[j]->type) {
      VALUE node ;
      xmlNodePtr node_ptr;
      node = Nokogiri_wrap_xml_node(Qnil, node_set->nodeTab[j]);
      rb_funcall(node, rb_intern("unlink"), 0); /* modifies the C struct out from under the object */
      Data_Get_Struct(node, xmlNode, node_ptr);
      node_set->nodeTab[j] = node_ptr ;
    }
  }
  return self ;
}

VALUE Nokogiri_wrap_xml_node_set(xmlNodeSetPtr node_set, VALUE document)
{
  VALUE new_set ;
  int i;
  xmlNodePtr cur;
  xmlNsPtr ns;
  nokogiriNodeSetTuple *tuple;

  new_set = Data_Make_Struct(cNokogiriXmlNodeSet, nokogiriNodeSetTuple, 0,
			     deallocate, tuple);

  tuple->node_set = node_set;
  tuple->namespaces = st_init_numtable();

  if (!NIL_P(document)) {
    rb_iv_set(new_set, "@document", document);
    rb_funcall(document, decorate, 1, new_set);
  }

  if (node_set && node_set->nodeTab) {
    for (i = 0; i < node_set->nodeNr; i++) {
      cur = node_set->nodeTab[i];
      if (cur && cur->type == XML_NAMESPACE_DECL) {
        ns = (xmlNsPtr)cur;
        if (ns->next && ns->next->type != XML_NAMESPACE_DECL)
          st_insert(tuple->namespaces, (st_data_t)cur, (st_data_t)0);
      }
    }
  }

  return new_set ;
}

VALUE cNokogiriXmlNodeSet ;
void init_xml_node_set(void)
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml      = rb_define_module_under(nokogiri, "XML");
  VALUE klass    = rb_define_class_under(xml, "NodeSet", rb_cObject);
  cNokogiriXmlNodeSet = klass;

  rb_define_alloc_func(klass, allocate);
  rb_define_method(klass, "length", length, 0);
  rb_define_method(klass, "[]", slice, -1);
  rb_define_method(klass, "slice", slice, -1);
  rb_define_method(klass, "push", push, 1);
  rb_define_method(klass, "|", set_union, 1);
  rb_define_method(klass, "-", minus, 1);
  rb_define_method(klass, "unlink", unlink_nodeset, 0);
  rb_define_method(klass, "to_a", to_array, 0);
  rb_define_method(klass, "dup", duplicate, 0);
  rb_define_method(klass, "delete", delete, 1);
  rb_define_method(klass, "&", intersection, 1);
  rb_define_method(klass, "include?", include_eh, 1);

  decorate = rb_intern("decorate");
}
                                                     xml_node_set.h                                                                                      0100644 0001750 0001750 00000000531 12566211316 043726  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_NODE_SET
#define NOKOGIRI_XML_NODE_SET

#include <nokogiri.h>
void init_xml_node_set();

extern VALUE cNokogiriXmlNodeSet ;
VALUE Nokogiri_wrap_xml_node_set(xmlNodeSetPtr node_set, VALUE document) ;

typedef struct _nokogiriNodeSetTuple {
  xmlNodeSetPtr node_set;
  st_table     *namespaces;
} nokogiriNodeSetTuple;
#endif
                                                                                                                                                                       xml_processing_instruction.c                                                                        0100644 0001750 0001750 00000002466 12566211316 046747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_processing_instruction.h>

/*
 * call-seq:
 *  new(document, name, content)
 *
 * Create a new ProcessingInstruction element on the +document+ with +name+
 * and +content+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr xml_doc;
  xmlNodePtr node;
  VALUE document;
  VALUE name;
  VALUE content;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "3*", &document, &name, &content, &rest);

  Data_Get_Struct(document, xmlDoc, xml_doc);

  node = xmlNewDocPI(
      xml_doc,
      (const xmlChar *)StringValuePtr(name),
      (const xmlChar *)StringValuePtr(content)
  );

  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(klass, node);
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlProcessingInstruction;
void init_xml_processing_instruction()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);

  /*
   * ProcessingInstruction represents a ProcessingInstruction node in an xml
   * document.
   */
  VALUE klass = rb_define_class_under(xml, "ProcessingInstruction", node);

  cNokogiriXmlProcessingInstruction = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                          xml_processing_instruction.h                                                                        0100644 0001750 0001750 00000000320 12566211316 046737  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_PROCESSING_INSTRUCTION
#define NOKOGIRI_XML_PROCESSING_INSTRUCTION

#include <nokogiri.h>

void init_xml_processing_instruction();

extern VALUE cNokogiriXmlProcessingInstruction;
#endif
                                                                                                                                                                                                                                                                                                                xml_reader.c                                                                                        0100644 0001750 0001750 00000035413 12566211316 043372  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_reader.h>

static void dealloc(xmlTextReaderPtr reader)
{
  NOKOGIRI_DEBUG_START(reader);
  xmlFreeTextReader(reader);
  NOKOGIRI_DEBUG_END(reader);
}

static int has_attributes(xmlTextReaderPtr reader)
{
  /*
   *  this implementation of xmlTextReaderHasAttributes explicitly includes
   *  namespaces and properties, because some earlier versions ignore
   *  namespaces.
   */
  xmlNodePtr node ;
  node = xmlTextReaderCurrentNode(reader);
  if (node == NULL)
    return(0);

  if ((node->type == XML_ELEMENT_NODE) &&
      ((node->properties != NULL) || (node->nsDef != NULL)))
    return(1);
  return(0);
}

#define XMLNS_PREFIX "xmlns"
#define XMLNS_PREFIX_LEN 6 /* including either colon or \0 */
#define XMLNS_BUFFER_LEN 128
static void Nokogiri_xml_node_namespaces(xmlNodePtr node, VALUE attr_hash)
{
  xmlNsPtr ns;
  static char buffer[XMLNS_BUFFER_LEN] ;
  char *key ;
  size_t keylen ;

  if (node->type != XML_ELEMENT_NODE) return ;

  ns = node->nsDef;
  while (ns != NULL) {

    keylen = XMLNS_PREFIX_LEN + (ns->prefix ? (strlen((const char*)ns->prefix) + 1) : 0) ;
    if (keylen > XMLNS_BUFFER_LEN) {
      key = (char*)malloc(keylen) ;
    } else {
      key = buffer ;
    }

    if (ns->prefix) {
      sprintf(key, "%s:%s", XMLNS_PREFIX, ns->prefix);
    } else {
      sprintf(key, "%s", XMLNS_PREFIX);
    }

    rb_hash_aset(attr_hash,
        NOKOGIRI_STR_NEW2(key),
        (ns->href ? NOKOGIRI_STR_NEW2(ns->href) : Qnil)
    );
    if (key != buffer) {
      free(key);
    }
    ns = ns->next ;
  }
}


/*
 * call-seq:
 *   default?
 *
 * Was an attribute generated from the default value in the DTD or schema?
 */
static VALUE default_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  int eh;

  Data_Get_Struct(self, xmlTextReader, reader);
  eh = xmlTextReaderIsDefault(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   value?
 *
 * Does this node have a text value?
 */
static VALUE value_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  int eh;

  Data_Get_Struct(self, xmlTextReader, reader);
  eh = xmlTextReaderHasValue(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   attributes?
 *
 * Does this node have attributes?
 */
static VALUE attributes_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  int eh;

  Data_Get_Struct(self, xmlTextReader, reader);
  eh = has_attributes(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   namespaces
 *
 * Get a hash of namespaces for this Node
 */
static VALUE namespaces(VALUE self)
{
  xmlTextReaderPtr reader;
  xmlNodePtr ptr;
  VALUE attr ;

  Data_Get_Struct(self, xmlTextReader, reader);

  attr = rb_hash_new() ;

  if (! has_attributes(reader))
    return attr ;

  ptr = xmlTextReaderExpand(reader);
  if(ptr == NULL) return Qnil;

  Nokogiri_xml_node_namespaces(ptr, attr);

  return attr ;
}

/*
 * call-seq:
 *   attribute_nodes
 *
 * Get a list of attributes for this Node
 */
static VALUE attribute_nodes(VALUE self)
{
  xmlTextReaderPtr reader;
  xmlNodePtr ptr;
  VALUE attr ;

  Data_Get_Struct(self, xmlTextReader, reader);

  attr = rb_ary_new() ;

  if (! has_attributes(reader))
    return attr ;

  ptr = xmlTextReaderExpand(reader);
  if(ptr == NULL) return Qnil;

  Nokogiri_xml_node_properties(ptr, attr);

  return attr ;
}

/*
 * call-seq:
 *   attribute_at(index)
 *
 * Get the value of attribute at +index+
 */
static VALUE attribute_at(VALUE self, VALUE index)
{
  xmlTextReaderPtr reader;
  xmlChar *value;
  VALUE rb_value;

  Data_Get_Struct(self, xmlTextReader, reader);

  if(NIL_P(index)) return Qnil;
  index = rb_Integer(index);

  value = xmlTextReaderGetAttributeNo(
      reader,
      (int)NUM2INT(index)
  );
  if(value == NULL) return Qnil;

  rb_value = NOKOGIRI_STR_NEW2(value);
  xmlFree(value);
  return rb_value;
}

/*
 * call-seq:
 *   attribute(name)
 *
 * Get the value of attribute named +name+
 */
static VALUE reader_attribute(VALUE self, VALUE name)
{
  xmlTextReaderPtr reader;
  xmlChar *value ;
  VALUE rb_value;

  Data_Get_Struct(self, xmlTextReader, reader);

  if(NIL_P(name)) return Qnil;
  name = StringValue(name) ;

  value = xmlTextReaderGetAttribute(reader, (xmlChar*)StringValuePtr(name));
  if(value == NULL) {
    /* this section is an attempt to workaround older versions of libxml that
       don't handle namespaces properly in all attribute-and-friends functions */
    xmlChar *prefix = NULL ;
    xmlChar *localname = xmlSplitQName2((xmlChar*)StringValuePtr(name), &prefix);
    if (localname != NULL) {
      value = xmlTextReaderLookupNamespace(reader, localname);
      xmlFree(localname) ;
    } else {
      value = xmlTextReaderLookupNamespace(reader, prefix);
    }
    xmlFree(prefix);
  }
  if(value == NULL) return Qnil;

  rb_value = NOKOGIRI_STR_NEW2(value);
  xmlFree(value);
  return rb_value;
}

/*
 * call-seq:
 *   attribute_count
 *
 * Get the number of attributes for the current node
 */
static VALUE attribute_count(VALUE self)
{
  xmlTextReaderPtr reader;
  int count;

  Data_Get_Struct(self, xmlTextReader, reader);
  count = xmlTextReaderAttributeCount(reader);
  if(count == -1) return Qnil;

  return INT2NUM((long)count);
}

/*
 * call-seq:
 *   depth
 *
 * Get the depth of the node
 */
static VALUE depth(VALUE self)
{
  xmlTextReaderPtr reader;
  int depth;

  Data_Get_Struct(self, xmlTextReader, reader);
  depth = xmlTextReaderDepth(reader);
  if(depth == -1) return Qnil;

  return INT2NUM((long)depth);
}

/*
 * call-seq:
 *   xml_version
 *
 * Get the XML version of the document being read
 */
static VALUE xml_version(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *version;

  Data_Get_Struct(self, xmlTextReader, reader);
  version = (const char *)xmlTextReaderConstXmlVersion(reader);
  if(version == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(version);
}

/*
 * call-seq:
 *   lang
 *
 * Get the xml:lang scope within which the node resides.
 */
static VALUE lang(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *lang;

  Data_Get_Struct(self, xmlTextReader, reader);
  lang = (const char *)xmlTextReaderConstXmlLang(reader);
  if(lang == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(lang);
}

/*
 * call-seq:
 *   value
 *
 * Get the text value of the node if present. Returns a utf-8 encoded string.
 */
static VALUE value(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *value;

  Data_Get_Struct(self, xmlTextReader, reader);
  value = (const char *)xmlTextReaderConstValue(reader);
  if(value == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(value);
}

/*
 * call-seq:
 *   prefix
 *
 * Get the shorthand reference to the namespace associated with the node.
 */
static VALUE prefix(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *prefix;

  Data_Get_Struct(self, xmlTextReader, reader);
  prefix = (const char *)xmlTextReaderConstPrefix(reader);
  if(prefix == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(prefix);
}

/*
 * call-seq:
 *   namespace_uri
 *
 * Get the URI defining the namespace associated with the node
 */
static VALUE namespace_uri(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *uri;

  Data_Get_Struct(self, xmlTextReader, reader);
  uri = (const char *)xmlTextReaderConstNamespaceUri(reader);
  if(uri == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(uri);
}

/*
 * call-seq:
 *   local_name
 *
 * Get the local name of the node
 */
static VALUE local_name(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *name;

  Data_Get_Struct(self, xmlTextReader, reader);
  name = (const char *)xmlTextReaderConstLocalName(reader);
  if(name == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(name);
}

/*
 * call-seq:
 *   name
 *
 * Get the name of the node. Returns a utf-8 encoded string.
 */
static VALUE name(VALUE self)
{
  xmlTextReaderPtr reader;
  const char *name;

  Data_Get_Struct(self, xmlTextReader, reader);
  name = (const char *)xmlTextReaderConstName(reader);
  if(name == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(name);
}

/*
 * call-seq:
 * base_uri
 *
 * Get the xml:base of the node
 */
static VALUE base_uri(VALUE self)
{
  xmlTextReaderPtr reader;
  const char * base_uri;

  Data_Get_Struct(self, xmlTextReader, reader);
  base_uri = (const char *)xmlTextReaderBaseUri(reader);
  if (base_uri == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(base_uri);
}

/*
 * call-seq:
 *   state
 *
 * Get the state of the reader
 */
static VALUE state(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  return INT2NUM((long)xmlTextReaderReadState(reader));
}

/*
 * call-seq:
 *   node_type
 *
 * Get the type of readers current node
 */
static VALUE node_type(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  return INT2NUM((long)xmlTextReaderNodeType(reader));
}

/*
 * call-seq:
 *   read
 *
 * Move the Reader forward through the XML document.
 */
static VALUE read_more(VALUE self)
{
  xmlTextReaderPtr reader;
  xmlErrorPtr error;
  VALUE error_list;
  int ret;

  Data_Get_Struct(self, xmlTextReader, reader);

  error_list = rb_funcall(self, rb_intern("errors"), 0);

  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
  ret = xmlTextReaderRead(reader);
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(ret == 1) return self;
  if(ret == 0) return Qnil;

  error = xmlGetLastError();
  if(error)
    rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
  else
    rb_raise(rb_eRuntimeError, "Error pulling: %d", ret);

  return Qnil;
}

/*
 * call-seq:
 *   inner_xml
 *
 * Read the contents of the current node, including child nodes and markup.
 * Returns a utf-8 encoded string.
 */
static VALUE inner_xml(VALUE self)
{
  xmlTextReaderPtr reader;
  xmlChar* value;
  VALUE str;

  Data_Get_Struct(self, xmlTextReader, reader);

  value = xmlTextReaderReadInnerXml(reader);

  str = Qnil;
  if(value) {
    str = NOKOGIRI_STR_NEW2((char*)value);
    xmlFree(value);
  }

  return str;
}

/*
 * call-seq:
 *   outer_xml
 *
 * Read the current node and its contents, including child nodes and markup.
 * Returns a utf-8 encoded string.
 */
static VALUE outer_xml(VALUE self)
{
  xmlTextReaderPtr reader;
  xmlChar *value;
  VALUE str = Qnil;

  Data_Get_Struct(self, xmlTextReader, reader);

  value = xmlTextReaderReadOuterXml(reader);

  if(value) {
    str = NOKOGIRI_STR_NEW2((char*)value);
    xmlFree(value);
  }
  return str;
}

/*
 * call-seq:
 *   from_memory(string, url = nil, encoding = nil, options = 0)
 *
 * Create a new reader that parses +string+
 */
static VALUE from_memory(int argc, VALUE *argv, VALUE klass)
{
  VALUE rb_buffer, rb_url, encoding, rb_options;
  xmlTextReaderPtr reader;
  const char * c_url      = NULL;
  const char * c_encoding = NULL;
  int c_options           = 0;
  VALUE rb_reader, args[3];

  rb_scan_args(argc, argv, "13", &rb_buffer, &rb_url, &encoding, &rb_options);

  if (!RTEST(rb_buffer)) rb_raise(rb_eArgError, "string cannot be nil");
  if (RTEST(rb_url)) c_url = StringValuePtr(rb_url);
  if (RTEST(encoding)) c_encoding = StringValuePtr(encoding);
  if (RTEST(rb_options)) c_options = (int)NUM2INT(rb_options);

  reader = xmlReaderForMemory(
      StringValuePtr(rb_buffer),
      (int)RSTRING_LEN(rb_buffer),
      c_url,
      c_encoding,
      c_options
  );

  if(reader == NULL) {
    xmlFreeTextReader(reader);
    rb_raise(rb_eRuntimeError, "couldn't create a parser");
  }

  rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
  args[0] = rb_buffer;
  args[1] = rb_url;
  args[2] = encoding;
  rb_obj_call_init(rb_reader, 3, args);

  return rb_reader;
}

/*
 * call-seq:
 *   from_io(io, url = nil, encoding = nil, options = 0)
 *
 * Create a new reader that parses +io+
 */
static VALUE from_io(int argc, VALUE *argv, VALUE klass)
{
  VALUE rb_io, rb_url, encoding, rb_options;
  xmlTextReaderPtr reader;
  const char * c_url      = NULL;
  const char * c_encoding = NULL;
  int c_options           = 0;
  VALUE rb_reader, args[3];

  rb_scan_args(argc, argv, "13", &rb_io, &rb_url, &encoding, &rb_options);

  if (!RTEST(rb_io)) rb_raise(rb_eArgError, "io cannot be nil");
  if (RTEST(rb_url)) c_url = StringValuePtr(rb_url);
  if (RTEST(encoding)) c_encoding = StringValuePtr(encoding);
  if (RTEST(rb_options)) c_options = (int)NUM2INT(rb_options);

  reader = xmlReaderForIO(
      (xmlInputReadCallback)io_read_callback,
      (xmlInputCloseCallback)io_close_callback,
      (void *)rb_io,
      c_url,
      c_encoding,
      c_options
  );

  if(reader == NULL) {
    xmlFreeTextReader(reader);
    rb_raise(rb_eRuntimeError, "couldn't create a parser");
  }

  rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
  args[0] = rb_io;
  args[1] = rb_url;
  args[2] = encoding;
  rb_obj_call_init(rb_reader, 3, args);

  return rb_reader;
}

/*
 * call-seq:
 *   reader.empty_element? # => true or false
 *
 * Returns true if the current node is empty, otherwise false.
 */
static VALUE empty_element_p(VALUE self)
{
  xmlTextReaderPtr reader;

  Data_Get_Struct(self, xmlTextReader, reader);

  if(xmlTextReaderIsEmptyElement(reader))
    return Qtrue;

  return Qfalse;
}

VALUE cNokogiriXmlReader;

void init_xml_reader()
{
  VALUE module = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(module, "XML");

  /*
   * The Reader parser allows you to effectively pull parse an XML document.
   * Once instantiated, call Nokogiri::XML::Reader#each to iterate over each
   * node.  Note that you may only iterate over the document once!
   */
  VALUE klass = rb_define_class_under(xml, "Reader", rb_cObject);

  cNokogiriXmlReader = klass;

  rb_define_singleton_method(klass, "from_memory", from_memory, -1);
  rb_define_singleton_method(klass, "from_io", from_io, -1);

  rb_define_method(klass, "read", read_more, 0);
  rb_define_method(klass, "inner_xml", inner_xml, 0);
  rb_define_method(klass, "outer_xml", outer_xml, 0);
  rb_define_method(klass, "state", state, 0);
  rb_define_method(klass, "node_type", node_type, 0);
  rb_define_method(klass, "name", name, 0);
  rb_define_method(klass, "local_name", local_name, 0);
  rb_define_method(klass, "namespace_uri", namespace_uri, 0);
  rb_define_method(klass, "prefix", prefix, 0);
  rb_define_method(klass, "value", value, 0);
  rb_define_method(klass, "lang", lang, 0);
  rb_define_method(klass, "xml_version", xml_version, 0);
  rb_define_method(klass, "depth", depth, 0);
  rb_define_method(klass, "attribute_count", attribute_count, 0);
  rb_define_method(klass, "attribute", reader_attribute, 1);
  rb_define_method(klass, "namespaces", namespaces, 0);
  rb_define_method(klass, "attribute_at", attribute_at, 1);
  rb_define_method(klass, "empty_element?", empty_element_p, 0);
  rb_define_method(klass, "attributes?", attributes_eh, 0);
  rb_define_method(klass, "value?", value_eh, 0);
  rb_define_method(klass, "default?", default_eh, 0);
  rb_define_method(klass, "base_uri", base_uri, 0);

  rb_define_private_method(klass, "attr_nodes", attribute_nodes, 0);
}
                                                                                                                                                                                                                                                     xml_reader.h                                                                                        0100644 0001750 0001750 00000000222 12566211316 043365  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_READER
#define NOKOGIRI_XML_READER

#include <nokogiri.h>

void init_xml_reader();

extern VALUE cNokogiriXmlReader;

#endif
                                                                                                                                                                                                                                                                                                                                                                              xml_relax_ng.c                                                                                      0100644 0001750 0001750 00000007114 12566211316 043724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_relax_ng.h>

static void dealloc(xmlRelaxNGPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlRelaxNGFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}

/*
 * call-seq:
 *  validate_document(document)
 *
 * Validate a Nokogiri::XML::Document against this RelaxNG schema.
 */
static VALUE validate_document(VALUE self, VALUE document)
{
  xmlDocPtr doc;
  xmlRelaxNGPtr schema;
  VALUE errors;
  xmlRelaxNGValidCtxtPtr valid_ctxt;

  Data_Get_Struct(self, xmlRelaxNG, schema);
  Data_Get_Struct(document, xmlDoc, doc);

  errors = rb_ary_new();

  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);

  if(NULL == valid_ctxt) {
    /* we have a problem */
    rb_raise(rb_eRuntimeError, "Could not create a validation context");
  }

#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS
  xmlRelaxNGSetValidStructuredErrors(
    valid_ctxt,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  xmlRelaxNGValidateDoc(valid_ctxt, doc);

  xmlRelaxNGFreeValidCtxt(valid_ctxt);

  return errors;
}

/*
 * call-seq:
 *  read_memory(string)
 *
 * Create a new RelaxNG from the contents of +string+
 */
static VALUE read_memory(VALUE klass, VALUE content)
{
  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(
      (const char *)StringValuePtr(content),
      (int)RSTRING_LEN(content)
  );
  xmlRelaxNGPtr schema;
  VALUE errors = rb_ary_new();
  VALUE rb_schema;

  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS
  xmlRelaxNGSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  schema = xmlRelaxNGParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlRelaxNGFreeParserCtxt(ctx);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, "@errors", errors);

  return rb_schema;
}

/*
 * call-seq:
 *  from_document(doc)
 *
 * Create a new RelaxNG schema from the Nokogiri::XML::Document +doc+
 */
static VALUE from_document(VALUE klass, VALUE document)
{
  xmlDocPtr doc;
  xmlRelaxNGParserCtxtPtr ctx;
  xmlRelaxNGPtr schema;
  VALUE errors;
  VALUE rb_schema;

  Data_Get_Struct(document, xmlDoc, doc);

  /* In case someone passes us a node. ugh. */
  doc = doc->doc;

  ctx = xmlRelaxNGNewDocParserCtxt(doc);

  errors = rb_ary_new();
  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS
  xmlRelaxNGSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  schema = xmlRelaxNGParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, "@errors", errors);

  return rb_schema;
}

VALUE cNokogiriXmlRelaxNG;
void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE klass = rb_define_class_under(xml, "RelaxNG", cNokogiriXmlSchema);

  cNokogiriXmlRelaxNG = klass;

  rb_define_singleton_method(klass, "read_memory", read_memory, 1);
  rb_define_singleton_method(klass, "from_document", from_document, 1);
  rb_define_private_method(klass, "validate_document", validate_document, 1);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                    xml_relax_ng.h                                                                                      0100644 0001750 0001750 00000000230 12566211316 043721  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_RELAX_NG
#define NOKOGIRI_XML_RELAX_NG

#include <nokogiri.h>

void init_xml_relax_ng();

extern VALUE cNokogiriXmlRelaxNG;
#endif
                                                                                                                                                                                                                                                                                                                                                                        xml_sax_parser.c                                                                                    0100644 0001750 0001750 00000020341 12566211316 044271  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_sax_parser.h>

int vasprintf (char **strp, const char *fmt, va_list ap);
void vasprintf_free (void *p);

static ID id_start_document, id_end_document, id_start_element, id_end_element;
static ID id_start_element_namespace, id_end_element_namespace;
static ID id_comment, id_characters, id_xmldecl, id_error, id_warning;
static ID id_cdata_block, id_cAttribute;
static ID id_processing_instruction;

#define STRING_OR_NULL(str) \
   (RTEST(str) ? StringValuePtr(str) : NULL)

static void start_document(void * ctx)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");

  xmlParserCtxtPtr ctxt = NOKOGIRI_SAX_CTXT(ctx);

  if(NULL != ctxt && ctxt->html != 1) {
    if(ctxt->standalone != -1) {  /* -1 means there was no declaration */
      VALUE encoding = ctxt->encoding ?
        NOKOGIRI_STR_NEW2(ctxt->encoding) :
        Qnil;

      VALUE version = ctxt->version ?
        NOKOGIRI_STR_NEW2(ctxt->version) :
        Qnil;

      VALUE standalone = Qnil;

      switch(ctxt->standalone)
      {
        case 0:
          standalone = NOKOGIRI_STR_NEW2("no");
          break;
        case 1:
          standalone = NOKOGIRI_STR_NEW2("yes");
          break;
      }

      rb_funcall(doc, id_xmldecl, 3, version, encoding, standalone);
    }
  }

  rb_funcall(doc, id_start_document, 0);
}

static void end_document(void * ctx)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  rb_funcall(doc, id_end_document, 0);
}

static void start_element(void * ctx, const xmlChar *name, const xmlChar **atts)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  VALUE attributes = rb_ary_new();
  const xmlChar * attr;
  int i = 0;
  if(atts) {
    while((attr = atts[i]) != NULL) {
      const xmlChar * val = atts[i+1];
      VALUE value = val != NULL ? NOKOGIRI_STR_NEW2(val) : Qnil;
      rb_ary_push(attributes, rb_ary_new3(2, NOKOGIRI_STR_NEW2(attr), value));
      i+=2;
    }
  }

  rb_funcall( doc,
              id_start_element,
              2,
              NOKOGIRI_STR_NEW2(name),
              attributes
  );
}

static void end_element(void * ctx, const xmlChar *name)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  rb_funcall(doc, id_end_element, 1, NOKOGIRI_STR_NEW2(name));
}

static VALUE attributes_as_list(
  VALUE self,
  int nb_attributes,
  const xmlChar ** attributes)
{
  VALUE list = rb_ary_new2((long)nb_attributes);

  VALUE attr_klass = rb_const_get(cNokogiriXmlSaxParser, id_cAttribute);
  if (attributes) {
    /* Each attribute is an array of [localname, prefix, URI, value, end] */
    int i;
    for (i = 0; i < nb_attributes * 5; i += 5) {
      VALUE argv[4], attribute;

      argv[0] = RBSTR_OR_QNIL(attributes[i + 0]); /* localname */
      argv[1] = RBSTR_OR_QNIL(attributes[i + 1]); /* prefix */
      argv[2] = RBSTR_OR_QNIL(attributes[i + 2]); /* URI */

      /* value */
      argv[3] = NOKOGIRI_STR_NEW((const char*)attributes[i+3],
          (attributes[i+4] - attributes[i+3]));

      attribute = rb_class_new_instance(4, argv, attr_klass);
      rb_ary_push(list, attribute);
    }
  }

  return list;
}

static void
start_element_ns (
  void * ctx,
  const xmlChar * localname,
  const xmlChar * prefix,
  const xmlChar * uri,
  int nb_namespaces,
  const xmlChar ** namespaces,
  int nb_attributes,
  int nb_defaulted,
  const xmlChar ** attributes)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");

  VALUE attribute_list = attributes_as_list(self, nb_attributes, attributes);

  VALUE ns_list = rb_ary_new2((long)nb_namespaces);

  if (namespaces) {
    int i;
    for (i = 0; i < nb_namespaces * 2; i += 2)
    {
      rb_ary_push(ns_list,
        rb_ary_new3((long)2,
          RBSTR_OR_QNIL(namespaces[i + 0]),
          RBSTR_OR_QNIL(namespaces[i + 1])
        )
      );
    }
  }

  rb_funcall( doc,
              id_start_element_namespace,
              5,
              NOKOGIRI_STR_NEW2(localname),
              attribute_list,
              RBSTR_OR_QNIL(prefix),
              RBSTR_OR_QNIL(uri),
              ns_list
  );
}

/**
 * end_element_ns was borrowed heavily from libxml-ruby. 
 */
static void
end_element_ns (
  void * ctx,
  const xmlChar * localname,
  const xmlChar * prefix,
  const xmlChar * uri)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");

  rb_funcall(doc, id_end_element_namespace, 3, 
    NOKOGIRI_STR_NEW2(localname),
    RBSTR_OR_QNIL(prefix),
    RBSTR_OR_QNIL(uri)
  );
}

static void characters_func(void * ctx, const xmlChar * ch, int len)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  VALUE str = NOKOGIRI_STR_NEW(ch, len);
  rb_funcall(doc, id_characters, 1, str);
}

static void comment_func(void * ctx, const xmlChar * value)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  VALUE str = NOKOGIRI_STR_NEW2(value);
  rb_funcall(doc, id_comment, 1, str);
}

static void warning_func(void * ctx, const char *msg, ...)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  char * message;
  VALUE ruby_message;

  va_list args;
  va_start(args, msg);
  vasprintf(&message, msg, args);
  va_end(args);

  ruby_message = NOKOGIRI_STR_NEW2(message);
  vasprintf_free(message);
  rb_funcall(doc, id_warning, 1, ruby_message);
}

static void error_func(void * ctx, const char *msg, ...)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  char * message;
  VALUE ruby_message;

  va_list args;
  va_start(args, msg);
  vasprintf(&message, msg, args);
  va_end(args);

  ruby_message = NOKOGIRI_STR_NEW2(message);
  vasprintf_free(message);
  rb_funcall(doc, id_error, 1, ruby_message);
}

static void cdata_block(void * ctx, const xmlChar * value, int len)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");
  VALUE string = NOKOGIRI_STR_NEW(value, len);
  rb_funcall(doc, id_cdata_block, 1, string);
}

static void processing_instruction(void * ctx, const xmlChar * name, const xmlChar * content)
{
  VALUE self = NOKOGIRI_SAX_SELF(ctx);
  VALUE doc = rb_iv_get(self, "@document");

  rb_funcall( doc,
              id_processing_instruction,
              2,
              NOKOGIRI_STR_NEW2(name),
              NOKOGIRI_STR_NEW2(content)
  );
}

static void deallocate(xmlSAXHandlerPtr handler)
{
  NOKOGIRI_DEBUG_START(handler);
  free(handler);
  NOKOGIRI_DEBUG_END(handler);
}

static VALUE allocate(VALUE klass)
{
  xmlSAXHandlerPtr handler = calloc((size_t)1, sizeof(xmlSAXHandler));

  xmlSetStructuredErrorFunc(NULL, NULL);

  handler->startDocument = start_document;
  handler->endDocument = end_document;
  handler->startElement = start_element;
  handler->endElement = end_element;
  handler->startElementNs = start_element_ns;
  handler->endElementNs = end_element_ns;
  handler->characters = characters_func;
  handler->comment = comment_func;
  handler->warning = warning_func;
  handler->error = error_func;
  handler->cdataBlock = cdata_block;
  handler->processingInstruction = processing_instruction;
  handler->initialized = XML_SAX2_MAGIC;

  return Data_Wrap_Struct(klass, NULL, deallocate, handler);
}

VALUE cNokogiriXmlSaxParser ;
void init_xml_sax_parser()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE sax       = rb_define_module_under(xml, "SAX");
  VALUE klass     = rb_define_class_under(sax, "Parser", rb_cObject);

  cNokogiriXmlSaxParser = klass;

  rb_define_alloc_func(klass, allocate);

  id_start_document = rb_intern("start_document");
  id_end_document   = rb_intern("end_document");
  id_start_element  = rb_intern("start_element");
  id_end_element    = rb_intern("end_element");
  id_comment        = rb_intern("comment");
  id_characters     = rb_intern("characters");
  id_xmldecl        = rb_intern("xmldecl");
  id_error          = rb_intern("error");
  id_warning        = rb_intern("warning");
  id_cdata_block    = rb_intern("cdata_block");
  id_cAttribute     = rb_intern("Attribute");
  id_start_element_namespace = rb_intern("start_element_namespace");
  id_end_element_namespace = rb_intern("end_element_namespace");
  id_processing_instruction = rb_intern("processing_instruction");
}
                                                                                                                                                                                                                                                                                               xml_sax_parser.h                                                                                    0100644 0001750 0001750 00000001511 12566211316 044274  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_SAX_PARSER
#define NOKOGIRI_XML_SAX_PARSER

#include <nokogiri.h>

void init_xml_sax_parser();

extern VALUE cNokogiriXmlSaxParser ;

typedef struct _nokogiriSAXTuple {
  xmlParserCtxtPtr  ctxt;
  VALUE             self;
} nokogiriSAXTuple;

typedef nokogiriSAXTuple * nokogiriSAXTuplePtr;

#define NOKOGIRI_SAX_SELF(_ctxt) \
  ((nokogiriSAXTuplePtr)(_ctxt))->self

#define NOKOGIRI_SAX_CTXT(_ctxt) \
  ((nokogiriSAXTuplePtr)(_ctxt))->ctxt

#define NOKOGIRI_SAX_TUPLE_NEW(_ctxt, _self) \
  nokogiri_sax_tuple_new(_ctxt, _self)

static inline nokogiriSAXTuplePtr
nokogiri_sax_tuple_new(xmlParserCtxtPtr ctxt, VALUE self)
{
  nokogiriSAXTuplePtr tuple = malloc(sizeof(nokogiriSAXTuple));
  tuple->self = self;
  tuple->ctxt = ctxt;
  return tuple;
}

#define NOKOGIRI_SAX_TUPLE_DESTROY(_tuple) \
  free(_tuple) \

#endif

                                                                                                                                                                                       xml_sax_parser_context.c                                                                            0100644 0001750 0001750 00000011421 12566211316 046034  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_sax_parser_context.h>

VALUE cNokogiriXmlSaxParserContext ;

static void deallocate(xmlParserCtxtPtr ctxt)
{
  NOKOGIRI_DEBUG_START(handler);

  ctxt->sax = NULL;

  xmlFreeParserCtxt(ctxt);

  NOKOGIRI_DEBUG_END(handler);
}

/*
 * call-seq:
 *  parse_io(io, encoding)
 *
 * Parse +io+ object with +encoding+
 */
static VALUE
parse_io(VALUE klass, VALUE io, VALUE encoding)
{
    xmlParserCtxtPtr ctxt;
    xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);

    ctxt = xmlCreateIOParserCtxt(NULL, NULL,
				 (xmlInputReadCallback)io_read_callback,
				 (xmlInputCloseCallback)io_close_callback,
				 (void *)io, enc);
    if (ctxt->sax) {
	xmlFree(ctxt->sax);
	ctxt->sax = NULL;
    }

    return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

/*
 * call-seq:
 *  parse_file(filename)
 *
 * Parse file given +filename+
 */
static VALUE parse_file(VALUE klass, VALUE filename)
{
  xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(StringValuePtr(filename));
  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

/*
 * call-seq:
 *  parse_memory(data)
 *
 * Parse the XML stored in memory in +data+
 */
static VALUE
parse_memory(VALUE klass, VALUE data)
{
    xmlParserCtxtPtr ctxt;

    if (NIL_P(data))
	rb_raise(rb_eArgError, "data cannot be nil");
    if (!(int)RSTRING_LEN(data))
	rb_raise(rb_eRuntimeError, "data cannot be empty");

    ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),
				     (int)RSTRING_LEN(data));
    if (ctxt->sax) {
	xmlFree(ctxt->sax);
	ctxt->sax = NULL;
    }

    return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

static VALUE
parse_doc(VALUE ctxt_val)
{
    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr)ctxt_val;
    xmlParseDocument(ctxt);
    return Qnil;
}

static VALUE
parse_doc_finalize(VALUE ctxt_val)
{
    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr)ctxt_val;

    if (NULL != ctxt->myDoc)
	xmlFreeDoc(ctxt->myDoc);

    NOKOGIRI_SAX_TUPLE_DESTROY(ctxt->userData);
    return Qnil;
}

/*
 * call-seq:
 *  parse_with(sax_handler)
 *
 * Use +sax_handler+ and parse the current document
 */
static VALUE
parse_with(VALUE self, VALUE sax_handler)
{
    xmlParserCtxtPtr ctxt;
    xmlSAXHandlerPtr sax;

    if (!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser))
	rb_raise(rb_eArgError, "argument must be a Nokogiri::XML::SAX::Parser");

    Data_Get_Struct(self, xmlParserCtxt, ctxt);
    Data_Get_Struct(sax_handler, xmlSAXHandler, sax);

    /* Free the sax handler since we'll assign our own */
    if (ctxt->sax && ctxt->sax != (xmlSAXHandlerPtr)&xmlDefaultSAXHandler)
	xmlFree(ctxt->sax);

    ctxt->sax = sax;
    ctxt->userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);

    rb_ensure(parse_doc, (VALUE)ctxt, parse_doc_finalize, (VALUE)ctxt);

    return Qnil;
}

/*
 * call-seq:
 *  replace_entities=(boolean)
 *
 * Should this parser replace entities?  &amp; will get converted to '&' if
 * set to true
 */
static VALUE set_replace_entities(VALUE self, VALUE value)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if(Qfalse == value)
    ctxt->replaceEntities = 0;
  else
    ctxt->replaceEntities = 1;

  return value;
}

/*
 * call-seq:
 *  replace_entities
 *
 * Should this parser replace entities?  &amp; will get converted to '&' if
 * set to true
 */
static VALUE get_replace_entities(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if(0 == ctxt->replaceEntities)
    return Qfalse;
  else
    return Qtrue;
}

/*
 * call-seq: line
 *
 * Get the current line the parser context is processing.
 */
static VALUE line(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  xmlParserInputPtr io;

  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  io = ctxt->input;
  if(io)
    return INT2NUM(io->line);

  return Qnil;
}

/*
 * call-seq: column
 *
 * Get the current column the parser context is processing.
 */
static VALUE column(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  xmlParserInputPtr io;

  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  io = ctxt->input;
  if(io)
    return INT2NUM(io->col);

  return Qnil;
}

void init_xml_sax_parser_context()
{
  VALUE nokogiri  = rb_define_module("Nokogiri");
  VALUE xml       = rb_define_module_under(nokogiri, "XML");
  VALUE sax       = rb_define_module_under(xml, "SAX");
  VALUE klass     = rb_define_class_under(sax, "ParserContext", rb_cObject);

  cNokogiriXmlSaxParserContext = klass;

  rb_define_singleton_method(klass, "io", parse_io, 2);
  rb_define_singleton_method(klass, "memory", parse_memory, 1);
  rb_define_singleton_method(klass, "file", parse_file, 1);

  rb_define_method(klass, "parse_with", parse_with, 1);
  rb_define_method(klass, "replace_entities=", set_replace_entities, 1);
  rb_define_method(klass, "replace_entities", get_replace_entities, 0);
  rb_define_method(klass, "line", line, 0);
  rb_define_method(klass, "column", column, 0);
}
                                                                                                                                                                                                                                               xml_sax_parser_context.h                                                                            0100644 0001750 0001750 00000000300 12566211316 046033  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_SAX_PARSER_CONTEXT
#define NOKOGIRI_XML_SAX_PARSER_CONTEXT

#include <nokogiri.h>

extern VALUE cNokogiriXmlSaxParserContext;

void init_xml_sax_parser_context();

#endif
                                                                                                                                                                                                                                                                                                                                xml_sax_push_parser.c                                                                               0100644 0001750 0001750 00000005277 12566211316 045343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_sax_push_parser.h>

static void deallocate(xmlParserCtxtPtr ctx)
{
  NOKOGIRI_DEBUG_START(ctx);
  if(ctx != NULL) {
    NOKOGIRI_SAX_TUPLE_DESTROY(ctx->userData);
    xmlFreeParserCtxt(ctx);
  }
  NOKOGIRI_DEBUG_END(ctx);
}

static VALUE allocate(VALUE klass)
{
  return Data_Wrap_Struct(klass, NULL, deallocate, NULL);
}

/*
 * call-seq:
 *  native_write(chunk, last_chunk)
 *
 * Write +chunk+ to PushParser. +last_chunk+ triggers the end_document handle
 */
static VALUE native_write(VALUE self, VALUE _chunk, VALUE _last_chunk)
{
  xmlParserCtxtPtr ctx;
  const char * chunk  = NULL;
  int size            = 0;


  Data_Get_Struct(self, xmlParserCtxt, ctx);

  if(Qnil != _chunk) {
    chunk = StringValuePtr(_chunk);
    size = (int)RSTRING_LEN(_chunk);
  }

  if(xmlParseChunk(ctx, chunk, size, Qtrue == _last_chunk ? 1 : 0)) {
    if (!(ctx->options & XML_PARSE_RECOVER)) {
      xmlErrorPtr e = xmlCtxtGetLastError(ctx);
      Nokogiri_error_raise(NULL, e);
    }
  }

  return self;
}

/*
 * call-seq:
 *  initialize_native(xml_sax, filename)
 *
 * Initialize the push parser with +xml_sax+ using +filename+
 */
static VALUE initialize_native(VALUE self, VALUE _xml_sax, VALUE _filename)
{
  xmlSAXHandlerPtr sax;
  const char * filename = NULL;
  xmlParserCtxtPtr ctx;

  Data_Get_Struct(_xml_sax, xmlSAXHandler, sax);

  if(_filename != Qnil) filename = StringValuePtr(_filename);

  ctx = xmlCreatePushParserCtxt(
      sax,
      NULL,
      NULL,
      0,
      filename
  );
  if(ctx == NULL)
    rb_raise(rb_eRuntimeError, "Could not create a parser context");

  ctx->userData = NOKOGIRI_SAX_TUPLE_NEW(ctx, self);

  ctx->sax2 = 1;
  DATA_PTR(self) = ctx;
  return self;
}

static VALUE get_options(VALUE self)
{
  xmlParserCtxtPtr ctx;
  Data_Get_Struct(self, xmlParserCtxt, ctx);

  return INT2NUM(ctx->options);
}

static VALUE set_options(VALUE self, VALUE options)
{
  xmlParserCtxtPtr ctx;
  Data_Get_Struct(self, xmlParserCtxt, ctx);

  if (xmlCtxtUseOptions(ctx, (int)NUM2INT(options)) != 0)
    rb_raise(rb_eRuntimeError, "Cannot set XML parser context options");

  return Qnil;
}

VALUE cNokogiriXmlSaxPushParser ;
void init_xml_sax_push_parser()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE sax = rb_define_module_under(xml, "SAX");
  VALUE klass = rb_define_class_under(sax, "PushParser", rb_cObject);

  cNokogiriXmlSaxPushParser = klass;

  rb_define_alloc_func(klass, allocate);
  rb_define_private_method(klass, "initialize_native", initialize_native, 2);
  rb_define_private_method(klass, "native_write", native_write, 2);
  rb_define_method(klass, "options", get_options, 0);
  rb_define_method(klass, "options=", set_options, 1);
}
                                                                                                                                                                                                                                                                                                                                 xml_sax_push_parser.h                                                                               0100644 0001750 0001750 00000000264 12566211316 045337  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_SAX_PUSH_PARSER
#define NOKOGIRI_XML_SAX_PUSH_PARSER

#include <nokogiri.h>

void init_xml_sax_push_parser();

extern VALUE cNokogiriXmlSaxPushParser ;
#endif
                                                                                                                                                                                                                                                                                                                                            xml_schema.c                                                                                        0100644 0001750 0001750 00000010721 12566211316 043363  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_schema.h>

static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}

/*
 * call-seq:
 *  validate_document(document)
 *
 * Validate a Nokogiri::XML::Document against this Schema.
 */
static VALUE validate_document(VALUE self, VALUE document)
{
  xmlDocPtr doc;
  xmlSchemaPtr schema;
  xmlSchemaValidCtxtPtr valid_ctxt;
  VALUE errors;

  Data_Get_Struct(self, xmlSchema, schema);
  Data_Get_Struct(document, xmlDoc, doc);

  errors = rb_ary_new();

  valid_ctxt = xmlSchemaNewValidCtxt(schema);

  if(NULL == valid_ctxt) {
    /* we have a problem */
    rb_raise(rb_eRuntimeError, "Could not create a validation context");
  }

#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS
  xmlSchemaSetValidStructuredErrors(
    valid_ctxt,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  xmlSchemaValidateDoc(valid_ctxt, doc);

  xmlSchemaFreeValidCtxt(valid_ctxt);

  return errors;
}

/*
 * call-seq:
 *  validate_file(filename)
 *
 * Validate a file against this Schema.
 */
static VALUE validate_file(VALUE self, VALUE rb_filename)
{
  xmlSchemaPtr schema;
  xmlSchemaValidCtxtPtr valid_ctxt;
  const char *filename ;
  VALUE errors;

  Data_Get_Struct(self, xmlSchema, schema);
  filename = (const char*)StringValuePtr(rb_filename) ;

  errors = rb_ary_new();

  valid_ctxt = xmlSchemaNewValidCtxt(schema);

  if(NULL == valid_ctxt) {
    /* we have a problem */
    rb_raise(rb_eRuntimeError, "Could not create a validation context");
  }

#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS
  xmlSchemaSetValidStructuredErrors(
    valid_ctxt,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  xmlSchemaValidateFile(valid_ctxt, filename, 0);

  xmlSchemaFreeValidCtxt(valid_ctxt);

  return errors;
}

/*
 * call-seq:
 *  read_memory(string)
 *
 * Create a new Schema from the contents of +string+
 */
static VALUE read_memory(VALUE klass, VALUE content)
{
  xmlSchemaPtr schema;
  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(
      (const char *)StringValuePtr(content),
      (int)RSTRING_LEN(content)
  );
  VALUE rb_schema;
  VALUE errors = rb_ary_new();
  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS
  xmlSchemaSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

   schema = xmlSchemaParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlSchemaFreeParserCtxt(ctx);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, "@errors", errors);

  return rb_schema;
}

/*
 * call-seq:
 *  from_document(doc)
 *
 * Create a new Schema from the Nokogiri::XML::Document +doc+
 */
static VALUE from_document(VALUE klass, VALUE document)
{
  xmlDocPtr doc;
  xmlSchemaParserCtxtPtr ctx;
  xmlSchemaPtr schema;
  VALUE errors;
  VALUE rb_schema;

  Data_Get_Struct(document, xmlDoc, doc);

  /* In case someone passes us a node. ugh. */
  doc = doc->doc;

  ctx = xmlSchemaNewDocParserCtxt(doc);

  errors = rb_ary_new();
  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS
  xmlSchemaSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  schema = xmlSchemaParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlSchemaFreeParserCtxt(ctx);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, "Could not parse document");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, "@errors", errors);

  return rb_schema;

  return Qnil;
}

VALUE cNokogiriXmlSchema;
void init_xml_schema()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  VALUE klass = rb_define_class_under(xml, "Schema", rb_cObject);

  cNokogiriXmlSchema = klass;

  rb_define_singleton_method(klass, "read_memory", read_memory, 1);
  rb_define_singleton_method(klass, "from_document", from_document, 1);

  rb_define_private_method(klass, "validate_document", validate_document, 1);
  rb_define_private_method(klass, "validate_file",     validate_file, 1);
}
                                               xml_schema.h                                                                                        0100644 0001750 0001750 00000000221 12566211316 043362  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_SCHEMA
#define NOKOGIRI_XML_SCHEMA

#include <nokogiri.h>

void init_xml_schema();

extern VALUE cNokogiriXmlSchema;
#endif
                                                                                                                                                                                                                                                                                                                                                                               xml_syntax_error.c                                                                                  0100644 0001750 0001750 00000003126 12566211316 044663  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_syntax_error.h>

void Nokogiri_error_array_pusher(void * ctx, xmlErrorPtr error)
{
  VALUE list = (VALUE)ctx;
  rb_ary_push(list,  Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
}

void Nokogiri_error_raise(void * ctx, xmlErrorPtr error)
{
  rb_exc_raise(Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error));
}

VALUE Nokogiri_wrap_xml_syntax_error(VALUE klass, xmlErrorPtr error)
{
  VALUE msg, e;

  if(!klass) klass = cNokogiriXmlSyntaxError;

  msg = (error && error->message) ? NOKOGIRI_STR_NEW2(error->message) : Qnil;

  e = rb_class_new_instance(
      1,
      &msg,
      klass
  );

  if (error)
  {
    rb_iv_set(e, "@domain", INT2NUM(error->domain));
    rb_iv_set(e, "@code", INT2NUM(error->code));
    rb_iv_set(e, "@level", INT2NUM((short)error->level));
    rb_iv_set(e, "@file", RBSTR_OR_QNIL(error->file));
    rb_iv_set(e, "@line", INT2NUM(error->line));
    rb_iv_set(e, "@str1", RBSTR_OR_QNIL(error->str1));
    rb_iv_set(e, "@str2", RBSTR_OR_QNIL(error->str2));
    rb_iv_set(e, "@str3", RBSTR_OR_QNIL(error->str3));
    rb_iv_set(e, "@int1", INT2NUM(error->int1));
    rb_iv_set(e, "@column", INT2NUM(error->int2));
  }

  return e;
}

VALUE cNokogiriXmlSyntaxError;
void init_xml_syntax_error()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");

  /*
   * The XML::SyntaxError is raised on parse errors
   */
  VALUE syntax_error_mommy = rb_define_class_under(nokogiri, "SyntaxError", rb_eStandardError);
  VALUE klass = rb_define_class_under(xml, "SyntaxError", syntax_error_mommy);
  cNokogiriXmlSyntaxError = klass;

}
                                                                                                                                                                                                                                                                                                                                                                                                                                          xml_syntax_error.h                                                                                  0100644 0001750 0001750 00000000564 12566211316 044673  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_SYNTAX_ERROR
#define NOKOGIRI_XML_SYNTAX_ERROR

#include <nokogiri.h>

void init_xml_syntax_error();
VALUE Nokogiri_wrap_xml_syntax_error(VALUE klass, xmlErrorPtr error);
void Nokogiri_error_array_pusher(void * ctx, xmlErrorPtr error);
NORETURN(void Nokogiri_error_raise(void * ctx, xmlErrorPtr error));

extern VALUE cNokogiriXmlSyntaxError;
#endif

                                                                                                                                            xml_text.c                                                                                          0100644 0001750 0001750 00000002166 12566211316 043113  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_text.h>

/*
 * call-seq:
 *  new(content, document)
 *
 * Create a new Text element on the +document+ with +content+
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  VALUE string;
  VALUE document;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &string, &document, &rest);

  Data_Get_Struct(document, xmlDoc, doc);

  node = xmlNewText((xmlChar *)StringValuePtr(string));
  node->doc = doc->doc;

  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(klass, node) ;
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}

VALUE cNokogiriXmlText ;
void init_xml_text()
{
  VALUE nokogiri = rb_define_module("Nokogiri");
  VALUE xml = rb_define_module_under(nokogiri, "XML");
  /* */
  VALUE node = rb_define_class_under(xml, "Node", rb_cObject);
  VALUE char_data = rb_define_class_under(xml, "CharacterData", node);

  /*
   * Wraps Text nodes.
   */
  VALUE klass = rb_define_class_under(xml, "Text", char_data);

  cNokogiriXmlText = klass;

  rb_define_singleton_method(klass, "new", new, -1);
}
                                                                                                                                                                                                                                                                                                                                                                                                          xml_text.h                                                                                          0100644 0001750 0001750 00000000212 12566211316 043106  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_TEXT
#define NOKOGIRI_XML_TEXT

#include <nokogiri.h>

void init_xml_text();

extern VALUE cNokogiriXmlText ;
#endif
                                                                                                                                                                                                                                                                                                                                                                                      xml_xpath_context.c                                                                                 0100644 0001750 0001750 00000020440 12566211316 045012  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xml_xpath_context.h>

int vasprintf (char **strp, const char *fmt, va_list ap);

static void deallocate(xmlXPathContextPtr ctx)
{
  NOKOGIRI_DEBUG_START(ctx);
  xmlXPathFreeContext(ctx);
  NOKOGIRI_DEBUG_END(ctx);
}

/*
 * call-seq:
 *  register_ns(prefix, uri)
 *
 * Register the namespace with +prefix+ and +uri+.
 */
static VALUE register_ns(VALUE self, VALUE prefix, VALUE uri)
{
  xmlXPathContextPtr ctx;
  Data_Get_Struct(self, xmlXPathContext, ctx);

  xmlXPathRegisterNs( ctx,
                      (const xmlChar *)StringValuePtr(prefix),
                      (const xmlChar *)StringValuePtr(uri)
  );
  return self;
}

/*
 * call-seq:
 *  register_variable(name, value)
 *
 * Register the variable +name+ with +value+.
 */
static VALUE register_variable(VALUE self, VALUE name, VALUE value)
{
   xmlXPathContextPtr ctx;
   xmlXPathObjectPtr xmlValue;
   Data_Get_Struct(self, xmlXPathContext, ctx);

   xmlValue = xmlXPathNewCString(StringValuePtr(value));

   xmlXPathRegisterVariable( ctx,
      (const xmlChar *)StringValuePtr(name),
      xmlValue
   );

   return self;
}

void Nokogiri_marshal_xpath_funcall_and_return_values(xmlXPathParserContextPtr ctx, int nargs, VALUE handler, const char* function_name)
{
  int i;
  VALUE result, doc;
  VALUE *argv;
  VALUE node_set = Qnil;
  xmlNodeSetPtr xml_node_set = NULL;
  xmlXPathObjectPtr obj;
  nokogiriNodeSetTuple *node_set_tuple;

  assert(ctx->context->doc);
  assert(DOC_RUBY_OBJECT_TEST(ctx->context->doc));

  argv = (VALUE *)calloc((size_t)nargs, sizeof(VALUE));
  for (i = 0 ; i < nargs ; ++i) {
    rb_gc_register_address(&argv[i]);
  }

  doc = DOC_RUBY_OBJECT(ctx->context->doc);

  if (nargs > 0) {
    i = nargs - 1;
    do {
      obj = valuePop(ctx);
      switch(obj->type) {
        case XPATH_STRING:
          argv[i] = NOKOGIRI_STR_NEW2(obj->stringval);
          break;
        case XPATH_BOOLEAN:
          argv[i] = obj->boolval == 1 ? Qtrue : Qfalse;
          break;
        case XPATH_NUMBER:
          argv[i] = rb_float_new(obj->floatval);
          break;
        case XPATH_NODESET:
          argv[i] = Nokogiri_wrap_xml_node_set(obj->nodesetval, doc);
          break;
        default:
          argv[i] = NOKOGIRI_STR_NEW2(xmlXPathCastToString(obj));
      }
      xmlXPathFreeNodeSetList(obj);
    } while(i-- > 0);
  }

  result = rb_funcall2(handler, rb_intern((const char*)function_name), nargs, argv);

  for (i = 0 ; i < nargs ; ++i) {
    rb_gc_unregister_address(&argv[i]);
  }
  free(argv);

  switch(TYPE(result)) {
    case T_FLOAT:
    case T_BIGNUM:
    case T_FIXNUM:
      xmlXPathReturnNumber(ctx, NUM2DBL(result));
      break;
    case T_STRING:
      xmlXPathReturnString(
          ctx,
          xmlCharStrdup(StringValuePtr(result))
      );
      break;
    case T_TRUE:
      xmlXPathReturnTrue(ctx);
      break;
    case T_FALSE:
      xmlXPathReturnFalse(ctx);
      break;
    case T_NIL:
      break;
    case T_ARRAY:
      {
        VALUE args[2];
	args[0] = doc;
	args[1] = result;
        node_set = rb_class_new_instance(2, args, cNokogiriXmlNodeSet);
        Data_Get_Struct(node_set, nokogiriNodeSetTuple, node_set_tuple);
	xml_node_set = node_set_tuple->node_set;
        xmlXPathReturnNodeSet(ctx, xmlXPathNodeSetMerge(NULL, xml_node_set));
      }
      break;
    case T_DATA:
      if(rb_obj_is_kind_of(result, cNokogiriXmlNodeSet)) {
        Data_Get_Struct(result, nokogiriNodeSetTuple, node_set_tuple);
	xml_node_set = node_set_tuple->node_set;
        /* Copy the node set, otherwise it will get GC'd. */
        xmlXPathReturnNodeSet(ctx, xmlXPathNodeSetMerge(NULL, xml_node_set));
        break;
      }
    default:
      rb_raise(rb_eRuntimeError, "Invalid return type");
  }
}

static void ruby_funcall(xmlXPathParserContextPtr ctx, int nargs)
{
  VALUE handler = Qnil;
  const char *function = NULL ;

  assert(ctx);
  assert(ctx->context);
  assert(ctx->context->userData);
  assert(ctx->context->function);

  handler = (VALUE)(ctx->context->userData);
  function = (const char*)(ctx->context->function);

  Nokogiri_marshal_xpath_funcall_and_return_values(ctx, nargs, handler, function);
}

static xmlXPathFunction lookup( void *ctx,
                                const xmlChar * name,
                                const xmlChar* ns_uri )
{
  VALUE xpath_handler = (VALUE)ctx;
  if(rb_respond_to(xpath_handler, rb_intern((const char *)name)))
    return ruby_funcall;

  return NULL;
}

NORETURN(static void xpath_exception_handler(void * ctx, xmlErrorPtr error));
static void xpath_exception_handler(void * ctx, xmlErrorPtr error)
{
  VALUE xpath = rb_const_get(mNokogiriXml, rb_intern("XPath"));
  VALUE klass = rb_const_get(xpath, rb_intern("SyntaxError"));

  rb_exc_raise(Nokogiri_wrap_xml_syntax_error(klass, error));
}

NORETURN(static void xpath_generic_exception_handler(void * ctx, const char *msg, ...));
static void xpath_generic_exception_handler(void * ctx, const char *msg, ...)
{
  char * message;

  va_list args;
  va_start(args, msg);
  vasprintf(&message, msg, args);
  va_end(args);

  rb_raise(rb_eRuntimeError, "%s", message);
}

/*
 * call-seq:
 *  evaluate(search_path, handler = nil)
 *
 * Evaluate the +search_path+ returning an XML::XPath object.
 */
static VALUE evaluate(int argc, VALUE *argv, VALUE self)
{
  VALUE search_path, xpath_handler;
  VALUE thing = Qnil;
  xmlXPathContextPtr ctx;
  xmlXPathObjectPtr xpath;
  xmlChar *query;

  Data_Get_Struct(self, xmlXPathContext, ctx);

  if(rb_scan_args(argc, argv, "11", &search_path, &xpath_handler) == 1)
    xpath_handler = Qnil;

  query = (xmlChar *)StringValuePtr(search_path);

  if(Qnil != xpath_handler) {
    /* FIXME: not sure if this is the correct place to shove private data. */
    ctx->userData = (void *)xpath_handler;
    xmlXPathRegisterFuncLookup(ctx, lookup, (void *)xpath_handler);
  }

  xmlResetLastError();
  xmlSetStructuredErrorFunc(NULL, xpath_exception_handler);

  /* For some reason, xmlXPathEvalExpression will blow up with a generic error */
  /* when there is a non existent function. */
  xmlSetGenericErrorFunc(NULL, xpath_generic_exception_handler);

  xpath = xmlXPathEvalExpression(query, ctx);
  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlSetGenericErrorFunc(NULL, NULL);

  if(xpath == NULL) {
    VALUE xpath = rb_const_get(mNokogiriXml, rb_intern("XPath"));
    VALUE klass = rb_const_get(xpath, rb_intern("SyntaxError"));

    xmlErrorPtr error = xmlGetLastError();
    rb_exc_raise(Nokogiri_wrap_xml_syntax_error(klass, error));
  }

  assert(ctx->doc);
  assert(DOC_RUBY_OBJECT_TEST(ctx->doc));

  switch(xpath->type) {
    case XPATH_STRING:
      thing = NOKOGIRI_STR_NEW2(xpath->stringval);
      xmlFree(xpath->stringval);
      break;
    case XPATH_NODESET:
      if(NULL == xpath->nodesetval) {
        thing = Nokogiri_wrap_xml_node_set(xmlXPathNodeSetCreate(NULL),
          DOC_RUBY_OBJECT(ctx->doc));
      } else {
        thing = Nokogiri_wrap_xml_node_set(xpath->nodesetval,
            DOC_RUBY_OBJECT(ctx->doc));
      }
      break;
    case XPATH_NUMBER:
      thing = rb_float_new(xpath->floatval);
      break;
    case XPATH_BOOLEAN:
      thing = xpath->boolval == 1 ? Qtrue : Qfalse;
      break;
    default:
      thing = Nokogiri_wrap_xml_node_set(xmlXPathNodeSetCreate(NULL),
        DOC_RUBY_OBJECT(ctx->doc));
  }

  xmlXPathFreeNodeSetList(xpath);

  return thing;
}

/*
 * call-seq:
 *  new(node)
 *
 * Create a new XPathContext with +node+ as the reference point.
 */
static VALUE new(VALUE klass, VALUE nodeobj)
{
  xmlNodePtr node;
  xmlXPathContextPtr ctx;
  VALUE self;

  xmlXPathInit();

  Data_Get_Struct(nodeobj, xmlNode, node);

  ctx = xmlXPathNewContext(node->doc);
  ctx->node = node;
  self = Data_Wrap_Struct(klass, 0, deallocate, ctx);
  /*rb_iv_set(self, "@xpath_handler", Qnil); */
  return self;
}

VALUE cNokogiriXmlXpathContext;
void init_xml_xpath_context(void)
{
  VALUE module = rb_define_module("Nokogiri");

  /*
   * Nokogiri::XML
   */
  VALUE xml = rb_define_module_under(module, "XML");

  /*
   * XPathContext is the entry point for searching a Document by using XPath.
   */
  VALUE klass = rb_define_class_under(xml, "XPathContext", rb_cObject);

  cNokogiriXmlXpathContext = klass;

  rb_define_singleton_method(klass, "new", new, 1);
  rb_define_method(klass, "evaluate", evaluate, -1);
  rb_define_method(klass, "register_variable", register_variable, 2);
  rb_define_method(klass, "register_ns", register_ns, 2);
}
                                                                                                                                                                                                                                xml_xpath_context.h                                                                                 0100644 0001750 0001750 00000000467 12566211316 045026  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XML_XPATH_CONTEXT
#define NOKOGIRI_XML_XPATH_CONTEXT

#include <nokogiri.h>

void init_xml_xpath_context();
void Nokogiri_marshal_xpath_funcall_and_return_values(xmlXPathParserContextPtr ctx, int nargs, VALUE handler, const char* function_name) ;

extern VALUE cNokogiriXmlXpathContext;
#endif
                                                                                                                                                                                                         xslt_stylesheet.c                                                                                   0100644 0001750 0001750 00000016400 12566211316 044506  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #include <xslt_stylesheet.h>

#include <libxslt/xsltInternals.h>
#include <libxslt/xsltutils.h>
#include <libxslt/transform.h>
#include <libexslt/exslt.h>

VALUE xslt;

int vasprintf (char **strp, const char *fmt, va_list ap);
void vasprintf_free (void *p);

static void mark(nokogiriXsltStylesheetTuple *wrapper)
{
  rb_gc_mark(wrapper->func_instances);
}

static void dealloc(nokogiriXsltStylesheetTuple *wrapper)
{
    xsltStylesheetPtr doc = wrapper->ss;

    NOKOGIRI_DEBUG_START(doc);
    xsltFreeStylesheet(doc); /* commented out for now. */
    NOKOGIRI_DEBUG_END(doc);
    
    free(wrapper);
}

static void xslt_generic_error_handler(void * ctx, const char *msg, ...)
{
  char * message;

  va_list args;
  va_start(args, msg);
  vasprintf(&message, msg, args);
  va_end(args);

  rb_str_cat2((VALUE)ctx, message);

  vasprintf_free(message);
}

VALUE Nokogiri_wrap_xslt_stylesheet(xsltStylesheetPtr ss)
{
  VALUE self;
  nokogiriXsltStylesheetTuple *wrapper;

  self = Data_Make_Struct(cNokogiriXsltStylesheet, nokogiriXsltStylesheetTuple,
                          mark, dealloc, wrapper);
  
  ss->_private = (void *)self;
  wrapper->ss = ss;
  wrapper->func_instances = rb_ary_new();

  return self;
}

/*
 * call-seq:
 *   parse_stylesheet_doc(document)
 *
 * Parse a stylesheet from +document+.
 */
static VALUE parse_stylesheet_doc(VALUE klass, VALUE xmldocobj)
{
    xmlDocPtr xml, xml_cpy;
    VALUE errstr, exception;
    xsltStylesheetPtr ss ;
    Data_Get_Struct(xmldocobj, xmlDoc, xml);
    exsltRegisterAll();

    errstr = rb_str_new(0, 0);
    xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);

    xml_cpy = xmlCopyDoc(xml, 1); /* 1 => recursive */
    ss = xsltParseStylesheetDoc(xml_cpy);

    xsltSetGenericErrorFunc(NULL, NULL);

    if (!ss) {
	xmlFreeDoc(xml_cpy);
	exception = rb_exc_new3(rb_eRuntimeError, errstr);
	rb_exc_raise(exception);
    }

    return Nokogiri_wrap_xslt_stylesheet(ss);
}


/*
 * call-seq:
 *   serialize(document)
 *
 * Serialize +document+ to an xml string.
 */
static VALUE serialize(VALUE self, VALUE xmlobj)
{
    xmlDocPtr xml ;
    nokogiriXsltStylesheetTuple *wrapper;
    xmlChar* doc_ptr ;
    int doc_len ;
    VALUE rval ;

    Data_Get_Struct(xmlobj, xmlDoc, xml);
    Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);
    xsltSaveResultToString(&doc_ptr, &doc_len, xml, wrapper->ss);
    rval = NOKOGIRI_STR_NEW(doc_ptr, doc_len);
    xmlFree(doc_ptr);
    return rval ;
}

static void swallow_superfluous_xml_errors(void * userdata, xmlErrorPtr error, ...)
{
}

/*
 *  call-seq:
 *    transform(document, params = [])
 *
 *  Apply an XSLT stylesheet to an XML::Document.
 *  +params+ is an array of strings used as XSLT parameters.
 *  returns Nokogiri::XML::Document
 *
 *  Example:
 * 
 *    doc   = Nokogiri::XML(File.read(ARGV[0]))
 *    xslt  = Nokogiri::XSLT(File.read(ARGV[1]))
 *    puts xslt.transform(doc, ['key', 'value'])
 *
 */
static VALUE transform(int argc, VALUE* argv, VALUE self)
{
    VALUE xmldoc, paramobj, errstr, exception ;
    xmlDocPtr xml ;
    xmlDocPtr result ;
    nokogiriXsltStylesheetTuple *wrapper;
    const char** params ;
    long param_len, j ;
    int parse_error_occurred ;

    rb_scan_args(argc, argv, "11", &xmldoc, &paramobj);
    if (NIL_P(paramobj)) { paramobj = rb_ary_new2(0L) ; }
    if (!rb_obj_is_kind_of(xmldoc, cNokogiriXmlDocument))
      rb_raise(rb_eArgError, "argument must be a Nokogiri::XML::Document");

    /* handle hashes as arguments. */
    if(T_HASH == TYPE(paramobj)) {
      paramobj = rb_funcall(paramobj, rb_intern("to_a"), 0);
      paramobj = rb_funcall(paramobj, rb_intern("flatten"), 0);
    }

    Check_Type(paramobj, T_ARRAY);

    Data_Get_Struct(xmldoc, xmlDoc, xml);
    Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);

    param_len = RARRAY_LEN(paramobj);
    params = calloc((size_t)param_len+1, sizeof(char*));
    for (j = 0 ; j < param_len ; j++) {
      VALUE entry = rb_ary_entry(paramobj, j);
      const char * ptr = StringValuePtr(entry);
      params[j] = ptr;
    }
    params[param_len] = 0 ;

    errstr = rb_str_new(0, 0);
    xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);
    xmlSetGenericErrorFunc(NULL, (xmlGenericErrorFunc)&swallow_superfluous_xml_errors);

    result = xsltApplyStylesheet(wrapper->ss, xml, params);
    free(params);

    xsltSetGenericErrorFunc(NULL, NULL);
    xmlSetGenericErrorFunc(NULL, NULL);

    parse_error_occurred = (Qfalse == rb_funcall(errstr, rb_intern("empty?"), 0));

    if (parse_error_occurred) {
      exception = rb_exc_new3(rb_eRuntimeError, errstr);
      rb_exc_raise(exception);
    }

    return Nokogiri_wrap_xml_document((VALUE)0, result) ;
}

static void method_caller(xmlXPathParserContextPtr ctxt, int nargs)
{
    VALUE handler;
    const char *function_name;
    xsltTransformContextPtr transform;
    const xmlChar *functionURI;

    transform = xsltXPathGetTransformContext(ctxt);
    functionURI = ctxt->context->functionURI;
    handler = (VALUE)xsltGetExtData(transform, functionURI);
    function_name = (const char*)(ctxt->context->function);

    Nokogiri_marshal_xpath_funcall_and_return_values(ctxt, nargs, handler, (const char*)function_name);
}

static void * initFunc(xsltTransformContextPtr ctxt, const xmlChar *uri)
{
    VALUE modules = rb_iv_get(xslt, "@modules");
    VALUE obj = rb_hash_aref(modules, rb_str_new2((const char *)uri));
    VALUE args = { Qfalse };
    VALUE methods = rb_funcall(obj, rb_intern("instance_methods"), 1, args);
    VALUE inst;
    nokogiriXsltStylesheetTuple *wrapper;
    int i;

    for(i = 0; i < RARRAY_LEN(methods); i++) {
	VALUE method_name = rb_obj_as_string(RARRAY_PTR(methods)[i]);
	xsltRegisterExtFunction(ctxt,
          (unsigned char *)StringValuePtr(method_name), uri, method_caller);
    }

    Data_Get_Struct(ctxt->style->_private, nokogiriXsltStylesheetTuple,
                    wrapper);
    inst = rb_class_new_instance(0, NULL, obj);
    rb_ary_push(wrapper->func_instances, inst);

    return (void *)inst;
}

static void shutdownFunc(xsltTransformContextPtr ctxt,
	const xmlChar *uri, void *data)
{
    nokogiriXsltStylesheetTuple *wrapper;

    Data_Get_Struct(ctxt->style->_private, nokogiriXsltStylesheetTuple,
                    wrapper);

    rb_ary_clear(wrapper->func_instances);
}

/*
 *  call-seq:
 *    register(uri, custom_handler_class)
 *
 *  Register a class that implements custom XLST transformation functions.
 */
static VALUE registr(VALUE self, VALUE uri, VALUE obj)
{
    VALUE modules = rb_iv_get(self, "@modules");
    if(NIL_P(modules)) rb_raise(rb_eRuntimeError, "wtf! @modules isn't set");

    rb_hash_aset(modules, uri, obj);
    xsltRegisterExtModule((unsigned char *)StringValuePtr(uri), initFunc, shutdownFunc);
    return self;
}

VALUE cNokogiriXsltStylesheet ;
void init_xslt_stylesheet()
{
  VALUE nokogiri;
  VALUE klass;

  nokogiri = rb_define_module("Nokogiri");
  xslt = rb_define_module_under(nokogiri, "XSLT");
  klass = rb_define_class_under(xslt, "Stylesheet", rb_cObject);

  rb_iv_set(xslt, "@modules", rb_hash_new());

  cNokogiriXsltStylesheet = klass;

  rb_define_singleton_method(klass, "parse_stylesheet_doc", parse_stylesheet_doc, 1);
  rb_define_singleton_method(xslt, "register", registr, 2);
  rb_define_method(klass, "serialize", serialize, 1);
  rb_define_method(klass, "transform", transform, -1);
}
                                                                                                                                                                                                                                                                xslt_stylesheet.h                                                                                   0100644 0001750 0001750 00000000444 12566211316 044514  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/ext/nokogiri                     #ifndef NOKOGIRI_XSLT_STYLESHEET
#define NOKOGIRI_XSLT_STYLESHEET

#include <nokogiri.h>

void init_xslt_stylesheet();

extern VALUE cNokogiriXsltStylesheet ;

typedef struct _nokogiriXsltStylesheetTuple {
  xsltStylesheetPtr ss;
  VALUE func_instances;
} nokogiriXsltStylesheetTuple;
#endif
                                                                                                                                                                                                                            lib/                                                                                                0040755 0001750 0001750 00000000000 12612224746 037231  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6                                  nokogiri/                                                                                           0040755 0001750 0001750 00000000000 12612224746 041052  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib                              css/                                                                                                0040755 0001750 0001750 00000000000 12612224746 041642  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     node.rb                                                                                             0100644 0001750 0001750 00000005755 12566211316 043122  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 module Nokogiri
  module CSS
    class Node
      ALLOW_COMBINATOR_ON_SELF = [:DIRECT_ADJACENT_SELECTOR, :FOLLOWING_SELECTOR, :CHILD_SELECTOR]

      # Get the type of this node
      attr_accessor :type
      # Get the value of this node
      attr_accessor :value

      # Create a new Node with +type+ and +value+
      def initialize type, value
        @type = type
        @value = value
      end

      # Accept +visitor+
      def accept visitor
        visitor.send(:"visit_#{type.to_s.downcase}", self)
      end

      ###
      # Convert this CSS node to xpath with +prefix+ using +visitor+
      def to_xpath prefix = '//', visitor = XPathVisitor.new
        self.preprocess!
        prefix = '.' if ALLOW_COMBINATOR_ON_SELF.include?(type) && value.first.nil?
        prefix + visitor.accept(self)
      end

      # Preprocess this node tree
      def preprocess!
        ### Deal with nth-child
        matches = find_by_type(
          [:CONDITIONAL_SELECTOR,
            [:ELEMENT_NAME],
            [:PSEUDO_CLASS,
              [:FUNCTION]
            ]
          ]
        )
        matches.each do |match|
          if match.value[1].value[0].value[0] =~ /^nth-(last-)?child/
            tag_name = match.value[0].value.first
            match.value[0].value = ['*']
            match.value[1] = Node.new(:COMBINATOR, [
              match.value[1].value[0],
              Node.new(:FUNCTION, ['self(', tag_name])
            ])
          end
        end

        ### Deal with first-child, last-child
        matches = find_by_type(
          [:CONDITIONAL_SELECTOR,
            [:ELEMENT_NAME], [:PSEUDO_CLASS]
        ])
        matches.each do |match|
          if ['first-child', 'last-child'].include?(match.value[1].value.first)
            which = match.value[1].value.first.gsub(/-\w*$/, '')
            tag_name = match.value[0].value.first
            match.value[0].value = ['*']
            match.value[1] = Node.new(:COMBINATOR, [
              Node.new(:FUNCTION, ["#{which}("]),
              Node.new(:FUNCTION, ['self(', tag_name])
            ])
          elsif 'only-child' == match.value[1].value.first
            tag_name = match.value[0].value.first
            match.value[0].value = ['*']
            match.value[1] = Node.new(:COMBINATOR, [
              Node.new(:FUNCTION, ["#{match.value[1].value.first}("]),
              Node.new(:FUNCTION, ['self(', tag_name])
            ])
          end
        end

        self
      end

      # Find a node by type using +types+
      def find_by_type types
        matches = []
        matches << self if to_type == types
        @value.each do |v|
          matches += v.find_by_type(types) if v.respond_to?(:find_by_type)
        end
        matches
      end

      # Convert to_type
      def to_type
        [@type] + @value.map { |n|
          n.to_type if n.respond_to?(:to_type)
        }.compact
      end

      # Convert to array
      def to_a
        [@type] + @value.map { |n| n.respond_to?(:to_a) ? n.to_a : [n] }
      end
    end
  end
end
                   parser.rb                                                                                           0100644 0001750 0001750 00000041620 12566211316 043460  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 #
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.8
# from Racc grammer file "".
#

require 'racc/parser.rb'


require 'nokogiri/css/parser_extras'
module Nokogiri
  module CSS
    class Parser < Racc::Parser
##### State transition tables begin ###

racc_action_table = [
    21,     4,     5,     7,    29,     4,     5,     7,    30,    19,
   -26,     6,    21,     9,     8,     6,    29,     9,     8,    22,
    31,    19,    20,    21,    23,    15,    17,    29,    24,    83,
    31,    22,    19,    84,    20,    21,    23,    15,    17,    29,
    24,    92,    22,    85,    19,    20,    21,    23,    15,    17,
    20,    24,    82,    90,    22,    59,    24,    20,    89,    23,
    15,    17,    21,    24,    88,    22,    29,     4,     5,     7,
    23,    19,    71,    29,    91,    29,    86,     6,    19,     9,
     8,    22,    29,    29,    20,    89,    23,    15,    17,    35,
    24,    20,    29,    20,    15,    17,    15,    24,    35,    24,
    20,    20,    29,    15,    15,    93,    24,    24,    21,    64,
    20,    95,    29,    15,    97,    96,    24,    43,   -26,    46,
    20,    52,    53,    15,    51,    98,    24,    22,    79,    80,
    20,    99,    23,    15,    48,    42,    24,    79,    80,    75,
    76,    77,   101,    78,    87,    86,    41,    74,    75,    76,
    77,    35,    78,   104,    52,    56,    74,    55,    52,    56,
   105,    55,    52,    56,   nil,    55,    52,    56,   nil,    55 ]

racc_action_check = [
     0,    14,    14,    14,     0,     0,     0,     0,     1,     0,
    43,    14,    40,    14,    14,     0,    40,     0,     0,     0,
     1,    40,     0,    31,     0,     0,     0,    31,     0,    47,
    57,    40,    31,    49,    40,    13,    40,    40,    40,    13,
    40,    57,    31,    50,    13,    31,    24,    31,    31,    31,
    11,    31,    46,    53,    13,    24,    11,    13,    53,    13,
    13,    13,    23,    13,    52,    24,    23,    23,    23,    23,
    24,    23,    42,    35,    54,    28,    55,    23,    35,    23,
    23,    23,    27,    10,    23,    56,    23,    23,    23,    33,
    23,    35,    26,    28,    35,    35,    28,    35,    10,    28,
    27,    10,    25,    27,    10,    67,    27,    10,    20,    30,
    26,    72,    68,    26,    73,    73,    26,    20,    19,    20,
    25,    21,    21,    25,    21,    81,    25,    20,    45,    45,
    68,    83,    20,    68,    21,    18,    68,    44,    44,    45,
    45,    45,    87,    45,    51,    51,    15,    45,    44,    44,
    44,    12,    44,    90,    89,    89,    44,    89,    86,    86,
   101,    86,    88,    88,   nil,    88,    22,    22,   nil,    22 ]

racc_action_pointer = [
    -2,     8,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
    77,    26,   130,    33,    -6,   135,   nil,   nil,   106,    89,
   106,   111,   156,    60,    44,    96,    86,    76,    69,   nil,
   109,    21,   nil,    68,   nil,    67,   nil,   nil,   nil,   nil,
    10,   nil,    61,   -19,   134,   125,    27,     0,   nil,    10,
    20,   133,    52,    46,    51,    64,    73,    18,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,    82,   106,   nil,
   nil,   nil,    86,   104,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   100,   nil,   120,   nil,   nil,   148,   135,   152,   144,
   140,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   147,   nil,   nil,   nil,   nil ]

racc_action_default = [
   -27,   -74,    -2,    -3,    -4,    -5,    -6,    -7,    -8,    -9,
   -50,   -13,   -17,   -27,   -20,   -74,   -22,   -23,   -74,   -25,
   -27,   -74,   -74,   -27,   -74,   -55,   -56,   -57,   -58,   -59,
   -74,   -27,   -10,   -49,   -12,   -27,   -14,   -15,   -16,   -18,
   -27,   -21,   -74,   -32,   -62,   -62,   -74,   -74,   -33,   -74,
   -74,   -41,   -42,   -43,   -74,   -41,   -43,   -74,   -47,   -48,
   -51,   -52,   -53,   -54,   106,    -1,   -11,   -74,   -71,   -73,
   -19,   -24,   -74,   -74,   -63,   -64,   -65,   -66,   -67,   -68,
   -69,   -74,   -30,   -74,   -34,   -35,   -74,   -46,   -74,   -74,
   -74,   -36,   -37,   -70,   -72,   -28,   -60,   -61,   -29,   -31,
   -38,   -74,   -39,   -40,   -45,   -44 ]

racc_goto_table = [
    49,    54,    33,    39,    36,     1,    34,    45,    38,    72,
    81,    58,    32,    37,    47,    44,    68,    60,    61,    62,
    63,    65,    40,    50,    67,   nil,   nil,    69,    57,    66,
    70,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
    94,   nil,   nil,   nil,   nil,   100,   nil,   102,   103 ]

racc_goto_check = [
    18,    18,     8,     2,    11,     1,     9,    10,     9,    17,
    17,    10,     7,    12,    15,    16,     6,     8,     8,     8,
     8,     2,     4,    19,    22,   nil,   nil,     8,     1,     9,
     2,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
     8,   nil,   nil,   nil,   nil,    18,   nil,    18,    18 ]

racc_goto_pointer = [
   nil,     5,   -10,   nil,     8,   nil,   -19,     2,    -8,    -4,
   -13,    -7,     2,   nil,   nil,    -6,    -5,   -35,   -21,     2,
   nil,   nil,   -11 ]

racc_goto_default = [
   nil,   nil,     3,     2,    13,    14,    10,   nil,    12,   nil,
    11,    28,    27,    26,    16,    18,   nil,   nil,   nil,   nil,
    25,    73,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  3, 32, :_reduce_1,
  1, 32, :_reduce_2,
  1, 32, :_reduce_3,
  1, 35, :_reduce_4,
  1, 35, :_reduce_5,
  1, 35, :_reduce_6,
  1, 35, :_reduce_7,
  1, 35, :_reduce_8,
  1, 35, :_reduce_9,
  2, 36, :_reduce_10,
  3, 36, :_reduce_11,
  2, 36, :_reduce_12,
  1, 36, :_reduce_none,
  2, 36, :_reduce_14,
  2, 36, :_reduce_15,
  2, 36, :_reduce_16,
  1, 36, :_reduce_17,
  2, 34, :_reduce_18,
  3, 33, :_reduce_19,
  1, 33, :_reduce_none,
  2, 44, :_reduce_21,
  1, 37, :_reduce_none,
  1, 37, :_reduce_23,
  3, 45, :_reduce_24,
  1, 45, :_reduce_25,
  1, 46, :_reduce_26,
  0, 46, :_reduce_none,
  4, 43, :_reduce_28,
  4, 43, :_reduce_29,
  3, 43, :_reduce_30,
  3, 47, :_reduce_31,
  1, 47, :_reduce_32,
  2, 41, :_reduce_33,
  3, 41, :_reduce_34,
  3, 41, :_reduce_35,
  3, 41, :_reduce_36,
  3, 41, :_reduce_37,
  3, 49, :_reduce_38,
  3, 49, :_reduce_39,
  3, 49, :_reduce_40,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_43,
  4, 50, :_reduce_44,
  3, 50, :_reduce_45,
  2, 50, :_reduce_46,
  2, 42, :_reduce_47,
  2, 42, :_reduce_48,
  1, 38, :_reduce_none,
  0, 38, :_reduce_none,
  2, 39, :_reduce_51,
  2, 39, :_reduce_52,
  2, 39, :_reduce_53,
  2, 39, :_reduce_54,
  1, 39, :_reduce_none,
  1, 39, :_reduce_none,
  1, 39, :_reduce_none,
  1, 39, :_reduce_none,
  1, 51, :_reduce_59,
  2, 48, :_reduce_60,
  2, 48, :_reduce_61,
  0, 48, :_reduce_none,
  1, 52, :_reduce_63,
  1, 52, :_reduce_64,
  1, 52, :_reduce_65,
  1, 52, :_reduce_66,
  1, 52, :_reduce_67,
  1, 52, :_reduce_68,
  1, 52, :_reduce_69,
  3, 40, :_reduce_70,
  1, 53, :_reduce_none,
  2, 53, :_reduce_none,
  1, 53, :_reduce_none ]

racc_reduce_n = 74

racc_shift_n = 106

racc_token_table = {
  false => 0,
  :error => 1,
  :FUNCTION => 2,
  :INCLUDES => 3,
  :DASHMATCH => 4,
  :LBRACE => 5,
  :HASH => 6,
  :PLUS => 7,
  :GREATER => 8,
  :S => 9,
  :STRING => 10,
  :IDENT => 11,
  :COMMA => 12,
  :NUMBER => 13,
  :PREFIXMATCH => 14,
  :SUFFIXMATCH => 15,
  :SUBSTRINGMATCH => 16,
  :TILDE => 17,
  :NOT_EQUAL => 18,
  :SLASH => 19,
  :DOUBLESLASH => 20,
  :NOT => 21,
  :EQUAL => 22,
  :RPAREN => 23,
  :LSQUARE => 24,
  :RSQUARE => 25,
  :HAS => 26,
  "." => 27,
  "*" => 28,
  "|" => 29,
  ":" => 30 }

racc_nt_base = 31

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "FUNCTION",
  "INCLUDES",
  "DASHMATCH",
  "LBRACE",
  "HASH",
  "PLUS",
  "GREATER",
  "S",
  "STRING",
  "IDENT",
  "COMMA",
  "NUMBER",
  "PREFIXMATCH",
  "SUFFIXMATCH",
  "SUBSTRINGMATCH",
  "TILDE",
  "NOT_EQUAL",
  "SLASH",
  "DOUBLESLASH",
  "NOT",
  "EQUAL",
  "RPAREN",
  "LSQUARE",
  "RSQUARE",
  "HAS",
  "\".\"",
  "\"*\"",
  "\"|\"",
  "\":\"",
  "$start",
  "selector",
  "simple_selector_1toN",
  "prefixless_combinator_selector",
  "combinator",
  "simple_selector",
  "element_name",
  "hcap_0toN",
  "hcap_1toN",
  "negation",
  "function",
  "pseudo",
  "attrib",
  "class",
  "namespaced_ident",
  "namespace",
  "attrib_name",
  "attrib_val_0or1",
  "expr",
  "an_plus_b",
  "attribute_id",
  "eql_incl_dash",
  "negation_arg" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

def _reduce_1(val, _values, result)
        result = [val.first, val.last].flatten
      
    result
end

def _reduce_2(val, _values, result)
 result = val.flatten 
    result
end

def _reduce_3(val, _values, result)
 result = val.flatten 
    result
end

def _reduce_4(val, _values, result)
 result = :DIRECT_ADJACENT_SELECTOR 
    result
end

def _reduce_5(val, _values, result)
 result = :CHILD_SELECTOR 
    result
end

def _reduce_6(val, _values, result)
 result = :FOLLOWING_SELECTOR 
    result
end

def _reduce_7(val, _values, result)
 result = :DESCENDANT_SELECTOR 
    result
end

def _reduce_8(val, _values, result)
 result = :DESCENDANT_SELECTOR 
    result
end

def _reduce_9(val, _values, result)
 result = :CHILD_SELECTOR 
    result
end

def _reduce_10(val, _values, result)
        result =  if val[1].nil?
                    val.first
                  else
                    Node.new(:CONDITIONAL_SELECTOR, [val.first, val[1]])
                  end
      
    result
end

def _reduce_11(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR,
          [
            val.first,
            Node.new(:COMBINATOR, [val[1], val.last])
          ]
        )
      
    result
end

def _reduce_12(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR, val)
      
    result
end

# reduce 13 omitted

def _reduce_14(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR, val)
      
    result
end

def _reduce_15(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR, val)
      
    result
end

def _reduce_16(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR,
          [
            Node.new(:ELEMENT_NAME, ['*']),
            Node.new(:COMBINATOR, val)
          ]
        )
      
    result
end

def _reduce_17(val, _values, result)
        result = Node.new(:CONDITIONAL_SELECTOR,
          [Node.new(:ELEMENT_NAME, ['*']), val.first]
        )
      
    result
end

def _reduce_18(val, _values, result)
        result = Node.new(val.first, [nil, val.last])
      
    result
end

def _reduce_19(val, _values, result)
        result = Node.new(val[1], [val.first, val.last])
      
    result
end

# reduce 20 omitted

def _reduce_21(val, _values, result)
 result = Node.new(:CLASS_CONDITION, [val[1]]) 
    result
end

# reduce 22 omitted

def _reduce_23(val, _values, result)
 result = Node.new(:ELEMENT_NAME, val) 
    result
end

def _reduce_24(val, _values, result)
        result = Node.new(:ELEMENT_NAME,
          [[val.first, val.last].compact.join(':')]
        )
      
    result
end

def _reduce_25(val, _values, result)
        name = @namespaces.key?('xmlns') ? "xmlns:#{val.first}" : val.first
        result = Node.new(:ELEMENT_NAME, [name])
      
    result
end

def _reduce_26(val, _values, result)
 result = val[0] 
    result
end

# reduce 27 omitted

def _reduce_28(val, _values, result)
        result = Node.new(:ATTRIBUTE_CONDITION,
          [val[1]] + (val[2] || [])
        )
      
    result
end

def _reduce_29(val, _values, result)
        result = Node.new(:ATTRIBUTE_CONDITION,
          [val[1]] + (val[2] || [])
        )
      
    result
end

def _reduce_30(val, _values, result)
        # Non standard, but hpricot supports it.
        result = Node.new(:PSEUDO_CLASS,
          [Node.new(:FUNCTION, ['nth-child(', val[1]])]
        )
      
    result
end

def _reduce_31(val, _values, result)
        result = Node.new(:ELEMENT_NAME,
          [[val.first, val.last].compact.join(':')]
        )
      
    result
end

def _reduce_32(val, _values, result)
        # Default namespace is not applied to attributes.
        # So we don't add prefix "xmlns:" as in namespaced_ident.
        result = Node.new(:ELEMENT_NAME, [val.first])
      
    result
end

def _reduce_33(val, _values, result)
        result = Node.new(:FUNCTION, [val.first.strip])
      
    result
end

def _reduce_34(val, _values, result)
        result = Node.new(:FUNCTION, [val.first.strip, val[1]].flatten)
      
    result
end

def _reduce_35(val, _values, result)
        result = Node.new(:FUNCTION, [val.first.strip, val[1]].flatten)
      
    result
end

def _reduce_36(val, _values, result)
        result = Node.new(:FUNCTION, [val.first.strip, val[1]].flatten)
      
    result
end

def _reduce_37(val, _values, result)
        result = Node.new(:FUNCTION, [val.first.strip, val[1]].flatten)
      
    result
end

def _reduce_38(val, _values, result)
 result = [val.first, val.last] 
    result
end

def _reduce_39(val, _values, result)
 result = [val.first, val.last] 
    result
end

def _reduce_40(val, _values, result)
 result = [val.first, val.last] 
    result
end

# reduce 41 omitted

# reduce 42 omitted

def _reduce_43(val, _values, result)
        if val[0] == 'even'
          val = ["2","n","+","0"]
          result = Node.new(:AN_PLUS_B, val)
        elsif val[0] == 'odd'
          val = ["2","n","+","1"]
          result = Node.new(:AN_PLUS_B, val)
        else
          # This is not CSS standard.  It allows us to support this:
          # assert_xpath("//a[foo(., @href)]", @parser.parse('a:foo(@href)'))
          # assert_xpath("//a[foo(., @a, b)]", @parser.parse('a:foo(@a, b)'))
          # assert_xpath("//a[foo(., a, 10)]", @parser.parse('a:foo(a, 10)'))
          result = val
        end
      
    result
end

def _reduce_44(val, _values, result)
        if val[1] == 'n'
          result = Node.new(:AN_PLUS_B, val)
        else
          raise Racc::ParseError, "parse error on IDENT '#{val[1]}'"
        end
      
    result
end

def _reduce_45(val, _values, result)
               # n+3, -n+3
        if val[0] == 'n'
          val.unshift("1")
          result = Node.new(:AN_PLUS_B, val)
        elsif val[0] == '-n'
          val[0] = 'n'
          val.unshift("-1")
          result = Node.new(:AN_PLUS_B, val)
        else
          raise Racc::ParseError, "parse error on IDENT '#{val[1]}'"
        end
      
    result
end

def _reduce_46(val, _values, result)
        if val[1] == 'n'
          val << "+"
          val << "0"
          result = Node.new(:AN_PLUS_B, val)
        else
          raise Racc::ParseError, "parse error on IDENT '#{val[1]}'"
        end
      
    result
end

def _reduce_47(val, _values, result)
        result = Node.new(:PSEUDO_CLASS, [val[1]])
      
    result
end

def _reduce_48(val, _values, result)
 result = Node.new(:PSEUDO_CLASS, [val[1]]) 
    result
end

# reduce 49 omitted

# reduce 50 omitted

def _reduce_51(val, _values, result)
        result = Node.new(:COMBINATOR, val)
      
    result
end

def _reduce_52(val, _values, result)
        result = Node.new(:COMBINATOR, val)
      
    result
end

def _reduce_53(val, _values, result)
        result = Node.new(:COMBINATOR, val)
      
    result
end

def _reduce_54(val, _values, result)
        result = Node.new(:COMBINATOR, val)
      
    result
end

# reduce 55 omitted

# reduce 56 omitted

# reduce 57 omitted

# reduce 58 omitted

def _reduce_59(val, _values, result)
 result = Node.new(:ID, val) 
    result
end

def _reduce_60(val, _values, result)
 result = [val.first, val[1]] 
    result
end

def _reduce_61(val, _values, result)
 result = [val.first, val[1]] 
    result
end

# reduce 62 omitted

def _reduce_63(val, _values, result)
 result = :equal 
    result
end

def _reduce_64(val, _values, result)
 result = :prefix_match 
    result
end

def _reduce_65(val, _values, result)
 result = :suffix_match 
    result
end

def _reduce_66(val, _values, result)
 result = :substring_match 
    result
end

def _reduce_67(val, _values, result)
 result = :not_equal 
    result
end

def _reduce_68(val, _values, result)
 result = :includes 
    result
end

def _reduce_69(val, _values, result)
 result = :dash_match 
    result
end

def _reduce_70(val, _values, result)
        result = Node.new(:NOT, [val[1]])
      
    result
end

# reduce 71 omitted

# reduce 72 omitted

# reduce 73 omitted

def _reduce_none(val, _values, result)
  val[0]
end

    end   # class Parser
    end   # module CSS
  end   # module Nokogiri
                                                                                                                parser_extras.rb                                                                                    0100644 0001750 0001750 00000004566 12566211316 045056  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 require 'thread'

module Nokogiri
  module CSS
    class Parser < Racc::Parser
      @cache_on = true
      @cache    = {}
      @mutex    = Mutex.new

      class << self
        # Turn on CSS parse caching
        attr_accessor :cache_on
        alias :cache_on? :cache_on
        alias :set_cache :cache_on=

        # Get the css selector in +string+ from the cache
        def [] string
          return unless @cache_on
          @mutex.synchronize { @cache[string] }
        end

        # Set the css selector in +string+ in the cache to +value+
        def []= string, value
          return value unless @cache_on
          @mutex.synchronize { @cache[string] = value }
        end

        # Clear the cache
        def clear_cache
          @mutex.synchronize { @cache = {} }
        end

        # Execute +block+ without cache
        def without_cache &block
          tmp = @cache_on
          @cache_on = false
          block.call
          @cache_on = tmp
        end

        ###
        # Parse this CSS selector in +selector+.  Returns an AST.
        def parse selector
          @warned ||= false
          unless @warned
            $stderr.puts('Nokogiri::CSS::Parser.parse is deprecated, call Nokogiri::CSS.parse(), this will be removed August 1st or version 1.4.0 (whichever is first)')
            @warned = true
          end
          new.parse selector
        end
      end

      # Create a new CSS parser with respect to +namespaces+
      def initialize namespaces = {}
        @tokenizer  = Tokenizer.new
        @namespaces = namespaces
        super()
      end

      def parse string
        @tokenizer.scan_setup string
        do_parse
      end

      def next_token
        @tokenizer.next_token
      end

      # Get the xpath for +string+ using +options+
      def xpath_for string, options={}
        key = "#{string}#{options[:ns]}#{options[:prefix]}"
        v = self.class[key]
        return v if v

        args = [
          options[:prefix] || '//',
          options[:visitor] || XPathVisitor.new
        ]
        self.class[key] = parse(string).map { |ast|
          ast.to_xpath(*args)
        }
      end

      # On CSS parser error, raise an exception
      def on_error error_token_id, error_value, value_stack
        after = value_stack.compact.last
        raise SyntaxError.new("unexpected '#{error_value}' after '#{after}'")
      end
    end
  end
end
                                                                                                                                          syntax_error.rb                                                                                     0100644 0001750 0001750 00000000177 12566211316 044725  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 require 'nokogiri/syntax_error'
module Nokogiri
  module CSS
    class SyntaxError < ::Nokogiri::SyntaxError
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                 tokenizer.rb                                                                                        0100644 0001750 0001750 00000007614 12566211316 044203  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 #--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.5
# from lexical definition file "lib/nokogiri/css/tokenizer.rex".
#++

module Nokogiri
module CSS
class Tokenizer # :nodoc:
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader   :lineno
  attr_reader   :filename
  attr_accessor :state

  def scan_setup(str)
    @ss = StringScanner.new(str)
    @lineno =  1
    @state  = nil
  end

  def action
    yield
  end

  def scan_str(str)
    scan_setup(str)
    do_parse
  end
  alias :scan :scan_str

  def load_file( filename )
    @filename = filename
    open(filename, "r") do |f|
      scan_setup(f.read)
    end
  end

  def scan_file( filename )
    load_file(filename)
    do_parse
  end


  def next_token
    return if @ss.eos?
    
    # skips empty actions
    until token = _next_token or @ss.eos?; end
    token
  end

  def _next_token
    text = @ss.peek(1)
    @lineno  +=  1  if text == "\n"
    token = case @state
    when nil
      case
      when (text = @ss.scan(/has\([\s]*/))
         action { [:HAS, text] }

      when (text = @ss.scan(/[-@]?([_A-Za-z]|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])([_A-Za-z0-9-]|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])*\([\s]*/))
         action { [:FUNCTION, text] }

      when (text = @ss.scan(/[-@]?([_A-Za-z]|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])([_A-Za-z0-9-]|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])*/))
         action { [:IDENT, text] }

      when (text = @ss.scan(/\#([_A-Za-z0-9-]|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])+/))
         action { [:HASH, text] }

      when (text = @ss.scan(/[\s]*~=[\s]*/))
         action { [:INCLUDES, text] }

      when (text = @ss.scan(/[\s]*\|=[\s]*/))
         action { [:DASHMATCH, text] }

      when (text = @ss.scan(/[\s]*\^=[\s]*/))
         action { [:PREFIXMATCH, text] }

      when (text = @ss.scan(/[\s]*\$=[\s]*/))
         action { [:SUFFIXMATCH, text] }

      when (text = @ss.scan(/[\s]*\*=[\s]*/))
         action { [:SUBSTRINGMATCH, text] }

      when (text = @ss.scan(/[\s]*!=[\s]*/))
         action { [:NOT_EQUAL, text] }

      when (text = @ss.scan(/[\s]*=[\s]*/))
         action { [:EQUAL, text] }

      when (text = @ss.scan(/[\s]*\)/))
         action { [:RPAREN, text] }

      when (text = @ss.scan(/[\s]*\[[\s]*/))
         action { [:LSQUARE, text] }

      when (text = @ss.scan(/[\s]*\]/))
         action { [:RSQUARE, text] }

      when (text = @ss.scan(/[\s]*\+[\s]*/))
         action { [:PLUS, text] }

      when (text = @ss.scan(/[\s]*>[\s]*/))
         action { [:GREATER, text] }

      when (text = @ss.scan(/[\s]*,[\s]*/))
         action { [:COMMA, text] }

      when (text = @ss.scan(/[\s]*~[\s]*/))
         action { [:TILDE, text] }

      when (text = @ss.scan(/\:not\([\s]*/))
         action { [:NOT, text] }

      when (text = @ss.scan(/-?([0-9]+|[0-9]*\.[0-9]+)/))
         action { [:NUMBER, text] }

      when (text = @ss.scan(/[\s]*\/\/[\s]*/))
         action { [:DOUBLESLASH, text] }

      when (text = @ss.scan(/[\s]*\/[\s]*/))
         action { [:SLASH, text] }

      when (text = @ss.scan(/U\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?/))
         action {[:UNICODE_RANGE, text] }

      when (text = @ss.scan(/[\s]+/))
         action { [:S, text] }

      when (text = @ss.scan(/"([^\n\r\f"]|\n|\r\n|\r|\f|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])*"|'([^\n\r\f']|\n|\r\n|\r|\f|[^\0-\177]|\\[0-9A-Fa-f]{1,6}(\r\n|[\s])?|\\[^\n\r\f0-9A-Fa-f])*'/))
         action { [:STRING, text] }

      when (text = @ss.scan(/./))
         action { [text, text] }

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    else
      raise  ScanError, "undefined state: '" + state.to_s + "'"
    end  # case state
    token
  end  # def _next_token

end # class
end
end
                                                                                                                    xpath_visitor.rb                                                                                    0100644 0001750 0001750 00000012712 12566211316 045067  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/css                 module Nokogiri
  module CSS
    class XPathVisitor # :nodoc:
      def visit_function node
        #  note that nth-child and nth-last-child are preprocessed in css/node.rb.
        msg = :"visit_function_#{node.value.first.gsub(/[(]/, '')}"
        return self.send(msg, node) if self.respond_to?(msg)

        case node.value.first
        when /^text\(/
          'child::text()'
        when /^self\(/
          "self::#{node.value[1]}"
        when /^eq\(/
          "position() = #{node.value[1]}"
        when /^(nth|nth-of-type|nth-child)\(/
          if node.value[1].is_a?(Nokogiri::CSS::Node) and node.value[1].type == :AN_PLUS_B
            an_plus_b(node.value[1])
          else
            "position() = #{node.value[1]}"
          end
        when /^(nth-last-child|nth-last-of-type)\(/
          if node.value[1].is_a?(Nokogiri::CSS::Node) and node.value[1].type == :AN_PLUS_B
            an_plus_b(node.value[1], :last => true)
          else
            index = node.value[1].to_i - 1
            index == 0 ? "position() = last()" : "position() = last() - #{index}"
          end
        when /^(first|first-of-type)\(/
          "position() = 1"
        when /^(last|last-of-type)\(/
          "position() = last()"
        when /^contains\(/
          "contains(., #{node.value[1]})"
        when /^gt\(/
          "position() > #{node.value[1]}"
        when /^only-child\(/
          "last() = 1"
        when /^comment\(/
          "comment()"
        when /^has\(/
          node.value[1].accept(self)
        else
          args = ['.'] + node.value[1..-1]
          "#{node.value.first}#{args.join(', ')})"
        end
      end

      def visit_not node
        child = node.value.first
        if :ELEMENT_NAME == child.type
          "not(self::#{child.accept(self)})"
        else
          "not(#{child.accept(self)})"
        end
      end

      def visit_id node
        node.value.first =~ /^#(.*)$/
        "@id = '#{$1}'"
      end

      def visit_attribute_condition node
         attribute = if (node.value.first.type == :FUNCTION) or (node.value.first.value.first =~ /::/)
                       ''
                     else
                       '@'
                     end
        attribute += node.value.first.accept(self)

        # Support non-standard css
        attribute.gsub!(/^@@/, '@')

        return attribute unless node.value.length == 3

        value = node.value.last
        value = "'#{value}'" if value !~ /^['"]/

        case node.value[1]
        when :equal
          attribute + " = " + "#{value}"
        when :not_equal
          attribute + " != " + "#{value}"
        when :substring_match
          "contains(#{attribute}, #{value})"
        when :prefix_match
          "starts-with(#{attribute}, #{value})"
        when :dash_match
          "#{attribute} = #{value} or starts-with(#{attribute}, concat(#{value}, '-'))"
        when :includes
          "contains(concat(\" \", #{attribute}, \" \"),concat(\" \", #{value}, \" \"))"
        when :suffix_match
          "substring(#{attribute}, string-length(#{attribute}) - " +
            "string-length(#{value}) + 1, string-length(#{value})) = #{value}"
        else
          attribute + " #{node.value[1]} " + "#{value}"
        end
      end

      def visit_pseudo_class node
        if node.value.first.is_a?(Nokogiri::CSS::Node) and node.value.first.type == :FUNCTION
          node.value.first.accept(self)
        else
          msg = :"visit_pseudo_class_#{node.value.first.gsub(/[(]/, '')}"
          return self.send(msg, node) if self.respond_to?(msg)

          case node.value.first
          when "first", "first-child" then "position() = 1"
          when "last", "last-child" then "position() = last()"
          when "first-of-type" then "position() = 1"
          when "last-of-type" then "position() = last()"
          when "only-of-type" then "last() = 1"
          when "empty" then "not(node())"
          when "parent" then "node()"
          when "root" then "not(parent::*)"
          else
            node.value.first + "(.)"
          end
        end
      end

      def visit_class_condition node
        "contains(concat(' ', @class, ' '), ' #{node.value.first} ')"
      end

      {
        'combinator'                => ' and ',
        'direct_adjacent_selector'  => "/following-sibling::*[1]/self::",
        'following_selector'        => "/following-sibling::",
        'descendant_selector'       => '//',
        'child_selector'            => '/',
      }.each do |k,v|
        class_eval %{
          def visit_#{k} node
            "\#{node.value.first.accept(self) if node.value.first}#{v}\#{node.value.last.accept(self)}"
          end
        }
      end

      def visit_conditional_selector node
        node.value.first.accept(self) + '[' +
        node.value.last.accept(self) + ']'
      end

      def visit_element_name node
        node.value.first
      end

      def accept node
        node.accept(self)
      end

    private
      def an_plus_b node, options={}
        raise ArgumentError, "expected an+b node to contain 4 tokens, but is #{node.value.inspect}" unless node.value.size == 4

        a = node.value[0].to_i
        b = node.value[3].to_i
        position = options[:last] ? "(last()-position()+1)" : "position()"

        if (b == 0)
          return "(#{position} mod #{a}) = 0"
        else
          compare = (a < 0) ? "<=" : ">="
          return "(#{position} #{compare} #{b}) and (((#{position}-#{b}) mod #{a.abs}) = 0)"
        end
      end

    end
  end
end
                                                      css.rb                                                                                              0100644 0001750 0001750 00000001071 12566211316 042160  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     require 'nokogiri/css/node'
require 'nokogiri/css/xpath_visitor'
x = $-w
$-w = false
require 'nokogiri/css/parser'
$-w = x

require 'nokogiri/css/tokenizer'
require 'nokogiri/css/syntax_error'

module Nokogiri
  module CSS
    class << self
      ###
      # Parse this CSS selector in +selector+.  Returns an AST.
      def parse selector
        Parser.new.parse selector
      end

      ###
      # Get the XPath for +selector+.
      def xpath_for selector, options={}
        Parser.new(options[:ns] || {}).xpath_for selector, options
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       decorators/                                                                                         0040755 0001750 0001750 00000000000 12612224746 043217  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     decorators/slop.rb                                                                                  0100644 0001750 0001750 00000001757 12566211316 044525  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     module Nokogiri
  module Decorators
    ###
    # The Slop decorator implements method missing such that a methods may be
    # used instead of XPath or CSS.  See Nokogiri.Slop
    module Slop
      ###
      # look for node with +name+.  See Nokogiri.Slop
      def method_missing name, *args, &block
        prefix = implied_xpath_context

        if args.empty?
          list = xpath("#{prefix}#{name.to_s.sub(/^_/, '')}")
        elsif args.first.is_a? Hash
          hash = args.first
          if hash[:css]
            list = css("#{name}#{hash[:css]}")
          elsif hash[:xpath]
            conds = Array(hash[:xpath]).join(' and ')
            list = xpath("#{prefix}#{name}[#{conds}]")
          end
        else
          CSS::Parser.without_cache do
            list = xpath(
              *CSS.xpath_for("#{name}#{args.first}", :prefix => prefix)
            )
          end
        end

        super if list.empty?
        list.length == 1 ? list.first : list
      end
    end
  end
end
                 html/                                                                                               0040755 0001750 0001750 00000000000 12612224746 042016  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     builder.rb                                                                                          0100644 0001750 0001750 00000002010 12566211316 043754  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    ###
    # Nokogiri HTML builder is used for building HTML documents.  It is very
    # similar to the Nokogiri::XML::Builder.  In fact, you should go read the
    # documentation for Nokogiri::XML::Builder before reading this
    # documentation.
    #
    # == Synopsis:
    #
    # Create an HTML document with a body that has an onload attribute, and a
    # span tag with a class of "bold" that has content of "Hello world".
    #
    #   builder = Nokogiri::HTML::Builder.new do |doc|
    #     doc.html {
    #       doc.body(:onload => 'some_func();') {
    #         doc.span.bold {
    #           doc.text "Hello world"
    #         }
    #       }
    #     }
    #   end
    #   puts builder.to_html
    #
    # The HTML builder inherits from the XML builder, so make sure to read the
    # Nokogiri::XML::Builder documentation.
    class Builder < Nokogiri::XML::Builder
      ###
      # Convert the builder to HTML
      def to_html
        @doc.to_html
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        document.rb                                                                                         0100644 0001750 0001750 00000020505 12566211316 044155  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    class Document < Nokogiri::XML::Document
      ###
      # Get the meta tag encoding for this document.  If there is no meta tag,
      # then nil is returned.
      def meta_encoding
        meta = meta_content_type and
          match = /charset\s*=\s*([\w-]+)/i.match(meta['content']) and
          match[1]
      end

      ###
      # Set the meta tag encoding for this document.  If there is no meta
      # content tag, the encoding is not set.
      def meta_encoding= encoding
        meta = meta_content_type and
          meta['content'] = "text/html; charset=%s" % encoding
      end

      def meta_content_type
        css('meta[@http-equiv]').find { |node|
          node['http-equiv'] =~ /\AContent-Type\z/i and
            !node['content'].nil? and
            !node['content'].empty?
        }
      end
      private :meta_content_type

      ###
      # Get the title string of this document.  Return nil if there is
      # no title tag.
      def title
        title = at('title') and title.inner_text
      end

      ###
      # Set the title string of this document.  If there is no head
      # element, the title is not set.
      def title=(text)
        unless title = at('title')
          head = at('head') or return nil
          title = Nokogiri::XML::Node.new('title', self)
          head << title
        end
        title.children = XML::Text.new(text, self)
      end

      ####
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #
      def serialize options = {}
        options[:save_with] ||= XML::Node::SaveOptions::DEFAULT_HTML
        super
      end

      ####
      # Create a Nokogiri::XML::DocumentFragment from +tags+
      def fragment tags = nil
        DocumentFragment.new(self, tags, self.root)
      end

      class << self
        ###
        # Parse HTML.  +string_or_io+ may be a String, or any object that
        # responds to _read_ and _close_ such as an IO, or StringIO.
        # +url+ is resource where this document is located.  +encoding+ is the
        # encoding that should be used when processing the document. +options+
        # is a number that sets options in the parser, such as
        # Nokogiri::XML::ParseOptions::RECOVER.  See the constants in
        # Nokogiri::XML::ParseOptions.
        def parse string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML

          options = Nokogiri::XML::ParseOptions.new(options) if Fixnum === options
          # Give the options to the user
          yield options if block_given?

          if string_or_io.respond_to?(:encoding)
            unless string_or_io.encoding.name == "ASCII-8BIT"
              encoding ||= string_or_io.encoding.name
            end
          end

          if string_or_io.respond_to?(:read)
            url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil
            if !encoding
              # Libxml2's parser has poor support for encoding
              # detection.  First, it does not recognize the HTML5
              # style meta charset declaration.  Secondly, even if it
              # successfully detects an encoding hint, it does not
              # re-decode or re-parse the preceding part which may be
              # garbled.
              #
              # EncodingReader aims to perform advanced encoding
              # detection beyond what Libxml2 does, and to emulate
              # rewinding of a stream and make Libxml2 redo parsing
              # from the start when an encoding hint is found.
              string_or_io = EncodingReader.new(string_or_io)
              begin
                return read_io(string_or_io, url, encoding, options.to_i)
              rescue EncodingFound => e
                encoding = e.found_encoding
              end
            end
            return read_io(string_or_io, url, encoding, options.to_i)
          end

          # read_memory pukes on empty docs
          return new if string_or_io.nil? or string_or_io.empty?

          encoding ||= EncodingReader.detect_encoding(string_or_io)

          read_memory(string_or_io, url, encoding, options.to_i)
        end
      end

      class EncodingFound < StandardError # :nodoc:
        attr_reader :found_encoding

        def initialize(encoding)
          @found_encoding = encoding
          super("encoding found: %s" % encoding)
        end
      end

      class EncodingReader # :nodoc:
        class SAXHandler < Nokogiri::XML::SAX::Document # :nodoc:
          attr_reader :encoding
          
          def initialize
            @encoding = nil
            super()
          end
    
          def start_element(name, attrs = [])
            return unless name == 'meta'
            attr = Hash[attrs]
            charset = attr['charset'] and
              @encoding = charset
            http_equiv = attr['http-equiv'] and
              http_equiv.match(/\AContent-Type\z/i) and
              content = attr['content'] and
              m = content.match(/;\s*charset\s*=\s*([\w-]+)/) and
              @encoding = m[1]
          end
        end
        
        class JumpSAXHandler < SAXHandler
          def initialize(jumptag)
            @jumptag = jumptag
            super()
          end

          def start_element(name, attrs = [])
            super
            throw @jumptag, @encoding if @encoding
            throw @jumptag, nil if name =~ /\A(?:div|h1|img|p|br)\z/
          end
        end

        def self.detect_encoding(chunk)
          if Nokogiri.jruby? && EncodingReader.is_jruby_without_fix?
            return EncodingReader.detect_encoding_for_jruby_without_fix(chunk)
          end
          m = chunk.match(/\A(<\?xml[ \t\r\n]+[^>]*>)/) and
            return Nokogiri.XML(m[1]).encoding

          if Nokogiri.jruby?
            m = chunk.match(/(<meta\s)(.*)(charset\s*=\s*([\w-]+))(.*)/i) and
              return m[4]
            catch(:encoding_found) {
              Nokogiri::HTML::SAX::Parser.new(JumpSAXHandler.new(:encoding_found)).parse(chunk)
              nil
            }
          else
            handler = SAXHandler.new
            parser = Nokogiri::HTML::SAX::PushParser.new(handler)
            parser << chunk rescue Nokogiri::SyntaxError
            handler.encoding
          end
        end

        def self.is_jruby_without_fix?
          JRUBY_VERSION.split('.').join.to_i < 165
        end

        def self.detect_encoding_for_jruby_without_fix(chunk)
          m = chunk.match(/\A(<\?xml[ \t\r\n]+[^>]*>)/) and
            return Nokogiri.XML(m[1]).encoding

          m = chunk.match(/(<meta\s)(.*)(charset\s*=\s*([\w-]+))(.*)/i) and
            return m[4]

          catch(:encoding_found) {
            Nokogiri::HTML::SAX::Parser.new(JumpSAXHandler.new(:encoding_found.to_s)).parse(chunk)
            nil
          }
        rescue Nokogiri::SyntaxError, RuntimeError
          # Ignore parser errors that nokogiri may raise
          nil
        end

        def initialize(io)
          @io = io
          @firstchunk = nil
          @encoding_found = nil
        end

        # This method is used by the C extension so that
        # Nokogiri::HTML::Document#read_io() does not leak memory when
        # EncodingFound is raised.
        attr_reader :encoding_found

        def read(len)
          # no support for a call without len

          if !@firstchunk
            @firstchunk = @io.read(len) or return nil

            # This implementation expects that the first call from
            # htmlReadIO() is made with a length long enough (~1KB) to
            # achieve advanced encoding detection.
            if encoding = EncodingReader.detect_encoding(@firstchunk)
              # The first chunk is stored for the next read in retry.
              raise @encoding_found = EncodingFound.new(encoding)
            end
          end
          @encoding_found = nil

          ret = @firstchunk.slice!(0, len)
          if (len -= ret.length) > 0
            rest = @io.read(len) and ret << rest
          end
          if ret.empty?
            nil
          else
            ret
          end
        end
      end
    end
  end
end
                                                                                                                                                                                           document_fragment.rb                                                                                0100644 0001750 0001750 00000002343 12566211316 046040  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    class DocumentFragment < Nokogiri::XML::DocumentFragment
      attr_accessor :errors

      ####
      # Create a Nokogiri::XML::DocumentFragment from +tags+, using +encoding+
      def self.parse tags, encoding = nil
        doc = HTML::Document.new

        encoding ||= tags.respond_to?(:encoding) ? tags.encoding.name : 'UTF-8'
        doc.encoding = encoding

        new(doc, tags)
      end

      def initialize document, tags = nil, ctx = nil
        return self unless tags

        if ctx
          preexisting_errors = document.errors.dup
          node_set = ctx.parse("<div>#{tags}</div>")
          node_set.first.children.each { |child| child.parent = self } unless node_set.empty?
          self.errors = document.errors - preexisting_errors
        else
          # This is a horrible hack, but I don't care
          if tags.strip =~ /^<body/i
            path = "/html/body"
          else
            path = "/html/body/node()"
          end

          temp_doc = HTML::Document.parse "<html><body>#{tags}", nil, document.encoding
          temp_doc.xpath(path).each { |child| child.parent = self }
          self.errors = temp_doc.errors
        end
        children
      end
    end
  end
end
                                                                                                                                                                                                                                                                                             element_description.rb                                                                              0100644 0001750 0001750 00000000635 12566211316 046375  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    class ElementDescription
      ###
      # Is this element a block element?
      def block?
        !inline?
      end

      ###
      # Convert this description to a string
      def to_s
        "#{name}: #{description}"
      end

      ###
      # Inspection information
      def inspect
        "#<#{self.class.name}: #{name} #{description}>"
      end
    end
  end
end
                                                                                                   element_description_defaults.rb                                                                     0100644 0001750 0001750 00000062713 12566211316 050271  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    class ElementDescription

      # Methods are defined protected by method_defined? because at
      # this point the C-library or Java library is already loaded,
      # and we don't want to clobber any methods that have been
      # defined there.

      Desc = Struct.new("HTMLElementDescription", :name,
                        :startTag, :endTag, :saveEndTag,
                        :empty, :depr, :dtd, :isinline,
                        :desc,
                        :subelts, :defaultsubelt,
                        :attrs_opt, :attrs_depr, :attrs_req)

      # This is filled in down below.
      DefaultDescriptions = Hash.new()

      def default_desc
        DefaultDescriptions[name.downcase]
      end
      private :default_desc

      unless method_defined? :implied_start_tag?
        def implied_start_tag?
          d = default_desc
          d ? d.startTag : nil
        end
      end

      unless method_defined? :implied_end_tag?
        def implied_end_tag?
          d = default_desc
          d ? d.endTag : nil
        end
      end

      unless method_defined? :save_end_tag?
        def save_end_tag?
          d = default_desc
          d ? d.saveEndTag : nil
        end
      end

      unless method_defined? :deprecated?
        def deprecated?
          d = default_desc
          d ? d.depr : nil
        end
      end

      unless method_defined? :description
        def description
          d = default_desc
          d ? d.desc : nil
        end
      end

      unless method_defined? :default_sub_element
        def default_sub_element
          d = default_desc
          d ? d.defaultsubelt : nil
        end
      end

      unless method_defined? :optional_attributes
        def optional_attributes
          d = default_desc
          d ? d.attrs_opt : []
        end
      end

      unless method_defined? :deprecated_attributes
        def deprecated_attributes
          d = default_desc
          d ? d.attrs_depr : []
        end
      end

      unless method_defined? :required_attributes
        def required_attributes
          d = default_desc
          d ? d.attrs_req : []
        end
      end

      ###
      # Default Element Descriptions (HTML 4.0) copied from
      # libxml2/HTMLparser.c and libxml2/include/libxml/HTMLparser.h
      #
      # The copyright notice for those files and the following list of
      # element and attribute descriptions is reproduced here:
      #
      # Except where otherwise noted in the source code (e.g. the
      # files hash.c, list.c and the trio files, which are covered by
      # a similar licence but with different Copyright notices) all
      # the files are:
      #
      #  Copyright (C) 1998-2003 Daniel Veillard.  All Rights Reserved.
      #
      # Permission is hereby granted, free of charge, to any person
      # obtaining a copy of this software and associated documentation
      # files (the "Software"), to deal in the Software without
      # restriction, including without limitation the rights to use,
      # copy, modify, merge, publish, distribute, sublicense, and/or
      # sell copies of the Software, and to permit persons to whom the
      # Software is fur- nished to do so, subject to the following
      # conditions:

      # The above copyright notice and this permission notice shall be
      # included in all copies or substantial portions of the
      # Software.

      # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
      # KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
      # WARRANTIES OF MERCHANTABILITY, FIT- NESS FOR A PARTICULAR
      # PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE DANIEL
      # VEILLARD BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      # WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      # FROM, OUT OF OR IN CON- NECTION WITH THE SOFTWARE OR THE USE
      # OR OTHER DEALINGS IN THE SOFTWARE.

      # Except as contained in this notice, the name of Daniel
      # Veillard shall not be used in advertising or otherwise to
      # promote the sale, use or other deal- ings in this Software
      # without prior written authorization from him.

      # Attributes defined and categorized
      FONTSTYLE = ["tt", "i", "b", "u", "s", "strike", "big", "small"]
      PHRASE = ['em', 'strong', 'dfn', 'code', 'samp',
                'kbd', 'var', 'cite', 'abbr', 'acronym']
      SPECIAL = ['a', 'img', 'applet', 'embed', 'object', 'font','basefont',
                 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo',
                 'iframe']
      PCDATA = []
      HEADING = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
      LIST = ['ul', 'ol', 'dir', 'menu']
      FORMCTRL = ['input', 'select', 'textarea', 'label', 'button']
      BLOCK = [HEADING, LIST, 'pre', 'p', 'dl', 'div', 'center', 'noscript',
               'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table',
               'fieldset', 'address']
      INLINE = [PCDATA, FONTSTYLE, PHRASE, SPECIAL, FORMCTRL]
      FLOW = [BLOCK, INLINE]
      MODIFIER = []
      EMPTY = []

      HTML_FLOW = FLOW
      HTML_INLINE = INLINE
      HTML_PCDATA = PCDATA
      HTML_CDATA = HTML_PCDATA

      COREATTRS = ['id', 'class', 'style', 'title']
      I18N = ['lang', 'dir']
      EVENTS = ['onclick', 'ondblclick', 'onmousedown', 'onmouseup',
                'onmouseover', 'onmouseout', 'onkeypress', 'onkeydown',
                'onkeyup']
      ATTRS = [COREATTRS, I18N,EVENTS]
      CELLHALIGN = ['align', 'char', 'charoff']
      CELLVALIGN = ['valign']

      HTML_ATTRS = ATTRS
      CORE_I18N_ATTRS = [COREATTRS, I18N]
      CORE_ATTRS = COREATTRS
      I18N_ATTRS = I18N


      A_ATTRS = [ATTRS, 'charset', 'type', 'name',
                 'href', 'hreflang', 'rel', 'rev', 'accesskey', 'shape',
                 'coords', 'tabindex', 'onfocus', 'onblur']
      TARGET_ATTR = ['target']
      ROWS_COLS_ATTR = ['rows', 'cols']
      ALT_ATTR = ['alt']
      SRC_ALT_ATTRS = ['src', 'alt']
      HREF_ATTRS = ['href']
      CLEAR_ATTRS = ['clear']
      INLINE_P = [INLINE, 'p']

      FLOW_PARAM = [FLOW, 'param']
      APPLET_ATTRS = [COREATTRS , 'codebase',
                      'archive', 'alt', 'name', 'height', 'width', 'align',
                      'hspace', 'vspace']
      AREA_ATTRS = ['shape', 'coords', 'href', 'nohref',
                    'tabindex', 'accesskey', 'onfocus', 'onblur']
      BASEFONT_ATTRS = ['id', 'size', 'color', 'face']
      QUOTE_ATTRS = [ATTRS, 'cite']
      BODY_CONTENTS = [FLOW, 'ins', 'del']
      BODY_ATTRS = [ATTRS, 'onload', 'onunload']
      BODY_DEPR = ['background', 'bgcolor', 'text',
                   'link', 'vlink', 'alink']
      BUTTON_ATTRS = [ATTRS, 'name', 'value', 'type',
                      'disabled', 'tabindex', 'accesskey', 'onfocus', 'onblur']


      COL_ATTRS = [ATTRS, 'span', 'width', CELLHALIGN, CELLVALIGN]
      COL_ELT = ['col']
      EDIT_ATTRS = [ATTRS, 'datetime', 'cite']
      COMPACT_ATTRS = [ATTRS, 'compact']
      DL_CONTENTS = ['dt', 'dd']
      COMPACT_ATTR = ['compact']
      LABEL_ATTR = ['label']
      FIELDSET_CONTENTS = [FLOW, 'legend' ]
      FONT_ATTRS = [COREATTRS, I18N, 'size', 'color', 'face' ]
      FORM_CONTENTS = [HEADING, LIST, INLINE, 'pre', 'p', 'div', 'center',
                       'noscript', 'noframes', 'blockquote', 'isindex', 'hr',
                       'table', 'fieldset', 'address']
      FORM_ATTRS = [ATTRS, 'method', 'enctype', 'accept', 'name', 'onsubmit',
                    'onreset', 'accept-charset']
      FRAME_ATTRS = [COREATTRS, 'longdesc', 'name', 'src', 'frameborder',
                     'marginwidth', 'marginheight', 'noresize', 'scrolling' ]
      FRAMESET_ATTRS = [COREATTRS, 'rows', 'cols', 'onload', 'onunload']
      FRAMESET_CONTENTS = ['frameset', 'frame', 'noframes']
      HEAD_ATTRS = [I18N, 'profile']
      HEAD_CONTENTS = ['title', 'isindex', 'base', 'script', 'style', 'meta',
                       'link', 'object']
      HR_DEPR = ['align', 'noshade', 'size', 'width']
      VERSION_ATTR = ['version']
      HTML_CONTENT = ['head', 'body', 'frameset']
      IFRAME_ATTRS = [COREATTRS, 'longdesc', 'name', 'src', 'frameborder',
                      'marginwidth', 'marginheight', 'scrolling', 'align',
                      'height', 'width']
      IMG_ATTRS = [ATTRS, 'longdesc', 'name', 'height', 'width', 'usemap',
                   'ismap']
      EMBED_ATTRS = [COREATTRS, 'align', 'alt', 'border', 'code', 'codebase',
                     'frameborder', 'height', 'hidden', 'hspace', 'name',
                     'palette', 'pluginspace', 'pluginurl', 'src', 'type',
                     'units', 'vspace', 'width']
      INPUT_ATTRS = [ATTRS, 'type', 'name', 'value', 'checked', 'disabled',
                     'readonly', 'size', 'maxlength', 'src', 'alt', 'usemap',
                     'ismap', 'tabindex', 'accesskey', 'onfocus', 'onblur',
                     'onselect', 'onchange', 'accept']
      PROMPT_ATTRS = [COREATTRS, I18N, 'prompt']
      LABEL_ATTRS = [ATTRS, 'for', 'accesskey', 'onfocus', 'onblur']
      LEGEND_ATTRS = [ATTRS, 'accesskey']
      ALIGN_ATTR = ['align']
      LINK_ATTRS = [ATTRS, 'charset', 'href', 'hreflang', 'type', 'rel', 'rev',
                    'media']
      MAP_CONTENTS = [BLOCK, 'area']
      NAME_ATTR = ['name']
      ACTION_ATTR = ['action']
      BLOCKLI_ELT = [BLOCK, 'li']
      META_ATTRS = [I18N, 'http-equiv', 'name', 'scheme']
      CONTENT_ATTR = ['content']
      TYPE_ATTR = ['type']
      NOFRAMES_CONTENT = ['body', FLOW, MODIFIER]
      OBJECT_CONTENTS = [FLOW, 'param']
      OBJECT_ATTRS = [ATTRS, 'declare', 'classid', 'codebase', 'data', 'type',
                      'codetype', 'archive', 'standby', 'height', 'width',
                      'usemap', 'name', 'tabindex']
      OBJECT_DEPR = ['align', 'border', 'hspace', 'vspace']
      OL_ATTRS = ['type', 'compact', 'start']
      OPTION_ELT = ['option']
      OPTGROUP_ATTRS = [ATTRS, 'disabled']
      OPTION_ATTRS = [ATTRS, 'disabled', 'label', 'selected', 'value']
      PARAM_ATTRS = ['id', 'value', 'valuetype', 'type']
      WIDTH_ATTR = ['width']
      PRE_CONTENT = [PHRASE, 'tt', 'i', 'b', 'u', 's', 'strike', 'a', 'br',
                     'script', 'map', 'q', 'span', 'bdo', 'iframe']
      SCRIPT_ATTRS = ['charset', 'src', 'defer', 'event', 'for']
      LANGUAGE_ATTR = ['language']
      SELECT_CONTENT = ['optgroup', 'option']
      SELECT_ATTRS = [ATTRS, 'name', 'size', 'multiple', 'disabled', 'tabindex',
                      'onfocus', 'onblur', 'onchange']
      STYLE_ATTRS = [I18N, 'media', 'title']
      TABLE_ATTRS = [ATTRS, 'summary', 'width', 'border', 'frame', 'rules',
                     'cellspacing', 'cellpadding', 'datapagesize']
      TABLE_DEPR = ['align', 'bgcolor']
      TABLE_CONTENTS = ['caption', 'col', 'colgroup', 'thead', 'tfoot', 'tbody',
                        'tr']
      TR_ELT = ['tr']
      TALIGN_ATTRS = [ATTRS, CELLHALIGN, CELLVALIGN]
      TH_TD_DEPR = ['nowrap', 'bgcolor', 'width', 'height']
      TH_TD_ATTR = [ATTRS, 'abbr', 'axis', 'headers', 'scope', 'rowspan',
                    'colspan', CELLHALIGN, CELLVALIGN]
      TEXTAREA_ATTRS = [ATTRS, 'name', 'disabled', 'readonly', 'tabindex',
                        'accesskey', 'onfocus', 'onblur', 'onselect',
                        'onchange']
      TR_CONTENTS = ['th', 'td']
      BGCOLOR_ATTR = ['bgcolor']
      LI_ELT = ['li']
      UL_DEPR = ['type', 'compact']
      DIR_ATTR = ['dir']

      [
       ['a', false, false, false, false, false, :any, true,
        'anchor ',
        HTML_INLINE, nil, A_ATTRS, TARGET_ATTR, []
       ],
       ['abbr', false, false, false, false, false, :any, true,
        'abbreviated form',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['acronym', false, false, false, false, false, :any, true, '',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['address', false, false, false, false, false, :any, false,
        'information on author',
        INLINE_P , nil, HTML_ATTRS, [], []
       ],
       ['applet', false, false, false, false, true, :loose, true,
        'java applet ',
        FLOW_PARAM, nil, [], APPLET_ATTRS, []
       ],
       ['area', false, true, true, true, false, :any, false,
        'client-side image map area ',
        EMPTY, nil, AREA_ATTRS, TARGET_ATTR, ALT_ATTR
       ],
       ['b', false, true, false, false, false, :any, true,
        'bold text style',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['base', false, true, true, true, false, :any, false,
        'document base uri ',
        EMPTY, nil, [], TARGET_ATTR, HREF_ATTRS
       ],
       ['basefont', false, true, true, true, true, :loose, true,
        'base font size ',
        EMPTY, nil, [], BASEFONT_ATTRS, []
       ],
       ['bdo', false, false, false, false, false, :any, true,
        'i18n bidi over-ride ',
        HTML_INLINE, nil, CORE_I18N_ATTRS, [], DIR_ATTR
       ],
       ['big', false, true, false, false, false, :any, true,
        'large text style',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['blockquote', false, false, false, false, false, :any, false,
        'long quotation ',
        HTML_FLOW, nil, QUOTE_ATTRS, [], []
       ],
       ['body', true, true, false, false, false, :any, false,
        'document body ',
        BODY_CONTENTS, 'div', BODY_ATTRS, BODY_DEPR, []
       ],
       ['br', false, true, true, true, false, :any, true,
        'forced line break ',
        EMPTY, nil, CORE_ATTRS, CLEAR_ATTRS, []
       ],
       ['button', false, false, false, false, false, :any, true,
        'push button ',
        [HTML_FLOW, MODIFIER], nil, BUTTON_ATTRS, [], []
       ],
       ['caption', false, false, false, false, false, :any, false,
        'table caption ',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['center', false, true, false, false, true, :loose, false,
        'shorthand for div align=center ',
        HTML_FLOW, nil, [], HTML_ATTRS, []
       ],
       ['cite', false, false, false, false, false, :any, true, 'citation',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['code', false, false, false, false, false, :any, true,
        'computer code fragment',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['col', false, true, true, true, false, :any, false, 'table column ',
        EMPTY, nil, COL_ATTRS, [], []
       ],
       ['colgroup', false, true, false, false, false, :any, false,
        'table column group ',
        COL_ELT, 'col', COL_ATTRS, [], []
       ],
       ['dd', false, true, false, false, false, :any, false,
        'definition description ',
        HTML_FLOW, nil, HTML_ATTRS, [], []
       ],
       ['del', false, false, false, false, false, :any, true,
        'deleted text ',
        HTML_FLOW, nil, EDIT_ATTRS, [], []
       ],
       ['dfn', false, false, false, false, false, :any, true,
        'instance definition',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['dir', false, false, false, false, true, :loose, false,
        'directory list',
        BLOCKLI_ELT, 'li', [], COMPACT_ATTRS, []
       ],
       ['div', false, false, false, false, false, :any, false,
        'generic language/style container',
        HTML_FLOW, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['dl', false, false, false, false, false, :any, false,
        'definition list ',
        DL_CONTENTS, 'dd', HTML_ATTRS, COMPACT_ATTR, []
       ],
       ['dt', false, true, false, false, false, :any, false,
        'definition term ',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['em', false, true, false, false, false, :any, true,
        'emphasis',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['embed', false, true, false, false, true, :loose, true,
        'generic embedded object ',
        EMPTY, nil, EMBED_ATTRS, [], []
       ],
       ['fieldset', false, false, false, false, false, :any, false,
        'form control group ',
        FIELDSET_CONTENTS, nil, HTML_ATTRS, [], []
       ],
       ['font', false, true, false, false, true, :loose, true,
        'local change to font ',
        HTML_INLINE, nil, [], FONT_ATTRS, []
       ],
       ['form', false, false, false, false, false, :any, false,
        'interactive form ',
        FORM_CONTENTS, 'fieldset', FORM_ATTRS, TARGET_ATTR, ACTION_ATTR
       ],
       ['frame', false, true, true, true, false, :frameset, false,
        'subwindow ',
        EMPTY, nil, [], FRAME_ATTRS, []
       ],
       ['frameset', false, false, false, false, false, :frameset, false,
        'window subdivision',
        FRAMESET_CONTENTS, 'noframes', [], FRAMESET_ATTRS, []
       ],
       ['htrue', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['htrue', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['htrue', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['h4', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['h5', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['h6', false, false, false, false, false, :any, false,
        'heading ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['head', true, true, false, false, false, :any, false,
        'document head ',
        HEAD_CONTENTS, nil, HEAD_ATTRS, [], []
       ],
       ['hr', false, true, true, true, false, :any, false,
        'horizontal rule ',
        EMPTY, nil, HTML_ATTRS, HR_DEPR, []
       ],
       ['html', true, true, false, false, false, :any, false,
        'document root element ',
        HTML_CONTENT, nil, I18N_ATTRS, VERSION_ATTR, []
       ],
       ['i', false, true, false, false, false, :any, true,
        'italic text style',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['iframe', false, false, false, false, false, :any, true,
        'inline subwindow ',
        HTML_FLOW, nil, [], IFRAME_ATTRS, []
       ],
       ['img', false, true, true, true, false, :any, true,
        'embedded image ',
        EMPTY, nil, IMG_ATTRS, ALIGN_ATTR, SRC_ALT_ATTRS
       ],
       ['input', false, true, true, true, false, :any, true,
        'form control ',
        EMPTY, nil, INPUT_ATTRS, ALIGN_ATTR, []
       ],
       ['ins', false, false, false, false, false, :any, true,
        'inserted text',
        HTML_FLOW, nil, EDIT_ATTRS, [], []
       ],
       ['isindex', false, true, true, true, true, :loose, false,
        'single line prompt ',
        EMPTY, nil, [], PROMPT_ATTRS, []
       ],
       ['kbd', false, false, false, false, false, :any, true,
        'text to be entered by the user',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['label', false, false, false, false, false, :any, true,
        'form field label text ',
        [HTML_INLINE, MODIFIER], nil, LABEL_ATTRS, [], []
       ],
       ['legend', false, false, false, false, false, :any, false,
        'fieldset legend ',
        HTML_INLINE, nil, LEGEND_ATTRS, ALIGN_ATTR, []
       ],
       ['li', false, true, true, false, false, :any, false,
        'list item ',
        HTML_FLOW, nil, HTML_ATTRS, [], []
       ],
       ['link', false, true, true, true, false, :any, false,
        'a media-independent link ',
        EMPTY, nil, LINK_ATTRS, TARGET_ATTR, []
       ],
       ['map', false, false, false, false, false, :any, true,
        'client-side image map ',
        MAP_CONTENTS, nil, HTML_ATTRS, [], NAME_ATTR
       ],
       ['menu', false, false, false, false, true, :loose, false,
        'menu list ',
        BLOCKLI_ELT, nil, [], COMPACT_ATTRS, []
       ],
       ['meta', false, true, true, true, false, :any, false,
        'generic metainformation ',
        EMPTY, nil, META_ATTRS, [], CONTENT_ATTR
       ],
       ['noframes', false, false, false, false, false, :frameset, false,
        'alternate content container for non frame-based rendering ',
        NOFRAMES_CONTENT, 'body', HTML_ATTRS, [], []
       ],
       ['noscript', false, false, false, false, false, :any, false,
        'alternate content container for non script-based rendering ',
        HTML_FLOW, 'div', HTML_ATTRS, [], []
       ],
       ['object', false, false, false, false, false, :any, true,
        'generic embedded object ',
        OBJECT_CONTENTS, 'div', OBJECT_ATTRS, OBJECT_DEPR, []
       ],
       ['ol', false, false, false, false, false, :any, false,
        'ordered list ',
        LI_ELT, 'li', HTML_ATTRS, OL_ATTRS, []
       ],
       ['optgroup', false, false, false, false, false, :any, false,
        'option group ',
        OPTION_ELT, 'option', OPTGROUP_ATTRS, [], LABEL_ATTR
       ],
       ['option', false, true, false, false, false, :any, false,
        'selectable choice ',
        HTML_PCDATA, nil, OPTION_ATTRS, [], []
       ],
       ['p', false, true, false, false, false, :any, false,
        'paragraph ',
        HTML_INLINE, nil, HTML_ATTRS, ALIGN_ATTR, []
       ],
       ['param', false, true, true, true, false, :any, false,
        'named property value ',
        EMPTY, nil, PARAM_ATTRS, [], NAME_ATTR
       ],
       ['pre', false, false, false, false, false, :any, false,
        'preformatted text ',
        PRE_CONTENT, nil, HTML_ATTRS, WIDTH_ATTR, []
       ],
       ['q', false, false, false, false, false, :any, true,
        'short inline quotation ',
        HTML_INLINE, nil, QUOTE_ATTRS, [], []
       ],
       ['s', false, true, false, false, true, :loose, true,
        'strike-through text style',
        HTML_INLINE, nil, [], HTML_ATTRS, []
       ],
       ['samp', false, false, false, false, false, :any, true,
        'sample program output, scripts, etc.',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['script', false, false, false, false, false, :any, true,
        'script statements ',
        HTML_CDATA, nil, SCRIPT_ATTRS, LANGUAGE_ATTR, TYPE_ATTR
       ],
       ['select', false, false, false, false, false, :any, true,
        'option selector ',
        SELECT_CONTENT, nil, SELECT_ATTRS, [], []
       ],
       ['small', false, true, false, false, false, :any, true,
        'small text style',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['span', false, false, false, false, false, :any, true,
        'generic language/style container ',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['strike', false, true, false, false, true, :loose, true,
        'strike-through text',
        HTML_INLINE, nil, [], HTML_ATTRS, []
       ],
       ['strong', false, true, false, false, false, :any, true,
        'strong emphasis',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['style', false, false, false, false, false, :any, false,
        'style info ',
        HTML_CDATA, nil, STYLE_ATTRS, [], TYPE_ATTR
       ],
       ['sub', false, true, false, false, false, :any, true,
        'subscript',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['sup', false, true, false, false, false, :any, true,
        'superscript ',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['table', false, false, false, false, false, :any, false,
        '',
        TABLE_CONTENTS, 'tr', TABLE_ATTRS, TABLE_DEPR, []
       ],
       ['tbody', true, false, false, false, false, :any, false,
        'table body ',
        TR_ELT, 'tr', TALIGN_ATTRS, [], []
       ],
       ['td', false, false, false, false, false, :any, false,
        'table data cell',
        HTML_FLOW, nil, TH_TD_ATTR, TH_TD_DEPR, []
       ],
       ['textarea', false, false, false, false, false, :any, true,
        'multi-line text field ',
        HTML_PCDATA, nil, TEXTAREA_ATTRS, [], ROWS_COLS_ATTR
       ],
       ['tfoot', false, true, false, false, false, :any, false,
        'table footer ',
        TR_ELT, 'tr', TALIGN_ATTRS, [], []
       ],
       ['th', false, true, false, false, false, :any, false,
        'table header cell',
        HTML_FLOW, nil, TH_TD_ATTR, TH_TD_DEPR, []
       ],
       ['thead', false, true, false, false, false, :any, false,
        'table header ',
        TR_ELT, 'tr', TALIGN_ATTRS, [], []
       ],
       ['title', false, false, false, false, false, :any, false,
        'document title ',
        HTML_PCDATA, nil, I18N_ATTRS, [], []
       ],
       ['tr', false, false, false, false, false, :any, false,
        'table row ',
        TR_CONTENTS, 'td', TALIGN_ATTRS, BGCOLOR_ATTR, []
       ],
       ['tt', false, true, false, false, false, :any, true,
        'teletype or monospaced text style',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ],
       ['u', false, true, false, false, true, :loose, true,
        'underlined text style',
        HTML_INLINE, nil, [], HTML_ATTRS, []
       ],
       ['ul', false, false, false, false, false, :any, false,
        'unordered list ',
        LI_ELT, 'li', HTML_ATTRS, UL_DEPR, []
       ],
       ['var', false, false, false, false, false, :any, true,
        'instance of a variable or program argument',
        HTML_INLINE, nil, HTML_ATTRS, [], []
       ]
      ].each do |descriptor|
        name = descriptor[0]

        begin
        d = Desc.new(*descriptor)

        # flatten all the attribute lists (Ruby1.9, *[a,b,c] can be
        # used to flatten a literal list, but not in Ruby1.8).
        d[:subelts] = d[:subelts].flatten
        d[:attrs_opt] = d[:attrs_opt].flatten
        d[:attrs_depr] = d[:attrs_depr].flatten
          d[:attrs_req] = d[:attrs_req].flatten
        rescue => e
            p name
          raise e
        end

        DefaultDescriptions[name] = d
      end
    end
  end
end
                                                     entity_lookup.rb                                                                                    0100644 0001750 0001750 00000000403 12566211316 045237  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                module Nokogiri
  module HTML
    class EntityDescription < Struct.new(:value, :name, :description); end

    class EntityLookup
      ###
      # Look up entity with +name+
      def [] name
        (val = get(name)) && val.value
      end
    end
  end
end
                                                                                                                                                                                                                                                             sax/                                                                                                0040755 0001750 0001750 00000000000 12612224746 042611  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html                parser.rb                                                                                           0100644 0001750 0001750 00000003201 12566211316 044420  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html/sax            module Nokogiri
  module HTML
    ###
    # Nokogiri lets you write a SAX parser to process HTML but get HTML
    # correction features.
    #
    # See Nokogiri::HTML::SAX::Parser for a basic example of using a
    # SAX parser with HTML.
    #
    # For more information on SAX parsers, see Nokogiri::XML::SAX
    module SAX
      ###
      # This class lets you perform SAX style parsing on HTML with HTML
      # error correction.
      #
      # Here is a basic usage example:
      #
      #   class MyDoc < Nokogiri::XML::SAX::Document
      #     def start_element name, attributes = []
      #       puts "found a #{name}"
      #     end
      #   end
      #
      #   parser = Nokogiri::HTML::SAX::Parser.new(MyDoc.new)
      #   parser.parse(File.read(ARGV[0], 'rb'))
      #
      # For more information on SAX parsers, see Nokogiri::XML::SAX
      class Parser < Nokogiri::XML::SAX::Parser
        ###
        # Parse html stored in +data+ using +encoding+
        def parse_memory data, encoding = 'UTF-8'
          raise ArgumentError unless data
          return unless data.length > 0
          ctx = ParserContext.memory(data, encoding)
          yield ctx if block_given?
          ctx.parse_with self
        end

        ###
        # Parse a file with +filename+
        def parse_file filename, encoding = 'UTF-8'
          raise ArgumentError unless filename
          raise Errno::ENOENT unless File.exists?(filename)
          raise Errno::EISDIR if File.directory?(filename)
          ctx = ParserContext.file(filename, encoding)
          yield ctx if block_given?
          ctx.parse_with self
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                               parser_context.rb                                                                                   0100644 0001750 0001750 00000000741 12566211316 046172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html/sax            module Nokogiri
  module HTML
    module SAX
      ###
      # Context for HTML SAX parsers.  This class is usually not instantiated
      # by the user.  Instead, you should be looking at
      # Nokogiri::HTML::SAX::Parser
      class ParserContext < Nokogiri::XML::SAX::ParserContext
        def self.new thing, encoding = 'UTF-8'
          [:read, :close].all? { |x| thing.respond_to?(x) } ?  super :
            memory(thing, encoding)
        end
      end
    end
  end
end
                               push_parser.rb                                                                                      0100644 0001750 0001750 00000000651 12566211316 045465  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/html/sax            module Nokogiri
  module HTML
    module SAX
      class PushParser
        def initialize(doc = XML::SAX::Document.new, file_name = nil, encoding = 'UTF-8')
          @document = doc
          @encoding = encoding
          @sax_parser = HTML::SAX::Parser.new(doc, @encoding)

          ## Create our push parser context
          initialize_native(@sax_parser, file_name, @encoding)
        end
      end
    end
  end
end
                                                                                       html.rb                                                                                             0100644 0001750 0001750 00000002256 12566211316 042342  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     require 'nokogiri/html/entity_lookup'
require 'nokogiri/html/document'
require 'nokogiri/html/document_fragment'
require 'nokogiri/html/sax/parser_context'
require 'nokogiri/html/sax/parser'
require 'nokogiri/html/sax/push_parser'
require 'nokogiri/html/element_description'
require 'nokogiri/html/element_description_defaults'

module Nokogiri
  class << self
    ###
    # Parse HTML.  Convenience method for Nokogiri::HTML::Document.parse
    def HTML thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block
      Nokogiri::HTML::Document.parse(thing, url, encoding, options, &block)
    end
  end

  module HTML
    class << self
      ###
      # Parse HTML.  Convenience method for Nokogiri::HTML::Document.parse
      def parse thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block
        Document.parse(thing, url, encoding, options, &block)
      end

      ####
      # Parse a fragment from +string+ in to a NodeSet.
      def fragment string, encoding = nil
        HTML::DocumentFragment.parse string, encoding
      end
    end

    # Instance of Nokogiri::HTML::EntityLookup
    NamedCharacters = EntityLookup.new
  end
end
                                                                                                                                                                                                                                                                                                                                                  syntax_error.rb                                                                                     0100644 0001750 0001750 00000000100 12566211316 044117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     module Nokogiri
  class SyntaxError < ::StandardError
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                version.rb                                                                                          0100644 0001750 0001750 00000004561 12566211316 043064  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     module Nokogiri
  # The version of Nokogiri you are using
  VERSION = '1.5.6'

  class VersionInfo # :nodoc:
    def jruby?
      ::JRUBY_VERSION if RUBY_PLATFORM == "java"
    end

    def engine
      defined?(RUBY_ENGINE) ? RUBY_ENGINE : 'mri'
    end

    def loaded_parser_version
      LIBXML_PARSER_VERSION.scan(/^(.*)(..)(..)$/).first.collect{ |j|
        j.to_i
      }.join(".")
    end

    def compiled_parser_version
      LIBXML_VERSION
    end

    def libxml2?
      defined?(LIBXML_VERSION)
    end

    def warnings
      return [] unless libxml2?

      if compiled_parser_version != loaded_parser_version
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end

    def to_hash
      hash_info = {}
      hash_info['warnings']              = []
      hash_info['nokogiri']              = Nokogiri::VERSION
      hash_info['ruby']                  = {}
      hash_info['ruby']['version']       = ::RUBY_VERSION
      hash_info['ruby']['platform']      = ::RUBY_PLATFORM
      hash_info['ruby']['description']   = ::RUBY_DESCRIPTION
      hash_info['ruby']['engine']        = engine
      hash_info['ruby']['jruby']         = jruby? if jruby?

      if libxml2?
        hash_info['libxml']              = {}
        hash_info['libxml']['binding']   = 'extension'
        hash_info['libxml']['compiled']  = compiled_parser_version
        hash_info['libxml']['loaded']    = loaded_parser_version
        hash_info['warnings']            = warnings
      elsif jruby?
        hash_info['xerces']   = Nokogiri::XERCES_VERSION
        hash_info['nekohtml'] = Nokogiri::NEKO_VERSION
      end

      hash_info
    end

    def to_markdown
      begin
        require 'psych'
      rescue LoadError
      end
      require 'yaml'
      "# Nokogiri (#{Nokogiri::VERSION})\n" +
      YAML.dump(to_hash).each_line.map { |line| "    #{line}" }.join
    end

    # FIXME: maybe switch to singleton?
    @@instance = new
    @@instance.warnings.each do |warning|
      warn "WARNING: #{warning}"
    end
    def self.instance; @@instance; end
  end

  # More complete version information about libxml
  VERSION_INFO = VersionInfo.instance.to_hash

  def self.uses_libxml? # :nodoc:
    VersionInfo.instance.libxml2?
  end

  def self.jruby? # :nodoc:
    VersionInfo.instance.jruby?
  end
end
                                                                                                                                               xml/                                                                                                0040755 0001750 0001750 00000000000 12612224746 041652  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     attr.rb                                                                                             0100644 0001750 0001750 00000000364 12566211316 043146  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class Attr < Node
      alias :value :content
      alias :to_s :content
      alias :content= :value=

      private
      def inspect_attributes
        [:name, :namespace, :value]
      end
    end
  end
end
                                                                                                                                                                                                                                                                            attribute_decl.rb                                                                                   0100644 0001750 0001750 00000000735 12566211316 045170  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # Represents an attribute declaration in a DTD
    class AttributeDecl < Nokogiri::XML::Node
      undef_method :attribute_nodes
      undef_method :attributes
      undef_method :content
      undef_method :namespace
      undef_method :namespace_definitions
      undef_method :line if method_defined?(:line)

      def inspect
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end
                                   builder.rb                                                                                          0100644 0001750 0001750 00000027221 12566211316 043623  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # Nokogiri builder can be used for building XML and HTML documents.
    #
    # == Synopsis:
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.root {
    #       xml.products {
    #         xml.widget {
    #           xml.id_ "10"
    #           xml.name "Awesome widget"
    #         }
    #       }
    #     }
    #   end
    #   puts builder.to_xml
    #
    # Will output:
    #
    #   <?xml version="1.0"?>
    #   <root>
    #     <products>
    #       <widget>
    #         <id>10</id>
    #         <name>Awesome widget</name>
    #       </widget>
    #     </products>
    #   </root>
    #
    #
    # === Builder scope
    #
    # The builder allows two forms.  When the builder is supplied with a block
    # that has a parameter, the outside scope is maintained.  This means you
    # can access variables that are outside your builder.  If you don't need
    # outside scope, you can use the builder without the "xml" prefix like
    # this:
    #
    #   builder = Nokogiri::XML::Builder.new do
    #     root {
    #       products {
    #         widget {
    #           id_ "10"
    #           name "Awesome widget"
    #         }
    #       }
    #     }
    #   end
    #
    # == Special Tags
    #
    # The builder works by taking advantage of method_missing.  Unfortunately
    # some methods are defined in ruby that are difficult or dangerous to
    # remove.  You may want to create tags with the name "type", "class", and
    # "id" for example.  In that case, you can use an underscore to
    # disambiguate your tag name from the method call.
    #
    # Here is an example of using the underscore to disambiguate tag names from
    # ruby methods:
    #
    #   @objects = [Object.new, Object.new, Object.new]
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.root {
    #       xml.objects {
    #         @objects.each do |o|
    #           xml.object {
    #             xml.type_   o.type
    #             xml.class_  o.class.name
    #             xml.id_     o.id
    #           }
    #         end
    #       }
    #     }
    #   end
    #   puts builder.to_xml
    #
    # The underscore may be used with any tag name, and the last underscore
    # will just be removed.  This code will output the following XML:
    #
    #   <?xml version="1.0"?>
    #   <root>
    #     <objects>
    #       <object>
    #         <type>Object</type>
    #         <class>Object</class>
    #         <id>48390</id>
    #       </object>
    #       <object>
    #         <type>Object</type>
    #         <class>Object</class>
    #         <id>48380</id>
    #       </object>
    #       <object>
    #         <type>Object</type>
    #         <class>Object</class>
    #         <id>48370</id>
    #       </object>
    #     </objects>
    #   </root>
    #
    # == Tag Attributes
    #
    # Tag attributes may be supplied as method arguments.  Here is our
    # previous example, but using attributes rather than tags:
    #
    #   @objects = [Object.new, Object.new, Object.new]
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.root {
    #       xml.objects {
    #         @objects.each do |o|
    #           xml.object(:type => o.type, :class => o.class, :id => o.id)
    #         end
    #       }
    #     }
    #   end
    #   puts builder.to_xml
    #
    # === Tag Attribute Short Cuts
    #
    # A couple attribute short cuts are available when building tags.  The
    # short cuts are available by special method calls when building a tag.
    #
    # This example builds an "object" tag with the class attribute "classy"
    # and the id of "thing":
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.root {
    #       xml.objects {
    #         xml.object.classy.thing!
    #       }
    #     }
    #   end
    #   puts builder.to_xml
    #
    # Which will output:
    #
    #   <?xml version="1.0"?>
    #   <root>
    #     <objects>
    #       <object class="classy" id="thing"/>
    #     </objects>
    #   </root>
    #
    # All other options are still supported with this syntax, including
    # blocks and extra tag attributes.
    #
    # == Namespaces
    #
    # Namespaces are added similarly to attributes.  Nokogiri::XML::Builder
    # assumes that when an attribute starts with "xmlns", it is meant to be
    # a namespace:
    #
    #   builder = Nokogiri::XML::Builder.new { |xml|
    #     xml.root('xmlns' => 'default', 'xmlns:foo' => 'bar') do
    #       xml.tenderlove
    #     end
    #   }
    #   puts builder.to_xml
    #
    # Will output XML like this:
    #
    #   <?xml version="1.0"?>
    #   <root xmlns:foo="bar" xmlns="default">
    #     <tenderlove/>
    #   </root>
    #
    # === Referencing declared namespaces
    #
    # Tags that reference non-default namespaces (i.e. a tag "foo:bar") can be
    # built by using the Nokogiri::XML::Builder#[] method.
    #
    # For example:
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.root('xmlns:foo' => 'bar') {
    #       xml.objects {
    #         xml['foo'].object.classy.thing!
    #       }
    #     }
    #   end
    #   puts builder.to_xml
    #
    # Will output this XML:
    #
    #   <?xml version="1.0"?>
    #   <root xmlns:foo="bar">
    #     <objects>
    #       <foo:object class="classy" id="thing"/>
    #     </objects>
    #   </root>
    #
    # Note the "foo:object" tag.
    #
    # == Document Types
    #
    # To create a document type (DTD), access use the Builder#doc method to get
    # the current context document.  Then call Node#create_internal_subset to
    # create the DTD node.
    #
    # For example, this Ruby:
    #
    #   builder = Nokogiri::XML::Builder.new do |xml|
    #     xml.doc.create_internal_subset(
    #       'html',
    #       "-//W3C//DTD HTML 4.01 Transitional//EN",
    #       "http://www.w3.org/TR/html4/loose.dtd"
    #     )
    #     xml.root do
    #       xml.foo
    #     end
    #   end
    #   
    #   puts builder.to_xml
    #
    # Will output this xml:
    #
    #   <?xml version="1.0"?>
    #   <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
    #   <root>
    #     <foo/>
    #   </root>
    #
    class Builder
      # The current Document object being built
      attr_accessor :doc

      # The parent of the current node being built
      attr_accessor :parent

      # A context object for use when the block has no arguments
      attr_accessor :context

      attr_accessor :arity # :nodoc:

      ###
      # Create a builder with an existing root object.  This is for use when
      # you have an existing document that you would like to augment with
      # builder methods.  The builder context created will start with the
      # given +root+ node.
      #
      # For example:
      #
      #   doc = Nokogiri::XML(open('somedoc.xml'))
      #   Nokogiri::XML::Builder.with(doc.at('some_tag')) do |xml|
      #     # ... Use normal builder methods here ...
      #     xml.awesome # add the "awesome" tag below "some_tag"
      #   end
      #
      def self.with root, &block
        new({}, root, &block)
      end

      ###
      # Create a new Builder object.  +options+ are sent to the top level
      # Document that is being built.
      #
      # Building a document with a particular encoding for example:
      #
      #   Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
      #     ...
      #   end
      def initialize options = {}, root = nil, &block

        if root
          @doc    = root.document
          @parent = root
        else
          namespace     = self.class.name.split('::')
          namespace[-1] = 'Document'
          @doc          = eval(namespace.join('::')).new
          @parent       = @doc
        end

        @context  = nil
        @arity    = nil
        @ns       = nil

        options.each do |k,v|
          @doc.send(:"#{k}=", v)
        end

        return unless block_given?

        @arity = block.arity
        if @arity <= 0
          @context = eval('self', block.binding)
          instance_eval(&block)
        else
          yield self
        end

        @parent = @doc
      end

      ###
      # Create a Text Node with content of +string+
      def text string
        insert @doc.create_text_node(string)
      end

      ###
      # Create a CDATA Node with content of +string+
      def cdata string
        insert doc.create_cdata(string)
      end

      ###
      # Create a Comment Node with content of +string+
      def comment string
        insert doc.create_comment(string)
      end

      ###
      # Build a tag that is associated with namespace +ns+.  Raises an
      # ArgumentError if +ns+ has not been defined higher in the tree.
      def [] ns
        @ns = @parent.namespace_definitions.find { |x| x.prefix == ns.to_s }
        return self if @ns

        @parent.ancestors.each do |a|
          next if a == doc
          @ns = a.namespace_definitions.find { |x| x.prefix == ns.to_s }
          return self if @ns
        end

        raise ArgumentError, "Namespace #{ns} has not been defined"
      end

      ###
      # Convert this Builder object to XML
      def to_xml(*args)
        if Nokogiri.jruby?
          options = args.first.is_a?(Hash) ? args.shift : {}
          if !options[:save_with]
            options[:save_with] = Node::SaveOptions::AS_BUILDER
          end
          args.insert(0, options)
        end
        @doc.to_xml(*args)
      end

      ###
      # Append the given raw XML +string+ to the document
      def << string
        @doc.fragment(string).children.each { |x| insert(x) }
      end

      def method_missing method, *args, &block # :nodoc:
        if @context && @context.respond_to?(method)
          @context.send(method, *args, &block)
        else
          node = @doc.create_element(method.to_s.sub(/[_!]$/, ''),*args) { |n|
            # Set up the namespace
            if @ns
              n.namespace = @ns
              @ns = nil
            end
          }
          insert(node, &block)
        end
      end

      private
      ###
      # Insert +node+ as a child of the current Node
      def insert(node, &block)
        node.parent = @parent
        if block_given?
          old_parent = @parent
          @parent    = node
          @arity ||= block.arity
          if @arity <= 0
            instance_eval(&block)
          else
            block.call(self)
          end
          @parent = old_parent
        end
        NodeBuilder.new(node, self)
      end

      class NodeBuilder # :nodoc:
        def initialize node, doc_builder
          @node = node
          @doc_builder = doc_builder
        end

        def []= k, v
          @node[k] = v
        end

        def [] k
          @node[k]
        end

        def method_missing(method, *args, &block)
          opts = args.last.is_a?(Hash) ? args.pop : {}
          case method.to_s
          when /^(.*)!$/
            @node['id'] = $1
            @node.content = args.first if args.first
          when /^(.*)=/
            @node[$1] = args.first
          else
            @node['class'] =
              ((@node['class'] || '').split(/\s/) + [method.to_s]).join(' ')
            @node.content = args.first if args.first
          end

          # Assign any extra options
          opts.each do |k,v|
            @node[k.to_s] = ((@node[k.to_s] || '').split(/\s/) + [v]).join(' ')
          end

          if block_given?
            old_parent = @doc_builder.parent
            @doc_builder.parent = @node
            value = @doc_builder.instance_eval(&block)
            @doc_builder.parent = old_parent
            return value
          end
          self
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                               cdata.rb                                                                                            0100644 0001750 0001750 00000000271 12566211316 043245  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class CDATA < Nokogiri::XML::Text
      ###
      # Get the name of this CDATA node
      def name
        '#cdata-section'
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                       character_data.rb                                                                                   0100644 0001750 0001750 00000000214 12566211316 045113  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class CharacterData < Nokogiri::XML::Node
      include Nokogiri::XML::PP::CharacterData
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                    document.rb                                                                                         0100644 0001750 0001750 00000020665 12566211316 044020  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ##
    # Nokogiri::XML::Document is the main entry point for dealing with
    # XML documents.  The Document is created by parsing an XML document.
    # See Nokogiri::XML::Document.parse() for more information on parsing.
    #
    # For searching a Document, see Nokogiri::XML::Node#css and
    # Nokogiri::XML::Node#xpath
    #
    class Document < Nokogiri::XML::Node
      # I'm ignoring unicode characters here.
      # See http://www.w3.org/TR/REC-xml-names/#ns-decl for more details.
      NCNAME_START_CHAR = "A-Za-z_"
      NCNAME_CHAR       = NCNAME_START_CHAR + "\\-.0-9"
      NCNAME_RE         = /^xmlns(:[#{NCNAME_START_CHAR}][#{NCNAME_CHAR}]*)?$/

      ##
      # Parse an XML file.
      #
      # +string_or_io+ may be a String, or any object that responds to
      # _read_ and _close_ such as an IO, or StringIO.
      #
      # +url+ (optional) is the URI where this document is located.
      #
      # +encoding+ (optional) is the encoding that should be used when processing
      # the document.
      #
      # +options+ (optional) is a configuration object that sets options during
      # parsing, such as Nokogiri::XML::ParseOptions::RECOVER. See the
      # Nokogiri::XML::ParseOptions for more information.
      #
      # +block+ (optional) is passed a configuration object on which
      # parse options may be set.
      #
      # When parsing untrusted documents, it's recommended that the
      # +nonet+ option be used, as shown in this example code:
      #
      #   Nokogiri::XML::Document.parse(xml_string) { |config| config.nonet }
      #
      # Nokogiri.XML() is a convenience method which will call this method.
      #
      def self.parse string_or_io, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block
        options = Nokogiri::XML::ParseOptions.new(options) if Fixnum === options
        # Give the options to the user
        yield options if block_given?

        doc = if string_or_io.respond_to?(:read)
          url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil
          read_io(string_or_io, url, encoding, options.to_i)
        else
          # read_memory pukes on empty docs
          return new if string_or_io.nil? or string_or_io.empty?
          read_memory(string_or_io, url, encoding, options.to_i)
        end

        # do xinclude processing
        doc.do_xinclude(options) if options.xinclude?

        return doc
      end

      # A list of Nokogiri::XML::SyntaxError found when parsing a document
      attr_accessor :errors

      def initialize *args # :nodoc:
        @errors     = []
        @decorators = nil
      end

      ##
      # Create an element with +name+, and optionally setting the content and attributes.
      #
      #   doc.create_element "div" # <div></div>
      #   doc.create_element "div", :class => "container" # <div class='container'></div>
      #   doc.create_element "div", "contents" # <div>contents</div>
      #   doc.create_element "div", "contents", :class => "container" # <div class='container'>contents</div>
      #   doc.create_element "div" { |node| node['class'] = "container" } # <div class='container'></div>
      #
      def create_element name, *args, &block
        elm = Nokogiri::XML::Element.new(name, self, &block)
        args.each do |arg|
          case arg
          when Hash
            arg.each { |k,v|
              key = k.to_s
              if key =~ NCNAME_RE
                ns_name = key.split(":", 2)[1]
                elm.add_namespace_definition ns_name, v
                next
              end
              elm[k.to_s] = v.to_s
            }
          else
            elm.content = arg
          end
        end
        elm
      end

      # Create a Text Node with +string+
      def create_text_node string, &block
        Nokogiri::XML::Text.new string.to_s, self, &block
      end

      # Create a CDATA Node containing +string+
      def create_cdata string, &block
        Nokogiri::XML::CDATA.new self, string.to_s, &block
      end

      # Create a Comment Node containing +string+
      def create_comment string, &block
        Nokogiri::XML::Comment.new self, string.to_s, &block
      end

      # The name of this document.  Always returns "document"
      def name
        'document'
      end

      # A reference to +self+
      def document
        self
      end

      ##
      # Recursively get all namespaces from this node and its subtree and
      # return them as a hash.
      #
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">
      #     <bar xmlns:hello="world" />
      #   </root>
      #
      # This method will return:
      #
      #   { 'xmlns:foo' => 'bar', 'xmlns:hello' => 'world' }
      #
      # WARNING: this method will clobber duplicate names in the keys.
      # For example, given this document:
      #
      #   <root xmlns:foo="bar">
      #     <bar xmlns:foo="baz" />
      #   </root>
      #
      # The hash returned will look like this: { 'xmlns:foo' => 'bar' }
      #
      # Non-prefixed default namespaces (as in "xmlns=") are not included
      # in the hash.
      #
      # Note that this method does an xpath lookup for nodes with
      # namespaces, and as a result the order may be dependent on the
      # implementation of the underlying XML library.
      #
      def collect_namespaces
        xpath("//namespace::*").inject({}) do |hash, ns|
          hash[["xmlns",ns.prefix].compact.join(":")] = ns.href if ns.prefix != "xml"
          hash
        end
      end

      # Get the list of decorators given +key+
      def decorators key
        @decorators ||= Hash.new
        @decorators[key] ||= []
      end

      ##
      # Validate this Document against it's DTD.  Returns a list of errors on
      # the document or +nil+ when there is no DTD.
      def validate
        return nil unless internal_subset
        internal_subset.validate self
      end

      ##
      # Explore a document with shortcut methods. See Nokogiri::Slop for details.
      #
      # Note that any nodes that have been instantiated before #slop!
      # is called will not be decorated with sloppy behavior. So, if you're in
      # irb, the preferred idiom is:
      #
      #   irb> doc = Nokogiri::Slop my_markup
      #
      # and not
      #
      #   irb> doc = Nokogiri::HTML my_markup
      #   ... followed by irb's implicit inspect (and therefore instantiation of every node) ...
      #   irb> doc.slop!
      #   ... which does absolutely nothing.
      #
      def slop!
        unless decorators(XML::Node).include? Nokogiri::Decorators::Slop
          decorators(XML::Node) << Nokogiri::Decorators::Slop
          decorate!
        end

        self
      end

      ##
      # Apply any decorators to +node+
      def decorate node
        return unless @decorators
        @decorators.each { |klass,list|
          next unless node.is_a?(klass)
          list.each { |moodule| node.extend(moodule) }
        }
      end

      alias :to_xml :serialize
      alias :clone :dup

      # Get the hash of namespaces on the root Nokogiri::XML::Node
      def namespaces
        root ? root.namespaces : {}
      end

      ##
      # Create a Nokogiri::XML::DocumentFragment from +tags+
      # Returns an empty fragment if +tags+ is nil.
      def fragment tags = nil
        DocumentFragment.new(self, tags, self.root)
      end

      undef_method :swap, :parent, :namespace, :default_namespace=
      undef_method :add_namespace_definition, :attributes
      undef_method :namespace_definitions, :line, :add_namespace

      def add_child node_or_tags
        raise "Document already has a root node" if root
        node_or_tags = coerce(node_or_tags)
        if node_or_tags.is_a?(XML::NodeSet)
          raise "Document cannot have multiple root nodes" if node_or_tags.size > 1
          super(node_or_tags.first)
        else
          super
        end
      end
      alias :<< :add_child

      ##
      # +JRuby+
      # Wraps Java's org.w3c.dom.document and returns Nokogiri::XML::Document
      def self.wrap document
        raise "JRuby only method" unless Nokogiri.jruby?
        return wrapJavaDocument(document)
      end

      ##
      # +JRuby+
      # Returns Java's org.w3c.dom.document of this Document.
      def to_java
        raise "JRuby only method" unless Nokogiri.jruby?
        return toJavaDocument()
      end

      private
      def implied_xpath_context
        "/"
      end

      def inspect_attributes
        [:name, :children]
      end
    end
  end
end
                                                                           document_fragment.rb                                                                                0100644 0001750 0001750 00000006102 12566211316 045671  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class DocumentFragment < Nokogiri::XML::Node
      ##
      #  Create a new DocumentFragment from +tags+.
      #
      #  If +ctx+ is present, it is used as a context node for the
      #  subtree created, e.g., namespaces will be resolved relative
      #  to +ctx+.
      def initialize document, tags = nil, ctx = nil
        return self unless tags

        children = if ctx
                     # Fix for issue#490
                     if Nokogiri.jruby?
                       # fix for issue #770
                       ctx.parse("<root #{namespace_declarations(ctx)}>#{tags}</root>").children
                     else
                       ctx.parse(tags)
                     end
                   else
                     XML::Document.parse("<root>#{tags}</root>") \
                       .xpath("/root/node()")
                   end
        children.each { |child| child.parent = self }
      end

      ###
      # return the name for DocumentFragment
      def name
        '#document-fragment'
      end

      ###
      # Convert this DocumentFragment to a string
      def to_s
        children.to_s
      end

      ###
      # Convert this DocumentFragment to html
      # See Nokogiri::XML::NodeSet#to_html
      def to_html *args
        if Nokogiri.jruby?
          options = args.first.is_a?(Hash) ? args.shift : {}
          if !options[:save_with]
            options[:save_with] = Node::SaveOptions::NO_DECLARATION | Node::SaveOptions::NO_EMPTY_TAGS | Node::SaveOptions::AS_HTML
          end
          args.insert(0, options)
        end
        children.to_html(*args)
      end

      ###
      # Convert this DocumentFragment to xhtml
      # See Nokogiri::XML::NodeSet#to_xhtml
      def to_xhtml *args
        if Nokogiri.jruby?
          options = args.first.is_a?(Hash) ? args.shift : {}
          if !options[:save_with]
            options[:save_with] = Node::SaveOptions::NO_DECLARATION | Node::SaveOptions::NO_EMPTY_TAGS | Node::SaveOptions::AS_XHTML
          end
          args.insert(0, options)
        end
        children.to_xhtml(*args)
      end

      ###
      # Convert this DocumentFragment to xml
      # See Nokogiri::XML::NodeSet#to_xml
      def to_xml *args
        children.to_xml(*args)
      end

      ###
      # Search this fragment.  See Nokogiri::XML::Node#css
      def css *args
        if children.any?
          children.css(*args)
        else
          NodeSet.new(document)
        end
      end

      alias :serialize :to_s

      class << self
        ####
        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def parse tags
          self.new(XML::Document.new, tags)
        end
      end

      private

      # fix for issue 770
      def namespace_declarations ctx
        ctx.namespace_scopes.map do |namespace|
          prefix = namespace.prefix.nil? ? "" : ":#{namespace.prefix}"
          %Q{xmlns#{prefix}="#{namespace.href}"}
        end.join ' '
      end

      def coerce data
        return super unless String === data

        document.fragment(data).children
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                              dtd.rb                                                                                              0100644 0001750 0001750 00000000720 12566211316 042743  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class DTD < Nokogiri::XML::Node
      undef_method :attribute_nodes
      undef_method :values
      undef_method :content
      undef_method :namespace
      undef_method :namespace_definitions
      undef_method :line if method_defined?(:line)

      def keys
        attributes.keys
      end

      def each &block
        attributes.each { |key, value|
          block.call([key, value])
        }
      end
    end
  end
end
                                                element_content.rb                                                                                  0100644 0001750 0001750 00000001526 12566211316 045360  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # Represents the allowed content in an Element Declaration inside a DTD:
    #
    #   <?xml version="1.0"?><?TEST-STYLE PIDATA?>
    #   <!DOCTYPE staff SYSTEM "staff.dtd" [
    #      <!ELEMENT div1 (head, (p | list | note)*, div2*)>
    #   ]>
    #   </root>
    #
    # ElementContent represents the tree inside the <!ELEMENT> tag shown above
    # that lists the possible content for the div1 tag.
    class ElementContent
      # Possible definitions of type
      PCDATA  = 1
      ELEMENT = 2
      SEQ     = 3
      OR      = 4

      # Possible content occurrences
      ONCE    = 1
      OPT     = 2
      MULT    = 3
      PLUS    = 4

      attr_reader :document

      ###
      # Get the children of this ElementContent node
      def children
        [c1, c2].compact
      end
    end
  end
end
                                                                                                                                                                          element_decl.rb                                                                                     0100644 0001750 0001750 00000000501 12566211316 044605  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method :namespace
      undef_method :namespace_definitions
      undef_method :line if method_defined?(:line)

      def inspect
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end
                                                                                                                                                                                               entity_decl.rb                                                                                      0100644 0001750 0001750 00000000731 12566211316 044475  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class EntityDecl < Nokogiri::XML::Node
      undef_method :attribute_nodes
      undef_method :attributes
      undef_method :namespace
      undef_method :namespace_definitions
      undef_method :line if method_defined?(:line)

      def self.new name, doc, *args
        doc.create_entity(name, *args)
      end

      def inspect
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end
                                       namespace.rb                                                                                        0100644 0001750 0001750 00000000324 12566211316 044124  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class Namespace
      include Nokogiri::XML::PP::Node
      attr_reader :document

      private
      def inspect_attributes
        [:prefix, :href]
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                            node/                                                                                               0040755 0001750 0001750 00000000000 12612224746 042577  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 save_options.rb                                                                                     0100644 0001750 0001750 00000003351 12566211316 045631  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/node            module Nokogiri
  module XML
    class Node
      ###
      # Save options for serializing nodes
      class SaveOptions
        # Format serialized xml
        FORMAT          = 1
        # Do not include declarations
        NO_DECLARATION  = 2
        # Do not include empty tags
        NO_EMPTY_TAGS   = 4
        # Do not save XHTML
        NO_XHTML        = 8
        # Save as XHTML
        AS_XHTML        = 16
        # Save as XML
        AS_XML          = 32
        # Save as HTML
        AS_HTML         = 64

        if Nokogiri.jruby?
          # Save builder created document
          AS_BUILDER    = 128
          # the default for XML documents
          DEFAULT_XML  = AS_XML # https://github.com/sparklemotion/nokogiri/issues/#issue/415
          # the default for HTML document
          DEFAULT_HTML = NO_DECLARATION | NO_EMPTY_TAGS | AS_HTML
        else
          # the default for XML documents
          DEFAULT_XML  = FORMAT | AS_XML
          # the default for HTML document
          DEFAULT_HTML = FORMAT | NO_DECLARATION | NO_EMPTY_TAGS | AS_HTML
        end
        # the default for XHTML document
        DEFAULT_XHTML = FORMAT | NO_DECLARATION | NO_EMPTY_TAGS | AS_XHTML

        # Integer representation of the SaveOptions
        attr_reader :options

        # Create a new SaveOptions object with +options+
        def initialize options = 0; @options = options; end

        constants.each do |constant|
          class_eval %{
            def #{constant.downcase}
              @options |= #{constant}
              self
            end

            def #{constant.downcase}?
              #{constant} & @options == #{constant}
            end
          }
        end

        alias :to_i :options
      end
    end
  end
end
                                                                                                                                                                                                                                                                                       node.rb                                                                                             0100644 0001750 0001750 00000075106 12566211316 043127  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 require 'stringio'
require 'nokogiri/xml/node/save_options'

module Nokogiri
  module XML
    ####
    # Nokogiri::XML::Node is your window to the fun filled world of dealing
    # with XML and HTML tags.  A Nokogiri::XML::Node may be treated similarly
    # to a hash with regard to attributes.  For example (from irb):
    #
    #   irb(main):004:0> node
    #   => <a href="#foo" id="link">link</a>
    #   irb(main):005:0> node['href']
    #   => "#foo"
    #   irb(main):006:0> node.keys
    #   => ["href", "id"]
    #   irb(main):007:0> node.values
    #   => ["#foo", "link"]
    #   irb(main):008:0> node['class'] = 'green'
    #   => "green"
    #   irb(main):009:0> node
    #   => <a href="#foo" id="link" class="green">link</a>
    #   irb(main):010:0>
    #
    # See Nokogiri::XML::Node#[] and Nokogiri::XML#[]= for more information.
    #
    # Nokogiri::XML::Node also has methods that let you move around your
    # tree.  For navigating your tree, see:
    #
    # * Nokogiri::XML::Node#parent
    # * Nokogiri::XML::Node#children
    # * Nokogiri::XML::Node#next
    # * Nokogiri::XML::Node#previous
    #
    # You may search this node's subtree using Node#xpath and Node#css
    class Node
      include Nokogiri::XML::PP::Node
      include Enumerable

      # Element node type, see Nokogiri::XML::Node#element?
      ELEMENT_NODE =       1
      # Attribute node type
      ATTRIBUTE_NODE =     2
      # Text node type, see Nokogiri::XML::Node#text?
      TEXT_NODE =          3
      # CDATA node type, see Nokogiri::XML::Node#cdata?
      CDATA_SECTION_NODE = 4
      # Entity reference node type
      ENTITY_REF_NODE =    5
      # Entity node type
      ENTITY_NODE =        6
      # PI node type
      PI_NODE =            7
      # Comment node type, see Nokogiri::XML::Node#comment?
      COMMENT_NODE =       8
      # Document node type, see Nokogiri::XML::Node#xml?
      DOCUMENT_NODE =      9
      # Document type node type
      DOCUMENT_TYPE_NODE = 10
      # Document fragment node type
      DOCUMENT_FRAG_NODE = 11
      # Notation node type
      NOTATION_NODE =      12
      # HTML document node type, see Nokogiri::XML::Node#html?
      HTML_DOCUMENT_NODE = 13
      # DTD node type
      DTD_NODE =           14
      # Element declaration type
      ELEMENT_DECL =       15
      # Attribute declaration type
      ATTRIBUTE_DECL =     16
      # Entity declaration type
      ENTITY_DECL =        17
      # Namespace declaration type
      NAMESPACE_DECL =     18
      # XInclude start type
      XINCLUDE_START =     19
      # XInclude end type
      XINCLUDE_END =       20
      # DOCB document node type
      DOCB_DOCUMENT_NODE = 21

      def initialize name, document # :nodoc:
        # ... Ya.  This is empty on purpose.
      end

      ###
      # Decorate this node with the decorators set up in this node's Document
      def decorate!
        document.decorate(self)
      end

      ###
      # Search this node for +paths+.  +paths+ can be XPath or CSS, and an
      # optional hash of namespaces may be appended.
      # See Node#xpath and Node#css.
      def search *paths
        # TODO use         paths, handler, ns, binds = extract_params(paths)
        ns = paths.last.is_a?(Hash) ? paths.pop :
          (document.root ? document.root.namespaces : {})

        prefix = "#{implied_xpath_context}/"

        xpath(*(paths.map { |path|
          path = path.to_s
          path =~ /^(\.\/|\/|\.\.|\.$)/ ? path : CSS.xpath_for(
            path,
            :prefix => prefix,
            :ns     => ns
          )
        }.flatten.uniq) + [ns])
      end
      alias :/ :search

      ###
      # call-seq: xpath *paths, [namespace-bindings, variable-bindings, custom-handler-class]
      #
      # Search this node for XPath +paths+. +paths+ must be one or more XPath
      # queries.
      #
      #   node.xpath('.//title')
      #
      # A hash of namespace bindings may be appended. For example:
      #
      #   node.xpath('.//foo:name', {'foo' => 'http://example.org/'})
      #   node.xpath('.//xmlns:name', node.root.namespaces)
      #
      # A hash of variable bindings may also be appended to the namespace bindings. For example:
      #
      #   node.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})
      #
      # Custom XPath functions may also be defined.  To define custom
      # functions create a class and implement the function you want
      # to define.  The first argument to the method will be the
      # current matching NodeSet.  Any other arguments are ones that
      # you pass in.  Note that this class may appear anywhere in the
      # argument list.  For example:
      #
      #   node.xpath('.//title[regex(., "\w+")]', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #
      def xpath *paths
        return NodeSet.new(document) unless document

        paths, handler, ns, binds = extract_params(paths)

        sets = paths.map { |path|
          ctx = XPathContext.new(self)
          ctx.register_namespaces(ns)
          path = path.gsub(/xmlns:/, ' :') unless Nokogiri.uses_libxml?

          binds.each do |key,value|
            ctx.register_variable key.to_s, value
          end if binds

          ctx.evaluate(path, handler)
        }
        return sets.first if sets.length == 1

        NodeSet.new(document) do |combined|
          sets.each do |set|
            set.each do |node|
              combined << node
            end
          end
        end
      end

      ###
      # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
      #
      # Search this node for CSS +rules+. +rules+ must be one or more CSS
      # selectors. For example:
      #
      #   node.css('title')
      #   node.css('body h1.bold')
      #   node.css('div + p.green', 'div#one')
      #
      # A hash of namespace bindings may be appended. For example:
      #
      #   node.css('bike|tire', {'bike' => 'http://schwinn.com/'})
      #
      # Custom CSS pseudo classes may also be defined.  To define
      # custom pseudo classes, create a class and implement the custom
      # pseudo class you want defined.  The first argument to the
      # method will be the current matching NodeSet.  Any other
      # arguments are ones that you pass in.  For example:
      #
      #   node.css('title:regex("\w+")', Class.new {
      #     def regex node_set, regex
      #       node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      #     end
      #   }.new)
      #
      # Note that the CSS query string is case-sensitive with regards
      # to your document type. That is, if you're looking for "H1" in
      # an HTML document, you'll never find anything, since HTML tags
      # will match only lowercase CSS queries. However, "H1" might be
      # found in an XML document, where tags names are case-sensitive
      # (e.g., "H1" is distinct from "h1").
      #
      def css *rules
        rules, handler, ns, binds = extract_params(rules)

        prefix = "#{implied_xpath_context}/"

        rules = rules.map { |rule|
          CSS.xpath_for(rule, :prefix => prefix, :ns => ns)
        }.flatten.uniq + [ns, handler, binds].compact

        xpath(*rules)
      end

      ###
      # Search this node's immediate children using CSS selector +selector+
      def > selector
        ns = document.root.namespaces
        xpath CSS.xpath_for(selector, :prefix => "./", :ns => ns).first
      end

      ###
      # Search for the first occurrence of +path+.
      #
      # Returns nil if nothing is found, otherwise a Node.
      def at path, ns = document.root ? document.root.namespaces : {}
        search(path, ns).first
      end
      alias :% :at

      ##
      # Search this node for the first occurrence of XPath +paths+.
      # Equivalent to <tt>xpath(paths).first</tt>
      # See Node#xpath for more information.
      #
      def at_xpath *paths
        xpath(*paths).first
      end

      ##
      # Search this node for the first occurrence of CSS +rules+.
      # Equivalent to <tt>css(rules).first</tt>
      # See Node#css for more information.
      #
      def at_css *rules
        css(*rules).first
      end

      ###
      # Get the attribute value for the attribute +name+
      def [] name
        get(name.to_s)
      end

      ###
      # Set the attribute value for the attribute +name+ to +value+
      def []= name, value
        set name.to_s, value.to_s
      end

      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +<<+.
      def add_child node_or_tags
        node_or_tags = coerce(node_or_tags)
        if node_or_tags.is_a?(XML::NodeSet)
          node_or_tags.each { |n| add_child_node n }
        else
          add_child_node node_or_tags
        end
        node_or_tags
      end

      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls (e.g., root << child1 << child2)
      #
      # Also see related method +add_child+.
      def << node_or_tags
        add_child node_or_tags
        self
      end
      ###
      # Insert +node_or_tags+ before this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +before+.
      def add_previous_sibling node_or_tags
        raise ArgumentError.new("A document may not have multiple root nodes.") if parent.is_a?(XML::Document) && !node_or_tags.is_a?(XML::ProcessingInstruction)

        add_sibling :previous, node_or_tags
      end

      ###
      # Insert +node_or_tags+ after this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +after+.
      def add_next_sibling node_or_tags
        raise ArgumentError.new("A document may not have multiple root nodes.") if parent.is_a?(XML::Document)
        
        add_sibling :next, node_or_tags
      end

      ####
      # Insert +node_or_tags+ before this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +add_previous_sibling+.
      def before node_or_tags
        add_previous_sibling node_or_tags
        self
      end

      ####
      # Insert +node_or_tags+ after this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +add_next_sibling+.
      def after node_or_tags
        add_next_sibling node_or_tags
        self
      end

      ####
      # Set the inner html for this Node to +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns self.
      #
      # Also see related method +children=+
      def inner_html= node_or_tags
        self.children = node_or_tags
        self
      end

      ####
      # Set the inner html for this Node +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +inner_html=+
      def children= node_or_tags
        node_or_tags = coerce(node_or_tags)
        children.unlink
        if node_or_tags.is_a?(XML::NodeSet)
          node_or_tags.each { |n| add_child_node n }
        else
          add_child_node node_or_tags
        end
        node_or_tags
      end

      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +swap+.
      def replace node_or_tags
        # We cannot replace a text node directly, otherwise libxml will return
        # an internal error at parser.c:13031, I don't know exactly why
        # libxml is trying to find a parent node that is an element or document
        # so I can't tell if this is bug in libxml or not. issue #775.
        if text?
          replacee = Nokogiri::XML::Node.new 'dummy', document
          add_previous_sibling_node replacee
          unlink
          return replacee.replace node_or_tags
        end

        node_or_tags = coerce(node_or_tags)

        if node_or_tags.is_a?(XML::NodeSet)
          node_or_tags.each { |n| add_previous_sibling n }
          unlink
        else
          replace_node node_or_tags
        end
        node_or_tags
      end

      ####
      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns self, to support chaining of calls.
      #
      # Also see related method +replace+.
      def swap node_or_tags
        replace node_or_tags
        self
      end

      alias :next           :next_sibling
      alias :previous       :previous_sibling

      # :stopdoc:
      # HACK: This is to work around an RDoc bug
      alias :next=          :add_next_sibling
      # :startdoc:

      alias :previous=      :add_previous_sibling
      alias :remove         :unlink
      alias :get_attribute  :[]
      alias :attr           :[]
      alias :set_attribute  :[]=
      alias :text           :content
      alias :inner_text     :content
      alias :has_attribute? :key?
      alias :name           :node_name
      alias :name=          :node_name=
      alias :type           :node_type
      alias :to_str         :text
      alias :clone          :dup
      alias :elements       :element_children

      ####
      # Returns a hash containing the node's attributes.  The key is
      # the attribute name without any namespace, the value is a Nokogiri::XML::Attr
      # representing the attribute.
      # If you need to distinguish attributes with the same name, with different namespaces
      # use #attribute_nodes instead.
      def attributes
        Hash[attribute_nodes.map { |node|
          [node.node_name, node]
        }]
      end

      ###
      # Get the attribute values for this Node.
      def values
        attribute_nodes.map { |node| node.value }
      end

      ###
      # Get the attribute names for this Node.
      def keys
        attribute_nodes.map { |node| node.node_name }
      end

      ###
      # Iterate over each attribute name and value pair for this Node.
      def each
        attribute_nodes.each { |node|
          yield [node.node_name, node.value]
        }
      end

      ###
      # Remove the attribute named +name+
      def remove_attribute name
        attributes[name].remove if key? name
      end
      alias :delete :remove_attribute

      ###
      # Returns true if this Node matches +selector+
      def matches? selector
        ancestors.last.search(selector).include?(self)
      end

      ###
      # Create a DocumentFragment containing +tags+ that is relative to _this_
      # context node.
      def fragment tags
        type = document.html? ? Nokogiri::HTML : Nokogiri::XML
        type::DocumentFragment.new(document, tags, self)
      end

      ###
      # Parse +string_or_io+ as a document fragment within the context of
      # *this* node.  Returns a XML::NodeSet containing the nodes parsed from
      # +string_or_io+.
      def parse string_or_io, options = nil
        options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
        if Fixnum === options
          options = Nokogiri::XML::ParseOptions.new(options)
        end
        # Give the options to the user
        yield options if block_given?

        contents = string_or_io.respond_to?(:read) ?
          string_or_io.read :
          string_or_io

        return Nokogiri::XML::NodeSet.new(document) if contents.empty?

        ##
        # This is a horrible hack, but I don't care. See #313 for background.
        error_count = document.errors.length
        node_set = in_context(contents, options.to_i)
        if node_set.empty? and document.errors.length > error_count and options.recover?
          fragment = Nokogiri::HTML::DocumentFragment.parse contents
          node_set = fragment.children
        end
        node_set
      end

      ####
      # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
      def content= string
        self.native_content = encode_special_chars(string.to_s)
      end

      ###
      # Set the parent Node for this Node
      def parent= parent_node
        parent_node.add_child(self)
        parent_node
      end

      ###
      # Returns a Hash of {prefix => value} for all namespaces on this
      # node and its ancestors.
      #
      # This method returns the same namespaces as #namespace_scopes.
      #
      # Returns namespaces in scope for self -- those defined on self
      # element directly or any ancestor node -- as a Hash of
      # attribute-name/value pairs. Note that the keys in this hash
      # XML attributes that would be used to define this namespace,
      # such as "xmlns:prefix", not just the prefix. Default namespace
      # set on self will be included with key "xmlns". However,
      # default namespaces set on ancestor will NOT be, even if self
      # has no explicit default namespace.
      def namespaces
        Hash[namespace_scopes.map { |nd|
          key = ['xmlns', nd.prefix].compact.join(':')
          if RUBY_VERSION >= '1.9' && document.encoding
            begin
              key.force_encoding document.encoding
            rescue ArgumentError
            end
          end
          [key, nd.href]
        }]
      end

      # Returns true if this is a Comment
      def comment?
        type == COMMENT_NODE
      end

      # Returns true if this is a CDATA
      def cdata?
        type == CDATA_SECTION_NODE
      end

      # Returns true if this is an XML::Document node
      def xml?
        type == DOCUMENT_NODE
      end

      # Returns true if this is an HTML::Document node
      def html?
        type == HTML_DOCUMENT_NODE
      end

      # Returns true if this is a Text node
      def text?
        type == TEXT_NODE
      end

      # Returns true if this is a DocumentFragment
      def fragment?
        type == DOCUMENT_FRAG_NODE
      end

      ###
      # Fetch the Nokogiri::HTML::ElementDescription for this node.  Returns
      # nil on XML documents and on unknown tags.
      def description
        return nil if document.xml?
        Nokogiri::HTML::ElementDescription[name]
      end

      ###
      # Is this a read only node?
      def read_only?
        # According to gdome2, these are read-only node types
        [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
      end

      # Returns true if this is an Element node
      def element?
        type == ELEMENT_NODE
      end
      alias :elem? :element?

      ###
      # Turn this node in to a string.  If the document is HTML, this method
      # returns html.  If the document is XML, this method returns XML.
      def to_s
        document.xml? ? to_xml : to_html
      end

      # Get the inner_html for this node's Node#children
      def inner_html *args
        children.map { |x| x.to_html(*args) }.join
      end

      # Get the path to this node as a CSS expression
      def css_path
        path.split(/\//).map { |part|
          part.length == 0 ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
        }.compact.join(' > ')
      end

      ###
      # Get a list of ancestor Node for this Node.  If +selector+ is given,
      # the ancestors must match +selector+
      def ancestors selector = nil
        return NodeSet.new(document) unless respond_to?(:parent)
        return NodeSet.new(document) unless parent

        parents = [parent]

        while parents.last.respond_to?(:parent)
          break unless ctx_parent = parents.last.parent
          parents << ctx_parent
        end

        return NodeSet.new(document, parents) unless selector

        root = parents.last

        NodeSet.new(document, parents.find_all { |parent|
          root.search(selector).include?(parent)
        })
      end

      ###
      # Adds a default namespace supplied as a string +url+ href, to self.
      # The consequence is as an xmlns attribute with supplied argument were
      # present in parsed XML.  A default namespace set with this method will
      # now show up in #attributes, but when this node is serialized to XML an
      # "xmlns" attribute will appear. See also #namespace and #namespace=
      def default_namespace= url
        add_namespace_definition(nil, url)
      end
      alias :add_namespace :add_namespace_definition

      ###
      # Set the default namespace on this node (as would be defined with an
      # "xmlns=" attribute in XML source), as a Namespace object +ns+. Note that
      # a Namespace added this way will NOT be serialized as an xmlns attribute
      # for this node. You probably want #default_namespace= instead, or perhaps
      # #add_namespace_definition with a nil prefix argument.
      def namespace= ns
        return set_namespace(ns) unless ns

        unless Nokogiri::XML::Namespace === ns
          raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
        end
        if ns.document != document
          raise ArgumentError, 'namespace must be declared on the same document'
        end

        set_namespace ns
      end

      ####
      # Yields self and all children to +block+ recursively.
      def traverse &block
        children.each{|j| j.traverse(&block) }
        block.call(self)
      end

      ###
      # Accept a visitor.  This method calls "visit" on +visitor+ with self.
      def accept visitor
        visitor.visit(self)
      end

      ###
      # Test to see if this Node is equal to +other+
      def == other
        return false unless other
        return false unless other.respond_to?(:pointer_id)
        pointer_id == other.pointer_id
      end

      ###
      # Serialize Node using +options+.  Save options can also be set using a
      # block. See SaveOptions.
      #
      # These two statements are equivalent:
      #
      #  node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
      #
      # or
      #
      #   node.serialize(:encoding => 'UTF-8') do |config|
      #     config.format.as_xml
      #   end
      #
      def serialize *args, &block
        options = args.first.is_a?(Hash) ? args.shift : {
          :encoding   => args[0],
          :save_with  => args[1]
        }

        encoding = options[:encoding] || document.encoding
        options[:encoding] = encoding

        outstring = ""
        if encoding && outstring.respond_to?(:force_encoding)
          outstring.force_encoding(Encoding.find(encoding))
        end
        io = StringIO.new(outstring)
        write_to io, options, &block
        io.string
      end

      ###
      # Serialize this Node to HTML
      #
      #   doc.to_html
      #
      # See Node#write_to for a list of +options+.  For formatted output,
      # use Node#to_xhtml instead.
      def to_html options = {}
        to_format SaveOptions::DEFAULT_HTML, options
      end

      ###
      # Serialize this Node to XML using +options+
      #
      #   doc.to_xml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def to_xml options = {}
        options[:save_with] ||= SaveOptions::DEFAULT_XML
        serialize(options)
      end

      ###
      # Serialize this Node to XHTML using +options+
      #
      #   doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
      #
      # See Node#write_to for a list of +options+
      def to_xhtml options = {}
        to_format SaveOptions::DEFAULT_XHTML, options
      end

      ###
      # Write Node to +io+ with +options+. +options+ modify the output of
      # this method.  Valid options are:
      #
      # * +:encoding+ for changing the encoding
      # * +:indent_text+ the indentation text, defaults to one space
      # * +:indent+ the number of +:indent_text+ to use, defaults to 2
      # * +:save_with+ a combination of SaveOptions constants.
      #
      # To save with UTF-8 indented twice:
      #
      #   node.write_to(io, :encoding => 'UTF-8', :indent => 2)
      #
      # To save indented with two dashes:
      #
      #   node.write_to(io, :indent_text => '-', :indent => 2
      #
      def write_to io, *options
        options       = options.first.is_a?(Hash) ? options.shift : {}
        encoding      = options[:encoding] || options[0]
        if Nokogiri.jruby?
          save_options  = options[:save_with] || options[1]
          indent_times  = options[:indent] || 0
        else
          save_options  = options[:save_with] || options[1] || SaveOptions::FORMAT
          indent_times  = options[:indent] || 2
        end
        indent_text   = options[:indent_text] || ' '

        config = SaveOptions.new(save_options.to_i)
        yield config if block_given?

        native_write_to(io, encoding, indent_text * indent_times, config.options)
      end

      ###
      # Write Node as HTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def write_html_to io, options = {}
        write_format_to SaveOptions::DEFAULT_HTML, io, options
      end

      ###
      # Write Node as XHTML to +io+ with +options+
      #
      # See Node#write_to for a list of +options+
      def write_xhtml_to io, options = {}
        write_format_to SaveOptions::DEFAULT_XHTML, io, options
      end

      ###
      # Write Node as XML to +io+ with +options+
      #
      #   doc.write_xml_to io, :encoding => 'UTF-8'
      #
      # See Node#write_to for a list of options
      def write_xml_to io, options = {}
        options[:save_with] ||= SaveOptions::DEFAULT_XML
        write_to io, options
      end

      ###
      # Compare two Node objects with respect to their Document.  Nodes from
      # different documents cannot be compared.
      def <=> other
        return nil unless other.is_a?(Nokogiri::XML::Node)
        return nil unless document == other.document
        compare other
      end

      ###
      # Do xinclude substitution on the subtree below node. If given a block, a
      # Nokogiri::XML::ParseOptions object initialized from +options+, will be
      # passed to it, allowing more convenient modification of the parser options.
      def do_xinclude options = XML::ParseOptions::DEFAULT_XML, &block
        options = Nokogiri::XML::ParseOptions.new(options) if Fixnum === options

        # give options to user
        yield options if block_given?

        # call c extension
        process_xincludes(options.to_i)
      end

      def canonicalize(mode=XML::XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)
        c14n_root = self
        document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
          tn = node.is_a?(XML::Node) ? node : parent
          tn == c14n_root || tn.ancestors.include?(c14n_root)
        end
      end

      private

      def add_sibling next_or_previous, node_or_tags
        impl = (next_or_previous == :next) ? :add_next_sibling_node : :add_previous_sibling_node
        iter = (next_or_previous == :next) ? :reverse_each          : :each

        node_or_tags = coerce node_or_tags
        if node_or_tags.is_a?(XML::NodeSet)
          if text?
            pivot = Nokogiri::XML::Node.new 'dummy', document
            send impl, pivot
          else
            pivot = self
          end
          node_or_tags.send(iter) { |n| pivot.send impl, n }
          pivot.unlink if text?
        else
          send impl, node_or_tags
        end
        node_or_tags
      end

      def to_format save_option, options
        # FIXME: this is a hack around broken libxml versions
        return dump_html if Nokogiri.uses_libxml? && %w[2 6] === LIBXML_VERSION.split('.')[0..1]

        options[:save_with] |= save_option if options[:save_with]
        options[:save_with] = save_option unless options[:save_with]
        serialize(options)
      end

      def write_format_to save_option, io, options
        # FIXME: this is a hack around broken libxml versions
        return (io << dump_html) if Nokogiri.uses_libxml? && %w[2 6] === LIBXML_VERSION.split('.')[0..1]

        options[:save_with] ||= save_option
        write_to io, options
      end

      def extract_params params # :nodoc:
        # Pop off our custom function handler if it exists
        handler = params.find { |param|
          ![Hash, String, Symbol].include?(param.class)
        }

        params -= [handler] if handler

        hashes = []
        while Hash === params.last || params.last.nil?
          hashes << params.pop
          break if params.empty?
        end

        ns, binds = hashes.reverse

        ns ||= document.root ? document.root.namespaces : {}

        [params, handler, ns, binds]
      end

      def coerce data # :nodoc:
        return data                    if data.is_a?(XML::NodeSet)
        return data.children           if data.is_a?(XML::DocumentFragment)
        return fragment(data).children if data.is_a?(String)

        if data.is_a?(Document) || data.is_a?(XML::Attr) || !data.is_a?(XML::Node)
          raise ArgumentError, <<-EOERR
Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.
(You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)
          EOERR
        end

        data
      end

      def implied_xpath_context
        "./"
      end

      def inspect_attributes
        [:name, :namespace, :attribute_nodes, :children]
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node_set.rb                                                                                         0100644 0001750 0001750 00000022276 12566211316 044002  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ####
    # A NodeSet contains a list of Nokogiri::XML::Node objects.  Typically
    # a NodeSet is return as a result of searching a Document via
    # Nokogiri::XML::Node#css or Nokogiri::XML::Node#xpath
    class NodeSet
      include Enumerable

      # The Document this NodeSet is associated with
      attr_accessor :document

      # Create a NodeSet with +document+ defaulting to +list+
      def initialize document, list = []
        @document = document
        document.decorate(self)
        list.each { |x| self << x }
        yield self if block_given?
      end

      ###
      # Get the first element of the NodeSet.
      def first n = nil
        return self[0] unless n
        list = []
        0.upto(n - 1) do |i|
          list << self[i]
        end
        list
      end

      ###
      # Get the last element of the NodeSet.
      def last
        self[length - 1]
      end

      ###
      # Is this NodeSet empty?
      def empty?
        length == 0
      end

      ###
      # Returns the index of the first node in self that is == to +node+. Returns nil if no match is found.
      def index(node)
        each_with_index { |member, j| return j if member == node }
        nil
      end

      ###
      # Insert +datum+ before the first Node in this NodeSet
      def before datum
        first.before datum
      end

      ###
      # Insert +datum+ after the last Node in this NodeSet
      def after datum
        last.after datum
      end

      alias :<< :push
      alias :remove :unlink

      ###
      # Search this document for +paths+
      #
      # For more information see Nokogiri::XML::Node#css and
      # Nokogiri::XML::Node#xpath
      def search *paths
        handler = ![
          Hash, String, Symbol
        ].include?(paths.last.class) ? paths.pop : nil

        ns = paths.last.is_a?(Hash) ? paths.pop : nil

        sub_set = NodeSet.new(document)

        paths.each do |path|
          sub_set += send(
            path =~ /^(\.\/|\/|\.\.|\.$)/ ? :xpath : :css,
            *(paths + [ns, handler]).compact
          )
        end

        document.decorate(sub_set)
        sub_set
      end
      alias :/ :search

      ###
      # Search this NodeSet for css +paths+
      #
      # For more information see Nokogiri::XML::Node#css
      def css *paths
        handler = ![
          Hash, String, Symbol
        ].include?(paths.last.class) ? paths.pop : nil

        ns = paths.last.is_a?(Hash) ? paths.pop : nil

        sub_set = NodeSet.new(document)

        each do |node|
          doc = node.document
          search_ns = ns || (doc.root ? doc.root.namespaces : {})

          xpaths = paths.map { |rule|
            [
              CSS.xpath_for(rule.to_s, :prefix => ".//", :ns => search_ns),
              CSS.xpath_for(rule.to_s, :prefix => "self::", :ns => search_ns)
            ].join(' | ')
          }

          sub_set += node.xpath(*(xpaths + [search_ns, handler].compact))
        end
        document.decorate(sub_set)
        sub_set
      end

      ###
      # Search this NodeSet for XPath +paths+
      #
      # For more information see Nokogiri::XML::Node#xpath
      def xpath *paths
        handler = ![
          Hash, String, Symbol
        ].include?(paths.last.class) ? paths.pop : nil

        ns = paths.last.is_a?(Hash) ? paths.pop : nil

        sub_set = NodeSet.new(document)
        each do |node|
          sub_set += node.xpath(*(paths + [ns, handler].compact))
        end
        document.decorate(sub_set)
        sub_set
      end

      ###
      # Search this NodeSet's nodes' immediate children using CSS selector +selector+
      def > selector
        ns = document.root.namespaces
        xpath CSS.xpath_for(selector, :prefix => "./", :ns => ns).first
      end

      ###
      # If path is a string, search this document for +path+ returning the
      # first Node.  Otherwise, index in to the array with +path+.
      def at path, ns = document.root ? document.root.namespaces : {}
        return self[path] if path.is_a?(Numeric)
        search(path, ns).first
      end
      alias :% :at

      ##
      # Search this NodeSet for the first occurrence of XPath +paths+.
      # Equivalent to <tt>xpath(paths).first</tt>
      # See NodeSet#xpath for more information.
      #
      def at_xpath *paths
        xpath(*paths).first
      end

      ##
      # Search this NodeSet for the first occurrence of CSS +rules+.
      # Equivalent to <tt>css(rules).first</tt>
      # See NodeSet#css for more information.
      #
      def at_css *rules
        css(*rules).first
      end

      ###
      # Filter this list for nodes that match +expr+
      def filter expr
        find_all { |node| node.matches?(expr) }
      end

      ###
      # Append the class attribute +name+ to all Node objects in the NodeSet.
      def add_class name
        each do |el|
          classes = el['class'].to_s.split(/\s+/)
          el['class'] = classes.push(name).uniq.join " "
        end
        self
      end

      ###
      # Remove the class attribute +name+ from all Node objects in the NodeSet.
      # If +name+ is nil, remove the class attribute from all Nodes in the
      # NodeSet.
      def remove_class name = nil
        each do |el|
          if name
            classes = el['class'].to_s.split(/\s+/)
            if classes.empty?
              el.delete 'class'
            else
              el['class'] = (classes - [name]).uniq.join " "
            end
          else
            el.delete "class"
          end
        end
        self
      end

      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+
      # on all Node objects in the NodeSet.
      def attr key, value = nil, &blk
        unless Hash === key || key && (value || blk)
          return first.attribute(key)
        end

        hash = key.is_a?(Hash) ? key : { key => value }

        hash.each { |k,v| each { |el| el[k] = v || blk[el] } }

        self
      end
      alias :set :attr
      alias :attribute :attr

      ###
      # Remove the attributed named +name+ from all Node objects in the NodeSet
      def remove_attr name
        each { |el| el.delete name }
        self
      end

      ###
      # Iterate over each node, yielding  to +block+
      def each(&block)
        0.upto(length - 1) do |x|
          yield self[x]
        end
      end

      ###
      # Get the inner text of all contained Node objects
      def inner_text
        collect{|j| j.inner_text}.join('')
      end
      alias :text :inner_text

      ###
      # Get the inner html of all contained Node objects
      def inner_html *args
        collect{|j| j.inner_html(*args) }.join('')
      end

      ###
      # Wrap this NodeSet with +html+ or the results of the builder in +blk+
      def wrap(html, &blk)
        each do |j|
          new_parent = document.parse(html).first
          j.add_next_sibling(new_parent)
          new_parent.add_child(j)
        end
        self
      end

      ###
      # Convert this NodeSet to a string.
      def to_s
        map { |x| x.to_s }.join
      end

      ###
      # Convert this NodeSet to HTML
      def to_html *args
        if Nokogiri.jruby?
          options = args.first.is_a?(Hash) ? args.shift : {}
          if !options[:save_with]
            options[:save_with] = Node::SaveOptions::NO_DECLARATION | Node::SaveOptions::NO_EMPTY_TAGS | Node::SaveOptions::AS_HTML
          end
          args.insert(0, options)
        end
        map { |x| x.to_html(*args) }.join
      end

      ###
      # Convert this NodeSet to XHTML
      def to_xhtml *args
        map { |x| x.to_xhtml(*args) }.join
      end

      ###
      # Convert this NodeSet to XML
      def to_xml *args
        map { |x| x.to_xml(*args) }.join
      end

      alias :size :length
      alias :to_ary :to_a

      ###
      # Removes the last element from set and returns it, or +nil+ if
      # the set is empty
      def pop
        return nil if length == 0
        delete last
      end

      ###
      # Returns the first element of the NodeSet and removes it.  Returns
      # +nil+ if the set is empty.
      def shift
        return nil if length == 0
        delete first
      end

      ###
      # Equality -- Two NodeSets are equal if the contain the same number
      # of elements and if each element is equal to the corresponding
      # element in the other NodeSet
      def == other
        return false unless other.is_a?(Nokogiri::XML::NodeSet)
        return false unless length == other.length
        each_with_index do |node, i|
          return false unless node == other[i]
        end
        true
      end

      ###
      # Returns a new NodeSet containing all the children of all the nodes in
      # the NodeSet
      def children
        inject(NodeSet.new(document)) { |set, node| set += node.children }
      end

      ###
      # Returns a new NodeSet containing all the nodes in the NodeSet
      # in reverse order
      def reverse
        node_set = NodeSet.new(document)
        (length - 1).downto(0) do |x|
          node_set.push self[x]
        end
        node_set
      end

      ###
      # Return a nicely formated string representation
      def inspect
        "[#{map { |c| c.inspect }.join ', '}]"
      end

      alias :+ :|
    end
  end
end
                                                                                                                                                                                                                                                                                                                                  notation.rb                                                                                         0100644 0001750 0001750 00000000156 12566211316 044026  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class Notation < Struct.new(:name, :public_id, :system_id)
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                  parse_options.rb                                                                                    0100644 0001750 0001750 00000005300 12566211316 045054  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # Parse options for passing to Nokogiri.XML or Nokogiri.HTML
    class ParseOptions
      # Strict parsing
      STRICT      = 0
      # Recover from errors
      RECOVER     = 1 << 0
      # Substitute entities
      NOENT       = 1 << 1
      # Load external subsets
      DTDLOAD     = 1 << 2
      # Default DTD attributes
      DTDATTR     = 1 << 3
      # validate with the DTD
      DTDVALID    = 1 << 4
      # suppress error reports
      NOERROR     = 1 << 5
      # suppress warning reports
      NOWARNING   = 1 << 6
      # pedantic error reporting
      PEDANTIC    = 1 << 7
      # remove blank nodes
      NOBLANKS    = 1 << 8
      # use the SAX1 interface internally
      SAX1        = 1 << 9
      # Implement XInclude substitution
      XINCLUDE    = 1 << 10
      # Forbid network access. Recommended for dealing with untrusted documents.
      NONET       = 1 << 11
      # Do not reuse the context dictionary
      NODICT      = 1 << 12
      # remove redundant namespaces declarations
      NSCLEAN     = 1 << 13
      # merge CDATA as text nodes
      NOCDATA     = 1 << 14
      # do not generate XINCLUDE START/END nodes
      NOXINCNODE  = 1 << 15
      # compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)
      COMPACT     = 1 << 16
      # parse using XML-1.0 before update 5
      OLD10       = 1 << 17
      # do not fixup XINCLUDE xml:base uris
      NOBASEFIX   = 1 << 18
      # relax any hardcoded limit from the parser
      HUGE        = 1 << 19

      # the default options used for parsing XML documents
      DEFAULT_XML  = RECOVER | NONET
      # the default options used for parsing HTML documents
      DEFAULT_HTML = RECOVER | NOERROR | NOWARNING | NONET

      attr_accessor :options
      def initialize options = STRICT
        @options = options
      end

      constants.each do |constant|
        next if constant.to_sym == :STRICT
        class_eval %{
          def #{constant.downcase}
            @options |= #{constant}
            self
          end

          def no#{constant.downcase}
            @options &= ~#{constant}
            self
          end

          def #{constant.downcase}?
            #{constant} & @options == #{constant}
          end
        }
      end

      def strict
        @options &= ~RECOVER
        self
      end

      def strict?
        @options & RECOVER == STRICT
      end

      alias :to_i :options

      def inspect
        options = []
        self.class.constants.each do |k|
          options << k.downcase if send(:"#{k.downcase}?")
        end
        super.sub(/>$/, " " + options.join(', ') + ">")
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                pp/                                                                                                 0040755 0001750 0001750 00000000000 12612224746 042271  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 character_data.rb                                                                                   0100644 0001750 0001750 00000000633 12566211316 045537  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/pp              module Nokogiri
  module XML
    module PP
      module CharacterData
        def pretty_print pp # :nodoc:
          nice_name = self.class.name.split('::').last
          pp.group(2, "#(#{nice_name} ", ')') do
            pp.pp text
          end
        end

        def inspect # :nodoc:
          "#<#{self.class.name}:#{sprintf("0x%x",object_id)} #{text.inspect}>"
        end
      end
    end
  end
end
                                                                                                     node.rb                                                                                             0100644 0001750 0001750 00000003156 12566211316 043542  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/pp              module Nokogiri
  module XML
    module PP
      module Node
        def inspect # :nodoc:
          attributes = inspect_attributes.reject { |x|
            begin
              attribute = send x
              !attribute || (attribute.respond_to?(:empty?) && attribute.empty?)
            rescue NoMethodError
              true
            end
          }.map { |attribute|
            "#{attribute.to_s.sub(/_\w+/, 's')}=#{send(attribute).inspect}"
          }.join ' '
          "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{attributes}>"
        end

        def pretty_print pp # :nodoc:
          nice_name = self.class.name.split('::').last
          pp.group(2, "#(#{nice_name}:#{sprintf("0x%x", object_id)} {", '})') do

            pp.breakable
            attrs = inspect_attributes.map { |t|
              [t, send(t)] if respond_to?(t)
            }.compact.find_all { |x|
              if x.last
                if [:attribute_nodes, :children].include? x.first
                  !x.last.empty?
                else
                  true
                end
              end
            }

            pp.seplist(attrs) do |v|
              if [:attribute_nodes, :children].include? v.first
                pp.group(2, "#{v.first.to_s.sub(/_\w+$/, 's')} = [", "]") do
                  pp.breakable
                  pp.seplist(v.last) do |item|
                    pp.pp item
                  end
                end
              else
                pp.text "#{v.first} = "
                pp.pp v.last
              end
            end
            pp.breakable

          end
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                  pp.rb                                                                                               0100644 0001750 0001750 00000000110 12566211316 042600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 require 'nokogiri/xml/pp/node'
require 'nokogiri/xml/pp/character_data'
                                                                                                                                                                                                                                                                                                                                                                                                                                                        processing_instruction.rb                                                                           0100644 0001750 0001750 00000000215 12566211316 047004  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class ProcessingInstruction < Node
      def initialize document, name, content
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                   reader.rb                                                                                           0100644 0001750 0001750 00000005776 12566211316 043452  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # Nokogiri::XML::Reader parses an XML document similar to the way a cursor
    # would move.  The Reader is given an XML document, and yields nodes
    # to an each block.
    #
    # Here is an example of usage:
    #
    #   reader = Nokogiri::XML::Reader(<<-eoxml)
    #     <x xmlns:tenderlove='http://tenderlovemaking.com/'>
    #       <tenderlove:foo awesome='true'>snuggles!</tenderlove:foo>
    #     </x>
    #   eoxml
    #
    #   reader.each do |node|
    #
    #     # node is an instance of Nokogiri::XML::Reader
    #     puts node.name
    #
    #   end
    #
    # Note that Nokogiri::XML::Reader#each can only be called once!!  Once
    # the cursor moves through the entire document, you must parse the
    # document again.  So make sure that you capture any information you
    # need during the first iteration.
    #
    # The Reader parser is good for when you need the speed of a SAX parser,
    # but do not want to write a Document handler.
    class Reader
      include Enumerable

      TYPE_NONE = 0
      # Element node type
      TYPE_ELEMENT = 1
      # Attribute node type
      TYPE_ATTRIBUTE = 2
      # Text node type
      TYPE_TEXT = 3
      # CDATA node type
      TYPE_CDATA = 4
      # Entity Reference node type
      TYPE_ENTITY_REFERENCE = 5
      # Entity node type
      TYPE_ENTITY = 6
      # PI node type
      TYPE_PROCESSING_INSTRUCTION = 7
      # Comment node type
      TYPE_COMMENT = 8
      # Document node type
      TYPE_DOCUMENT = 9
      # Document Type node type
      TYPE_DOCUMENT_TYPE = 10
      # Document Fragment node type
      TYPE_DOCUMENT_FRAGMENT = 11
      # Notation node type
      TYPE_NOTATION = 12
      # Whitespace node type
      TYPE_WHITESPACE = 13
      # Significant Whitespace node type
      TYPE_SIGNIFICANT_WHITESPACE = 14
      # Element end node type
      TYPE_END_ELEMENT = 15
      # Entity end node type
      TYPE_END_ENTITY = 16
      # XML Declaration node type
      TYPE_XML_DECLARATION = 17

      # A list of errors encountered while parsing
      attr_accessor :errors

      # The encoding for the document
      attr_reader :encoding

      # The XML source
      attr_reader :source

      alias :self_closing? :empty_element?

      def initialize source, url = nil, encoding = nil # :nodoc:
        @source   = source
        @errors   = []
        @encoding = encoding
      end
      private :initialize

      ###
      # Get a list of attributes for the current node.
      def attributes
        Hash[attribute_nodes.map { |node|
          [node.name, node.to_s]
        }].merge(namespaces || {})
      end

      ###
      # Get a list of attributes for the current node
      def attribute_nodes
        nodes = attr_nodes
        nodes.each { |v| v.instance_variable_set(:@_r, self) }
        nodes
      end

      ###
      # Move the cursor through the document yielding the cursor to the block
      def each
        while cursor = self.read
          yield cursor
        end
      end
    end
  end
end
  relax_ng.rb                                                                                         0100644 0001750 0001750 00000001556 12566211316 043777  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class << self
      ###
      # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.
      # See Nokogiri::XML::RelaxNG for an example.
      def RelaxNG string_or_io
        RelaxNG.new(string_or_io)
      end
    end

    ###
    # Nokogiri::XML::RelaxNG is used for validating XML against a
    # RelaxNG schema.
    #
    # == Synopsis
    #
    # Validate an XML document against a RelaxNG schema.  Loop over the errors
    # that are returned and print them out:
    #
    #   schema  = Nokogiri::XML::RelaxNG(File.open(ADDRESS_SCHEMA_FILE))
    #   doc     = Nokogiri::XML(File.open(ADDRESS_XML_FILE))
    #
    #   schema.validate(doc).each do |error|
    #     puts error.message
    #   end
    #
    # The list of errors are Nokogiri::XML::SyntaxError objects.
    class RelaxNG < Nokogiri::XML::Schema
    end
  end
end
                                                                                                                                                  sax/                                                                                                0040755 0001750 0001750 00000000000 12612224746 042445  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 document.rb                                                                                         0100644 0001750 0001750 00000013412 12566211316 044603  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/sax             module Nokogiri
  module XML
    ###
    # SAX Parsers are event driven parsers.  Nokogiri provides two different
    # event based parsers when dealing with XML.  If you want to do SAX style
    # parsing using HTML, check out Nokogiri::HTML::SAX.
    #
    # The basic way a SAX style parser works is by creating a parser,
    # telling the parser about the events we're interested in, then giving
    # the parser some XML to process.  The parser will notify you when
    # it encounters events your said you would like to know about.
    #
    # To register for events, you simply subclass Nokogiri::XML::SAX::Document,
    # and implement the methods for which you would like notification.
    #
    # For example, if I want to be notified when a document ends, and when an
    # element starts, I would write a class like this:
    #
    #   class MyDocument < Nokogiri::XML::SAX::Document
    #     def end_document
    #       puts "the document has ended"
    #     end
    #
    #     def start_element name, attributes = []
    #       puts "#{name} started"
    #     end
    #   end
    #
    # Then I would instantiate a SAX parser with this document, and feed the
    # parser some XML
    #
    #   # Create a new parser
    #   parser = Nokogiri::XML::SAX::Parser.new(MyDocument.new)
    #
    #   # Feed the parser some XML
    #   parser.parse(File.open(ARGV[0]))
    #
    # Now my document handler will be called when each node starts, and when
    # then document ends.  To see what kinds of events are available, take
    # a look at Nokogiri::XML::SAX::Document.
    #
    # Two SAX parsers for XML are available, a parser that reads from a string
    # or IO object as it feels necessary, and a parser that lets you spoon
    # feed it XML.  If you want to let Nokogiri deal with reading your XML,
    # use the Nokogiri::XML::SAX::Parser.  If you want to have fine grain
    # control over the XML input, use the Nokogiri::XML::SAX::PushParser.
    module SAX
      ###
      # This class is used for registering types of events you are interested
      # in handling.  All of the methods on this class are available as
      # possible events while parsing an XML document.  To register for any
      # particular event, just subclass this class and implement the methods
      # you are interested in knowing about.
      #
      # To only be notified about start and end element events, write a class
      # like this:
      #
      #   class MyDocument < Nokogiri::XML::SAX::Document
      #     def start_element name, attrs = []
      #       puts "#{name} started!"
      #     end
      #
      #     def end_element name
      #       puts "#{name} ended"
      #     end
      #   end
      #
      # You can use this event handler for any SAX style parser included with
      # Nokogiri.  See Nokogiri::XML::SAX, and Nokogiri::HTML::SAX.
      class Document
        ###
        # Called when an XML declaration is parsed
        def xmldecl version, encoding, standalone
        end

        ###
        # Called when document starts parsing
        def start_document
        end

        ###
        # Called when document ends parsing
        def end_document
        end

        ###
        # Called at the beginning of an element
        # * +name+ is the name of the tag
        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def start_element name, attrs = []
        end

        ###
        # Called at the end of an element
        # +name+ is the tag name
        def end_element name
        end

        ###
        # Called at the beginning of an element
        # +name+ is the element name
        # +attrs+ is a list of attributes
        # +prefix+ is the namespace prefix for the element
        # +uri+ is the associated namespace URI
        # +ns+ is a hash of namespace prefix:urls associated with the element
        def start_element_namespace name, attrs = [], prefix = nil, uri = nil, ns = []
          ###
          # Deal with SAX v1 interface
          name = [prefix, name].compact.join(':')
          attributes = ns.map { |ns_prefix,ns_uri|
            [['xmlns', ns_prefix].compact.join(':'), ns_uri]
          } + attrs.map { |attr|
            [[attr.prefix, attr.localname].compact.join(':'), attr.value]
          }
          start_element name, attributes
        end

        ###
        # Called at the end of an element
        # +name+ is the element's name
        # +prefix+ is the namespace prefix associated with the element
        # +uri+ is the associated namespace URI
        def end_element_namespace name, prefix = nil, uri = nil
          ###
          # Deal with SAX v1 interface
          end_element [prefix, name].compact.join(':')
        end

        ###
        # Characters read between a tag.  This method might be called multiple
        # times given one contiguous string of characters.
        #
        # +string+ contains the character data
        def characters string
        end

        ###
        # Called when comments are encountered
        # +string+ contains the comment data
        def comment string
        end

        ###
        # Called on document warnings
        # +string+ contains the warning
        def warning string
        end

        ###
        # Called on document errors
        # +string+ contains the error
        def error string
        end

        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def cdata_block string
        end

        ###
        # Called when processing instructions are found
        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def processing_instruction name, content
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                      parser.rb                                                                                           0100644 0001750 0001750 00000010064 12566211316 044261  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/sax             module Nokogiri
  module XML
    module SAX
      ###
      # This parser is a SAX style parser that reads it's input as it
      # deems necessary.  The parser takes a Nokogiri::XML::SAX::Document,
      # an optional encoding, then given an XML input, sends messages to
      # the Nokogiri::XML::SAX::Document.
      #
      # Here is an example of using this parser:
      #
      #   # Create a subclass of Nokogiri::XML::SAX::Document and implement
      #   # the events we care about:
      #   class MyDoc < Nokogiri::XML::SAX::Document
      #     def start_element name, attrs = []
      #       puts "starting: #{name}"
      #     end
      #
      #     def end_element name
      #       puts "ending: #{name}"
      #     end
      #   end
      #
      #   # Create our parser
      #   parser = Nokogiri::XML::SAX::Parser.new(MyDoc.new)
      #
      #   # Send some XML to the parser
      #   parser.parse(File.open(ARGV[0]))
      #
      # For more information about SAX parsers, see Nokogiri::XML::SAX.  Also
      # see Nokogiri::XML::SAX::Document for the available events.
      class Parser
        class Attribute < Struct.new(:localname, :prefix, :uri, :value)
        end

        # Encodinds this parser supports
        ENCODINGS = {
          'NONE'        => 0, # No char encoding detected
          'UTF-8'       => 1, # UTF-8
          'UTF16LE'     => 2, # UTF-16 little endian
          'UTF16BE'     => 3, # UTF-16 big endian
          'UCS4LE'      => 4, # UCS-4 little endian
          'UCS4BE'      => 5, # UCS-4 big endian
          'EBCDIC'      => 6, # EBCDIC uh!
          'UCS4-2143'   => 7, # UCS-4 unusual ordering
          'UCS4-3412'   => 8, # UCS-4 unusual ordering
          'UCS2'        => 9, # UCS-2
          'ISO-8859-1'  => 10, # ISO-8859-1 ISO Latin 1
          'ISO-8859-2'  => 11, # ISO-8859-2 ISO Latin 2
          'ISO-8859-3'  => 12, # ISO-8859-3
          'ISO-8859-4'  => 13, # ISO-8859-4
          'ISO-8859-5'  => 14, # ISO-8859-5
          'ISO-8859-6'  => 15, # ISO-8859-6
          'ISO-8859-7'  => 16, # ISO-8859-7
          'ISO-8859-8'  => 17, # ISO-8859-8
          'ISO-8859-9'  => 18, # ISO-8859-9
          'ISO-2022-JP' => 19, # ISO-2022-JP
          'SHIFT-JIS'   => 20, # Shift_JIS
          'EUC-JP'      => 21, # EUC-JP
          'ASCII'       => 22, # pure ASCII
        }

        # The Nokogiri::XML::SAX::Document where events will be sent.
        attr_accessor :document

        # The encoding beings used for this document.
        attr_accessor :encoding

        # Create a new Parser with +doc+ and +encoding+
        def initialize doc = Nokogiri::XML::SAX::Document.new, encoding = 'UTF-8'
          check_encoding(encoding)
          @encoding = encoding
          @document = doc
          @warned   = false
        end

        ###
        # Parse given +thing+ which may be a string containing xml, or an
        # IO object.
        def parse thing, &block
          if thing.respond_to?(:read) && thing.respond_to?(:close)
            parse_io(thing, &block)
          else
            parse_memory(thing, &block)
          end
        end

        ###
        # Parse given +io+
        def parse_io io, encoding = 'ASCII'
          check_encoding(encoding)
          @encoding = encoding
          ctx = ParserContext.io(io, ENCODINGS[encoding])
          yield ctx if block_given?
          ctx.parse_with self
        end

        ###
        # Parse a file with +filename+
        def parse_file filename
          raise ArgumentError unless filename
          raise Errno::ENOENT unless File.exists?(filename)
          raise Errno::EISDIR if File.directory?(filename)
          ctx = ParserContext.file filename
          yield ctx if block_given?
          ctx.parse_with self
        end

        def parse_memory data
          ctx = ParserContext.memory data
          yield ctx if block_given?
          ctx.parse_with self
        end

        private
        def check_encoding(encoding)
          raise ArgumentError.new("'#{encoding}' is not a valid encoding") unless ENCODINGS[encoding]
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            parser_context.rb                                                                                   0100644 0001750 0001750 00000000720 12566211316 046023  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/sax             module Nokogiri
  module XML
    module SAX
      ###
      # Context for XML SAX parsers.  This class is usually not instantiated
      # by the user.  Instead, you should be looking at
      # Nokogiri::XML::SAX::Parser
      class ParserContext
        def self.new thing, encoding = 'UTF-8'
          [:read, :close].all? { |x| thing.respond_to?(x) } ?
            io(thing, Parser::ENCODINGS[encoding]) : memory(thing)
        end
      end
    end
  end
end
                                                push_parser.rb                                                                                      0100644 0001750 0001750 00000003511 12566211316 045317  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml/sax             module Nokogiri
  module XML
    module SAX
      ###
      # PushParser can parse a document that is fed to it manually.  It
      # must be given a SAX::Document object which will be called with
      # SAX events as the document is being parsed.
      #
      # Calling PushParser#<< writes XML to the parser, calling any SAX
      # callbacks it can.
      #
      # PushParser#finish tells the parser that the document is finished
      # and calls the end_document SAX method.
      #
      # Example:
      #
      #   parser = PushParser.new(Class.new(XML::SAX::Document) {
      #     def start_document
      #       puts "start document called"
      #     end
      #   }.new)
      #   parser << "<div>hello<"
      #   parser << "/div>"
      #   parser.finish
      class PushParser

        # The Nokogiri::XML::SAX::Document on which the PushParser will be
        # operating
        attr_accessor :document

        ###
        # Create a new PushParser with +doc+ as the SAX Document, providing
        # an optional +file_name+ and +encoding+
        def initialize(doc = XML::SAX::Document.new, file_name = nil, encoding = 'UTF-8')
          @document = doc
          @encoding = encoding
          @sax_parser = XML::SAX::Parser.new(doc)

          ## Create our push parser context
          initialize_native(@sax_parser, file_name)
        end

        ###
        # Write a +chunk+ of XML to the PushParser.  Any callback methods
        # that can be called will be called immediately.
        def write chunk, last_chunk = false
          native_write(chunk, last_chunk)
        end
        alias :<< :write

        ###
        # Finish the parsing.  This method is only necessary for
        # Nokogiri::XML::SAX::Document#end_document to be called.
        def finish
          write '', true
        end
      end
    end
  end
end
                                                                                                                                                                                       sax.rb                                                                                              0100644 0001750 0001750 00000000227 12566211316 042765  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 require 'nokogiri/xml/sax/document'
require 'nokogiri/xml/sax/parser_context'
require 'nokogiri/xml/sax/parser'
require 'nokogiri/xml/sax/push_parser'
                                                                                                                                                                                                                                                                                                                                                                         schema.rb                                                                                           0100644 0001750 0001750 00000003370 12566211316 043434  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class << self
      ###
      # Create a new Nokogiri::XML::Schema object using a +string_or_io+
      # object.
      def Schema string_or_io
        Schema.new(string_or_io)
      end
    end

    ###
    # Nokogiri::XML::Schema is used for validating XML against a schema
    # (usually from an xsd file).
    #
    # == Synopsis
    #
    # Validate an XML document against a Schema.  Loop over the errors that
    # are returned and print them out:
    #
    #   xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))
    #   doc = Nokogiri::XML(File.read(PO_XML_FILE))
    #
    #   xsd.validate(doc).each do |error|
    #     puts error.message
    #   end
    #
    # The list of errors are Nokogiri::XML::SyntaxError objects.
    class Schema
      # Errors while parsing the schema file
      attr_accessor :errors

      ###
      # Create a new Nokogiri::XML::Schema object using a +string_or_io+
      # object.
      def self.new string_or_io
        from_document Nokogiri::XML(string_or_io)
      end

      ###
      # Validate +thing+ against this schema.  +thing+ can be a
      # Nokogiri::XML::Document object, or a filename.  An Array of
      # Nokogiri::XML::SyntaxError objects found while validating the
      # +thing+ is returned.
      def validate thing
        if thing.is_a?(Nokogiri::XML::Document) 
          validate_document(thing) 
        elsif File.file?(thing)
          validate_file(thing)
        else
          raise ArgumentError, "Must provide Nokogiri::Xml::Document or the name of an existing file"
        end
      end

      ###
      # Returns true if +thing+ is a valid Nokogiri::XML::Document or
      # file.
      def valid? thing
        validate(thing).length == 0
      end
    end
  end
end
                                                                                                                                                                                                                                                                        syntax_error.rb                                                                                     0100644 0001750 0001750 00000001644 12566211316 044735  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    ###
    # This class provides information about XML SyntaxErrors.  These
    # exceptions are typically stored on Nokogiri::XML::Document#errors.
    class SyntaxError < ::Nokogiri::SyntaxError
      attr_reader :domain
      attr_reader :code
      attr_reader :level
      attr_reader :file
      attr_reader :line
      attr_reader :str1
      attr_reader :str2
      attr_reader :str3
      attr_reader :int1
      attr_reader :column

      ###
      # return true if this is a non error
      def none?
        level == 0
      end

      ###
      # return true if this is a warning
      def warning?
        level == 1
      end

      ###
      # return true if this is an error
      def error?
        level == 2
      end

      ###
      # return true if this error is fatal
      def fatal?
        level == 3
      end

      def to_s
        super.chomp
      end
    end
  end
end
                                                                                            text.rb                                                                                             0100644 0001750 0001750 00000000254 12566211316 043156  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class Text < Nokogiri::XML::CharacterData
      def content=(string)
        self.native_content = string.to_s
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                    xpath/                                                                                              0040755 0001750 0001750 00000000000 12612224746 042776  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 xpath/syntax_error.rb                                                                               0100644 0001750 0001750 00000000302 12566211316 046047  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class XPath
      class SyntaxError < XML::SyntaxError
        def to_s
          [super.chomp, str1].compact.join(': ')
        end
      end
    end
  end
end
                                                                                                                                                                                                                                                                                                                              xpath.rb                                                                                            0100644 0001750 0001750 00000000310 12566211316 043307  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 require 'nokogiri/xml/xpath/syntax_error'

module Nokogiri
  module XML
    class XPath
      # The Nokogiri::XML::Document tied to this XPath instance
      attr_accessor :document
    end
  end
end
                                                                                                                                                                                                                                                                                                                        xpath_context.rb                                                                                    0100644 0001750 0001750 00000000477 12566211316 045071  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xml                 module Nokogiri
  module XML
    class XPathContext

      ###
      # Register namespaces in +namespaces+
      def register_namespaces(namespaces)
        namespaces.each do |k, v|
          k = k.to_s.gsub(/.*:/,'') # strip off 'xmlns:' or 'xml:'
          register_ns(k, v)
        end
      end

    end
  end
end
                                                                                                                                                                                                 xml.rb                                                                                              0100644 0001750 0001750 00000004544 12566211316 042200  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     require 'nokogiri/xml/pp'
require 'nokogiri/xml/parse_options'
require 'nokogiri/xml/sax'
require 'nokogiri/xml/node'
require 'nokogiri/xml/attribute_decl'
require 'nokogiri/xml/element_decl'
require 'nokogiri/xml/element_content'
require 'nokogiri/xml/character_data'
require 'nokogiri/xml/namespace'
require 'nokogiri/xml/attr'
require 'nokogiri/xml/dtd'
require 'nokogiri/xml/cdata'
require 'nokogiri/xml/text'
require 'nokogiri/xml/document'
require 'nokogiri/xml/document_fragment'
require 'nokogiri/xml/processing_instruction'
require 'nokogiri/xml/node_set'
require 'nokogiri/xml/syntax_error'
require 'nokogiri/xml/xpath'
require 'nokogiri/xml/xpath_context'
require 'nokogiri/xml/builder'
require 'nokogiri/xml/reader'
require 'nokogiri/xml/notation'
require 'nokogiri/xml/entity_decl'
require 'nokogiri/xml/schema'
require 'nokogiri/xml/relax_ng'

module Nokogiri
  class << self
    ###
    # Parse XML.  Convenience method for Nokogiri::XML::Document.parse
    def XML thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_XML, &block
      Nokogiri::XML::Document.parse(thing, url, encoding, options, &block)
    end
  end

  module XML
    # Original C14N 1.0 spec canonicalization
    XML_C14N_1_0 =       0
    # Exclusive C14N 1.0 spec canonicalization
    XML_C14N_EXCLUSIVE_1_0 =     1
    # C14N 1.1 spec canonicalization
    XML_C14N_1_1 = 2
    class << self
      ###
      # Parse an XML document using the Nokogiri::XML::Reader API.  See
      # Nokogiri::XML::Reader for mor information
      def Reader string_or_io, url = nil, encoding = nil, options = ParseOptions::STRICT

        options = Nokogiri::XML::ParseOptions.new(options) if Fixnum === options
        # Give the options to the user
        yield options if block_given?

        if string_or_io.respond_to? :read
          return Reader.from_io(string_or_io, url, encoding, options.to_i)
        end
        Reader.from_memory(string_or_io, url, encoding, options.to_i)
      end

      ###
      # Parse XML.  Convenience method for Nokogiri::XML::Document.parse
      def parse thing, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block
        Document.parse(thing, url, encoding, options, &block)
      end

      ####
      # Parse a fragment from +string+ in to a NodeSet.
      def fragment string
        XML::DocumentFragment.parse(string)
      end
    end
  end
end
                                                                                                                                                            xslt/                                                                                               0040755 0001750 0001750 00000000000 12612224746 042044  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     stylesheet.rb                                                                                       0100644 0001750 0001750 00000001437 12566211316 044561  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri/xslt                module Nokogiri
  module XSLT
    ###
    # A Stylesheet represents an XSLT Stylesheet object.  Stylesheet creation
    # is done through Nokogiri.XSLT.  Here is an example of transforming
    # an XML::Document with a Stylesheet:
    #
    #   doc   = Nokogiri::XML(File.read('some_file.xml'))
    #   xslt  = Nokogiri::XSLT(File.read('some_transformer.xslt'))
    #
    #   puts xslt.transform(doc)
    #
    # See Nokogiri::XSLT::Stylesheet#transform for more transformation
    # information.
    class Stylesheet
      ###
      # Apply an XSLT stylesheet to an XML::Document.
      # +params+ is an array of strings used as XSLT parameters.
      # returns serialized document
      def apply_to document, params = []
        serialize(transform(document, params))
      end
    end
  end
end
                                                                                                                                                                                                                                 xslt.rb                                                                                             0100644 0001750 0001750 00000002524 12566211316 042366  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/nokogiri                     require 'nokogiri/xslt/stylesheet'

module Nokogiri
  class << self
    ###
    # Create a Nokogiri::XSLT::Stylesheet with +stylesheet+.
    #
    # Example:
    #
    #   xslt = Nokogiri::XSLT(File.read(ARGV[0]))
    #
    def XSLT stylesheet, modules = {}
      XSLT.parse(stylesheet, modules)
    end
  end

  ###
  # See Nokogiri::XSLT::Stylesheet for creating and manipulating
  # Stylesheet object.
  module XSLT
    class << self
      ###
      # Parse the stylesheet in +string+, register any +modules+
      def parse string, modules = {}
        modules.each do |url, klass|
          XSLT.register url, klass
        end

        if Nokogiri.jruby?
          Stylesheet.parse_stylesheet_doc(XML.parse(string), string)
        else
          Stylesheet.parse_stylesheet_doc(XML.parse(string))
        end
      end

      ###
      # Quote parameters in +params+ for stylesheet safety
      def quote_params params
        parray = (params.instance_of?(Hash) ? params.to_a.flatten : params).dup
        parray.each_with_index do |v,i|
          if i % 2 > 0
            parray[i]=
              if v =~ /'/
                "concat('#{ v.gsub(/'/, %q{', "'", '}) }')"
              else
                "'#{v}'";
              end
          else
            parray[i] = v.to_s
          end
        end
        parray.flatten
      end
    end
  end
end
                                                                                                                                                                            nokogiri.rb                                                                                         0100644 0001750 0001750 00000007445 12566211316 041403  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib                              # -*- coding: utf-8 -*-
# Modify the PATH on windows so that the external DLLs will get loaded.

require 'rbconfig'
ENV['PATH'] = [File.expand_path(
  File.join(File.dirname(__FILE__), "..", "ext", "nokogiri")
), ENV['PATH']].compact.join(';') if RbConfig::CONFIG['host_os'] =~ /(mswin|mingw)/i

if defined?(RUBY_ENGINE) && RUBY_ENGINE == "jruby"
  # The line below caused a problem on non-GAE rack environment.
  # unless defined?(JRuby::Rack::VERSION) || defined?(AppEngine::ApiProxy)
  #
  # However, simply cutting defined?(JRuby::Rack::VERSION) off resulted in
  # an unable-to-load-nokogiri problem. Thus, now, Nokogiri checks the presense
  # of appengine-rack.jar in $LOAD_PATH. If Nokogiri is on GAE, Nokogiri
  # should skip loading xml jars. This is because those are in WEB-INF/lib and 
  # already set in the classpath.
  unless $LOAD_PATH.to_s.include?("appengine-rack")
    require 'isorelax.jar'
    require 'jing.jar'
    require 'nekohtml.jar'
    require 'nekodtd.jar'
    require 'xercesImpl.jar'
  end
end

require 'nokogiri/nokogiri'
require 'nokogiri/version'
require 'nokogiri/syntax_error'
require 'nokogiri/xml'
require 'nokogiri/xslt'
require 'nokogiri/html'
require 'nokogiri/decorators/slop'
require 'nokogiri/css'
require 'nokogiri/html/builder'

# Nokogiri parses and searches XML/HTML very quickly, and also has
# correctly implemented CSS3 selector support as well as XPath support.
#
# Parsing a document returns either a Nokogiri::XML::Document, or a
# Nokogiri::HTML::Document depending on the kind of document you parse.
#
# Here is an example:
#
#   require 'nokogiri'
#   require 'open-uri'
#
#   # Get a Nokogiri::HTML:Document for the page were interested in...
#
#   doc = Nokogiri::HTML(open('http://www.google.com/search?q=tenderlove'))
#
#   # Do funky things with it using Nokogiri::XML::Node methods...
#
#   ####
#   # Search for nodes by css
#   doc.css('h3.r a.l').each do |link|
#     puts link.content
#   end
#
# See Nokogiri::XML::Node#css for more information about CSS searching.
# See Nokogiri::XML::Node#xpath for more information about XPath searching.
module Nokogiri
  class << self
    ###
    # Parse an HTML or XML document.  +string+ contains the document.
    def parse string, url = nil, encoding = nil, options = nil
      doc =
        if string.respond_to?(:read) ||
          string =~ /^\s*<[^Hh>]*html/i # Probably html
          Nokogiri.HTML(
            string,
            url,
            encoding, options || XML::ParseOptions::DEFAULT_HTML
          )
        else
          Nokogiri.XML(string, url, encoding,
                        options || XML::ParseOptions::DEFAULT_XML)
        end
      yield doc if block_given?
      doc
    end

    ###
    # Create a new Nokogiri::XML::DocumentFragment
    def make input = nil, opts = {}, &blk
      if input
        Nokogiri::HTML.fragment(input).children.first
      else
        Nokogiri(&blk)
      end
    end

    ###
    # Parse a document and add the Slop decorator.  The Slop decorator
    # implements method_missing such that methods may be used instead of CSS
    # or XPath.  For example:
    #
    #   doc = Nokogiri::Slop(<<-eohtml)
    #     <html>
    #       <body>
    #         <p>first</p>
    #         <p>second</p>
    #       </body>
    #     </html>
    #   eohtml
    #   assert_equal('second', doc.html.body.p[1].text)
    #
    def Slop(*args, &block)
      Nokogiri(*args, &block).slop!
    end
  end
end

###
# Parser a document contained in +args+.  Nokogiri will try to guess what
# type of document you are attempting to parse.  For more information, see
# Nokogiri.parse
#
# To specify the type of document, use Nokogiri.XML or Nokogiri.HTML.
def Nokogiri(*args, &block)
  if block_given?
    builder = Nokogiri::HTML::Builder.new(&block)
    return builder.doc.root
  else
    Nokogiri.parse(*args)
  end
end
                                                                                                                                                                                                                           xsd/                                                                                                0040755 0001750 0001750 00000000000 12612224746 040027  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib                              xmlparser/                                                                                          0040755 0001750 0001750 00000000000 12612224746 042044  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/xsd                          nokogiri.rb                                                                                         0100644 0001750 0001750 00000004735 12566211316 044215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/lib/xsd/xmlparser                require 'nokogiri'

module XSD # :nodoc:
  module XMLParser # :nodoc:
    ###
    # Nokogiri XML parser for soap4r.
    #
    # Nokogiri may be used as the XML parser in soap4r.  Simply require
    # 'xsd/xmlparser/nokogiri' in your soap4r applications, and soap4r
    # will use Nokogiri as it's XML parser.  No other changes should be
    # required to use Nokogiri as the XML parser.
    #
    # Example (using UW ITS Web Services):
    #
    #   require 'rubygems'
    #   require 'nokogiri'
    #   gem 'soap4r'
    #   require 'defaultDriver'
    #   require 'xsd/xmlparser/nokogiri'
    #   
    #   obj = AvlPortType.new
    #   obj.getLatestByRoute(obj.getAgencies.first, 8).each do |bus|
    #     p "#{bus.routeID}, #{bus.longitude}, #{bus.latitude}"
    #   end
    #
    class Nokogiri < XSD::XMLParser::Parser
      ###
      # Create a new XSD parser with +host+ and +opt+
      def initialize host, opt = {}
        super
        @parser = ::Nokogiri::XML::SAX::Parser.new(self, @charset || 'UTF-8')
      end

      ###
      # Start parsing +string_or_readable+
      def do_parse string_or_readable
        @parser.parse(string_or_readable)
      end

      ###
      # Handle the start_element event with +name+ and +attrs+
      def start_element name, attrs = []
        super(name, Hash[*attrs.flatten])
      end

      ###
      # Handle the end_element event with +name+
      def end_element name
        super
      end

      ###
      # Handle errors with message +msg+
      def error msg
        raise ParseError.new(msg)
      end
      alias :warning :error

      ###
      # Handle cdata_blocks containing +string+
      def cdata_block string
        characters string
      end

      def start_element_namespace name, attrs = [], prefix = nil, uri = nil, ns = []
        ###
        # Deal with SAX v1 interface
        name = [prefix, name].compact.join(':')
        attributes = ns.map { |ns_prefix,ns_uri|
          [['xmlns', ns_prefix].compact.join(':'), ns_uri]
        } + attrs.map { |attr|
          [[attr.prefix, attr.localname].compact.join(':'), attr.value]
        }.flatten
        start_element name, attributes
      end

      def end_element_namespace name, prefix = nil, uri = nil
        ###
        # Deal with SAX v1 interface
        end_element [prefix, name].compact.join(':')
      end

      %w{ xmldecl start_document end_document comment }.each do |name|
        class_eval %{ def #{name}(*args); end }
      end

      add_factory(self)
    end
  end
end
                                   tasks/                                                                                              0040755 0001750 0001750 00000000000 12612224746 037610  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6                                  cross_compile.rb                                                                                    0100644 0001750 0001750 00000010250 12566211316 042766  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/tasks                            gem 'rake-compiler'
require 'rake/extensioncompiler'
HOST = Rake::ExtensionCompiler.mingw_host

require 'mini_portile'
$recipes = {}
$recipes[:zlib]     = MiniPortile.new "zlib",     "1.2.7"
$recipes[:libiconv] = MiniPortile.new "libiconv", "1.13.1"
$recipes[:libxml2]  = MiniPortile.new "libxml2",  "2.7.7"
$recipes[:libxslt]  = MiniPortile.new "libxslt",  "1.1.26"
$recipes.each { |_, recipe| recipe.host = HOST }

file "lib/nokogiri/nokogiri.rb" do
  File.open("lib/nokogiri/nokogiri.rb", 'wb') do |f|
    f.write %Q{require "nokogiri/\#{RUBY_VERSION.sub(/\\.\\d+$/, '')}/nokogiri"\n}
  end
end

namespace :cross do
  task :zlib do
    recipe = $recipes[:zlib]
    recipe.files = ["http://zlib.net/#{recipe.name}-#{recipe.version}.tar.gz"]
    class << recipe
      def configure
        Dir.chdir work_path do
          mk = File.read 'win32/Makefile.gcc'
          File.open 'win32/Makefile.gcc', 'wb' do |f|
            f.puts "BINARY_PATH = #{CROSS_DIR}/bin"
            f.puts "LIBRARY_PATH = #{CROSS_DIR}/lib"
            f.puts "INCLUDE_PATH = #{CROSS_DIR}/include"
            f.puts mk.sub(/^PREFIX\s*=\s*$/, "PREFIX = #{HOST}-")
          end
        end
      end

      def configured?
        Dir.chdir work_path do
          !! (File.read('win32/Makefile.gcc') =~ /^BINARY_PATH/)
        end
      end

      def compile
        execute "compile", "make -f win32/Makefile.gcc"
      end

      def install
        execute "install", "make -f win32/Makefile.gcc install"
      end
    end

    checkpoint = "#{CROSS_DIR}/#{recipe.name}-#{recipe.version}.installed"
    unless File.exist?(checkpoint)
      recipe.cook
      touch checkpoint
    end
    recipe.activate
  end

  task :libiconv do
    recipe = $recipes[:libiconv]
    recipe.files = ["http://ftp.gnu.org/pub/gnu/libiconv/#{recipe.name}-#{recipe.version}.tar.gz"]
    recipe.configure_options = [
      "--host=#{HOST}",
      "--enable-static",
      "--disable-shared",
      "CPPFLAGS='-mno-cygwin -Wall'",
      "CFLAGS='-mno-cygwin -O2 -g'",
      "CXXFLAGS='-mno-cygwin -O2 -g'",
      "LDFLAGS=-mno-cygwin"
    ]

    checkpoint = "#{CROSS_DIR}/#{recipe.name}-#{recipe.version}.installed"
    unless File.exist?(checkpoint)
      recipe.cook
      touch checkpoint
    end
    recipe.activate
  end

  task :libxml2 => ["cross:zlib", "cross:libiconv"] do
    recipe = $recipes[:libxml2]
    recipe.files = ["ftp://ftp.xmlsoft.org/libxml2/#{recipe.name}-#{recipe.version}.tar.gz"]
    recipe.configure_options = [
      "--host=#{HOST}",
      "--enable-static",
      "--disable-shared",
      "--with-zlib=#{CROSS_DIR}",
      "--with-iconv=#{$recipes[:libiconv].path}",
      "--without-python",
      "--without-readline",
      "CFLAGS='-DIN_LIBXML'"
    ]
    class << recipe
      def download
        Dir.chdir archives_path do
          @files.each do |url|
            sh "wget #{url} || curl -O #{url}"
          end
        end
      end
    end

    checkpoint = "#{CROSS_DIR}/#{recipe.name}-#{recipe.version}.installed"
    unless File.exist?(checkpoint)
      recipe.cook
      touch checkpoint
    end
    recipe.activate
  end

  task :libxslt => ['cross:libxml2'] do
    recipe = $recipes[:libxslt]
    recipe.files = ["ftp://ftp.xmlsoft.org/libxml2/#{recipe.name}-#{recipe.version}.tar.gz"]
    recipe.configure_options = [
      "--host=#{HOST}",
      "--enable-static",
      "--disable-shared",
      "--with-libxml-prefix=#{$recipes[:libxml2].path}",
      "--without-python",
      "--without-crypto",
      "CFLAGS='-DIN_LIBXML'"
    ]
    class << recipe
      def download
        Dir.chdir archives_path do
          @files.each do |url|
            sh "wget #{url} || curl -O #{url}"
          end
        end
      end
    end

    checkpoint = "#{CROSS_DIR}/#{recipe.name}-#{recipe.version}.installed"
    unless File.exist?(checkpoint)
      recipe.cook
      touch checkpoint
    end
    recipe.activate
  end

  task :file_list do
    HOE.spec.files += Dir["lib/nokogiri/nokogiri.rb"]
    HOE.spec.files += Dir["lib/nokogiri/1.{8,9}/nokogiri.so"]
  end
end

require 'rake/clean'
CLOBBER.include("#{CROSS_DIR}/*.installed", "#{CROSS_DIR}/#{HOST}", "tmp/#{HOST}")

task :cross => ["cross:libxslt", "lib/nokogiri/nokogiri.rb", "cross:file_list"]
                                                                                                                                                                                                                                                                                                                                                        nokogiri.org.rb                                                                                     0100644 0001750 0001750 00000001415 12566211316 042537  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/tasks                            #
#  note that this file will only work if you've got the `nokogiri.org`
#  repo checked out, and you've got an rvm gemset "1.8.7@nokogiri"
#  bundled with both nokogiri's and nokogiri.org's gems.
#
namespace :docs do
  desc "generate HTML docs for nokogiri.org"
  task :website do
    system 'rvm use 1.8.7@nokogiri' # see above
    title = "#{HOE.name}-#{HOE.version} Documentation"

    options = []
    options << "--main=#{HOE.readme_file}"
    options << '--format=activerecord'
    options << '--threads=1'
    options << "--title=#{title.inspect}"

    options += HOE.spec.require_paths
    options += HOE.spec.extra_rdoc_files
    require 'rdoc/rdoc'
    ENV['RAILS_ROOT'] ||= File.expand_path(File.join('..', 'nokogiri_ws'))
    RDoc::RDoc.new.document options
  end
end
                                                                                                                                                                                                                                                   test.rb                                                                                             0100644 0001750 0001750 00000006126 12566211316 041113  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/nokogiri-1.5.6/tasks                            namespace :test do
  desc "run test suite with aggressive GC"
  task :gc => :build do
    ENV['NOKOGIRI_GC'] = "true"
    Rake::Task["test"].invoke
  end

  desc "find call-seq in the rdoc"
  task :rdoc_call_seq => 'docs' do
    Dir['doc/**/*.html'].each { |docfile|
      next if docfile =~ /\.src/
      puts "FAIL: #{docfile}" if File.read(docfile) =~ /call-seq/
    }
  end

  desc "find all undocumented things"
  task :rdoc => 'docs' do
    base = File.expand_path(File.join(File.dirname(__FILE__), '..', 'doc'))
    require 'test/unit'
    test = Class.new(Test::Unit::TestCase)
    Dir["#{base}/**/*.html"].each { |docfile|
      test.class_eval(<<-eotest)
        def test_#{docfile.sub("#{base}/", '').gsub(/[\/\.-]/, '_')}
          assert_no_match(
            /Not documented/,
            File.read('#{docfile}'),
            '#{docfile} has undocumented things'
          )
        end
      eotest
    }
  end

  desc "Test against multiple versions of libxml2 (MULTIXML2_DIR=directory)"
  task :multixml2 do
    MULTI_XML = File.join(ENV['HOME'], '.multixml2')
    unless File.exists?(MULTI_XML)
      %w{ versions install build }.each { |x|
        FileUtils.mkdir_p(File.join(MULTI_XML, x))
      }
      Dir.chdir File.join(MULTI_XML, 'versions') do
        require 'net/ftp'
        puts "Contacting xmlsoft.org ..."
        ftp = Net::FTP.new('xmlsoft.org')
        ftp.login('anonymous', 'anonymous')
        ftp.chdir('libxml2')
        ftp.list('libxml2-2.*.tar.gz').each do |x|
          file = x[/[^\s]*$/]
          puts "Downloading #{file}"
          ftp.getbinaryfile(file)
        end
      end
    end

    # Build any libxml2 versions in $HOME/.multixml2/versions that
    # haven't been built yet
    Dir[File.join(MULTI_XML, 'versions','*.tar.gz')].each do |f|
      filename = File.basename(f, '.tar.gz')

      install_dir = File.join(MULTI_XML, 'install', filename)
      next if File.exists?(install_dir)

      Dir.chdir File.join(MULTI_XML, 'versions') do
        system "tar zxvf #{f} -C #{File.join(MULTI_XML, 'build')}"
      end

      Dir.chdir File.join(MULTI_XML, 'build', filename) do
        system "./configure --without-http --prefix=#{install_dir}"
        system "make && make install"
      end
    end

    test_results = {}
    libxslt = Dir[File.join(MULTI_XML, 'install', 'libxslt*')].first

    directories = ENV['MULTIXML2_DIR'] ? [ENV['MULTIXML2_DIR']] : Dir[File.join(MULTI_XML, 'install', '*')]
    directories.sort.reverse_each do |xml2_version|
      next unless xml2_version =~ /libxml2/
      extopts = "--with-xml2-include=#{xml2_version}/include/libxml2 --with-xml2-lib=#{xml2_version}/lib --with-xslt-dir=#{libxslt} --with-iconv-dir=/usr"
      cmd = "#{$0} clean test EXTOPTS='#{extopts}' LD_LIBRARY_PATH='#{xml2_version}/lib'"

      version = File.basename(xml2_version)
      result = system(cmd)
      test_results[version] = {
        :result => result,
        :cmd    => cmd
      }
    end
    test_results.sort_by { |k,v| k }.each do |k,v|
      passed = v[:result]
      puts "#{k}: #{passed ? 'PASS' : 'FAIL'}"
      puts "repro: #{v[:cmd]}" unless passed
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                          sqlite3-1.3.7/                                                                                      0040755 0001750 0001750 00000000000 12612224746 036225  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems                                                 ext/                                                                                                0040755 0001750 0001750 00000000000 12612224746 037025  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7                                   sqlite3/                                                                                            0040755 0001750 0001750 00000000000 12612224746 040411  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext                               backup.c                                                                                            0100644 0001750 0001750 00000010572 12566211336 042023  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #ifdef HAVE_SQLITE3_BACKUP_INIT

#include <sqlite3_ruby.h>

#define REQUIRE_OPEN_BACKUP(_ctxt) \
  if(!_ctxt->p) \
    rb_raise(rb_path2class("SQLite3::Exception"), "cannot use a closed backup");

VALUE cSqlite3Backup;

static void deallocate(void * ctx)
{
  sqlite3BackupRubyPtr c = (sqlite3BackupRubyPtr)ctx;
  xfree(c);
}

static VALUE allocate(VALUE klass)
{
  sqlite3BackupRubyPtr ctx = xcalloc((size_t)1, sizeof(sqlite3BackupRuby));
  return Data_Wrap_Struct(klass, NULL, deallocate, ctx);
}

/* call-seq: SQLite3::Backup.new(dstdb, dstname, srcdb, srcname)
 *
 * Initialize backup the backup.
 *
 * dstdb:
 *   the destination SQLite3::Database object.
 * dstname:
 *   the destination's database name.
 * srcdb:
 *   the source SQLite3::Database object.
 * srcname:
 *   the source's database name.
 *
 * The database name is "main", "temp", or the name specified in an
 * ATTACH statement.
 *
 * This feature requires SQLite 3.6.11 or later.
 *
 *   require 'sqlite3'
 *   sdb = SQLite3::Database.new('src.sqlite3')
 *
 *   ddb = SQLite3::Database.new(':memory:')
 *   b = SQLite3::Backup.new(ddb, 'main', sdb, 'main')
 *   p [b.remaining, b.pagecount] # invalid value; for example [0, 0]
 *   begin
 *     p b.step(1) #=> OK or DONE
 *     p [b.remaining, b.pagecount]
 *   end while b.remaining > 0
 *   b.finish
 *
 *   ddb = SQLite3::Database.new(':memory:')
 *   b = SQLite3::Backup.new(ddb, 'main', sdb, 'main')
 *   b.step(-1) #=> DONE
 *   b.finish
 *
 */
static VALUE initialize(VALUE self, VALUE dstdb, VALUE dstname, VALUE srcdb, VALUE srcname)
{
  sqlite3BackupRubyPtr ctx;
  sqlite3RubyPtr ddb_ctx, sdb_ctx;
  sqlite3_backup *pBackup;

  Data_Get_Struct(self, sqlite3BackupRuby, ctx);
  Data_Get_Struct(dstdb, sqlite3Ruby, ddb_ctx);
  Data_Get_Struct(srcdb, sqlite3Ruby, sdb_ctx);

  if(!sdb_ctx->db)
    rb_raise(rb_eArgError, "cannot backup from a closed database");
  if(!ddb_ctx->db)
    rb_raise(rb_eArgError, "cannot backup to a closed database");

  pBackup = sqlite3_backup_init(ddb_ctx->db, StringValuePtr(dstname),
    sdb_ctx->db, StringValuePtr(srcname));
  if( pBackup ){
    ctx->p = pBackup;
  }
  else {
    CHECK(ddb_ctx->db, sqlite3_errcode(ddb_ctx->db));
  }

  return self;
}

/* call-seq: SQLite3::Backup#step(nPage)
 *
 * Copy database pages up to +nPage+.
 * If negative, copy all remaining source pages.
 *
 * If all pages are copied, it returns SQLite3::Constants::ErrorCode::DONE.
 * When coping is not done, it returns SQLite3::Constants::ErrorCode::OK.
 * When some errors occur, it returns the error code.
 */
static VALUE step(VALUE self, VALUE nPage)
{
  sqlite3BackupRubyPtr ctx;
  int status;

  Data_Get_Struct(self, sqlite3BackupRuby, ctx);
  REQUIRE_OPEN_BACKUP(ctx);
  status = sqlite3_backup_step(ctx->p, NUM2INT(nPage));
  return INT2NUM(status);
}

/* call-seq: SQLite3::Backup#finish
 *
 * Destroy the backup object.
 */
static VALUE finish(VALUE self)
{
  sqlite3BackupRubyPtr ctx;

  Data_Get_Struct(self, sqlite3BackupRuby, ctx);
  REQUIRE_OPEN_BACKUP(ctx);
  (void)sqlite3_backup_finish(ctx->p);
  ctx->p = NULL;
  return Qnil;
}

/* call-seq: SQLite3::Backup#remaining
 *
 * Returns the number of pages still to be backed up.
 *
 * Note that the value is only updated after step() is called,
 * so before calling step() returned value is invalid.
 */
static VALUE remaining(VALUE self)
{
  sqlite3BackupRubyPtr ctx;

  Data_Get_Struct(self, sqlite3BackupRuby, ctx);
  REQUIRE_OPEN_BACKUP(ctx);
  return INT2NUM(sqlite3_backup_remaining(ctx->p));
}

/* call-seq: SQLite3::Backup#pagecount
 *
 * Returns the total number of pages in the source database file.
 *
 * Note that the value is only updated after step() is called,
 * so before calling step() returned value is invalid.
 */
static VALUE pagecount(VALUE self)
{
  sqlite3BackupRubyPtr ctx;

  Data_Get_Struct(self, sqlite3BackupRuby, ctx);
  REQUIRE_OPEN_BACKUP(ctx);
  return INT2NUM(sqlite3_backup_pagecount(ctx->p));
}

void init_sqlite3_backup()
{
#if 0
  VALUE mSqlite3 = rb_define_module("SQLite3");
#endif
  cSqlite3Backup = rb_define_class_under(mSqlite3, "Backup", rb_cObject);

  rb_define_alloc_func(cSqlite3Backup, allocate);
  rb_define_method(cSqlite3Backup, "initialize", initialize, 4);
  rb_define_method(cSqlite3Backup, "step", step, 1);
  rb_define_method(cSqlite3Backup, "finish", finish, 0);
  rb_define_method(cSqlite3Backup, "remaining", remaining, 0);
  rb_define_method(cSqlite3Backup, "pagecount", pagecount, 0);
}

#endif
                                                                                                                                      backup.h                                                                                            0100644 0001750 0001750 00000000500 12566211336 042016  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #if !defined(SQLITE3_BACKUP_RUBY) && defined(HAVE_SQLITE3_BACKUP_INIT)
#define SQLITE3_BACKUP_RUBY

#include <sqlite3_ruby.h>

struct _sqlite3BackupRuby {
  sqlite3_backup *p;
};

typedef struct _sqlite3BackupRuby sqlite3BackupRuby;
typedef sqlite3BackupRuby * sqlite3BackupRubyPtr;

void init_sqlite3_backup();

#endif
                                                                                                                                                                                                database.c                                                                                          0100644 0001750 0001750 00000051031 12566211336 042315  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #include <sqlite3_ruby.h>

#define REQUIRE_OPEN_DB(_ctxt) \
  if(!_ctxt->db) \
    rb_raise(rb_path2class("SQLite3::Exception"), "cannot use a closed database");

VALUE cSqlite3Database;
static VALUE sym_utf16, sym_results_as_hash, sym_type_translation;

static void deallocate(void * ctx)
{
  sqlite3RubyPtr c = (sqlite3RubyPtr)ctx;
  sqlite3 * db     = c->db;

  if(db) sqlite3_close(db);
  xfree(c);
}

static VALUE allocate(VALUE klass)
{
  sqlite3RubyPtr ctx = xcalloc((size_t)1, sizeof(sqlite3Ruby));
  return Data_Wrap_Struct(klass, NULL, deallocate, ctx);
}

static char *
utf16_string_value_ptr(VALUE str)
{
  StringValue(str);
  rb_str_buf_cat(str, "\x00", 1L);
  return RSTRING_PTR(str);
}

/* call-seq: SQLite3::Database.new(file, options = {})
 *
 * Create a new Database object that opens the given file. If utf16
 * is +true+, the filename is interpreted as a UTF-16 encoded string.
 *
 * By default, the new database will return result rows as arrays
 * (#results_as_hash) and has type translation disabled (#type_translation=).
 */
static VALUE initialize(int argc, VALUE *argv, VALUE self)
{
  sqlite3RubyPtr ctx;
  VALUE file;
  VALUE opts;
  VALUE zvfs;
#ifdef HAVE_SQLITE3_OPEN_V2
  int mode = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
#endif
  int status;

  Data_Get_Struct(self, sqlite3Ruby, ctx);

  rb_scan_args(argc, argv, "12", &file, &opts, &zvfs);
#if defined StringValueCStr
  StringValuePtr(file);
  rb_check_safe_obj(file);
#else
  Check_SafeStr(file);
#endif
  if(NIL_P(opts)) opts = rb_hash_new();
  else Check_Type(opts, T_HASH);

#ifdef HAVE_RUBY_ENCODING_H
  if(UTF16_LE_P(file) || UTF16_BE_P(file)) {
    status = sqlite3_open16(utf16_string_value_ptr(file), &ctx->db);
  } else {
#endif

    if(Qtrue == rb_hash_aref(opts, sym_utf16)) {
      status = sqlite3_open16(utf16_string_value_ptr(file), &ctx->db);
    } else {

#ifdef HAVE_RUBY_ENCODING_H
      if(!UTF8_P(file)) {
        file = rb_str_export_to_enc(file, rb_utf8_encoding());
      }
#endif

      if (Qtrue == rb_hash_aref(opts, ID2SYM(rb_intern("readonly")))) {
#ifdef HAVE_SQLITE3_OPEN_V2
        mode = SQLITE_OPEN_READONLY;
#else
        rb_raise(rb_eNotImpError, "sqlite3-ruby was compiled against a version of sqlite that does not support readonly databases");
#endif
      }
#ifdef HAVE_SQLITE3_OPEN_V2
      status = sqlite3_open_v2(
          StringValuePtr(file),
          &ctx->db,
          mode,
          NIL_P(zvfs) ? NULL : StringValuePtr(zvfs)
      );
#else
      status = sqlite3_open(
          StringValuePtr(file),
          &ctx->db
      );
#endif
    }

#ifdef HAVE_RUBY_ENCODING_H
  }
#endif

  CHECK(ctx->db, status)

  rb_iv_set(self, "@tracefunc", Qnil);
  rb_iv_set(self, "@authorizer", Qnil);
  rb_iv_set(self, "@encoding", Qnil);
  rb_iv_set(self, "@busy_handler", Qnil);
  rb_iv_set(self, "@collations", rb_hash_new());
  rb_iv_set(self, "@functions", rb_hash_new());
  rb_iv_set(self, "@results_as_hash", rb_hash_aref(opts, sym_results_as_hash));
  rb_iv_set(self, "@type_translation", rb_hash_aref(opts, sym_type_translation));
#ifdef HAVE_SQLITE3_OPEN_V2
  rb_iv_set(self, "@readonly", mode == SQLITE_OPEN_READONLY ? Qtrue : Qfalse);
#else
  rb_iv_set(self, "@readonly", Qfalse);
#endif

  if(rb_block_given_p()) {
    rb_yield(self);
    rb_funcall(self, rb_intern("close"), 0);
  }

  return self;
}

/* call-seq: db.close
 *
 * Closes this database.
 */
static VALUE sqlite3_rb_close(VALUE self)
{
  sqlite3RubyPtr ctx;
  sqlite3 * db;
  Data_Get_Struct(self, sqlite3Ruby, ctx);

  db = ctx->db;
  CHECK(db, sqlite3_close(ctx->db));

  ctx->db = NULL;

  return self;
}

/* call-seq: db.closed?
 *
 * Returns +true+ if this database instance has been closed (see #close).
 */
static VALUE closed_p(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);

  if(!ctx->db) return Qtrue;

  return Qfalse;
}

/* call-seq: total_changes
 *
 * Returns the total number of changes made to this database instance
 * since it was opened.
 */
static VALUE total_changes(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return INT2NUM((long)sqlite3_total_changes(ctx->db));
}

static void tracefunc(void * data, const char *sql)
{
  VALUE self = (VALUE)data;
  VALUE thing = rb_iv_get(self, "@tracefunc");
  rb_funcall(thing, rb_intern("call"), 1, rb_str_new2(sql));
}

/* call-seq:
 *    trace { |sql| ... }
 *    trace(Class.new { def call sql; end }.new)
 *
 * Installs (or removes) a block that will be invoked for every SQL
 * statement executed. The block receives one parameter: the SQL statement
 * executed. If the block is +nil+, any existing tracer will be uninstalled.
 */
static VALUE trace(int argc, VALUE *argv, VALUE self)
{
  sqlite3RubyPtr ctx;
  VALUE block;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  rb_scan_args(argc, argv, "01", &block);

  if(NIL_P(block) && rb_block_given_p()) block = rb_block_proc();

  rb_iv_set(self, "@tracefunc", block);

  sqlite3_trace(ctx->db, NIL_P(block) ? NULL : tracefunc, (void *)self);

  return self;
}

static int rb_sqlite3_busy_handler(void * ctx, int count)
{
  VALUE self = (VALUE)(ctx);
  VALUE handle = rb_iv_get(self, "@busy_handler");
  VALUE result = rb_funcall(handle, rb_intern("call"), 1, INT2NUM((long)count));

  if(Qfalse == result) return 0;

  return 1;
}

/* call-seq:
 *    busy_handler { |count| ... }
 *    busy_handler(Class.new { def call count; end }.new)
 *
 * Register a busy handler with this database instance. When a requested
 * resource is busy, this handler will be invoked. If the handler returns
 * +false+, the operation will be aborted; otherwise, the resource will
 * be requested again.
 *
 * The handler will be invoked with the name of the resource that was
 * busy, and the number of times it has been retried.
 *
 * See also the mutually exclusive #busy_timeout.
 */
static VALUE busy_handler(int argc, VALUE *argv, VALUE self)
{
  sqlite3RubyPtr ctx;
  VALUE block;
  int status;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  rb_scan_args(argc, argv, "01", &block);

  if(NIL_P(block) && rb_block_given_p()) block = rb_block_proc();

  rb_iv_set(self, "@busy_handler", block);

  status = sqlite3_busy_handler(
      ctx->db, NIL_P(block) ? NULL : rb_sqlite3_busy_handler, (void *)self);

  CHECK(ctx->db, status);

  return self;
}

/* call-seq: last_insert_row_id
 *
 * Obtains the unique row ID of the last row to be inserted by this Database
 * instance.
 */
static VALUE last_insert_row_id(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return LL2NUM(sqlite3_last_insert_rowid(ctx->db));
}

static VALUE sqlite3val2rb(sqlite3_value * val)
{
  switch(sqlite3_value_type(val)) {
    case SQLITE_INTEGER:
      return LL2NUM(sqlite3_value_int64(val));
      break;
    case SQLITE_FLOAT:
      return rb_float_new(sqlite3_value_double(val));
      break;
    case SQLITE_TEXT:
      return rb_tainted_str_new2((const char *)sqlite3_value_text(val));
      break;
    case SQLITE_BLOB:
      return rb_tainted_str_new2((const char *)sqlite3_value_blob(val));
      break;
    case SQLITE_NULL:
      return Qnil;
      break;
    default:
      rb_raise(rb_eRuntimeError, "bad type"); /* FIXME */
  }
}

static void set_sqlite3_func_result(sqlite3_context * ctx, VALUE result)
{
  switch(TYPE(result)) {
    case T_NIL:
      sqlite3_result_null(ctx);
      break;
    case T_FIXNUM:
      sqlite3_result_int64(ctx, (sqlite3_int64)FIX2LONG(result));
      break;
    case T_BIGNUM:
#if SIZEOF_LONG < 8
      if (RBIGNUM_LEN(result) * SIZEOF_BDIGITS <= 8) {
          sqlite3_result_int64(ctx, NUM2LL(result));
          break;
      }
#endif
    case T_FLOAT:
      sqlite3_result_double(ctx, NUM2DBL(result));
      break;
    case T_STRING:
      sqlite3_result_text(
          ctx,
          (const char *)StringValuePtr(result),
          (int)RSTRING_LEN(result),
          SQLITE_TRANSIENT
      );
      break;
    default:
      rb_raise(rb_eRuntimeError, "can't return %s",
          rb_class2name(CLASS_OF(result)));
  }
}

static void rb_sqlite3_func(sqlite3_context * ctx, int argc, sqlite3_value **argv)
{
  VALUE callable = (VALUE)sqlite3_user_data(ctx);
  VALUE * params = NULL;
  VALUE result;
  int i;

  if (argc > 0) {
    params = xcalloc((size_t)argc, sizeof(VALUE *));

    for(i = 0; i < argc; i++) {
      VALUE param = sqlite3val2rb(argv[i]);
      RB_GC_GUARD(param);
      params[i] = param;
    }
  }

  result = rb_funcall2(callable, rb_intern("call"), argc, params);
  xfree(params);

  set_sqlite3_func_result(ctx, result);
}

#ifndef HAVE_RB_PROC_ARITY
int rb_proc_arity(VALUE self)
{
  return (int)NUM2INT(rb_funcall(self, rb_intern("arity"), 0));
}
#endif

/* call-seq: define_function(name) { |args,...| }
 *
 * Define a function named +name+ with +args+.  The arity of the block
 * will be used as the arity for the function defined.
 */
static VALUE define_function(VALUE self, VALUE name)
{
  sqlite3RubyPtr ctx;
  VALUE block;
  int status;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  block = rb_block_proc();

  status = sqlite3_create_function(
    ctx->db,
    StringValuePtr(name),
    rb_proc_arity(block),
    SQLITE_UTF8,
    (void *)block,
    rb_sqlite3_func,
    NULL,
    NULL
  );

  CHECK(ctx->db, status);

  rb_hash_aset(rb_iv_get(self, "@functions"), name, block);

  return self;
}

static int sqlite3_obj_method_arity(VALUE obj, ID id)
{
  VALUE method = rb_funcall(obj, rb_intern("method"), 1, ID2SYM(id));
  VALUE arity  = rb_funcall(method, rb_intern("arity"), 0);

  return (int)NUM2INT(arity);
}

static void rb_sqlite3_step(sqlite3_context * ctx, int argc, sqlite3_value **argv)
{
  VALUE callable = (VALUE)sqlite3_user_data(ctx);
  VALUE * params = NULL;
  int i;

  if (argc > 0) {
    params = xcalloc((size_t)argc, sizeof(VALUE *));
    for(i = 0; i < argc; i++) {
      params[i] = sqlite3val2rb(argv[i]);
    }
  }
  rb_funcall2(callable, rb_intern("step"), argc, params);
  xfree(params);
}

static void rb_sqlite3_final(sqlite3_context * ctx)
{
  VALUE callable = (VALUE)sqlite3_user_data(ctx);
  VALUE result = rb_funcall(callable, rb_intern("finalize"), 0);
  set_sqlite3_func_result(ctx, result);
}

/* call-seq: define_aggregator(name, aggregator)
 *
 * Define an aggregate function named +name+ using the object +aggregator+.
 * +aggregator+ must respond to +step+ and +finalize+.  +step+ will be called
 * with row information and +finalize+ must return the return value for the
 * aggregator function.
 */
static VALUE define_aggregator(VALUE self, VALUE name, VALUE aggregator)
{
  sqlite3RubyPtr ctx;
  int arity, status;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  arity = sqlite3_obj_method_arity(aggregator, rb_intern("step"));

  status = sqlite3_create_function(
    ctx->db,
    StringValuePtr(name),
    arity,
    SQLITE_UTF8,
    (void *)aggregator,
    NULL,
    rb_sqlite3_step,
    rb_sqlite3_final
  );

  rb_iv_set(self, "@agregator", aggregator);

  CHECK(ctx->db, status);

  return self;
}

/* call-seq: interrupt
 *
 * Interrupts the currently executing operation, causing it to abort.
 */
static VALUE interrupt(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  sqlite3_interrupt(ctx->db);

  return self;
}

/* call-seq: errmsg
 *
 * Return a string describing the last error to have occurred with this
 * database.
 */
static VALUE errmsg(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return rb_str_new2(sqlite3_errmsg(ctx->db));
}

/* call-seq: errcode
 *
 * Return an integer representing the last error to have occurred with this
 * database.
 */
static VALUE errcode_(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return INT2NUM((long)sqlite3_errcode(ctx->db));
}

/* call-seq: complete?(sql)
 *
 * Return +true+ if the string is a valid (ie, parsable) SQL statement, and
 * +false+ otherwise.
 */
static VALUE complete_p(VALUE UNUSED(self), VALUE sql)
{
  if(sqlite3_complete(StringValuePtr(sql)))
    return Qtrue;

  return Qfalse;
}

/* call-seq: changes
 *
 * Returns the number of changes made to this database instance by the last
 * operation performed. Note that a "delete from table" without a where
 * clause will not affect this value.
 */
static VALUE changes(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return INT2NUM(sqlite3_changes(ctx->db));
}

static int rb_sqlite3_auth(
    void *ctx,
    int _action,
    const char * _a,
    const char * _b,
    const char * _c,
    const char * _d)
{
  VALUE self   = (VALUE)ctx;
  VALUE action = INT2NUM(_action);
  VALUE a      = _a ? rb_str_new2(_a) : Qnil;
  VALUE b      = _b ? rb_str_new2(_b) : Qnil;
  VALUE c      = _c ? rb_str_new2(_c) : Qnil;
  VALUE d      = _d ? rb_str_new2(_d) : Qnil;
  VALUE callback = rb_iv_get(self, "@authorizer");
  VALUE result = rb_funcall(callback, rb_intern("call"), 5, action, a, b, c, d);

  if(T_FIXNUM == TYPE(result)) return (int)NUM2INT(result);
  if(Qtrue == result) return SQLITE_OK;
  if(Qfalse == result) return SQLITE_DENY;

  return SQLITE_IGNORE;
}

/* call-seq: set_authorizer = auth
 *
 * Set the authorizer for this database.  +auth+ must respond to +call+, and
 * +call+ must take 5 arguments.
 *
 * Installs (or removes) a block that will be invoked for every access
 * to the database. If the block returns 0 (or +true+), the statement
 * is allowed to proceed. Returning 1 or false causes an authorization error to
 * occur, and returning 2 or nil causes the access to be silently denied.
 */
static VALUE set_authorizer(VALUE self, VALUE authorizer)
{
  sqlite3RubyPtr ctx;
  int status;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  status = sqlite3_set_authorizer(
      ctx->db, NIL_P(authorizer) ? NULL : rb_sqlite3_auth, (void *)self
  );

  CHECK(ctx->db, status);

  rb_iv_set(self, "@authorizer", authorizer);

  return self;
}

/* call-seq: db.busy_timeout = ms
 *
 * Indicates that if a request for a resource terminates because that
 * resource is busy, SQLite should sleep and retry for up to the indicated
 * number of milliseconds. By default, SQLite does not retry
 * busy resources. To restore the default behavior, send 0 as the
 * +ms+ parameter.
 *
 * See also the mutually exclusive #busy_handler.
 */
static VALUE set_busy_timeout(VALUE self, VALUE timeout)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  CHECK(ctx->db, sqlite3_busy_timeout(ctx->db, (int)NUM2INT(timeout)));

  return self;
}

int rb_comparator_func(void * ctx, int a_len, const void * a, int b_len, const void * b)
{
  VALUE comparator;
  VALUE a_str;
  VALUE b_str;
  VALUE comparison;
#ifdef HAVE_RUBY_ENCODING_H
  rb_encoding * internal_encoding;

  internal_encoding = rb_default_internal_encoding();
#endif

  comparator = (VALUE)ctx;
  a_str = rb_str_new((const char *)a, a_len);
  b_str = rb_str_new((const char *)b, b_len);

#ifdef HAVE_RUBY_ENCODING_H
  rb_enc_associate_index(a_str, rb_utf8_encindex());
  rb_enc_associate_index(b_str, rb_utf8_encindex());

  if(internal_encoding) {
    a_str = rb_str_export_to_enc(a_str, internal_encoding);
    b_str = rb_str_export_to_enc(b_str, internal_encoding);
  }
#endif

  comparison = rb_funcall(comparator, rb_intern("compare"), 2, a_str, b_str);

  return NUM2INT(comparison);
}

/* call-seq: db.collation(name, comparator)
 *
 * Add a collation with name +name+, and a +comparator+ object.  The
 * +comparator+ object should implement a method called "compare" that takes
 * two parameters and returns an integer less than, equal to, or greater than
 * 0.
 */
static VALUE collation(VALUE self, VALUE name, VALUE comparator)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  CHECK(ctx->db, sqlite3_create_collation(
        ctx->db,
        StringValuePtr(name),
        SQLITE_UTF8,
        (void *)comparator,
        NIL_P(comparator) ? NULL : rb_comparator_func));

  /* Make sure our comparator doesn't get garbage collected. */
  rb_hash_aset(rb_iv_get(self, "@collations"), name, comparator);

  return self;
}

#ifdef HAVE_SQLITE3_LOAD_EXTENSION
/* call-seq: db.load_extension(file)
 *
 * Loads an SQLite extension library from the named file. Extension
 * loading must be enabled using db.enable_load_extension(true) prior
 * to calling this API.
 */
static VALUE load_extension(VALUE self, VALUE file)
{
  sqlite3RubyPtr ctx;
  int status;
  char *errMsg;
  VALUE errexp;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  status = sqlite3_load_extension(ctx->db, RSTRING_PTR(file), 0, &errMsg);
  if (status != SQLITE_OK)
  {
    errexp = rb_exc_new2(rb_eRuntimeError, errMsg);
    sqlite3_free(errMsg);
    rb_exc_raise(errexp);
  }

  return self;
}
#endif

#ifdef HAVE_SQLITE3_ENABLE_LOAD_EXTENSION
/* call-seq: db.enable_load_extension(onoff)
 *
 * Enable or disable extension loading.
 */
static VALUE enable_load_extension(VALUE self, VALUE onoff)
{
  sqlite3RubyPtr ctx;
  int onoffparam;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  if (Qtrue == onoff) {
    onoffparam = 1;
  } else if (Qfalse == onoff) {
    onoffparam = 0;
  } else {
    onoffparam = (int)NUM2INT(onoff);
  }

  CHECK(ctx->db, sqlite3_enable_load_extension(ctx->db, onoffparam));

  return self;
}
#endif

#ifdef HAVE_RUBY_ENCODING_H
static int enc_cb(void * _self, int UNUSED(columns), char **data, char **UNUSED(names))
{
  VALUE self = (VALUE)_self;

  int index = rb_enc_find_index(data[0]);
  rb_encoding * e = rb_enc_from_index(index);
  rb_iv_set(self, "@encoding", rb_enc_from_encoding(e));

  return 0;
}
#else
static int enc_cb(void * _self, int UNUSED(columns), char **data, char **UNUSED(names))
{
  VALUE self = (VALUE)_self;

  rb_iv_set(self, "@encoding", rb_str_new2(data[0]));

  return 0;
}
#endif

/* call-seq: db.encoding
 *
 * Fetch the encoding set on this database
 */
static VALUE db_encoding(VALUE self)
{
  sqlite3RubyPtr ctx;
  VALUE enc;

  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  enc = rb_iv_get(self, "@encoding");

  if(NIL_P(enc)) {
    sqlite3_exec(ctx->db, "PRAGMA encoding", enc_cb, (void *)self, NULL);
  }

  return rb_iv_get(self, "@encoding");
}

/* call-seq: db.transaction_active?
 *
 * Returns +true+ if there is a transaction active, and +false+ otherwise.
 *
 */
static VALUE transaction_active_p(VALUE self)
{
  sqlite3RubyPtr ctx;
  Data_Get_Struct(self, sqlite3Ruby, ctx);
  REQUIRE_OPEN_DB(ctx);

  return sqlite3_get_autocommit(ctx->db) ? Qfalse : Qtrue;
}

void init_sqlite3_database()
{
  ID id_utf16, id_results_as_hash, id_type_translation;
#if 0
  VALUE mSqlite3 = rb_define_module("SQLite3");
#endif
  cSqlite3Database = rb_define_class_under(mSqlite3, "Database", rb_cObject);

  rb_define_alloc_func(cSqlite3Database, allocate);
  rb_define_method(cSqlite3Database, "initialize", initialize, -1);
  rb_define_method(cSqlite3Database, "collation", collation, 2);
  rb_define_method(cSqlite3Database, "close", sqlite3_rb_close, 0);
  rb_define_method(cSqlite3Database, "closed?", closed_p, 0);
  rb_define_method(cSqlite3Database, "total_changes", total_changes, 0);
  rb_define_method(cSqlite3Database, "trace", trace, -1);
  rb_define_method(cSqlite3Database, "last_insert_row_id", last_insert_row_id, 0);
  rb_define_method(cSqlite3Database, "define_function", define_function, 1);
  rb_define_method(cSqlite3Database, "define_aggregator", define_aggregator, 2);
  rb_define_method(cSqlite3Database, "interrupt", interrupt, 0);
  rb_define_method(cSqlite3Database, "errmsg", errmsg, 0);
  rb_define_method(cSqlite3Database, "errcode", errcode_, 0);
  rb_define_method(cSqlite3Database, "complete?", complete_p, 1);
  rb_define_method(cSqlite3Database, "changes", changes, 0);
  rb_define_method(cSqlite3Database, "authorizer=", set_authorizer, 1);
  rb_define_method(cSqlite3Database, "busy_handler", busy_handler, -1);
  rb_define_method(cSqlite3Database, "busy_timeout=", set_busy_timeout, 1);
  rb_define_method(cSqlite3Database, "transaction_active?", transaction_active_p, 0);

#ifdef HAVE_SQLITE3_LOAD_EXTENSION
  rb_define_method(cSqlite3Database, "load_extension", load_extension, 1);
#endif

#ifdef HAVE_SQLITE3_ENABLE_LOAD_EXTENSION
  rb_define_method(cSqlite3Database, "enable_load_extension", enable_load_extension, 1);
#endif

  rb_define_method(cSqlite3Database, "encoding", db_encoding, 0);

  id_utf16 = rb_intern("utf16");
  sym_utf16 = ID2SYM(id_utf16);
  id_results_as_hash = rb_intern("results_as_hash");
  sym_results_as_hash = ID2SYM(id_results_as_hash);
  id_type_translation = rb_intern("type_translation");
  sym_type_translation = ID2SYM(id_type_translation);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       database.h                                                                                          0100644 0001750 0001750 00000000367 12566211336 042330  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #ifndef SQLITE3_DATABASE_RUBY
#define SQLITE3_DATABASE_RUBY

#include <sqlite3_ruby.h>

struct _sqlite3Ruby {
  sqlite3 *db;
};

typedef struct _sqlite3Ruby sqlite3Ruby;
typedef sqlite3Ruby * sqlite3RubyPtr;

void init_sqlite3_database();

#endif
                                                                                                                                                                                                                                                                         exception.c                                                                                         0100644 0001750 0001750 00000005273 12566211336 042556  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #include <sqlite3_ruby.h>

void rb_sqlite3_raise(sqlite3 * db, int status)
{
  VALUE klass = Qnil;

  switch(status) {
    case SQLITE_OK:
      return;
      break;
    case SQLITE_ERROR:
      klass = rb_path2class("SQLite3::SQLException");
      break;
    case SQLITE_INTERNAL:
      klass = rb_path2class("SQLite3::InternalException");
      break;
    case SQLITE_PERM:
      klass = rb_path2class("SQLite3::PermissionException");
      break;
    case SQLITE_ABORT:
      klass = rb_path2class("SQLite3::AbortException");
      break;
    case SQLITE_BUSY:
      klass = rb_path2class("SQLite3::BusyException");
      break;
    case SQLITE_LOCKED:
      klass = rb_path2class("SQLite3::LockedException");
      break;
    case SQLITE_NOMEM:
      klass = rb_path2class("SQLite3::MemoryException");
      break;
    case SQLITE_READONLY:
      klass = rb_path2class("SQLite3::ReadOnlyException");
      break;
    case SQLITE_INTERRUPT:
      klass = rb_path2class("SQLite3::InterruptException");
      break;
    case SQLITE_IOERR:
      klass = rb_path2class("SQLite3::IOException");
      break;
    case SQLITE_CORRUPT:
      klass = rb_path2class("SQLite3::CorruptException");
      break;
    case SQLITE_NOTFOUND:
      klass = rb_path2class("SQLite3::NotFoundException");
      break;
    case SQLITE_FULL:
      klass = rb_path2class("SQLite3::FullException");
      break;
    case SQLITE_CANTOPEN:
      klass = rb_path2class("SQLite3::CantOpenException");
      break;
    case SQLITE_PROTOCOL:
      klass = rb_path2class("SQLite3::ProtocolException");
      break;
    case SQLITE_EMPTY:
      klass = rb_path2class("SQLite3::EmptyException");
      break;
    case SQLITE_SCHEMA:
      klass = rb_path2class("SQLite3::SchemaChangedException");
      break;
    case SQLITE_TOOBIG:
      klass = rb_path2class("SQLite3::TooBigException");
      break;
    case SQLITE_CONSTRAINT:
      klass = rb_path2class("SQLite3::ConstraintException");
      break;
    case SQLITE_MISMATCH:
      klass = rb_path2class("SQLite3::MismatchException");
      break;
    case SQLITE_MISUSE:
      klass = rb_path2class("SQLite3::MisuseException");
      break;
    case SQLITE_NOLFS:
      klass = rb_path2class("SQLite3::UnsupportedException");
      break;
    case SQLITE_AUTH:
      klass = rb_path2class("SQLite3::AuthorizationException");
      break;
    case SQLITE_FORMAT:
      klass = rb_path2class("SQLite3::FormatException");
      break;
    case SQLITE_RANGE:
      klass = rb_path2class("SQLite3::RangeException");
      break;
    case SQLITE_NOTADB:
      klass = rb_path2class("SQLite3::NotADatabaseException");
      break;
    default:
      klass = rb_eRuntimeError;
  }

  rb_raise(klass, "%s", sqlite3_errmsg(db));
}
                                                                                                                                                                                                                                                                                                                                     exception.h                                                                                         0100644 0001750 0001750 00000000265 12566211336 042557  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #ifndef SQLITE3_EXCEPTION_RUBY
#define SQLITE3_EXCEPTION_RUBY

#define CHECK(_db, _status) rb_sqlite3_raise(_db, _status);

void rb_sqlite3_raise(sqlite3 * db, int status);

#endif
                                                                                                                                                                                                                                                                                                                                           extconf.rb                                                                                          0100644 0001750 0001750 00000002533 12566211336 042403  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       ENV['RC_ARCHS'] = '' if RUBY_PLATFORM =~ /darwin/

require 'mkmf'

# :stopdoc:

RbConfig::MAKEFILE_CONFIG['CC'] = ENV['CC'] if ENV['CC']

# --with-sqlite3-{dir,include,lib}
dir_config("sqlite3")

# prioritize local builds
if enable_config("local", false)
  $LDFLAGS = ENV.fetch("LDFLAGS", "")
end

if RbConfig::CONFIG["host_os"] =~ /mswin/
  $CFLAGS << ' -W3'
end

def asplode missing
  if RUBY_PLATFORM =~ /mingw|mswin/
    abort "#{missing} is missing. Install SQLite3 from " +
          "http://www.sqlite.org/ first."
  else
    abort <<-error
#{missing} is missing. Try 'port install sqlite3 +universal'
or 'yum install sqlite-devel' and check your shared library search path (the
location where your sqlite3 shared library is located).
    error
  end
end

asplode('sqlite3.h')  unless find_header  'sqlite3.h'
asplode('sqlite3') unless find_library 'sqlite3', 'sqlite3_libversion_number'

# Functions defined in 1.9 but not 1.8
have_func('rb_proc_arity')

# These functions may not be defined
have_func('sqlite3_initialize')
have_func('sqlite3_backup_init')
have_func('sqlite3_column_database_name')
have_func('sqlite3_enable_load_extension')
have_func('sqlite3_load_extension')
have_func('sqlite3_open_v2')
have_func('sqlite3_prepare_v2')
have_type('sqlite3_int64', 'sqlite3.h')
have_type('sqlite3_uint64', 'sqlite3.h')

create_makefile('sqlite3/sqlite3_native')
                                                                                                                                                                     sqlite3.c                                                                                           0100644 0001750 0001750 00000002000 12566211336 042125  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #include <sqlite3_ruby.h>

VALUE mSqlite3;
VALUE cSqlite3Blob;

static VALUE libversion(VALUE UNUSED(klass))
{
  return INT2NUM(sqlite3_libversion_number());
}

void Init_sqlite3_native()
{
  /*
   * SQLite3 is a wrapper around the popular database
   * sqlite[http://sqlite.org].
   *
   * For an example of usage, see SQLite3::Database.
   */
  mSqlite3     = rb_define_module("SQLite3");

  /* A class for differentiating between strings and blobs, when binding them
   * into statements.
   */
  cSqlite3Blob = rb_define_class_under(mSqlite3, "Blob", rb_cString);

  /* Initialize the sqlite3 library */
#ifdef HAVE_SQLITE3_INITIALIZE
  sqlite3_initialize();
#endif

  init_sqlite3_database();
  init_sqlite3_statement();
#ifdef HAVE_SQLITE3_BACKUP_INIT
  init_sqlite3_backup();
#endif

  rb_define_singleton_method(mSqlite3, "libversion", libversion, 0);
  rb_define_const(mSqlite3, "SQLITE_VERSION", rb_str_new2(SQLITE_VERSION));
  rb_define_const(mSqlite3, "SQLITE_VERSION_NUMBER", INT2FIX(SQLITE_VERSION_NUMBER));
}
sqlite3_ruby.h                                                                                      0100644 0001750 0001750 00000002130 12566211336 043177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #ifndef SQLITE3_RUBY
#define SQLITE3_RUBY

#include <ruby.h>

#ifdef UNUSED
#elif defined(__GNUC__)
# define UNUSED(x) UNUSED_ ## x __attribute__((unused))
#elif defined(__LCLINT__)
# define UNUSED(x) /*@unused@*/ x
#else
# define UNUSED(x) x
#endif

#ifndef RBIGNUM_LEN
#define RBIGNUM_LEN(x) RBIGNUM(x)->len
#endif

#ifdef HAVE_RUBY_ENCODING_H
#include <ruby/encoding.h>

#define UTF8_P(_obj) (rb_enc_get_index(_obj) == rb_utf8_encindex())
#define UTF16_LE_P(_obj) (rb_enc_get_index(_obj) == rb_enc_find_index("UTF-16LE"))
#define UTF16_BE_P(_obj) (rb_enc_get_index(_obj) == rb_enc_find_index("UTF-16BE"))
#define SQLITE3_UTF8_STR_NEW2(_obj) \
    (rb_enc_associate_index(rb_str_new2(_obj), rb_utf8_encindex()))

#else

#define SQLITE3_UTF8_STR_NEW2(_obj) (rb_str_new2(_obj))

#endif


#include <sqlite3.h>

#ifndef HAVE_TYPE_SQLITE3_INT64
typedef sqlite_int64 sqlite3_int64;
#endif

#ifndef HAVE_TYPE_SQLITE3_UINT64
typedef sqlite_uint64 sqlite3_uint64;
#endif

extern VALUE mSqlite3;
extern VALUE cSqlite3Blob;

#include <database.h>
#include <statement.h>
#include <exception.h>
#include <backup.h>

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                        statement.c                                                                                         0100644 0001750 0001750 00000025741 12566211336 042566  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #include <sqlite3_ruby.h>

#define REQUIRE_OPEN_STMT(_ctxt) \
  if(!_ctxt->st) \
    rb_raise(rb_path2class("SQLite3::Exception"), "cannot use a closed statement");

VALUE cSqlite3Statement;

static void deallocate(void * ctx)
{
  sqlite3StmtRubyPtr c = (sqlite3StmtRubyPtr)ctx;
  xfree(c);
}

static VALUE allocate(VALUE klass)
{
  sqlite3StmtRubyPtr ctx = xcalloc((size_t)1, sizeof(sqlite3StmtRuby));
  ctx->st     = NULL;
  ctx->done_p = 0;

  return Data_Wrap_Struct(klass, NULL, deallocate, ctx);
}

/* call-seq: SQLite3::Statement.new(db, sql)
 *
 * Create a new statement attached to the given Database instance, and which
 * encapsulates the given SQL text. If the text contains more than one
 * statement (i.e., separated by semicolons), then the #remainder property
 * will be set to the trailing text.
 */
static VALUE initialize(VALUE self, VALUE db, VALUE sql)
{
  sqlite3RubyPtr db_ctx;
  sqlite3StmtRubyPtr ctx;
  const char *tail = NULL;
  int status;

  StringValue(sql);

  Data_Get_Struct(db, sqlite3Ruby, db_ctx);
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);

  if(!db_ctx->db)
    rb_raise(rb_eArgError, "prepare called on a closed database");

#ifdef HAVE_RUBY_ENCODING_H
  if(!UTF8_P(sql)) {
    sql               = rb_str_export_to_enc(sql, rb_utf8_encoding());
  }
#endif

#ifdef HAVE_SQLITE3_PREPARE_V2
  status = sqlite3_prepare_v2(
#else
  status = sqlite3_prepare(
#endif
      db_ctx->db,
      (const char *)StringValuePtr(sql),
      (int)RSTRING_LEN(sql),
      &ctx->st,
      &tail
  );

  CHECK(db_ctx->db, status);

  rb_iv_set(self, "@connection", db);
  rb_iv_set(self, "@remainder", rb_str_new2(tail));
  rb_iv_set(self, "@columns", Qnil);
  rb_iv_set(self, "@types", Qnil);

  return self;
}

/* call-seq: stmt.close
 *
 * Closes the statement by finalizing the underlying statement
 * handle. The statement must not be used after being closed.
 */
static VALUE sqlite3_rb_close(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  sqlite3 * db;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);

  REQUIRE_OPEN_STMT(ctx);

  sqlite3_finalize(ctx->st);
  ctx->st = NULL;

  return self;
}

/* call-seq: stmt.closed?
 *
 * Returns true if the statement has been closed.
 */
static VALUE closed_p(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);

  if(!ctx->st) return Qtrue;

  return Qfalse;
}

static VALUE step(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  sqlite3_stmt *stmt;
  int value, length;
  VALUE list;
#ifdef HAVE_RUBY_ENCODING_H
  rb_encoding * internal_encoding;
  int enc_index;
#endif

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);

  REQUIRE_OPEN_STMT(ctx);

  if(ctx->done_p) return Qnil;

#ifdef HAVE_RUBY_ENCODING_H
  {
      VALUE db          = rb_iv_get(self, "@connection");
      VALUE encoding    = rb_funcall(db, rb_intern("encoding"), 0);
      enc_index = NIL_P(encoding) ? rb_utf8_encindex() : rb_to_encoding_index(encoding);
      internal_encoding = rb_default_internal_encoding();
  }
#endif

  stmt = ctx->st;

  value = sqlite3_step(stmt);
  length = sqlite3_column_count(stmt);
  list = rb_ary_new2((long)length);

  switch(value) {
    case SQLITE_ROW:
      {
        int i;
        for(i = 0; i < length; i++) {
          switch(sqlite3_column_type(stmt, i)) {
            case SQLITE_INTEGER:
              rb_ary_push(list, LL2NUM(sqlite3_column_int64(stmt, i)));
              break;
            case SQLITE_FLOAT:
              rb_ary_push(list, rb_float_new(sqlite3_column_double(stmt, i)));
              break;
            case SQLITE_TEXT:
              {
                VALUE str = rb_tainted_str_new(
                    (const char *)sqlite3_column_text(stmt, i),
                    (long)sqlite3_column_bytes(stmt, i)
                );
#ifdef HAVE_RUBY_ENCODING_H
                rb_enc_associate_index(str, enc_index);
                if(internal_encoding)
                  str = rb_str_export_to_enc(str, internal_encoding);
#endif
                rb_ary_push(list, str);
              }
              break;
            case SQLITE_BLOB:
              {
                VALUE str = rb_tainted_str_new(
                    (const char *)sqlite3_column_blob(stmt, i),
                    (long)sqlite3_column_bytes(stmt, i)
                );
                rb_ary_push(list, str);
              }
              break;
            case SQLITE_NULL:
              rb_ary_push(list, Qnil);
              break;
            default:
              rb_raise(rb_eRuntimeError, "bad type");
          }
        }
      }
      break;
    case SQLITE_DONE:
      ctx->done_p = 1;
      return Qnil;
      break;
    default:
      CHECK(sqlite3_db_handle(ctx->st), value);
  }

  return list;
}

/* call-seq: stmt.bind_param(key, value)
 *
 * Binds value to the named (or positional) placeholder. If +param+ is a
 * Fixnum, it is treated as an index for a positional placeholder.
 * Otherwise it is used as the name of the placeholder to bind to.
 *
 * See also #bind_params.
 */
static VALUE bind_param(VALUE self, VALUE key, VALUE value)
{
  sqlite3StmtRubyPtr ctx;
  int status;
  int index;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  switch(TYPE(key)) {
    case T_SYMBOL:
      key = rb_funcall(key, rb_intern("to_s"), 0);
    case T_STRING:
      if(RSTRING_PTR(key)[0] != ':') key = rb_str_plus(rb_str_new2(":"), key);
      index = sqlite3_bind_parameter_index(ctx->st, StringValuePtr(key));
      break;
    default:
      index = (int)NUM2INT(key);
  }

  if(index == 0)
    rb_raise(rb_path2class("SQLite3::Exception"), "no such bind parameter");

  switch(TYPE(value)) {
    case T_STRING:
      if(CLASS_OF(value) == cSqlite3Blob
#ifdef HAVE_RUBY_ENCODING_H
              || rb_enc_get_index(value) == rb_ascii8bit_encindex()
#endif
        ) {
        status = sqlite3_bind_blob(
            ctx->st,
            index,
            (const char *)StringValuePtr(value),
            (int)RSTRING_LEN(value),
            SQLITE_TRANSIENT
            );
      } else {
#ifdef HAVE_RUBY_ENCODING_H
        if(!UTF8_P(value)) {
              VALUE db          = rb_iv_get(self, "@connection");
              VALUE encoding    = rb_funcall(db, rb_intern("encoding"), 0);
              rb_encoding * enc = rb_to_encoding(encoding);
              value = rb_str_export_to_enc(value, enc);
          }
#endif

        status = sqlite3_bind_text(
            ctx->st,
            index,
            (const char *)StringValuePtr(value),
            (int)RSTRING_LEN(value),
            SQLITE_TRANSIENT
            );
      }
      break;
    case T_BIGNUM:
      if (RBIGNUM_LEN(value) * SIZEOF_BDIGITS <= 8) {
          status = sqlite3_bind_int64(ctx->st, index, (sqlite3_int64)NUM2LL(value));
          break;
      }
    case T_FLOAT:
      status = sqlite3_bind_double(ctx->st, index, NUM2DBL(value));
      break;
    case T_FIXNUM:
      status = sqlite3_bind_int64(ctx->st, index, (sqlite3_int64)FIX2LONG(value));
      break;
    case T_NIL:
      status = sqlite3_bind_null(ctx->st, index);
      break;
    default:
      rb_raise(rb_eRuntimeError, "can't prepare %s",
          rb_class2name(CLASS_OF(value)));
      break;
  }

  CHECK(sqlite3_db_handle(ctx->st), status);

  return self;
}

/* call-seq: stmt.reset!
 *
 * Resets the statement. This is typically done internally, though it might
 * occassionally be necessary to manually reset the statement.
 */
static VALUE reset_bang(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  int status;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  status = sqlite3_reset(ctx->st);

  ctx->done_p = 0;

  return self;
}

/* call-seq: stmt.clear_bindings!
 *
 * Resets the statement. This is typically done internally, though it might
 * occassionally be necessary to manually reset the statement.
 */
static VALUE clear_bindings(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  int status;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  status = sqlite3_clear_bindings(ctx->st);

  ctx->done_p = 0;

  return self;
}

/* call-seq: stmt.done?
 *
 * returns true if all rows have been returned.
 */
static VALUE done_p(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);

  if(ctx->done_p) return Qtrue;
  return Qfalse;
}

/* call-seq: stmt.column_count
 *
 * Returns the number of columns to be returned for this statement
 */
static VALUE column_count(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  return INT2NUM((long)sqlite3_column_count(ctx->st));
}

/* call-seq: stmt.column_name(index)
 *
 * Get the column name at +index+.  0 based.
 */
static VALUE column_name(VALUE self, VALUE index)
{
  sqlite3StmtRubyPtr ctx;
  const char * name;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  name = sqlite3_column_name(ctx->st, (int)NUM2INT(index));

  if(name) return SQLITE3_UTF8_STR_NEW2(name);
  return Qnil;
}

/* call-seq: stmt.column_decltype(index)
 *
 * Get the column type at +index+.  0 based.
 */
static VALUE column_decltype(VALUE self, VALUE index)
{
  sqlite3StmtRubyPtr ctx;
  const char * name;

  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  name = sqlite3_column_decltype(ctx->st, (int)NUM2INT(index));

  if(name) return rb_str_new2(name);
  return Qnil;
}

/* call-seq: stmt.bind_parameter_count
 *
 * Return the number of bind parameters
 */
static VALUE bind_parameter_count(VALUE self)
{
  sqlite3StmtRubyPtr ctx;
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  return INT2NUM((long)sqlite3_bind_parameter_count(ctx->st));
}

#ifdef HAVE_SQLITE3_COLUMN_DATABASE_NAME

/* call-seq: stmt.database_name(column_index)
 *
 * Return the database name for the column at +column_index+
 */
static VALUE database_name(VALUE self, VALUE index)
{
  sqlite3StmtRubyPtr ctx;
  Data_Get_Struct(self, sqlite3StmtRuby, ctx);
  REQUIRE_OPEN_STMT(ctx);

  return SQLITE3_UTF8_STR_NEW2(
      sqlite3_column_database_name(ctx->st, NUM2INT(index)));
}

#endif

void init_sqlite3_statement()
{
  cSqlite3Statement = rb_define_class_under(mSqlite3, "Statement", rb_cObject);

  rb_define_alloc_func(cSqlite3Statement, allocate);
  rb_define_method(cSqlite3Statement, "initialize", initialize, 2);
  rb_define_method(cSqlite3Statement, "close", sqlite3_rb_close, 0);
  rb_define_method(cSqlite3Statement, "closed?", closed_p, 0);
  rb_define_method(cSqlite3Statement, "bind_param", bind_param, 2);
  rb_define_method(cSqlite3Statement, "reset!", reset_bang, 0);
  rb_define_method(cSqlite3Statement, "clear_bindings!", clear_bindings, 0);
  rb_define_method(cSqlite3Statement, "step", step, 0);
  rb_define_method(cSqlite3Statement, "done?", done_p, 0);
  rb_define_method(cSqlite3Statement, "column_count", column_count, 0);
  rb_define_method(cSqlite3Statement, "column_name", column_name, 1);
  rb_define_method(cSqlite3Statement, "column_decltype", column_decltype, 1);
  rb_define_method(cSqlite3Statement, "bind_parameter_count", bind_parameter_count, 0);

#ifdef HAVE_SQLITE3_COLUMN_DATABASE_NAME
  rb_define_method(cSqlite3Statement, "database_name", database_name, 1);
#endif
}
                               statement.h                                                                                         0100644 0001750 0001750 00000000441 12566211336 042561  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/ext/sqlite3                       #ifndef SQLITE3_STATEMENT_RUBY
#define SQLITE3_STATEMENT_RUBY

#include <sqlite3_ruby.h>

struct _sqlite3StmtRuby {
  sqlite3_stmt *st;
  int done_p;
};

typedef struct _sqlite3StmtRuby sqlite3StmtRuby;
typedef sqlite3StmtRuby * sqlite3StmtRubyPtr;

void init_sqlite3_statement();

#endif
                                                                                                                                                                                                                               faq/                                                                                                0040755 0001750 0001750 00000000000 12612224746 036774  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7                                   faq.rb                                                                                              0100644 0001750 0001750 00000006146 12566211336 040073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/faq                               require 'yaml'
require 'redcloth'

def process_faq_list( faqs )
  puts "<ul>"
  faqs.each do |faq|
    process_faq_list_item faq
  end
  puts "</ul>"
end

def process_faq_list_item( faq )
  question = faq.keys.first
  answer = faq.values.first

  print "<li>"

  question_text = RedCloth.new(question).to_html.gsub( %r{</?p>},"" )
  if answer.is_a?( Array )
    puts question_text
    process_faq_list answer
  else
    print "<a href='##{question.object_id}'>#{question_text}</a>"
  end

  puts "</li>"
end

def process_faq_descriptions( faqs, path=nil )
  faqs.each do |faq|
    process_faq_description faq, path
  end
end

def process_faq_description( faq, path )
  question = faq.keys.first
  path = ( path ? path + " " : "" ) + question
  answer = faq.values.first

  if answer.is_a?( Array )
    process_faq_descriptions( answer, path )
  else
    title = RedCloth.new( path ).to_html.gsub( %r{</?p>}, "" )
    answer = RedCloth.new( answer || "" )

    puts "<a name='#{question.object_id}'></a>"
    puts "<div class='faq-title'>#{title}</div>"
    puts "<div class='faq-answer'>#{add_api_links(answer.to_html)}</div>"
  end
end

API_OBJECTS = [ "Database", "Statement", "ResultSet",
  "ParsedStatement", "Pragmas", "Translator" ].inject( "(" ) { |acc,name|
    acc << "|" if acc.length > 1
    acc << name
    acc
  } + ")"

def add_api_links( text )
  text.gsub( /#{API_OBJECTS}(#(\w+))?/ ) do
    disp_obj = obj = $1

    case obj
      when "Pragmas"; disp_obj = "Database"
    end

    method = $3
    s = "<a href='http://sqlite-ruby.rubyforge.org/classes/SQLite/#{obj}.html'>#{disp_obj}"
    s << "##{method}" if method
    s << "</a>"
    s
  end
end

faqs = YAML.load( File.read( "faq.yml" ) )

puts <<-EOF
<html>
  <head>
    <title>SQLite3/Ruby FAQ</title>
    <style type="text/css">
      a, a:visited, a:active {
        color: #00F;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }

      .faq-list {
        color: #000;
        font-family: vera-sans, verdana, arial, sans-serif;
      }

      .faq-title {
        background: #007;
        color: #FFF;
        font-family: vera-sans, verdana, arial, sans-serif;
        padding-left: 1em;
        padding-top: 0.5em;
        padding-bottom: 0.5em;
        font-weight: bold;
        font-size: large;
        border: 1px solid #000;
      }

      .faq-answer {
        margin-left: 1em;
        color: #000;
        font-family: vera-sans, verdana, arial, sans-serif;
      }

      .faq-answer pre {
        margin-left: 1em;
        color: #000;
        background: #FFE;
        font-size: normal;
        border: 1px dotted #CCC;
        padding: 1em;
      }

      h1 {
        background: #005;
        color: #FFF;
        font-family: vera-sans, verdana, arial, sans-serif;
        padding-left: 1em;
        padding-top: 1em;
        padding-bottom: 1em;
        font-weight: bold;
        font-size: x-large;
        border: 1px solid #00F;
      }
    </style>
  </head>
  <body>
  <h1>SQLite/Ruby FAQ</h1>
  <div class="faq-list">
EOF

process_faq_list( faqs )
puts "</div>"
process_faq_descriptions( faqs )

puts "</body></html>"
                                                                                                                                                                                                                                                                                                                                                                                                                          lib/                                                                                                0040755 0001750 0001750 00000000000 12612224746 036773  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7                                   sqlite3/                                                                                            0040755 0001750 0001750 00000000000 12612224746 040357  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib                               constants.rb                                                                                        0100644 0001750 0001750 00000003321 12566211336 042713  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       module SQLite3 ; module Constants

  module TextRep
    UTF8    = 1
    UTF16LE = 2
    UTF16BE = 3
    UTF16   = 4
    ANY     = 5
  end

  module ColumnType
    INTEGER = 1
    FLOAT   = 2
    TEXT    = 3
    BLOB    = 4
    NULL    = 5
  end

  module ErrorCode
    OK         =  0   # Successful result
    ERROR      =  1   # SQL error or missing database
    INTERNAL   =  2   # An internal logic error in SQLite
    PERM       =  3   # Access permission denied
    ABORT      =  4   # Callback routine requested an abort
    BUSY       =  5   # The database file is locked
    LOCKED     =  6   # A table in the database is locked
    NOMEM      =  7   # A malloc() failed
    READONLY   =  8   # Attempt to write a readonly database
    INTERRUPT  =  9   # Operation terminated by sqlite_interrupt()
    IOERR      = 10   # Some kind of disk I/O error occurred
    CORRUPT    = 11   # The database disk image is malformed
    NOTFOUND   = 12   # (Internal Only) Table or record not found
    FULL       = 13   # Insertion failed because database is full
    CANTOPEN   = 14   # Unable to open the database file
    PROTOCOL   = 15   # Database lock protocol error
    EMPTY      = 16   # (Internal Only) Database table is empty
    SCHEMA     = 17   # The database schema changed
    TOOBIG     = 18   # Too much data for one row of a table
    CONSTRAINT = 19   # Abort due to contraint violation
    MISMATCH   = 20   # Data type mismatch
    MISUSE     = 21   # Library used incorrectly
    NOLFS      = 22   # Uses OS features not supported on host
    AUTH       = 23   # Authorization denied

    ROW        = 100  # sqlite_step() has another row ready
    DONE       = 101  # sqlite_step() has finished executing
  end

end ; end
                                                                                                                                                                                                                                                                                                               database.rb                                                                                         0100644 0001750 0001750 00000046617 12566211336 042462  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/constants'
require 'sqlite3/errors'
require 'sqlite3/pragmas'
require 'sqlite3/statement'
require 'sqlite3/translator'
require 'sqlite3/value'

module SQLite3

  # The Database class encapsulates a single connection to a SQLite3 database.
  # Its usage is very straightforward:
  #
  #   require 'sqlite3'
  #
  #   SQLite3::Database.new( "data.db" ) do |db|
  #     db.execute( "select * from table" ) do |row|
  #       p row
  #     end
  #   end
  #
  # It wraps the lower-level methods provides by the selected driver, and
  # includes the Pragmas module for access to various pragma convenience
  # methods.
  #
  # The Database class provides type translation services as well, by which
  # the SQLite3 data types (which are all represented as strings) may be
  # converted into their corresponding types (as defined in the schemas
  # for their tables). This translation only occurs when querying data from
  # the database--insertions and updates are all still typeless.
  #
  # Furthermore, the Database class has been designed to work well with the
  # ArrayFields module from Ara Howard. If you require the ArrayFields
  # module before performing a query, and if you have not enabled results as
  # hashes, then the results will all be indexible by field name.
  class Database
    attr_reader :collations

    include Pragmas

    class << self

      alias :open :new

      # Quotes the given string, making it safe to use in an SQL statement.
      # It replaces all instances of the single-quote character with two
      # single-quote characters. The modified string is returned.
      def quote( string )
        string.gsub( /'/, "''" )
      end

    end

    # A boolean that indicates whether rows in result sets should be returned
    # as hashes or not. By default, rows are returned as arrays.
    attr_accessor :results_as_hash

    def type_translation= value # :nodoc:
      warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling SQLite3::Database#type_translation=
SQLite3::Database#type_translation= is deprecated and will be removed
in version 2.0.0.
      eowarn
      @type_translation = value
    end
    attr_reader :type_translation # :nodoc:

    # Return the type translator employed by this database instance. Each
    # database instance has its own type translator; this allows for different
    # type handlers to be installed in each instance without affecting other
    # instances. Furthermore, the translators are instantiated lazily, so that
    # if a database does not use type translation, it will not be burdened by
    # the overhead of a useless type translator. (See the Translator class.)
    def translator
      @translator ||= Translator.new
    end

    # Installs (or removes) a block that will be invoked for every access
    # to the database. If the block returns 0 (or +nil+), the statement
    # is allowed to proceed. Returning 1 causes an authorization error to
    # occur, and returning 2 causes the access to be silently denied.
    def authorizer( &block )
      self.authorizer = block
    end

    # Returns a Statement object representing the given SQL. This does not
    # execute the statement; it merely prepares the statement for execution.
    #
    # The Statement can then be executed using Statement#execute.
    #
    def prepare sql
      stmt = SQLite3::Statement.new( self, sql )
      return stmt unless block_given?

      begin
        yield stmt
      ensure
        stmt.close
      end
    end

    # Executes the given SQL statement. If additional parameters are given,
    # they are treated as bind variables, and are bound to the placeholders in
    # the query.
    #
    # Note that if any of the values passed to this are hashes, then the
    # key/value pairs are each bound separately, with the key being used as
    # the name of the placeholder to bind the value to.
    #
    # The block is optional. If given, it will be invoked for each row returned
    # by the query. Otherwise, any results are accumulated into an array and
    # returned wholesale.
    #
    # See also #execute2, #query, and #execute_batch for additional ways of
    # executing statements.
    def execute sql, bind_vars = [], *args, &block
      # FIXME: This is a terrible hack and should be removed but is required
      # for older versions of rails
      hack = Object.const_defined?(:ActiveRecord) && sql =~ /^PRAGMA index_list/

      if bind_vars.nil? || !args.empty?
        if args.empty?
          bind_vars = []
        else
          bind_vars = [bind_vars] + args
        end

        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling SQLite3::Database#execute with nil or multiple bind params
without using an array.  Please switch to passing bind parameters as an array.
Support for bind parameters as *args will be removed in 2.0.0.
        eowarn
      end

      prepare( sql ) do |stmt|
        stmt.bind_params(bind_vars)
        columns = stmt.columns
        stmt    = ResultSet.new(self, stmt).to_a if type_translation

        if block_given?
          stmt.each do |row|
            if @results_as_hash
              yield type_translation ? row : ordered_map_for(columns, row)
            else
              yield row
            end
          end
        else
          if @results_as_hash
            stmt.map { |row|
              h = type_translation ? row : ordered_map_for(columns, row)

              # FIXME UGH TERRIBLE HACK!
              h['unique'] = h['unique'].to_s if hack

              h
            }
          else
            stmt.to_a
          end
        end
      end
    end

    # Executes the given SQL statement, exactly as with #execute. However, the
    # first row returned (either via the block, or in the returned array) is
    # always the names of the columns. Subsequent rows correspond to the data
    # from the result set.
    #
    # Thus, even if the query itself returns no rows, this method will always
    # return at least one row--the names of the columns.
    #
    # See also #execute, #query, and #execute_batch for additional ways of
    # executing statements.
    def execute2( sql, *bind_vars )
      prepare( sql ) do |stmt|
        result = stmt.execute( *bind_vars )
        if block_given?
          yield stmt.columns
          result.each { |row| yield row }
        else
          return result.inject( [ stmt.columns ] ) { |arr,row|
            arr << row; arr }
        end
      end
    end

    # Executes all SQL statements in the given string. By contrast, the other
    # means of executing queries will only execute the first statement in the
    # string, ignoring all subsequent statements. This will execute each one
    # in turn. The same bind parameters, if given, will be applied to each
    # statement.
    #
    # This always returns +nil+, making it unsuitable for queries that return
    # rows.
    def execute_batch( sql, bind_vars = [], *args )
      # FIXME: remove this stuff later
      unless [Array, Hash].include?(bind_vars.class)
        bind_vars = [bind_vars]
        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling SQLite3::Database#execute_batch with bind parameters
that are not a list of a hash.  Please switch to passing bind parameters as an
array or hash. Support for this behavior will be removed in version 2.0.0.
        eowarn
      end

      # FIXME: remove this stuff later
      if bind_vars.nil? || !args.empty?
        if args.empty?
          bind_vars = []
        else
          bind_vars = [nil] + args
        end

        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling SQLite3::Database#execute_batch with nil or multiple bind params
without using an array.  Please switch to passing bind parameters as an array.
Support for this behavior will be removed in version 2.0.0.
        eowarn
      end

      sql = sql.strip
      until sql.empty? do
        prepare( sql ) do |stmt|
          # FIXME: this should probably use sqlite3's api for batch execution
          # This implementation requires stepping over the results.
          if bind_vars.length == stmt.bind_parameter_count
            stmt.bind_params(bind_vars)
          end
          stmt.step
          sql = stmt.remainder.strip
        end
      end
      nil
    end

    # This is a convenience method for creating a statement, binding
    # paramters to it, and calling execute:
    #
    #   result = db.query( "select * from foo where a=?", [5])
    #   # is the same as
    #   result = db.prepare( "select * from foo where a=?" ).execute( 5 )
    #
    # You must be sure to call +close+ on the ResultSet instance that is
    # returned, or you could have problems with locks on the table. If called
    # with a block, +close+ will be invoked implicitly when the block
    # terminates.
    def query( sql, bind_vars = [], *args )

      if bind_vars.nil? || !args.empty?
        if args.empty?
          bind_vars = []
        else
          bind_vars = [bind_vars] + args
        end

        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling SQLite3::Database#query with nil or multiple bind params
without using an array.  Please switch to passing bind parameters as an array.
Support for this will be removed in version 2.0.0.
        eowarn
      end

      result = prepare( sql ).execute( bind_vars )
      if block_given?
        begin
          yield result
        ensure
          result.close
        end
      else
        return result
      end
    end

    # A convenience method for obtaining the first row of a result set, and
    # discarding all others. It is otherwise identical to #execute.
    #
    # See also #get_first_value.
    def get_first_row( sql, *bind_vars )
      execute( sql, *bind_vars ).first
    end

    # A convenience method for obtaining the first value of the first row of a
    # result set, and discarding all other values and rows. It is otherwise
    # identical to #execute.
    #
    # See also #get_first_row.
    def get_first_value( sql, *bind_vars )
      execute( sql, *bind_vars ) { |row| return row[0] }
      nil
    end

    alias :busy_timeout :busy_timeout=

    # Creates a new function for use in SQL statements. It will be added as
    # +name+, with the given +arity+. (For variable arity functions, use
    # -1 for the arity.)
    #
    # The block should accept at least one parameter--the FunctionProxy
    # instance that wraps this function invocation--and any other
    # arguments it needs (up to its arity).
    #
    # The block does not return a value directly. Instead, it will invoke
    # the FunctionProxy#result= method on the +func+ parameter and
    # indicate the return value that way.
    #
    # Example:
    #
    #   db.create_function( "maim", 1 ) do |func, value|
    #     if value.nil?
    #       func.result = nil
    #     else
    #       func.result = value.split(//).sort.join
    #     end
    #   end
    #
    #   puts db.get_first_value( "select maim(name) from table" )
    def create_function name, arity, text_rep=Constants::TextRep::ANY, &block
      define_function(name) do |*args|
        fp = FunctionProxy.new
        block.call(fp, *args)
        fp.result
      end
      self
    end

    # Creates a new aggregate function for use in SQL statements. Aggregate
    # functions are functions that apply over every row in the result set,
    # instead of over just a single row. (A very common aggregate function
    # is the "count" function, for determining the number of rows that match
    # a query.)
    #
    # The new function will be added as +name+, with the given +arity+. (For
    # variable arity functions, use -1 for the arity.)
    #
    # The +step+ parameter must be a proc object that accepts as its first
    # parameter a FunctionProxy instance (representing the function
    # invocation), with any subsequent parameters (up to the function's arity).
    # The +step+ callback will be invoked once for each row of the result set.
    #
    # The +finalize+ parameter must be a +proc+ object that accepts only a
    # single parameter, the FunctionProxy instance representing the current
    # function invocation. It should invoke FunctionProxy#result= to
    # store the result of the function.
    #
    # Example:
    #
    #   db.create_aggregate( "lengths", 1 ) do
    #     step do |func, value|
    #       func[ :total ] ||= 0
    #       func[ :total ] += ( value ? value.length : 0 )
    #     end
    #
    #     finalize do |func|
    #       func.result = func[ :total ] || 0
    #     end
    #   end
    #
    #   puts db.get_first_value( "select lengths(name) from table" )
    #
    # See also #create_aggregate_handler for a more object-oriented approach to
    # aggregate functions.
    def create_aggregate( name, arity, step=nil, finalize=nil,
      text_rep=Constants::TextRep::ANY, &block )

      factory = Class.new do
        def self.step( &block )
          define_method(:step, &block)
        end

        def self.finalize( &block )
          define_method(:finalize, &block)
        end
      end

      if block_given?
        factory.instance_eval(&block)
      else
        factory.class_eval do
          define_method(:step, step)
          define_method(:finalize, finalize)
        end
      end

      proxy = factory.new
      proxy.extend(Module.new {
        attr_accessor :ctx

        def step( *args )
          super(@ctx, *args)
        end

        def finalize
          super(@ctx)
        end
      })
      proxy.ctx = FunctionProxy.new
      define_aggregator(name, proxy)
    end

    # This is another approach to creating an aggregate function (see
    # #create_aggregate). Instead of explicitly specifying the name,
    # callbacks, arity, and type, you specify a factory object
    # (the "handler") that knows how to obtain all of that information. The
    # handler should respond to the following messages:
    #
    # +arity+:: corresponds to the +arity+ parameter of #create_aggregate. This
    #           message is optional, and if the handler does not respond to it,
    #           the function will have an arity of -1.
    # +name+:: this is the name of the function. The handler _must_ implement
    #          this message.
    # +new+:: this must be implemented by the handler. It should return a new
    #         instance of the object that will handle a specific invocation of
    #         the function.
    #
    # The handler instance (the object returned by the +new+ message, described
    # above), must respond to the following messages:
    #
    # +step+:: this is the method that will be called for each step of the
    #          aggregate function's evaluation. It should implement the same
    #          signature as the +step+ callback for #create_aggregate.
    # +finalize+:: this is the method that will be called to finalize the
    #              aggregate function's evaluation. It should implement the
    #              same signature as the +finalize+ callback for
    #              #create_aggregate.
    #
    # Example:
    #
    #   class LengthsAggregateHandler
    #     def self.arity; 1; end
    #
    #     def initialize
    #       @total = 0
    #     end
    #
    #     def step( ctx, name )
    #       @total += ( name ? name.length : 0 )
    #     end
    #
    #     def finalize( ctx )
    #       ctx.result = @total
    #     end
    #   end
    #
    #   db.create_aggregate_handler( LengthsAggregateHandler )
    #   puts db.get_first_value( "select lengths(name) from A" )
    def create_aggregate_handler( handler )
      proxy = Class.new do
        def initialize handler
          @handler  = handler
          @fp       = FunctionProxy.new
        end

        def step( *args )
          @handler.step(@fp, *args)
        end

        def finalize
          @handler.finalize @fp
          @fp.result
        end
      end
      define_aggregator(handler.name, proxy.new(handler.new))
      self
    end

    # Begins a new transaction. Note that nested transactions are not allowed
    # by SQLite, so attempting to nest a transaction will result in a runtime
    # exception.
    #
    # The +mode+ parameter may be either <tt>:deferred</tt> (the default),
    # <tt>:immediate</tt>, or <tt>:exclusive</tt>.
    #
    # If a block is given, the database instance is yielded to it, and the
    # transaction is committed when the block terminates. If the block
    # raises an exception, a rollback will be performed instead. Note that if
    # a block is given, #commit and #rollback should never be called
    # explicitly or you'll get an error when the block terminates.
    #
    # If a block is not given, it is the caller's responsibility to end the
    # transaction explicitly, either by calling #commit, or by calling
    # #rollback.
    def transaction( mode = :deferred )
      execute "begin #{mode.to_s} transaction"

      if block_given?
        abort = false
        begin
          yield self
        rescue ::Object
          abort = true
          raise
        ensure
          abort and rollback or commit
        end
      end

      true
    end

    # Commits the current transaction. If there is no current transaction,
    # this will cause an error to be raised. This returns +true+, in order
    # to allow it to be used in idioms like
    # <tt>abort? and rollback or commit</tt>.
    def commit
      execute "commit transaction"
      true
    end

    # Rolls the current transaction back. If there is no current transaction,
    # this will cause an error to be raised. This returns +true+, in order
    # to allow it to be used in idioms like
    # <tt>abort? and rollback or commit</tt>.
    def rollback
      execute "rollback transaction"
      true
    end

    # Returns +true+ if the database has been open in readonly mode
    # A helper to check before performing any operation
    def readonly?
      @readonly
    end

    # A helper class for dealing with custom functions (see #create_function,
    # #create_aggregate, and #create_aggregate_handler). It encapsulates the
    # opaque function object that represents the current invocation. It also
    # provides more convenient access to the API functions that operate on
    # the function object.
    #
    # This class will almost _always_ be instantiated indirectly, by working
    # with the create methods mentioned above.
    class FunctionProxy
      attr_accessor :result

      # Create a new FunctionProxy that encapsulates the given +func+ object.
      # If context is non-nil, the functions context will be set to that. If
      # it is non-nil, it must quack like a Hash. If it is nil, then none of
      # the context functions will be available.
      def initialize
        @result   = nil
        @context  = {}
      end

      # Set the result of the function to the given error message.
      # The function will then return that error.
      def set_error( error )
        @driver.result_error( @func, error.to_s, -1 )
      end

      # (Only available to aggregate functions.) Returns the number of rows
      # that the aggregate has processed so far. This will include the current
      # row, and so will always return at least 1.
      def count
        @driver.aggregate_count( @func )
      end

      # Returns the value with the given key from the context. This is only
      # available to aggregate functions.
      def []( key )
        @context[ key ]
      end

      # Sets the value with the given key in the context. This is only
      # available to aggregate functions.
      def []=( key, value )
        @context[ key ] = value
      end
    end

    private

    def ordered_map_for columns, row
      h = Hash[*columns.zip(row).flatten]
      row.each_with_index { |r, i| h[i] = r }
      h
    end
  end
end
                                                                                                                 errors.rb                                                                                           0100644 0001750 0001750 00000002613 12566211336 042216  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/constants'

module SQLite3
  class Exception < ::StandardError
    @code = 0

    # The numeric error code that this exception represents.
    def self.code
      @code
    end

    # A convenience for accessing the error code for this exception.
    def code
      self.class.code
    end
  end

  class SQLException < Exception; end
  class InternalException < Exception; end
  class PermissionException < Exception; end
  class AbortException < Exception; end
  class BusyException < Exception; end
  class LockedException < Exception; end
  class MemoryException < Exception; end
  class ReadOnlyException < Exception; end
  class InterruptException < Exception; end
  class IOException < Exception; end
  class CorruptException < Exception; end
  class NotFoundException < Exception; end
  class FullException < Exception; end
  class CantOpenException < Exception; end
  class ProtocolException < Exception; end
  class EmptyException < Exception; end
  class SchemaChangedException < Exception; end
  class TooBigException < Exception; end
  class ConstraintException < Exception; end
  class MismatchException < Exception; end
  class MisuseException < Exception; end
  class UnsupportedException < Exception; end
  class AuthorizationException < Exception; end
  class FormatException < Exception; end
  class RangeException < Exception; end
  class NotADatabaseException < Exception; end
end
                                                                                                                     pragmas.rb                                                                                          0100644 0001750 0001750 00000017113 12566211336 042335  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/errors'

module SQLite3

  # This module is intended for inclusion solely by the Database class. It
  # defines convenience methods for the various pragmas supported by SQLite3.
  #
  # For a detailed description of these pragmas, see the SQLite3 documentation
  # at http://sqlite.org/pragma.html.
  module Pragmas

    # Returns +true+ or +false+ depending on the value of the named pragma.
    def get_boolean_pragma( name )
      get_first_value( "PRAGMA #{name}" ) != "0"
    end
    private :get_boolean_pragma

    # Sets the given pragma to the given boolean value. The value itself
    # may be +true+ or +false+, or any other commonly used string or
    # integer that represents truth.
    def set_boolean_pragma( name, mode )
      case mode
        when String
          case mode.downcase
            when "on", "yes", "true", "y", "t"; mode = "'ON'"
            when "off", "no", "false", "n", "f"; mode = "'OFF'"
            else
              raise Exception,
                "unrecognized pragma parameter #{mode.inspect}"
          end
        when true, 1
          mode = "ON"
        when false, 0, nil
          mode = "OFF"
        else
          raise Exception,
            "unrecognized pragma parameter #{mode.inspect}"
      end

      execute( "PRAGMA #{name}=#{mode}" )
    end
    private :set_boolean_pragma

    # Requests the given pragma (and parameters), and if the block is given,
    # each row of the result set will be yielded to it. Otherwise, the results
    # are returned as an array.
    def get_query_pragma( name, *parms, &block ) # :yields: row
      if parms.empty?
        execute( "PRAGMA #{name}", &block )
      else
        args = "'" + parms.join("','") + "'"
        execute( "PRAGMA #{name}( #{args} )", &block )
      end
    end
    private :get_query_pragma

    # Return the value of the given pragma.
    def get_enum_pragma( name )
      get_first_value( "PRAGMA #{name}" )
    end
    private :get_enum_pragma

    # Set the value of the given pragma to +mode+. The +mode+ parameter must
    # conform to one of the values in the given +enum+ array. Each entry in
    # the array is another array comprised of elements in the enumeration that
    # have duplicate values. See #synchronous, #default_synchronous,
    # #temp_store, and #default_temp_store for usage examples.
    def set_enum_pragma( name, mode, enums )
      match = enums.find { |p| p.find { |i| i.to_s.downcase == mode.to_s.downcase } }
      raise Exception,
        "unrecognized #{name} #{mode.inspect}" unless match
      execute( "PRAGMA #{name}='#{match.first.upcase}'" )
    end
    private :set_enum_pragma

    # Returns the value of the given pragma as an integer.
    def get_int_pragma( name )
      get_first_value( "PRAGMA #{name}" ).to_i
    end
    private :get_int_pragma

    # Set the value of the given pragma to the integer value of the +value+
    # parameter.
    def set_int_pragma( name, value )
      execute( "PRAGMA #{name}=#{value.to_i}" )
    end
    private :set_int_pragma

    # The enumeration of valid synchronous modes.
    SYNCHRONOUS_MODES = [ [ 'full', 2 ], [ 'normal', 1 ], [ 'off', 0 ] ]

    # The enumeration of valid temp store modes.
    TEMP_STORE_MODES  = [ [ 'default', 0 ], [ 'file', 1 ], [ 'memory', 2 ] ]

    # Does an integrity check on the database. If the check fails, a
    # SQLite3::Exception will be raised. Otherwise it
    # returns silently.
    def integrity_check
      execute( "PRAGMA integrity_check" ) do |row|
        raise Exception, row[0] if row[0] != "ok"
      end
    end

    def auto_vacuum
      get_boolean_pragma "auto_vacuum"
    end

    def auto_vacuum=( mode )
      set_boolean_pragma "auto_vacuum", mode
    end

    def schema_cookie
      get_int_pragma "schema_cookie"
    end

    def schema_cookie=( cookie )
      set_int_pragma "schema_cookie", cookie
    end

    def user_cookie
      get_int_pragma "user_cookie"
    end

    def user_cookie=( cookie )
      set_int_pragma "user_cookie", cookie
    end

    def cache_size
      get_int_pragma "cache_size"
    end

    def cache_size=( size )
      set_int_pragma "cache_size", size
    end

    def default_cache_size
      get_int_pragma "default_cache_size"
    end

    def default_cache_size=( size )
      set_int_pragma "default_cache_size", size
    end

    def default_synchronous
      get_enum_pragma "default_synchronous"
    end

    def default_synchronous=( mode )
      set_enum_pragma "default_synchronous", mode, SYNCHRONOUS_MODES
    end

    def synchronous
      get_enum_pragma "synchronous"
    end

    def synchronous=( mode )
      set_enum_pragma "synchronous", mode, SYNCHRONOUS_MODES
    end

    def default_temp_store
      get_enum_pragma "default_temp_store"
    end

    def default_temp_store=( mode )
      set_enum_pragma "default_temp_store", mode, TEMP_STORE_MODES
    end
  
    def temp_store
      get_enum_pragma "temp_store"
    end

    def temp_store=( mode )
      set_enum_pragma "temp_store", mode, TEMP_STORE_MODES
    end

    def full_column_names
      get_boolean_pragma "full_column_names"
    end

    def full_column_names=( mode )
      set_boolean_pragma "full_column_names", mode
    end
  
    def parser_trace
      get_boolean_pragma "parser_trace"
    end

    def parser_trace=( mode )
      set_boolean_pragma "parser_trace", mode
    end
  
    def vdbe_trace
      get_boolean_pragma "vdbe_trace"
    end

    def vdbe_trace=( mode )
      set_boolean_pragma "vdbe_trace", mode
    end

    def database_list( &block ) # :yields: row
      get_query_pragma "database_list", &block
    end

    def foreign_key_list( table, &block ) # :yields: row
      get_query_pragma "foreign_key_list", table, &block
    end

    def index_info( index, &block ) # :yields: row
      get_query_pragma "index_info", index, &block
    end

    def index_list( table, &block ) # :yields: row
      get_query_pragma "index_list", table, &block
    end

    ###
    # Returns information about +table+.  Yields each row of table information
    # if a block is provided.
    def table_info table
      stmt    = prepare "PRAGMA table_info(#{table})"
      columns = stmt.columns

      needs_tweak_default =
        version_compare(SQLite3.libversion.to_s, "3.3.7") > 0

      result = [] unless block_given?
      stmt.each do |row|
        new_row = Hash[columns.zip(row)]

        # FIXME: This should be removed but is required for older versions
        # of rails
        if(Object.const_defined?(:ActiveRecord))
          new_row['notnull'] = new_row['notnull'].to_s
        end

        tweak_default(new_row) if needs_tweak_default

        if block_given?
          yield new_row
        else
          result << new_row
        end
      end
      stmt.close

      result
    end

    private

      # Compares two version strings
      def version_compare(v1, v2)
        v1 = v1.split(".").map { |i| i.to_i }
        v2 = v2.split(".").map { |i| i.to_i }
        parts = [v1.length, v2.length].max
        v1.push 0 while v1.length < parts
        v2.push 0 while v2.length < parts
        v1.zip(v2).each do |a,b|
          return -1 if a < b
          return  1 if a > b
        end
        return 0
      end

      # Since SQLite 3.3.8, the table_info pragma has returned the default
      # value of the row as a quoted SQL value. This method essentially
      # unquotes those values.
      def tweak_default(hash)
        case hash["dflt_value"]
        when /^null$/i
          hash["dflt_value"] = nil
        when /^'(.*)'$/
          hash["dflt_value"] = $1.gsub(/''/, "'")
        when /^"(.*)"$/
          hash["dflt_value"] = $1.gsub(/""/, '"')
        end
      end
  end

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                     resultset.rb                                                                                        0100644 0001750 0001750 00000013161 12566211336 042734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/constants'
require 'sqlite3/errors'

module SQLite3

  # The ResultSet object encapsulates the enumerability of a query's output.
  # It is a simple cursor over the data that the query returns. It will
  # very rarely (if ever) be instantiated directly. Instead, client's should
  # obtain a ResultSet instance via Statement#execute.
  class ResultSet
    include Enumerable

    class ArrayWithTypes < Array # :nodoc:
      attr_accessor :types
    end

    class ArrayWithTypesAndFields < Array # :nodoc:
      attr_writer :types
      attr_writer :fields

      def types
        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling #{self.class}#types.  This method will be removed in
sqlite3 version 2.0.0, please call the `types` method on the SQLite3::ResultSet
object that created this object
        eowarn
        @types
      end

      def fields
        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling #{self.class}#fields.  This method will be removed in
sqlite3 version 2.0.0, please call the `columns` method on the SQLite3::ResultSet
object that created this object
        eowarn
        @fields
      end
    end

    # The class of which we return an object in case we want a Hash as
    # result.
    class HashWithTypesAndFields < Hash # :nodoc:
      attr_writer :types
      attr_writer :fields

      def types
        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling #{self.class}#types.  This method will be removed in
sqlite3 version 2.0.0, please call the `types` method on the SQLite3::ResultSet
object that created this object
        eowarn
        @types
      end

      def fields
        warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling #{self.class}#fields.  This method will be removed in
sqlite3 version 2.0.0, please call the `columns` method on the SQLite3::ResultSet
object that created this object
        eowarn
        @fields
      end

      def [] key
        key = fields[key] if key.is_a? Numeric
        super key
      end
    end

    # Create a new ResultSet attached to the given database, using the
    # given sql text.
    def initialize db, stmt
      @db   = db
      @stmt = stmt
    end

    # Reset the cursor, so that a result set which has reached end-of-file
    # can be rewound and reiterated.
    def reset( *bind_params )
      @stmt.reset!
      @stmt.bind_params( *bind_params )
      @eof = false
    end

    # Query whether the cursor has reached the end of the result set or not.
    def eof?
      @stmt.done?
    end

    # Obtain the next row from the cursor. If there are no more rows to be
    # had, this will return +nil+. If type translation is active on the
    # corresponding database, the values in the row will be translated
    # according to their types.
    #
    # The returned value will be an array, unless Database#results_as_hash has
    # been set to +true+, in which case the returned value will be a hash.
    #
    # For arrays, the column names are accessible via the +fields+ property,
    # and the column types are accessible via the +types+ property.
    #
    # For hashes, the column names are the keys of the hash, and the column
    # types are accessible via the +types+ property.
    def next
      if @db.results_as_hash
        return next_hash
      end

      row = @stmt.step
      return nil if @stmt.done?

      if @db.type_translation
        row = @stmt.types.zip(row).map do |type, value|
          @db.translator.translate( type, value )
        end
      end

      if row.respond_to?(:fields)
        # FIXME: this can only happen if the translator returns something
        # that responds to `fields`.  Since we're removing the translator
        # in 2.0, we can remove this branch in 2.0.
        row = ArrayWithTypes.new(row)
      else
        # FIXME: the `fields` and `types` methods are deprecated on this
        # object for version 2.0, so we can safely remove this branch
        # as well.
        row = ArrayWithTypesAndFields.new(row)
      end

      row.fields = @stmt.columns
      row.types = @stmt.types
      row
    end

    # Required by the Enumerable mixin. Provides an internal iterator over the
    # rows of the result set.
    def each
      while node = self.next
        yield node
      end
    end

    # Provides an internal iterator over the rows of the result set where
    # each row is yielded as a hash.
    def each_hash
      while node = next_hash
        yield node
      end
    end

    # Closes the statement that spawned this result set.
    # <em>Use with caution!</em> Closing a result set will automatically
    # close any other result sets that were spawned from the same statement.
    def close
      @stmt.close
    end

    # Queries whether the underlying statement has been closed or not.
    def closed?
      @stmt.closed?
    end

    # Returns the types of the columns returned by this result set.
    def types
      @stmt.types
    end

    # Returns the names of the columns returned by this result set.
    def columns
      @stmt.columns
    end

    # Return the next row as a hash
    def next_hash
      row = @stmt.step
      return nil if @stmt.done?

      # FIXME: type translation is deprecated, so this can be removed
      # in 2.0
      if @db.type_translation
        row = @stmt.types.zip(row).map do |type, value|
          @db.translator.translate( type, value )
        end
      end

      # FIXME: this can be switched to a regular hash in 2.0
      row = HashWithTypesAndFields[*@stmt.columns.zip(row).flatten]

      # FIXME: these methods are deprecated for version 2.0, so we can remove
      # this code in 2.0
      row.fields = @stmt.columns
      row.types = @stmt.types
      row
    end
  end
end
                                                                                                                                                                                                                                                                                                                                                                                                               statement.rb                                                                                        0100644 0001750 0001750 00000007750 12566211336 042715  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/errors'
require 'sqlite3/resultset'

class String
  def to_blob
    SQLite3::Blob.new( self )
  end
end

module SQLite3
  # A statement represents a prepared-but-unexecuted SQL query. It will rarely
  # (if ever) be instantiated directly by a client, and is most often obtained
  # via the Database#prepare method.
  class Statement
    include Enumerable

    # This is any text that followed the first valid SQL statement in the text
    # with which the statement was initialized. If there was no trailing text,
    # this will be the empty string.
    attr_reader :remainder

    # Binds the given variables to the corresponding placeholders in the SQL
    # text.
    #
    # See Database#execute for a description of the valid placeholder
    # syntaxes.
    #
    # Example:
    #
    #   stmt = db.prepare( "select * from table where a=? and b=?" )
    #   stmt.bind_params( 15, "hello" )
    #
    # See also #execute, #bind_param, Statement#bind_param, and
    # Statement#bind_params.
    def bind_params( *bind_vars )
      index = 1
      bind_vars.flatten.each do |var|
        if Hash === var
          var.each { |key, val| bind_param key, val }
        else
          bind_param index, var
          index += 1
        end
      end
    end

    # Execute the statement. This creates a new ResultSet object for the
    # statement's virtual machine. If a block was given, the new ResultSet will
    # be yielded to it; otherwise, the ResultSet will be returned.
    #
    # Any parameters will be bound to the statement using #bind_params.
    #
    # Example:
    #
    #   stmt = db.prepare( "select * from table" )
    #   stmt.execute do |result|
    #     ...
    #   end
    #
    # See also #bind_params, #execute!.
    def execute( *bind_vars )
      reset! if active? || done?

      bind_params(*bind_vars) unless bind_vars.empty?
      @results = ResultSet.new(@connection, self)

      step if 0 == column_count

      yield @results if block_given?
      @results
    end

    # Execute the statement. If no block was given, this returns an array of
    # rows returned by executing the statement. Otherwise, each row will be
    # yielded to the block.
    #
    # Any parameters will be bound to the statement using #bind_params.
    #
    # Example:
    #
    #   stmt = db.prepare( "select * from table" )
    #   stmt.execute! do |row|
    #     ...
    #   end
    #
    # See also #bind_params, #execute.
    def execute!( *bind_vars, &block )
      execute(*bind_vars)
      block_given? ? each(&block) : to_a
    end

    # Returns true if the statement is currently active, meaning it has an
    # open result set.
    def active?
      !done?
    end

    # Return an array of the column names for this statement. Note that this
    # may execute the statement in order to obtain the metadata; this makes it
    # a (potentially) expensive operation.
    def columns
      get_metadata unless @columns
      return @columns
    end

    def each
      loop do
        val = step
        break self if done?
        yield val
      end
    end

    # Return an array of the data types for each column in this statement. Note
    # that this may execute the statement in order to obtain the metadata; this
    # makes it a (potentially) expensive operation.
    def types
      must_be_open!
      get_metadata unless @types
      @types
    end

    # Performs a sanity check to ensure that the statement is not
    # closed. If it is, an exception is raised.
    def must_be_open! # :nodoc:
      if closed?
        raise SQLite3::Exception, "cannot use a closed statement"
      end
    end

    private
    # A convenience method for obtaining the metadata about the query. Note
    # that this will actually execute the SQL, which means it can be a
    # (potentially) expensive operation.
    def get_metadata
      @columns = Array.new(column_count) do |column|
        column_name column
      end
      @types = Array.new(column_count) do |column|
        column_decltype column
      end
    end
  end
end
                        translator.rb                                                                                       0100644 0001750 0001750 00000010022 12566211336 043064  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'time'
require 'date'

module SQLite3

  # The Translator class encapsulates the logic and callbacks necessary for
  # converting string data to a value of some specified type. Every Database
  # instance may have a Translator instance, in order to assist in type
  # translation (Database#type_translation).
  #
  # Further, applications may define their own custom type translation logic
  # by registering translator blocks with the corresponding database's
  # translator instance (Database#translator).
  class Translator

    # Create a new Translator instance. It will be preinitialized with default
    # translators for most SQL data types.
    def initialize
      @translators = Hash.new( proc { |type,value| value } )
      @type_name_cache = {}
      register_default_translators
    end

    # Add a new translator block, which will be invoked to process type
    # translations to the given type. The type should be an SQL datatype, and
    # may include parentheses (i.e., "VARCHAR(30)"). However, any parenthetical
    # information is stripped off and discarded, so type translation decisions
    # are made solely on the "base" type name.
    #
    # The translator block itself should accept two parameters, "type" and
    # "value". In this case, the "type" is the full type name (including
    # parentheses), so the block itself may include logic for changing how a
    # type is translated based on the additional data. The "value" parameter
    # is the (string) data to convert.
    #
    # The block should return the translated value.
    def add_translator( type, &block ) # :yields: type, value
      warn(<<-eowarn) if $VERBOSE
#{caller[0]} is calling `add_translator`.
Built in translators are deprecated and will be removed in version 2.0.0
      eowarn
      @translators[ type_name( type ) ] = block
    end

    # Translate the given string value to a value of the given type. In the
    # absense of an installed translator block for the given type, the value
    # itself is always returned. Further, +nil+ values are never translated,
    # and are always passed straight through regardless of the type parameter.
    def translate( type, value )
      unless value.nil?
        # FIXME: this is a hack to support Sequel
        if type && %w{ datetime timestamp }.include?(type.downcase)
          @translators[ type_name( type ) ].call( type, value.to_s )
        else
          @translators[ type_name( type ) ].call( type, value )
        end
      end
    end

    # A convenience method for working with type names. This returns the "base"
    # type name, without any parenthetical data.
    def type_name( type )
      @type_name_cache[type] ||= begin
        type = "" if type.nil?
        type = $1 if type =~ /^(.*?)\(/
        type.upcase
      end
    end
    private :type_name

    # Register the default translators for the current Translator instance.
    # This includes translators for most major SQL data types.
    def register_default_translators
      [ "time",
        "timestamp" ].each { |type| add_translator( type ) { |t, v| Time.parse( v ) } }

      add_translator( "date" ) { |t,v| Date.parse(v) }
      add_translator( "datetime" ) { |t,v| DateTime.parse(v) }

      [ "decimal",
        "float",
        "numeric",
        "double",
        "real",
        "dec",
        "fixed" ].each { |type| add_translator( type ) { |t,v| v.to_f } }

      [ "integer",
        "smallint",
        "mediumint",
        "int",
        "bigint" ].each { |type| add_translator( type ) { |t,v| v.to_i } }

      [ "bit",
        "bool",
        "boolean" ].each do |type|
        add_translator( type ) do |t,v|
          !( v.strip.gsub(/00+/,"0") == "0" ||
             v.downcase == "false" ||
             v.downcase == "f" ||
             v.downcase == "no" ||
             v.downcase == "n" )
        end
      end

      add_translator( "tinyint" ) do |type, value|
        if type =~ /\(\s*1\s*\)/
          value.to_i == 1
        else
          value.to_i
        end
      end
    end
    private :register_default_translators

  end

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value.rb                                                                                            0100644 0001750 0001750 00000002041 12566211336 042011  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       require 'sqlite3/constants'

module SQLite3

  class Value
    attr_reader :handle

    def initialize( db, handle )
      @driver = db.driver
      @handle = handle
    end

    def null?
      type == :null
    end

    def to_blob
      @driver.value_blob( @handle )
    end

    def length( utf16=false )
      if utf16
        @driver.value_bytes16( @handle )
      else
        @driver.value_bytes( @handle )
      end
    end

    def to_f
      @driver.value_double( @handle )
    end

    def to_i
      @driver.value_int( @handle )
    end

    def to_int64
      @driver.value_int64( @handle )
    end

    def to_s( utf16=false )
      @driver.value_text( @handle, utf16 )
    end

    def type
      case @driver.value_type( @handle )
        when Constants::ColumnType::INTEGER then :int
        when Constants::ColumnType::FLOAT   then :float
        when Constants::ColumnType::TEXT    then :text
        when Constants::ColumnType::BLOB    then :blob
        when Constants::ColumnType::NULL    then :null
      end
    end
    
  end

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               version.rb                                                                                          0100644 0001750 0001750 00000000711 12566211336 042364  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib/sqlite3                       module SQLite3

  VERSION = '1.3.7'

  module VersionProxy

    MAJOR = 1
    MINOR = 3
    TINY  = 7
    BUILD = nil

    STRING = [ MAJOR, MINOR, TINY, BUILD ].compact.join( "." )
    #:beta-tag:

    VERSION = ::SQLite3::VERSION
  end

  def self.const_missing(name)
    return super unless name == :Version
    warn(<<-eowarn) if $VERBOSE
#{caller[0]}: SQLite::Version will be removed in sqlite3-ruby version 2.0.0
    eowarn
    VersionProxy
  end
end
                                                       sqlite3.rb                                                                                          0100644 0001750 0001750 00000000371 12566211336 040701  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7/lib                               # support multiple ruby version (fat binaries under windows)
begin
  RUBY_VERSION =~ /(\d+\.\d+)/
  require "sqlite3/#{$1}/sqlite3_native"
rescue LoadError
  require 'sqlite3/sqlite3_native'
end

require 'sqlite3/database'
require 'sqlite3/version'
                                                                                                                                                                                                                                                                       setup.rb                                                                                            0100644 0001750 0001750 00000067405 12566211336 037722  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/gems/2.0.0/gems/sqlite3-1.3.7                                   #
# setup.rb
#
# Copyright (c) 2000-2004 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the terms of
# the GNU LGPL, Lesser General Public License version 2.1.
#

#
# For backward compatibility
#

unless Enumerable.method_defined?(:map)
  module Enumerable
    alias map collect
  end
end

unless Enumerable.method_defined?(:detect)
  module Enumerable
    alias detect find
  end
end

unless Enumerable.method_defined?(:select)
  module Enumerable
    alias select find_all
  end
end

unless Enumerable.method_defined?(:reject)
  module Enumerable
    def reject
      select {|i| not yield(i) }
    end
  end
end

unless Enumerable.method_defined?(:inject)
  module Enumerable
    def inject(result)
      each do |i|
        result = yield(result, i)
      end
      result
    end
  end
end

unless Enumerable.method_defined?(:any?)
  module Enumerable
    def any?
      each do |i|
        return true if yield(i)
      end
      false
    end
  end
end

unless File.respond_to?(:read)
  def File.read(fname)
    open(fname) {|f|
      return f.read
    }
  end
end

#
# Application independent utilities
#

def File.binread(fname)
  open(fname, 'rb') {|f|
    return f.read
  }
end

# for corrupted windows stat(2)
def File.dir?(path)
  File.directory?((path[-1,1] == '/') ? path : path + '/')
end

#
# Config
#

if arg = ARGV.detect {|arg| /\A--rbconfig=/ =~ arg }
  ARGV.delete(arg)
  require arg.split(/=/, 2)[1]
  $".push 'rbconfig.rb'
else
  require 'rbconfig'
end

def multipackage_install?
  FileTest.directory?(File.dirname($0) + '/packages')
end


class ConfigTable

  c = ::Config::CONFIG

  rubypath = c['bindir'] + '/' + c['ruby_install_name']

  major = c['MAJOR'].to_i
  minor = c['MINOR'].to_i
  teeny = c['TEENY'].to_i
  version = "#{major}.#{minor}"

  # ruby ver. >= 1.4.4?
  newpath_p = ((major >= 2) or
               ((major == 1) and
                ((minor >= 5) or
                 ((minor == 4) and (teeny >= 4)))))
  
  subprefix = lambda {|path|
    path.sub(/\A#{Regexp.quote(c['prefix'])}/o, '$prefix')
  }

  if c['rubylibdir']
    # V < 1.6.3
    stdruby    = subprefix.call(c['rubylibdir'])
    siteruby   = subprefix.call(c['sitedir'])
    versite    = subprefix.call(c['sitelibdir'])
    sodir      = subprefix.call(c['sitearchdir'])
  elsif newpath_p
    # 1.4.4 <= V <= 1.6.3
    stdruby    = "$prefix/lib/ruby/#{version}"
    siteruby   = subprefix.call(c['sitedir'])
    versite    = siteruby + '/' + version
    sodir      = "$site-ruby/#{c['arch']}"
  else
    # V < 1.4.4
    stdruby    = "$prefix/lib/ruby/#{version}"
    siteruby   = "$prefix/lib/ruby/#{version}/site_ruby"
    versite    = siteruby
    sodir      = "$site-ruby/#{c['arch']}"
  end

  if arg = c['configure_args'].split.detect {|arg| /--with-make-prog=/ =~ arg }
    makeprog = arg.sub(/'/, '').split(/=/, 2)[1]
  else
    makeprog = 'make'
  end

  common_descripters = [
    [ 'prefix',    [ c['prefix'],
                     'path',
                     'path prefix of target environment' ] ],
    [ 'std-ruby',  [ stdruby,
                     'path',
                     'the directory for standard ruby libraries' ] ],
    [ 'site-ruby-common', [ siteruby,
                     'path',
                     'the directory for version-independent non-standard ruby libraries' ] ],
    [ 'site-ruby', [ versite,
                     'path',
                     'the directory for non-standard ruby libraries' ] ],
    [ 'bin-dir',   [ '$prefix/bin',
                     'path',
                     'the directory for commands' ] ],
    [ 'rb-dir',    [ '$site-ruby',
                     'path',
                     'the directory for ruby scripts' ] ],
    [ 'so-dir',    [ sodir,
                     'path',
                     'the directory for ruby extentions' ] ],
    [ 'data-dir',  [ '$prefix/share',
                     'path',
                     'the directory for shared data' ] ],
    [ 'ruby-path', [ rubypath,
                     'path',
                     'path to set to #! line' ] ],
    [ 'ruby-prog', [ rubypath,
                     'name',
                     'the ruby program using for installation' ] ],
    [ 'make-prog', [ makeprog,
                     'name',
                     'the make program to compile ruby extentions' ] ],
    [ 'without-ext', [ 'no',
                       'yes/no',
                       'does not compile/install ruby extentions' ] ]
  ]
  multipackage_descripters = [
    [ 'with',      [ '',
                     'name,name...',
                     'package names that you want to install',
                     'ALL' ] ],
    [ 'without',   [ '',
                     'name,name...',
                     'package names that you do not want to install',
                     'NONE' ] ]
  ]
  if multipackage_install?
    DESCRIPTER = common_descripters + multipackage_descripters
  else
    DESCRIPTER = common_descripters
  end

  SAVE_FILE = '.config'

  def ConfigTable.each_name(&block)
    keys().each(&block)
  end

  def ConfigTable.keys
    DESCRIPTER.map {|name, *dummy| name }
  end

  def ConfigTable.each_definition(&block)
    DESCRIPTER.each(&block)
  end

  def ConfigTable.get_entry(name)
    name, ent = DESCRIPTER.assoc(name)
    ent
  end

  def ConfigTable.get_entry!(name)
    get_entry(name) or raise ArgumentError, "no such config: #{name}"
  end

  def ConfigTable.add_entry(name, vals)
    ConfigTable::DESCRIPTER.push [name,vals]
  end

  def ConfigTable.remove_entry(name)
    get_entry(name) or raise ArgumentError, "no such config: #{name}"
    DESCRIPTER.delete_if {|n, arr| n == name }
  end

  def ConfigTable.config_key?(name)
    get_entry(name) ? true : false
  end

  def ConfigTable.bool_config?(name)
    ent = get_entry(name) or return false
    ent[1] == 'yes/no'
  end

  def ConfigTable.value_config?(name)
    ent = get_entry(name) or return false
    ent[1] != 'yes/no'
  end

  def ConfigTable.path_config?(name)
    ent = get_entry(name) or return false
    ent[1] == 'path'
  end


  class << self
    alias newobj new
  end

  def ConfigTable.new
    c = newobj()
    c.initialize_from_table
    c
  end

  def ConfigTable.load
    c = newobj()
    c.initialize_from_file
    c
  end

  def initialize_from_table
    @table = {}
    DESCRIPTER.each do |k, (default, vname, desc, default2)|
      @table[k] = default
    end
  end

  def initialize_from_file
    raise InstallError, "#{File.basename $0} config first"\
        unless File.file?(SAVE_FILE)
    @table = {}
    File.foreach(SAVE_FILE) do |line|
      k, v = line.split(/=/, 2)
      @table[k] = v.strip
    end
  end

  def save
    File.open(SAVE_FILE, 'w') {|f|
      @table.each do |k, v|
        f.printf "%s=%s\n", k, v if v
      end
    }
  end

  def []=(k, v)
    raise InstallError, "unknown config option #{k}"\
        unless ConfigTable.config_key?(k)
    @table[k] = v
  end
    
  def [](key)
    return nil unless @table[key]
    @table[key].gsub(%r<\$([^/]+)>) { self[$1] }
  end

  def set_raw(key, val)
    @table[key] = val
  end

  def get_raw(key)
    @table[key]
  end

end


module MetaConfigAPI

  def eval_file_ifexist(fname)
    instance_eval File.read(fname), fname, 1 if File.file?(fname)
  end

  def config_names
    ConfigTable.keys
  end

  def config?(name)
    ConfigTable.config_key?(name)
  end

  def bool_config?(name)
    ConfigTable.bool_config?(name)
  end

  def value_config?(name)
    ConfigTable.value_config?(name)
  end

  def path_config?(name)
    ConfigTable.path_config?(name)
  end

  def add_config(name, argname, default, desc)
    ConfigTable.add_entry name,[default,argname,desc]
  end

  def add_path_config(name, default, desc)
    add_config name, 'path', default, desc
  end

  def add_bool_config(name, default, desc)
    add_config name, 'yes/no', default ? 'yes' : 'no', desc
  end

  def set_config_default(name, default)
    if bool_config?(name)
      ConfigTable.get_entry!(name)[0] = (default ? 'yes' : 'no')
    else
      ConfigTable.get_entry!(name)[0] = default
    end
  end

  def remove_config(name)
    ent = ConfigTable.get_entry(name)
    ConfigTable.remove_entry name
    ent
  end

end

#
# File Operations
#

module FileOperations

  def mkdir_p(dirname, prefix = nil)
    dirname = prefix + dirname if prefix
    $stderr.puts "mkdir -p #{dirname}" if verbose?
    return if no_harm?

    # does not check '/'... it's too abnormal case
    dirs = dirname.split(%r<(?=/)>)
    if /\A[a-z]:\z/i =~ dirs[0]
      disk = dirs.shift
      dirs[0] = disk + dirs[0]
    end
    dirs.each_index do |idx|
      path = dirs[0..idx].join('')
      Dir.mkdir path unless File.dir?(path)
    end
  end

  def rm_f(fname)
    $stderr.puts "rm -f #{fname}" if verbose?
    return if no_harm?

    if File.exist?(fname) or File.symlink?(fname)
      File.chmod 0777, fname
      File.unlink fname
    end
  end

  def rm_rf(dn)
    $stderr.puts "rm -rf #{dn}" if verbose?
    return if no_harm?

    Dir.chdir dn
    Dir.foreach('.') do |fn|
      next if fn == '.'
      next if fn == '..'
      if File.dir?(fn)
        verbose_off {
          rm_rf fn
        }
      else
        verbose_off {
          rm_f fn
        }
      end
    end
    Dir.chdir '..'
    Dir.rmdir dn
  end

  def move_file(src, dest)
    File.unlink dest if File.exist?(dest)
    begin
      File.rename src, dest
    rescue
      File.open(dest, 'wb') {|f| f.write File.binread(src) }
      File.chmod File.stat(src).mode, dest
      File.unlink src
    end
  end

  def install(from, dest, mode, prefix = nil)
    $stderr.puts "install #{from} #{dest}" if verbose?
    return if no_harm?

    realdest = prefix ? prefix + dest : dest
    realdest = File.join(realdest, File.basename(from)) if File.dir?(realdest)
    str = File.binread(from)
    if diff?(str, realdest)
      verbose_off {
        rm_f realdest if File.exist?(realdest)
      }
      File.open(realdest, 'wb') {|f|
        f.write str
      }
      File.chmod mode, realdest

      File.open("#{objdir_root()}/InstalledFiles", 'a') {|f|
        if prefix
          f.puts realdest.sub(prefix, '')
        else
          f.puts realdest
        end
      }
    end
  end

  def diff?(new_content, path)
    return true unless File.exist?(path)
    new_content != File.binread(path)
  end

  def command(str)
    $stderr.puts str if verbose?
    system str or raise RuntimeError, "'system #{str}' failed"
  end

  def ruby(str)
    command config('ruby-prog') + ' ' + str
  end
  
  def make(task = '')
    command config('make-prog') + ' ' + task
  end

  def extdir?(dir)
    File.exist?(dir + '/MANIFEST') or File.exist?("#{dir}/extconf.rb")
  end

  def all_files_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|ent| File.file?("#{dirname}/#{ent}") }
    }
  end

  REJECT_DIRS = %w(
    CVS SCCS RCS CVS.adm .svn
  )

  def all_dirs_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|n| File.dir?("#{dirname}/#{n}") } - %w(. ..) - REJECT_DIRS
    }
  end

end

#
# Main Installer
#

class InstallError < StandardError; end


module HookUtils

  def run_hook(name)
    try_run_hook "#{curr_srcdir()}/#{name}" or
    try_run_hook "#{curr_srcdir()}/#{name}.rb"
  end

  def try_run_hook(fname)
    return false unless File.file?(fname)
    begin
      instance_eval File.read(fname), fname, 1
    rescue
      raise InstallError, "hook #{fname} failed:\n" + $!.message
    end
    true
  end

end


module HookScriptAPI

  def get_config(key)
    @config[key]
  end

  alias config get_config

  def set_config(key, val)
    @config[key] = val
  end

  #
  # srcdir/objdir (works only in the package directory)
  #

  #abstract srcdir_root
  #abstract objdir_root
  #abstract relpath

  def curr_srcdir
    "#{srcdir_root()}/#{relpath()}"
  end

  def curr_objdir
    "#{objdir_root()}/#{relpath()}"
  end

  def srcfile(path)
    "#{curr_srcdir()}/#{path}"
  end

  def srcexist?(path)
    File.exist?(srcfile(path))
  end

  def srcdirectory?(path)
    File.dir?(srcfile(path))
  end
  
  def srcfile?(path)
    File.file? srcfile(path)
  end

  def srcentries(path = '.')
    Dir.open("#{curr_srcdir()}/#{path}") {|d|
      return d.to_a - %w(. ..)
    }
  end

  def srcfiles(path = '.')
    srcentries(path).select {|fname|
      File.file?(File.join(curr_srcdir(), path, fname))
    }
  end

  def srcdirectories(path = '.')
    srcentries(path).select {|fname|
      File.dir?(File.join(curr_srcdir(), path, fname))
    }
  end

end


class ToplevelInstaller

  Version   = '3.3.0'
  Copyright = 'Copyright (c) 2000-2004 Minero Aoki'

  TASKS = [
    [ 'all',      'do config, setup, then install' ],
    [ 'config',   'saves your configurations' ],
    [ 'show',     'shows current configuration' ],
    [ 'setup',    'compiles ruby extentions and others' ],
    [ 'install',  'installs files' ],
    [ 'clean',    "does `make clean' for each extention" ],
    [ 'distclean',"does `make distclean' for each extention" ]
  ]

  def ToplevelInstaller.invoke
    instance().invoke
  end

  @singleton = nil

  def ToplevelInstaller.instance
    @singleton ||= new(File.dirname($0))
    @singleton
  end

  include MetaConfigAPI

  def initialize(ardir_root)
    @config = nil
    @options = { 'verbose' => true }
    @ardir = File.expand_path(ardir_root)
  end

  def inspect
    "#<#{self.class} #{__id__()}>"
  end

  def invoke
    run_metaconfigs
    case task = parsearg_global()
    when nil, 'all'
      @config = load_config('config')
      parsearg_config
      init_installers
      exec_config
      exec_setup
      exec_install
    else
      @config = load_config(task)
      __send__ "parsearg_#{task}"
      init_installers
      __send__ "exec_#{task}"
    end
  end
  
  def run_metaconfigs
    eval_file_ifexist "#{@ardir}/metaconfig"
  end

  def load_config(task)
    case task
    when 'config'
      ConfigTable.new
    when 'clean', 'distclean'
      if File.exist?(ConfigTable::SAVE_FILE)
      then ConfigTable.load
      else ConfigTable.new
      end
    else
      ConfigTable.load
    end
  end

  def init_installers
    @installer = Installer.new(@config, @options, @ardir, File.expand_path('.'))
  end

  #
  # Hook Script API bases
  #

  def srcdir_root
    @ardir
  end

  def objdir_root
    '.'
  end

  def relpath
    '.'
  end

  #
  # Option Parsing
  #

  def parsearg_global
    valid_task = /\A(?:#{TASKS.map {|task,desc| task }.join '|'})\z/

    while arg = ARGV.shift
      case arg
      when /\A\w+\z/
        raise InstallError, "invalid task: #{arg}" unless valid_task =~ arg
        return arg

      when '-q', '--quiet'
        @options['verbose'] = false

      when       '--verbose'
        @options['verbose'] = true

      when '-h', '--help'
        print_usage $stdout
        exit 0

      when '-v', '--version'
        puts "#{File.basename($0)} version #{Version}"
        exit 0
      
      when '--copyright'
        puts Copyright
        exit 0

      else
        raise InstallError, "unknown global option '#{arg}'"
      end
    end

    nil
  end


  def parsearg_no_options
    raise InstallError, "#{task}:  unknown options: #{ARGV.join ' '}"\
        unless ARGV.empty?
  end

  alias parsearg_show       parsearg_no_options
  alias parsearg_setup      parsearg_no_options
  alias parsearg_clean      parsearg_no_options
  alias parsearg_distclean  parsearg_no_options

  def parsearg_config
    re = /\A--(#{ConfigTable.keys.join '|'})(?:=(.*))?\z/
    @options['config-opt'] = []

    while i = ARGV.shift
      if /\A--?\z/ =~ i
        @options['config-opt'] = ARGV.dup
        break
      end
      m = re.match(i) or raise InstallError, "config: unknown option #{i}"
      name, value = m.to_a[1,2]
      if value
        if ConfigTable.bool_config?(name)
          raise InstallError, "config: --#{name} allows only yes/no for argument"\
              unless /\A(y(es)?|n(o)?|t(rue)?|f(alse))\z/i =~ value
          value = (/\Ay(es)?|\At(rue)/i =~ value) ? 'yes' : 'no'
        end
      else
        raise InstallError, "config: --#{name} requires argument"\
            unless ConfigTable.bool_config?(name)
        value = 'yes'
      end
      @config[name] = value
    end
  end

  def parsearg_install
    @options['no-harm'] = false
    @options['install-prefix'] = ''
    while a = ARGV.shift
      case a
      when /\A--no-harm\z/
        @options['no-harm'] = true
      when /\A--prefix=(.*)\z/
        path = $1
        path = File.expand_path(path) unless path[0,1] == '/'
        @options['install-prefix'] = path
      else
        raise InstallError, "install: unknown option #{a}"
      end
    end
  end

  def print_usage(out)
    out.puts 'Typical Installation Procedure:'
    out.puts "  $ ruby #{File.basename $0} config"
    out.puts "  $ ruby #{File.basename $0} setup"
    out.puts "  # ruby #{File.basename $0} install (may require root privilege)"
    out.puts
    out.puts 'Detailed Usage:'
    out.puts "  ruby #{File.basename $0} <global option>"
    out.puts "  ruby #{File.basename $0} [<global options>] <task> [<task options>]"

    fmt = "  %-20s %s\n"
    out.puts
    out.puts 'Global options:'
    out.printf fmt, '-q,--quiet',   'suppress message outputs'
    out.printf fmt, '   --verbose', 'output messages verbosely'
    out.printf fmt, '-h,--help',    'print this message'
    out.printf fmt, '-v,--version', 'print version and quit'
    out.printf fmt, '   --copyright',  'print copyright and quit'

    out.puts
    out.puts 'Tasks:'
    TASKS.each do |name, desc|
      out.printf "  %-10s  %s\n", name, desc
    end

    out.puts
    out.puts 'Options for CONFIG or ALL:'
    ConfigTable.each_definition do |name, (default, arg, desc, default2)|
      out.printf "  %-20s %s [%s]\n",
                 '--'+ name + (ConfigTable.bool_config?(name) ? '' : '='+arg),
                 desc,
                 default2 || default
    end
    out.printf "  %-20s %s [%s]\n",
        '--rbconfig=path', 'your rbconfig.rb to load', "running ruby's"

    out.puts
    out.puts 'Options for INSTALL:'
    out.printf "  %-20s %s [%s]\n",
        '--no-harm', 'only display what to do if given', 'off'
    out.printf "  %-20s %s [%s]\n",
        '--prefix',  'install path prefix', '$prefix'

    out.puts
  end

  #
  # Task Handlers
  #

  def exec_config
    @installer.exec_config
    @config.save   # must be final
  end

  def exec_setup
    @installer.exec_setup
  end

  def exec_install
    @installer.exec_install
  end

  def exec_show
    ConfigTable.each_name do |k|
      v = @config.get_raw(k)
      if not v or v.empty?
        v = '(not specified)'
      end
      printf "%-10s %s\n", k, v
    end
  end

  def exec_clean
    @installer.exec_clean
  end

  def exec_distclean
    @installer.exec_distclean
  end

end


class ToplevelInstallerMulti < ToplevelInstaller

  include HookUtils
  include HookScriptAPI
  include FileOperations

  def initialize(ardir)
    super
    @packages = all_dirs_in("#{@ardir}/packages")
    raise 'no package exists' if @packages.empty?
  end

  def run_metaconfigs
    eval_file_ifexist "#{@ardir}/metaconfig"
    @packages.each do |name|
      eval_file_ifexist "#{@ardir}/packages/#{name}/metaconfig"
    end
  end

  def init_installers
    @installers = {}
    @packages.each do |pack|
      @installers[pack] = Installer.new(@config, @options,
                                       "#{@ardir}/packages/#{pack}",
                                       "packages/#{pack}")
    end

    with    = extract_selection(config('with'))
    without = extract_selection(config('without'))
    @selected = @installers.keys.select {|name|
                  (with.empty? or with.include?(name)) \
                      and not without.include?(name)
                }
  end

  def extract_selection(list)
    a = list.split(/,/)
    a.each do |name|
      raise InstallError, "no such package: #{name}" \
              unless @installers.key?(name)
    end
    a
  end

  def print_usage(f)
    super
    f.puts 'Inluded packages:'
    f.puts '  ' + @packages.sort.join(' ')
    f.puts
  end

  #
  # multi-package metaconfig API
  #

  attr_reader :packages

  def declare_packages(list)
    raise 'package list is empty' if list.empty?
    list.each do |name|
      raise "directory packages/#{name} does not exist"\
              unless File.dir?("#{@ardir}/packages/#{name}")
    end
    @packages = list
  end

  #
  # Task Handlers
  #

  def exec_config
    run_hook 'pre-config'
    each_selected_installers {|inst| inst.exec_config }
    run_hook 'post-config'
    @config.save   # must be final
  end

  def exec_setup
    run_hook 'pre-setup'
    each_selected_installers {|inst| inst.exec_setup }
    run_hook 'post-setup'
  end

  def exec_install
    run_hook 'pre-install'
    each_selected_installers {|inst| inst.exec_install }
    run_hook 'post-install'
  end

  def exec_clean
    rm_f ConfigTable::SAVE_FILE
    run_hook 'pre-clean'
    each_selected_installers {|inst| inst.exec_clean }
    run_hook 'post-clean'
  end

  def exec_distclean
    rm_f ConfigTable::SAVE_FILE
    run_hook 'pre-distclean'
    each_selected_installers {|inst| inst.exec_distclean }
    run_hook 'post-distclean'
  end

  #
  # lib
  #

  def each_selected_installers
    Dir.mkdir 'packages' unless File.dir?('packages')
    @selected.each do |pack|
      $stderr.puts "Processing the package `#{pack}' ..." if @options['verbose']
      Dir.mkdir "packages/#{pack}" unless File.dir?("packages/#{pack}")
      Dir.chdir "packages/#{pack}"
      yield @installers[pack]
      Dir.chdir '../..'
    end
  end

  def verbose?
    @options['verbose']
  end

  def no_harm?
    @options['no-harm']
  end

end


class Installer

  FILETYPES = %w( bin lib ext data )

  include HookScriptAPI
  include HookUtils
  include FileOperations

  def initialize(config, opt, srcroot, objroot)
    @config = config
    @options = opt
    @srcdir = File.expand_path(srcroot)
    @objdir = File.expand_path(objroot)
    @currdir = '.'
  end

  def inspect
    "#<#{self.class} #{File.basename(@srcdir)}>"
  end

  #
  # Hook Script API bases
  #

  def srcdir_root
    @srcdir
  end

  def objdir_root
    @objdir
  end

  def relpath
    @currdir
  end

  #
  # configs/options
  #

  def no_harm?
    @options['no-harm']
  end

  def verbose?
    @options['verbose']
  end

  def verbose_off
    begin
      save, @options['verbose'] = @options['verbose'], false
      yield
    ensure
      @options['verbose'] = save
    end
  end

  #
  # TASK config
  #

  def exec_config
    exec_task_traverse 'config'
  end

  def config_dir_bin(rel)
  end

  def config_dir_lib(rel)
  end

  def config_dir_ext(rel)
    extconf if extdir?(curr_srcdir())
  end

  def extconf
    opt = @options['config-opt'].join(' ')
    command "#{config('ruby-prog')} #{curr_srcdir()}/extconf.rb #{opt}"
  end

  def config_dir_data(rel)
  end

  #
  # TASK setup
  #

  def exec_setup
    exec_task_traverse 'setup'
  end

  def setup_dir_bin(rel)
    all_files_in(curr_srcdir()).each do |fname|
      adjust_shebang "#{curr_srcdir()}/#{fname}"
    end
  end

  def adjust_shebang(path)
    return if no_harm?
    tmpfile = File.basename(path) + '.tmp'
    begin
      File.open(path, 'rb') {|r|
        File.open(tmpfile, 'wb') {|w|
          first = r.gets
          return unless should_modify_shebang?(first)
          $stderr.puts "adjusting shebang: #{File.basename(path)}" if verbose?
          w.print first.sub(SHEBANG_RE, '#!' + config('ruby-path'))
          w.write r.read
        }
      }
      move_file tmpfile, File.basename(path)
    ensure
      File.unlink tmpfile if File.exist?(tmpfile)
    end
  end

  def should_modify_shebang?(line)
    File.basename(config('ruby-path')) == 'ruby' or
        shebang_command(line) == 'ruby'
  end

  def shebang_command(line)
    cmd, arg = *line.sub(/\A\#!/, '').strip.split(/\s+/, 2)
    cmd
  end

  def setup_dir_lib(rel)
  end

  def setup_dir_ext(rel)
    make if extdir?(curr_srcdir())
  end

  def setup_dir_data(rel)
  end

  #
  # TASK install
  #

  def exec_install
    exec_task_traverse 'install'
  end

  def install_dir_bin(rel)
    install_files collect_filenames_auto(), "#{config('bin-dir')}/#{rel}", 0755
  end

  def install_dir_lib(rel)
    install_files ruby_scripts(), "#{config('rb-dir')}/#{rel}", 0644
  end

  def install_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    install_files ruby_extentions('.'),
                  "#{config('so-dir')}/#{rel}",
                  0555
  end

  def install_dir_data(rel)
    install_files collect_filenames_auto(), "#{config('data-dir')}/#{rel}", 0644
  end

  def install_files(list, dest, mode)
    mkdir_p dest, @options['install-prefix']
    list.each do |fname|
      install fname, dest, mode, @options['install-prefix']
    end
  end

  def ruby_scripts
    collect_filenames_auto().select {|n| /\.rb\z/ =~ n }
  end
  
  # picked up many entries from cvs-1.11.1/src/ignore.c
  reject_patterns = %w( 
    core RCSLOG tags TAGS .make.state
    .nse_depinfo #* .#* cvslog.* ,* .del-* *.olb
    *~ *.old *.bak *.BAK *.orig *.rej _$* *$

    *.org *.in .*
  )
  mapping = {
    '.' => '\.',
    '$' => '\$',
    '#' => '\#',
    '*' => '.*'
  }
  REJECT_PATTERNS = Regexp.new('\A(?:' +
                               reject_patterns.map {|pat|
                                 pat.gsub(/[\.\$\#\*]/) {|ch| mapping[ch] }
                               }.join('|') +
                               ')\z')

  def collect_filenames_auto
    mapdir((existfiles() - hookfiles()).reject {|fname|
             REJECT_PATTERNS =~ fname
           })
  end

  def existfiles
    all_files_in(curr_srcdir()) | all_files_in('.')
  end

  def hookfiles
    %w( pre-%s post-%s pre-%s.rb post-%s.rb ).map {|fmt|
      %w( config setup install clean ).map {|t| sprintf(fmt, t) }
    }.flatten
  end

  def mapdir(filelist)
    filelist.map {|fname|
      if File.exist?(fname)   # objdir
        fname
      else                    # srcdir
        File.join(curr_srcdir(), fname)
      end
    }
  end

  def ruby_extentions(dir)
    _ruby_extentions(dir) or
        raise InstallError, "no ruby extention exists: 'ruby #{$0} setup' first"
  end

  DLEXT = /\.#{ ::Config::CONFIG['DLEXT'] }\z/

  def _ruby_extentions(dir)
    Dir.open(dir) {|d|
      return d.select {|fname| DLEXT =~ fname }
    }
  end

  #
  # TASK clean
  #

  def exec_clean
    exec_task_traverse 'clean'
    rm_f ConfigTable::SAVE_FILE
    rm_f 'InstalledFiles'
  end

  def clean_dir_bin(rel)
  end

  def clean_dir_lib(rel)
  end

  def clean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'clean' if File.file?('Makefile')
  end

  def clean_dir_data(rel)
  end

  #
  # TASK distclean
  #

  def exec_distclean
    exec_task_traverse 'distclean'
    rm_f ConfigTable::SAVE_FILE
    rm_f 'InstalledFiles'
  end

  def distclean_dir_bin(rel)
  end

  def distclean_dir_lib(rel)
  end

  def distclean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'distclean' if File.file?('Makefile')
  end

  #
  # lib
  #

  def exec_task_traverse(task)
    run_hook "pre-#{task}"
    FILETYPES.each do |type|
      if config('without-ext') == 'yes' and type == 'ext'
        $stderr.puts 'skipping ext/* by user option' if verbose?
        next
      end
      traverse task, type, "#{task}_dir_#{type}"
    end
    run_hook "post-#{task}"
  end

  def traverse(task, rel, mid)
    dive_into(rel) {
      run_hook "pre-#{task}"
      __send__ mid, rel.sub(%r[\A.*?(?:/|\z)], '')
      all_dirs_in(curr_srcdir()).each do |d|
        traverse task, "#{rel}/#{d}", mid
      end
      run_hook "post-#{task}"
    }
  end

  def dive_into(rel)
    return unless File.dir?("#{@srcdir}/#{rel}")

    dir = File.basename(rel)
    Dir.mkdir dir unless File.dir?(dir)
    prevdir = Dir.pwd
    Dir.chdir dir
    $stderr.puts '---> ' + rel if verbose?
    @currdir = rel
    yield
    Dir.chdir prevdir
    $stderr.puts '<--- ' + rel if verbose?
    @currdir = File.dirname(rel)
  end

end


if $0 == __FILE__
  begin
    if multipackage_install?
      ToplevelInstallerMulti.invoke
    else
      ToplevelInstaller.invoke
    end
  rescue
    raise if $DEBUG
    $stderr.puts $!.message
    $stderr.puts "Try 'ruby #{$0} --help' for detailed usage."
    exit 1
  end
end
                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/0040755 0001750 0001750 00000000000 12612224746 031304  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ri/                                                                                                 0040755 0001750 0001750 00000000000 12612224746 031637  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share                                                                    2.0.0/                                                                                              0040755 0001750 0001750 00000000000 12612224746 032274  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri                                                                 system/                                                                                             0040755 0001750 0001750 00000000000 12612224746 033620  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0                                                           Gem/                                                                                                0040755 0001750 0001750 00000000000 12612224746 034330  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system                                                    Commands/                                                                                           0040755 0001750 0001750 00000000000 12612224746 036071  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem                                                SourcesCommand/                                                                                     0040755 0001750 0001750 00000000000 12612224746 041013  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands                                       cdesc-SourcesCommand.ri                                                                             0100644 0001750 0001750 00000001222 12566207204 045340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands/SourcesCommand                        U:RDoc::NormalClass[iI"SourcesCommand:ETI""Gem::Commands::SourcesCommand;FI"Gem::Command;Fo:RDoc::Markup::Document:@parts[o;;[ :
@fileI"-lib/rubygems/commands/sources_command.rb;F:0@omit_headings_from_table_of_contents_below0;	0;
0[ [ [[I"Gem::LocalRemoteOptions;To;;[ ;	@;
0I"f/Library/Caches/com.apple.xbs/Sources/ruby/ruby-113/ruby/lib/rubygems/commands/sources_command.rb;T[[I"
class;T[[:public[[I"new;T@[:protected[ [:private[ [I"instance;T[[;[[I"defaults_str;F@[I"execute;F@[;[ [;[[I"remove_cache_file;F@[ [U:RDoc::Context::Section[i 0o;;[ ;	0;
0[@@cRDoc::TopLevel                                                                                                                                                                                                                                                                                                                                                                              defaults_str-i.ri                                                                                   0100644 0001750 0001750 00000000447 12566207204 044274  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands/SourcesCommand                        U:RDoc::AnyMethod[iI"defaults_str:EFI"/Gem::Commands::SourcesCommand#defaults_str;FF:publico:RDoc::Markup::Document:@parts[ :
@fileI"-lib/rubygems/commands/sources_command.rb;F:0@omit_headings_from_table_of_contents_below000[ I"();T@FI"SourcesCommand;TcRDoc::NormalClass0                                                                                                                                                                                                                         execute-i.ri                                                                                        0100644 0001750 0001750 00000000435 12566207204 043234  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands/SourcesCommand                        U:RDoc::AnyMethod[iI"execute:EFI"*Gem::Commands::SourcesCommand#execute;FF:publico:RDoc::Markup::Document:@parts[ :
@fileI"-lib/rubygems/commands/sources_command.rb;F:0@omit_headings_from_table_of_contents_below000[ I"();T@FI"SourcesCommand;TcRDoc::NormalClass0                                                                                                                                                                                                                                   new-c.ri                                                                                            0100644 0001750 0001750 00000000426 12566207204 042355  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands/SourcesCommand                        U:RDoc::AnyMethod[iI"new:ETI"'Gem::Commands::SourcesCommand::new;FT:publico:RDoc::Markup::Document:@parts[ :
@fileI"-lib/rubygems/commands/sources_command.rb;F:0@omit_headings_from_table_of_contents_below000[ I"();T@TI"SourcesCommand;TcRDoc::NormalClass0                                                                                                                                                                                                                                          remove_cache_file-i.ri                                                                              0100644 0001750 0001750 00000000474 12566207204 045214  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/share/ri/2.0.0/system/Gem/Commands/SourcesCommand                        U:RDoc::AnyMethod[iI"remove_cache_file:EFI"4Gem::Commands::SourcesCommand#remove_cache_file;FF:privateo:RDoc::Markup::Document:@parts[ :
@fileI"-lib/rubygems/commands/sources_command.rb;F:0@omit_headings_from_table_of_contents_below000[ I"(desc, path);T@FI"SourcesCommand;TcRDoc::NormalClass0                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Ruby.framework/Versions/Current       0120777 0001750 0001750 00000000000 12620245063 030647  22.0                                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/                   0040755 0001750 0001750 00000000000 12612224746 026046  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Headers            0120777 0001750 0001750 00000000000 12620245063 034062  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Modules            0120777 0001750 0001750 00000000000 12620245063 034154  2Versions/Current/Modules                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/SceneKit.tbd       0120777 0001750 0001750 00000000000 12620245063 035666  2Versions/Current/SceneKit.tbd                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/          0040755 0001750 0001750 00000000000 12612224746 027656  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/        0040755 0001750 0001750 00000000000 12612224746 030036  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers/0040755 0001750 0001750 00000000000 12612224746 031411  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ModelIO.h                                                                                           0100644 0001750 0001750 00000003745 12566226113 032777  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  ModelIO.h
//
//  Copyright (c) 2015 Apple Inc. All rights reserved.
//

#import <ModelIO/ModelIO.h>

NS_ASSUME_NONNULL_BEGIN

/*! 
 @header ModelIO.h
 @abstract Bridge with the Model I/O framework
 */

@interface SCNScene (SCNModelIO)
+ (instancetype)sceneWithMDLAsset:(MDLAsset *)mdlAsset NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLAsset (SCNModelIO)
+ (instancetype)assetWithSCNScene:(SCNScene *)scnScene NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNNode (SCNModelIO)
+ (instancetype)nodeWithMDLObject:(MDLObject *)mdlObject NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLObject (SCNModelIO)
+ (instancetype)objectWithSCNNode:(SCNNode *)scnNode NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNGeometry (SCNModelIO)
+ (instancetype)geometryWithMDLMesh:(MDLMesh *)mdlMesh NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLMesh (SCNModelIO)
+ (instancetype)meshWithSCNGeometry:(SCNGeometry *)scnGeometry NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNGeometryElement (SCNModelIO)
+ (instancetype)geometryElementWithMDLSubmesh:(MDLSubmesh *)mdlSubMesh NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLSubmesh (SCNModelIO)
+ (instancetype)submeshWithSCNGeometryElement:(SCNGeometryElement *)scnGeometryElement NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNMaterial (SCNModelIO)
+ (instancetype)materialWithMDLMaterial:(MDLMaterial *)mdlMaterial NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLMaterial (SCNModelIO)
+ (instancetype)materialWithSCNMaterial:(SCNMaterial *)scnMaterial NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNLight (SCNModelIO)
+ (instancetype)lightWithMDLLight:(MDLLight *)mdlLight NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLLight (SCNModelIO)
+ (instancetype)lightWithSCNLight:(SCNLight *)scnLight NS_AVAILABLE(10_11, 9_0);
@end

@interface SCNCamera (SCNModelIO)
+ (instancetype)cameraWithMDLCamera:(MDLCamera *)mdlCamera NS_AVAILABLE(10_11, 9_0);
@end

@interface MDLCamera (SCNModelIO)
+ (instancetype)cameraWithSCNCamera:(SCNCamera *)scnCamera NS_AVAILABLE(10_11, 9_0);
@end

NS_ASSUME_NONNULL_END
                           SCNAction.h                                                                                         0100644 0001750 0001750 00000017426 12566226113 033271  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  SCNAction.h
//
//  Copyright (c) 2014-2015 Apple, Inc. All rights reserved.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@class SCNNode;
@class SCNAction;
@class SCNAudioSource;

/*! @enum SCNActionTimingMode
 @abstract The modes that an action can use to adjust the apparent timing of the action.
 */
typedef NS_ENUM(NSInteger, SCNActionTimingMode) {
    SCNActionTimingModeLinear,
    SCNActionTimingModeEaseIn,
    SCNActionTimingModeEaseOut,
    SCNActionTimingModeEaseInEaseOut
} NS_ENUM_AVAILABLE(10_10, 8_0);

/**
 A custom timing function for SCNActions. Input time will be between 0.0 and 1.0
 over the duration of the action. Return values must be 0.0-1.0 and increasing
 and the function must return 1.0 when the input time reaches 1.0.
 */
typedef float (^SCNActionTimingFunction)(float time);

@protocol SCNActionable <NSObject>

/*!
 @method runAction:
 @abstract Adds an action to the list of actions executed by the node.
 */
- (void)runAction:(SCNAction *)action NS_AVAILABLE(10_10, 8_0);

/*!
 @method runAction:completionHandler:
 @abstract Adds an action to the list of actions executed by the node. Your block is called when the action completes.
 */
- (void)runAction:(SCNAction *)action completionHandler:(nullable void (^)())block NS_AVAILABLE(10_10, 8_0);

/*!
 @method runAction:forKey:
 @abstract Adds an identifiable action to the list of actions executed by the node.
 */
- (void)runAction:(SCNAction *)action forKey:(nullable NSString *)key NS_AVAILABLE(10_10, 8_0);

/*!
 @method runAction:forKey:completionHandler:
 @abstract Adds an identifiable action to the list of actions executed by the node. Your block is called when the action completes.
 */
- (void)runAction:(SCNAction *)action forKey:(nullable NSString *)key completionHandler:(nullable void (^)())block NS_AVAILABLE(10_10, 8_0);

/*!
 @method hasActions
 @abstract Returns a Boolean value that indicates whether the node is executing actions.
 */
@property(nonatomic, readonly) BOOL hasActions NS_AVAILABLE(10_10, 8_0);

/*!
 @method actionForKey:
 @abstract Returns an action associated with a specific key.
 */
- (nullable SCNAction *)actionForKey:(NSString *)key NS_AVAILABLE(10_10, 8_0);

/*!
 @method removeActionForKey:
 @abstract Removes an action associated with a specific key.
 */
- (void)removeActionForKey:(NSString *)key NS_AVAILABLE(10_10, 8_0);

/*!
 @method removeAllActions
 @abstract Ends and removes all actions from the node.
 */
- (void)removeAllActions NS_AVAILABLE(10_10, 8_0);

/*!
 @method actionKeys
 @abstract Returns an array containing the keys of all actions currently attached to the receiver.
 */
@property(nonatomic, readonly) NSArray<NSString *> *actionKeys NS_AVAILABLE(10_10, 8_0);

@end


NS_CLASS_AVAILABLE(10_10, 8_0)
@interface SCNAction : NSObject <NSCopying, NSSecureCoding>

/*!
 @property duration
 @abstract This is the expected duration of an actions animation. The actual time an action takes to complete is modified by the speed property of the action.
 */
@property(nonatomic) NSTimeInterval duration;

/*!
 @property timingMode
 @abstract The timing mode used to execute an action.
 */
@property(nonatomic) SCNActionTimingMode timingMode;

/** When set, prodives a custom timing via a block. Applies after
 the 'timingMode' property is taken into account, defaults to nil
 @see SCNActionTimingFunction
 */
@property(nonatomic, nullable) SCNActionTimingFunction timingFunction;

/*!
 @property speed
 @abstract A speed factor that modifies how fast an action runs. Defaults to 1.
 */
@property(nonatomic) CGFloat speed;

/*!
 @method reversedAction
 @abstract Creates an action that reverses the behavior of another action.
 */
- (SCNAction *)reversedAction;

//Creates an action that moves a node relative to its current position.
+ (SCNAction *)moveByX:(CGFloat)deltaX y:(CGFloat)deltaY z:(CGFloat)deltaZ duration:(NSTimeInterval)duration;
+ (SCNAction *)moveBy:(SCNVector3)delta duration:(NSTimeInterval)duration;

//Creates an action that moves a node to a new position.
+ (SCNAction *)moveTo:(SCNVector3)location duration:(NSTimeInterval)duration;

//Creates an action that rotates the node by a relative value.
+ (SCNAction *)rotateByX:(CGFloat)xAngle y:(CGFloat)yAngle z:(CGFloat)zAngle duration:(NSTimeInterval)duration;

//Creates an action that rotates the node to an absolute angle.
+ (SCNAction *)rotateToX:(CGFloat)xAngle y:(CGFloat)yAngle z:(CGFloat)zAngle duration:(NSTimeInterval)duration;
+ (SCNAction *)rotateToX:(CGFloat)xAngle y:(CGFloat)yAngle z:(CGFloat)zAngle duration:(NSTimeInterval)duration shortestUnitArc:(BOOL)shortestUnitArc;

//Creates an action that rotates the node arond an axis by the specified angle
+ (SCNAction *)rotateByAngle:(CGFloat)angle aroundAxis:(SCNVector3)axis duration:(NSTimeInterval)duration;
+ (SCNAction *)rotateToAxisAngle:(SCNVector4)axisAngle duration:(NSTimeInterval)duration;

//Creates an action that changes the x, y and z scale values of a node by a relative value.
+ (SCNAction *)scaleBy:(CGFloat)scale duration:(NSTimeInterval)sec;

//Creates an action that changes the x, y and z scale values of a node.
+ (SCNAction *)scaleTo:(CGFloat)scale duration:(NSTimeInterval)sec;

//Creates an action that runs a collection of actions sequentially.
+ (SCNAction *)sequence:(NSArray<SCNAction *> *)actions;

//Creates an action that runs a collection of actions in parallel.
+ (SCNAction *)group:(NSArray<SCNAction *> *)actions;

//Creates an action that repeats another action a specified number of times.
+ (SCNAction *)repeatAction:(SCNAction *)action count:(NSUInteger)count;

//Creates an action that repeats another action forever.
+ (SCNAction *)repeatActionForever:(SCNAction *)action;

//Creates an action that changes the opacity value of the node to 1.0
+ (SCNAction *)fadeInWithDuration:(NSTimeInterval)sec;

//Creates an action that changes the opacity value of the node to 0.0
+ (SCNAction *)fadeOutWithDuration:(NSTimeInterval)sec;

//Creates an action that adjusts the opacity value of a node by a relative value.
+ (SCNAction *)fadeOpacityBy:(CGFloat)factor duration:(NSTimeInterval)sec;

//Creates an action that adjusts the opacity value of a node to a new value.
+ (SCNAction *)fadeOpacityTo:(CGFloat)opacity duration:(NSTimeInterval)sec;

//Creates an action that hides a node
+ (SCNAction *)hide NS_AVAILABLE(10_11, 9_0);

//Creates an action that unhides a node
+ (SCNAction *)unhide NS_AVAILABLE(10_11, 9_0);

//Creates an action that idles for a specified period of time.
+ (SCNAction *)waitForDuration:(NSTimeInterval)sec;

//Creates an action that idles for a randomized period of time.
+ (SCNAction *)waitForDuration:(NSTimeInterval)sec withRange:(NSTimeInterval)durationRange;

//Creates an action that removes the node from its parent node.
+ (SCNAction *)removeFromParentNode;

//Creates an action that executes a block.
+ (SCNAction *)runBlock:(void (^)(SCNNode *node))block;
+ (SCNAction *)runBlock:(void (^)(SCNNode *node))block queue:(dispatch_queue_t)queue;

//Creates an action that runs a javascript script over a duration. the node can be accessed from javascript via the "node" symbol and the elapsed time (between 0 and 1 relative to the duration) via the "elapsedTime" symbol.
+ (SCNAction *)javaScriptActionWithScript:(NSString *)script duration:(NSTimeInterval)seconds;

//Creates an action that executes a block over a duration.
+ (SCNAction *)customActionWithDuration:(NSTimeInterval)seconds actionBlock:(void (^)(SCNNode *node, CGFloat elapsedTime))block;

/** Creates an action that plays a sound
 @param source The audio source to play (see SCNAudioSource.h)
 @param waitForCompletion If YES, then the duration of this action is the same
 as the length of the audio playback. If NO, the action is considered
 to have completed immediately.*/
+ (SCNAction *)playAudioSource:(SCNAudioSource *)source waitForCompletion:(BOOL)wait NS_AVAILABLE(10_11, 9_0);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                          SCNAnimation.h                                                                                      0100644 0001750 0001750 00000011231 12566226113 033757  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  SCNAnimation.h
//
//  Copyright (c) 2012-2015 Apple Inc. All rights reserved.
//

#import <QuartzCore/QuartzCore.h>

NS_ASSUME_NONNULL_BEGIN

/*!
 @typedef SCNAnimationEventBlock
 @discussion Signature for the block executed when the animation event is triggered.
 */
typedef void (^SCNAnimationEventBlock)(CAAnimation *animation, id animatedObject, BOOL playingBackward);

/*!
 @class SCNAnimationEvent
 @abstract SCNAnimationEvent encapsulate a block to trigger at a specific time.
 */

NS_CLASS_AVAILABLE(10_9, 8_0)
@interface SCNAnimationEvent : NSObject

/*!
 @method animationEventWithKeyTime:block:
 @abstract Returns an animation event instance
 @param time The relative time to trigger the event.
 @param eventBlock The block to call when the event is triggered.
 @discussion "time" is relative to animation duration and therefor it has to be a value in the range [0,1].
 */
+ (instancetype)animationEventWithKeyTime:(CGFloat)time block:(SCNAnimationEventBlock)eventBlock;

@end

/*!
 @protocol SCNAnimatable
 @abstract The SCNAnimatable protocol defines an animatable property. Objects that implement this protocol can be animated through these methods.
*/
@protocol SCNAnimatable <NSObject>

/*!
 @method addAnimation:forKey:
 @abstract Add an animation.
 @param animation Added animation.
 @param key May be any string such that only one animation per unique key is added per animatable object.
 */
- (void)addAnimation:(CAAnimation *)animation forKey:(nullable NSString *)key;

/*!
 @method removeAllAnimations
 @abstract Remove all animations.
 */
- (void)removeAllAnimations;

/*!
 @method removeAnimationForKey
 @abstract Remove the animation with the given identifier.
 @param key The identifier for the animation to remove.
 */
- (void)removeAnimationForKey:(NSString *)key;

/*!
 @method animationKeys
 @abstract Returns an array containing the keys of all animations currently attached to the receiver.
 */
@property(readonly) NSArray<NSString *> *animationKeys;

/*!
 @method animationForKey:
 @abstract Returns the animation with the given identifier
 @param key The identifier for the animation to retrieve.
 @discussion This will return nil if no such animation exists.
			 Attempting to modify any properties of the returned object will result in undefined behavior.
 */
- (nullable CAAnimation *)animationForKey:(NSString *)key;

/*!
 @method pauseAnimationForKey:
 @abstract Pause the animation with the given identifier.
 @param key The identifier for the animation to pause.
 */
- (void)pauseAnimationForKey:(NSString *)key NS_AVAILABLE(10_9, 8_0);

/*!
 @method resumeAnimationForKey:
 @abstract Resume the animation with the given identifier.
 @param key The identifier for the animation to resume.
 */
- (void)resumeAnimationForKey:(NSString *)key NS_AVAILABLE(10_9, 8_0);

/*!
 @method isAnimationForKeyPaused:
 @abstract Returns whether the animation for the specified identifier is paused.
 @param key The identifier for the animation to query.
 */
- (BOOL)isAnimationForKeyPaused:(NSString *)key NS_AVAILABLE(10_9, 8_0);

/*!
 @method removeAnimationForKey:fadeOutDuration:
 @abstract Smoothly remove the animation with the given identifier.
 @param key The identifier for the animation to remove.
 @param duration The fade out duration used to remove the animation.
 */
- (void)removeAnimationForKey:(NSString *)key fadeOutDuration:(CGFloat)duration NS_AVAILABLE(10_10, 8_0);

@end

/*!
 @category CAAnimation (CAAnimation)
 @abstract Extends the CAAnimation class for SceneKit explicit animations.
 */
@interface CAAnimation (SceneKitAdditions)

/*!
 @property usesSceneTimeBase
 @abstract Determines whether the receiver is evaluated using the scene time or the system time. Defaults to NO.
 @discussion A scene-time based animation is evaluated using the "sceneTime" value of the renderer that renders the scene.
 */
@property BOOL usesSceneTimeBase;

/*!
 @property fadeInDuration
 @abstract Determines the receiver's fade-in duration.
 @discussion When the fadeInDuration is greater than zero, the effect of the animation progressively increase from 0% to 100% during the specified duration.
 */
@property CGFloat fadeInDuration NS_AVAILABLE(10_9, 8_0);
 
/*!
 @property fadeOutDuration
 @abstract Determines the receiver's fade-out duration.
 @discussion When the fadeOutDuration is greater than zero, the effect of the animation progressively decrease from 100% to 0% at the end of the animation duration.
 */
@property CGFloat fadeOutDuration NS_AVAILABLE(10_9, 8_0);

/*!
 @property animationEvents
 @abstract Specifies the animation events attached to the receiver.
 */
@property(nonatomic, copy, nullable) NSArray<SCNAnimationEvent *> *animationEvents NS_AVAILABLE(10_9, 8_0);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                       SCNAudioSource.h                                                                                    0100644 0001750 0001750 00000012017 12566226113 034265  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  SCNAudioSource.h
//
//  Copyright (c) 2015 Apple Inc. All rights reserved.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@class AVAudioNode;

/*!
 @class SCNAudioSource
 @abstract The SCNAudioSource class represents an audio source that can be added to a SCNNode.
 */
NS_CLASS_AVAILABLE(10_11, 9_0)
@interface SCNAudioSource : NSObject <NSCopying, NSSecureCoding>

/*!
 @method initWithFileNamed:
 @abstract Convenience initializer that creates an AVAudioNode from the named audio asset in the main bundle.
 */
- (nullable instancetype)initWithFileNamed:(NSString *)name;

/*!
 @method initWithURL:
 @abstract Convenience initializer that creates an AVAudioNode from the URL that contain a audio asset.
 */
- (nullable instancetype)initWithURL:(NSURL *)url NS_DESIGNATED_INITIALIZER;

/*!
 @method audioSourceNamed:
 @abstract Convenience class initializer that caches audioSources.
 */
+ (nullable instancetype)audioSourceNamed:(NSString *)fileName;

/*!
 @property positional
 @abstract Marks the audio source as positional so that the audio mix considers relative position and velocity with regards to the SCNSceneRenderer's current listener node. Defaults to YES.
 @see SCNSceneRenderer audioListener.
 */
@property(nonatomic, getter=isPositional) BOOL positional;

/*!
 @property volume
 @abstract The default volume for this audio buffer. Default is 1.0 (full volume).
 */
@property(nonatomic) float volume;

/*!
 @property rate
 @abstract The default rate for this audio buffer. Default is 1.0 (original rate of the audio source).
 */
@property(nonatomic) float rate;

/*!
 @property reverbBlend
 @abstract The default reverbBlend for this audio buffer. Default is 0.0 (no sound is sent to the reverb).
 */
@property(nonatomic) float reverbBlend;

/*!
 @property loops
 @abstract Specifies whether the audio source should loop or not. Default to NO.
 */
@property(nonatomic) BOOL loops;

/*!
 @property shouldStream
 @abstract Specifies whether the audio source should be streamed or not. Default to NO.
 */
@property(nonatomic) BOOL shouldStream;

/*!
 @method load
 @abstract Load and uncompress the audio source in memory. This method has no effect if "shouldStream" is set to YES or if the audio source is already loaded.
 @discussion This method let you preload your audio sources. If an audio source is not preloaded, it will be loaded anyway when playing it.
 */
- (void)load;

@end

NS_CLASS_AVAILABLE(10_11, 9_0)
@interface SCNAudioPlayer : NSObject

- (instancetype)init NS_UNAVAILABLE;

/*!
 @property initWithSource:
 @abstract Init an audio player with a source. Most people should use audioPlayerWithSource as it permits to recycle previous players instead of creating new ones for each instance.
 */
- (instancetype)initWithSource:(SCNAudioSource *)source NS_DESIGNATED_INITIALIZER;

/*!
 @property initWithAVAudioNode:
 @abstract Init an audio player with an AVAudioNode. Most people should use audioPlayerWithAVAudioNode as it permits to recycle previous players instead of creating new ones for each instance.
 */
- (instancetype)initWithAVAudioNode:(AVAudioNode *)audioNode NS_DESIGNATED_INITIALIZER;

/*!
 @property audioPlayerWithSource:
 @abstract Create an audio player with a source.
 */
+ (instancetype)audioPlayerWithSource:(SCNAudioSource *)source;

/*!
 @property audioPlayerWithAVAudioNode:
 @abstract Create an audio player with a custom AVAudioNode instance.
 */
+ (instancetype)audioPlayerWithAVAudioNode:(AVAudioNode *)audioNode;

/*!
 @property playbackStarted
 @abstract This block is called when the playback starts in case a valid audio source is present.
 */
@property(nonatomic, copy, nullable) void (^willStartPlayback)();

/*!
 @property playbackFinished
 @abstract This block is called when the playback stops in case a valid audio source is present.
 */
@property(nonatomic, copy, nullable) void (^didFinishPlayback)();

/*!
 @property audioNode
 @abstract The audioNode. If this player was not initialised with a custom AVAudioNode this contains the internal audio player node used by scene kit internally.
 */
@property(nonatomic, readonly, nullable) AVAudioNode *audioNode;

/*!
 @property audioSource
 @abstract The audioSource if there is one.
 */
@property(nonatomic, readonly, nullable) SCNAudioSource *audioSource;

@end


@interface SCNNode (SCNAudioSupport)

/*!
 @method addAudioPlayer:
 @abstract Add an audio player to the node and starts playing it right away.
 */
- (void)addAudioPlayer:(SCNAudioPlayer *)player NS_AVAILABLE(10_11, 9_0);

/*!
 @method removeAllAudioPlayers
 @abstract Remove all audio players from this node and stop playing them.
 */
- (void)removeAllAudioPlayers NS_AVAILABLE(10_11, 9_0);

/*!
 @method removeAudioPlayer:
 @abstract Remove the given audio player from this node and stop playing it.
 */
- (void)removeAudioPlayer:(SCNAudioPlayer *)player NS_AVAILABLE(10_11, 9_0);

/*!
 @property audioPlayers
 @abstract Get an array with all the audio players connected and playing on this node.
 */
@property(nonatomic, readonly) NSArray<SCNAudioPlayer *> *audioPlayers NS_AVAILABLE(10_11, 9_0);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 SCNBase.h                                                                                           0100644 0001750 0001750 00000000477 12566226113 032724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  SCNBase.h
//
//  Copyright (c) 2012-2015 Apple Inc. All rights reserved.
//

/*! @header SCNBase
    @abstract Various defines used throughout SceneKit
 */

#define SCN_EXTERN FOUNDATION_EXTERN

#ifndef __has_feature      // Optional.
#define __has_feature(x) 0 // Compatibility with non-clang compilers.
#endif
                                                                                                                                                                                                 SCNBoundingVolume.h                                                                                 0100644 0001750 0001750 00000003422 12566226113 035000  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/SceneKit.framework/Versions/A/Headers                                                                    //
//  SCNBoundingVolume.h
//
//  Copyright (c) 2012-2015 Apple Inc. All rights reserved.
//

/*!
 @protocol SCNBoundingVolume
 @abstract The SCNBoundingVolume protocol is implemented by objects which can compute their bounding boxes.
 @discussion You can currently use this protocol to get the bounding boxes of nodes and geometries.
 */

NS_ASSUME_NONNULL_BEGIN

@protocol SCNBoundingVolume <NSObject>
@required

/*! 
 @method getBoundingBoxMin:max:
 @abstract Fill the min and max vectors with the min and max vertex of the bounding box.
 @param min A pointer to a SCNVector3 to store the min vertex of the bounding box into.
 @param max A pointer to a SCNVector3 to store the max vertex of the bounding box into.
 */
- (BOOL)getBoundingBoxMin:(nullable SCNVector3 *)min max:(nullable SCNVector3 *)max;

/*!
 @method getBoundingSphereCenter:radius:
 @abstract Fill the center vector with the center of the bounding sphere and store the radius of the bounding sphere in 'radius'.
 @param center A pointer to a SCNVector3 to store the center of the bounding sphere into.
 @param radius A pointer to a CGFloat to store the radius of the bounding sphere into.
 */
- (BOOL)getBoundingSphereCenter:(nullable SCNVector3 *)center radius:(nullable CGFloat *)radius;

/*!
 @method setBoundingBoxMin:max:
 @abstract Override the receiver bounding box with the min and max vectors provided.
 @param min A pointer to a SCNVector3 representing the min vertex of the desired bounding box.
 @param max A pointer to a SCNVector3 representing the max vertex of the desired bounding box.
 @discussion Passing nil as arguments will recompute the original bounding box of the receiver.
 */
- (void)setBoundingBoxMin:(nullable SCNVector3 *)min max:(nullable SCNVector3 *)max NS_AVAILABLE(10_9, 8_0);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                              