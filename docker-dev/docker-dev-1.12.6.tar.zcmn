ore_prototype" 8
.IX Xref "core_prototype"
.IX Item "core_prototype"
This function assigns the prototype of the named core function to \f(CW\*(C`sv\*(C'\fR, or
to a new mortal \s-1SV\s0 if \f(CW\*(C`sv\*(C'\fR is \s-1NULL\s0.  It returns the modified \f(CW\*(C`sv\*(C'\fR, or
\&\s-1NULL\s0 if the core function has no prototype.  \f(CW\*(C`code\*(C'\fR is a code as returned
by \f(CW\*(C`keyword()\*(C'\fR.  It must be negative and unequal to \-KEY_CORE.
.Sp
.Vb 3
\&        SV *    core_prototype(SV *sv, const char *name,
\&                               const int code,
\&                               int * const opnum)
.Ve
.SH "Functions in file pp_ctl.c"
.IX Header "Functions in file pp_ctl.c"
.IP "docatch" 8
.IX Xref "docatch"
.IX Item "docatch"
Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.
.Sp
0 is used as continue inside eval,
.Sp
3 is used for a die caught by an inner eval \- continue inner loop
.Sp
See cop.h: je_mustcatch, when set at any runlevel to \s-1TRUE\s0, means eval ops must
establish a local jmpenv to handle exception traps.
.Sp
.Vb 1
\&        OP*     docatch(OP *o)
.Ve
.SH "GV Functions"
.IX Header "GV Functions"
.IP "gv_try_downgrade" 8
.IX Xref "gv_try_downgrade"
.IX Item "gv_try_downgrade"
If the typeglob \f(CW\*(C`gv\*(C'\fR can be expressed more succinctly, by having
something other than a real \s-1GV\s0 in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that \f(CW\*(C`gv\*(C'\fR
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a \s-1GV\s0 has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real \s-1GV\s0 isn't required after all.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a completely empty typeglob, it is deleted from the stash.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    gv_try_downgrade(GV* gv)
.Ve
.SH "Hash Manipulation Functions"
.IX Header "Hash Manipulation Functions"
.IP "hv_ename_add" 8
.IX Xref "hv_ename_add"
.IX Item "hv_ename_add"
Adds a name to a stash's internal list of effective names.  See
\&\f(CW\*(C`hv_ename_delete\*(C'\fR.
.Sp
This is called when a stash is assigned to a new location in the symbol
table.
.Sp
.Vb 2
\&        void    hv_ename_add(HV *hv, const char *name, U32 len,
\&                             U32 flags)
.Ve
.IP "hv_ename_delete" 8
.IX Xref "hv_ename_delete"
.IX Item "hv_ename_delete"
Removes a name from a stash's internal list of effective names.  If this is
the name returned by \f(CW\*(C`HvENAME\*(C'\fR, then another name in the list will take
its place (\f(CW\*(C`HvENAME\*(C'\fR will use it).
.Sp
This is called when a stash is deleted from the symbol table.
.Sp
.Vb 2
\&        void    hv_ename_delete(HV *hv, const char *name,
\&                                U32 len, U32 flags)
.Ve
.IP "refcounted_he_chain_2hv" 8
.IX Xref "refcounted_he_chain_2hv"
.IX Item "refcounted_he_chain_2hv"
Generates and returns a \f(CW\*(C`HV *\*(C'\fR representing the content of a
\&\f(CW\*(C`refcounted_he\*(C'\fR chain.
\&\fIflags\fR is currently unused and must be zero.
.Sp
.Vb 3
\&        HV *    refcounted_he_chain_2hv(
\&                    const struct refcounted_he *c, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pv" 8
.IX Xref "refcounted_he_fetch_pv"
.IX Item "refcounted_he_fetch_pv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pv(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvn" 8
.IX Xref "refcounted_he_fetch_pvn"
.IX Item "refcounted_he_fetch_pvn"
Search along a \f(CW\*(C`refcounted_he\*(C'\fR chain for an entry with the key specified
by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR
bit set, the key octets are interpreted as \s-1UTF\-8\s0, otherwise they
are interpreted as Latin\-1.  \fIhash\fR is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or \f(CW&PL_sv_placeholder\fR
if there is no value associated with the key.
.Sp
.Vb 5
\&        SV *    refcounted_he_fetch_pvn(
\&                    const struct refcounted_he *chain,
\&                    const char *keypv, STRLEN keylen, U32 hash,
\&                    U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvs" 8
.IX Xref "refcounted_he_fetch_pvs"
.IX Item "refcounted_he_fetch_pvs"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pvs(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_sv" 8
.IX Xref "refcounted_he_fetch_sv"
.IX Item "refcounted_he_fetch_sv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_sv(
\&                    const struct refcounted_he *chain, SV *key,
\&                    U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_free" 8
.IX Xref "refcounted_he_free"
.IX Item "refcounted_he_free"
Decrements the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent \f(CW\*(C`refcounted_he\*(C'\fR's
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.
.Sp
.Vb 1
\&        void    refcounted_he_free(struct refcounted_he *he)
.Ve
.IP "refcounted_he_inc" 8
.IX Xref "refcounted_he_inc"
.IX Item "refcounted_he_inc"
Increment the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR.  The pointer to the
\&\f(CW\*(C`refcounted_he\*(C'\fR is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.
.Sp
.Vb 3
\&        struct refcounted_he * refcounted_he_inc(
\&                                   struct refcounted_he *he
\&                               )
.Ve
.IP "refcounted_he_new_pv" 8
.IX Xref "refcounted_he_new_pv"
.IX Item "refcounted_he_new_pv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a nul-terminated string instead
of a string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pv(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvn" 8
.IX Xref "refcounted_he_new_pvn"
.IX Item "refcounted_he_new_pvn"
Creates a new \f(CW\*(C`refcounted_he\*(C'\fR.  This consists of a single key/value
pair and a reference to an existing \f(CW\*(C`refcounted_he\*(C'\fR chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.
.Sp
The new key is specified by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has
the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR bit set, the key octets are interpreted
as \s-1UTF\-8\s0, otherwise they are interpreted as Latin\-1.  \fIhash\fR is
a precomputed hash of the key string, or zero if it has not been
precomputed.
.Sp
\&\fIvalue\fR is the scalar value to store for this key.  \fIvalue\fR is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the \f(CW\*(C`refcounted_he\*(C'\fR.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
\&\fIvalue\fR may be either null or \f(CW&PL_sv_placeholder\fR to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.
.Sp
\&\fIparent\fR points to the rest of the \f(CW\*(C`refcounted_he\*(C'\fR chain to be
attached to the new \f(CW\*(C`refcounted_he\*(C'\fR.  This function takes ownership
of one reference to \fIparent\fR, and returns one reference to the new
\&\f(CW\*(C`refcounted_he\*(C'\fR.
.Sp
.Vb 6
\&        struct refcounted_he * refcounted_he_new_pvn(
\&                                   struct refcounted_he *parent,
\&                                   const char *keypv,
\&                                   STRLEN keylen, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvs" 8
.IX Xref "refcounted_he_new_pvs"
.IX Item "refcounted_he_new_pvs"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pvs(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_sv" 8
.IX Xref "refcounted_he_new_sv"
.IX Item "refcounted_he_new_sv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_sv(
\&                                   struct refcounted_he *parent,
\&                                   SV *key, U32 hash, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.SH "IO Functions"
.IX Header "IO Functions"
.IP "start_glob" 8
.IX Xref "start_glob"
.IX Item "start_glob"
Function called by \f(CW\*(C`do_readline\*(C'\fR to spawn a glob (or do the glob inside
perl on \s-1VMS\s0). This code used to be inline, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        PerlIO* start_glob(SV *tmpglob, IO *io)
.Ve
.SH "Magical Functions"
.IX Header "Magical Functions"
.IP "magic_clearhint" 8
.IX Xref "magic_clearhint"
.IX Item "magic_clearhint"
Triggered by a delete from %^H, records the key to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhint(SV* sv, MAGIC* mg)
.Ve
.IP "magic_clearhints" 8
.IX Xref "magic_clearhints"
.IX Item "magic_clearhints"
Triggered by clearing %^H, resets \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhints(SV* sv, MAGIC* mg)
.Ve
.IP "magic_methcall" 8
.IX Xref "magic_methcall"
.IX Item "magic_methcall"
Invoke a magic method (like \s-1FETCH\s0).
.Sp
\&\f(CW\*(C`sv\*(C'\fR and \f(CW\*(C`mg\*(C'\fR are the tied thingy and the tie magic.
.Sp
\&\f(CW\*(C`meth\*(C'\fR is the name of the method to call.
.Sp
\&\f(CW\*(C`argc\*(C'\fR is the number of args (in addition to \f(CW$self\fR) to pass to the method.
.Sp
The \f(CW\*(C`flags\*(C'\fR can be:
.Sp
.Vb 4
\&    G_DISCARD     invoke method with G_DISCARD flag and don\*(Aqt
\&                  return a value
\&    G_UNDEF_FILL  fill the stack with argc pointers to
\&                  PL_sv_undef
.Ve
.Sp
The arguments themselves are any values following the \f(CW\*(C`flags\*(C'\fR argument.
.Sp
Returns the \s-1SV\s0 (if any) returned by the method, or \s-1NULL\s0 on failure.
.Sp
.Vb 3
\&        SV*     magic_methcall(SV *sv, const MAGIC *mg,
\&                               const char *meth, U32 flags,
\&                               U32 argc, ...)
.Ve
.IP "magic_sethint" 8
.IX Xref "magic_sethint"
.IX Item "magic_sethint"
Triggered by a store to %^H, records the key/value pair to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.
.Sp
.Vb 1
\&        int     magic_sethint(SV* sv, MAGIC* mg)
.Ve
.IP "mg_localize" 8
.IX Xref "mg_localize"
.IX Item "mg_localize"
Copy some of the magic from an existing \s-1SV\s0 to new localized version of that
\&\s-1SV\s0. Container magic (eg \f(CW%ENV\fR, \f(CW$1\fR, tie) gets copied, value magic doesn't (eg
taint, pos).
.Sp
If setmagic is false then no set magic will be called on the new (empty) \s-1SV\s0.
This typically means that assignment will soon follow (e.g. 'local \f(CW$x\fR = \f(CW$y\fR'),
and that will handle the magic.
.Sp
.Vb 1
\&        void    mg_localize(SV* sv, SV* nsv, bool setmagic)
.Ve
.SH "MRO Functions"
.IX Header "MRO Functions"
.IP "mro_get_linear_isa_dfs" 8
.IX Xref "mro_get_linear_isa_dfs"
.IX Item "mro_get_linear_isa_dfs"
Returns the Depth-First Search linearization of \f(CW@ISA\fR
the given stash.  The return value is a read-only AV*.
\&\f(CW\*(C`level\*(C'\fR should be 0 (it is used internally in this
function's recursion).
.Sp
You are responsible for \f(CW\*(C`SvREFCNT_inc()\*(C'\fR on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).
.Sp
.Vb 1
\&        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)
.Ve
.IP "mro_isa_changed_in" 8
.IX Xref "mro_isa_changed_in"
.IX Item "mro_isa_changed_in"
Takes the necessary steps (cache invalidations, mostly)
when the \f(CW@ISA\fR of the given package has changed.  Invoked
by the \f(CW\*(C`setisa\*(C'\fR magic, should not need to invoke directly.
.Sp
.Vb 1
\&        void    mro_isa_changed_in(HV* stash)
.Ve
.IP "mro_package_moved" 8
.IX Xref "mro_package_moved"
.IX Item "mro_package_moved"
Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  \f(CW\*(C`stash\*(C'\fR is the stash that has been
assigned. \f(CW\*(C`oldstash\*(C'\fR is the stash it replaces, if any.  \f(CW\*(C`gv\*(C'\fR is the glob
that is actually being assigned to.
.Sp
This can also be called with a null first argument to
indicate that \f(CW\*(C`oldstash\*(C'\fR has been deleted.
.Sp
This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in \f(CW\*(C`stash\*(C'\fR.
.Sp
It also sets the effective names (\f(CW\*(C`HvENAME\*(C'\fR) on all the stashes as
appropriate.
.Sp
If the \f(CW\*(C`gv\*(C'\fR is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if \f(CW\*(C`flags & 1\*(C'\fR.
.Sp
.Vb 4
\&        void    mro_package_moved(HV * const stash,
\&                                  HV * const oldstash,
\&                                  const GV * const gv,
\&                                  U32 flags)
.Ve
.SH "Optree Manipulation Functions"
.IX Header "Optree Manipulation Functions"
.IP "finalize_optree" 8
.IX Xref "finalize_optree"
.IX Item "finalize_optree"
This function finalizes the optree. Should be called directly after
the complete optree is built. It does some additional
checking which can't be done in the normal ck_xxx functions and makes
the tree thread-safe.
.Sp
.Vb 1
\&        void    finalize_optree(OP* o)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "\s-1CX_CURPAD_SAVE\s0" 8
.IX Xref "CX_CURPAD_SAVE"
.IX Item "CX_CURPAD_SAVE"
Save the current pad in the given context block structure.
.Sp
.Vb 1
\&        void    CX_CURPAD_SAVE(struct context)
.Ve
.IP "\s-1CX_CURPAD_SV\s0" 8
.IX Xref "CX_CURPAD_SV"
.IX Item "CX_CURPAD_SV"
Access the \s-1SV\s0 at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).
.Sp
.Vb 1
\&        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)
.Ve
.IP "\s-1PAD_BASE_SV\s0" 8
.IX Xref "PAD_BASE_SV"
.IX Item "PAD_BASE_SV"
Get the value from slot \f(CW\*(C`po\*(C'\fR in the base (DEPTH=1) pad of a padlist
.Sp
.Vb 1
\&        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
.Ve
.IP "\s-1PAD_CLONE_VARS\s0" 8
.IX Xref "PAD_CLONE_VARS"
.IX Item "PAD_CLONE_VARS"
Clone the state variables associated with running and compiling pads.
.Sp
.Vb 2
\&        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
\&                               CLONE_PARAMS* param)
.Ve
.IP "\s-1PAD_COMPNAME_FLAGS\s0" 8
.IX Xref "PAD_COMPNAME_FLAGS"
.IX Item "PAD_COMPNAME_FLAGS"
Return the flags for the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_GEN\s0" 8
.IX Xref "PAD_COMPNAME_GEN"
.IX Item "PAD_COMPNAME_GEN"
The generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
compiling pad (lvalue). Note that \f(CW\*(C`SvUVX\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
.Ve
.IP "PAD_COMPNAME_GEN_set" 8
.IX Xref "PAD_COMPNAME_GEN_set"
.IX Item "PAD_COMPNAME_GEN_set"
Sets the generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
ling pad (lvalue) to \f(CW\*(C`gen\*(C'\fR.  Note that \f(CW\*(C`SvUV_set\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
.Ve
.IP "\s-1PAD_COMPNAME_OURSTASH\s0" 8
.IX Xref "PAD_COMPNAME_OURSTASH"
.IX Item "PAD_COMPNAME_OURSTASH"
Return the stash associated with an \f(CW\*(C`our\*(C'\fR variable.
Assumes the slot entry is a valid \f(CW\*(C`our\*(C'\fR lexical.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_PV\s0" 8
.IX Xref "PAD_COMPNAME_PV"
.IX Item "PAD_COMPNAME_PV"
Return the name of the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        char *  PAD_COMPNAME_PV(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_TYPE\s0" 8
.IX Xref "PAD_COMPNAME_TYPE"
.IX Item "PAD_COMPNAME_TYPE"
Return the type (stash) of the current compiling pad name at offset
\&\f(CW\*(C`po\*(C'\fR. Must be a valid name. Returns null if not typed.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)
.Ve
.IP "pad_peg" 8
.IX Xref "pad_peg"
.IX Item "pad_peg"
When \s-1PERL_MAD\s0 is enabled, this is a small no-op function that gets called
at the start of each pad-related function.  It can be breakpointed to
track all pad operations.  The parameter is a string indicating the type
of pad operation being performed.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    pad_peg(const char *s)
.Ve
.IP "\s-1PAD_RESTORE_LOCAL\s0" 8
.IX Xref "PAD_RESTORE_LOCAL"
.IX Item "PAD_RESTORE_LOCAL"
Restore the old pad saved into the local variable opad by \s-1\fIPAD_SAVE_LOCAL\s0()\fR
.Sp
.Vb 1
\&        void    PAD_RESTORE_LOCAL(PAD *opad)
.Ve
.IP "\s-1PAD_SAVE_LOCAL\s0" 8
.IX Xref "PAD_SAVE_LOCAL"
.IX Item "PAD_SAVE_LOCAL"
Save the current pad to the local variable opad, then make the
current pad equal to npad
.Sp
.Vb 1
\&        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
.Ve
.IP "\s-1PAD_SAVE_SETNULLPAD\s0" 8
.IX Xref "PAD_SAVE_SETNULLPAD"
.IX Item "PAD_SAVE_SETNULLPAD"
Save the current pad then set it to null.
.Sp
.Vb 1
\&        void    PAD_SAVE_SETNULLPAD()
.Ve
.IP "\s-1PAD_SETSV\s0" 8
.IX Xref "PAD_SETSV"
.IX Item "PAD_SETSV"
Set the slot at offset \f(CW\*(C`po\*(C'\fR in the current pad to \f(CW\*(C`sv\*(C'\fR
.Sp
.Vb 1
\&        SV *    PAD_SETSV(PADOFFSET po, SV* sv)
.Ve
.IP "\s-1PAD_SET_CUR\s0" 8
.IX Xref "PAD_SET_CUR"
.IX Item "PAD_SET_CUR"
Set the current pad to be pad \f(CW\*(C`n\*(C'\fR in the padlist, saving
the previous current pad. \s-1NB\s0 currently this macro expands to a string too
long for some compilers, so it's best to replace it with
.Sp
.Vb 2
\&    SAVECOMPPAD();
\&    PAD_SET_CUR_NOSAVE(padlist,n);
\&
\&
\&        void    PAD_SET_CUR(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SET_CUR_NOSAVE\s0" 8
.IX Xref "PAD_SET_CUR_NOSAVE"
.IX Item "PAD_SET_CUR_NOSAVE"
like \s-1PAD_SET_CUR\s0, but without the save
.Sp
.Vb 1
\&        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SV\s0" 8
.IX Xref "PAD_SV"
.IX Item "PAD_SV"
Get the value at offset \f(CW\*(C`po\*(C'\fR in the current pad
.Sp
.Vb 1
\&        void    PAD_SV(PADOFFSET po)
.Ve
.IP "PAD_SVl" 8
.IX Xref "PAD_SVl"
.IX Item "PAD_SVl"
Lightweight and lvalue version of \f(CW\*(C`PAD_SV\*(C'\fR.
Get or set the value at offset \f(CW\*(C`po\*(C'\fR in the current pad.
Unlike \f(CW\*(C`PAD_SV\*(C'\fR, does not print diagnostics with \-DX.
For internal use only.
.Sp
.Vb 1
\&        SV *    PAD_SVl(PADOFFSET po)
.Ve
.IP "\s-1SAVECLEARSV\s0" 8
.IX Xref "SAVECLEARSV"
.IX Item "SAVECLEARSV"
Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')
.Sp
.Vb 1
\&        void    SAVECLEARSV(SV **svp)
.Ve
.IP "\s-1SAVECOMPPAD\s0" 8
.IX Xref "SAVECOMPPAD"
.IX Item "SAVECOMPPAD"
save PL_comppad and PL_curpad
.Sp
.Vb 1
\&        void    SAVECOMPPAD()
.Ve
.IP "\s-1SAVEPADSV\s0" 8
.IX Xref "SAVEPADSV"
.IX Item "SAVEPADSV"
Save a pad slot (used to restore after an iteration)
.Sp
\&\s-1XXX\s0 \s-1DAPM\s0 it would make more sense to make the arg a \s-1PADOFFSET\s0
	void	\s-1SAVEPADSV\s0(\s-1PADOFFSET\s0 po)
.SH "Per-Interpreter Variables"
.IX Header "Per-Interpreter Variables"
.IP "PL_DBsingle" 8
.IX Xref "PL_DBsingle"
.IX Item "PL_DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1SV\s0 is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See
\&\f(CW\*(C`PL_DBsub\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBsingle
.Ve
.IP "PL_DBsub" 8
.IX Xref "PL_DBsub"
.IX Item "PL_DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1GV\s0 contains
the \s-1SV\s0 which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See
\&\f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        GV *    PL_DBsub
.Ve
.IP "PL_DBtrace" 8
.IX Xref "PL_DBtrace"
.IX Item "PL_DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBtrace
.Ve
.IP "PL_dowarn" 8
.IX Xref "PL_dowarn"
.IX Item "PL_dowarn"
The C variable which corresponds to Perl's $^W warning variable.
.Sp
.Vb 1
\&        bool    PL_dowarn
.Ve
.IP "PL_last_in_gv" 8
.IX Xref "PL_last_in_gv"
.IX Item "PL_last_in_gv"
The \s-1GV\s0 which was last used for a filehandle input operation. (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
.Vb 1
\&        GV*     PL_last_in_gv
.Ve
.IP "PL_ofsgv" 8
.IX Xref "PL_ofsgv"
.IX Item "PL_ofsgv"
The glob containing the output field separator \- \f(CW\*(C`*,\*(C'\fR in Perl space.
.Sp
.Vb 1
\&        GV*     PL_ofsgv
.Ve
.IP "PL_rs" 8
.IX Xref "PL_rs"
.IX Item "PL_rs"
The input record separator \- \f(CW$/\fR in Perl space.
.Sp
.Vb 1
\&        SV*     PL_rs
.Ve
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "djSP" 8
.IX Xref "djSP"
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR. This is actually identical to \f(CW\*(C`dSP\*(C'\fR, and declares
a local copy of perl's stack pointer, available via the \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`SP\*(C'\fR.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)
.Sp
.Vb 1
\&                djSP;
.Ve
.IP "\s-1LVRET\s0" 8
.IX Xref "LVRET"
.IX Item "LVRET"
True if this op will be the return value of an lvalue subroutine
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "sv_add_arena" 8
.IX Xref "sv_add_arena"
.IX Item "sv_add_arena"
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.
.Sp
.Vb 2
\&        void    sv_add_arena(char *const ptr, const U32 size,
\&                             const U32 flags)
.Ve
.IP "sv_clean_all" 8
.IX Xref "sv_clean_all"
.IX Item "sv_clean_all"
Decrement the refcnt of each remaining \s-1SV\s0, possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.
.Sp
.Vb 1
\&        I32     sv_clean_all()
.Ve
.IP "sv_clean_objs" 8
.IX Xref "sv_clean_objs"
.IX Item "sv_clean_objs"
Attempt to destroy all objects not yet freed.
.Sp
.Vb 1
\&        void    sv_clean_objs()
.Ve
.IP "sv_free_arenas" 8
.IX Xref "sv_free_arenas"
.IX Item "sv_free_arenas"
Deallocate the memory used by all arenas.  Note that all the individual \s-1SV\s0
heads and bodies within the arenas must already have been freed.
.Sp
.Vb 1
\&        void    sv_free_arenas()
.Ve
.SH "SV-Body Allocation"
.IX Header "SV-Body Allocation"
.IP "sv_2num" 8
.IX Xref "sv_2num"
.IX Item "sv_2num"
Return an \s-1SV\s0 with the numeric value of the source \s-1SV\s0, doing any necessary
reference or overload conversion.  You must use the \f(CW\*(C`SvNUM(sv)\*(C'\fR macro to
access this function.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        SV*     sv_2num(SV *const sv)
.Ve
.IP "sv_ref" 8
.IX Xref "sv_ref"
.IX Item "sv_ref"
Returns a \s-1SV\s0 describing what the \s-1SV\s0 passed in is a reference to.
.Sp
.Vb 2
\&        SV*     sv_ref(SV *dst, const SV *const sv,
\&                       const int ob)
.Ve
.SH "Unicode Support"
.IX Header "Unicode Support"
.IP "find_uninit_var" 8
.IX Xref "find_uninit_var"
.IX Item "find_uninit_var"
Find the name of the undefined variable (if any) that caused the operator
to issue a \*(L"Use of uninitialized value\*(R" warning.
If match is true, only return a name if its value matches uninit_sv.
So roughly speaking, if a unary operator (such as \s-1OP_COS\s0) generates a
warning, then following the direct child of the op may yield an
\&\s-1OP_PADSV\s0 or \s-1OP_GV\s0 that gives the name of the undefined variable.  On the
other hand, with \s-1OP_ADD\s0 there are two branches to follow, so we only print
the variable name if we get an exact match.
.Sp
The name is returned as a mortal \s-1SV\s0.
.Sp
Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 3
\&        SV*     find_uninit_var(const OP *const obase,
\&                                const SV *const uninit_sv,
\&                                bool top)
.Ve
.IP "report_uninit" 8
.IX Xref "report_uninit"
.IX Item "report_uninit"
Print appropriate \*(L"Use of uninitialized variable\*(R" warning.
.Sp
.Vb 1
\&        void    report_uninit(const SV *uninit_sv)
.Ve
.SH "Undocumented functions"
.IX Header "Undocumented functions"
The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.
.IP "_add_range_to_invlist" 4
.IX Xref "_add_range_to_invlist"
.IX Item "_add_range_to_invlist"
.PD 0
.IP "_core_swash_init" 4
.IX Xref "_core_swash_init"
.IX Item "_core_swash_init"
.IP "_invlist_array_init" 4
.IX Xref "_invlist_array_init"
.IX Item "_invlist_array_init"
.IP "_invlist_contents" 4
.IX Xref "_invlist_contents"
.IX Item "_invlist_contents"
.IP "_invlist_intersection" 4
.IX Xref "_invlist_intersection"
.IX Item "_invlist_intersection"
.IP "_invlist_intersection_maybe_complement_2nd" 4
.IX Xref "_invlist_intersection_maybe_complement_2nd"
.IX Item "_invlist_intersection_maybe_complement_2nd"
.IP "_invlist_invert" 4
.IX Xref "_invlist_invert"
.IX Item "_invlist_invert"
.IP "_invlist_invert_prop" 4
.IX Xref "_invlist_invert_prop"
.IX Item "_invlist_invert_prop"
.IP "_invlist_populate_swatch" 4
.IX Xref "_invlist_populate_swatch"
.IX Item "_invlist_populate_swatch"
.IP "_invlist_subtract" 4
.IX Xref "_invlist_subtract"
.IX Item "_invlist_subtract"
.IP "_invlist_union" 4
.IX Xref "_invlist_union"
.IX Item "_invlist_union"
.IP "_invlist_union_maybe_complement_2nd" 4
.IX Xref "_invlist_union_maybe_complement_2nd"
.IX Item "_invlist_union_maybe_complement_2nd"
.IP "_is_utf8_\|_perl_idstart" 4
.IX Xref "_is_utf8__perl_idstart"
.IX Item "_is_utf8__perl_idstart"
.IP "_new_invlist" 4
.IX Xref "_new_invlist"
.IX Item "_new_invlist"
.IP "_swash_inversion_hash" 4
.IX Xref "_swash_inversion_hash"
.IX Item "_swash_inversion_hash"
.IP "_swash_to_invlist" 4
.IX Xref "_swash_to_invlist"
.IX Item "_swash_to_invlist"
.IP "_to_fold_latin1" 4
.IX Xref "_to_fold_latin1"
.IX Item "_to_fold_latin1"
.IP "_to_upper_title_latin1" 4
.IX Xref "_to_upper_title_latin1"
.IX Item "_to_upper_title_latin1"
.IP "aassign_common_vars" 4
.IX Xref "aassign_common_vars"
.IX Item "aassign_common_vars"
.IP "add_cp_to_invlist" 4
.IX Xref "add_cp_to_invlist"
.IX Item "add_cp_to_invlist"
.IP "addmad" 4
.IX Xref "addmad"
.IX Item "addmad"
.IP "allocmy" 4
.IX Xref "allocmy"
.IX Item "allocmy"
.IP "amagic_is_enabled" 4
.IX Xref "amagic_is_enabled"
.IX Item "amagic_is_enabled"
.IP "append_madprops" 4
.IX Xref "append_madprops"
.IX Item "append_madprops"
.IP "apply" 4
.IX Xref "apply"
.IX Item "apply"
.IP "av_reify" 4
.IX Xref "av_reify"
.IX Item "av_reify"
.IP "bind_match" 4
.IX Xref "bind_match"
.IX Item "bind_match"
.IP "block_end" 4
.IX Xref "block_end"
.IX Item "block_end"
.IP "block_start" 4
.IX Xref "block_start"
.IX Item "block_start"
.IP "boot_core_PerlIO" 4
.IX Xref "boot_core_PerlIO"
.IX Item "boot_core_PerlIO"
.IP "boot_core_UNIVERSAL" 4
.IX Xref "boot_core_UNIVERSAL"
.IX Item "boot_core_UNIVERSAL"
.IP "boot_core_mro" 4
.IX Xref "boot_core_mro"
.IX Item "boot_core_mro"
.IP "cando" 4
.IX Xref "cando"
.IX Item "cando"
.IP "check_utf8_print" 4
.IX Xref "check_utf8_print"
.IX Item "check_utf8_print"
.IP "ck_entersub_args_core" 4
.IX Xref "ck_entersub_args_core"
.IX Item "ck_entersub_args_core"
.IP "convert" 4
.IX Xref "convert"
.IX Item "convert"
.IP "coresub_op" 4
.IX Xref "coresub_op"
.IX Item "coresub_op"
.IP "create_eval_scope" 4
.IX Xref "create_eval_scope"
.IX Item "create_eval_scope"
.IP "cv_ckproto_len_flags" 4
.IX Xref "cv_ckproto_len_flags"
.IX Item "cv_ckproto_len_flags"
.IP "cvgv_set" 4
.IX Xref "cvgv_set"
.IX Item "cvgv_set"
.IP "cvstash_set" 4
.IX Xref "cvstash_set"
.IX Item "cvstash_set"
.IP "deb_stack_all" 4
.IX Xref "deb_stack_all"
.IX Item "deb_stack_all"
.IP "delete_eval_scope" 4
.IX Xref "delete_eval_scope"
.IX Item "delete_eval_scope"
.IP "die_unwind" 4
.IX Xref "die_unwind"
.IX Item "die_unwind"
.IP "do_aexec" 4
.IX Xref "do_aexec"
.IX Item "do_aexec"
.IP "do_aexec5" 4
.IX Xref "do_aexec5"
.IX Item "do_aexec5"
.IP "do_eof" 4
.IX Xref "do_eof"
.IX Item "do_eof"
.IP "do_exec" 4
.IX Xref "do_exec"
.IX Item "do_exec"
.IP "do_exec3" 4
.IX Xref "do_exec3"
.IX Item "do_exec3"
.IP "do_execfree" 4
.IX Xref "do_execfree"
.IX Item "do_execfree"
.IP "do_ipcctl" 4
.IX Xref "do_ipcctl"
.IX Item "do_ipcctl"
.IP "do_ipcget" 4
.IX Xref "do_ipcget"
.IX Item "do_ipcget"
.IP "do_msgrcv" 4
.IX Xref "do_msgrcv"
.IX Item "do_msgrcv"
.IP "do_msgsnd" 4
.IX Xref "do_msgsnd"
.IX Item "do_msgsnd"
.IP "do_ncmp" 4
.IX Xref "do_ncmp"
.IX Item "do_ncmp"
.IP "do_op_xmldump" 4
.IX Xref "do_op_xmldump"
.IX Item "do_op_xmldump"
.IP "do_pmop_xmldump" 4
.IX Xref "do_pmop_xmldump"
.IX Item "do_pmop_xmldump"
.IP "do_print" 4
.IX Xref "do_print"
.IX Item "do_print"
.IP "do_readline" 4
.IX Xref "do_readline"
.IX Item "do_readline"
.IP "do_seek" 4
.IX Xref "do_seek"
.IX Item "do_seek"
.IP "do_semop" 4
.IX Xref "do_semop"
.IX Item "do_semop"
.IP "do_shmio" 4
.IX Xref "do_shmio"
.IX Item "do_shmio"
.IP "do_sysseek" 4
.IX Xref "do_sysseek"
.IX Item "do_sysseek"
.IP "do_tell" 4
.IX Xref "do_tell"
.IX Item "do_tell"
.IP "do_trans" 4
.IX Xref "do_trans"
.IX Item "do_trans"
.IP "do_vecget" 4
.IX Xref "do_vecget"
.IX Item "do_vecget"
.IP "do_vecset" 4
.IX Xref "do_vecset"
.IX Item "do_vecset"
.IP "do_vop" 4
.IX Xref "do_vop"
.IX Item "do_vop"
.IP "dofile" 4
.IX Xref "dofile"
.IX Item "dofile"
.IP "dump_all_perl" 4
.IX Xref "dump_all_perl"
.IX Item "dump_all_perl"
.IP "dump_packsubs_perl" 4
.IX Xref "dump_packsubs_perl"
.IX Item "dump_packsubs_perl"
.IP "dump_sub_perl" 4
.IX Xref "dump_sub_perl"
.IX Item "dump_sub_perl"
.IP "dump_sv_child" 4
.IX Xref "dump_sv_child"
.IX Item "dump_sv_child"
.IP "emulate_cop_io" 4
.IX Xref "emulate_cop_io"
.IX Item "emulate_cop_io"
.IP "feature_is_enabled" 4
.IX Xref "feature_is_enabled"
.IX Item "feature_is_enabled"
.IP "find_rundefsv2" 4
.IX Xref "find_rundefsv2"
.IX Item "find_rundefsv2"
.IP "find_script" 4
.IX Xref "find_script"
.IX Item "find_script"
.IP "free_tied_hv_pool" 4
.IX Xref "free_tied_hv_pool"
.IX Item "free_tied_hv_pool"
.IP "get_db_sub" 4
.IX Xref "get_db_sub"
.IX Item "get_db_sub"
.IP "get_debug_opts" 4
.IX Xref "get_debug_opts"
.IX Item "get_debug_opts"
.IP "get_hash_seed" 4
.IX Xref "get_hash_seed"
.IX Item "get_hash_seed"
.IP "get_invlist_iter_addr" 4
.IX Xref "get_invlist_iter_addr"
.IX Item "get_invlist_iter_addr"
.IP "get_invlist_len_addr" 4
.IX Xref "get_invlist_len_addr"
.IX Item "get_invlist_len_addr"
.IP "get_invlist_version_id_addr" 4
.IX Xref "get_invlist_version_id_addr"
.IX Item "get_invlist_version_id_addr"
.IP "get_invlist_zero_addr" 4
.IX Xref "get_invlist_zero_addr"
.IX Item "get_invlist_zero_addr"
.IP "get_no_modify" 4
.IX Xref "get_no_modify"
.IX Item "get_no_modify"
.IP "get_opargs" 4
.IX Xref "get_opargs"
.IX Item "get_opargs"
.IP "get_re_arg" 4
.IX Xref "get_re_arg"
.IX Item "get_re_arg"
.IP "getenv_len" 4
.IX Xref "getenv_len"
.IX Item "getenv_len"
.IP "hfree_next_entry" 4
.IX Xref "hfree_next_entry"
.IX Item "hfree_next_entry"
.IP "hv_backreferences_p" 4
.IX Xref "hv_backreferences_p"
.IX Item "hv_backreferences_p"
.IP "hv_kill_backrefs" 4
.IX Xref "hv_kill_backrefs"
.IX Item "hv_kill_backrefs"
.IP "hv_undef_flags" 4
.IX Xref "hv_undef_flags"
.IX Item "hv_undef_flags"
.IP "init_argv_symbols" 4
.IX Xref "init_argv_symbols"
.IX Item "init_argv_symbols"
.IP "init_dbargs" 4
.IX Xref "init_dbargs"
.IX Item "init_dbargs"
.IP "init_debugger" 4
.IX Xref "init_debugger"
.IX Item "init_debugger"
.IP "invert" 4
.IX Xref "invert"
.IX Item "invert"
.IP "invlist_array" 4
.IX Xref "invlist_array"
.IX Item "invlist_array"
.IP "invlist_clone" 4
.IX Xref "invlist_clone"
.IX Item "invlist_clone"
.IP "invlist_iterinit" 4
.IX Xref "invlist_iterinit"
.IX Item "invlist_iterinit"
.IP "invlist_len" 4
.IX Xref "invlist_len"
.IX Item "invlist_len"
.IP "invlist_max" 4
.IX Xref "invlist_max"
.IX Item "invlist_max"
.IP "invlist_set_len" 4
.IX Xref "invlist_set_len"
.IX Item "invlist_set_len"
.IP "invlist_trim" 4
.IX Xref "invlist_trim"
.IX Item "invlist_trim"
.IP "io_close" 4
.IX Xref "io_close"
.IX Item "io_close"
.IP "is_utf8_X_L" 4
.IX Xref "is_utf8_X_L"
.IX Item "is_utf8_X_L"
.IP "is_utf8_X_LV" 4
.IX Xref "is_utf8_X_LV"
.IX Item "is_utf8_X_LV"
.IP "is_utf8_X_LVT" 4
.IX Xref "is_utf8_X_LVT"
.IX Item "is_utf8_X_LVT"
.IP "is_utf8_X_LV_LVT_V" 4
.IX Xref "is_utf8_X_LV_LVT_V"
.IX Item "is_utf8_X_LV_LVT_V"
.IP "is_utf8_X_T" 4
.IX Xref "is_utf8_X_T"
.IX Item "is_utf8_X_T"
.IP "is_utf8_X_V" 4
.IX Xref "is_utf8_X_V"
.IX Item "is_utf8_X_V"
.IP "is_utf8_X_begin" 4
.IX Xref "is_utf8_X_begin"
.IX Item "is_utf8_X_begin"
.IP "is_utf8_X_extend" 4
.IX Xref "is_utf8_X_extend"
.IX Item "is_utf8_X_extend"
.IP "is_utf8_X_non_hangul" 4
.IX Xref "is_utf8_X_non_hangul"
.IX Item "is_utf8_X_non_hangul"
.IP "is_utf8_X_prepend" 4
.IX Xref "is_utf8_X_prepend"
.IX Item "is_utf8_X_prepend"
.IP "jmaybe" 4
.IX Xref "jmaybe"
.IX Item "jmaybe"
.IP "keyword" 4
.IX Xref "keyword"
.IX Item "keyword"
.IP "keyword_plugin_standard" 4
.IX Xref "keyword_plugin_standard"
.IX Item "keyword_plugin_standard"
.IP "list" 4
.IX Xref "list"
.IX Item "list"
.IP "localize" 4
.IX Xref "localize"
.IX Item "localize"
.IP "mad_free" 4
.IX Xref "mad_free"
.IX Item "mad_free"
.IP "madlex" 4
.IX Xref "madlex"
.IX Item "madlex"
.IP "madparse" 4
.IX Xref "madparse"
.IX Item "madparse"
.IP "magic_clear_all_env" 4
.IX Xref "magic_clear_all_env"
.IX Item "magic_clear_all_env"
.IP "magic_clearenv" 4
.IX Xref "magic_clearenv"
.IX Item "magic_clearenv"
.IP "magic_clearisa" 4
.IX Xref "magic_clearisa"
.IX Item "magic_clearisa"
.IP "magic_clearpack" 4
.IX Xref "magic_clearpack"
.IX Item "magic_clearpack"
.IP "magic_clearsig" 4
.IX Xref "magic_clearsig"
.IX Item "magic_clearsig"
.IP "magic_existspack" 4
.IX Xref "magic_existspack"
.IX Item "magic_existspack"
.IP "magic_freearylen_p" 4
.IX Xref "magic_freearylen_p"
.IX Item "magic_freearylen_p"
.IP "magic_freeovrld" 4
.IX Xref "magic_freeovrld"
.IX Item "magic_freeovrld"
.IP "magic_get" 4
.IX Xref "magic_get"
.IX Item "magic_get"
.IP "magic_getarylen" 4
.IX Xref "magic_getarylen"
.IX Item "magic_getarylen"
.IP "magic_getdefelem" 4
.IX Xref "magic_getdefelem"
.IX Item "magic_getdefelem"
.IP "magic_getnkeys" 4
.IX Xref "magic_getnkeys"
.IX Item "magic_getnkeys"
.IP "magic_getpack" 4
.IX Xref "magic_getpack"
.IX Item "magic_getpack"
.IP "magic_getpos" 4
.IX Xref "magic_getpos"
.IX Item "magic_getpos"
.IP "magic_getsig" 4
.IX Xref "magic_getsig"
.IX Item "magic_getsig"
.IP "magic_getsubstr" 4
.IX Xref "magic_getsubstr"
.IX Item "magic_getsubstr"
.IP "magic_gettaint" 4
.IX Xref "magic_gettaint"
.IX Item "magic_gettaint"
.IP "magic_getuvar" 4
.IX Xref "magic_getuvar"
.IX Item "magic_getuvar"
.IP "magic_getvec" 4
.IX Xref "magic_getvec"
.IX Item "magic_getvec"
.IP "magic_killbackrefs" 4
.IX Xref "magic_killbackrefs"
.IX Item "magic_killbackrefs"
.IP "magic_len" 4
.IX Xref "magic_len"
.IX Item "magic_len"
.IP "magic_nextpack" 4
.IX Xref "magic_nextpack"
.IX Item "magic_nextpack"
.IP "magic_regdata_cnt" 4
.IX Xref "magic_regdata_cnt"
.IX Item "magic_regdata_cnt"
.IP "magic_regdatum_get" 4
.IX Xref "magic_regdatum_get"
.IX Item "magic_regdatum_get"
.IP "magic_regdatum_set" 4
.IX Xref "magic_regdatum_set"
.IX Item "magic_regdatum_set"
.IP "magic_scalarpack" 4
.IX Xref "magic_scalarpack"
.IX Item "magic_scalarpack"
.IP "magic_set" 4
.IX Xref "magic_set"
.IX Item "magic_set"
.IP "magic_set_all_env" 4
.IX Xref "magic_set_all_env"
.IX Item "magic_set_all_env"
.IP "magic_setamagic" 4
.IX Xref "magic_setamagic"
.IX Item "magic_setamagic"
.IP "magic_setarylen" 4
.IX Xref "magic_setarylen"
.IX Item "magic_setarylen"
.IP "magic_setcollxfrm" 4
.IX Xref "magic_setcollxfrm"
.IX Item "magic_setcollxfrm"
.IP "magic_setdbline" 4
.IX Xref "magic_setdbline"
.IX Item "magic_setdbline"
.IP "magic_setdefelem" 4
.IX Xref "magic_setdefelem"
.IX Item "magic_setdefelem"
.IP "magic_setenv" 4
.IX Xref "magic_setenv"
.IX Item "magic_setenv"
.IP "magic_setisa" 4
.IX Xref "magic_setisa"
.IX Item "magic_setisa"
.IP "magic_setmglob" 4
.IX Xref "magic_setmglob"
.IX Item "magic_setmglob"
.IP "magic_setnkeys" 4
.IX Xref "magic_setnkeys"
.IX Item "magic_setnkeys"
.IP "magic_setpack" 4
.IX Xref "magic_setpack"
.IX Item "magic_setpack"
.IP "magic_setpos" 4
.IX Xref "magic_setpos"
.IX Item "magic_setpos"
.IP "magic_setregexp" 4
.IX Xref "magic_setregexp"
.IX Item "magic_setregexp"
.IP "magic_setsig" 4
.IX Xref "magic_setsig"
.IX Item "magic_setsig"
.IP "magic_setsubstr" 4
.IX Xref "magic_setsubstr"
.IX Item "magic_setsubstr"
.IP "magic_settaint" 4
.IX Xref "magic_settaint"
.IX Item "magic_settaint"
.IP "magic_setutf8" 4
.IX Xref "magic_setutf8"
.IX Item "magic_setutf8"
.IP "magic_setuvar" 4
.IX Xref "magic_setuvar"
.IX Item "magic_setuvar"
.IP "magic_setvec" 4
.IX Xref "magic_setvec"
.IX Item "magic_setvec"
.IP "magic_setvstring" 4
.IX Xref "magic_setvstring"
.IX Item "magic_setvstring"
.IP "magic_sizepack" 4
.IX Xref "magic_sizepack"
.IX Item "magic_sizepack"
.IP "magic_wipepack" 4
.IX Xref "magic_wipepack"
.IX Item "magic_wipepack"
.IP "malloc_good_size" 4
.IX Xref "malloc_good_size"
.IX Item "malloc_good_size"
.IP "malloced_size" 4
.IX Xref "malloced_size"
.IX Item "malloced_size"
.IP "mem_collxfrm" 4
.IX Xref "mem_collxfrm"
.IX Item "mem_collxfrm"
.IP "mode_from_discipline" 4
.IX Xref "mode_from_discipline"
.IX Item "mode_from_discipline"
.IP "more_bodies" 4
.IX Xref "more_bodies"
.IX Item "more_bodies"
.IP "mro_meta_dup" 4
.IX Xref "mro_meta_dup"
.IX Item "mro_meta_dup"
.IP "mro_meta_init" 4
.IX Xref "mro_meta_init"
.IX Item "mro_meta_init"
.IP "munge_qwlist_to_paren_list" 4
.IX Xref "munge_qwlist_to_paren_list"
.IX Item "munge_qwlist_to_paren_list"
.IP "my_attrs" 4
.IX Xref "my_attrs"
.IX Item "my_attrs"
.IP "my_betoh16" 4
.IX Xref "my_betoh16"
.IX Item "my_betoh16"
.IP "my_betoh32" 4
.IX Xref "my_betoh32"
.IX Item "my_betoh32"
.IP "my_betoh64" 4
.IX Xref "my_betoh64"
.IX Item "my_betoh64"
.IP "my_betohi" 4
.IX Xref "my_betohi"
.IX Item "my_betohi"
.IP "my_betohl" 4
.IX Xref "my_betohl"
.IX Item "my_betohl"
.IP "my_betohs" 4
.IX Xref "my_betohs"
.IX Item "my_betohs"
.IP "my_clearenv" 4
.IX Xref "my_clearenv"
.IX Item "my_clearenv"
.IP "my_htobe16" 4
.IX Xref "my_htobe16"
.IX Item "my_htobe16"
.IP "my_htobe32" 4
.IX Xref "my_htobe32"
.IX Item "my_htobe32"
.IP "my_htobe64" 4
.IX Xref "my_htobe64"
.IX Item "my_htobe64"
.IP "my_htobei" 4
.IX Xref "my_htobei"
.IX Item "my_htobei"
.IP "my_htobel" 4
.IX Xref "my_htobel"
.IX Item "my_htobel"
.IP "my_htobes" 4
.IX Xref "my_htobes"
.IX Item "my_htobes"
.IP "my_htole16" 4
.IX Xref "my_htole16"
.IX Item "my_htole16"
.IP "my_htole32" 4
.IX Xref "my_htole32"
.IX Item "my_htole32"
.IP "my_htole64" 4
.IX Xref "my_htole64"
.IX Item "my_htole64"
.IP "my_htolei" 4
.IX Xref "my_htolei"
.IX Item "my_htolei"
.IP "my_htolel" 4
.IX Xref "my_htolel"
.IX Item "my_htolel"
.IP "my_htoles" 4
.IX Xref "my_htoles"
.IX Item "my_htoles"
.IP "my_letoh16" 4
.IX Xref "my_letoh16"
.IX Item "my_letoh16"
.IP "my_letoh32" 4
.IX Xref "my_letoh32"
.IX Item "my_letoh32"
.IP "my_letoh64" 4
.IX Xref "my_letoh64"
.IX Item "my_letoh64"
.IP "my_letohi" 4
.IX Xref "my_letohi"
.IX Item "my_letohi"
.IP "my_letohl" 4
.IX Xref "my_letohl"
.IX Item "my_letohl"
.IP "my_letohs" 4
.IX Xref "my_letohs"
.IX Item "my_letohs"
.IP "my_lstat_flags" 4
.IX Xref "my_lstat_flags"
.IX Item "my_lstat_flags"
.IP "my_stat_flags" 4
.IX Xref "my_stat_flags"
.IX Item "my_stat_flags"
.IP "my_swabn" 4
.IX Xref "my_swabn"
.IX Item "my_swabn"
.IP "my_unexec" 4
.IX Xref "my_unexec"
.IX Item "my_unexec"
.IP "newATTRSUB_flags" 4
.IX Xref "newATTRSUB_flags"
.IX Item "newATTRSUB_flags"
.IP "newGP" 4
.IX Xref "newGP"
.IX Item "newGP"
.IP "newMADPROP" 4
.IX Xref "newMADPROP"
.IX Item "newMADPROP"
.IP "newMADsv" 4
.IX Xref "newMADsv"
.IX Item "newMADsv"
.IP "newTOKEN" 4
.IX Xref "newTOKEN"
.IX Item "newTOKEN"
.IP "newXS_len_flags" 4
.IX Xref "newXS_len_flags"
.IX Item "newXS_len_flags"
.IP "new_warnings_bitfield" 4
.IX Xref "new_warnings_bitfield"
.IX Item "new_warnings_bitfield"
.IP "nextargv" 4
.IX Xref "nextargv"
.IX Item "nextargv"
.IP "oopsAV" 4
.IX Xref "oopsAV"
.IX Item "oopsAV"
.IP "oopsHV" 4
.IX Xref "oopsHV"
.IX Item "oopsHV"
.IP "op_clear" 4
.IX Xref "op_clear"
.IX Item "op_clear"
.IP "op_const_sv" 4
.IX Xref "op_const_sv"
.IX Item "op_const_sv"
.IP "op_getmad" 4
.IX Xref "op_getmad"
.IX Item "op_getmad"
.IP "op_getmad_weak" 4
.IX Xref "op_getmad_weak"
.IX Item "op_getmad_weak"
.IP "op_integerize" 4
.IX Xref "op_integerize"
.IX Item "op_integerize"
.IP "op_lvalue_flags" 4
.IX Xref "op_lvalue_flags"
.IX Item "op_lvalue_flags"
.IP "op_refcnt_dec" 4
.IX Xref "op_refcnt_dec"
.IX Item "op_refcnt_dec"
.IP "op_refcnt_inc" 4
.IX Xref "op_refcnt_inc"
.IX Item "op_refcnt_inc"
.IP "op_std_init" 4
.IX Xref "op_std_init"
.IX Item "op_std_init"
.IP "op_xmldump" 4
.IX Xref "op_xmldump"
.IX Item "op_xmldump"
.IP "package" 4
.IX Xref "package"
.IX Item "package"
.IP "package_version" 4
.IX Xref "package_version"
.IX Item "package_version"
.IP "parse_unicode_opts" 4
.IX Xref "parse_unicode_opts"
.IX Item "parse_unicode_opts"
.IP "parser_free" 4
.IX Xref "parser_free"
.IX Item "parser_free"
.IP "peep" 4
.IX Xref "peep"
.IX Item "peep"
.IP "pending_Slabs_to_ro" 4
.IX Xref "pending_Slabs_to_ro"
.IX Item "pending_Slabs_to_ro"
.IP "pmop_xmldump" 4
.IX Xref "pmop_xmldump"
.IX Item "pmop_xmldump"
.IP "pmruntime" 4
.IX Xref "pmruntime"
.IX Item "pmruntime"
.IP "populate_isa" 4
.IX Xref "populate_isa"
.IX Item "populate_isa"
.IP "prepend_madprops" 4
.IX Xref "prepend_madprops"
.IX Item "prepend_madprops"
.IP "qerror" 4
.IX Xref "qerror"
.IX Item "qerror"
.IP "reg_named_buff" 4
.IX Xref "reg_named_buff"
.IX Item "reg_named_buff"
.IP "reg_named_buff_iter" 4
.IX Xref "reg_named_buff_iter"
.IX Item "reg_named_buff_iter"
.IP "reg_numbered_buff_fetch" 4
.IX Xref "reg_numbered_buff_fetch"
.IX Item "reg_numbered_buff_fetch"
.IP "reg_numbered_buff_length" 4
.IX Xref "reg_numbered_buff_length"
.IX Item "reg_numbered_buff_length"
.IP "reg_numbered_buff_store" 4
.IX Xref "reg_numbered_buff_store"
.IX Item "reg_numbered_buff_store"
.IP "reg_qr_package" 4
.IX Xref "reg_qr_package"
.IX Item "reg_qr_package"
.IP "reg_temp_copy" 4
.IX Xref "reg_temp_copy"
.IX Item "reg_temp_copy"
.IP "regcurly" 4
.IX Xref "regcurly"
.IX Item "regcurly"
.IP "regprop" 4
.IX Xref "regprop"
.IX Item "regprop"
.IP "report_evil_fh" 4
.IX Xref "report_evil_fh"
.IX Item "report_evil_fh"
.IP "report_redefined_cv" 4
.IX Xref "report_redefined_cv"
.IX Item "report_redefined_cv"
.IP "report_wrongway_fh" 4
.IX Xref "report_wrongway_fh"
.IX Item "report_wrongway_fh"
.IP "rpeep" 4
.IX Xref "rpeep"
.IX Item "rpeep"
.IP "rsignal_restore" 4
.IX Xref "rsignal_restore"
.IX Item "rsignal_restore"
.IP "rsignal_save" 4
.IX Xref "rsignal_save"
.IX Item "rsignal_save"
.IP "rxres_save" 4
.IX Xref "rxres_save"
.IX Item "rxres_save"
.IP "same_dirent" 4
.IX Xref "same_dirent"
.IX Item "same_dirent"
.IP "sawparens" 4
.IX Xref "sawparens"
.IX Item "sawparens"
.IP "scalar" 4
.IX Xref "scalar"
.IX Item "scalar"
.IP "scalarvoid" 4
.IX Xref "scalarvoid"
.IX Item "scalarvoid"
.IP "set_regclass_bit" 4
.IX Xref "set_regclass_bit"
.IX Item "set_regclass_bit"
.IP "sighandler" 4
.IX Xref "sighandler"
.IX Item "sighandler"
.IP "softref2xv" 4
.IX Xref "softref2xv"
.IX Item "softref2xv"
.IP "sub_crush_depth" 4
.IX Xref "sub_crush_depth"
.IX Item "sub_crush_depth"
.IP "sv_add_backref" 4
.IX Xref "sv_add_backref"
.IX Item "sv_add_backref"
.IP "sv_catxmlpv" 4
.IX Xref "sv_catxmlpv"
.IX Item "sv_catxmlpv"
.IP "sv_catxmlpvn" 4
.IX Xref "sv_catxmlpvn"
.IX Item "sv_catxmlpvn"
.IP "sv_catxmlsv" 4
.IX Xref "sv_catxmlsv"
.IX Item "sv_catxmlsv"
.IP "sv_compile_2op_is_broken" 4
.IX Xref "sv_compile_2op_is_broken"
.IX Item "sv_compile_2op_is_broken"
.IP "sv_del_backref" 4
.IX Xref "sv_del_backref"
.IX Item "sv_del_backref"
.IP "sv_free2" 4
.IX Xref "sv_free2"
.IX Item "sv_free2"
.IP "sv_kill_backrefs" 4
.IX Xref "sv_kill_backrefs"
.IX Item "sv_kill_backrefs"
.IP "sv_sethek" 4
.IX Xref "sv_sethek"
.IX Item "sv_sethek"
.IP "sv_setsv_cow" 4
.IX Xref "sv_setsv_cow"
.IX Item "sv_setsv_cow"
.IP "sv_unglob" 4
.IX Xref "sv_unglob"
.IX Item "sv_unglob"
.IP "sv_xmlpeek" 4
.IX Xref "sv_xmlpeek"
.IX Item "sv_xmlpeek"
.IP "tied_method" 4
.IX Xref "tied_method"
.IX Item "tied_method"
.IP "token_free" 4
.IX Xref "token_free"
.IX Item "token_free"
.IP "token_getmad" 4
.IX Xref "token_getmad"
.IX Item "token_getmad"
.IP "translate_substr_offsets" 4
.IX Xref "translate_substr_offsets"
.IX Item "translate_substr_offsets"
.IP "try_amagic_bin" 4
.IX Xref "try_amagic_bin"
.IX Item "try_amagic_bin"
.IP "try_amagic_un" 4
.IX Xref "try_amagic_un"
.IX Item "try_amagic_un"
.IP "unshare_hek" 4
.IX Xref "unshare_hek"
.IX Item "unshare_hek"
.IP "utilize" 4
.IX Xref "utilize"
.IX Item "utilize"
.IP "varname" 4
.IX Xref "varname"
.IX Item "varname"
.IP "vivify_defelem" 4
.IX Xref "vivify_defelem"
.IX Item "vivify_defelem"
.IP "vivify_ref" 4
.IX Xref "vivify_ref"
.IX Item "vivify_ref"
.IP "wait4pid" 4
.IX Xref "wait4pid"
.IX Item "wait4pid"
.IP "was_lvalue_sub" 4
.IX Xref "was_lvalue_sub"
.IX Item "was_lvalue_sub"
.IP "watch" 4
.IX Xref "watch"
.IX Item "watch"
.IP "write_to_stderr" 4
.IX Xref "write_to_stderr"
.IX Item "write_to_stderr"
.IP "xmldump_all" 4
.IX Xref "xmldump_all"
.IX Item "xmldump_all"
.IP "xmldump_all_perl" 4
.IX Xref "xmldump_all_perl"
.IX Item "xmldump_all_perl"
.IP "xmldump_eval" 4
.IX Xref "xmldump_eval"
.IX Item "xmldump_eval"
.IP "xmldump_form" 4
.IX Xref "xmldump_form"
.IX Item "xmldump_form"
.IP "xmldump_indent" 4
.IX Xref "xmldump_indent"
.IX Item "xmldump_indent"
.IP "xmldump_packsubs" 4
.IX Xref "xmldump_packsubs"
.IX Item "xmldump_packsubs"
.IP "xmldump_packsubs_perl" 4
.IX Xref "xmldump_packsubs_perl"
.IX Item "xmldump_packsubs_perl"
.IP "xmldump_sub" 4
.IX Xref "xmldump_sub"
.IX Item "xmldump_sub"
.IP "xmldump_sub_perl" 4
.IX Xref "xmldump_sub_perl"
.IX Item "xmldump_sub_perl"
.IP "xmldump_vindent" 4
.IX Xref "xmldump_vindent"
.IX Item "xmldump_vindent"
.IP "xs_apiversion_bootcheck" 4
.IX Xref "xs_apiversion_bootcheck"
.IX Item "xs_apiversion_bootcheck"
.IP "xs_version_bootcheck" 4
.IX Xref "xs_version_bootcheck"
.IX Item "xs_version_bootcheck"
.IP "yyerror" 4
.IX Xref "yyerror"
.IX Item "yyerror"
.IP "yyerror_pv" 4
.IX Xref "yyerror_pv"
.IX Item "yyerror_pv"
.IP "yyerror_pvn" 4
.IX Xref "yyerror_pvn"
.IX Item "yyerror_pvn"
.IP "yylex" 4
.IX Xref "yylex"
.IX Item "yylex"
.IP "yyparse" 4
.IX Xref "yyparse"
.IX Item "yyparse"
.IP "yyunlex" 4
.IX Xref "yyunlex"
.IX Item "yyunlex"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, perlapi
                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlintern5.18.1                             0100644 0001750 0001750 00000206272 12566207441 023446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERN 1"
.TH PERLINTERN 1 "2015-08-22" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintern \- autogenerated documentation of purely internal
		 Perl functions
.SH "DESCRIPTION"
.IX Xref "internal Perl functions interpreter functions"
.IX Header "DESCRIPTION"
This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl \s-1API.\s0 In other words,
\&\fBthey are not for use in extensions\fR!
.SH "Compile-time scope hooks"
.IX Header "Compile-time scope hooks"
.IP "BhkENTRY" 8
.IX Xref "BhkENTRY"
.IX Item "BhkENTRY"
Return an entry from the \s-1BHK\s0 structure. \fIwhich\fR is a preprocessor token
indicating which entry to return. If the appropriate flag is not set
this will return \s-1NULL.\s0 The type of the return value depends on which
entry you ask for.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void *  BhkENTRY(BHK *hk, which)
.Ve
.IP "BhkFLAGS" 8
.IX Xref "BhkFLAGS"
.IX Item "BhkFLAGS"
Return the \s-1BHK\s0's flags.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        U32     BhkFLAGS(BHK *hk)
.Ve
.IP "\s-1CALL_BLOCK_HOOKS \s0" 8
.IX Xref "CALL_BLOCK_HOOKS"
.IX Item "CALL_BLOCK_HOOKS "
Call all the registered block hooks for type \fIwhich\fR. \fIwhich\fR is a
preprocessing token; the type of \fIarg\fR depends on \fIwhich\fR.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    CALL_BLOCK_HOOKS(which, arg)
.Ve
.SH "CV reference counts and CvOUTSIDE"
.IX Header "CV reference counts and CvOUTSIDE"
.IP "CvWEAKOUTSIDE" 8
.IX Xref "CvWEAKOUTSIDE"
.IX Item "CvWEAKOUTSIDE"
Each \s-1CV\s0 has a pointer, \f(CW\*(C`CvOUTSIDE()\*(C'\fR, to its lexically enclosing
\&\s-1CV \s0(if any). Because pointers to anonymous sub prototypes are
stored in \f(CW\*(C`&\*(C'\fR pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the \s-1CV\s0
pointed to by \f(CW\*(C`CvOUTSIDE\*(C'\fR in the \fIone specific instance\fR that the parent
has a \f(CW\*(C`&\*(C'\fR pad slot pointing back to us. In this case, we set the
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.
.Sp
There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg
.Sp
.Vb 1
\&    BEGIN { $a = sub { eval \*(Aq$x\*(Aq } }
.Ve
.Sp
In this case, the \s-1BEGIN\s0 is freed immediately after execution since there
are no active references to it: the anon sub prototype has
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR set since it's not a closure, and \f(CW$a\fR points to the same
\&\s-1CV,\s0 so it doesn't contribute to \s-1BEGIN\s0's refcount either.  When \f(CW$a\fR is
executed, the \f(CW\*(C`eval \*(Aq$x\*(Aq\*(C'\fR causes the chain of \f(CW\*(C`CvOUTSIDE\*(C'\fRs to be followed,
and the freed \s-1BEGIN\s0 is accessed.
.Sp
To avoid this, whenever a \s-1CV\s0 and its associated pad is freed, any
\&\f(CW\*(C`&\*(C'\fR entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's \f(CW\*(C`CvOUTSIDE\*(C'\fR is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as \f(CW$a\fR above).
.Sp
One other thing to consider is that a \s-1CV\s0 may be merely undefined
rather than freed, eg \f(CW\*(C`undef &foo\*(C'\fR. In this case, its refcount may
not have reached zero, but we still delete its pad and its \f(CW\*(C`CvROOT\*(C'\fR etc.
Since various children may still have their \f(CW\*(C`CvOUTSIDE\*(C'\fR pointing at this
undefined \s-1CV,\s0 we keep its own \f(CW\*(C`CvOUTSIDE\*(C'\fR for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:
.Sp
.Vb 5
\&    my $x = 123;
\&    sub tmp { sub { eval \*(Aq$x\*(Aq } }
\&    my $a = tmp();
\&    undef &tmp;
\&    print  $a\->();
\&
\&        bool    CvWEAKOUTSIDE(CV *cv)
.Ve
.SH "Embedding Functions"
.IX Header "Embedding Functions"
.IP "cv_dump" 8
.IX Xref "cv_dump"
.IX Item "cv_dump"
dump the contents of a \s-1CV\s0
.Sp
.Vb 1
\&        void    cv_dump(CV *cv, const char *title)
.Ve
.IP "cv_forget_slab" 8
.IX Xref "cv_forget_slab"
.IX Item "cv_forget_slab"
When a \s-1CV\s0 has a reference count on its slab (CvSLABBED), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The \s-1CV\s0 only needs to reference the slab
during compilation.  Once it is compiled and CvROOT attached, it has
finished its job, so it can forget the slab.
.Sp
.Vb 1
\&        void    cv_forget_slab(CV *cv)
.Ve
.IP "do_dump_pad" 8
.IX Xref "do_dump_pad"
.IX Item "do_dump_pad"
Dump the contents of a padlist
.Sp
.Vb 2
\&        void    do_dump_pad(I32 level, PerlIO *file,
\&                            PADLIST *padlist, int full)
.Ve
.IP "intro_my" 8
.IX Xref "intro_my"
.IX Item "intro_my"
\&\*(L"Introduce\*(R" my variables to visible status.  This is called during parsing
at the end of each statement to make lexical variables visible to
subsequent statements.
.Sp
.Vb 1
\&        U32     intro_my()
.Ve
.IP "padlist_dup" 8
.IX Xref "padlist_dup"
.IX Item "padlist_dup"
Duplicates a pad.
.Sp
.Vb 2
\&        PADLIST * padlist_dup(PADLIST *srcpad,
\&                              CLONE_PARAMS *param)
.Ve
.IP "pad_alloc_name" 8
.IX Xref "pad_alloc_name"
.IX Item "pad_alloc_name"
Allocates a place in the currently-compiling
pad (via \*(L"pad_alloc\*(R" in perlapi) and
then stores a name for that entry.  \fInamesv\fR is adopted and becomes the
name entry; it must already contain the name string and be sufficiently
upgraded.  \fItypestash\fR and \fIourstash\fR and the \f(CW\*(C`padadd_STATE\*(C'\fR flag get
added to \fInamesv\fR.  None of the other
processing of \*(L"pad_add_name_pvn\*(R" in perlapi
is done.  Returns the offset of the allocated pad slot.
.Sp
.Vb 2
\&        PADOFFSET pad_alloc_name(SV *namesv, U32 flags,
\&                                 HV *typestash, HV *ourstash)
.Ve
.IP "pad_block_start" 8
.IX Xref "pad_block_start"
.IX Item "pad_block_start"
Update the pad compilation state variables on entry to a new block.
.Sp
.Vb 1
\&        void    pad_block_start(int full)
.Ve
.IP "pad_check_dup" 8
.IX Xref "pad_check_dup"
.IX Item "pad_check_dup"
Check for duplicate declarations: report any of:
.Sp
.Vb 3
\&     * a my in the current scope with the same name;
\&     * an our (anywhere in the pad) with the same name and the
\&       same stash as C<ourstash>
.Ve
.Sp
\&\f(CW\*(C`is_our\*(C'\fR indicates that the name to check is an 'our' declaration.
.Sp
.Vb 2
\&        void    pad_check_dup(SV *name, U32 flags,
\&                              const HV *ourstash)
.Ve
.IP "pad_findlex" 8
.IX Xref "pad_findlex"
.IX Item "pad_findlex"
Find a named lexical anywhere in a chain of nested pads. Add fake entries
in the inner pads if it's found in an outer one.
.Sp
Returns the offset in the bottom pad of the lex or the fake lex.
cv is the \s-1CV\s0 in which to start the search, and seq is the current cop_seq
to match against. If warn is true, print appropriate warnings.  The out_*
vars return values, and so are pointers to where the returned values
should be stored. out_capture, if non-null, requests that the innermost
instance of the lexical is captured; out_name_sv is set to the innermost
matched namesv or fake namesv; out_flags returns the flags normally
associated with the \s-1IVX\s0 field of a fake namesv.
.Sp
Note that \fIpad_findlex()\fR is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries as it goes. It has to be this way
because fake namesvs in anon protoypes have to store in xlow the index into
the parent pad.
.Sp
.Vb 5
\&        PADOFFSET pad_findlex(const char *namepv,
\&                              STRLEN namelen, U32 flags,
\&                              const CV* cv, U32 seq, int warn,
\&                              SV** out_capture,
\&                              SV** out_name_sv, int *out_flags)
.Ve
.IP "pad_fixup_inner_anons" 8
.IX Xref "pad_fixup_inner_anons"
.IX Item "pad_fixup_inner_anons"
For any anon CVs in the pad, change CvOUTSIDE of that \s-1CV\s0 from
old_cv to new_cv if necessary. Needed when a newly-compiled \s-1CV\s0 has to be
moved to a pre-existing \s-1CV\s0 struct.
.Sp
.Vb 2
\&        void    pad_fixup_inner_anons(PADLIST *padlist,
\&                                      CV *old_cv, CV *new_cv)
.Ve
.IP "pad_free" 8
.IX Xref "pad_free"
.IX Item "pad_free"
Free the \s-1SV\s0 at offset po in the current pad.
.Sp
.Vb 1
\&        void    pad_free(PADOFFSET po)
.Ve
.IP "pad_leavemy" 8
.IX Xref "pad_leavemy"
.IX Item "pad_leavemy"
Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.
.Sp
.Vb 1
\&        void    pad_leavemy()
.Ve
.IP "pad_push" 8
.IX Xref "pad_push"
.IX Item "pad_push"
Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an \f(CW@_\fR in slot zero.
.Sp
.Vb 1
\&        void    pad_push(PADLIST *padlist, int depth)
.Ve
.IP "pad_reset" 8
.IX Xref "pad_reset"
.IX Item "pad_reset"
Mark all the current temporaries for reuse
.Sp
.Vb 1
\&        void    pad_reset()
.Ve
.IP "pad_swipe" 8
.IX Xref "pad_swipe"
.IX Item "pad_swipe"
Abandon the tmp in the current pad at offset po and replace with a
new one.
.Sp
.Vb 1
\&        void    pad_swipe(PADOFFSET po, bool refadjust)
.Ve
.SH "Functions in file op.c"
.IX Header "Functions in file op.c"
.IP "core_prototype" 8
.IX Xref "core_prototype"
.IX Item "core_prototype"
This function assigns the prototype of the named core function to \f(CW\*(C`sv\*(C'\fR, or
to a new mortal \s-1SV\s0 if \f(CW\*(C`sv\*(C'\fR is \s-1NULL. \s0 It returns the modified \f(CW\*(C`sv\*(C'\fR, or
\&\s-1NULL\s0 if the core function has no prototype.  \f(CW\*(C`code\*(C'\fR is a code as returned
by \f(CW\*(C`keyword()\*(C'\fR.  It must not be equal to 0 or \-KEY_CORE.
.Sp
.Vb 3
\&        SV *    core_prototype(SV *sv, const char *name,
\&                               const int code,
\&                               int * const opnum)
.Ve
.SH "Functions in file pp_ctl.c"
.IX Header "Functions in file pp_ctl.c"
.IP "docatch" 8
.IX Xref "docatch"
.IX Item "docatch"
Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.
.Sp
0 is used as continue inside eval,
.Sp
3 is used for a die caught by an inner eval \- continue inner loop
.Sp
See cop.h: je_mustcatch, when set at any runlevel to \s-1TRUE,\s0 means eval ops must
establish a local jmpenv to handle exception traps.
.Sp
.Vb 1
\&        OP*     docatch(OP *o)
.Ve
.SH "GV Functions"
.IX Header "GV Functions"
.IP "gv_try_downgrade" 8
.IX Xref "gv_try_downgrade"
.IX Item "gv_try_downgrade"
If the typeglob \f(CW\*(C`gv\*(C'\fR can be expressed more succinctly, by having
something other than a real \s-1GV\s0 in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that \f(CW\*(C`gv\*(C'\fR
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a \s-1GV\s0 has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real \s-1GV\s0 isn't required after all.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a completely empty typeglob, it is deleted from the stash.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    gv_try_downgrade(GV* gv)
.Ve
.SH "Hash Manipulation Functions"
.IX Header "Hash Manipulation Functions"
.IP "hv_ename_add" 8
.IX Xref "hv_ename_add"
.IX Item "hv_ename_add"
Adds a name to a stash's internal list of effective names.  See
\&\f(CW\*(C`hv_ename_delete\*(C'\fR.
.Sp
This is called when a stash is assigned to a new location in the symbol
table.
.Sp
.Vb 2
\&        void    hv_ename_add(HV *hv, const char *name, U32 len,
\&                             U32 flags)
.Ve
.IP "hv_ename_delete" 8
.IX Xref "hv_ename_delete"
.IX Item "hv_ename_delete"
Removes a name from a stash's internal list of effective names.  If this is
the name returned by \f(CW\*(C`HvENAME\*(C'\fR, then another name in the list will take
its place (\f(CW\*(C`HvENAME\*(C'\fR will use it).
.Sp
This is called when a stash is deleted from the symbol table.
.Sp
.Vb 2
\&        void    hv_ename_delete(HV *hv, const char *name,
\&                                U32 len, U32 flags)
.Ve
.IP "refcounted_he_chain_2hv" 8
.IX Xref "refcounted_he_chain_2hv"
.IX Item "refcounted_he_chain_2hv"
Generates and returns a \f(CW\*(C`HV *\*(C'\fR representing the content of a
\&\f(CW\*(C`refcounted_he\*(C'\fR chain.
\&\fIflags\fR is currently unused and must be zero.
.Sp
.Vb 3
\&        HV *    refcounted_he_chain_2hv(
\&                    const struct refcounted_he *c, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pv" 8
.IX Xref "refcounted_he_fetch_pv"
.IX Item "refcounted_he_fetch_pv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pv(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvn" 8
.IX Xref "refcounted_he_fetch_pvn"
.IX Item "refcounted_he_fetch_pvn"
Search along a \f(CW\*(C`refcounted_he\*(C'\fR chain for an entry with the key specified
by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR
bit set, the key octets are interpreted as \s-1UTF\-8,\s0 otherwise they
are interpreted as Latin\-1.  \fIhash\fR is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or \f(CW&PL_sv_placeholder\fR
if there is no value associated with the key.
.Sp
.Vb 5
\&        SV *    refcounted_he_fetch_pvn(
\&                    const struct refcounted_he *chain,
\&                    const char *keypv, STRLEN keylen, U32 hash,
\&                    U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvs" 8
.IX Xref "refcounted_he_fetch_pvs"
.IX Item "refcounted_he_fetch_pvs"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pvs(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_sv" 8
.IX Xref "refcounted_he_fetch_sv"
.IX Item "refcounted_he_fetch_sv"
Like \*(L"refcounted_he_fetch_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_sv(
\&                    const struct refcounted_he *chain, SV *key,
\&                    U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_free" 8
.IX Xref "refcounted_he_free"
.IX Item "refcounted_he_free"
Decrements the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent \f(CW\*(C`refcounted_he\*(C'\fR's
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.
.Sp
.Vb 1
\&        void    refcounted_he_free(struct refcounted_he *he)
.Ve
.IP "refcounted_he_inc" 8
.IX Xref "refcounted_he_inc"
.IX Item "refcounted_he_inc"
Increment the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR.  The pointer to the
\&\f(CW\*(C`refcounted_he\*(C'\fR is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.
.Sp
.Vb 3
\&        struct refcounted_he * refcounted_he_inc(
\&                                   struct refcounted_he *he
\&                               )
.Ve
.IP "refcounted_he_new_pv" 8
.IX Xref "refcounted_he_new_pv"
.IX Item "refcounted_he_new_pv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a nul-terminated string instead
of a string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pv(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvn" 8
.IX Xref "refcounted_he_new_pvn"
.IX Item "refcounted_he_new_pvn"
Creates a new \f(CW\*(C`refcounted_he\*(C'\fR.  This consists of a single key/value
pair and a reference to an existing \f(CW\*(C`refcounted_he\*(C'\fR chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.
.Sp
The new key is specified by \fIkeypv\fR and \fIkeylen\fR.  If \fIflags\fR has
the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR bit set, the key octets are interpreted
as \s-1UTF\-8,\s0 otherwise they are interpreted as Latin\-1.  \fIhash\fR is
a precomputed hash of the key string, or zero if it has not been
precomputed.
.Sp
\&\fIvalue\fR is the scalar value to store for this key.  \fIvalue\fR is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the \f(CW\*(C`refcounted_he\*(C'\fR.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
\&\fIvalue\fR may be either null or \f(CW&PL_sv_placeholder\fR to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.
.Sp
\&\fIparent\fR points to the rest of the \f(CW\*(C`refcounted_he\*(C'\fR chain to be
attached to the new \f(CW\*(C`refcounted_he\*(C'\fR.  This function takes ownership
of one reference to \fIparent\fR, and returns one reference to the new
\&\f(CW\*(C`refcounted_he\*(C'\fR.
.Sp
.Vb 6
\&        struct refcounted_he * refcounted_he_new_pvn(
\&                                   struct refcounted_he *parent,
\&                                   const char *keypv,
\&                                   STRLEN keylen, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvs" 8
.IX Xref "refcounted_he_new_pvs"
.IX Item "refcounted_he_new_pvs"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a literal string instead of
a string/length pair, and no precomputed hash.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pvs(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_sv" 8
.IX Xref "refcounted_he_new_sv"
.IX Item "refcounted_he_new_sv"
Like \*(L"refcounted_he_new_pvn\*(R", but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_sv(
\&                                   struct refcounted_he *parent,
\&                                   SV *key, U32 hash, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.SH "IO Functions"
.IX Header "IO Functions"
.IP "start_glob" 8
.IX Xref "start_glob"
.IX Item "start_glob"
Function called by \f(CW\*(C`do_readline\*(C'\fR to spawn a glob (or do the glob inside
perl on \s-1VMS\s0). This code used to be inline, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starter is only used by miniperl during the build process.
Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        PerlIO* start_glob(SV *tmpglob, IO *io)
.Ve
.SH "Magical Functions"
.IX Header "Magical Functions"
.IP "magic_clearhint" 8
.IX Xref "magic_clearhint"
.IX Item "magic_clearhint"
Triggered by a delete from %^H, records the key to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhint(SV* sv, MAGIC* mg)
.Ve
.IP "magic_clearhints" 8
.IX Xref "magic_clearhints"
.IX Item "magic_clearhints"
Triggered by clearing %^H, resets \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhints(SV* sv, MAGIC* mg)
.Ve
.IP "magic_methcall" 8
.IX Xref "magic_methcall"
.IX Item "magic_methcall"
Invoke a magic method (like \s-1FETCH\s0).
.Sp
\&\f(CW\*(C`sv\*(C'\fR and \f(CW\*(C`mg\*(C'\fR are the tied thingy and the tie magic.
.Sp
\&\f(CW\*(C`meth\*(C'\fR is the name of the method to call.
.Sp
\&\f(CW\*(C`argc\*(C'\fR is the number of args (in addition to \f(CW$self\fR) to pass to the method.
.Sp
The \f(CW\*(C`flags\*(C'\fR can be:
.Sp
.Vb 4
\&    G_DISCARD     invoke method with G_DISCARD flag and don\*(Aqt
\&                  return a value
\&    G_UNDEF_FILL  fill the stack with argc pointers to
\&                  PL_sv_undef
.Ve
.Sp
The arguments themselves are any values following the \f(CW\*(C`flags\*(C'\fR argument.
.Sp
Returns the \s-1SV \s0(if any) returned by the method, or \s-1NULL\s0 on failure.
.Sp
.Vb 3
\&        SV*     magic_methcall(SV *sv, const MAGIC *mg,
\&                               const char *meth, U32 flags,
\&                               U32 argc, ...)
.Ve
.IP "magic_sethint" 8
.IX Xref "magic_sethint"
.IX Item "magic_sethint"
Triggered by a store to %^H, records the key/value pair to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.
.Sp
.Vb 1
\&        int     magic_sethint(SV* sv, MAGIC* mg)
.Ve
.IP "mg_localize" 8
.IX Xref "mg_localize"
.IX Item "mg_localize"
Copy some of the magic from an existing \s-1SV\s0 to new localized version of that
\&\s-1SV.\s0 Container magic (eg \f(CW%ENV\fR, \f(CW$1\fR, tie) gets copied, value magic doesn't (eg
taint, pos).
.Sp
If setmagic is false then no set magic will be called on the new (empty) \s-1SV.\s0
This typically means that assignment will soon follow (e.g. 'local \f(CW$x\fR = \f(CW$y\fR'),
and that will handle the magic.
.Sp
.Vb 1
\&        void    mg_localize(SV* sv, SV* nsv, bool setmagic)
.Ve
.SH "MRO Functions"
.IX Header "MRO Functions"
.IP "mro_get_linear_isa_dfs" 8
.IX Xref "mro_get_linear_isa_dfs"
.IX Item "mro_get_linear_isa_dfs"
Returns the Depth-First Search linearization of \f(CW@ISA\fR
the given stash.  The return value is a read-only AV*.
\&\f(CW\*(C`level\*(C'\fR should be 0 (it is used internally in this
function's recursion).
.Sp
You are responsible for \f(CW\*(C`SvREFCNT_inc()\*(C'\fR on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).
.Sp
.Vb 1
\&        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)
.Ve
.IP "mro_isa_changed_in" 8
.IX Xref "mro_isa_changed_in"
.IX Item "mro_isa_changed_in"
Takes the necessary steps (cache invalidations, mostly)
when the \f(CW@ISA\fR of the given package has changed.  Invoked
by the \f(CW\*(C`setisa\*(C'\fR magic, should not need to invoke directly.
.Sp
.Vb 1
\&        void    mro_isa_changed_in(HV* stash)
.Ve
.IP "mro_package_moved" 8
.IX Xref "mro_package_moved"
.IX Item "mro_package_moved"
Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  \f(CW\*(C`stash\*(C'\fR is the stash that has been
assigned. \f(CW\*(C`oldstash\*(C'\fR is the stash it replaces, if any.  \f(CW\*(C`gv\*(C'\fR is the glob
that is actually being assigned to.
.Sp
This can also be called with a null first argument to
indicate that \f(CW\*(C`oldstash\*(C'\fR has been deleted.
.Sp
This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in \f(CW\*(C`stash\*(C'\fR.
.Sp
It also sets the effective names (\f(CW\*(C`HvENAME\*(C'\fR) on all the stashes as
appropriate.
.Sp
If the \f(CW\*(C`gv\*(C'\fR is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if \f(CW\*(C`flags & 1\*(C'\fR.
.Sp
.Vb 4
\&        void    mro_package_moved(HV * const stash,
\&                                  HV * const oldstash,
\&                                  const GV * const gv,
\&                                  U32 flags)
.Ve
.SH "Optree Manipulation Functions"
.IX Header "Optree Manipulation Functions"
.IP "finalize_optree" 8
.IX Xref "finalize_optree"
.IX Item "finalize_optree"
This function finalizes the optree. Should be called directly after
the complete optree is built. It does some additional
checking which can't be done in the normal ck_xxx functions and makes
the tree thread-safe.
.Sp
.Vb 1
\&        void    finalize_optree(OP* o)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "\s-1CX_CURPAD_SAVE \s0" 8
.IX Xref "CX_CURPAD_SAVE"
.IX Item "CX_CURPAD_SAVE "
Save the current pad in the given context block structure.
.Sp
.Vb 1
\&        void    CX_CURPAD_SAVE(struct context)
.Ve
.IP "\s-1CX_CURPAD_SV \s0" 8
.IX Xref "CX_CURPAD_SV"
.IX Item "CX_CURPAD_SV "
Access the \s-1SV\s0 at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).
.Sp
.Vb 1
\&        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)
.Ve
.IP "PadnameIsOUR" 8
.IX Xref "PadnameIsOUR"
.IX Item "PadnameIsOUR"
Whether this is an \*(L"our\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsOUR(PADNAME pn)
.Ve
.IP "PadnameIsSTATE" 8
.IX Xref "PadnameIsSTATE"
.IX Item "PadnameIsSTATE"
Whether this is a \*(L"state\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsSTATE(PADNAME pn)
.Ve
.IP "PadnameOURSTASH" 8
.IX Xref "PadnameOURSTASH"
.IX Item "PadnameOURSTASH"
The stash in which this \*(L"our\*(R" variable was declared.
.Sp
.Vb 1
\&        HV *    PadnameOURSTASH()
.Ve
.IP "PadnameOUTER" 8
.IX Xref "PadnameOUTER"
.IX Item "PadnameOUTER"
Whether this entry belongs to an outer pad.
.Sp
.Vb 1
\&        bool    PadnameOUTER(PADNAME pn)
.Ve
.IP "PadnameTYPE" 8
.IX Xref "PadnameTYPE"
.IX Item "PadnameTYPE"
The stash associated with a typed lexical.  This returns the \f(CW%Foo::\fR hash
for \f(CW\*(C`my Foo $bar\*(C'\fR.
.Sp
.Vb 1
\&        HV *    PadnameTYPE(PADNAME pn)
.Ve
.IP "\s-1PAD_BASE_SV \s0" 8
.IX Xref "PAD_BASE_SV"
.IX Item "PAD_BASE_SV "
Get the value from slot \f(CW\*(C`po\*(C'\fR in the base (DEPTH=1) pad of a padlist
.Sp
.Vb 1
\&        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
.Ve
.IP "\s-1PAD_CLONE_VARS \s0" 8
.IX Xref "PAD_CLONE_VARS"
.IX Item "PAD_CLONE_VARS "
Clone the state variables associated with running and compiling pads.
.Sp
.Vb 2
\&        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
\&                               CLONE_PARAMS* param)
.Ve
.IP "\s-1PAD_COMPNAME_FLAGS \s0" 8
.IX Xref "PAD_COMPNAME_FLAGS"
.IX Item "PAD_COMPNAME_FLAGS "
Return the flags for the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_GEN \s0" 8
.IX Xref "PAD_COMPNAME_GEN"
.IX Item "PAD_COMPNAME_GEN "
The generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
compiling pad (lvalue). Note that \f(CW\*(C`SvUVX\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
.Ve
.IP "PAD_COMPNAME_GEN_set" 8
.IX Xref "PAD_COMPNAME_GEN_set"
.IX Item "PAD_COMPNAME_GEN_set"
Sets the generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
ling pad (lvalue) to \f(CW\*(C`gen\*(C'\fR.  Note that \f(CW\*(C`SvUV_set\*(C'\fR is hijacked for this purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
.Ve
.IP "\s-1PAD_COMPNAME_OURSTASH \s0" 8
.IX Xref "PAD_COMPNAME_OURSTASH"
.IX Item "PAD_COMPNAME_OURSTASH "
Return the stash associated with an \f(CW\*(C`our\*(C'\fR variable.
Assumes the slot entry is a valid \f(CW\*(C`our\*(C'\fR lexical.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_PV \s0" 8
.IX Xref "PAD_COMPNAME_PV"
.IX Item "PAD_COMPNAME_PV "
Return the name of the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR. Assumes a valid slot entry.
.Sp
.Vb 1
\&        char *  PAD_COMPNAME_PV(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_TYPE \s0" 8
.IX Xref "PAD_COMPNAME_TYPE"
.IX Item "PAD_COMPNAME_TYPE "
Return the type (stash) of the current compiling pad name at offset
\&\f(CW\*(C`po\*(C'\fR. Must be a valid name. Returns null if not typed.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)
.Ve
.IP "pad_peg" 8
.IX Xref "pad_peg"
.IX Item "pad_peg"
When \s-1PERL_MAD\s0 is enabled, this is a small no-op function that gets called
at the start of each pad-related function.  It can be breakpointed to
track all pad operations.  The parameter is a string indicating the type
of pad operation being performed.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        void    pad_peg(const char *s)
.Ve
.IP "\s-1PAD_RESTORE_LOCAL \s0" 8
.IX Xref "PAD_RESTORE_LOCAL"
.IX Item "PAD_RESTORE_LOCAL "
Restore the old pad saved into the local variable opad by \s-1\fIPAD_SAVE_LOCAL\s0()\fR
.Sp
.Vb 1
\&        void    PAD_RESTORE_LOCAL(PAD *opad)
.Ve
.IP "\s-1PAD_SAVE_LOCAL \s0" 8
.IX Xref "PAD_SAVE_LOCAL"
.IX Item "PAD_SAVE_LOCAL "
Save the current pad to the local variable opad, then make the
current pad equal to npad
.Sp
.Vb 1
\&        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
.Ve
.IP "\s-1PAD_SAVE_SETNULLPAD \s0" 8
.IX Xref "PAD_SAVE_SETNULLPAD"
.IX Item "PAD_SAVE_SETNULLPAD "
Save the current pad then set it to null.
.Sp
.Vb 1
\&        void    PAD_SAVE_SETNULLPAD()
.Ve
.IP "\s-1PAD_SETSV \s0" 8
.IX Xref "PAD_SETSV"
.IX Item "PAD_SETSV "
Set the slot at offset \f(CW\*(C`po\*(C'\fR in the current pad to \f(CW\*(C`sv\*(C'\fR
.Sp
.Vb 1
\&        SV *    PAD_SETSV(PADOFFSET po, SV* sv)
.Ve
.IP "\s-1PAD_SET_CUR \s0" 8
.IX Xref "PAD_SET_CUR"
.IX Item "PAD_SET_CUR "
Set the current pad to be pad \f(CW\*(C`n\*(C'\fR in the padlist, saving
the previous current pad. \s-1NB\s0 currently this macro expands to a string too
long for some compilers, so it's best to replace it with
.Sp
.Vb 2
\&    SAVECOMPPAD();
\&    PAD_SET_CUR_NOSAVE(padlist,n);
\&
\&
\&        void    PAD_SET_CUR(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SET_CUR_NOSAVE \s0" 8
.IX Xref "PAD_SET_CUR_NOSAVE"
.IX Item "PAD_SET_CUR_NOSAVE "
like \s-1PAD_SET_CUR,\s0 but without the save
.Sp
.Vb 1
\&        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SV \s0" 8
.IX Xref "PAD_SV"
.IX Item "PAD_SV "
Get the value at offset \f(CW\*(C`po\*(C'\fR in the current pad
.Sp
.Vb 1
\&        void    PAD_SV(PADOFFSET po)
.Ve
.IP "PAD_SVl" 8
.IX Xref "PAD_SVl"
.IX Item "PAD_SVl"
Lightweight and lvalue version of \f(CW\*(C`PAD_SV\*(C'\fR.
Get or set the value at offset \f(CW\*(C`po\*(C'\fR in the current pad.
Unlike \f(CW\*(C`PAD_SV\*(C'\fR, does not print diagnostics with \-DX.
For internal use only.
.Sp
.Vb 1
\&        SV *    PAD_SVl(PADOFFSET po)
.Ve
.IP "\s-1SAVECLEARSV \s0" 8
.IX Xref "SAVECLEARSV"
.IX Item "SAVECLEARSV "
Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')
.Sp
.Vb 1
\&        void    SAVECLEARSV(SV **svp)
.Ve
.IP "\s-1SAVECOMPPAD \s0" 8
.IX Xref "SAVECOMPPAD"
.IX Item "SAVECOMPPAD "
save PL_comppad and PL_curpad
.Sp
.Vb 1
\&        void    SAVECOMPPAD()
.Ve
.IP "\s-1SAVEPADSV \s0" 8
.IX Xref "SAVEPADSV"
.IX Item "SAVEPADSV "
Save a pad slot (used to restore after an iteration)
.Sp
\&\s-1XXX DAPM\s0 it would make more sense to make the arg a \s-1PADOFFSET
\&\s0	void	\s-1SAVEPADSV\s0(\s-1PADOFFSET\s0 po)
.SH "Per-Interpreter Variables"
.IX Header "Per-Interpreter Variables"
.IP "PL_DBsingle" 8
.IX Xref "PL_DBsingle"
.IX Item "PL_DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1SV\s0 is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See
\&\f(CW\*(C`PL_DBsub\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBsingle
.Ve
.IP "PL_DBsub" 8
.IX Xref "PL_DBsub"
.IX Item "PL_DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this \s-1GV\s0 contains
the \s-1SV\s0 which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See
\&\f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        GV *    PL_DBsub
.Ve
.IP "PL_DBtrace" 8
.IX Xref "PL_DBtrace"
.IX Item "PL_DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBtrace
.Ve
.IP "PL_dowarn" 8
.IX Xref "PL_dowarn"
.IX Item "PL_dowarn"
The C variable which corresponds to Perl's $^W warning variable.
.Sp
.Vb 1
\&        bool    PL_dowarn
.Ve
.IP "PL_last_in_gv" 8
.IX Xref "PL_last_in_gv"
.IX Item "PL_last_in_gv"
The \s-1GV\s0 which was last used for a filehandle input operation. (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
.Vb 1
\&        GV*     PL_last_in_gv
.Ve
.IP "PL_ofsgv" 8
.IX Xref "PL_ofsgv"
.IX Item "PL_ofsgv"
The glob containing the output field separator \- \f(CW\*(C`*,\*(C'\fR in Perl space.
.Sp
.Vb 1
\&        GV*     PL_ofsgv
.Ve
.IP "PL_rs" 8
.IX Xref "PL_rs"
.IX Item "PL_rs"
The input record separator \- \f(CW$/\fR in Perl space.
.Sp
.Vb 1
\&        SV*     PL_rs
.Ve
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "djSP" 8
.IX Xref "djSP"
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR. This is actually identical to \f(CW\*(C`dSP\*(C'\fR, and declares
a local copy of perl's stack pointer, available via the \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`SP\*(C'\fR.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)
.Sp
.Vb 1
\&                djSP;
.Ve
.IP "\s-1LVRET \s0" 8
.IX Xref "LVRET"
.IX Item "LVRET "
True if this op will be the return value of an lvalue subroutine
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "SvTHINKFIRST" 8
.IX Xref "SvTHINKFIRST"
.IX Item "SvTHINKFIRST"
A quick flag check to see whether an sv should be passed to sv_force_normal
to be \*(L"downgraded\*(R" before SvIVX or SvPVX can be modified directly.
.Sp
For example, if your scalar is a reference and you want to modify the SvIVX
slot, you can't just do SvROK_off, as that will leak the referent.
.Sp
This is used internally by various sv-modifying functions, such as
sv_setsv, sv_setiv and sv_pvn_force.
.Sp
One case that this does not handle is a gv without SvFAKE set.  After
.Sp
.Vb 1
\&    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
.Ve
.Sp
it will still be a gv.
.Sp
SvTHINKFIRST sometimes produces false positives.  In those cases
sv_force_normal does nothing.
.Sp
.Vb 1
\&        U32     SvTHINKFIRST(SV *sv)
.Ve
.IP "sv_add_arena" 8
.IX Xref "sv_add_arena"
.IX Item "sv_add_arena"
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.
.Sp
.Vb 2
\&        void    sv_add_arena(char *const ptr, const U32 size,
\&                             const U32 flags)
.Ve
.IP "sv_clean_all" 8
.IX Xref "sv_clean_all"
.IX Item "sv_clean_all"
Decrement the refcnt of each remaining \s-1SV,\s0 possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.
.Sp
.Vb 1
\&        I32     sv_clean_all()
.Ve
.IP "sv_clean_objs" 8
.IX Xref "sv_clean_objs"
.IX Item "sv_clean_objs"
Attempt to destroy all objects not yet freed.
.Sp
.Vb 1
\&        void    sv_clean_objs()
.Ve
.IP "sv_free_arenas" 8
.IX Xref "sv_free_arenas"
.IX Item "sv_free_arenas"
Deallocate the memory used by all arenas.  Note that all the individual \s-1SV\s0
heads and bodies within the arenas must already have been freed.
.Sp
.Vb 1
\&        void    sv_free_arenas()
.Ve
.SH "SV-Body Allocation"
.IX Header "SV-Body Allocation"
.IP "sv_2num" 8
.IX Xref "sv_2num"
.IX Item "sv_2num"
Return an \s-1SV\s0 with the numeric value of the source \s-1SV,\s0 doing any necessary
reference or overload conversion.  You must use the \f(CW\*(C`SvNUM(sv)\*(C'\fR macro to
access this function.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 1
\&        SV*     sv_2num(SV *const sv)
.Ve
.IP "sv_copypv" 8
.IX Xref "sv_copypv"
.IX Item "sv_copypv"
Copies a stringified representation of the source \s-1SV\s0 into the
destination \s-1SV. \s0 Automatically performs any necessary mg_get and
coercion of numeric values into strings.  Guaranteed to preserve
\&\s-1UTF8\s0 flag even from overloaded objects.  Similar in nature to
sv_2pv[_flags] but operates directly on an \s-1SV\s0 instead of just the
string.  Mostly uses sv_2pv_flags to do its work, except when that
would lose the \s-1UTF\-8\s0'ness of the \s-1PV.\s0
.Sp
.Vb 1
\&        void    sv_copypv(SV *const dsv, SV *const ssv)
.Ve
.IP "sv_ref" 8
.IX Xref "sv_ref"
.IX Item "sv_ref"
Returns a \s-1SV\s0 describing what the \s-1SV\s0 passed in is a reference to.
.Sp
.Vb 2
\&        SV*     sv_ref(SV *dst, const SV *const sv,
\&                       const int ob)
.Ve
.SH "Unicode Support"
.IX Header "Unicode Support"
.IP "find_uninit_var" 8
.IX Xref "find_uninit_var"
.IX Item "find_uninit_var"
Find the name of the undefined variable (if any) that caused the operator
to issue a \*(L"Use of uninitialized value\*(R" warning.
If match is true, only return a name if its value matches uninit_sv.
So roughly speaking, if a unary operator (such as \s-1OP_COS\s0) generates a
warning, then following the direct child of the op may yield an
\&\s-1OP_PADSV\s0 or \s-1OP_GV\s0 that gives the name of the undefined variable.  On the
other hand, with \s-1OP_ADD\s0 there are two branches to follow, so we only print
the variable name if we get an exact match.
.Sp
The name is returned as a mortal \s-1SV.\s0
.Sp
Assumes that PL_op is the op that originally triggered the error, and that
PL_comppad/PL_curpad points to the currently executing pad.
.Sp
\&\s-1NOTE:\s0 this function is experimental and may change or be
removed without notice.
.Sp
.Vb 3
\&        SV*     find_uninit_var(const OP *const obase,
\&                                const SV *const uninit_sv,
\&                                bool top)
.Ve
.IP "report_uninit" 8
.IX Xref "report_uninit"
.IX Item "report_uninit"
Print appropriate \*(L"Use of uninitialized variable\*(R" warning.
.Sp
.Vb 1
\&        void    report_uninit(const SV *uninit_sv)
.Ve
.SH "Undocumented functions"
.IX Header "Undocumented functions"
The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.
.IP "Perl_croak_memory_wrap" 4
.IX Xref "Perl_croak_memory_wrap"
.IX Item "Perl_croak_memory_wrap"
.PD 0
.IP "Slab_Alloc" 4
.IX Xref "Slab_Alloc"
.IX Item "Slab_Alloc"
.IP "Slab_Free" 4
.IX Xref "Slab_Free"
.IX Item "Slab_Free"
.IP "Slab_to_ro" 4
.IX Xref "Slab_to_ro"
.IX Item "Slab_to_ro"
.IP "Slab_to_rw" 4
.IX Xref "Slab_to_rw"
.IX Item "Slab_to_rw"
.IP "_add_range_to_invlist" 4
.IX Xref "_add_range_to_invlist"
.IX Item "_add_range_to_invlist"
.IP "_core_swash_init" 4
.IX Xref "_core_swash_init"
.IX Item "_core_swash_init"
.IP "_get_invlist_len_addr" 4
.IX Xref "_get_invlist_len_addr"
.IX Item "_get_invlist_len_addr"
.IP "_get_swash_invlist" 4
.IX Xref "_get_swash_invlist"
.IX Item "_get_swash_invlist"
.IP "_invlist_array_init" 4
.IX Xref "_invlist_array_init"
.IX Item "_invlist_array_init"
.IP "_invlist_contains_cp" 4
.IX Xref "_invlist_contains_cp"
.IX Item "_invlist_contains_cp"
.IP "_invlist_contents" 4
.IX Xref "_invlist_contents"
.IX Item "_invlist_contents"
.IP "_invlist_intersection" 4
.IX Xref "_invlist_intersection"
.IX Item "_invlist_intersection"
.IP "_invlist_intersection_maybe_complement_2nd" 4
.IX Xref "_invlist_intersection_maybe_complement_2nd"
.IX Item "_invlist_intersection_maybe_complement_2nd"
.IP "_invlist_invert" 4
.IX Xref "_invlist_invert"
.IX Item "_invlist_invert"
.IP "_invlist_invert_prop" 4
.IX Xref "_invlist_invert_prop"
.IX Item "_invlist_invert_prop"
.IP "_invlist_len" 4
.IX Xref "_invlist_len"
.IX Item "_invlist_len"
.IP "_invlist_populate_swatch" 4
.IX Xref "_invlist_populate_swatch"
.IX Item "_invlist_populate_swatch"
.IP "_invlist_search" 4
.IX Xref "_invlist_search"
.IX Item "_invlist_search"
.IP "_invlist_subtract" 4
.IX Xref "_invlist_subtract"
.IX Item "_invlist_subtract"
.IP "_invlist_union" 4
.IX Xref "_invlist_union"
.IX Item "_invlist_union"
.IP "_invlist_union_maybe_complement_2nd" 4
.IX Xref "_invlist_union_maybe_complement_2nd"
.IX Item "_invlist_union_maybe_complement_2nd"
.IP "_new_invlist" 4
.IX Xref "_new_invlist"
.IX Item "_new_invlist"
.IP "_swash_inversion_hash" 4
.IX Xref "_swash_inversion_hash"
.IX Item "_swash_inversion_hash"
.IP "_swash_to_invlist" 4
.IX Xref "_swash_to_invlist"
.IX Item "_swash_to_invlist"
.IP "_to_fold_latin1" 4
.IX Xref "_to_fold_latin1"
.IX Item "_to_fold_latin1"
.IP "_to_upper_title_latin1" 4
.IX Xref "_to_upper_title_latin1"
.IX Item "_to_upper_title_latin1"
.IP "aassign_common_vars" 4
.IX Xref "aassign_common_vars"
.IX Item "aassign_common_vars"
.IP "add_cp_to_invlist" 4
.IX Xref "add_cp_to_invlist"
.IX Item "add_cp_to_invlist"
.IP "addmad" 4
.IX Xref "addmad"
.IX Item "addmad"
.IP "alloc_maybe_populate_EXACT" 4
.IX Xref "alloc_maybe_populate_EXACT"
.IX Item "alloc_maybe_populate_EXACT"
.IP "allocmy" 4
.IX Xref "allocmy"
.IX Item "allocmy"
.IP "amagic_is_enabled" 4
.IX Xref "amagic_is_enabled"
.IX Item "amagic_is_enabled"
.IP "append_madprops" 4
.IX Xref "append_madprops"
.IX Item "append_madprops"
.IP "apply" 4
.IX Xref "apply"
.IX Item "apply"
.IP "av_extend_guts" 4
.IX Xref "av_extend_guts"
.IX Item "av_extend_guts"
.IP "av_reify" 4
.IX Xref "av_reify"
.IX Item "av_reify"
.IP "bind_match" 4
.IX Xref "bind_match"
.IX Item "bind_match"
.IP "block_end" 4
.IX Xref "block_end"
.IX Item "block_end"
.IP "block_start" 4
.IX Xref "block_start"
.IX Item "block_start"
.IP "boot_core_PerlIO" 4
.IX Xref "boot_core_PerlIO"
.IX Item "boot_core_PerlIO"
.IP "boot_core_UNIVERSAL" 4
.IX Xref "boot_core_UNIVERSAL"
.IX Item "boot_core_UNIVERSAL"
.IP "boot_core_mro" 4
.IX Xref "boot_core_mro"
.IX Item "boot_core_mro"
.IP "cando" 4
.IX Xref "cando"
.IX Item "cando"
.IP "check_utf8_print" 4
.IX Xref "check_utf8_print"
.IX Item "check_utf8_print"
.IP "ck_entersub_args_core" 4
.IX Xref "ck_entersub_args_core"
.IX Item "ck_entersub_args_core"
.IP "compute_EXACTish" 4
.IX Xref "compute_EXACTish"
.IX Item "compute_EXACTish"
.IP "convert" 4
.IX Xref "convert"
.IX Item "convert"
.IP "coresub_op" 4
.IX Xref "coresub_op"
.IX Item "coresub_op"
.IP "create_eval_scope" 4
.IX Xref "create_eval_scope"
.IX Item "create_eval_scope"
.IP "croak_no_mem" 4
.IX Xref "croak_no_mem"
.IX Item "croak_no_mem"
.IP "croak_popstack" 4
.IX Xref "croak_popstack"
.IX Item "croak_popstack"
.IP "current_re_engine" 4
.IX Xref "current_re_engine"
.IX Item "current_re_engine"
.IP "cv_ckproto_len_flags" 4
.IX Xref "cv_ckproto_len_flags"
.IX Item "cv_ckproto_len_flags"
.IP "cv_clone_into" 4
.IX Xref "cv_clone_into"
.IX Item "cv_clone_into"
.IP "cvgv_set" 4
.IX Xref "cvgv_set"
.IX Item "cvgv_set"
.IP "cvstash_set" 4
.IX Xref "cvstash_set"
.IX Item "cvstash_set"
.IP "deb_stack_all" 4
.IX Xref "deb_stack_all"
.IX Item "deb_stack_all"
.IP "delete_eval_scope" 4
.IX Xref "delete_eval_scope"
.IX Item "delete_eval_scope"
.IP "die_unwind" 4
.IX Xref "die_unwind"
.IX Item "die_unwind"
.IP "do_aexec" 4
.IX Xref "do_aexec"
.IX Item "do_aexec"
.IP "do_aexec5" 4
.IX Xref "do_aexec5"
.IX Item "do_aexec5"
.IP "do_eof" 4
.IX Xref "do_eof"
.IX Item "do_eof"
.IP "do_exec" 4
.IX Xref "do_exec"
.IX Item "do_exec"
.IP "do_exec3" 4
.IX Xref "do_exec3"
.IX Item "do_exec3"
.IP "do_execfree" 4
.IX Xref "do_execfree"
.IX Item "do_execfree"
.IP "do_ipcctl" 4
.IX Xref "do_ipcctl"
.IX Item "do_ipcctl"
.IP "do_ipcget" 4
.IX Xref "do_ipcget"
.IX Item "do_ipcget"
.IP "do_msgrcv" 4
.IX Xref "do_msgrcv"
.IX Item "do_msgrcv"
.IP "do_msgsnd" 4
.IX Xref "do_msgsnd"
.IX Item "do_msgsnd"
.IP "do_ncmp" 4
.IX Xref "do_ncmp"
.IX Item "do_ncmp"
.IP "do_op_xmldump" 4
.IX Xref "do_op_xmldump"
.IX Item "do_op_xmldump"
.IP "do_pmop_xmldump" 4
.IX Xref "do_pmop_xmldump"
.IX Item "do_pmop_xmldump"
.IP "do_print" 4
.IX Xref "do_print"
.IX Item "do_print"
.IP "do_readline" 4
.IX Xref "do_readline"
.IX Item "do_readline"
.IP "do_seek" 4
.IX Xref "do_seek"
.IX Item "do_seek"
.IP "do_semop" 4
.IX Xref "do_semop"
.IX Item "do_semop"
.IP "do_shmio" 4
.IX Xref "do_shmio"
.IX Item "do_shmio"
.IP "do_sysseek" 4
.IX Xref "do_sysseek"
.IX Item "do_sysseek"
.IP "do_tell" 4
.IX Xref "do_tell"
.IX Item "do_tell"
.IP "do_trans" 4
.IX Xref "do_trans"
.IX Item "do_trans"
.IP "do_vecget" 4
.IX Xref "do_vecget"
.IX Item "do_vecget"
.IP "do_vecset" 4
.IX Xref "do_vecset"
.IX Item "do_vecset"
.IP "do_vop" 4
.IX Xref "do_vop"
.IX Item "do_vop"
.IP "dofile" 4
.IX Xref "dofile"
.IX Item "dofile"
.IP "dump_all_perl" 4
.IX Xref "dump_all_perl"
.IX Item "dump_all_perl"
.IP "dump_packsubs_perl" 4
.IX Xref "dump_packsubs_perl"
.IX Item "dump_packsubs_perl"
.IP "dump_sub_perl" 4
.IX Xref "dump_sub_perl"
.IX Item "dump_sub_perl"
.IP "dump_sv_child" 4
.IX Xref "dump_sv_child"
.IX Item "dump_sv_child"
.IP "emulate_cop_io" 4
.IX Xref "emulate_cop_io"
.IX Item "emulate_cop_io"
.IP "feature_is_enabled" 4
.IX Xref "feature_is_enabled"
.IX Item "feature_is_enabled"
.IP "find_lexical_cv" 4
.IX Xref "find_lexical_cv"
.IX Item "find_lexical_cv"
.IP "find_runcv_where" 4
.IX Xref "find_runcv_where"
.IX Item "find_runcv_where"
.IP "find_rundefsv2" 4
.IX Xref "find_rundefsv2"
.IX Item "find_rundefsv2"
.IP "find_script" 4
.IX Xref "find_script"
.IX Item "find_script"
.IP "free_tied_hv_pool" 4
.IX Xref "free_tied_hv_pool"
.IX Item "free_tied_hv_pool"
.IP "get_and_check_backslash_N_name" 4
.IX Xref "get_and_check_backslash_N_name"
.IX Item "get_and_check_backslash_N_name"
.IP "get_db_sub" 4
.IX Xref "get_db_sub"
.IX Item "get_db_sub"
.IP "get_debug_opts" 4
.IX Xref "get_debug_opts"
.IX Item "get_debug_opts"
.IP "get_hash_seed" 4
.IX Xref "get_hash_seed"
.IX Item "get_hash_seed"
.IP "get_invlist_iter_addr" 4
.IX Xref "get_invlist_iter_addr"
.IX Item "get_invlist_iter_addr"
.IP "get_invlist_previous_index_addr" 4
.IX Xref "get_invlist_previous_index_addr"
.IX Item "get_invlist_previous_index_addr"
.IP "get_invlist_version_id_addr" 4
.IX Xref "get_invlist_version_id_addr"
.IX Item "get_invlist_version_id_addr"
.IP "get_invlist_zero_addr" 4
.IX Xref "get_invlist_zero_addr"
.IX Item "get_invlist_zero_addr"
.IP "get_no_modify" 4
.IX Xref "get_no_modify"
.IX Item "get_no_modify"
.IP "get_opargs" 4
.IX Xref "get_opargs"
.IX Item "get_opargs"
.IP "get_re_arg" 4
.IX Xref "get_re_arg"
.IX Item "get_re_arg"
.IP "getenv_len" 4
.IX Xref "getenv_len"
.IX Item "getenv_len"
.IP "grok_bslash_x" 4
.IX Xref "grok_bslash_x"
.IX Item "grok_bslash_x"
.IP "hfree_next_entry" 4
.IX Xref "hfree_next_entry"
.IX Item "hfree_next_entry"
.IP "hv_backreferences_p" 4
.IX Xref "hv_backreferences_p"
.IX Item "hv_backreferences_p"
.IP "hv_kill_backrefs" 4
.IX Xref "hv_kill_backrefs"
.IX Item "hv_kill_backrefs"
.IP "hv_undef_flags" 4
.IX Xref "hv_undef_flags"
.IX Item "hv_undef_flags"
.IP "init_argv_symbols" 4
.IX Xref "init_argv_symbols"
.IX Item "init_argv_symbols"
.IP "init_constants" 4
.IX Xref "init_constants"
.IX Item "init_constants"
.IP "init_dbargs" 4
.IX Xref "init_dbargs"
.IX Item "init_dbargs"
.IP "init_debugger" 4
.IX Xref "init_debugger"
.IX Item "init_debugger"
.IP "invert" 4
.IX Xref "invert"
.IX Item "invert"
.IP "invlist_array" 4
.IX Xref "invlist_array"
.IX Item "invlist_array"
.IP "invlist_clone" 4
.IX Xref "invlist_clone"
.IX Item "invlist_clone"
.IP "invlist_highest" 4
.IX Xref "invlist_highest"
.IX Item "invlist_highest"
.IP "invlist_is_iterating" 4
.IX Xref "invlist_is_iterating"
.IX Item "invlist_is_iterating"
.IP "invlist_iterfinish" 4
.IX Xref "invlist_iterfinish"
.IX Item "invlist_iterfinish"
.IP "invlist_iterinit" 4
.IX Xref "invlist_iterinit"
.IX Item "invlist_iterinit"
.IP "invlist_max" 4
.IX Xref "invlist_max"
.IX Item "invlist_max"
.IP "invlist_previous_index" 4
.IX Xref "invlist_previous_index"
.IX Item "invlist_previous_index"
.IP "invlist_set_len" 4
.IX Xref "invlist_set_len"
.IX Item "invlist_set_len"
.IP "invlist_set_previous_index" 4
.IX Xref "invlist_set_previous_index"
.IX Item "invlist_set_previous_index"
.IP "invlist_trim" 4
.IX Xref "invlist_trim"
.IX Item "invlist_trim"
.IP "io_close" 4
.IX Xref "io_close"
.IX Item "io_close"
.IP "isALNUM_lazy" 4
.IX Xref "isALNUM_lazy"
.IX Item "isALNUM_lazy"
.IP "isIDFIRST_lazy" 4
.IX Xref "isIDFIRST_lazy"
.IX Item "isIDFIRST_lazy"
.IP "is_utf8_char_slow" 4
.IX Xref "is_utf8_char_slow"
.IX Item "is_utf8_char_slow"
.IP "is_utf8_common" 4
.IX Xref "is_utf8_common"
.IX Item "is_utf8_common"
.IP "jmaybe" 4
.IX Xref "jmaybe"
.IX Item "jmaybe"
.IP "keyword" 4
.IX Xref "keyword"
.IX Item "keyword"
.IP "keyword_plugin_standard" 4
.IX Xref "keyword_plugin_standard"
.IX Item "keyword_plugin_standard"
.IP "list" 4
.IX Xref "list"
.IX Item "list"
.IP "localize" 4
.IX Xref "localize"
.IX Item "localize"
.IP "mad_free" 4
.IX Xref "mad_free"
.IX Item "mad_free"
.IP "madlex" 4
.IX Xref "madlex"
.IX Item "madlex"
.IP "madparse" 4
.IX Xref "madparse"
.IX Item "madparse"
.IP "magic_clear_all_env" 4
.IX Xref "magic_clear_all_env"
.IX Item "magic_clear_all_env"
.IP "magic_cleararylen_p" 4
.IX Xref "magic_cleararylen_p"
.IX Item "magic_cleararylen_p"
.IP "magic_clearenv" 4
.IX Xref "magic_clearenv"
.IX Item "magic_clearenv"
.IP "magic_clearisa" 4
.IX Xref "magic_clearisa"
.IX Item "magic_clearisa"
.IP "magic_clearpack" 4
.IX Xref "magic_clearpack"
.IX Item "magic_clearpack"
.IP "magic_clearsig" 4
.IX Xref "magic_clearsig"
.IX Item "magic_clearsig"
.IP "magic_copycallchecker" 4
.IX Xref "magic_copycallchecker"
.IX Item "magic_copycallchecker"
.IP "magic_existspack" 4
.IX Xref "magic_existspack"
.IX Item "magic_existspack"
.IP "magic_freearylen_p" 4
.IX Xref "magic_freearylen_p"
.IX Item "magic_freearylen_p"
.IP "magic_freeovrld" 4
.IX Xref "magic_freeovrld"
.IX Item "magic_freeovrld"
.IP "magic_get" 4
.IX Xref "magic_get"
.IX Item "magic_get"
.IP "magic_getarylen" 4
.IX Xref "magic_getarylen"
.IX Item "magic_getarylen"
.IP "magic_getdefelem" 4
.IX Xref "magic_getdefelem"
.IX Item "magic_getdefelem"
.IP "magic_getnkeys" 4
.IX Xref "magic_getnkeys"
.IX Item "magic_getnkeys"
.IP "magic_getpack" 4
.IX Xref "magic_getpack"
.IX Item "magic_getpack"
.IP "magic_getpos" 4
.IX Xref "magic_getpos"
.IX Item "magic_getpos"
.IP "magic_getsig" 4
.IX Xref "magic_getsig"
.IX Item "magic_getsig"
.IP "magic_getsubstr" 4
.IX Xref "magic_getsubstr"
.IX Item "magic_getsubstr"
.IP "magic_gettaint" 4
.IX Xref "magic_gettaint"
.IX Item "magic_gettaint"
.IP "magic_getuvar" 4
.IX Xref "magic_getuvar"
.IX Item "magic_getuvar"
.IP "magic_getvec" 4
.IX Xref "magic_getvec"
.IX Item "magic_getvec"
.IP "magic_killbackrefs" 4
.IX Xref "magic_killbackrefs"
.IX Item "magic_killbackrefs"
.IP "magic_nextpack" 4
.IX Xref "magic_nextpack"
.IX Item "magic_nextpack"
.IP "magic_regdata_cnt" 4
.IX Xref "magic_regdata_cnt"
.IX Item "magic_regdata_cnt"
.IP "magic_regdatum_get" 4
.IX Xref "magic_regdatum_get"
.IX Item "magic_regdatum_get"
.IP "magic_regdatum_set" 4
.IX Xref "magic_regdatum_set"
.IX Item "magic_regdatum_set"
.IP "magic_scalarpack" 4
.IX Xref "magic_scalarpack"
.IX Item "magic_scalarpack"
.IP "magic_set" 4
.IX Xref "magic_set"
.IX Item "magic_set"
.IP "magic_set_all_env" 4
.IX Xref "magic_set_all_env"
.IX Item "magic_set_all_env"
.IP "magic_setarylen" 4
.IX Xref "magic_setarylen"
.IX Item "magic_setarylen"
.IP "magic_setcollxfrm" 4
.IX Xref "magic_setcollxfrm"
.IX Item "magic_setcollxfrm"
.IP "magic_setdbline" 4
.IX Xref "magic_setdbline"
.IX Item "magic_setdbline"
.IP "magic_setdefelem" 4
.IX Xref "magic_setdefelem"
.IX Item "magic_setdefelem"
.IP "magic_setenv" 4
.IX Xref "magic_setenv"
.IX Item "magic_setenv"
.IP "magic_setisa" 4
.IX Xref "magic_setisa"
.IX Item "magic_setisa"
.IP "magic_setmglob" 4
.IX Xref "magic_setmglob"
.IX Item "magic_setmglob"
.IP "magic_setnkeys" 4
.IX Xref "magic_setnkeys"
.IX Item "magic_setnkeys"
.IP "magic_setpack" 4
.IX Xref "magic_setpack"
.IX Item "magic_setpack"
.IP "magic_setpos" 4
.IX Xref "magic_setpos"
.IX Item "magic_setpos"
.IP "magic_setregexp" 4
.IX Xref "magic_setregexp"
.IX Item "magic_setregexp"
.IP "magic_setsig" 4
.IX Xref "magic_setsig"
.IX Item "magic_setsig"
.IP "magic_setsubstr" 4
.IX Xref "magic_setsubstr"
.IX Item "magic_setsubstr"
.IP "magic_settaint" 4
.IX Xref "magic_settaint"
.IX Item "magic_settaint"
.IP "magic_setutf8" 4
.IX Xref "magic_setutf8"
.IX Item "magic_setutf8"
.IP "magic_setuvar" 4
.IX Xref "magic_setuvar"
.IX Item "magic_setuvar"
.IP "magic_setvec" 4
.IX Xref "magic_setvec"
.IX Item "magic_setvec"
.IP "magic_sizepack" 4
.IX Xref "magic_sizepack"
.IX Item "magic_sizepack"
.IP "magic_wipepack" 4
.IX Xref "magic_wipepack"
.IX Item "magic_wipepack"
.IP "malloc_good_size" 4
.IX Xref "malloc_good_size"
.IX Item "malloc_good_size"
.IP "malloced_size" 4
.IX Xref "malloced_size"
.IX Item "malloced_size"
.IP "mem_collxfrm" 4
.IX Xref "mem_collxfrm"
.IX Item "mem_collxfrm"
.IP "mode_from_discipline" 4
.IX Xref "mode_from_discipline"
.IX Item "mode_from_discipline"
.IP "more_bodies" 4
.IX Xref "more_bodies"
.IX Item "more_bodies"
.IP "mro_meta_dup" 4
.IX Xref "mro_meta_dup"
.IX Item "mro_meta_dup"
.IP "mro_meta_init" 4
.IX Xref "mro_meta_init"
.IX Item "mro_meta_init"
.IP "my_attrs" 4
.IX Xref "my_attrs"
.IX Item "my_attrs"
.IP "my_betoh16" 4
.IX Xref "my_betoh16"
.IX Item "my_betoh16"
.IP "my_betoh32" 4
.IX Xref "my_betoh32"
.IX Item "my_betoh32"
.IP "my_betoh64" 4
.IX Xref "my_betoh64"
.IX Item "my_betoh64"
.IP "my_betohi" 4
.IX Xref "my_betohi"
.IX Item "my_betohi"
.IP "my_betohl" 4
.IX Xref "my_betohl"
.IX Item "my_betohl"
.IP "my_betohs" 4
.IX Xref "my_betohs"
.IX Item "my_betohs"
.IP "my_clearenv" 4
.IX Xref "my_clearenv"
.IX Item "my_clearenv"
.IP "my_htobe16" 4
.IX Xref "my_htobe16"
.IX Item "my_htobe16"
.IP "my_htobe32" 4
.IX Xref "my_htobe32"
.IX Item "my_htobe32"
.IP "my_htobe64" 4
.IX Xref "my_htobe64"
.IX Item "my_htobe64"
.IP "my_htobei" 4
.IX Xref "my_htobei"
.IX Item "my_htobei"
.IP "my_htobel" 4
.IX Xref "my_htobel"
.IX Item "my_htobel"
.IP "my_htobes" 4
.IX Xref "my_htobes"
.IX Item "my_htobes"
.IP "my_htole16" 4
.IX Xref "my_htole16"
.IX Item "my_htole16"
.IP "my_htole32" 4
.IX Xref "my_htole32"
.IX Item "my_htole32"
.IP "my_htole64" 4
.IX Xref "my_htole64"
.IX Item "my_htole64"
.IP "my_htolei" 4
.IX Xref "my_htolei"
.IX Item "my_htolei"
.IP "my_htolel" 4
.IX Xref "my_htolel"
.IX Item "my_htolel"
.IP "my_htoles" 4
.IX Xref "my_htoles"
.IX Item "my_htoles"
.IP "my_letoh16" 4
.IX Xref "my_letoh16"
.IX Item "my_letoh16"
.IP "my_letoh32" 4
.IX Xref "my_letoh32"
.IX Item "my_letoh32"
.IP "my_letoh64" 4
.IX Xref "my_letoh64"
.IX Item "my_letoh64"
.IP "my_letohi" 4
.IX Xref "my_letohi"
.IX Item "my_letohi"
.IP "my_letohl" 4
.IX Xref "my_letohl"
.IX Item "my_letohl"
.IP "my_letohs" 4
.IX Xref "my_letohs"
.IX Item "my_letohs"
.IP "my_lstat_flags" 4
.IX Xref "my_lstat_flags"
.IX Item "my_lstat_flags"
.IP "my_stat_flags" 4
.IX Xref "my_stat_flags"
.IX Item "my_stat_flags"
.IP "my_swabn" 4
.IX Xref "my_swabn"
.IX Item "my_swabn"
.IP "my_unexec" 4
.IX Xref "my_unexec"
.IX Item "my_unexec"
.IP "newATTRSUB_flags" 4
.IX Xref "newATTRSUB_flags"
.IX Item "newATTRSUB_flags"
.IP "newGP" 4
.IX Xref "newGP"
.IX Item "newGP"
.IP "newMADPROP" 4
.IX Xref "newMADPROP"
.IX Item "newMADPROP"
.IP "newMADsv" 4
.IX Xref "newMADsv"
.IX Item "newMADsv"
.IP "newSTUB" 4
.IX Xref "newSTUB"
.IX Item "newSTUB"
.IP "newTOKEN" 4
.IX Xref "newTOKEN"
.IX Item "newTOKEN"
.IP "newXS_len_flags" 4
.IX Xref "newXS_len_flags"
.IX Item "newXS_len_flags"
.IP "new_warnings_bitfield" 4
.IX Xref "new_warnings_bitfield"
.IX Item "new_warnings_bitfield"
.IP "nextargv" 4
.IX Xref "nextargv"
.IX Item "nextargv"
.IP "oopsAV" 4
.IX Xref "oopsAV"
.IX Item "oopsAV"
.IP "oopsHV" 4
.IX Xref "oopsHV"
.IX Item "oopsHV"
.IP "op_clear" 4
.IX Xref "op_clear"
.IX Item "op_clear"
.IP "op_const_sv" 4
.IX Xref "op_const_sv"
.IX Item "op_const_sv"
.IP "op_getmad" 4
.IX Xref "op_getmad"
.IX Item "op_getmad"
.IP "op_getmad_weak" 4
.IX Xref "op_getmad_weak"
.IX Item "op_getmad_weak"
.IP "op_integerize" 4
.IX Xref "op_integerize"
.IX Item "op_integerize"
.IP "op_lvalue_flags" 4
.IX Xref "op_lvalue_flags"
.IX Item "op_lvalue_flags"
.IP "op_refcnt_dec" 4
.IX Xref "op_refcnt_dec"
.IX Item "op_refcnt_dec"
.IP "op_refcnt_inc" 4
.IX Xref "op_refcnt_inc"
.IX Item "op_refcnt_inc"
.IP "op_std_init" 4
.IX Xref "op_std_init"
.IX Item "op_std_init"
.IP "op_unscope" 4
.IX Xref "op_unscope"
.IX Item "op_unscope"
.IP "op_xmldump" 4
.IX Xref "op_xmldump"
.IX Item "op_xmldump"
.IP "opslab_force_free" 4
.IX Xref "opslab_force_free"
.IX Item "opslab_force_free"
.IP "opslab_free" 4
.IX Xref "opslab_free"
.IX Item "opslab_free"
.IP "opslab_free_nopad" 4
.IX Xref "opslab_free_nopad"
.IX Item "opslab_free_nopad"
.IP "package" 4
.IX Xref "package"
.IX Item "package"
.IP "package_version" 4
.IX Xref "package_version"
.IX Item "package_version"
.IP "padlist_store" 4
.IX Xref "padlist_store"
.IX Item "padlist_store"
.IP "parse_unicode_opts" 4
.IX Xref "parse_unicode_opts"
.IX Item "parse_unicode_opts"
.IP "parser_free" 4
.IX Xref "parser_free"
.IX Item "parser_free"
.IP "parser_free_nexttoke_ops" 4
.IX Xref "parser_free_nexttoke_ops"
.IX Item "parser_free_nexttoke_ops"
.IP "peep" 4
.IX Xref "peep"
.IX Item "peep"
.IP "pmop_xmldump" 4
.IX Xref "pmop_xmldump"
.IX Item "pmop_xmldump"
.IP "pmruntime" 4
.IX Xref "pmruntime"
.IX Item "pmruntime"
.IP "populate_isa" 4
.IX Xref "populate_isa"
.IX Item "populate_isa"
.IP "prepend_madprops" 4
.IX Xref "prepend_madprops"
.IX Item "prepend_madprops"
.IP "qerror" 4
.IX Xref "qerror"
.IX Item "qerror"
.IP "re_op_compile" 4
.IX Xref "re_op_compile"
.IX Item "re_op_compile"
.IP "reg_named_buff" 4
.IX Xref "reg_named_buff"
.IX Item "reg_named_buff"
.IP "reg_named_buff_iter" 4
.IX Xref "reg_named_buff_iter"
.IX Item "reg_named_buff_iter"
.IP "reg_numbered_buff_fetch" 4
.IX Xref "reg_numbered_buff_fetch"
.IX Item "reg_numbered_buff_fetch"
.IP "reg_numbered_buff_length" 4
.IX Xref "reg_numbered_buff_length"
.IX Item "reg_numbered_buff_length"
.IP "reg_numbered_buff_store" 4
.IX Xref "reg_numbered_buff_store"
.IX Item "reg_numbered_buff_store"
.IP "reg_qr_package" 4
.IX Xref "reg_qr_package"
.IX Item "reg_qr_package"
.IP "reg_temp_copy" 4
.IX Xref "reg_temp_copy"
.IX Item "reg_temp_copy"
.IP "regcurly" 4
.IX Xref "regcurly"
.IX Item "regcurly"
.IP "regpposixcc" 4
.IX Xref "regpposixcc"
.IX Item "regpposixcc"
.IP "regprop" 4
.IX Xref "regprop"
.IX Item "regprop"
.IP "report_evil_fh" 4
.IX Xref "report_evil_fh"
.IX Item "report_evil_fh"
.IP "report_redefined_cv" 4
.IX Xref "report_redefined_cv"
.IX Item "report_redefined_cv"
.IP "report_wrongway_fh" 4
.IX Xref "report_wrongway_fh"
.IX Item "report_wrongway_fh"
.IP "rpeep" 4
.IX Xref "rpeep"
.IX Item "rpeep"
.IP "rsignal_restore" 4
.IX Xref "rsignal_restore"
.IX Item "rsignal_restore"
.IP "rsignal_save" 4
.IX Xref "rsignal_save"
.IX Item "rsignal_save"
.IP "rxres_save" 4
.IX Xref "rxres_save"
.IX Item "rxres_save"
.IP "same_dirent" 4
.IX Xref "same_dirent"
.IX Item "same_dirent"
.IP "sawparens" 4
.IX Xref "sawparens"
.IX Item "sawparens"
.IP "scalar" 4
.IX Xref "scalar"
.IX Item "scalar"
.IP "scalarvoid" 4
.IX Xref "scalarvoid"
.IX Item "scalarvoid"
.IP "sighandler" 4
.IX Xref "sighandler"
.IX Item "sighandler"
.IP "softref2xv" 4
.IX Xref "softref2xv"
.IX Item "softref2xv"
.IP "sub_crush_depth" 4
.IX Xref "sub_crush_depth"
.IX Item "sub_crush_depth"
.IP "sv_add_backref" 4
.IX Xref "sv_add_backref"
.IX Item "sv_add_backref"
.IP "sv_catxmlpv" 4
.IX Xref "sv_catxmlpv"
.IX Item "sv_catxmlpv"
.IP "sv_catxmlpvn" 4
.IX Xref "sv_catxmlpvn"
.IX Item "sv_catxmlpvn"
.IP "sv_catxmlsv" 4
.IX Xref "sv_catxmlsv"
.IX Item "sv_catxmlsv"
.IP "sv_del_backref" 4
.IX Xref "sv_del_backref"
.IX Item "sv_del_backref"
.IP "sv_free2" 4
.IX Xref "sv_free2"
.IX Item "sv_free2"
.IP "sv_kill_backrefs" 4
.IX Xref "sv_kill_backrefs"
.IX Item "sv_kill_backrefs"
.IP "sv_len_utf8_nomg" 4
.IX Xref "sv_len_utf8_nomg"
.IX Item "sv_len_utf8_nomg"
.IP "sv_mortalcopy_flags" 4
.IX Xref "sv_mortalcopy_flags"
.IX Item "sv_mortalcopy_flags"
.IP "sv_resetpvn" 4
.IX Xref "sv_resetpvn"
.IX Item "sv_resetpvn"
.IP "sv_sethek" 4
.IX Xref "sv_sethek"
.IX Item "sv_sethek"
.IP "sv_setsv_cow" 4
.IX Xref "sv_setsv_cow"
.IX Item "sv_setsv_cow"
.IP "sv_unglob" 4
.IX Xref "sv_unglob"
.IX Item "sv_unglob"
.IP "sv_xmlpeek" 4
.IX Xref "sv_xmlpeek"
.IX Item "sv_xmlpeek"
.IP "tied_method" 4
.IX Xref "tied_method"
.IX Item "tied_method"
.IP "token_free" 4
.IX Xref "token_free"
.IX Item "token_free"
.IP "token_getmad" 4
.IX Xref "token_getmad"
.IX Item "token_getmad"
.IP "translate_substr_offsets" 4
.IX Xref "translate_substr_offsets"
.IX Item "translate_substr_offsets"
.IP "try_amagic_bin" 4
.IX Xref "try_amagic_bin"
.IX Item "try_amagic_bin"
.IP "try_amagic_un" 4
.IX Xref "try_amagic_un"
.IX Item "try_amagic_un"
.IP "unshare_hek" 4
.IX Xref "unshare_hek"
.IX Item "unshare_hek"
.IP "utilize" 4
.IX Xref "utilize"
.IX Item "utilize"
.IP "varname" 4
.IX Xref "varname"
.IX Item "varname"
.IP "vivify_defelem" 4
.IX Xref "vivify_defelem"
.IX Item "vivify_defelem"
.IP "vivify_ref" 4
.IX Xref "vivify_ref"
.IX Item "vivify_ref"
.IP "wait4pid" 4
.IX Xref "wait4pid"
.IX Item "wait4pid"
.IP "was_lvalue_sub" 4
.IX Xref "was_lvalue_sub"
.IX Item "was_lvalue_sub"
.IP "watch" 4
.IX Xref "watch"
.IX Item "watch"
.IP "win32_croak_not_implemented" 4
.IX Xref "win32_croak_not_implemented"
.IX Item "win32_croak_not_implemented"
.IP "write_to_stderr" 4
.IX Xref "write_to_stderr"
.IX Item "write_to_stderr"
.IP "xmldump_all" 4
.IX Xref "xmldump_all"
.IX Item "xmldump_all"
.IP "xmldump_all_perl" 4
.IX Xref "xmldump_all_perl"
.IX Item "xmldump_all_perl"
.IP "xmldump_eval" 4
.IX Xref "xmldump_eval"
.IX Item "xmldump_eval"
.IP "xmldump_form" 4
.IX Xref "xmldump_form"
.IX Item "xmldump_form"
.IP "xmldump_indent" 4
.IX Xref "xmldump_indent"
.IX Item "xmldump_indent"
.IP "xmldump_packsubs" 4
.IX Xref "xmldump_packsubs"
.IX Item "xmldump_packsubs"
.IP "xmldump_packsubs_perl" 4
.IX Xref "xmldump_packsubs_perl"
.IX Item "xmldump_packsubs_perl"
.IP "xmldump_sub" 4
.IX Xref "xmldump_sub"
.IX Item "xmldump_sub"
.IP "xmldump_sub_perl" 4
.IX Xref "xmldump_sub_perl"
.IX Item "xmldump_sub_perl"
.IP "xmldump_vindent" 4
.IX Xref "xmldump_vindent"
.IX Item "xmldump_vindent"
.IP "xs_apiversion_bootcheck" 4
.IX Xref "xs_apiversion_bootcheck"
.IX Item "xs_apiversion_bootcheck"
.IP "xs_version_bootcheck" 4
.IX Xref "xs_version_bootcheck"
.IX Item "xs_version_bootcheck"
.IP "yyerror" 4
.IX Xref "yyerror"
.IX Item "yyerror"
.IP "yyerror_pv" 4
.IX Xref "yyerror_pv"
.IX Item "yyerror_pv"
.IP "yyerror_pvn" 4
.IX Xref "yyerror_pvn"
.IX Item "yyerror_pvn"
.IP "yylex" 4
.IX Xref "yylex"
.IX Item "yylex"
.IP "yyparse" 4
.IX Xref "yyparse"
.IX Item "yyparse"
.IP "yyunlex" 4
.IX Xref "yyunlex"
.IX Item "yyunlex"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document their functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, perlapi
                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlinterp.1                                 0100644 0001750 0001750 00000115273 12566207441 023134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERP 1"
.TH PERLINTERP 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlinterp \- An overview of the Perl interpreter
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides an overview of how the Perl interpreter works at
the level of C code, along with pointers to the relevant C source code
files.
.SH "ELEMENTS OF THE INTERPRETER"
.IX Header "ELEMENTS OF THE INTERPRETER"
The work of the interpreter has two main stages: compiling the code
into the internal representation, or bytecode, and then executing it.
\&\*(L"Compiled code\*(R" in perlguts explains exactly how the compilation stage
happens.
.PP
Here is a short breakdown of perl's operation:
.SS "Startup"
.IX Subsection "Startup"
The action begins in \fIperlmain.c\fR. (or \fIminiperlmain.c\fR for miniperl)
This is very high-level code, enough to fit on a single screen, and it
resembles the code found in perlembed; most of the real action takes
place in \fIperl.c\fR
.PP
\&\fIperlmain.c\fR is generated by \f(CW\*(C`ExtUtils::Miniperl\*(C'\fR from
\&\fIminiperlmain.c\fR at make time, so you should make perl to follow this
along.
.PP
First, \fIperlmain.c\fR allocates some memory and constructs a Perl
interpreter, along these lines:
.PP
.Vb 9
\&    1 PERL_SYS_INIT3(&argc,&argv,&env);
\&    2
\&    3 if (!PL_do_undump) {
\&    4     my_perl = perl_alloc();
\&    5     if (!my_perl)
\&    6         exit(1);
\&    7     perl_construct(my_perl);
\&    8     PL_perl_destruct_level = 0;
\&    9 }
.Ve
.PP
Line 1 is a macro, and its definition is dependent on your operating
system. Line 3 references \f(CW\*(C`PL_do_undump\*(C'\fR, a global variable \- all
global variables in Perl start with \f(CW\*(C`PL_\*(C'\fR. This tells you whether the
current running program was created with the \f(CW\*(C`\-u\*(C'\fR flag to perl and
then \fIundump\fR, which means it's going to be false in any sane context.
.PP
Line 4 calls a function in \fIperl.c\fR to allocate memory for a Perl
interpreter. It's quite a simple function, and the guts of it looks
like this:
.PP
.Vb 1
\& my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
.Ve
.PP
Here you see an example of Perl's system abstraction, which we'll see
later: \f(CW\*(C`PerlMem_malloc\*(C'\fR is either your system's \f(CW\*(C`malloc\*(C'\fR, or Perl's
own \f(CW\*(C`malloc\*(C'\fR as defined in \fImalloc.c\fR if you selected that option at
configure time.
.PP
Next, in line 7, we construct the interpreter using perl_construct,
also in \fIperl.c\fR; this sets up all the special variables that Perl
needs, the stacks, and so on.
.PP
Now we pass Perl the command line options, and tell it to go:
.PP
.Vb 3
\& exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
\& if (!exitstatus)
\&     perl_run(my_perl);
\&
\& exitstatus = perl_destruct(my_perl);
\&
\& perl_free(my_perl);
.Ve
.PP
\&\f(CW\*(C`perl_parse\*(C'\fR is actually a wrapper around \f(CW\*(C`S_parse_body\*(C'\fR, as defined
in \fIperl.c\fR, which processes the command line options, sets up any
statically linked \s-1XS\s0 modules, opens the program and calls \f(CW\*(C`yyparse\*(C'\fR to
parse it.
.SS "Parsing"
.IX Subsection "Parsing"
The aim of this stage is to take the Perl source, and turn it into an
op tree. We'll see what one of those looks like later. Strictly
speaking, there's three things going on here.
.PP
\&\f(CW\*(C`yyparse\*(C'\fR, the parser, lives in \fIperly.c\fR, although you're better off
reading the original \s-1YACC\s0 input in \fIperly.y\fR. (Yes, Virginia, there
\&\fBis\fR a \s-1YACC\s0 grammar for Perl!) The job of the parser is to take your
code and \*(L"understand\*(R" it, splitting it into sentences, deciding which
operands go with which operators and so on.
.PP
The parser is nobly assisted by the lexer, which chunks up your input
into tokens, and decides what type of thing each token is: a variable
name, an operator, a bareword, a subroutine, a core function, and so
on. The main point of entry to the lexer is \f(CW\*(C`yylex\*(C'\fR, and that and its
associated routines can be found in \fItoke.c\fR. Perl isn't much like
other computer languages; it's highly context sensitive at times, it
can be tricky to work out what sort of token something is, or where a
token ends. As such, there's a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if you're not used to
it.
.PP
As the parser understands a Perl program, it builds up a tree of
operations for the interpreter to perform during execution. The
routines which construct and link together the various operations are
to be found in \fIop.c\fR, and will be examined later.
.SS "Optimization"
.IX Subsection "Optimization"
Now the parsing stage is complete, and the finished tree represents the
operations that the Perl interpreter needs to perform to execute our
program. Next, Perl does a dry run over the tree looking for
optimisations: constant expressions such as \f(CW\*(C`3 + 4\*(C'\fR will be computed
now, and the optimizer will also see if any multiple operations can be
replaced with a single one. For instance, to fetch the variable
\&\f(CW$foo\fR, instead of grabbing the glob \f(CW*foo\fR and looking at the scalar
component, the optimizer fiddles the op tree to use a function which
directly looks up the scalar in question. The main optimizer is \f(CW\*(C`peep\*(C'\fR
in \fIop.c\fR, and many ops have their own optimizing functions.
.SS "Running"
.IX Subsection "Running"
Now we're finally ready to go: we have compiled Perl byte code, and all
that's left to do is run it. The actual execution is done by the
\&\f(CW\*(C`runops_standard\*(C'\fR function in \fIrun.c\fR; more specifically, it's done
by these three innocent looking lines:
.PP
.Vb 3
\&    while ((PL_op = PL_op\->op_ppaddr(aTHX))) {
\&        PERL_ASYNC_CHECK();
\&    }
.Ve
.PP
You may be more comfortable with the Perl version of that:
.PP
.Vb 1
\&    PERL_ASYNC_CHECK() while $Perl::op = &{$Perl::op\->{function}};
.Ve
.PP
Well, maybe not. Anyway, each op contains a function pointer, which
stipulates the function which will actually carry out the operation.
This function will return the next op in the sequence \- this allows for
things like \f(CW\*(C`if\*(C'\fR which choose the next op dynamically at run time. The
\&\f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR makes sure that things like signals interrupt
execution if required.
.PP
The actual functions called are known as \s-1PP\s0 code, and they're spread
between four files: \fIpp_hot.c\fR contains the \*(L"hot\*(R" code, which is most
often used and highly optimized, \fIpp_sys.c\fR contains all the
system-specific functions, \fIpp_ctl.c\fR contains the functions which
implement control structures (\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR and the like) and \fIpp.c\fR
contains everything else. These are, if you like, the C code for Perl's
built-in functions and operators.
.PP
Note that each \f(CW\*(C`pp_\*(C'\fR function is expected to return a pointer to the
next op. Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume extra space on the C stack. For
example, \f(CW\*(C`pp_entersub\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR just push a \f(CW\*(C`CxSUB\*(C'\fR or
\&\f(CW\*(C`CxEVAL\*(C'\fR block struct onto the context stack which contain the address
of the op following the sub call or eval. They then return the first op
of that sub or eval block, and so execution continues of that sub or
block. Later, a \f(CW\*(C`pp_leavesub\*(C'\fR or \f(CW\*(C`pp_leavetry\*(C'\fR op pops the \f(CW\*(C`CxSUB\*(C'\fR
or \f(CW\*(C`CxEVAL\*(C'\fR, retrieves the return op from it, and returns it.
.SS "Exception handing"
.IX Subsection "Exception handing"
Perl's exception handing (i.e. \f(CW\*(C`die\*(C'\fR etc.) is built on top of the
low-level \f(CW\*(C`setjmp()\*(C'\fR/\f(CW\*(C`longjmp()\*(C'\fR C\-library functions. These basically
provide a way to capture the current \s-1PC\s0 and \s-1SP\s0 registers and later
restore them; i.e. a \f(CW\*(C`longjmp()\*(C'\fR continues at the point in code where
a previous \f(CW\*(C`setjmp()\*(C'\fR was done, with anything further up on the C
stack being lost. This is why code should always save values using
\&\f(CW\*(C`SAVE_FOO\*(C'\fR rather than in auto variables.
.PP
The perl core wraps \f(CW\*(C`setjmp()\*(C'\fR etc in the macros \f(CW\*(C`JMPENV_PUSH\*(C'\fR and
\&\f(CW\*(C`JMPENV_JUMP\*(C'\fR. The basic rule of perl exceptions is that \f(CW\*(C`exit\*(C'\fR, and
\&\f(CW\*(C`die\*(C'\fR (in the absence of \f(CW\*(C`eval\*(C'\fR) perform a \f(CWJMPENV_JUMP(2)\fR, while
\&\f(CW\*(C`die\*(C'\fR within \f(CW\*(C`eval\*(C'\fR does a \f(CWJMPENV_JUMP(3)\fR.
.PP
At entry points to perl, such as \f(CW\*(C`perl_parse()\*(C'\fR, \f(CW\*(C`perl_run()\*(C'\fR and
\&\f(CW\*(C`call_sv(cv, G_EVAL)\*(C'\fR each does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR, then enter a runops
loop or whatever, and handle possible exception returns. For a 2
return, final cleanup is performed, such as popping stacks and calling
\&\f(CW\*(C`CHECK\*(C'\fR or \f(CW\*(C`END\*(C'\fR blocks. Amongst other things, this is how scope
cleanup still occurs during an \f(CW\*(C`exit\*(C'\fR.
.PP
If a \f(CW\*(C`die\*(C'\fR can find a \f(CW\*(C`CxEVAL\*(C'\fR block on the context stack, then the
stack is popped to that level and the return op in that block is
assigned to \f(CW\*(C`PL_restartop\*(C'\fR; then a \f(CWJMPENV_JUMP(3)\fR is performed.
This normally passes control back to the guard. In the case of
\&\f(CW\*(C`perl_run\*(C'\fR and \f(CW\*(C`call_sv\*(C'\fR, a non-null \f(CW\*(C`PL_restartop\*(C'\fR triggers
re-entry to the runops loop. The is the normal way that \f(CW\*(C`die\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR is handled within an \f(CW\*(C`eval\*(C'\fR.
.PP
Sometimes ops are executed within an inner runops loop, such as tie,
sort or overload code. In this case, something like
.PP
.Vb 1
\&    sub FETCH { eval { die } }
.Ve
.PP
would cause a longjmp right back to the guard in \f(CW\*(C`perl_run\*(C'\fR, popping
both runops loops, which is clearly incorrect. One way to avoid this is
for the tie code to do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR before executing \f(CW\*(C`FETCH\*(C'\fR in
the inner runops loop, but for efficiency reasons, perl in fact just
sets a flag, using \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR. The \f(CW\*(C`pp_require\*(C'\fR,
\&\f(CW\*(C`pp_entereval\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR ops check this flag, and if true,
they call \f(CW\*(C`docatch\*(C'\fR, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a new
runops level to execute the code, rather than doing it on the current
loop.
.PP
As a further optimisation, on exit from the eval block in the \f(CW\*(C`FETCH\*(C'\fR,
execution of the code following the block is still carried on in the
inner loop. When an exception is raised, \f(CW\*(C`docatch\*(C'\fR compares the
\&\f(CW\*(C`JMPENV\*(C'\fR level of the \f(CW\*(C`CxEVAL\*(C'\fR with \f(CW\*(C`PL_top_env\*(C'\fR and if they differ,
just re-throws the exception. In this way any inner loops get popped.
.PP
Here's an example.
.PP
.Vb 5
\&    1: eval { tie @a, \*(AqA\*(Aq };
\&    2: sub A::TIEARRAY {
\&    3:     eval { die };
\&    4:     die;
\&    5: }
.Ve
.PP
To run this code, \f(CW\*(C`perl_run\*(C'\fR is called, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR
then enters a runops loop. This loop executes the eval and tie ops on
line 1, with the eval pushing a \f(CW\*(C`CxEVAL\*(C'\fR onto the context stack.
.PP
The \f(CW\*(C`pp_tie\*(C'\fR does a \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR, then starts a second runops
loop to execute the body of \f(CW\*(C`TIEARRAY\*(C'\fR. When it executes the entertry
op on line 3, \f(CW\*(C`CATCH_GET\*(C'\fR is true, so \f(CW\*(C`pp_entertry\*(C'\fR calls \f(CW\*(C`docatch\*(C'\fR
which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a third runops loop, which then
executes the die op. At this point the C call stack looks like this:
.PP
.Vb 10
\&    Perl_pp_die
\&    Perl_runops      # third loop
\&    S_docatch_body
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
and the context and data stacks, as shown by \f(CW\*(C`\-Dstv\*(C'\fR, look like:
.PP
.Vb 9
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
\&      CX 1: EVAL   => *
\&    retop=nextstate
.Ve
.PP
The die pops the first \f(CW\*(C`CxEVAL\*(C'\fR off the context stack, sets
\&\f(CW\*(C`PL_restartop\*(C'\fR from it, does a \f(CWJMPENV_JUMP(3)\fR, and control returns
to the top \f(CW\*(C`docatch\*(C'\fR. This then starts another third-level runops
level, which executes the nextstate, pushmark and die ops on line 4. At
the point that the second \f(CW\*(C`pp_die\*(C'\fR is called, the C call stack looks
exactly like that above, even though we are no longer within an inner
eval; this is because of the optimization mentioned earlier. However,
the context stack now looks like this, ie with the top CxEVAL popped:
.PP
.Vb 7
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
.Ve
.PP
The die on line 4 pops the context stack back down to the CxEVAL,
leaving it as:
.PP
.Vb 2
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
.Ve
.PP
As usual, \f(CW\*(C`PL_restartop\*(C'\fR is extracted from the \f(CW\*(C`CxEVAL\*(C'\fR, and a
\&\f(CWJMPENV_JUMP(3)\fR done, which pops the C stack back to the docatch:
.PP
.Vb 10
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
In  this case, because the \f(CW\*(C`JMPENV\*(C'\fR level recorded in the \f(CW\*(C`CxEVAL\*(C'\fR
differs from the current one, \f(CW\*(C`docatch\*(C'\fR just does a \f(CWJMPENV_JUMP(3)\fR
and the C stack unwinds to:
.PP
.Vb 2
\&    perl_run
\&    main
.Ve
.PP
Because \f(CW\*(C`PL_restartop\*(C'\fR is non-null, \f(CW\*(C`run_body\*(C'\fR starts a new runops
loop and execution continues.
.SS "\s-1INTERNAL VARIABLE TYPES\s0"
.IX Subsection "INTERNAL VARIABLE TYPES"
You should by now have had a look at perlguts, which tells you about
Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
that now.
.PP
These variables are used not only to represent Perl-space variables,
but also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance, is an
ordinary Perl hash. Your code is represented by an \s-1SV\s0 as it's read into
the parser; any program files you call are opened via ordinary Perl
filehandles, and so on.
.PP
The core Devel::Peek module lets us examine SVs from a
Perl program. Let's see, for instance, how Perl treats the constant
\&\f(CW"hello"\fR.
.PP
.Vb 7
\&      % perl \-MDevel::Peek \-e \*(AqDump("hello")\*(Aq
\&    1 SV = PV(0xa041450) at 0xa04ecbc
\&    2   REFCNT = 1
\&    3   FLAGS = (POK,READONLY,pPOK)
\&    4   PV = 0xa0484e0 "hello"\e0
\&    5   CUR = 5
\&    6   LEN = 6
.Ve
.PP
Reading \f(CW\*(C`Devel::Peek\*(C'\fR output takes a bit of practise, so let's go
through it line by line.
.PP
Line 1 tells us we're looking at an \s-1SV\s0 which lives at \f(CW0xa04ecbc\fR in
memory. SVs themselves are very simple structures, but they contain a
pointer to a more complex structure. In this case, it's a \s-1PV,\s0 a
structure which holds a string value, at location \f(CW0xa041450\fR. Line 2
is the reference count; there are no other references to this data, so
it's 1.
.PP
Line 3 are the flags for this \s-1SV \-\s0 it's \s-1OK\s0 to use it as a \s-1PV,\s0 it's a
read-only \s-1SV \s0(because it's a constant) and the data is a \s-1PV\s0 internally.
Next we've got the contents of the string, starting at location
\&\f(CW0xa0484e0\fR.
.PP
Line 5 gives us the current length of the string \- note that this does
\&\fBnot\fR include the null terminator. Line 6 is not the length of the
string, but the length of the currently allocated buffer; as the string
grows, Perl automatically extends the available storage via a routine
called \f(CW\*(C`SvGROW\*(C'\fR.
.PP
You can get at any of these quantities from C very easily; just add
\&\f(CW\*(C`Sv\*(C'\fR to the name of the field shown in the snippet, and you've got a
macro which will return the value: \f(CW\*(C`SvCUR(sv)\*(C'\fR returns the current
length of the string, \f(CW\*(C`SvREFCOUNT(sv)\*(C'\fR returns the reference count,
\&\f(CW\*(C`SvPV(sv, len)\*(C'\fR returns the string itself with its length, and so on.
More macros to manipulate these properties can be found in perlguts.
.PP
Let's take an example of manipulating a \s-1PV,\s0 from \f(CW\*(C`sv_catpvn\*(C'\fR, in
\&\fIsv.c\fR
.PP
.Vb 5
\&     1  void
\&     2  Perl_sv_catpvn(pTHX_ SV *sv, const char *ptr, STRLEN len)
\&     3  {
\&     4      STRLEN tlen;
\&     5      char *junk;
\&
\&     6      junk = SvPV_force(sv, tlen);
\&     7      SvGROW(sv, tlen + len + 1);
\&     8      if (ptr == junk)
\&     9          ptr = SvPVX(sv);
\&    10      Move(ptr,SvPVX(sv)+tlen,len,char);
\&    11      SvCUR(sv) += len;
\&    12      *SvEND(sv) = \*(Aq\e0\*(Aq;
\&    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
\&    14      SvTAINT(sv);
\&    15  }
.Ve
.PP
This is a function which adds a string, \f(CW\*(C`ptr\*(C'\fR, of length \f(CW\*(C`len\*(C'\fR onto
the end of the \s-1PV\s0 stored in \f(CW\*(C`sv\*(C'\fR. The first thing we do in line 6 is
make sure that the \s-1SV \s0\fBhas\fR a valid \s-1PV,\s0 by calling the \f(CW\*(C`SvPV_force\*(C'\fR
macro to force a \s-1PV.\s0 As a side effect, \f(CW\*(C`tlen\*(C'\fR gets set to the current
value of the \s-1PV,\s0 and the \s-1PV\s0 itself is returned to \f(CW\*(C`junk\*(C'\fR.
.PP
In line 7, we make sure that the \s-1SV\s0 will have enough room to
accommodate the old string, the new string and the null terminator. If
\&\f(CW\*(C`LEN\*(C'\fR isn't big enough, \f(CW\*(C`SvGROW\*(C'\fR will reallocate space for us.
.PP
Now, if \f(CW\*(C`junk\*(C'\fR is the same as the string we're trying to add, we can
grab the string directly from the \s-1SV\s0; \f(CW\*(C`SvPVX\*(C'\fR is the address of the \s-1PV\s0
in the \s-1SV.\s0
.PP
Line 10 does the actual catenation: the \f(CW\*(C`Move\*(C'\fR macro moves a chunk of
memory around: we move the string \f(CW\*(C`ptr\*(C'\fR to the end of the \s-1PV \-\s0 that's
the start of the \s-1PV\s0 plus its current length. We're moving \f(CW\*(C`len\*(C'\fR bytes
of type \f(CW\*(C`char\*(C'\fR. After doing so, we need to tell Perl we've extended
the string, by altering \f(CW\*(C`CUR\*(C'\fR to reflect the new length. \f(CW\*(C`SvEND\*(C'\fR is a
macro which gives us the end of the string, so that needs to be a
\&\f(CW"\e0"\fR.
.PP
Line 13 manipulates the flags; since we've changed the \s-1PV,\s0 any \s-1IV\s0 or \s-1NV\s0
values will no longer be valid: if we have \f(CW\*(C`$a=10; $a.="6";\*(C'\fR we don't
want to use the old \s-1IV\s0 of 10. \f(CW\*(C`SvPOK_only_utf8\*(C'\fR is a special
UTF\-8\-aware version of \f(CW\*(C`SvPOK_only\*(C'\fR, a macro which turns off the \s-1IOK\s0
and \s-1NOK\s0 flags and turns on \s-1POK.\s0 The final \f(CW\*(C`SvTAINT\*(C'\fR is a macro which
launders tainted data if taint mode is turned on.
.PP
AVs and HVs are more complicated, but SVs are by far the most common
variable type being thrown around. Having seen something of how we
manipulate these, let's go on and look at how the op tree is
constructed.
.SH "OP TREES"
.IX Header "OP TREES"
First, what is the op tree, anyway? The op tree is the parsed
representation of your program, as we saw in our section on parsing,
and it's the sequence of operations that Perl goes through to execute
your program, as we saw in \*(L"Running\*(R".
.PP
An op is a fundamental operation that Perl can perform: all the
built-in functions and operators are ops, and there are a series of ops
which deal with concepts the interpreter needs internally \- entering
and leaving a block, ending a statement, fetching a variable, and so
on.
.PP
The op tree is connected in two ways: you can imagine that there are
two \*(L"routes\*(R" through it, two orders in which you can traverse the tree.
First, parse order reflects how the parser understood the code, and
secondly, execution order tells perl what order to perform the
operations in.
.PP
The easiest way to examine the op tree is to stop Perl after it has
finished parsing, and get it to dump out the tree. This is exactly what
the compiler backends B::Terse, B::Concise
and B::Debug do.
.PP
Let's have a look at how Perl sees \f(CW\*(C`$a = $b + $c\*(C'\fR:
.PP
.Vb 12
\&     % perl \-MO=Terse \-e \*(Aq$a=$b+$c\*(Aq
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
\&     4      BINOP (0x8179828) sassign
\&     5          BINOP (0x8179800) add [1]
\&     6              UNOP (0x81796e0) null [15]
\&     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
\&     8              UNOP (0x81797e0) null [15]
\&     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
\&    10          UNOP (0x816b4f0) null [15]
\&    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a
.Ve
.PP
Let's start in the middle, at line 4. This is a \s-1BINOP,\s0 a binary
operator, which is at location \f(CW0x8179828\fR. The specific operator in
question is \f(CW\*(C`sassign\*(C'\fR \- scalar assignment \- and you can find the code
which implements it in the function \f(CW\*(C`pp_sassign\*(C'\fR in \fIpp_hot.c\fR. As a
binary operator, it has two children: the add operator, providing the
result of \f(CW\*(C`$b+$c\*(C'\fR, is uppermost on line 5, and the left hand side is
on line 10.
.PP
Line 10 is the null op: this does exactly nothing. What is that doing
there? If you see the null op, it's a sign that something has been
optimized away after parsing. As we mentioned in \*(L"Optimization\*(R", the
optimization stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens, instead of
rewriting the op tree and cleaning up the dangling pointers, it's
easier just to replace the redundant operation with the null op.
Originally, the tree would have looked like this:
.PP
.Vb 2
\&    10          SVOP (0x816b4f0) rv2sv [15]
\&    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a
.Ve
.PP
That is, fetch the \f(CW\*(C`a\*(C'\fR entry from the main symbol table, and then look
at the scalar component of it: \f(CW\*(C`gvsv\*(C'\fR (\f(CW\*(C`pp_gvsv\*(C'\fR into \fIpp_hot.c\fR)
happens to do both these things.
.PP
The right hand side, starting at line 5 is similar to what we've just
seen: we have the \f(CW\*(C`add\*(C'\fR op (\f(CW\*(C`pp_add\*(C'\fR also in \fIpp_hot.c\fR) add
together two \f(CW\*(C`gvsv\*(C'\fRs.
.PP
Now, what's this about?
.PP
.Vb 3
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
.Ve
.PP
\&\f(CW\*(C`enter\*(C'\fR and \f(CW\*(C`leave\*(C'\fR are scoping ops, and their job is to perform any
housekeeping every time you enter and leave a block: lexical variables
are tidied up, unreferenced variables are destroyed, and so on. Every
program will have those first three lines: \f(CW\*(C`leave\*(C'\fR is a list, and its
children are all the statements in the block. Statements are delimited
by \f(CW\*(C`nextstate\*(C'\fR, so a block is a collection of \f(CW\*(C`nextstate\*(C'\fR ops, with
the ops to be performed for each statement being the children of
\&\f(CW\*(C`nextstate\*(C'\fR. \f(CW\*(C`enter\*(C'\fR is a single op which functions as a marker.
.PP
That's how Perl parsed the program, from top to bottom:
.PP
.Vb 10
\&                        Program
\&                           |
\&                       Statement
\&                           |
\&                           =
\&                          / \e
\&                         /   \e
\&                        $a   +
\&                            / \e
\&                          $b   $c
.Ve
.PP
However, it's impossible to \fBperform\fR the operations in this order:
you have to find the values of \f(CW$b\fR and \f(CW$c\fR before you add them
together, for instance. So, the other thread that runs through the op
tree is the execution order: each op has a field \f(CW\*(C`op_next\*(C'\fR which
points to the next op to be run, so following these pointers tells us
how perl executes the code. We can traverse the tree in this order
using the \f(CW\*(C`exec\*(C'\fR option to \f(CW\*(C`B::Terse\*(C'\fR:
.PP
.Vb 9
\&     % perl \-MO=Terse,exec \-e \*(Aq$a=$b+$c\*(Aq
\&     1  OP (0x8179928) enter
\&     2  COP (0x81798c8) nextstate
\&     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
\&     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
\&     5  BINOP (0x8179878) add [1]
\&     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
\&     7  BINOP (0x81798a0) sassign
\&     8  LISTOP (0x8179900) leave
.Ve
.PP
This probably makes more sense for a human: enter a block, start a
statement. Get the values of \f(CW$b\fR and \f(CW$c\fR, and add them together.
Find \f(CW$a\fR, and assign one to the other. Then leave.
.PP
The way Perl builds up these op trees in the parsing process can be
unravelled by examining \fIperly.y\fR, the \s-1YACC\s0 grammar. Let's take the
piece we need to construct the tree for \f(CW\*(C`$a = $b + $c\*(C'\fR
.PP
.Vb 4
\&    1 term    :   term ASSIGNOP term
\&    2                { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
\&    3         |   term ADDOP term
\&    4                { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
If you're not used to reading \s-1BNF\s0 grammars, this is how it works:
You're fed certain things by the tokeniser, which generally end up in
upper case. Here, \f(CW\*(C`ADDOP\*(C'\fR, is provided when the tokeniser sees \f(CW\*(C`+\*(C'\fR in
your code. \f(CW\*(C`ASSIGNOP\*(C'\fR is provided when \f(CW\*(C`=\*(C'\fR is used for assigning.
These are \*(L"terminal symbols\*(R", because you can't get any simpler than
them.
.PP
The grammar, lines one and three of the snippet above, tells you how to
build up more complex forms. These complex forms, \*(L"non-terminal
symbols\*(R" are generally placed in lower case. \f(CW\*(C`term\*(C'\fR here is a
non-terminal symbol, representing a single expression.
.PP
The grammar gives you the following rule: you can make the thing on the
left of the colon if you see all the things on the right in sequence.
This is called a \*(L"reduction\*(R", and the aim of parsing is to completely
reduce the input. There are several different ways you can perform a
reduction, separated by vertical bars: so, \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`=\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR makes a \f(CW\*(C`term\*(C'\fR, and \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`+\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR can also make a \f(CW\*(C`term\*(C'\fR.
.PP
So, if you see two terms with an \f(CW\*(C`=\*(C'\fR or \f(CW\*(C`+\*(C'\fR, between them, you can
turn them into a single expression. When you do this, you execute the
code in the block on the next line: if you see \f(CW\*(C`=\*(C'\fR, you'll do the code
in line 2. If you see \f(CW\*(C`+\*(C'\fR, you'll do the code in line 4. It's this
code which contributes to the op tree.
.PP
.Vb 2
\&            |   term ADDOP term
\&            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
What this does is creates a new binary op, and feeds it a number of
variables. The variables refer to the tokens: \f(CW$1\fR is the first token
in the input, \f(CW$2\fR the second, and so on \- think regular expression
backreferences. \f(CW$$\fR is the op returned from this reduction. So, we
call \f(CW\*(C`newBINOP\*(C'\fR to create a new binary operator. The first parameter
to \f(CW\*(C`newBINOP\*(C'\fR, a function in \fIop.c\fR, is the op type. It's an addition
operator, so we want the type to be \f(CW\*(C`ADDOP\*(C'\fR. We could specify this
directly, but it's right there as the second token in the input, so we
use \f(CW$2\fR. The second parameter is the op's flags: 0 means \*(L"nothing
special\*(R". Then the things to add: the left and right hand side of our
expression, in scalar context.
.SH "STACKS"
.IX Header "STACKS"
When perl executes something like \f(CW\*(C`addop\*(C'\fR, how does it pass on its
results to the next op? The answer is, through the use of stacks. Perl
has a number of stacks to store things it's currently working on, and
we'll look at the three most important ones here.
.SS "Argument stack"
.IX Subsection "Argument stack"
Arguments are passed to \s-1PP\s0 code and returned from \s-1PP\s0 code using the
argument stack, \f(CW\*(C`ST\*(C'\fR. The typical way to handle arguments is to pop
them off the stack, deal with them how you wish, and then push the
result back onto the stack. This is how, for instance, the cosine
operator works:
.PP
.Vb 4
\&      NV value;
\&      value = POPn;
\&      value = Perl_cos(value);
\&      XPUSHn(value);
.Ve
.PP
We'll see a more tricky example of this when we consider Perl's macros
below. \f(CW\*(C`POPn\*(C'\fR gives you the \s-1NV \s0(floating point value) of the top \s-1SV\s0 on
the stack: the \f(CW$x\fR in \f(CW\*(C`cos($x)\*(C'\fR. Then we compute the cosine, and
push the result back as an \s-1NV.\s0 The \f(CW\*(C`X\*(C'\fR in \f(CW\*(C`XPUSHn\*(C'\fR means that the
stack should be extended if necessary \- it can't be necessary here,
because we know there's room for one more item on the stack, since
we've just removed one! The \f(CW\*(C`XPUSH*\*(C'\fR macros at least guarantee safety.
.PP
Alternatively, you can fiddle with the stack directly: \f(CW\*(C`SP\*(C'\fR gives you
the first element in your portion of the stack, and \f(CW\*(C`TOP*\*(C'\fR gives you
the top SV/IV/NV/etc. on the stack. So, for instance, to do unary
negation of an integer:
.PP
.Vb 1
\&     SETi(\-TOPi);
.Ve
.PP
Just set the integer value of the top stack entry to its negation.
.PP
Argument stack manipulation in the core is exactly the same as it is in
XSUBs \- see perlxstut, perlxs and perlguts for a longer
description of the macros used in stack manipulation.
.SS "Mark stack"
.IX Subsection "Mark stack"
I say \*(L"your portion of the stack\*(R" above because \s-1PP\s0 code doesn't
necessarily get the whole stack to itself: if your function calls
another function, you'll only want to expose the arguments aimed for
the called function, and not (necessarily) let it get at your own data.
The way we do this is to have a \*(L"virtual\*(R" bottom-of-stack, exposed to
each function. The mark stack keeps bookmarks to locations in the
argument stack usable by each function. For instance, when dealing with
a tied variable, (internally, something with \*(L"P\*(R" magic) Perl has to
call methods for accesses to the tied variables. However, we need to
separate the arguments exposed to the method to the argument exposed to
the original function \- the store or fetch or whatever it may be.
Here's roughly how the tied \f(CW\*(C`push\*(C'\fR is implemented; see \f(CW\*(C`av_push\*(C'\fR in
\&\fIav.c\fR:
.PP
.Vb 8
\&     1  PUSHMARK(SP);
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
\&     5  PUTBACK;
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
Let's examine the whole implementation, for practice:
.PP
.Vb 1
\&     1  PUSHMARK(SP);
.Ve
.PP
Push the current state of the stack pointer onto the mark stack. This
is so that when we've finished adding items to the argument stack, Perl
knows how many things we've added recently.
.PP
.Vb 3
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
.Ve
.PP
We're going to add two more items onto the argument stack: when you
have a tied array, the \f(CW\*(C`PUSH\*(C'\fR subroutine receives the object and the
value to be pushed, and that's exactly what we have here \- the tied
object, retrieved with \f(CW\*(C`SvTIED_obj\*(C'\fR, and the value, the \s-1SV \s0\f(CW\*(C`val\*(C'\fR.
.PP
.Vb 1
\&     5  PUTBACK;
.Ve
.PP
Next we tell Perl to update the global stack pointer from our internal
variable: \f(CW\*(C`dSP\*(C'\fR only gave us a local copy, not a reference to the
global.
.PP
.Vb 3
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
\&\f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR localise a block of code \- they make sure that
all variables are tidied up, everything that has been localised gets
its previous value returned, and so on. Think of them as the \f(CW\*(C`{\*(C'\fR and
\&\f(CW\*(C`}\*(C'\fR of a Perl block.
.PP
To actually do the magic method call, we have to call a subroutine in
Perl space: \f(CW\*(C`call_method\*(C'\fR takes care of that, and it's described in
perlcall. We call the \f(CW\*(C`PUSH\*(C'\fR method in scalar context, and we're
going to discard its return value. The \fIcall_method()\fR function removes
the top element of the mark stack, so there is nothing for the caller
to clean up.
.SS "Save stack"
.IX Subsection "Save stack"
C doesn't have a concept of local scope, so perl provides one. We've
seen that \f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR are used as scoping braces; the save
stack implements the C equivalent of, for example:
.PP
.Vb 4
\&    {
\&        local $foo = 42;
\&        ...
\&    }
.Ve
.PP
See \*(L"Localizing changes\*(R" in perlguts for how to use the save stack.
.SH "MILLIONS OF MACROS"
.IX Header "MILLIONS OF MACROS"
One thing you'll notice about the Perl source is that it's full of
macros. Some have called the pervasive use of macros the hardest thing
to understand, others find it adds to clarity. Let's take an example,
the code which implements the addition operator:
.PP
.Vb 9
\&   1  PP(pp_add)
\&   2  {
\&   3      dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
\&   4      {
\&   5        dPOPTOPnnrl_ul;
\&   6        SETn( left + right );
\&   7        RETURN;
\&   8      }
\&   9  }
.Ve
.PP
Every line here (apart from the braces, of course) contains a macro.
The first line sets up the function declaration as Perl expects for \s-1PP\s0
code; line 3 sets up variable declarations for the argument stack and
the target, the return value of the operation. Finally, it tries to see
if the addition operation is overloaded; if so, the appropriate
subroutine is called.
.PP
Line 5 is another variable declaration \- all variable declarations
start with \f(CW\*(C`d\*(C'\fR \- which pops from the top of the argument stack two NVs
(hence \f(CW\*(C`nn\*(C'\fR) and puts them into the variables \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR,
hence the \f(CW\*(C`rl\*(C'\fR. These are the two operands to the addition operator.
Next, we call \f(CW\*(C`SETn\*(C'\fR to set the \s-1NV\s0 of the return value to the result
of adding the two values. This done, we return \- the \f(CW\*(C`RETURN\*(C'\fR macro
makes sure that our return value is properly handled, and we pass the
next operator to run back to the main run loop.
.PP
Most of these macros are explained in perlapi, and some of the more
important ones are explained in perlxs as well. Pay special
attention to \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 in perlguts for
information on the \f(CW\*(C`[pad]THX_?\*(C'\fR macros.
.SH "FURTHER READING"
.IX Header "FURTHER READING"
For more information on the Perl internals, please see the documents
listed at \*(L"Internals and C Language Interface\*(R" in perl.
                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlinterp5.16.1                             0100644 0001750 0001750 00000115023 12566207421 023435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERP 1"
.TH PERLINTERP 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlinterp \- An overview of the Perl interpreter
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides an overview of how the Perl interpreter works at
the level of C code, along with pointers to the relevant C source code
files.
.SH "ELEMENTS OF THE INTERPRETER"
.IX Header "ELEMENTS OF THE INTERPRETER"
The work of the interpreter has two main stages: compiling the code
into the internal representation, or bytecode, and then executing it.
\&\*(L"Compiled code\*(R" in perlguts explains exactly how the compilation stage
happens.
.PP
Here is a short breakdown of perl's operation:
.SS "Startup"
.IX Subsection "Startup"
The action begins in \fIperlmain.c\fR. (or \fIminiperlmain.c\fR for miniperl)
This is very high-level code, enough to fit on a single screen, and it
resembles the code found in perlembed; most of the real action takes
place in \fIperl.c\fR
.PP
\&\fIperlmain.c\fR is generated by \f(CW\*(C`ExtUtils::Miniperl\*(C'\fR from
\&\fIminiperlmain.c\fR at make time, so you should make perl to follow this
along.
.PP
First, \fIperlmain.c\fR allocates some memory and constructs a Perl
interpreter, along these lines:
.PP
.Vb 9
\&    1 PERL_SYS_INIT3(&argc,&argv,&env);
\&    2
\&    3 if (!PL_do_undump) {
\&    4     my_perl = perl_alloc();
\&    5     if (!my_perl)
\&    6         exit(1);
\&    7     perl_construct(my_perl);
\&    8     PL_perl_destruct_level = 0;
\&    9 }
.Ve
.PP
Line 1 is a macro, and its definition is dependent on your operating
system. Line 3 references \f(CW\*(C`PL_do_undump\*(C'\fR, a global variable \- all
global variables in Perl start with \f(CW\*(C`PL_\*(C'\fR. This tells you whether the
current running program was created with the \f(CW\*(C`\-u\*(C'\fR flag to perl and
then \fIundump\fR, which means it's going to be false in any sane context.
.PP
Line 4 calls a function in \fIperl.c\fR to allocate memory for a Perl
interpreter. It's quite a simple function, and the guts of it looks
like this:
.PP
.Vb 1
\& my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
.Ve
.PP
Here you see an example of Perl's system abstraction, which we'll see
later: \f(CW\*(C`PerlMem_malloc\*(C'\fR is either your system's \f(CW\*(C`malloc\*(C'\fR, or Perl's
own \f(CW\*(C`malloc\*(C'\fR as defined in \fImalloc.c\fR if you selected that option at
configure time.
.PP
Next, in line 7, we construct the interpreter using perl_construct,
also in \fIperl.c\fR; this sets up all the special variables that Perl
needs, the stacks, and so on.
.PP
Now we pass Perl the command line options, and tell it to go:
.PP
.Vb 3
\& exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
\& if (!exitstatus)
\&     perl_run(my_perl);
\&
\& exitstatus = perl_destruct(my_perl);
\&
\& perl_free(my_perl);
.Ve
.PP
\&\f(CW\*(C`perl_parse\*(C'\fR is actually a wrapper around \f(CW\*(C`S_parse_body\*(C'\fR, as defined
in \fIperl.c\fR, which processes the command line options, sets up any
statically linked \s-1XS\s0 modules, opens the program and calls \f(CW\*(C`yyparse\*(C'\fR to
parse it.
.SS "Parsing"
.IX Subsection "Parsing"
The aim of this stage is to take the Perl source, and turn it into an
op tree. We'll see what one of those looks like later. Strictly
speaking, there's three things going on here.
.PP
\&\f(CW\*(C`yyparse\*(C'\fR, the parser, lives in \fIperly.c\fR, although you're better off
reading the original \s-1YACC\s0 input in \fIperly.y\fR. (Yes, Virginia, there
\&\fBis\fR a \s-1YACC\s0 grammar for Perl!) The job of the parser is to take your
code and \*(L"understand\*(R" it, splitting it into sentences, deciding which
operands go with which operators and so on.
.PP
The parser is nobly assisted by the lexer, which chunks up your input
into tokens, and decides what type of thing each token is: a variable
name, an operator, a bareword, a subroutine, a core function, and so
on. The main point of entry to the lexer is \f(CW\*(C`yylex\*(C'\fR, and that and its
associated routines can be found in \fItoke.c\fR. Perl isn't much like
other computer languages; it's highly context sensitive at times, it
can be tricky to work out what sort of token something is, or where a
token ends. As such, there's a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if you're not used to
it.
.PP
As the parser understands a Perl program, it builds up a tree of
operations for the interpreter to perform during execution. The
routines which construct and link together the various operations are
to be found in \fIop.c\fR, and will be examined later.
.SS "Optimization"
.IX Subsection "Optimization"
Now the parsing stage is complete, and the finished tree represents the
operations that the Perl interpreter needs to perform to execute our
program. Next, Perl does a dry run over the tree looking for
optimisations: constant expressions such as \f(CW\*(C`3 + 4\*(C'\fR will be computed
now, and the optimizer will also see if any multiple operations can be
replaced with a single one. For instance, to fetch the variable
\&\f(CW$foo\fR, instead of grabbing the glob \f(CW*foo\fR and looking at the scalar
component, the optimizer fiddles the op tree to use a function which
directly looks up the scalar in question. The main optimizer is \f(CW\*(C`peep\*(C'\fR
in \fIop.c\fR, and many ops have their own optimizing functions.
.SS "Running"
.IX Subsection "Running"
Now we're finally ready to go: we have compiled Perl byte code, and all
that's left to do is run it. The actual execution is done by the
\&\f(CW\*(C`runops_standard\*(C'\fR function in \fIrun.c\fR; more specifically, it's done
by these three innocent looking lines:
.PP
.Vb 3
\&    while ((PL_op = PL_op\->op_ppaddr(aTHX))) {
\&        PERL_ASYNC_CHECK();
\&    }
.Ve
.PP
You may be more comfortable with the Perl version of that:
.PP
.Vb 1
\&    PERL_ASYNC_CHECK() while $Perl::op = &{$Perl::op\->{function}};
.Ve
.PP
Well, maybe not. Anyway, each op contains a function pointer, which
stipulates the function which will actually carry out the operation.
This function will return the next op in the sequence \- this allows for
things like \f(CW\*(C`if\*(C'\fR which choose the next op dynamically at run time. The
\&\f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR makes sure that things like signals interrupt
execution if required.
.PP
The actual functions called are known as \s-1PP\s0 code, and they're spread
between four files: \fIpp_hot.c\fR contains the \*(L"hot\*(R" code, which is most
often used and highly optimized, \fIpp_sys.c\fR contains all the
system-specific functions, \fIpp_ctl.c\fR contains the functions which
implement control structures (\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR and the like) and \fIpp.c\fR
contains everything else. These are, if you like, the C code for Perl's
built-in functions and operators.
.PP
Note that each \f(CW\*(C`pp_\*(C'\fR function is expected to return a pointer to the
next op. Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume extra space on the C stack. For
example, \f(CW\*(C`pp_entersub\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR just push a \f(CW\*(C`CxSUB\*(C'\fR or
\&\f(CW\*(C`CxEVAL\*(C'\fR block struct onto the context stack which contain the address
of the op following the sub call or eval. They then return the first op
of that sub or eval block, and so execution continues of that sub or
block. Later, a \f(CW\*(C`pp_leavesub\*(C'\fR or \f(CW\*(C`pp_leavetry\*(C'\fR op pops the \f(CW\*(C`CxSUB\*(C'\fR
or \f(CW\*(C`CxEVAL\*(C'\fR, retrieves the return op from it, and returns it.
.SS "Exception handing"
.IX Subsection "Exception handing"
Perl's exception handing (i.e. \f(CW\*(C`die\*(C'\fR etc.) is built on top of the
low-level \f(CW\*(C`setjmp()\*(C'\fR/\f(CW\*(C`longjmp()\*(C'\fR C\-library functions. These basically
provide a way to capture the current \s-1PC\s0 and \s-1SP\s0 registers and later
restore them; i.e. a \f(CW\*(C`longjmp()\*(C'\fR continues at the point in code where
a previous \f(CW\*(C`setjmp()\*(C'\fR was done, with anything further up on the C
stack being lost. This is why code should always save values using
\&\f(CW\*(C`SAVE_FOO\*(C'\fR rather than in auto variables.
.PP
The perl core wraps \f(CW\*(C`setjmp()\*(C'\fR etc in the macros \f(CW\*(C`JMPENV_PUSH\*(C'\fR and
\&\f(CW\*(C`JMPENV_JUMP\*(C'\fR. The basic rule of perl exceptions is that \f(CW\*(C`exit\*(C'\fR, and
\&\f(CW\*(C`die\*(C'\fR (in the absence of \f(CW\*(C`eval\*(C'\fR) perform a \f(CWJMPENV_JUMP(2)\fR, while
\&\f(CW\*(C`die\*(C'\fR within \f(CW\*(C`eval\*(C'\fR does a \f(CWJMPENV_JUMP(3)\fR.
.PP
At entry points to perl, such as \f(CW\*(C`perl_parse()\*(C'\fR, \f(CW\*(C`perl_run()\*(C'\fR and
\&\f(CW\*(C`call_sv(cv, G_EVAL)\*(C'\fR each does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR, then enter a runops
loop or whatever, and handle possible exception returns. For a 2
return, final cleanup is performed, such as popping stacks and calling
\&\f(CW\*(C`CHECK\*(C'\fR or \f(CW\*(C`END\*(C'\fR blocks. Amongst other things, this is how scope
cleanup still occurs during an \f(CW\*(C`exit\*(C'\fR.
.PP
If a \f(CW\*(C`die\*(C'\fR can find a \f(CW\*(C`CxEVAL\*(C'\fR block on the context stack, then the
stack is popped to that level and the return op in that block is
assigned to \f(CW\*(C`PL_restartop\*(C'\fR; then a \f(CWJMPENV_JUMP(3)\fR is performed.
This normally passes control back to the guard. In the case of
\&\f(CW\*(C`perl_run\*(C'\fR and \f(CW\*(C`call_sv\*(C'\fR, a non-null \f(CW\*(C`PL_restartop\*(C'\fR triggers
re-entry to the runops loop. The is the normal way that \f(CW\*(C`die\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR is handled within an \f(CW\*(C`eval\*(C'\fR.
.PP
Sometimes ops are executed within an inner runops loop, such as tie,
sort or overload code. In this case, something like
.PP
.Vb 1
\&    sub FETCH { eval { die } }
.Ve
.PP
would cause a longjmp right back to the guard in \f(CW\*(C`perl_run\*(C'\fR, popping
both runops loops, which is clearly incorrect. One way to avoid this is
for the tie code to do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR before executing \f(CW\*(C`FETCH\*(C'\fR in
the inner runops loop, but for efficiency reasons, perl in fact just
sets a flag, using \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR. The \f(CW\*(C`pp_require\*(C'\fR,
\&\f(CW\*(C`pp_entereval\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR ops check this flag, and if true,
they call \f(CW\*(C`docatch\*(C'\fR, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a new
runops level to execute the code, rather than doing it on the current
loop.
.PP
As a further optimisation, on exit from the eval block in the \f(CW\*(C`FETCH\*(C'\fR,
execution of the code following the block is still carried on in the
inner loop. When an exception is raised, \f(CW\*(C`docatch\*(C'\fR compares the
\&\f(CW\*(C`JMPENV\*(C'\fR level of the \f(CW\*(C`CxEVAL\*(C'\fR with \f(CW\*(C`PL_top_env\*(C'\fR and if they differ,
just re-throws the exception. In this way any inner loops get popped.
.PP
Here's an example.
.PP
.Vb 5
\&    1: eval { tie @a, \*(AqA\*(Aq };
\&    2: sub A::TIEARRAY {
\&    3:     eval { die };
\&    4:     die;
\&    5: }
.Ve
.PP
To run this code, \f(CW\*(C`perl_run\*(C'\fR is called, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR
then enters a runops loop. This loop executes the eval and tie ops on
line 1, with the eval pushing a \f(CW\*(C`CxEVAL\*(C'\fR onto the context stack.
.PP
The \f(CW\*(C`pp_tie\*(C'\fR does a \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR, then starts a second runops
loop to execute the body of \f(CW\*(C`TIEARRAY\*(C'\fR. When it executes the entertry
op on line 3, \f(CW\*(C`CATCH_GET\*(C'\fR is true, so \f(CW\*(C`pp_entertry\*(C'\fR calls \f(CW\*(C`docatch\*(C'\fR
which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a third runops loop, which then
executes the die op. At this point the C call stack looks like this:
.PP
.Vb 10
\&    Perl_pp_die
\&    Perl_runops      # third loop
\&    S_docatch_body
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
and the context and data stacks, as shown by \f(CW\*(C`\-Dstv\*(C'\fR, look like:
.PP
.Vb 9
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
\&      CX 1: EVAL   => *
\&    retop=nextstate
.Ve
.PP
The die pops the first \f(CW\*(C`CxEVAL\*(C'\fR off the context stack, sets
\&\f(CW\*(C`PL_restartop\*(C'\fR from it, does a \f(CWJMPENV_JUMP(3)\fR, and control returns
to the top \f(CW\*(C`docatch\*(C'\fR. This then starts another third-level runops
level, which executes the nextstate, pushmark and die ops on line 4. At
the point that the second \f(CW\*(C`pp_die\*(C'\fR is called, the C call stack looks
exactly like that above, even though we are no longer within an inner
eval; this is because of the optimization mentioned earlier. However,
the context stack now looks like this, ie with the top CxEVAL popped:
.PP
.Vb 7
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
.Ve
.PP
The die on line 4 pops the context stack back down to the CxEVAL,
leaving it as:
.PP
.Vb 2
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
.Ve
.PP
As usual, \f(CW\*(C`PL_restartop\*(C'\fR is extracted from the \f(CW\*(C`CxEVAL\*(C'\fR, and a
\&\f(CWJMPENV_JUMP(3)\fR done, which pops the C stack back to the docatch:
.PP
.Vb 10
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
In  this case, because the \f(CW\*(C`JMPENV\*(C'\fR level recorded in the \f(CW\*(C`CxEVAL\*(C'\fR
differs from the current one, \f(CW\*(C`docatch\*(C'\fR just does a \f(CWJMPENV_JUMP(3)\fR
and the C stack unwinds to:
.PP
.Vb 2
\&    perl_run
\&    main
.Ve
.PP
Because \f(CW\*(C`PL_restartop\*(C'\fR is non-null, \f(CW\*(C`run_body\*(C'\fR starts a new runops
loop and execution continues.
.SS "\s-1INTERNAL\s0 \s-1VARIABLE\s0 \s-1TYPES\s0"
.IX Subsection "INTERNAL VARIABLE TYPES"
You should by now have had a look at perlguts, which tells you about
Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
that now.
.PP
These variables are used not only to represent Perl-space variables,
but also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance, is an
ordinary Perl hash. Your code is represented by an \s-1SV\s0 as it's read into
the parser; any program files you call are opened via ordinary Perl
filehandles, and so on.
.PP
The core Devel::Peek module lets us examine SVs from a
Perl program. Let's see, for instance, how Perl treats the constant
\&\f(CW"hello"\fR.
.PP
.Vb 7
\&      % perl \-MDevel::Peek \-e \*(AqDump("hello")\*(Aq
\&    1 SV = PV(0xa041450) at 0xa04ecbc
\&    2   REFCNT = 1
\&    3   FLAGS = (POK,READONLY,pPOK)
\&    4   PV = 0xa0484e0 "hello"\e0
\&    5   CUR = 5
\&    6   LEN = 6
.Ve
.PP
Reading \f(CW\*(C`Devel::Peek\*(C'\fR output takes a bit of practise, so let's go
through it line by line.
.PP
Line 1 tells us we're looking at an \s-1SV\s0 which lives at \f(CW0xa04ecbc\fR in
memory. SVs themselves are very simple structures, but they contain a
pointer to a more complex structure. In this case, it's a \s-1PV\s0, a
structure which holds a string value, at location \f(CW0xa041450\fR. Line 2
is the reference count; there are no other references to this data, so
it's 1.
.PP
Line 3 are the flags for this \s-1SV\s0 \- it's \s-1OK\s0 to use it as a \s-1PV\s0, it's a
read-only \s-1SV\s0 (because it's a constant) and the data is a \s-1PV\s0 internally.
Next we've got the contents of the string, starting at location
\&\f(CW0xa0484e0\fR.
.PP
Line 5 gives us the current length of the string \- note that this does
\&\fBnot\fR include the null terminator. Line 6 is not the length of the
string, but the length of the currently allocated buffer; as the string
grows, Perl automatically extends the available storage via a routine
called \f(CW\*(C`SvGROW\*(C'\fR.
.PP
You can get at any of these quantities from C very easily; just add
\&\f(CW\*(C`Sv\*(C'\fR to the name of the field shown in the snippet, and you've got a
macro which will return the value: \f(CW\*(C`SvCUR(sv)\*(C'\fR returns the current
length of the string, \f(CW\*(C`SvREFCOUNT(sv)\*(C'\fR returns the reference count,
\&\f(CW\*(C`SvPV(sv, len)\*(C'\fR returns the string itself with its length, and so on.
More macros to manipulate these properties can be found in perlguts.
.PP
Let's take an example of manipulating a \s-1PV\s0, from \f(CW\*(C`sv_catpvn\*(C'\fR, in
\&\fIsv.c\fR
.PP
.Vb 5
\&     1  void
\&     2  Perl_sv_catpvn(pTHX_ register SV *sv, register const char *ptr, register STRLEN len)
\&     3  {
\&     4      STRLEN tlen;
\&     5      char *junk;
\&
\&     6      junk = SvPV_force(sv, tlen);
\&     7      SvGROW(sv, tlen + len + 1);
\&     8      if (ptr == junk)
\&     9          ptr = SvPVX(sv);
\&    10      Move(ptr,SvPVX(sv)+tlen,len,char);
\&    11      SvCUR(sv) += len;
\&    12      *SvEND(sv) = \*(Aq\e0\*(Aq;
\&    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
\&    14      SvTAINT(sv);
\&    15  }
.Ve
.PP
This is a function which adds a string, \f(CW\*(C`ptr\*(C'\fR, of length \f(CW\*(C`len\*(C'\fR onto
the end of the \s-1PV\s0 stored in \f(CW\*(C`sv\*(C'\fR. The first thing we do in line 6 is
make sure that the \s-1SV\s0 \fBhas\fR a valid \s-1PV\s0, by calling the \f(CW\*(C`SvPV_force\*(C'\fR
macro to force a \s-1PV\s0. As a side effect, \f(CW\*(C`tlen\*(C'\fR gets set to the current
value of the \s-1PV\s0, and the \s-1PV\s0 itself is returned to \f(CW\*(C`junk\*(C'\fR.
.PP
In line 7, we make sure that the \s-1SV\s0 will have enough room to
accommodate the old string, the new string and the null terminator. If
\&\f(CW\*(C`LEN\*(C'\fR isn't big enough, \f(CW\*(C`SvGROW\*(C'\fR will reallocate space for us.
.PP
Now, if \f(CW\*(C`junk\*(C'\fR is the same as the string we're trying to add, we can
grab the string directly from the \s-1SV\s0; \f(CW\*(C`SvPVX\*(C'\fR is the address of the \s-1PV\s0
in the \s-1SV\s0.
.PP
Line 10 does the actual catenation: the \f(CW\*(C`Move\*(C'\fR macro moves a chunk of
memory around: we move the string \f(CW\*(C`ptr\*(C'\fR to the end of the \s-1PV\s0 \- that's
the start of the \s-1PV\s0 plus its current length. We're moving \f(CW\*(C`len\*(C'\fR bytes
of type \f(CW\*(C`char\*(C'\fR. After doing so, we need to tell Perl we've extended
the string, by altering \f(CW\*(C`CUR\*(C'\fR to reflect the new length. \f(CW\*(C`SvEND\*(C'\fR is a
macro which gives us the end of the string, so that needs to be a
\&\f(CW"\e0"\fR.
.PP
Line 13 manipulates the flags; since we've changed the \s-1PV\s0, any \s-1IV\s0 or \s-1NV\s0
values will no longer be valid: if we have \f(CW\*(C`$a=10; $a.="6";\*(C'\fR we don't
want to use the old \s-1IV\s0 of 10. \f(CW\*(C`SvPOK_only_utf8\*(C'\fR is a special
UTF\-8\-aware version of \f(CW\*(C`SvPOK_only\*(C'\fR, a macro which turns off the \s-1IOK\s0
and \s-1NOK\s0 flags and turns on \s-1POK\s0. The final \f(CW\*(C`SvTAINT\*(C'\fR is a macro which
launders tainted data if taint mode is turned on.
.PP
AVs and HVs are more complicated, but SVs are by far the most common
variable type being thrown around. Having seen something of how we
manipulate these, let's go on and look at how the op tree is
constructed.
.SH "OP TREES"
.IX Header "OP TREES"
First, what is the op tree, anyway? The op tree is the parsed
representation of your program, as we saw in our section on parsing,
and it's the sequence of operations that Perl goes through to execute
your program, as we saw in \*(L"Running\*(R".
.PP
An op is a fundamental operation that Perl can perform: all the
built-in functions and operators are ops, and there are a series of ops
which deal with concepts the interpreter needs internally \- entering
and leaving a block, ending a statement, fetching a variable, and so
on.
.PP
The op tree is connected in two ways: you can imagine that there are
two \*(L"routes\*(R" through it, two orders in which you can traverse the tree.
First, parse order reflects how the parser understood the code, and
secondly, execution order tells perl what order to perform the
operations in.
.PP
The easiest way to examine the op tree is to stop Perl after it has
finished parsing, and get it to dump out the tree. This is exactly what
the compiler backends B::Terse, B::Concise
and B::Debug do.
.PP
Let's have a look at how Perl sees \f(CW\*(C`$a = $b + $c\*(C'\fR:
.PP
.Vb 12
\&     % perl \-MO=Terse \-e \*(Aq$a=$b+$c\*(Aq
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
\&     4      BINOP (0x8179828) sassign
\&     5          BINOP (0x8179800) add [1]
\&     6              UNOP (0x81796e0) null [15]
\&     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
\&     8              UNOP (0x81797e0) null [15]
\&     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
\&    10          UNOP (0x816b4f0) null [15]
\&    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a
.Ve
.PP
Let's start in the middle, at line 4. This is a \s-1BINOP\s0, a binary
operator, which is at location \f(CW0x8179828\fR. The specific operator in
question is \f(CW\*(C`sassign\*(C'\fR \- scalar assignment \- and you can find the code
which implements it in the function \f(CW\*(C`pp_sassign\*(C'\fR in \fIpp_hot.c\fR. As a
binary operator, it has two children: the add operator, providing the
result of \f(CW\*(C`$b+$c\*(C'\fR, is uppermost on line 5, and the left hand side is
on line 10.
.PP
Line 10 is the null op: this does exactly nothing. What is that doing
there? If you see the null op, it's a sign that something has been
optimized away after parsing. As we mentioned in \*(L"Optimization\*(R", the
optimization stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens, instead of
rewriting the op tree and cleaning up the dangling pointers, it's
easier just to replace the redundant operation with the null op.
Originally, the tree would have looked like this:
.PP
.Vb 2
\&    10          SVOP (0x816b4f0) rv2sv [15]
\&    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a
.Ve
.PP
That is, fetch the \f(CW\*(C`a\*(C'\fR entry from the main symbol table, and then look
at the scalar component of it: \f(CW\*(C`gvsv\*(C'\fR (\f(CW\*(C`pp_gvsv\*(C'\fR into \fIpp_hot.c\fR)
happens to do both these things.
.PP
The right hand side, starting at line 5 is similar to what we've just
seen: we have the \f(CW\*(C`add\*(C'\fR op (\f(CW\*(C`pp_add\*(C'\fR also in \fIpp_hot.c\fR) add
together two \f(CW\*(C`gvsv\*(C'\fRs.
.PP
Now, what's this about?
.PP
.Vb 3
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
.Ve
.PP
\&\f(CW\*(C`enter\*(C'\fR and \f(CW\*(C`leave\*(C'\fR are scoping ops, and their job is to perform any
housekeeping every time you enter and leave a block: lexical variables
are tidied up, unreferenced variables are destroyed, and so on. Every
program will have those first three lines: \f(CW\*(C`leave\*(C'\fR is a list, and its
children are all the statements in the block. Statements are delimited
by \f(CW\*(C`nextstate\*(C'\fR, so a block is a collection of \f(CW\*(C`nextstate\*(C'\fR ops, with
the ops to be performed for each statement being the children of
\&\f(CW\*(C`nextstate\*(C'\fR. \f(CW\*(C`enter\*(C'\fR is a single op which functions as a marker.
.PP
That's how Perl parsed the program, from top to bottom:
.PP
.Vb 10
\&                        Program
\&                           |
\&                       Statement
\&                           |
\&                           =
\&                          / \e
\&                         /   \e
\&                        $a   +
\&                            / \e
\&                          $b   $c
.Ve
.PP
However, it's impossible to \fBperform\fR the operations in this order:
you have to find the values of \f(CW$b\fR and \f(CW$c\fR before you add them
together, for instance. So, the other thread that runs through the op
tree is the execution order: each op has a field \f(CW\*(C`op_next\*(C'\fR which
points to the next op to be run, so following these pointers tells us
how perl executes the code. We can traverse the tree in this order
using the \f(CW\*(C`exec\*(C'\fR option to \f(CW\*(C`B::Terse\*(C'\fR:
.PP
.Vb 9
\&     % perl \-MO=Terse,exec \-e \*(Aq$a=$b+$c\*(Aq
\&     1  OP (0x8179928) enter
\&     2  COP (0x81798c8) nextstate
\&     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
\&     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
\&     5  BINOP (0x8179878) add [1]
\&     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
\&     7  BINOP (0x81798a0) sassign
\&     8  LISTOP (0x8179900) leave
.Ve
.PP
This probably makes more sense for a human: enter a block, start a
statement. Get the values of \f(CW$b\fR and \f(CW$c\fR, and add them together.
Find \f(CW$a\fR, and assign one to the other. Then leave.
.PP
The way Perl builds up these op trees in the parsing process can be
unravelled by examining \fIperly.y\fR, the \s-1YACC\s0 grammar. Let's take the
piece we need to construct the tree for \f(CW\*(C`$a = $b + $c\*(C'\fR
.PP
.Vb 4
\&    1 term    :   term ASSIGNOP term
\&    2                { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
\&    3         |   term ADDOP term
\&    4                { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
If you're not used to reading \s-1BNF\s0 grammars, this is how it works:
You're fed certain things by the tokeniser, which generally end up in
upper case. Here, \f(CW\*(C`ADDOP\*(C'\fR, is provided when the tokeniser sees \f(CW\*(C`+\*(C'\fR in
your code. \f(CW\*(C`ASSIGNOP\*(C'\fR is provided when \f(CW\*(C`=\*(C'\fR is used for assigning.
These are \*(L"terminal symbols\*(R", because you can't get any simpler than
them.
.PP
The grammar, lines one and three of the snippet above, tells you how to
build up more complex forms. These complex forms, \*(L"non-terminal
symbols\*(R" are generally placed in lower case. \f(CW\*(C`term\*(C'\fR here is a
non-terminal symbol, representing a single expression.
.PP
The grammar gives you the following rule: you can make the thing on the
left of the colon if you see all the things on the right in sequence.
This is called a \*(L"reduction\*(R", and the aim of parsing is to completely
reduce the input. There are several different ways you can perform a
reduction, separated by vertical bars: so, \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`=\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR makes a \f(CW\*(C`term\*(C'\fR, and \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`+\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR can also make a \f(CW\*(C`term\*(C'\fR.
.PP
So, if you see two terms with an \f(CW\*(C`=\*(C'\fR or \f(CW\*(C`+\*(C'\fR, between them, you can
turn them into a single expression. When you do this, you execute the
code in the block on the next line: if you see \f(CW\*(C`=\*(C'\fR, you'll do the code
in line 2. If you see \f(CW\*(C`+\*(C'\fR, you'll do the code in line 4. It's this
code which contributes to the op tree.
.PP
.Vb 2
\&            |   term ADDOP term
\&            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
What this does is creates a new binary op, and feeds it a number of
variables. The variables refer to the tokens: \f(CW$1\fR is the first token
in the input, \f(CW$2\fR the second, and so on \- think regular expression
backreferences. \f(CW$$\fR is the op returned from this reduction. So, we
call \f(CW\*(C`newBINOP\*(C'\fR to create a new binary operator. The first parameter
to \f(CW\*(C`newBINOP\*(C'\fR, a function in \fIop.c\fR, is the op type. It's an addition
operator, so we want the type to be \f(CW\*(C`ADDOP\*(C'\fR. We could specify this
directly, but it's right there as the second token in the input, so we
use \f(CW$2\fR. The second parameter is the op's flags: 0 means \*(L"nothing
special\*(R". Then the things to add: the left and right hand side of our
expression, in scalar context.
.SH "STACKS"
.IX Header "STACKS"
When perl executes something like \f(CW\*(C`addop\*(C'\fR, how does it pass on its
results to the next op? The answer is, through the use of stacks. Perl
has a number of stacks to store things it's currently working on, and
we'll look at the three most important ones here.
.SS "Argument stack"
.IX Subsection "Argument stack"
Arguments are passed to \s-1PP\s0 code and returned from \s-1PP\s0 code using the
argument stack, \f(CW\*(C`ST\*(C'\fR. The typical way to handle arguments is to pop
them off the stack, deal with them how you wish, and then push the
result back onto the stack. This is how, for instance, the cosine
operator works:
.PP
.Vb 4
\&      NV value;
\&      value = POPn;
\&      value = Perl_cos(value);
\&      XPUSHn(value);
.Ve
.PP
We'll see a more tricky example of this when we consider Perl's macros
below. \f(CW\*(C`POPn\*(C'\fR gives you the \s-1NV\s0 (floating point value) of the top \s-1SV\s0 on
the stack: the \f(CW$x\fR in \f(CW\*(C`cos($x)\*(C'\fR. Then we compute the cosine, and
push the result back as an \s-1NV\s0. The \f(CW\*(C`X\*(C'\fR in \f(CW\*(C`XPUSHn\*(C'\fR means that the
stack should be extended if necessary \- it can't be necessary here,
because we know there's room for one more item on the stack, since
we've just removed one! The \f(CW\*(C`XPUSH*\*(C'\fR macros at least guarantee safety.
.PP
Alternatively, you can fiddle with the stack directly: \f(CW\*(C`SP\*(C'\fR gives you
the first element in your portion of the stack, and \f(CW\*(C`TOP*\*(C'\fR gives you
the top SV/IV/NV/etc. on the stack. So, for instance, to do unary
negation of an integer:
.PP
.Vb 1
\&     SETi(\-TOPi);
.Ve
.PP
Just set the integer value of the top stack entry to its negation.
.PP
Argument stack manipulation in the core is exactly the same as it is in
XSUBs \- see perlxstut, perlxs and perlguts for a longer
description of the macros used in stack manipulation.
.SS "Mark stack"
.IX Subsection "Mark stack"
I say \*(L"your portion of the stack\*(R" above because \s-1PP\s0 code doesn't
necessarily get the whole stack to itself: if your function calls
another function, you'll only want to expose the arguments aimed for
the called function, and not (necessarily) let it get at your own data.
The way we do this is to have a \*(L"virtual\*(R" bottom-of-stack, exposed to
each function. The mark stack keeps bookmarks to locations in the
argument stack usable by each function. For instance, when dealing with
a tied variable, (internally, something with \*(L"P\*(R" magic) Perl has to
call methods for accesses to the tied variables. However, we need to
separate the arguments exposed to the method to the argument exposed to
the original function \- the store or fetch or whatever it may be.
Here's roughly how the tied \f(CW\*(C`push\*(C'\fR is implemented; see \f(CW\*(C`av_push\*(C'\fR in
\&\fIav.c\fR:
.PP
.Vb 8
\&     1  PUSHMARK(SP);
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
\&     5  PUTBACK;
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
Let's examine the whole implementation, for practice:
.PP
.Vb 1
\&     1  PUSHMARK(SP);
.Ve
.PP
Push the current state of the stack pointer onto the mark stack. This
is so that when we've finished adding items to the argument stack, Perl
knows how many things we've added recently.
.PP
.Vb 3
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
.Ve
.PP
We're going to add two more items onto the argument stack: when you
have a tied array, the \f(CW\*(C`PUSH\*(C'\fR subroutine receives the object and the
value to be pushed, and that's exactly what we have here \- the tied
object, retrieved with \f(CW\*(C`SvTIED_obj\*(C'\fR, and the value, the \s-1SV\s0 \f(CW\*(C`val\*(C'\fR.
.PP
.Vb 1
\&     5  PUTBACK;
.Ve
.PP
Next we tell Perl to update the global stack pointer from our internal
variable: \f(CW\*(C`dSP\*(C'\fR only gave us a local copy, not a reference to the
global.
.PP
.Vb 3
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
\&\f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR localise a block of code \- they make sure that
all variables are tidied up, everything that has been localised gets
its previous value returned, and so on. Think of them as the \f(CW\*(C`{\*(C'\fR and
\&\f(CW\*(C`}\*(C'\fR of a Perl block.
.PP
To actually do the magic method call, we have to call a subroutine in
Perl space: \f(CW\*(C`call_method\*(C'\fR takes care of that, and it's described in
perlcall. We call the \f(CW\*(C`PUSH\*(C'\fR method in scalar context, and we're
going to discard its return value. The \fIcall_method()\fR function removes
the top element of the mark stack, so there is nothing for the caller
to clean up.
.SS "Save stack"
.IX Subsection "Save stack"
C doesn't have a concept of local scope, so perl provides one. We've
seen that \f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR are used as scoping braces; the save
stack implements the C equivalent of, for example:
.PP
.Vb 4
\&    {
\&        local $foo = 42;
\&        ...
\&    }
.Ve
.PP
See \*(L"Localizing changes\*(R" in perlguts for how to use the save stack.
.SH "MILLIONS OF MACROS"
.IX Header "MILLIONS OF MACROS"
One thing you'll notice about the Perl source is that it's full of
macros. Some have called the pervasive use of macros the hardest thing
to understand, others find it adds to clarity. Let's take an example,
the code which implements the addition operator:
.PP
.Vb 9
\&   1  PP(pp_add)
\&   2  {
\&   3      dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
\&   4      {
\&   5        dPOPTOPnnrl_ul;
\&   6        SETn( left + right );
\&   7        RETURN;
\&   8      }
\&   9  }
.Ve
.PP
Every line here (apart from the braces, of course) contains a macro.
The first line sets up the function declaration as Perl expects for \s-1PP\s0
code; line 3 sets up variable declarations for the argument stack and
the target, the return value of the operation. Finally, it tries to see
if the addition operation is overloaded; if so, the appropriate
subroutine is called.
.PP
Line 5 is another variable declaration \- all variable declarations
start with \f(CW\*(C`d\*(C'\fR \- which pops from the top of the argument stack two NVs
(hence \f(CW\*(C`nn\*(C'\fR) and puts them into the variables \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR,
hence the \f(CW\*(C`rl\*(C'\fR. These are the two operands to the addition operator.
Next, we call \f(CW\*(C`SETn\*(C'\fR to set the \s-1NV\s0 of the return value to the result
of adding the two values. This done, we return \- the \f(CW\*(C`RETURN\*(C'\fR macro
makes sure that our return value is properly handled, and we pass the
next operator to run back to the main run loop.
.PP
Most of these macros are explained in perlapi, and some of the more
important ones are explained in perlxs as well. Pay special
attention to \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\s0\*(R" in perlguts for
information on the \f(CW\*(C`[pad]THX_?\*(C'\fR macros.
.SH "FURTHER READING"
.IX Header "FURTHER READING"
For more information on the Perl internals, please see the documents
listed at \*(L"Internals and C Language Interface\*(R" in perl.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlinterp5.18.1                             0100644 0001750 0001750 00000115273 12566207441 023450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERP 1"
.TH PERLINTERP 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlinterp \- An overview of the Perl interpreter
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document provides an overview of how the Perl interpreter works at
the level of C code, along with pointers to the relevant C source code
files.
.SH "ELEMENTS OF THE INTERPRETER"
.IX Header "ELEMENTS OF THE INTERPRETER"
The work of the interpreter has two main stages: compiling the code
into the internal representation, or bytecode, and then executing it.
\&\*(L"Compiled code\*(R" in perlguts explains exactly how the compilation stage
happens.
.PP
Here is a short breakdown of perl's operation:
.SS "Startup"
.IX Subsection "Startup"
The action begins in \fIperlmain.c\fR. (or \fIminiperlmain.c\fR for miniperl)
This is very high-level code, enough to fit on a single screen, and it
resembles the code found in perlembed; most of the real action takes
place in \fIperl.c\fR
.PP
\&\fIperlmain.c\fR is generated by \f(CW\*(C`ExtUtils::Miniperl\*(C'\fR from
\&\fIminiperlmain.c\fR at make time, so you should make perl to follow this
along.
.PP
First, \fIperlmain.c\fR allocates some memory and constructs a Perl
interpreter, along these lines:
.PP
.Vb 9
\&    1 PERL_SYS_INIT3(&argc,&argv,&env);
\&    2
\&    3 if (!PL_do_undump) {
\&    4     my_perl = perl_alloc();
\&    5     if (!my_perl)
\&    6         exit(1);
\&    7     perl_construct(my_perl);
\&    8     PL_perl_destruct_level = 0;
\&    9 }
.Ve
.PP
Line 1 is a macro, and its definition is dependent on your operating
system. Line 3 references \f(CW\*(C`PL_do_undump\*(C'\fR, a global variable \- all
global variables in Perl start with \f(CW\*(C`PL_\*(C'\fR. This tells you whether the
current running program was created with the \f(CW\*(C`\-u\*(C'\fR flag to perl and
then \fIundump\fR, which means it's going to be false in any sane context.
.PP
Line 4 calls a function in \fIperl.c\fR to allocate memory for a Perl
interpreter. It's quite a simple function, and the guts of it looks
like this:
.PP
.Vb 1
\& my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
.Ve
.PP
Here you see an example of Perl's system abstraction, which we'll see
later: \f(CW\*(C`PerlMem_malloc\*(C'\fR is either your system's \f(CW\*(C`malloc\*(C'\fR, or Perl's
own \f(CW\*(C`malloc\*(C'\fR as defined in \fImalloc.c\fR if you selected that option at
configure time.
.PP
Next, in line 7, we construct the interpreter using perl_construct,
also in \fIperl.c\fR; this sets up all the special variables that Perl
needs, the stacks, and so on.
.PP
Now we pass Perl the command line options, and tell it to go:
.PP
.Vb 3
\& exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
\& if (!exitstatus)
\&     perl_run(my_perl);
\&
\& exitstatus = perl_destruct(my_perl);
\&
\& perl_free(my_perl);
.Ve
.PP
\&\f(CW\*(C`perl_parse\*(C'\fR is actually a wrapper around \f(CW\*(C`S_parse_body\*(C'\fR, as defined
in \fIperl.c\fR, which processes the command line options, sets up any
statically linked \s-1XS\s0 modules, opens the program and calls \f(CW\*(C`yyparse\*(C'\fR to
parse it.
.SS "Parsing"
.IX Subsection "Parsing"
The aim of this stage is to take the Perl source, and turn it into an
op tree. We'll see what one of those looks like later. Strictly
speaking, there's three things going on here.
.PP
\&\f(CW\*(C`yyparse\*(C'\fR, the parser, lives in \fIperly.c\fR, although you're better off
reading the original \s-1YACC\s0 input in \fIperly.y\fR. (Yes, Virginia, there
\&\fBis\fR a \s-1YACC\s0 grammar for Perl!) The job of the parser is to take your
code and \*(L"understand\*(R" it, splitting it into sentences, deciding which
operands go with which operators and so on.
.PP
The parser is nobly assisted by the lexer, which chunks up your input
into tokens, and decides what type of thing each token is: a variable
name, an operator, a bareword, a subroutine, a core function, and so
on. The main point of entry to the lexer is \f(CW\*(C`yylex\*(C'\fR, and that and its
associated routines can be found in \fItoke.c\fR. Perl isn't much like
other computer languages; it's highly context sensitive at times, it
can be tricky to work out what sort of token something is, or where a
token ends. As such, there's a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if you're not used to
it.
.PP
As the parser understands a Perl program, it builds up a tree of
operations for the interpreter to perform during execution. The
routines which construct and link together the various operations are
to be found in \fIop.c\fR, and will be examined later.
.SS "Optimization"
.IX Subsection "Optimization"
Now the parsing stage is complete, and the finished tree represents the
operations that the Perl interpreter needs to perform to execute our
program. Next, Perl does a dry run over the tree looking for
optimisations: constant expressions such as \f(CW\*(C`3 + 4\*(C'\fR will be computed
now, and the optimizer will also see if any multiple operations can be
replaced with a single one. For instance, to fetch the variable
\&\f(CW$foo\fR, instead of grabbing the glob \f(CW*foo\fR and looking at the scalar
component, the optimizer fiddles the op tree to use a function which
directly looks up the scalar in question. The main optimizer is \f(CW\*(C`peep\*(C'\fR
in \fIop.c\fR, and many ops have their own optimizing functions.
.SS "Running"
.IX Subsection "Running"
Now we're finally ready to go: we have compiled Perl byte code, and all
that's left to do is run it. The actual execution is done by the
\&\f(CW\*(C`runops_standard\*(C'\fR function in \fIrun.c\fR; more specifically, it's done
by these three innocent looking lines:
.PP
.Vb 3
\&    while ((PL_op = PL_op\->op_ppaddr(aTHX))) {
\&        PERL_ASYNC_CHECK();
\&    }
.Ve
.PP
You may be more comfortable with the Perl version of that:
.PP
.Vb 1
\&    PERL_ASYNC_CHECK() while $Perl::op = &{$Perl::op\->{function}};
.Ve
.PP
Well, maybe not. Anyway, each op contains a function pointer, which
stipulates the function which will actually carry out the operation.
This function will return the next op in the sequence \- this allows for
things like \f(CW\*(C`if\*(C'\fR which choose the next op dynamically at run time. The
\&\f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR makes sure that things like signals interrupt
execution if required.
.PP
The actual functions called are known as \s-1PP\s0 code, and they're spread
between four files: \fIpp_hot.c\fR contains the \*(L"hot\*(R" code, which is most
often used and highly optimized, \fIpp_sys.c\fR contains all the
system-specific functions, \fIpp_ctl.c\fR contains the functions which
implement control structures (\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR and the like) and \fIpp.c\fR
contains everything else. These are, if you like, the C code for Perl's
built-in functions and operators.
.PP
Note that each \f(CW\*(C`pp_\*(C'\fR function is expected to return a pointer to the
next op. Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume extra space on the C stack. For
example, \f(CW\*(C`pp_entersub\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR just push a \f(CW\*(C`CxSUB\*(C'\fR or
\&\f(CW\*(C`CxEVAL\*(C'\fR block struct onto the context stack which contain the address
of the op following the sub call or eval. They then return the first op
of that sub or eval block, and so execution continues of that sub or
block. Later, a \f(CW\*(C`pp_leavesub\*(C'\fR or \f(CW\*(C`pp_leavetry\*(C'\fR op pops the \f(CW\*(C`CxSUB\*(C'\fR
or \f(CW\*(C`CxEVAL\*(C'\fR, retrieves the return op from it, and returns it.
.SS "Exception handing"
.IX Subsection "Exception handing"
Perl's exception handing (i.e. \f(CW\*(C`die\*(C'\fR etc.) is built on top of the
low-level \f(CW\*(C`setjmp()\*(C'\fR/\f(CW\*(C`longjmp()\*(C'\fR C\-library functions. These basically
provide a way to capture the current \s-1PC\s0 and \s-1SP\s0 registers and later
restore them; i.e. a \f(CW\*(C`longjmp()\*(C'\fR continues at the point in code where
a previous \f(CW\*(C`setjmp()\*(C'\fR was done, with anything further up on the C
stack being lost. This is why code should always save values using
\&\f(CW\*(C`SAVE_FOO\*(C'\fR rather than in auto variables.
.PP
The perl core wraps \f(CW\*(C`setjmp()\*(C'\fR etc in the macros \f(CW\*(C`JMPENV_PUSH\*(C'\fR and
\&\f(CW\*(C`JMPENV_JUMP\*(C'\fR. The basic rule of perl exceptions is that \f(CW\*(C`exit\*(C'\fR, and
\&\f(CW\*(C`die\*(C'\fR (in the absence of \f(CW\*(C`eval\*(C'\fR) perform a \f(CWJMPENV_JUMP(2)\fR, while
\&\f(CW\*(C`die\*(C'\fR within \f(CW\*(C`eval\*(C'\fR does a \f(CWJMPENV_JUMP(3)\fR.
.PP
At entry points to perl, such as \f(CW\*(C`perl_parse()\*(C'\fR, \f(CW\*(C`perl_run()\*(C'\fR and
\&\f(CW\*(C`call_sv(cv, G_EVAL)\*(C'\fR each does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR, then enter a runops
loop or whatever, and handle possible exception returns. For a 2
return, final cleanup is performed, such as popping stacks and calling
\&\f(CW\*(C`CHECK\*(C'\fR or \f(CW\*(C`END\*(C'\fR blocks. Amongst other things, this is how scope
cleanup still occurs during an \f(CW\*(C`exit\*(C'\fR.
.PP
If a \f(CW\*(C`die\*(C'\fR can find a \f(CW\*(C`CxEVAL\*(C'\fR block on the context stack, then the
stack is popped to that level and the return op in that block is
assigned to \f(CW\*(C`PL_restartop\*(C'\fR; then a \f(CWJMPENV_JUMP(3)\fR is performed.
This normally passes control back to the guard. In the case of
\&\f(CW\*(C`perl_run\*(C'\fR and \f(CW\*(C`call_sv\*(C'\fR, a non-null \f(CW\*(C`PL_restartop\*(C'\fR triggers
re-entry to the runops loop. The is the normal way that \f(CW\*(C`die\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR is handled within an \f(CW\*(C`eval\*(C'\fR.
.PP
Sometimes ops are executed within an inner runops loop, such as tie,
sort or overload code. In this case, something like
.PP
.Vb 1
\&    sub FETCH { eval { die } }
.Ve
.PP
would cause a longjmp right back to the guard in \f(CW\*(C`perl_run\*(C'\fR, popping
both runops loops, which is clearly incorrect. One way to avoid this is
for the tie code to do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR before executing \f(CW\*(C`FETCH\*(C'\fR in
the inner runops loop, but for efficiency reasons, perl in fact just
sets a flag, using \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR. The \f(CW\*(C`pp_require\*(C'\fR,
\&\f(CW\*(C`pp_entereval\*(C'\fR and \f(CW\*(C`pp_entertry\*(C'\fR ops check this flag, and if true,
they call \f(CW\*(C`docatch\*(C'\fR, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a new
runops level to execute the code, rather than doing it on the current
loop.
.PP
As a further optimisation, on exit from the eval block in the \f(CW\*(C`FETCH\*(C'\fR,
execution of the code following the block is still carried on in the
inner loop. When an exception is raised, \f(CW\*(C`docatch\*(C'\fR compares the
\&\f(CW\*(C`JMPENV\*(C'\fR level of the \f(CW\*(C`CxEVAL\*(C'\fR with \f(CW\*(C`PL_top_env\*(C'\fR and if they differ,
just re-throws the exception. In this way any inner loops get popped.
.PP
Here's an example.
.PP
.Vb 5
\&    1: eval { tie @a, \*(AqA\*(Aq };
\&    2: sub A::TIEARRAY {
\&    3:     eval { die };
\&    4:     die;
\&    5: }
.Ve
.PP
To run this code, \f(CW\*(C`perl_run\*(C'\fR is called, which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR
then enters a runops loop. This loop executes the eval and tie ops on
line 1, with the eval pushing a \f(CW\*(C`CxEVAL\*(C'\fR onto the context stack.
.PP
The \f(CW\*(C`pp_tie\*(C'\fR does a \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR, then starts a second runops
loop to execute the body of \f(CW\*(C`TIEARRAY\*(C'\fR. When it executes the entertry
op on line 3, \f(CW\*(C`CATCH_GET\*(C'\fR is true, so \f(CW\*(C`pp_entertry\*(C'\fR calls \f(CW\*(C`docatch\*(C'\fR
which does a \f(CW\*(C`JMPENV_PUSH\*(C'\fR and starts a third runops loop, which then
executes the die op. At this point the C call stack looks like this:
.PP
.Vb 10
\&    Perl_pp_die
\&    Perl_runops      # third loop
\&    S_docatch_body
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
and the context and data stacks, as shown by \f(CW\*(C`\-Dstv\*(C'\fR, look like:
.PP
.Vb 9
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
\&      CX 1: EVAL   => *
\&    retop=nextstate
.Ve
.PP
The die pops the first \f(CW\*(C`CxEVAL\*(C'\fR off the context stack, sets
\&\f(CW\*(C`PL_restartop\*(C'\fR from it, does a \f(CWJMPENV_JUMP(3)\fR, and control returns
to the top \f(CW\*(C`docatch\*(C'\fR. This then starts another third-level runops
level, which executes the nextstate, pushmark and die ops on line 4. At
the point that the second \f(CW\*(C`pp_die\*(C'\fR is called, the C call stack looks
exactly like that above, even though we are no longer within an inner
eval; this is because of the optimization mentioned earlier. However,
the context stack now looks like this, ie with the top CxEVAL popped:
.PP
.Vb 7
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
.Ve
.PP
The die on line 4 pops the context stack back down to the CxEVAL,
leaving it as:
.PP
.Vb 2
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
.Ve
.PP
As usual, \f(CW\*(C`PL_restartop\*(C'\fR is extracted from the \f(CW\*(C`CxEVAL\*(C'\fR, and a
\&\f(CWJMPENV_JUMP(3)\fR done, which pops the C stack back to the docatch:
.PP
.Vb 10
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
In  this case, because the \f(CW\*(C`JMPENV\*(C'\fR level recorded in the \f(CW\*(C`CxEVAL\*(C'\fR
differs from the current one, \f(CW\*(C`docatch\*(C'\fR just does a \f(CWJMPENV_JUMP(3)\fR
and the C stack unwinds to:
.PP
.Vb 2
\&    perl_run
\&    main
.Ve
.PP
Because \f(CW\*(C`PL_restartop\*(C'\fR is non-null, \f(CW\*(C`run_body\*(C'\fR starts a new runops
loop and execution continues.
.SS "\s-1INTERNAL VARIABLE TYPES\s0"
.IX Subsection "INTERNAL VARIABLE TYPES"
You should by now have had a look at perlguts, which tells you about
Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
that now.
.PP
These variables are used not only to represent Perl-space variables,
but also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance, is an
ordinary Perl hash. Your code is represented by an \s-1SV\s0 as it's read into
the parser; any program files you call are opened via ordinary Perl
filehandles, and so on.
.PP
The core Devel::Peek module lets us examine SVs from a
Perl program. Let's see, for instance, how Perl treats the constant
\&\f(CW"hello"\fR.
.PP
.Vb 7
\&      % perl \-MDevel::Peek \-e \*(AqDump("hello")\*(Aq
\&    1 SV = PV(0xa041450) at 0xa04ecbc
\&    2   REFCNT = 1
\&    3   FLAGS = (POK,READONLY,pPOK)
\&    4   PV = 0xa0484e0 "hello"\e0
\&    5   CUR = 5
\&    6   LEN = 6
.Ve
.PP
Reading \f(CW\*(C`Devel::Peek\*(C'\fR output takes a bit of practise, so let's go
through it line by line.
.PP
Line 1 tells us we're looking at an \s-1SV\s0 which lives at \f(CW0xa04ecbc\fR in
memory. SVs themselves are very simple structures, but they contain a
pointer to a more complex structure. In this case, it's a \s-1PV,\s0 a
structure which holds a string value, at location \f(CW0xa041450\fR. Line 2
is the reference count; there are no other references to this data, so
it's 1.
.PP
Line 3 are the flags for this \s-1SV \-\s0 it's \s-1OK\s0 to use it as a \s-1PV,\s0 it's a
read-only \s-1SV \s0(because it's a constant) and the data is a \s-1PV\s0 internally.
Next we've got the contents of the string, starting at location
\&\f(CW0xa0484e0\fR.
.PP
Line 5 gives us the current length of the string \- note that this does
\&\fBnot\fR include the null terminator. Line 6 is not the length of the
string, but the length of the currently allocated buffer; as the string
grows, Perl automatically extends the available storage via a routine
called \f(CW\*(C`SvGROW\*(C'\fR.
.PP
You can get at any of these quantities from C very easily; just add
\&\f(CW\*(C`Sv\*(C'\fR to the name of the field shown in the snippet, and you've got a
macro which will return the value: \f(CW\*(C`SvCUR(sv)\*(C'\fR returns the current
length of the string, \f(CW\*(C`SvREFCOUNT(sv)\*(C'\fR returns the reference count,
\&\f(CW\*(C`SvPV(sv, len)\*(C'\fR returns the string itself with its length, and so on.
More macros to manipulate these properties can be found in perlguts.
.PP
Let's take an example of manipulating a \s-1PV,\s0 from \f(CW\*(C`sv_catpvn\*(C'\fR, in
\&\fIsv.c\fR
.PP
.Vb 5
\&     1  void
\&     2  Perl_sv_catpvn(pTHX_ SV *sv, const char *ptr, STRLEN len)
\&     3  {
\&     4      STRLEN tlen;
\&     5      char *junk;
\&
\&     6      junk = SvPV_force(sv, tlen);
\&     7      SvGROW(sv, tlen + len + 1);
\&     8      if (ptr == junk)
\&     9          ptr = SvPVX(sv);
\&    10      Move(ptr,SvPVX(sv)+tlen,len,char);
\&    11      SvCUR(sv) += len;
\&    12      *SvEND(sv) = \*(Aq\e0\*(Aq;
\&    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
\&    14      SvTAINT(sv);
\&    15  }
.Ve
.PP
This is a function which adds a string, \f(CW\*(C`ptr\*(C'\fR, of length \f(CW\*(C`len\*(C'\fR onto
the end of the \s-1PV\s0 stored in \f(CW\*(C`sv\*(C'\fR. The first thing we do in line 6 is
make sure that the \s-1SV \s0\fBhas\fR a valid \s-1PV,\s0 by calling the \f(CW\*(C`SvPV_force\*(C'\fR
macro to force a \s-1PV.\s0 As a side effect, \f(CW\*(C`tlen\*(C'\fR gets set to the current
value of the \s-1PV,\s0 and the \s-1PV\s0 itself is returned to \f(CW\*(C`junk\*(C'\fR.
.PP
In line 7, we make sure that the \s-1SV\s0 will have enough room to
accommodate the old string, the new string and the null terminator. If
\&\f(CW\*(C`LEN\*(C'\fR isn't big enough, \f(CW\*(C`SvGROW\*(C'\fR will reallocate space for us.
.PP
Now, if \f(CW\*(C`junk\*(C'\fR is the same as the string we're trying to add, we can
grab the string directly from the \s-1SV\s0; \f(CW\*(C`SvPVX\*(C'\fR is the address of the \s-1PV\s0
in the \s-1SV.\s0
.PP
Line 10 does the actual catenation: the \f(CW\*(C`Move\*(C'\fR macro moves a chunk of
memory around: we move the string \f(CW\*(C`ptr\*(C'\fR to the end of the \s-1PV \-\s0 that's
the start of the \s-1PV\s0 plus its current length. We're moving \f(CW\*(C`len\*(C'\fR bytes
of type \f(CW\*(C`char\*(C'\fR. After doing so, we need to tell Perl we've extended
the string, by altering \f(CW\*(C`CUR\*(C'\fR to reflect the new length. \f(CW\*(C`SvEND\*(C'\fR is a
macro which gives us the end of the string, so that needs to be a
\&\f(CW"\e0"\fR.
.PP
Line 13 manipulates the flags; since we've changed the \s-1PV,\s0 any \s-1IV\s0 or \s-1NV\s0
values will no longer be valid: if we have \f(CW\*(C`$a=10; $a.="6";\*(C'\fR we don't
want to use the old \s-1IV\s0 of 10. \f(CW\*(C`SvPOK_only_utf8\*(C'\fR is a special
UTF\-8\-aware version of \f(CW\*(C`SvPOK_only\*(C'\fR, a macro which turns off the \s-1IOK\s0
and \s-1NOK\s0 flags and turns on \s-1POK.\s0 The final \f(CW\*(C`SvTAINT\*(C'\fR is a macro which
launders tainted data if taint mode is turned on.
.PP
AVs and HVs are more complicated, but SVs are by far the most common
variable type being thrown around. Having seen something of how we
manipulate these, let's go on and look at how the op tree is
constructed.
.SH "OP TREES"
.IX Header "OP TREES"
First, what is the op tree, anyway? The op tree is the parsed
representation of your program, as we saw in our section on parsing,
and it's the sequence of operations that Perl goes through to execute
your program, as we saw in \*(L"Running\*(R".
.PP
An op is a fundamental operation that Perl can perform: all the
built-in functions and operators are ops, and there are a series of ops
which deal with concepts the interpreter needs internally \- entering
and leaving a block, ending a statement, fetching a variable, and so
on.
.PP
The op tree is connected in two ways: you can imagine that there are
two \*(L"routes\*(R" through it, two orders in which you can traverse the tree.
First, parse order reflects how the parser understood the code, and
secondly, execution order tells perl what order to perform the
operations in.
.PP
The easiest way to examine the op tree is to stop Perl after it has
finished parsing, and get it to dump out the tree. This is exactly what
the compiler backends B::Terse, B::Concise
and B::Debug do.
.PP
Let's have a look at how Perl sees \f(CW\*(C`$a = $b + $c\*(C'\fR:
.PP
.Vb 12
\&     % perl \-MO=Terse \-e \*(Aq$a=$b+$c\*(Aq
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
\&     4      BINOP (0x8179828) sassign
\&     5          BINOP (0x8179800) add [1]
\&     6              UNOP (0x81796e0) null [15]
\&     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
\&     8              UNOP (0x81797e0) null [15]
\&     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
\&    10          UNOP (0x816b4f0) null [15]
\&    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a
.Ve
.PP
Let's start in the middle, at line 4. This is a \s-1BINOP,\s0 a binary
operator, which is at location \f(CW0x8179828\fR. The specific operator in
question is \f(CW\*(C`sassign\*(C'\fR \- scalar assignment \- and you can find the code
which implements it in the function \f(CW\*(C`pp_sassign\*(C'\fR in \fIpp_hot.c\fR. As a
binary operator, it has two children: the add operator, providing the
result of \f(CW\*(C`$b+$c\*(C'\fR, is uppermost on line 5, and the left hand side is
on line 10.
.PP
Line 10 is the null op: this does exactly nothing. What is that doing
there? If you see the null op, it's a sign that something has been
optimized away after parsing. As we mentioned in \*(L"Optimization\*(R", the
optimization stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens, instead of
rewriting the op tree and cleaning up the dangling pointers, it's
easier just to replace the redundant operation with the null op.
Originally, the tree would have looked like this:
.PP
.Vb 2
\&    10          SVOP (0x816b4f0) rv2sv [15]
\&    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a
.Ve
.PP
That is, fetch the \f(CW\*(C`a\*(C'\fR entry from the main symbol table, and then look
at the scalar component of it: \f(CW\*(C`gvsv\*(C'\fR (\f(CW\*(C`pp_gvsv\*(C'\fR into \fIpp_hot.c\fR)
happens to do both these things.
.PP
The right hand side, starting at line 5 is similar to what we've just
seen: we have the \f(CW\*(C`add\*(C'\fR op (\f(CW\*(C`pp_add\*(C'\fR also in \fIpp_hot.c\fR) add
together two \f(CW\*(C`gvsv\*(C'\fRs.
.PP
Now, what's this about?
.PP
.Vb 3
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
.Ve
.PP
\&\f(CW\*(C`enter\*(C'\fR and \f(CW\*(C`leave\*(C'\fR are scoping ops, and their job is to perform any
housekeeping every time you enter and leave a block: lexical variables
are tidied up, unreferenced variables are destroyed, and so on. Every
program will have those first three lines: \f(CW\*(C`leave\*(C'\fR is a list, and its
children are all the statements in the block. Statements are delimited
by \f(CW\*(C`nextstate\*(C'\fR, so a block is a collection of \f(CW\*(C`nextstate\*(C'\fR ops, with
the ops to be performed for each statement being the children of
\&\f(CW\*(C`nextstate\*(C'\fR. \f(CW\*(C`enter\*(C'\fR is a single op which functions as a marker.
.PP
That's how Perl parsed the program, from top to bottom:
.PP
.Vb 10
\&                        Program
\&                           |
\&                       Statement
\&                           |
\&                           =
\&                          / \e
\&                         /   \e
\&                        $a   +
\&                            / \e
\&                          $b   $c
.Ve
.PP
However, it's impossible to \fBperform\fR the operations in this order:
you have to find the values of \f(CW$b\fR and \f(CW$c\fR before you add them
together, for instance. So, the other thread that runs through the op
tree is the execution order: each op has a field \f(CW\*(C`op_next\*(C'\fR which
points to the next op to be run, so following these pointers tells us
how perl executes the code. We can traverse the tree in this order
using the \f(CW\*(C`exec\*(C'\fR option to \f(CW\*(C`B::Terse\*(C'\fR:
.PP
.Vb 9
\&     % perl \-MO=Terse,exec \-e \*(Aq$a=$b+$c\*(Aq
\&     1  OP (0x8179928) enter
\&     2  COP (0x81798c8) nextstate
\&     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
\&     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
\&     5  BINOP (0x8179878) add [1]
\&     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
\&     7  BINOP (0x81798a0) sassign
\&     8  LISTOP (0x8179900) leave
.Ve
.PP
This probably makes more sense for a human: enter a block, start a
statement. Get the values of \f(CW$b\fR and \f(CW$c\fR, and add them together.
Find \f(CW$a\fR, and assign one to the other. Then leave.
.PP
The way Perl builds up these op trees in the parsing process can be
unravelled by examining \fIperly.y\fR, the \s-1YACC\s0 grammar. Let's take the
piece we need to construct the tree for \f(CW\*(C`$a = $b + $c\*(C'\fR
.PP
.Vb 4
\&    1 term    :   term ASSIGNOP term
\&    2                { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
\&    3         |   term ADDOP term
\&    4                { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
If you're not used to reading \s-1BNF\s0 grammars, this is how it works:
You're fed certain things by the tokeniser, which generally end up in
upper case. Here, \f(CW\*(C`ADDOP\*(C'\fR, is provided when the tokeniser sees \f(CW\*(C`+\*(C'\fR in
your code. \f(CW\*(C`ASSIGNOP\*(C'\fR is provided when \f(CW\*(C`=\*(C'\fR is used for assigning.
These are \*(L"terminal symbols\*(R", because you can't get any simpler than
them.
.PP
The grammar, lines one and three of the snippet above, tells you how to
build up more complex forms. These complex forms, \*(L"non-terminal
symbols\*(R" are generally placed in lower case. \f(CW\*(C`term\*(C'\fR here is a
non-terminal symbol, representing a single expression.
.PP
The grammar gives you the following rule: you can make the thing on the
left of the colon if you see all the things on the right in sequence.
This is called a \*(L"reduction\*(R", and the aim of parsing is to completely
reduce the input. There are several different ways you can perform a
reduction, separated by vertical bars: so, \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`=\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR makes a \f(CW\*(C`term\*(C'\fR, and \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`+\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR can also make a \f(CW\*(C`term\*(C'\fR.
.PP
So, if you see two terms with an \f(CW\*(C`=\*(C'\fR or \f(CW\*(C`+\*(C'\fR, between them, you can
turn them into a single expression. When you do this, you execute the
code in the block on the next line: if you see \f(CW\*(C`=\*(C'\fR, you'll do the code
in line 2. If you see \f(CW\*(C`+\*(C'\fR, you'll do the code in line 4. It's this
code which contributes to the op tree.
.PP
.Vb 2
\&            |   term ADDOP term
\&            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
What this does is creates a new binary op, and feeds it a number of
variables. The variables refer to the tokens: \f(CW$1\fR is the first token
in the input, \f(CW$2\fR the second, and so on \- think regular expression
backreferences. \f(CW$$\fR is the op returned from this reduction. So, we
call \f(CW\*(C`newBINOP\*(C'\fR to create a new binary operator. The first parameter
to \f(CW\*(C`newBINOP\*(C'\fR, a function in \fIop.c\fR, is the op type. It's an addition
operator, so we want the type to be \f(CW\*(C`ADDOP\*(C'\fR. We could specify this
directly, but it's right there as the second token in the input, so we
use \f(CW$2\fR. The second parameter is the op's flags: 0 means \*(L"nothing
special\*(R". Then the things to add: the left and right hand side of our
expression, in scalar context.
.SH "STACKS"
.IX Header "STACKS"
When perl executes something like \f(CW\*(C`addop\*(C'\fR, how does it pass on its
results to the next op? The answer is, through the use of stacks. Perl
has a number of stacks to store things it's currently working on, and
we'll look at the three most important ones here.
.SS "Argument stack"
.IX Subsection "Argument stack"
Arguments are passed to \s-1PP\s0 code and returned from \s-1PP\s0 code using the
argument stack, \f(CW\*(C`ST\*(C'\fR. The typical way to handle arguments is to pop
them off the stack, deal with them how you wish, and then push the
result back onto the stack. This is how, for instance, the cosine
operator works:
.PP
.Vb 4
\&      NV value;
\&      value = POPn;
\&      value = Perl_cos(value);
\&      XPUSHn(value);
.Ve
.PP
We'll see a more tricky example of this when we consider Perl's macros
below. \f(CW\*(C`POPn\*(C'\fR gives you the \s-1NV \s0(floating point value) of the top \s-1SV\s0 on
the stack: the \f(CW$x\fR in \f(CW\*(C`cos($x)\*(C'\fR. Then we compute the cosine, and
push the result back as an \s-1NV.\s0 The \f(CW\*(C`X\*(C'\fR in \f(CW\*(C`XPUSHn\*(C'\fR means that the
stack should be extended if necessary \- it can't be necessary here,
because we know there's room for one more item on the stack, since
we've just removed one! The \f(CW\*(C`XPUSH*\*(C'\fR macros at least guarantee safety.
.PP
Alternatively, you can fiddle with the stack directly: \f(CW\*(C`SP\*(C'\fR gives you
the first element in your portion of the stack, and \f(CW\*(C`TOP*\*(C'\fR gives you
the top SV/IV/NV/etc. on the stack. So, for instance, to do unary
negation of an integer:
.PP
.Vb 1
\&     SETi(\-TOPi);
.Ve
.PP
Just set the integer value of the top stack entry to its negation.
.PP
Argument stack manipulation in the core is exactly the same as it is in
XSUBs \- see perlxstut, perlxs and perlguts for a longer
description of the macros used in stack manipulation.
.SS "Mark stack"
.IX Subsection "Mark stack"
I say \*(L"your portion of the stack\*(R" above because \s-1PP\s0 code doesn't
necessarily get the whole stack to itself: if your function calls
another function, you'll only want to expose the arguments aimed for
the called function, and not (necessarily) let it get at your own data.
The way we do this is to have a \*(L"virtual\*(R" bottom-of-stack, exposed to
each function. The mark stack keeps bookmarks to locations in the
argument stack usable by each function. For instance, when dealing with
a tied variable, (internally, something with \*(L"P\*(R" magic) Perl has to
call methods for accesses to the tied variables. However, we need to
separate the arguments exposed to the method to the argument exposed to
the original function \- the store or fetch or whatever it may be.
Here's roughly how the tied \f(CW\*(C`push\*(C'\fR is implemented; see \f(CW\*(C`av_push\*(C'\fR in
\&\fIav.c\fR:
.PP
.Vb 8
\&     1  PUSHMARK(SP);
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
\&     5  PUTBACK;
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
Let's examine the whole implementation, for practice:
.PP
.Vb 1
\&     1  PUSHMARK(SP);
.Ve
.PP
Push the current state of the stack pointer onto the mark stack. This
is so that when we've finished adding items to the argument stack, Perl
knows how many things we've added recently.
.PP
.Vb 3
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
.Ve
.PP
We're going to add two more items onto the argument stack: when you
have a tied array, the \f(CW\*(C`PUSH\*(C'\fR subroutine receives the object and the
value to be pushed, and that's exactly what we have here \- the tied
object, retrieved with \f(CW\*(C`SvTIED_obj\*(C'\fR, and the value, the \s-1SV \s0\f(CW\*(C`val\*(C'\fR.
.PP
.Vb 1
\&     5  PUTBACK;
.Ve
.PP
Next we tell Perl to update the global stack pointer from our internal
variable: \f(CW\*(C`dSP\*(C'\fR only gave us a local copy, not a reference to the
global.
.PP
.Vb 3
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
\&\f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR localise a block of code \- they make sure that
all variables are tidied up, everything that has been localised gets
its previous value returned, and so on. Think of them as the \f(CW\*(C`{\*(C'\fR and
\&\f(CW\*(C`}\*(C'\fR of a Perl block.
.PP
To actually do the magic method call, we have to call a subroutine in
Perl space: \f(CW\*(C`call_method\*(C'\fR takes care of that, and it's described in
perlcall. We call the \f(CW\*(C`PUSH\*(C'\fR method in scalar context, and we're
going to discard its return value. The \fIcall_method()\fR function removes
the top element of the mark stack, so there is nothing for the caller
to clean up.
.SS "Save stack"
.IX Subsection "Save stack"
C doesn't have a concept of local scope, so perl provides one. We've
seen that \f(CW\*(C`ENTER\*(C'\fR and \f(CW\*(C`LEAVE\*(C'\fR are used as scoping braces; the save
stack implements the C equivalent of, for example:
.PP
.Vb 4
\&    {
\&        local $foo = 42;
\&        ...
\&    }
.Ve
.PP
See \*(L"Localizing changes\*(R" in perlguts for how to use the save stack.
.SH "MILLIONS OF MACROS"
.IX Header "MILLIONS OF MACROS"
One thing you'll notice about the Perl source is that it's full of
macros. Some have called the pervasive use of macros the hardest thing
to understand, others find it adds to clarity. Let's take an example,
the code which implements the addition operator:
.PP
.Vb 9
\&   1  PP(pp_add)
\&   2  {
\&   3      dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
\&   4      {
\&   5        dPOPTOPnnrl_ul;
\&   6        SETn( left + right );
\&   7        RETURN;
\&   8      }
\&   9  }
.Ve
.PP
Every line here (apart from the braces, of course) contains a macro.
The first line sets up the function declaration as Perl expects for \s-1PP\s0
code; line 3 sets up variable declarations for the argument stack and
the target, the return value of the operation. Finally, it tries to see
if the addition operation is overloaded; if so, the appropriate
subroutine is called.
.PP
Line 5 is another variable declaration \- all variable declarations
start with \f(CW\*(C`d\*(C'\fR \- which pops from the top of the argument stack two NVs
(hence \f(CW\*(C`nn\*(C'\fR) and puts them into the variables \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR,
hence the \f(CW\*(C`rl\*(C'\fR. These are the two operands to the addition operator.
Next, we call \f(CW\*(C`SETn\*(C'\fR to set the \s-1NV\s0 of the return value to the result
of adding the two values. This done, we return \- the \f(CW\*(C`RETURN\*(C'\fR macro
makes sure that our return value is properly handled, and we pass the
next operator to run back to the main run loop.
.PP
Most of these macros are explained in perlapi, and some of the more
important ones are explained in perlxs as well. Pay special
attention to \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 in perlguts for
information on the \f(CW\*(C`[pad]THX_?\*(C'\fR macros.
.SH "FURTHER READING"
.IX Header "FURTHER READING"
For more information on the Perl internals, please see the documents
listed at \*(L"Internals and C Language Interface\*(R" in perl.
                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlintro.1                                  0100644 0001750 0001750 00000071364 12566207441 022770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTRO 1"
.TH PERLINTRO 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintro \-\- a brief introduction and overview of Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is intended to give you a quick overview of the Perl
programming language, along with pointers to further documentation.  It
is intended as a \*(L"bootstrap\*(R" guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.
.PP
This introductory document does not aim to be complete.  It does not
even aim to be entirely accurate.  In some cases perfection has been
sacrificed in the goal of getting the general idea across.  You are
\&\fIstrongly\fR advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in perltoc.
.PP
Throughout this document you'll see references to other parts of the
Perl documentation.  You can read that documentation using the \f(CW\*(C`perldoc\*(C'\fR
command or whatever method you're using to read this document.
.PP
Throughout Perl's documentation, you'll find numerous examples intended
to help explain the discussed features.  Please keep in mind that many
of them are code fragments rather than complete programs.
.PP
These examples often reflect the style and preference of the author of
that piece of the documentation, and may be briefer than a corresponding
line of code in a real program.  Except where otherwise noted, you
should assume that \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR statements
appear earlier in the \*(L"program\*(R", and that any variables used have
already been declared, even if those declarations have been omitted
to make the example easier to read.
.PP
Do note that the examples have been written by many different authors over
a period of several decades.  Styles and techniques will therefore differ,
although some effort has been made to not vary styles too widely in the
same sections.  Do not consider one style to be better than others \- \*(L"There's
More Than One Way To Do It\*(R" is one of Perl's mottos.  After all, in your
journey as a programmer, you are likely to encounter different styles.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a general-purpose programming language originally developed for
text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, \s-1GUI\s0
development, and more.
.PP
The language is intended to be practical (easy to use, efficient,
complete) rather than beautiful (tiny, elegant, minimal).  Its major
features are that it's easy to use, supports both procedural and
object-oriented (\s-1OO\s0) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.
.PP
Different definitions of Perl are given in perl, perlfaq1 and
no doubt other places.  From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.
.SS "Running Perl programs"
.IX Subsection "Running Perl programs"
To run a Perl program from the Unix command line:
.PP
.Vb 1
\& perl progname.pl
.Ve
.PP
Alternatively, put this as the first line of your script:
.PP
.Vb 1
\& #!/usr/bin/env perl
.Ve
.PP
\&... and run the script as \fI/path/to/script.pl\fR.  Of course, it'll need
to be executable first, so \f(CW\*(C`chmod 755 script.pl\*(C'\fR (under Unix).
.PP
(This start line assumes you have the \fBenv\fR program.  You can also put
directly the path to your perl executable, like in \f(CW\*(C`#!/usr/bin/perl\*(C'\fR).
.PP
For more information, including instructions for other platforms such as
Windows and Mac \s-1OS,\s0 read perlrun.
.SS "Safety net"
.IX Subsection "Safety net"
Perl by default is very forgiving.  In order to make it more robust
it is recommended to start every program with the following lines:
.PP
.Vb 3
\& #!/usr/bin/perl
\& use strict;
\& use warnings;
.Ve
.PP
The two additional lines request from perl to catch various common
problems in your code.  They check different things so you need both.  A
potential problem caught by \f(CW\*(C`use strict;\*(C'\fR will cause your code to stop
immediately when it is encountered, while \f(CW\*(C`use warnings;\*(C'\fR will merely
give a warning (like the command-line switch \fB\-w\fR) and let your code run.
To read more about them check their respective manual pages at strict
and warnings.
.SS "Basic syntax overview"
.IX Subsection "Basic syntax overview"
A Perl script or program consists of one or more statements.  These
statements are simply written in the script in a straightforward
fashion.  There is no need to have a \f(CW\*(C`main()\*(C'\fR function or anything of
that kind.
.PP
Perl statements end in a semi-colon:
.PP
.Vb 1
\& print "Hello, world";
.Ve
.PP
Comments start with a hash symbol and run to the end of the line
.PP
.Vb 1
\& # This is a comment
.Ve
.PP
Whitespace is irrelevant:
.PP
.Vb 3
\& print
\&     "Hello, world"
\&     ;
.Ve
.PP
\&... except inside quoted strings:
.PP
.Vb 3
\& # this would print with a linebreak in the middle
\& print "Hello
\& world";
.Ve
.PP
Double quotes or single quotes may be used around literal strings:
.PP
.Vb 2
\& print "Hello, world";
\& print \*(AqHello, world\*(Aq;
.Ve
.PP
However, only double quotes \*(L"interpolate\*(R" variables and special
characters such as newlines (\f(CW\*(C`\en\*(C'\fR):
.PP
.Vb 2
\& print "Hello, $name\en";     # works fine
\& print \*(AqHello, $name\en\*(Aq;     # prints $name\en literally
.Ve
.PP
Numbers don't need quotes around them:
.PP
.Vb 1
\& print 42;
.Ve
.PP
You can use parentheses for functions' arguments or omit them
according to your personal taste.  They are only required
occasionally to clarify issues of precedence.
.PP
.Vb 2
\& print("Hello, world\en");
\& print "Hello, world\en";
.Ve
.PP
More detailed information about Perl syntax can be found in perlsyn.
.SS "Perl variable types"
.IX Subsection "Perl variable types"
Perl has three main variable types: scalars, arrays, and hashes.
.IP "Scalars" 4
.IX Item "Scalars"
A scalar represents a single value:
.Sp
.Vb 2
\& my $animal = "camel";
\& my $answer = 42;
.Ve
.Sp
Scalar values can be strings, integers or floating point numbers, and Perl
will automatically convert between them as required.  There is no need
to pre-declare your variable types, but you have to declare them using
the \f(CW\*(C`my\*(C'\fR keyword the first time you use them.  (This is one of the
requirements of \f(CW\*(C`use strict;\*(C'\fR.)
.Sp
Scalar values can be used in various ways:
.Sp
.Vb 3
\& print $animal;
\& print "The animal is $animal\en";
\& print "The square of $answer is ", $answer * $answer, "\en";
.Ve
.Sp
There are a number of \*(L"magic\*(R" scalars with names that look like
punctuation or line noise.  These special variables are used for all
kinds of purposes, and are documented in perlvar.  The only one you
need to know about for now is \f(CW$_\fR which is the \*(L"default variable\*(R".
It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.
.Sp
.Vb 1
\& print;          # prints contents of $_ by default
.Ve
.IP "Arrays" 4
.IX Item "Arrays"
An array represents a list of values:
.Sp
.Vb 3
\& my @animals = ("camel", "llama", "owl");
\& my @numbers = (23, 42, 69);
\& my @mixed   = ("camel", 42, 1.23);
.Ve
.Sp
Arrays are zero-indexed.  Here's how you get at elements in an array:
.Sp
.Vb 2
\& print $animals[0];              # prints "camel"
\& print $animals[1];              # prints "llama"
.Ve
.Sp
The special variable \f(CW$#array\fR tells you the index of the last element
of an array:
.Sp
.Vb 1
\& print $mixed[$#mixed];       # last element, prints 1.23
.Ve
.Sp
You might be tempted to use \f(CW\*(C`$#array + 1\*(C'\fR to tell you how many items there
are in an array.  Don't bother.  As it happens, using \f(CW@array\fR where Perl
expects to find a scalar value (\*(L"in scalar context\*(R") will give you the number
of elements in the array:
.Sp
.Vb 1
\& if (@animals < 5) { ... }
.Ve
.Sp
The elements we're getting from the array start with a \f(CW\*(C`$\*(C'\fR because
we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.
.Sp
To get multiple values from an array:
.Sp
.Vb 3
\& @animals[0,1];                 # gives ("camel", "llama");
\& @animals[0..2];                # gives ("camel", "llama", "owl");
\& @animals[1..$#animals];        # gives all except the first element
.Ve
.Sp
This is called an \*(L"array slice\*(R".
.Sp
You can do various useful things to lists:
.Sp
.Vb 2
\& my @sorted    = sort @animals;
\& my @backwards = reverse @numbers;
.Ve
.Sp
There are a couple of special arrays too, such as \f(CW@ARGV\fR (the command
line arguments to your script) and \f(CW@_\fR (the arguments passed to a
subroutine).  These are documented in perlvar.
.IP "Hashes" 4
.IX Item "Hashes"
A hash represents a set of key/value pairs:
.Sp
.Vb 1
\& my %fruit_color = ("apple", "red", "banana", "yellow");
.Ve
.Sp
You can use whitespace and the \f(CW\*(C`=>\*(C'\fR operator to lay them out more
nicely:
.Sp
.Vb 4
\& my %fruit_color = (
\&     apple  => "red",
\&     banana => "yellow",
\& );
.Ve
.Sp
To get at hash elements:
.Sp
.Vb 1
\& $fruit_color{"apple"};           # gives "red"
.Ve
.Sp
You can get at lists of keys and values with \f(CW\*(C`keys()\*(C'\fR and
\&\f(CW\*(C`values()\*(C'\fR.
.Sp
.Vb 2
\& my @fruits = keys %fruit_colors;
\& my @colors = values %fruit_colors;
.Ve
.Sp
Hashes have no particular internal order, though you can sort the keys
and loop through them.
.Sp
Just like special scalars and arrays, there are also special hashes.
The most well known of these is \f(CW%ENV\fR which contains environment
variables.  Read all about it (and other special variables) in
perlvar.
.PP
Scalars, arrays and hashes are documented more fully in perldata.
.PP
More complex data types can be constructed using references, which allow
you to build lists and hashes within lists and hashes.
.PP
A reference is a scalar value and can refer to any other Perl data
type.  So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes.  The following example shows a 2 level hash of hash
structure using anonymous hash references.
.PP
.Vb 10
\& my $variables = {
\&     scalar  =>  {
\&                  description => "single item",
\&                  sigil => \*(Aq$\*(Aq,
\&                 },
\&     array   =>  {
\&                  description => "ordered list of items",
\&                  sigil => \*(Aq@\*(Aq,
\&                 },
\&     hash    =>  {
\&                  description => "key/value pairs",
\&                  sigil => \*(Aq%\*(Aq,
\&                 },
\& };
\&
\& print "Scalars begin with a $variables\->{\*(Aqscalar\*(Aq}\->{\*(Aqsigil\*(Aq}\en";
.Ve
.PP
Exhaustive information on the topic of references can be found in
perlreftut, perllol, perlref and perldsc.
.SS "Variable scoping"
.IX Subsection "Variable scoping"
Throughout the previous section all the examples have used the syntax:
.PP
.Vb 1
\& my $var = "value";
.Ve
.PP
The \f(CW\*(C`my\*(C'\fR is actually not required; you could just use:
.PP
.Vb 1
\& $var = "value";
.Ve
.PP
However, the above usage will create global variables throughout your
program, which is bad programming practice.  \f(CW\*(C`my\*(C'\fR creates lexically
scoped variables instead.  The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.
.PP
.Vb 9
\& my $x = "foo";
\& my $some_condition = 1;
\& if ($some_condition) {
\&     my $y = "bar";
\&     print $x;           # prints "foo"
\&     print $y;           # prints "bar"
\& }
\& print $x;               # prints "foo"
\& print $y;               # prints nothing; $y has fallen out of scope
.Ve
.PP
Using \f(CW\*(C`my\*(C'\fR in combination with a \f(CW\*(C`use strict;\*(C'\fR at the top of
your Perl scripts means that the interpreter will pick up certain common
programming errors.  For instance, in the example above, the final
\&\f(CW\*(C`print $y\*(C'\fR would cause a compile-time error and prevent you from
running the program.  Using \f(CW\*(C`strict\*(C'\fR is highly recommended.
.SS "Conditional and looping constructs"
.IX Subsection "Conditional and looping constructs"
Perl has most of the usual conditional and looping constructs.  As of Perl
5.10, it even has a case/switch statement (spelled \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR).  See
\&\*(L"Switch Statements\*(R" in perlsyn for more details.
.PP
The conditions can be any Perl expression.  See the list of operators in
the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.
.IP "if" 4
.IX Item "if"
.Vb 7
\& if ( condition ) {
\&     ...
\& } elsif ( other condition ) {
\&     ...
\& } else {
\&     ...
\& }
.Ve
.Sp
There's also a negated version of it:
.Sp
.Vb 3
\& unless ( condition ) {
\&     ...
\& }
.Ve
.Sp
This is provided as a more readable version of \f(CW\*(C`if (!\f(CIcondition\f(CW)\*(C'\fR.
.Sp
Note that the braces are required in Perl, even if you've only got one
line in the block.  However, there is a clever way of making your one-line
conditional blocks more English like:
.Sp
.Vb 4
\& # the traditional way
\& if ($zippy) {
\&     print "Yow!";
\& }
\&
\& # the Perlish post\-condition way
\& print "Yow!" if $zippy;
\& print "We have no bananas" unless $bananas;
.Ve
.IP "while" 4
.IX Item "while"
.Vb 3
\& while ( condition ) {
\&     ...
\& }
.Ve
.Sp
There's also a negated version, for the same reason we have \f(CW\*(C`unless\*(C'\fR:
.Sp
.Vb 3
\& until ( condition ) {
\&     ...
\& }
.Ve
.Sp
You can also use \f(CW\*(C`while\*(C'\fR in a post-condition:
.Sp
.Vb 1
\& print "LA LA LA\en" while 1;          # loops forever
.Ve
.IP "for" 4
.IX Item "for"
Exactly like C:
.Sp
.Vb 3
\& for ($i = 0; $i <= $max; $i++) {
\&     ...
\& }
.Ve
.Sp
The C style for loop is rarely needed in Perl since Perl provides
the more friendly list scanning \f(CW\*(C`foreach\*(C'\fR loop.
.IP "foreach" 4
.IX Item "foreach"
.Vb 3
\& foreach (@array) {
\&     print "This element is $_\en";
\& }
\&
\& print $list[$_] foreach 0 .. $max;
\&
\& # you don\*(Aqt have to use the default $_ either...
\& foreach my $key (keys %hash) {
\&     print "The value of $key is $hash{$key}\en";
\& }
.Ve
.Sp
The \f(CW\*(C`foreach\*(C'\fR keyword is actually a synonym for the \f(CW\*(C`for\*(C'\fR
keyword.  See \f(CW\*(C`"Foreach Loops" in perlsyn\*(C'\fR.
.PP
For more detail on looping constructs (and some that weren't mentioned in
this overview) see perlsyn.
.SS "Builtin operators and functions"
.IX Subsection "Builtin operators and functions"
Perl comes with a wide selection of builtin functions.  Some of the ones
we've already seen include \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`sort\*(C'\fR and \f(CW\*(C`reverse\*(C'\fR.  A list of
them is given at the start of perlfunc and you can easily read
about any given function by using \f(CW\*(C`perldoc \-f \f(CIfunctionname\f(CW\*(C'\fR.
.PP
Perl operators are documented in full in perlop, but here are a few
of the most common ones:
.IP "Arithmetic" 4
.IX Item "Arithmetic"
.Vb 4
\& +   addition
\& \-   subtraction
\& *   multiplication
\& /   division
.Ve
.IP "Numeric comparison" 4
.IX Item "Numeric comparison"
.Vb 6
\& ==  equality
\& !=  inequality
\& <   less than
\& >   greater than
\& <=  less than or equal
\& >=  greater than or equal
.Ve
.IP "String comparison" 4
.IX Item "String comparison"
.Vb 6
\& eq  equality
\& ne  inequality
\& lt  less than
\& gt  greater than
\& le  less than or equal
\& ge  greater than or equal
.Ve
.Sp
(Why do we have separate numeric and string comparisons?  Because we don't
have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).
.IP "Boolean logic" 4
.IX Item "Boolean logic"
.Vb 3
\& &&  and
\& ||  or
\& !   not
.Ve
.Sp
(\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR aren't just in the above table as descriptions
of the operators.  They're also supported as operators in their own
right.  They're more readable than the C\-style operators, but have
different precedence to \f(CW\*(C`&&\*(C'\fR and friends.  Check perlop for more
detail.)
.IP "Miscellaneous" 4
.IX Item "Miscellaneous"
.Vb 4
\& =   assignment
\& .   string concatenation
\& x   string multiplication
\& ..  range operator (creates a list of numbers)
.Ve
.PP
Many operators can be combined with a \f(CW\*(C`=\*(C'\fR as follows:
.PP
.Vb 3
\& $a += 1;        # same as $a = $a + 1
\& $a \-= 1;        # same as $a = $a \- 1
\& $a .= "\en";     # same as $a = $a . "\en";
.Ve
.SS "Files and I/O"
.IX Subsection "Files and I/O"
You can open a file for input or output using the \f(CW\*(C`open()\*(C'\fR function.
It's documented in extravagant detail in perlfunc and perlopentut,
but in short:
.PP
.Vb 3
\& open(my $in,  "<",  "input.txt")  or die "Can\*(Aqt open input.txt: $!";
\& open(my $out, ">",  "output.txt") or die "Can\*(Aqt open output.txt: $!";
\& open(my $log, ">>", "my.log")     or die "Can\*(Aqt open my.log: $!";
.Ve
.PP
You can read from an open filehandle using the \f(CW\*(C`<>\*(C'\fR operator.  In
scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:
.PP
.Vb 2
\& my $line  = <$in>;
\& my @lines = <$in>;
.Ve
.PP
Reading in the whole file at one time is called slurping.  It can
be useful but it may be a memory hog.  Most text file processing
can be done a line at a time with Perl's looping constructs.
.PP
The \f(CW\*(C`<>\*(C'\fR operator is most often seen in a \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 3
\& while (<$in>) {     # assigns each line in turn to $_
\&     print "Just read in this line: $_";
\& }
.Ve
.PP
We've already seen how to print to standard output using \f(CW\*(C`print()\*(C'\fR.
However, \f(CW\*(C`print()\*(C'\fR can also take an optional first argument specifying
which filehandle to print to:
.PP
.Vb 3
\& print STDERR "This is your final warning.\en";
\& print $out $record;
\& print $log $logmessage;
.Ve
.PP
When you're done with your filehandles, you should \f(CW\*(C`close()\*(C'\fR them
(though to be honest, Perl will clean up after you if you forget):
.PP
.Vb 1
\& close $in or die "$in: $!";
.Ve
.SS "Regular expressions"
.IX Subsection "Regular expressions"
Perl's regular expression support is both broad and deep, and is the
subject of lengthy documentation in perlrequick, perlretut, and
elsewhere.  However, in short:
.IP "Simple matching" 4
.IX Item "Simple matching"
.Vb 2
\& if (/foo/)       { ... }  # true if $_ contains "foo"
\& if ($a =~ /foo/) { ... }  # true if $a contains "foo"
.Ve
.Sp
The \f(CW\*(C`//\*(C'\fR matching operator is documented in perlop.  It operates on
\&\f(CW$_\fR by default, or can be bound to another variable using the \f(CW\*(C`=~\*(C'\fR
binding operator (also documented in perlop).
.IP "Simple substitution" 4
.IX Item "Simple substitution"
.Vb 4
\& s/foo/bar/;               # replaces foo with bar in $_
\& $a =~ s/foo/bar/;         # replaces foo with bar in $a
\& $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar
\&                           # in $a
.Ve
.Sp
The \f(CW\*(C`s///\*(C'\fR substitution operator is documented in perlop.
.IP "More complex regular expressions" 4
.IX Item "More complex regular expressions"
You don't just have to match on fixed strings.  In fact, you can match
on just about anything you could dream of by using more complex regular
expressions.  These are documented at great length in perlre, but for
the meantime, here's a quick cheat sheet:
.Sp
.Vb 12
\& .                   a single character
\& \es                  a whitespace character (space, tab, newline,
\&                     ...)
\& \eS                  non\-whitespace character
\& \ed                  a digit (0\-9)
\& \eD                  a non\-digit
\& \ew                  a word character (a\-z, A\-Z, 0\-9, _)
\& \eW                  a non\-word character
\& [aeiou]             matches a single character in the given set
\& [^aeiou]            matches a single character outside the given
\&                     set
\& (foo|bar|baz)       matches any of the alternatives specified
\&
\& ^                   start of string
\& $                   end of string
.Ve
.Sp
Quantifiers can be used to specify how many of the previous thing you
want to match on, where \*(L"thing\*(R" means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.
.Sp
.Vb 6
\& *                   zero or more of the previous thing
\& +                   one or more of the previous thing
\& ?                   zero or one of the previous thing
\& {3}                 matches exactly 3 of the previous thing
\& {3,6}               matches between 3 and 6 of the previous thing
\& {3,}                matches 3 or more of the previous thing
.Ve
.Sp
Some brief examples:
.Sp
.Vb 7
\& /^\ed+/              string starts with one or more digits
\& /^$/                nothing in the string (start and end are
\&                     adjacent)
\& /(\ed\es){3}/         three digits, each followed by a whitespace
\&                     character (eg "3 4 5 ")
\& /(a.)+/             matches a string in which every odd\-numbered
\&                     letter is a (eg "abacadaf")
\&
\& # This loop reads from STDIN, and prints non\-blank lines:
\& while (<>) {
\&     next if /^$/;
\&     print;
\& }
.Ve
.IP "Parentheses for capturing" 4
.IX Item "Parentheses for capturing"
As well as grouping, parentheses serve a second purpose.  They can be
used to capture the results of parts of the regexp match for later use.
The results end up in \f(CW$1\fR, \f(CW$2\fR and so on.
.Sp
.Vb 1
\& # a cheap and nasty way to break an email address up into parts
\&
\& if ($email =~ /([^@]+)@(.+)/) {
\&     print "Username is $1\en";
\&     print "Hostname is $2\en";
\& }
.Ve
.IP "Other regexp features" 4
.IX Item "Other regexp features"
Perl regexps also support backreferences, lookaheads, and all kinds of
other complex details.  Read all about them in perlrequick,
perlretut, and perlre.
.SS "Writing subroutines"
.IX Subsection "Writing subroutines"
Writing subroutines is easy:
.PP
.Vb 5
\& sub logger {
\&    my $logmessage = shift;
\&    open my $logfile, ">>", "my.log" or die "Could not open my.log: $!";
\&    print $logfile $logmessage;
\& }
.Ve
.PP
Now we can use the subroutine just as any other built-in function:
.PP
.Vb 1
\& logger("We have a logger subroutine!");
.Ve
.PP
What's that \f(CW\*(C`shift\*(C'\fR?  Well, the arguments to a subroutine are available
to us as a special array called \f(CW@_\fR (see perlvar for more on that).
The default argument to the \f(CW\*(C`shift\*(C'\fR function just happens to be \f(CW@_\fR.
So \f(CW\*(C`my $logmessage = shift;\*(C'\fR shifts the first item off the list of
arguments and assigns it to \f(CW$logmessage\fR.
.PP
We can manipulate \f(CW@_\fR in other ways too:
.PP
.Vb 2
\& my ($logmessage, $priority) = @_;       # common
\& my $logmessage = $_[0];                 # uncommon, and ugly
.Ve
.PP
Subroutines can also return values:
.PP
.Vb 5
\& sub square {
\&     my $num = shift;
\&     my $result = $num * $num;
\&     return $result;
\& }
.Ve
.PP
Then use it like:
.PP
.Vb 1
\& $sq = square(8);
.Ve
.PP
For more information on writing subroutines, see perlsub.
.SS "\s-1OO\s0 Perl"
.IX Subsection "OO Perl"
\&\s-1OO\s0 Perl is relatively simple and is implemented using references which
know what sort of object they are based on Perl's concept of packages.
However, \s-1OO\s0 Perl is largely beyond the scope of this document.
Read perlootut and perlobj.
.PP
As a beginning Perl programmer, your most common use of \s-1OO\s0 Perl will be
in using third-party modules, which are documented below.
.SS "Using Perl modules"
.IX Subsection "Using Perl modules"
Perl modules provide a range of features to help you avoid reinventing
the wheel, and can be downloaded from \s-1CPAN \s0( http://www.cpan.org/ ).  A
number of popular modules are included with the Perl distribution
itself.
.PP
Categories of modules range from text manipulation to network protocols
to database integration to graphics.  A categorized list of modules is
also available from \s-1CPAN.\s0
.PP
To learn how to install modules you download from \s-1CPAN,\s0 read
perlmodinstall.
.PP
To learn how to use a particular module, use \f(CW\*(C`perldoc \f(CIModule::Name\f(CW\*(C'\fR.
Typically you will want to \f(CW\*(C`use \f(CIModule::Name\f(CW\*(C'\fR, which will then give
you access to exported functions or an \s-1OO\s0 interface to the module.
.PP
perlfaq contains questions and answers related to many common
tasks, and often provides suggestions for good \s-1CPAN\s0 modules to use.
.PP
perlmod describes Perl modules in general.  perlmodlib lists the
modules which came with your Perl installation.
.PP
If you feel the urge to write Perl modules, perlnewmod will give you
good advice.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirrily \*(L"Skud\*(R" Robert <skud@cpan.org>
                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlintro5.16.1                              0100644 0001750 0001750 00000072045 12566207421 023275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTRO 1"
.TH PERLINTRO 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintro \-\- a brief introduction and overview of Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is intended to give you a quick overview of the Perl
programming language, along with pointers to further documentation.  It
is intended as a \*(L"bootstrap\*(R" guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.
.PP
This introductory document does not aim to be complete.  It does not
even aim to be entirely accurate.  In some cases perfection has been
sacrificed in the goal of getting the general idea across.  You are
\&\fIstrongly\fR advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in perltoc.
.PP
Throughout this document you'll see references to other parts of the
Perl documentation.  You can read that documentation using the \f(CW\*(C`perldoc\*(C'\fR
command or whatever method you're using to read this document.
.PP
Throughout Perl's documentation, you'll find numerous examples intended
to help explain the discussed features.  Please keep in mind that many
of them are code fragments rather than complete programs.
.PP
These examples often reflect the style and preference of the author of
that piece of the documentation, and may be briefer than a corresponding
line of code in a real program.  Except where otherwise noted, you
should assume that \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR statements
appear earlier in the \*(L"program\*(R", and that any variables used have
already been declared, even if those declarations have been omitted
to make the example easier to read.
.PP
Do note that the examples have been written by many different authors over
a period of several decades.  Styles and techniques will therefore differ,
although some effort has been made to not vary styles too widely in the
same sections.  Do not consider one style to be better than others \- \*(L"There's
More Than One Way To Do It\*(R" is one of Perl's mottos.  After all, in your
journey as a programmer, you are likely to encounter different styles.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a general-purpose programming language originally developed for
text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, \s-1GUI\s0
development, and more.
.PP
The language is intended to be practical (easy to use, efficient,
complete) rather than beautiful (tiny, elegant, minimal).  Its major
features are that it's easy to use, supports both procedural and
object-oriented (\s-1OO\s0) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.
.PP
Different definitions of Perl are given in perl, perlfaq1 and
no doubt other places.  From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.
.SS "Running Perl programs"
.IX Subsection "Running Perl programs"
To run a Perl program from the Unix command line:
.PP
.Vb 1
\&    perl progname.pl
.Ve
.PP
Alternatively, put this as the first line of your script:
.PP
.Vb 1
\&    #!/usr/bin/env perl
.Ve
.PP
\&... and run the script as \f(CW\*(C`/path/to/script.pl\*(C'\fR.  Of course, it'll need
to be executable first, so \f(CW\*(C`chmod 755 script.pl\*(C'\fR (under Unix).
.PP
(This start line assumes you have the \fBenv\fR program.  You can also put
directly the path to your perl executable, like in \f(CW\*(C`#!/usr/bin/perl\*(C'\fR).
.PP
For more information, including instructions for other platforms such as
Windows and Mac \s-1OS\s0, read perlrun.
.SS "Safety net"
.IX Subsection "Safety net"
Perl by default is very forgiving.  In order to make it more robust
it is recommended to start every program with the following lines:
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.PP
The two additional lines request from perl to catch various common
problems in your code.  They check different things so you need both.  A
potential problem caught by \f(CW\*(C`use strict;\*(C'\fR will cause your code to stop
immediately when it is encountered, while \f(CW\*(C`use warnings;\*(C'\fR will merely
give a warning (like the command-line switch \fB\-w\fR) and let your code run.
To read more about them check their respective manual pages at strict
and warnings.
.SS "Basic syntax overview"
.IX Subsection "Basic syntax overview"
A Perl script or program consists of one or more statements.  These
statements are simply written in the script in a straightforward
fashion.  There is no need to have a \f(CW\*(C`main()\*(C'\fR function or anything of
that kind.
.PP
Perl statements end in a semi-colon:
.PP
.Vb 1
\&    print "Hello, world";
.Ve
.PP
Comments start with a hash symbol and run to the end of the line
.PP
.Vb 1
\&    # This is a comment
.Ve
.PP
Whitespace is irrelevant:
.PP
.Vb 3
\&    print
\&        "Hello, world"
\&        ;
.Ve
.PP
\&... except inside quoted strings:
.PP
.Vb 3
\&    # this would print with a linebreak in the middle
\&    print "Hello
\&    world";
.Ve
.PP
Double quotes or single quotes may be used around literal strings:
.PP
.Vb 2
\&    print "Hello, world";
\&    print \*(AqHello, world\*(Aq;
.Ve
.PP
However, only double quotes \*(L"interpolate\*(R" variables and special
characters such as newlines (\f(CW\*(C`\en\*(C'\fR):
.PP
.Vb 2
\&    print "Hello, $name\en";     # works fine
\&    print \*(AqHello, $name\en\*(Aq;     # prints $name\en literally
.Ve
.PP
Numbers don't need quotes around them:
.PP
.Vb 1
\&    print 42;
.Ve
.PP
You can use parentheses for functions' arguments or omit them
according to your personal taste.  They are only required
occasionally to clarify issues of precedence.
.PP
.Vb 2
\&    print("Hello, world\en");
\&    print "Hello, world\en";
.Ve
.PP
More detailed information about Perl syntax can be found in perlsyn.
.SS "Perl variable types"
.IX Subsection "Perl variable types"
Perl has three main variable types: scalars, arrays, and hashes.
.IP "Scalars" 4
.IX Item "Scalars"
A scalar represents a single value:
.Sp
.Vb 2
\&    my $animal = "camel";
\&    my $answer = 42;
.Ve
.Sp
Scalar values can be strings, integers or floating point numbers, and Perl
will automatically convert between them as required.  There is no need
to pre-declare your variable types, but you have to declare them using
the \f(CW\*(C`my\*(C'\fR keyword the first time you use them.  (This is one of the
requirements of \f(CW\*(C`use strict;\*(C'\fR.)
.Sp
Scalar values can be used in various ways:
.Sp
.Vb 3
\&    print $animal;
\&    print "The animal is $animal\en";
\&    print "The square of $answer is ", $answer * $answer, "\en";
.Ve
.Sp
There are a number of \*(L"magic\*(R" scalars with names that look like
punctuation or line noise.  These special variables are used for all
kinds of purposes, and are documented in perlvar.  The only one you
need to know about for now is \f(CW$_\fR which is the \*(L"default variable\*(R".
It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.
.Sp
.Vb 1
\&    print;          # prints contents of $_ by default
.Ve
.IP "Arrays" 4
.IX Item "Arrays"
An array represents a list of values:
.Sp
.Vb 3
\&    my @animals = ("camel", "llama", "owl");
\&    my @numbers = (23, 42, 69);
\&    my @mixed   = ("camel", 42, 1.23);
.Ve
.Sp
Arrays are zero-indexed.  Here's how you get at elements in an array:
.Sp
.Vb 2
\&    print $animals[0];              # prints "camel"
\&    print $animals[1];              # prints "llama"
.Ve
.Sp
The special variable \f(CW$#array\fR tells you the index of the last element
of an array:
.Sp
.Vb 1
\&    print $mixed[$#mixed];       # last element, prints 1.23
.Ve
.Sp
You might be tempted to use \f(CW\*(C`$#array + 1\*(C'\fR to tell you how many items there
are in an array.  Don't bother.  As it happens, using \f(CW@array\fR where Perl
expects to find a scalar value (\*(L"in scalar context\*(R") will give you the number
of elements in the array:
.Sp
.Vb 1
\&    if (@animals < 5) { ... }
.Ve
.Sp
The elements we're getting from the array start with a \f(CW\*(C`$\*(C'\fR because
we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.
.Sp
To get multiple values from an array:
.Sp
.Vb 3
\&    @animals[0,1];                  # gives ("camel", "llama");
\&    @animals[0..2];                 # gives ("camel", "llama", "owl");
\&    @animals[1..$#animals];         # gives all except the first element
.Ve
.Sp
This is called an \*(L"array slice\*(R".
.Sp
You can do various useful things to lists:
.Sp
.Vb 2
\&    my @sorted    = sort @animals;
\&    my @backwards = reverse @numbers;
.Ve
.Sp
There are a couple of special arrays too, such as \f(CW@ARGV\fR (the command
line arguments to your script) and \f(CW@_\fR (the arguments passed to a
subroutine).  These are documented in perlvar.
.IP "Hashes" 4
.IX Item "Hashes"
A hash represents a set of key/value pairs:
.Sp
.Vb 1
\&    my %fruit_color = ("apple", "red", "banana", "yellow");
.Ve
.Sp
You can use whitespace and the \f(CW\*(C`=>\*(C'\fR operator to lay them out more
nicely:
.Sp
.Vb 4
\&    my %fruit_color = (
\&        apple  => "red",
\&        banana => "yellow",
\&    );
.Ve
.Sp
To get at hash elements:
.Sp
.Vb 1
\&    $fruit_color{"apple"};           # gives "red"
.Ve
.Sp
You can get at lists of keys and values with \f(CW\*(C`keys()\*(C'\fR and
\&\f(CW\*(C`values()\*(C'\fR.
.Sp
.Vb 2
\&    my @fruits = keys %fruit_colors;
\&    my @colors = values %fruit_colors;
.Ve
.Sp
Hashes have no particular internal order, though you can sort the keys
and loop through them.
.Sp
Just like special scalars and arrays, there are also special hashes.
The most well known of these is \f(CW%ENV\fR which contains environment
variables.  Read all about it (and other special variables) in
perlvar.
.PP
Scalars, arrays and hashes are documented more fully in perldata.
.PP
More complex data types can be constructed using references, which allow
you to build lists and hashes within lists and hashes.
.PP
A reference is a scalar value and can refer to any other Perl data
type.  So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes.  The following example shows a 2 level hash of hash
structure using anonymous hash references.
.PP
.Vb 10
\&    my $variables = {
\&        scalar  =>  {
\&                     description => "single item",
\&                     sigil => \*(Aq$\*(Aq,
\&                    },
\&        array   =>  {
\&                     description => "ordered list of items",
\&                     sigil => \*(Aq@\*(Aq,
\&                    },
\&        hash    =>  {
\&                     description => "key/value pairs",
\&                     sigil => \*(Aq%\*(Aq,
\&                    },
\&    };
\&
\&    print "Scalars begin with a $variables\->{\*(Aqscalar\*(Aq}\->{\*(Aqsigil\*(Aq}\en";
.Ve
.PP
Exhaustive information on the topic of references can be found in
perlreftut, perllol, perlref and perldsc.
.SS "Variable scoping"
.IX Subsection "Variable scoping"
Throughout the previous section all the examples have used the syntax:
.PP
.Vb 1
\&    my $var = "value";
.Ve
.PP
The \f(CW\*(C`my\*(C'\fR is actually not required; you could just use:
.PP
.Vb 1
\&    $var = "value";
.Ve
.PP
However, the above usage will create global variables throughout your
program, which is bad programming practice.  \f(CW\*(C`my\*(C'\fR creates lexically
scoped variables instead.  The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.
.PP
.Vb 9
\&    my $x = "foo";
\&    my $some_condition = 1;
\&    if ($some_condition) {
\&        my $y = "bar";
\&        print $x;           # prints "foo"
\&        print $y;           # prints "bar"
\&    }
\&    print $x;               # prints "foo"
\&    print $y;               # prints nothing; $y has fallen out of scope
.Ve
.PP
Using \f(CW\*(C`my\*(C'\fR in combination with a \f(CW\*(C`use strict;\*(C'\fR at the top of
your Perl scripts means that the interpreter will pick up certain common
programming errors.  For instance, in the example above, the final
\&\f(CW\*(C`print $y\*(C'\fR would cause a compile-time error and prevent you from
running the program.  Using \f(CW\*(C`strict\*(C'\fR is highly recommended.
.SS "Conditional and looping constructs"
.IX Subsection "Conditional and looping constructs"
Perl has most of the usual conditional and looping constructs.  As of Perl
5.10, it even has a case/switch statement (spelled \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR).  See
\&\*(L"Switch Statements\*(R" in perlsyn for more details.
.PP
The conditions can be any Perl expression.  See the list of operators in
the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.
.IP "if" 4
.IX Item "if"
.Vb 7
\&    if ( condition ) {
\&        ...
\&    } elsif ( other condition ) {
\&        ...
\&    } else {
\&        ...
\&    }
.Ve
.Sp
There's also a negated version of it:
.Sp
.Vb 3
\&    unless ( condition ) {
\&        ...
\&    }
.Ve
.Sp
This is provided as a more readable version of \f(CW\*(C`if (!\f(CIcondition\f(CW)\*(C'\fR.
.Sp
Note that the braces are required in Perl, even if you've only got one
line in the block.  However, there is a clever way of making your one-line
conditional blocks more English like:
.Sp
.Vb 4
\&    # the traditional way
\&    if ($zippy) {
\&        print "Yow!";
\&    }
\&
\&    # the Perlish post\-condition way
\&    print "Yow!" if $zippy;
\&    print "We have no bananas" unless $bananas;
.Ve
.IP "while" 4
.IX Item "while"
.Vb 3
\&    while ( condition ) {
\&        ...
\&    }
.Ve
.Sp
There's also a negated version, for the same reason we have \f(CW\*(C`unless\*(C'\fR:
.Sp
.Vb 3
\&    until ( condition ) {
\&        ...
\&    }
.Ve
.Sp
You can also use \f(CW\*(C`while\*(C'\fR in a post-condition:
.Sp
.Vb 1
\&    print "LA LA LA\en" while 1;          # loops forever
.Ve
.IP "for" 4
.IX Item "for"
Exactly like C:
.Sp
.Vb 3
\&    for ($i = 0; $i <= $max; $i++) {
\&        ...
\&    }
.Ve
.Sp
The C style for loop is rarely needed in Perl since Perl provides
the more friendly list scanning \f(CW\*(C`foreach\*(C'\fR loop.
.IP "foreach" 4
.IX Item "foreach"
.Vb 3
\&    foreach (@array) {
\&        print "This element is $_\en";
\&    }
\&
\&    print $list[$_] foreach 0 .. $max;
\&
\&    # you don\*(Aqt have to use the default $_ either...
\&    foreach my $key (keys %hash) {
\&        print "The value of $key is $hash{$key}\en";
\&    }
.Ve
.Sp
The \f(CW\*(C`foreach\*(C'\fR keyword is actually a synonym for the \f(CW\*(C`for\*(C'\fR
keyword.  See \f(CW\*(C`"Foreach Loops" in perlsyn\*(C'\fR.
.PP
For more detail on looping constructs (and some that weren't mentioned in
this overview) see perlsyn.
.SS "Builtin operators and functions"
.IX Subsection "Builtin operators and functions"
Perl comes with a wide selection of builtin functions.  Some of the ones
we've already seen include \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`sort\*(C'\fR and \f(CW\*(C`reverse\*(C'\fR.  A list of
them is given at the start of perlfunc and you can easily read
about any given function by using \f(CW\*(C`perldoc \-f \f(CIfunctionname\f(CW\*(C'\fR.
.PP
Perl operators are documented in full in perlop, but here are a few
of the most common ones:
.IP "Arithmetic" 4
.IX Item "Arithmetic"
.Vb 4
\&    +   addition
\&    \-   subtraction
\&    *   multiplication
\&    /   division
.Ve
.IP "Numeric comparison" 4
.IX Item "Numeric comparison"
.Vb 6
\&    ==  equality
\&    !=  inequality
\&    <   less than
\&    >   greater than
\&    <=  less than or equal
\&    >=  greater than or equal
.Ve
.IP "String comparison" 4
.IX Item "String comparison"
.Vb 6
\&    eq  equality
\&    ne  inequality
\&    lt  less than
\&    gt  greater than
\&    le  less than or equal
\&    ge  greater than or equal
.Ve
.Sp
(Why do we have separate numeric and string comparisons?  Because we don't
have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).
.IP "Boolean logic" 4
.IX Item "Boolean logic"
.Vb 3
\&    &&  and
\&    ||  or
\&    !   not
.Ve
.Sp
(\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR aren't just in the above table as descriptions
of the operators.  They're also supported as operators in their own
right.  They're more readable than the C\-style operators, but have
different precedence to \f(CW\*(C`&&\*(C'\fR and friends.  Check perlop for more
detail.)
.IP "Miscellaneous" 4
.IX Item "Miscellaneous"
.Vb 4
\&    =   assignment
\&    .   string concatenation
\&    x   string multiplication
\&    ..  range operator (creates a list of numbers)
.Ve
.PP
Many operators can be combined with a \f(CW\*(C`=\*(C'\fR as follows:
.PP
.Vb 3
\&    $a += 1;        # same as $a = $a + 1
\&    $a \-= 1;        # same as $a = $a \- 1
\&    $a .= "\en";     # same as $a = $a . "\en";
.Ve
.SS "Files and I/O"
.IX Subsection "Files and I/O"
You can open a file for input or output using the \f(CW\*(C`open()\*(C'\fR function.
It's documented in extravagant detail in perlfunc and perlopentut,
but in short:
.PP
.Vb 3
\&    open(my $in,  "<",  "input.txt")  or die "Can\*(Aqt open input.txt: $!";
\&    open(my $out, ">",  "output.txt") or die "Can\*(Aqt open output.txt: $!";
\&    open(my $log, ">>", "my.log")     or die "Can\*(Aqt open my.log: $!";
.Ve
.PP
You can read from an open filehandle using the \f(CW\*(C`<>\*(C'\fR operator.  In
scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:
.PP
.Vb 2
\&    my $line  = <$in>;
\&    my @lines = <$in>;
.Ve
.PP
Reading in the whole file at one time is called slurping.  It can
be useful but it may be a memory hog.  Most text file processing
can be done a line at a time with Perl's looping constructs.
.PP
The \f(CW\*(C`<>\*(C'\fR operator is most often seen in a \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 3
\&    while (<$in>) {     # assigns each line in turn to $_
\&        print "Just read in this line: $_";
\&    }
.Ve
.PP
We've already seen how to print to standard output using \f(CW\*(C`print()\*(C'\fR.
However, \f(CW\*(C`print()\*(C'\fR can also take an optional first argument specifying
which filehandle to print to:
.PP
.Vb 3
\&    print STDERR "This is your final warning.\en";
\&    print $out $record;
\&    print $log $logmessage;
.Ve
.PP
When you're done with your filehandles, you should \f(CW\*(C`close()\*(C'\fR them
(though to be honest, Perl will clean up after you if you forget):
.PP
.Vb 1
\&    close $in or die "$in: $!";
.Ve
.SS "Regular expressions"
.IX Subsection "Regular expressions"
Perl's regular expression support is both broad and deep, and is the
subject of lengthy documentation in perlrequick, perlretut, and
elsewhere.  However, in short:
.IP "Simple matching" 4
.IX Item "Simple matching"
.Vb 2
\&    if (/foo/)       { ... }  # true if $_ contains "foo"
\&    if ($a =~ /foo/) { ... }  # true if $a contains "foo"
.Ve
.Sp
The \f(CW\*(C`//\*(C'\fR matching operator is documented in perlop.  It operates on
\&\f(CW$_\fR by default, or can be bound to another variable using the \f(CW\*(C`=~\*(C'\fR
binding operator (also documented in perlop).
.IP "Simple substitution" 4
.IX Item "Simple substitution"
.Vb 3
\&    s/foo/bar/;               # replaces foo with bar in $_
\&    $a =~ s/foo/bar/;         # replaces foo with bar in $a
\&    $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $a
.Ve
.Sp
The \f(CW\*(C`s///\*(C'\fR substitution operator is documented in perlop.
.IP "More complex regular expressions" 4
.IX Item "More complex regular expressions"
You don't just have to match on fixed strings.  In fact, you can match
on just about anything you could dream of by using more complex regular
expressions.  These are documented at great length in perlre, but for
the meantime, here's a quick cheat sheet:
.Sp
.Vb 10
\&    .                   a single character
\&    \es                  a whitespace character (space, tab, newline, ...)
\&    \eS                  non\-whitespace character
\&    \ed                  a digit (0\-9)
\&    \eD                  a non\-digit
\&    \ew                  a word character (a\-z, A\-Z, 0\-9, _)
\&    \eW                  a non\-word character
\&    [aeiou]             matches a single character in the given set
\&    [^aeiou]            matches a single character outside the given set
\&    (foo|bar|baz)       matches any of the alternatives specified
\&
\&    ^                   start of string
\&    $                   end of string
.Ve
.Sp
Quantifiers can be used to specify how many of the previous thing you
want to match on, where \*(L"thing\*(R" means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.
.Sp
.Vb 6
\&    *                   zero or more of the previous thing
\&    +                   one or more of the previous thing
\&    ?                   zero or one of the previous thing
\&    {3}                 matches exactly 3 of the previous thing
\&    {3,6}               matches between 3 and 6 of the previous thing
\&    {3,}                matches 3 or more of the previous thing
.Ve
.Sp
Some brief examples:
.Sp
.Vb 6
\&    /^\ed+/              string starts with one or more digits
\&    /^$/                nothing in the string (start and end are adjacent)
\&    /(\ed\es){3}/         a three digits, each followed by a whitespace
\&                        character (eg "3 4 5 ")
\&    /(a.)+/             matches a string in which every odd\-numbered letter
\&                        is a (eg "abacadaf")
\&
\&    # This loop reads from STDIN, and prints non\-blank lines:
\&    while (<>) {
\&        next if /^$/;
\&        print;
\&    }
.Ve
.IP "Parentheses for capturing" 4
.IX Item "Parentheses for capturing"
As well as grouping, parentheses serve a second purpose.  They can be
used to capture the results of parts of the regexp match for later use.
The results end up in \f(CW$1\fR, \f(CW$2\fR and so on.
.Sp
.Vb 1
\&    # a cheap and nasty way to break an email address up into parts
\&
\&    if ($email =~ /([^@]+)@(.+)/) {
\&        print "Username is $1\en";
\&        print "Hostname is $2\en";
\&    }
.Ve
.IP "Other regexp features" 4
.IX Item "Other regexp features"
Perl regexps also support backreferences, lookaheads, and all kinds of
other complex details.  Read all about them in perlrequick,
perlretut, and perlre.
.SS "Writing subroutines"
.IX Subsection "Writing subroutines"
Writing subroutines is easy:
.PP
.Vb 5
\&    sub logger {
\&        my $logmessage = shift;
\&        open my $logfile, ">>", "my.log" or die "Could not open my.log: $!";
\&        print $logfile $logmessage;
\&    }
.Ve
.PP
Now we can use the subroutine just as any other built-in function:
.PP
.Vb 1
\&    logger("We have a logger subroutine!");
.Ve
.PP
What's that \f(CW\*(C`shift\*(C'\fR?  Well, the arguments to a subroutine are available
to us as a special array called \f(CW@_\fR (see perlvar for more on that).
The default argument to the \f(CW\*(C`shift\*(C'\fR function just happens to be \f(CW@_\fR.
So \f(CW\*(C`my $logmessage = shift;\*(C'\fR shifts the first item off the list of
arguments and assigns it to \f(CW$logmessage\fR.
.PP
We can manipulate \f(CW@_\fR in other ways too:
.PP
.Vb 2
\&    my ($logmessage, $priority) = @_;       # common
\&    my $logmessage = $_[0];                 # uncommon, and ugly
.Ve
.PP
Subroutines can also return values:
.PP
.Vb 5
\&    sub square {
\&        my $num = shift;
\&        my $result = $num * $num;
\&        return $result;
\&    }
.Ve
.PP
Then use it like:
.PP
.Vb 1
\&    $sq = square(8);
.Ve
.PP
For more information on writing subroutines, see perlsub.
.SS "\s-1OO\s0 Perl"
.IX Subsection "OO Perl"
\&\s-1OO\s0 Perl is relatively simple and is implemented using references which
know what sort of object they are based on Perl's concept of packages.
However, \s-1OO\s0 Perl is largely beyond the scope of this document.
Read perlootut and perlobj.
.PP
As a beginning Perl programmer, your most common use of \s-1OO\s0 Perl will be
in using third-party modules, which are documented below.
.SS "Using Perl modules"
.IX Subsection "Using Perl modules"
Perl modules provide a range of features to help you avoid reinventing
the wheel, and can be downloaded from \s-1CPAN\s0 ( http://www.cpan.org/ ).  A
number of popular modules are included with the Perl distribution
itself.
.PP
Categories of modules range from text manipulation to network protocols
to database integration to graphics.  A categorized list of modules is
also available from \s-1CPAN\s0.
.PP
To learn how to install modules you download from \s-1CPAN\s0, read
perlmodinstall.
.PP
To learn how to use a particular module, use \f(CW\*(C`perldoc \f(CIModule::Name\f(CW\*(C'\fR.
Typically you will want to \f(CW\*(C`use \f(CIModule::Name\f(CW\*(C'\fR, which will then give
you access to exported functions or an \s-1OO\s0 interface to the module.
.PP
perlfaq contains questions and answers related to many common
tasks, and often provides suggestions for good \s-1CPAN\s0 modules to use.
.PP
perlmod describes Perl modules in general.  perlmodlib lists the
modules which came with your Perl installation.
.PP
If you feel the urge to write Perl modules, perlnewmod will give you
good advice.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirrily \*(L"Skud\*(R" Robert <skud@cpan.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlintro5.18.1                              0100644 0001750 0001750 00000071364 12566207441 023304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTRO 1"
.TH PERLINTRO 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintro \-\- a brief introduction and overview of Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is intended to give you a quick overview of the Perl
programming language, along with pointers to further documentation.  It
is intended as a \*(L"bootstrap\*(R" guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.
.PP
This introductory document does not aim to be complete.  It does not
even aim to be entirely accurate.  In some cases perfection has been
sacrificed in the goal of getting the general idea across.  You are
\&\fIstrongly\fR advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in perltoc.
.PP
Throughout this document you'll see references to other parts of the
Perl documentation.  You can read that documentation using the \f(CW\*(C`perldoc\*(C'\fR
command or whatever method you're using to read this document.
.PP
Throughout Perl's documentation, you'll find numerous examples intended
to help explain the discussed features.  Please keep in mind that many
of them are code fragments rather than complete programs.
.PP
These examples often reflect the style and preference of the author of
that piece of the documentation, and may be briefer than a corresponding
line of code in a real program.  Except where otherwise noted, you
should assume that \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR statements
appear earlier in the \*(L"program\*(R", and that any variables used have
already been declared, even if those declarations have been omitted
to make the example easier to read.
.PP
Do note that the examples have been written by many different authors over
a period of several decades.  Styles and techniques will therefore differ,
although some effort has been made to not vary styles too widely in the
same sections.  Do not consider one style to be better than others \- \*(L"There's
More Than One Way To Do It\*(R" is one of Perl's mottos.  After all, in your
journey as a programmer, you are likely to encounter different styles.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a general-purpose programming language originally developed for
text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, \s-1GUI\s0
development, and more.
.PP
The language is intended to be practical (easy to use, efficient,
complete) rather than beautiful (tiny, elegant, minimal).  Its major
features are that it's easy to use, supports both procedural and
object-oriented (\s-1OO\s0) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.
.PP
Different definitions of Perl are given in perl, perlfaq1 and
no doubt other places.  From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.
.SS "Running Perl programs"
.IX Subsection "Running Perl programs"
To run a Perl program from the Unix command line:
.PP
.Vb 1
\& perl progname.pl
.Ve
.PP
Alternatively, put this as the first line of your script:
.PP
.Vb 1
\& #!/usr/bin/env perl
.Ve
.PP
\&... and run the script as \fI/path/to/script.pl\fR.  Of course, it'll need
to be executable first, so \f(CW\*(C`chmod 755 script.pl\*(C'\fR (under Unix).
.PP
(This start line assumes you have the \fBenv\fR program.  You can also put
directly the path to your perl executable, like in \f(CW\*(C`#!/usr/bin/perl\*(C'\fR).
.PP
For more information, including instructions for other platforms such as
Windows and Mac \s-1OS,\s0 read perlrun.
.SS "Safety net"
.IX Subsection "Safety net"
Perl by default is very forgiving.  In order to make it more robust
it is recommended to start every program with the following lines:
.PP
.Vb 3
\& #!/usr/bin/perl
\& use strict;
\& use warnings;
.Ve
.PP
The two additional lines request from perl to catch various common
problems in your code.  They check different things so you need both.  A
potential problem caught by \f(CW\*(C`use strict;\*(C'\fR will cause your code to stop
immediately when it is encountered, while \f(CW\*(C`use warnings;\*(C'\fR will merely
give a warning (like the command-line switch \fB\-w\fR) and let your code run.
To read more about them check their respective manual pages at strict
and warnings.
.SS "Basic syntax overview"
.IX Subsection "Basic syntax overview"
A Perl script or program consists of one or more statements.  These
statements are simply written in the script in a straightforward
fashion.  There is no need to have a \f(CW\*(C`main()\*(C'\fR function or anything of
that kind.
.PP
Perl statements end in a semi-colon:
.PP
.Vb 1
\& print "Hello, world";
.Ve
.PP
Comments start with a hash symbol and run to the end of the line
.PP
.Vb 1
\& # This is a comment
.Ve
.PP
Whitespace is irrelevant:
.PP
.Vb 3
\& print
\&     "Hello, world"
\&     ;
.Ve
.PP
\&... except inside quoted strings:
.PP
.Vb 3
\& # this would print with a linebreak in the middle
\& print "Hello
\& world";
.Ve
.PP
Double quotes or single quotes may be used around literal strings:
.PP
.Vb 2
\& print "Hello, world";
\& print \*(AqHello, world\*(Aq;
.Ve
.PP
However, only double quotes \*(L"interpolate\*(R" variables and special
characters such as newlines (\f(CW\*(C`\en\*(C'\fR):
.PP
.Vb 2
\& print "Hello, $name\en";     # works fine
\& print \*(AqHello, $name\en\*(Aq;     # prints $name\en literally
.Ve
.PP
Numbers don't need quotes around them:
.PP
.Vb 1
\& print 42;
.Ve
.PP
You can use parentheses for functions' arguments or omit them
according to your personal taste.  They are only required
occasionally to clarify issues of precedence.
.PP
.Vb 2
\& print("Hello, world\en");
\& print "Hello, world\en";
.Ve
.PP
More detailed information about Perl syntax can be found in perlsyn.
.SS "Perl variable types"
.IX Subsection "Perl variable types"
Perl has three main variable types: scalars, arrays, and hashes.
.IP "Scalars" 4
.IX Item "Scalars"
A scalar represents a single value:
.Sp
.Vb 2
\& my $animal = "camel";
\& my $answer = 42;
.Ve
.Sp
Scalar values can be strings, integers or floating point numbers, and Perl
will automatically convert between them as required.  There is no need
to pre-declare your variable types, but you have to declare them using
the \f(CW\*(C`my\*(C'\fR keyword the first time you use them.  (This is one of the
requirements of \f(CW\*(C`use strict;\*(C'\fR.)
.Sp
Scalar values can be used in various ways:
.Sp
.Vb 3
\& print $animal;
\& print "The animal is $animal\en";
\& print "The square of $answer is ", $answer * $answer, "\en";
.Ve
.Sp
There are a number of \*(L"magic\*(R" scalars with names that look like
punctuation or line noise.  These special variables are used for all
kinds of purposes, and are documented in perlvar.  The only one you
need to know about for now is \f(CW$_\fR which is the \*(L"default variable\*(R".
It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.
.Sp
.Vb 1
\& print;          # prints contents of $_ by default
.Ve
.IP "Arrays" 4
.IX Item "Arrays"
An array represents a list of values:
.Sp
.Vb 3
\& my @animals = ("camel", "llama", "owl");
\& my @numbers = (23, 42, 69);
\& my @mixed   = ("camel", 42, 1.23);
.Ve
.Sp
Arrays are zero-indexed.  Here's how you get at elements in an array:
.Sp
.Vb 2
\& print $animals[0];              # prints "camel"
\& print $animals[1];              # prints "llama"
.Ve
.Sp
The special variable \f(CW$#array\fR tells you the index of the last element
of an array:
.Sp
.Vb 1
\& print $mixed[$#mixed];       # last element, prints 1.23
.Ve
.Sp
You might be tempted to use \f(CW\*(C`$#array + 1\*(C'\fR to tell you how many items there
are in an array.  Don't bother.  As it happens, using \f(CW@array\fR where Perl
expects to find a scalar value (\*(L"in scalar context\*(R") will give you the number
of elements in the array:
.Sp
.Vb 1
\& if (@animals < 5) { ... }
.Ve
.Sp
The elements we're getting from the array start with a \f(CW\*(C`$\*(C'\fR because
we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.
.Sp
To get multiple values from an array:
.Sp
.Vb 3
\& @animals[0,1];                 # gives ("camel", "llama");
\& @animals[0..2];                # gives ("camel", "llama", "owl");
\& @animals[1..$#animals];        # gives all except the first element
.Ve
.Sp
This is called an \*(L"array slice\*(R".
.Sp
You can do various useful things to lists:
.Sp
.Vb 2
\& my @sorted    = sort @animals;
\& my @backwards = reverse @numbers;
.Ve
.Sp
There are a couple of special arrays too, such as \f(CW@ARGV\fR (the command
line arguments to your script) and \f(CW@_\fR (the arguments passed to a
subroutine).  These are documented in perlvar.
.IP "Hashes" 4
.IX Item "Hashes"
A hash represents a set of key/value pairs:
.Sp
.Vb 1
\& my %fruit_color = ("apple", "red", "banana", "yellow");
.Ve
.Sp
You can use whitespace and the \f(CW\*(C`=>\*(C'\fR operator to lay them out more
nicely:
.Sp
.Vb 4
\& my %fruit_color = (
\&     apple  => "red",
\&     banana => "yellow",
\& );
.Ve
.Sp
To get at hash elements:
.Sp
.Vb 1
\& $fruit_color{"apple"};           # gives "red"
.Ve
.Sp
You can get at lists of keys and values with \f(CW\*(C`keys()\*(C'\fR and
\&\f(CW\*(C`values()\*(C'\fR.
.Sp
.Vb 2
\& my @fruits = keys %fruit_colors;
\& my @colors = values %fruit_colors;
.Ve
.Sp
Hashes have no particular internal order, though you can sort the keys
and loop through them.
.Sp
Just like special scalars and arrays, there are also special hashes.
The most well known of these is \f(CW%ENV\fR which contains environment
variables.  Read all about it (and other special variables) in
perlvar.
.PP
Scalars, arrays and hashes are documented more fully in perldata.
.PP
More complex data types can be constructed using references, which allow
you to build lists and hashes within lists and hashes.
.PP
A reference is a scalar value and can refer to any other Perl data
type.  So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes.  The following example shows a 2 level hash of hash
structure using anonymous hash references.
.PP
.Vb 10
\& my $variables = {
\&     scalar  =>  {
\&                  description => "single item",
\&                  sigil => \*(Aq$\*(Aq,
\&                 },
\&     array   =>  {
\&                  description => "ordered list of items",
\&                  sigil => \*(Aq@\*(Aq,
\&                 },
\&     hash    =>  {
\&                  description => "key/value pairs",
\&                  sigil => \*(Aq%\*(Aq,
\&                 },
\& };
\&
\& print "Scalars begin with a $variables\->{\*(Aqscalar\*(Aq}\->{\*(Aqsigil\*(Aq}\en";
.Ve
.PP
Exhaustive information on the topic of references can be found in
perlreftut, perllol, perlref and perldsc.
.SS "Variable scoping"
.IX Subsection "Variable scoping"
Throughout the previous section all the examples have used the syntax:
.PP
.Vb 1
\& my $var = "value";
.Ve
.PP
The \f(CW\*(C`my\*(C'\fR is actually not required; you could just use:
.PP
.Vb 1
\& $var = "value";
.Ve
.PP
However, the above usage will create global variables throughout your
program, which is bad programming practice.  \f(CW\*(C`my\*(C'\fR creates lexically
scoped variables instead.  The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.
.PP
.Vb 9
\& my $x = "foo";
\& my $some_condition = 1;
\& if ($some_condition) {
\&     my $y = "bar";
\&     print $x;           # prints "foo"
\&     print $y;           # prints "bar"
\& }
\& print $x;               # prints "foo"
\& print $y;               # prints nothing; $y has fallen out of scope
.Ve
.PP
Using \f(CW\*(C`my\*(C'\fR in combination with a \f(CW\*(C`use strict;\*(C'\fR at the top of
your Perl scripts means that the interpreter will pick up certain common
programming errors.  For instance, in the example above, the final
\&\f(CW\*(C`print $y\*(C'\fR would cause a compile-time error and prevent you from
running the program.  Using \f(CW\*(C`strict\*(C'\fR is highly recommended.
.SS "Conditional and looping constructs"
.IX Subsection "Conditional and looping constructs"
Perl has most of the usual conditional and looping constructs.  As of Perl
5.10, it even has a case/switch statement (spelled \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR).  See
\&\*(L"Switch Statements\*(R" in perlsyn for more details.
.PP
The conditions can be any Perl expression.  See the list of operators in
the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.
.IP "if" 4
.IX Item "if"
.Vb 7
\& if ( condition ) {
\&     ...
\& } elsif ( other condition ) {
\&     ...
\& } else {
\&     ...
\& }
.Ve
.Sp
There's also a negated version of it:
.Sp
.Vb 3
\& unless ( condition ) {
\&     ...
\& }
.Ve
.Sp
This is provided as a more readable version of \f(CW\*(C`if (!\f(CIcondition\f(CW)\*(C'\fR.
.Sp
Note that the braces are required in Perl, even if you've only got one
line in the block.  However, there is a clever way of making your one-line
conditional blocks more English like:
.Sp
.Vb 4
\& # the traditional way
\& if ($zippy) {
\&     print "Yow!";
\& }
\&
\& # the Perlish post\-condition way
\& print "Yow!" if $zippy;
\& print "We have no bananas" unless $bananas;
.Ve
.IP "while" 4
.IX Item "while"
.Vb 3
\& while ( condition ) {
\&     ...
\& }
.Ve
.Sp
There's also a negated version, for the same reason we have \f(CW\*(C`unless\*(C'\fR:
.Sp
.Vb 3
\& until ( condition ) {
\&     ...
\& }
.Ve
.Sp
You can also use \f(CW\*(C`while\*(C'\fR in a post-condition:
.Sp
.Vb 1
\& print "LA LA LA\en" while 1;          # loops forever
.Ve
.IP "for" 4
.IX Item "for"
Exactly like C:
.Sp
.Vb 3
\& for ($i = 0; $i <= $max; $i++) {
\&     ...
\& }
.Ve
.Sp
The C style for loop is rarely needed in Perl since Perl provides
the more friendly list scanning \f(CW\*(C`foreach\*(C'\fR loop.
.IP "foreach" 4
.IX Item "foreach"
.Vb 3
\& foreach (@array) {
\&     print "This element is $_\en";
\& }
\&
\& print $list[$_] foreach 0 .. $max;
\&
\& # you don\*(Aqt have to use the default $_ either...
\& foreach my $key (keys %hash) {
\&     print "The value of $key is $hash{$key}\en";
\& }
.Ve
.Sp
The \f(CW\*(C`foreach\*(C'\fR keyword is actually a synonym for the \f(CW\*(C`for\*(C'\fR
keyword.  See \f(CW\*(C`"Foreach Loops" in perlsyn\*(C'\fR.
.PP
For more detail on looping constructs (and some that weren't mentioned in
this overview) see perlsyn.
.SS "Builtin operators and functions"
.IX Subsection "Builtin operators and functions"
Perl comes with a wide selection of builtin functions.  Some of the ones
we've already seen include \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`sort\*(C'\fR and \f(CW\*(C`reverse\*(C'\fR.  A list of
them is given at the start of perlfunc and you can easily read
about any given function by using \f(CW\*(C`perldoc \-f \f(CIfunctionname\f(CW\*(C'\fR.
.PP
Perl operators are documented in full in perlop, but here are a few
of the most common ones:
.IP "Arithmetic" 4
.IX Item "Arithmetic"
.Vb 4
\& +   addition
\& \-   subtraction
\& *   multiplication
\& /   division
.Ve
.IP "Numeric comparison" 4
.IX Item "Numeric comparison"
.Vb 6
\& ==  equality
\& !=  inequality
\& <   less than
\& >   greater than
\& <=  less than or equal
\& >=  greater than or equal
.Ve
.IP "String comparison" 4
.IX Item "String comparison"
.Vb 6
\& eq  equality
\& ne  inequality
\& lt  less than
\& gt  greater than
\& le  less than or equal
\& ge  greater than or equal
.Ve
.Sp
(Why do we have separate numeric and string comparisons?  Because we don't
have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).
.IP "Boolean logic" 4
.IX Item "Boolean logic"
.Vb 3
\& &&  and
\& ||  or
\& !   not
.Ve
.Sp
(\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR aren't just in the above table as descriptions
of the operators.  They're also supported as operators in their own
right.  They're more readable than the C\-style operators, but have
different precedence to \f(CW\*(C`&&\*(C'\fR and friends.  Check perlop for more
detail.)
.IP "Miscellaneous" 4
.IX Item "Miscellaneous"
.Vb 4
\& =   assignment
\& .   string concatenation
\& x   string multiplication
\& ..  range operator (creates a list of numbers)
.Ve
.PP
Many operators can be combined with a \f(CW\*(C`=\*(C'\fR as follows:
.PP
.Vb 3
\& $a += 1;        # same as $a = $a + 1
\& $a \-= 1;        # same as $a = $a \- 1
\& $a .= "\en";     # same as $a = $a . "\en";
.Ve
.SS "Files and I/O"
.IX Subsection "Files and I/O"
You can open a file for input or output using the \f(CW\*(C`open()\*(C'\fR function.
It's documented in extravagant detail in perlfunc and perlopentut,
but in short:
.PP
.Vb 3
\& open(my $in,  "<",  "input.txt")  or die "Can\*(Aqt open input.txt: $!";
\& open(my $out, ">",  "output.txt") or die "Can\*(Aqt open output.txt: $!";
\& open(my $log, ">>", "my.log")     or die "Can\*(Aqt open my.log: $!";
.Ve
.PP
You can read from an open filehandle using the \f(CW\*(C`<>\*(C'\fR operator.  In
scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:
.PP
.Vb 2
\& my $line  = <$in>;
\& my @lines = <$in>;
.Ve
.PP
Reading in the whole file at one time is called slurping.  It can
be useful but it may be a memory hog.  Most text file processing
can be done a line at a time with Perl's looping constructs.
.PP
The \f(CW\*(C`<>\*(C'\fR operator is most often seen in a \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 3
\& while (<$in>) {     # assigns each line in turn to $_
\&     print "Just read in this line: $_";
\& }
.Ve
.PP
We've already seen how to print to standard output using \f(CW\*(C`print()\*(C'\fR.
However, \f(CW\*(C`print()\*(C'\fR can also take an optional first argument specifying
which filehandle to print to:
.PP
.Vb 3
\& print STDERR "This is your final warning.\en";
\& print $out $record;
\& print $log $logmessage;
.Ve
.PP
When you're done with your filehandles, you should \f(CW\*(C`close()\*(C'\fR them
(though to be honest, Perl will clean up after you if you forget):
.PP
.Vb 1
\& close $in or die "$in: $!";
.Ve
.SS "Regular expressions"
.IX Subsection "Regular expressions"
Perl's regular expression support is both broad and deep, and is the
subject of lengthy documentation in perlrequick, perlretut, and
elsewhere.  However, in short:
.IP "Simple matching" 4
.IX Item "Simple matching"
.Vb 2
\& if (/foo/)       { ... }  # true if $_ contains "foo"
\& if ($a =~ /foo/) { ... }  # true if $a contains "foo"
.Ve
.Sp
The \f(CW\*(C`//\*(C'\fR matching operator is documented in perlop.  It operates on
\&\f(CW$_\fR by default, or can be bound to another variable using the \f(CW\*(C`=~\*(C'\fR
binding operator (also documented in perlop).
.IP "Simple substitution" 4
.IX Item "Simple substitution"
.Vb 4
\& s/foo/bar/;               # replaces foo with bar in $_
\& $a =~ s/foo/bar/;         # replaces foo with bar in $a
\& $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar
\&                           # in $a
.Ve
.Sp
The \f(CW\*(C`s///\*(C'\fR substitution operator is documented in perlop.
.IP "More complex regular expressions" 4
.IX Item "More complex regular expressions"
You don't just have to match on fixed strings.  In fact, you can match
on just about anything you could dream of by using more complex regular
expressions.  These are documented at great length in perlre, but for
the meantime, here's a quick cheat sheet:
.Sp
.Vb 12
\& .                   a single character
\& \es                  a whitespace character (space, tab, newline,
\&                     ...)
\& \eS                  non\-whitespace character
\& \ed                  a digit (0\-9)
\& \eD                  a non\-digit
\& \ew                  a word character (a\-z, A\-Z, 0\-9, _)
\& \eW                  a non\-word character
\& [aeiou]             matches a single character in the given set
\& [^aeiou]            matches a single character outside the given
\&                     set
\& (foo|bar|baz)       matches any of the alternatives specified
\&
\& ^                   start of string
\& $                   end of string
.Ve
.Sp
Quantifiers can be used to specify how many of the previous thing you
want to match on, where \*(L"thing\*(R" means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.
.Sp
.Vb 6
\& *                   zero or more of the previous thing
\& +                   one or more of the previous thing
\& ?                   zero or one of the previous thing
\& {3}                 matches exactly 3 of the previous thing
\& {3,6}               matches between 3 and 6 of the previous thing
\& {3,}                matches 3 or more of the previous thing
.Ve
.Sp
Some brief examples:
.Sp
.Vb 7
\& /^\ed+/              string starts with one or more digits
\& /^$/                nothing in the string (start and end are
\&                     adjacent)
\& /(\ed\es){3}/         three digits, each followed by a whitespace
\&                     character (eg "3 4 5 ")
\& /(a.)+/             matches a string in which every odd\-numbered
\&                     letter is a (eg "abacadaf")
\&
\& # This loop reads from STDIN, and prints non\-blank lines:
\& while (<>) {
\&     next if /^$/;
\&     print;
\& }
.Ve
.IP "Parentheses for capturing" 4
.IX Item "Parentheses for capturing"
As well as grouping, parentheses serve a second purpose.  They can be
used to capture the results of parts of the regexp match for later use.
The results end up in \f(CW$1\fR, \f(CW$2\fR and so on.
.Sp
.Vb 1
\& # a cheap and nasty way to break an email address up into parts
\&
\& if ($email =~ /([^@]+)@(.+)/) {
\&     print "Username is $1\en";
\&     print "Hostname is $2\en";
\& }
.Ve
.IP "Other regexp features" 4
.IX Item "Other regexp features"
Perl regexps also support backreferences, lookaheads, and all kinds of
other complex details.  Read all about them in perlrequick,
perlretut, and perlre.
.SS "Writing subroutines"
.IX Subsection "Writing subroutines"
Writing subroutines is easy:
.PP
.Vb 5
\& sub logger {
\&    my $logmessage = shift;
\&    open my $logfile, ">>", "my.log" or die "Could not open my.log: $!";
\&    print $logfile $logmessage;
\& }
.Ve
.PP
Now we can use the subroutine just as any other built-in function:
.PP
.Vb 1
\& logger("We have a logger subroutine!");
.Ve
.PP
What's that \f(CW\*(C`shift\*(C'\fR?  Well, the arguments to a subroutine are available
to us as a special array called \f(CW@_\fR (see perlvar for more on that).
The default argument to the \f(CW\*(C`shift\*(C'\fR function just happens to be \f(CW@_\fR.
So \f(CW\*(C`my $logmessage = shift;\*(C'\fR shifts the first item off the list of
arguments and assigns it to \f(CW$logmessage\fR.
.PP
We can manipulate \f(CW@_\fR in other ways too:
.PP
.Vb 2
\& my ($logmessage, $priority) = @_;       # common
\& my $logmessage = $_[0];                 # uncommon, and ugly
.Ve
.PP
Subroutines can also return values:
.PP
.Vb 5
\& sub square {
\&     my $num = shift;
\&     my $result = $num * $num;
\&     return $result;
\& }
.Ve
.PP
Then use it like:
.PP
.Vb 1
\& $sq = square(8);
.Ve
.PP
For more information on writing subroutines, see perlsub.
.SS "\s-1OO\s0 Perl"
.IX Subsection "OO Perl"
\&\s-1OO\s0 Perl is relatively simple and is implemented using references which
know what sort of object they are based on Perl's concept of packages.
However, \s-1OO\s0 Perl is largely beyond the scope of this document.
Read perlootut and perlobj.
.PP
As a beginning Perl programmer, your most common use of \s-1OO\s0 Perl will be
in using third-party modules, which are documented below.
.SS "Using Perl modules"
.IX Subsection "Using Perl modules"
Perl modules provide a range of features to help you avoid reinventing
the wheel, and can be downloaded from \s-1CPAN \s0( http://www.cpan.org/ ).  A
number of popular modules are included with the Perl distribution
itself.
.PP
Categories of modules range from text manipulation to network protocols
to database integration to graphics.  A categorized list of modules is
also available from \s-1CPAN.\s0
.PP
To learn how to install modules you download from \s-1CPAN,\s0 read
perlmodinstall.
.PP
To learn how to use a particular module, use \f(CW\*(C`perldoc \f(CIModule::Name\f(CW\*(C'\fR.
Typically you will want to \f(CW\*(C`use \f(CIModule::Name\f(CW\*(C'\fR, which will then give
you access to exported functions or an \s-1OO\s0 interface to the module.
.PP
perlfaq contains questions and answers related to many common
tasks, and often provides suggestions for good \s-1CPAN\s0 modules to use.
.PP
perlmod describes Perl modules in general.  perlmodlib lists the
modules which came with your Perl installation.
.PP
If you feel the urge to write Perl modules, perlnewmod will give you
good advice.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirrily \*(L"Skud\*(R" Robert <skud@cpan.org>
                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perliol.1                                    0100644 0001750 0001750 00000131226 12566207441 022412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIOL 1"
.TH PERLIOL 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perliol \- C API for Perl's implementation of IO in Layers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    /* Defining a layer ... */
\&    #include <perliol.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the behavior and implementation of the PerlIO
abstraction described in perlapio when \f(CW\*(C`USE_PERLIO\*(C'\fR is defined (and
\&\f(CW\*(C`USE_SFIO\*(C'\fR is not).
.SS "History and Background"
.IX Subsection "History and Background"
The PerlIO abstraction was introduced in perl5.003_02 but languished as
just an abstraction until perl5.7.0. However during that time a number
of perl extensions switched to using it, so the \s-1API\s0 is mostly fixed to
maintain (source) compatibility.
.PP
The aim of the implementation is to provide the PerlIO \s-1API\s0 in a flexible
and platform neutral manner. It is also a trial of an \*(L"Object Oriented
C, with vtables\*(R" approach which may be applied to Perl 6.
.SS "Basic Structure"
.IX Subsection "Basic Structure"
PerlIO is a stack of layers.
.PP
The low levels of the stack work with the low-level operating system
calls (file descriptors in C) getting bytes in and out, the higher
layers of the stack buffer, filter, and otherwise manipulate the I/O,
and return characters (or bytes) to Perl.  Terms \fIabove\fR and \fIbelow\fR
are used to refer to the relative positioning of the stack layers.
.PP
A layer contains a \*(L"vtable\*(R", the table of I/O operations (at C level
a table of function pointers), and status flags.  The functions in the
vtable implement operations like \*(L"open\*(R", \*(L"read\*(R", and \*(L"write\*(R".
.PP
When I/O, for example \*(L"read\*(R", is requested, the request goes from Perl
first down the stack using \*(L"read\*(R" functions of each layer, then at the
bottom the input is requested from the operating system services, then
the result is returned up the stack, finally being interpreted as Perl
data.
.PP
The requests do not necessarily go always all the way down to the
operating system: that's where PerlIO buffering comes into play.
.PP
When you do an \fIopen()\fR and specify extra PerlIO layers to be deployed,
the layers you specify are \*(L"pushed\*(R" on top of the already existing
default stack.  One way to see it is that \*(L"operating system is
on the left\*(R" and \*(L"Perl is on the right\*(R".
.PP
What exact layers are in this default stack depends on a lot of
things: your operating system, Perl version, Perl compile time
configuration, and Perl runtime configuration.  See PerlIO,
\&\*(L"\s-1PERLIO\*(R"\s0 in perlrun, and open for more information.
.PP
\&\fIbinmode()\fR operates similarly to \fIopen()\fR: by default the specified
layers are pushed on top of the existing stack.
.PP
However, note that even as the specified layers are \*(L"pushed on top\*(R"
for \fIopen()\fR and \fIbinmode()\fR, this doesn't mean that the effects are
limited to the \*(L"top\*(R": PerlIO layers can be very 'active' and inspect
and affect layers also deeper in the stack.  As an example there
is a layer called \*(L"raw\*(R" which repeatedly \*(L"pops\*(R" layers until
it reaches the first layer that has declared itself capable of
handling binary data.  The \*(L"pushed\*(R" layers are processed in left-to-right
order.
.PP
\&\fIsysopen()\fR operates (unsurprisingly) at a lower level in the stack than
\&\fIopen()\fR.  For example in Unix or Unix-like systems \fIsysopen()\fR operates
directly at the level of file descriptors: in the terms of PerlIO
layers, it uses only the \*(L"unix\*(R" layer, which is a rather thin wrapper
on top of the Unix file descriptors.
.SS "Layers vs Disciplines"
.IX Subsection "Layers vs Disciplines"
Initial discussion of the ability to modify \s-1IO\s0 streams behaviour used
the term \*(L"discipline\*(R" for the entities which were added. This came (I
believe) from the use of the term in \*(L"sfio\*(R", which in turn borrowed it
from \*(L"line disciplines\*(R" on Unix terminals. However, this document (and
the C code) uses the term \*(L"layer\*(R".
.PP
This is, I hope, a natural term given the implementation, and should
avoid connotations that are inherent in earlier uses of \*(L"discipline\*(R"
for things which are rather different.
.SS "Data Structures"
.IX Subsection "Data Structures"
The basic data structure is a PerlIOl:
.PP
.Vb 3
\&        typedef struct _PerlIO PerlIOl;
\&        typedef struct _PerlIO_funcs PerlIO_funcs;
\&        typedef PerlIOl *PerlIO;
\&
\&        struct _PerlIO
\&        {
\&         PerlIOl *      next;       /* Lower layer */
\&         PerlIO_funcs * tab;        /* Functions for this layer */
\&         IV             flags;      /* Various flags for state */
\&        };
.Ve
.PP
A \f(CW\*(C`PerlIOl *\*(C'\fR is a pointer to the struct, and the \fIapplication\fR
level \f(CW\*(C`PerlIO *\*(C'\fR is a pointer to a \f(CW\*(C`PerlIOl *\*(C'\fR \- i.e. a pointer
to a pointer to the struct. This allows the application level \f(CW\*(C`PerlIO *\*(C'\fR
to remain constant while the actual \f(CW\*(C`PerlIOl *\*(C'\fR underneath
changes. (Compare perl's \f(CW\*(C`SV *\*(C'\fR which remains constant while its
\&\f(CW\*(C`sv_any\*(C'\fR field changes as the scalar's type changes.) An \s-1IO\s0 stream is
then in general represented as a pointer to this linked-list of
\&\*(L"layers\*(R".
.PP
It should be noted that because of the double indirection in a \f(CW\*(C`PerlIO *\*(C'\fR,
a \f(CW\*(C`&(perlio\->next)\*(C'\fR \*(L"is\*(R" a \f(CW\*(C`PerlIO *\*(C'\fR, and so to some degree
at least one layer can use the \*(L"standard\*(R" \s-1API\s0 on the next layer down.
.PP
A \*(L"layer\*(R" is composed of two parts:
.IP "1." 4
The functions and attributes of the \*(L"layer class\*(R".
.IP "2." 4
The per-instance data for a particular handle.
.SS "Functions and Attributes"
.IX Subsection "Functions and Attributes"
The functions and attributes are accessed via the \*(L"tab\*(R" (for table)
member of \f(CW\*(C`PerlIOl\*(C'\fR. The functions (methods of the layer \*(L"class\*(R") are
fixed, and are defined by the \f(CW\*(C`PerlIO_funcs\*(C'\fR type. They are broadly the
same as the public \f(CW\*(C`PerlIO_xxxxx\*(C'\fR functions:
.PP
.Vb 10
\&  struct _PerlIO_funcs
\&  {
\&   Size_t               fsize;
\&   char *               name;
\&   Size_t               size;
\&   IV           kind;
\&   IV           (*Pushed)(pTHX_ PerlIO *f,const char *mode,SV *arg, PerlIO_funcs *tab);
\&   IV           (*Popped)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
\&   IV           (*Binmode)(pTHX_ PerlIO *f);
\&   SV *         (*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
\&   IV           (*Fileno)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Dup)(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
\&   /* Unix\-like functions \- cf sfio line disciplines */
\&   SSize_t      (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
\&   SSize_t      (*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   SSize_t      (*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   IV           (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
\&   Off_t        (*Tell)(pTHX_ PerlIO *f);
\&   IV           (*Close)(pTHX_ PerlIO *f);
\&   /* Stdio\-like buffered IO functions */
\&   IV           (*Flush)(pTHX_ PerlIO *f);
\&   IV           (*Fill)(pTHX_ PerlIO *f);
\&   IV           (*Eof)(pTHX_ PerlIO *f);
\&   IV           (*Error)(pTHX_ PerlIO *f);
\&   void         (*Clearerr)(pTHX_ PerlIO *f);
\&   void         (*Setlinebuf)(pTHX_ PerlIO *f);
\&   /* Perl\*(Aqs snooping functions */
\&   STDCHAR *    (*Get_base)(pTHX_ PerlIO *f);
\&   Size_t       (*Get_bufsiz)(pTHX_ PerlIO *f);
\&   STDCHAR *    (*Get_ptr)(pTHX_ PerlIO *f);
\&   SSize_t      (*Get_cnt)(pTHX_ PerlIO *f);
\&   void         (*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
\&  };
.Ve
.PP
The first few members of the struct give a function table size for
compatibility check \*(L"name\*(R" for the layer, the  size to \f(CW\*(C`malloc\*(C'\fR for the per-instance data,
and some flags which are attributes of the class as whole (such as whether it is a buffering
layer), then follow the functions which fall into four basic groups:
.IP "1." 4
Opening and setup functions
.IP "2." 4
Basic \s-1IO\s0 operations
.IP "3." 4
Stdio class buffering options.
.IP "4." 4
Functions to support Perl's traditional \*(L"fast\*(R" access to the buffer.
.PP
A layer does not have to implement all the functions, but the whole
table has to be present. Unimplemented slots can be \s-1NULL \s0(which will
result in an error when called) or can be filled in with stubs to
\&\*(L"inherit\*(R" behaviour from a \*(L"base class\*(R". This \*(L"inheritance\*(R" is fixed
for all instances of the layer, but as the layer chooses which stubs
to populate the table, limited \*(L"multiple inheritance\*(R" is possible.
.SS "Per-instance Data"
.IX Subsection "Per-instance Data"
The per-instance data are held in memory beyond the basic PerlIOl
struct, by making a PerlIOl the first member of the layer's struct
thus:
.PP
.Vb 10
\&        typedef struct
\&        {
\&         struct _PerlIO base;       /* Base "class" info */
\&         STDCHAR *      buf;        /* Start of buffer */
\&         STDCHAR *      end;        /* End of valid part of buffer */
\&         STDCHAR *      ptr;        /* Current position in buffer */
\&         Off_t          posn;       /* Offset of buf into the file */
\&         Size_t         bufsiz;     /* Real size of buffer */
\&         IV             oneword;    /* Emergency buffer */
\&        } PerlIOBuf;
.Ve
.PP
In this way (as for perl's scalars) a pointer to a PerlIOBuf can be
treated as a pointer to a PerlIOl.
.SS "Layers in action."
.IX Subsection "Layers in action."
.Vb 8
\&                table           perlio          unix
\&            |           |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&   PerlIO \->|           |\-\-\->|  next    |\-\-\->|  NULL  |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&            |           |    |  buffer  |    |   fd   |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    |          |    +\-\-\-\-\-\-\-\-+
\&            |           |    +\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
The above attempts to show how the layer scheme works in a simple case.
The application's \f(CW\*(C`PerlIO *\*(C'\fR points to an entry in the table(s)
representing open (allocated) handles. For example the first three slots
in the table correspond to \f(CW\*(C`stdin\*(C'\fR,\f(CW\*(C`stdout\*(C'\fR and \f(CW\*(C`stderr\*(C'\fR. The table
in turn points to the current \*(L"top\*(R" layer for the handle \- in this case
an instance of the generic buffering layer \*(L"perlio\*(R". That layer in turn
points to the next layer down \- in this case the low-level \*(L"unix\*(R" layer.
.PP
The above is roughly equivalent to a \*(L"stdio\*(R" buffered stream, but with
much more flexibility:
.IP "\(bu" 4
If Unix level \f(CW\*(C`read\*(C'\fR/\f(CW\*(C`write\*(C'\fR/\f(CW\*(C`lseek\*(C'\fR is not appropriate for (say)
sockets then the \*(L"unix\*(R" layer can be replaced (at open time or even
dynamically) with a \*(L"socket\*(R" layer.
.IP "\(bu" 4
Different handles can have different buffering schemes. The \*(L"top\*(R"
layer could be the \*(L"mmap\*(R" layer if reading disk files was quicker
using \f(CW\*(C`mmap\*(C'\fR than \f(CW\*(C`read\*(C'\fR. An \*(L"unbuffered\*(R" stream can be implemented
simply by not having a buffer layer.
.IP "\(bu" 4
Extra layers can be inserted to process the data as it flows through.
This was the driving need for including the scheme in perl 5.7.0+ \- we
needed a mechanism to allow data to be translated between perl's
internal encoding (conceptually at least Unicode as \s-1UTF\-8\s0), and the
\&\*(L"native\*(R" format used by the system. This is provided by the
\&\*(L":encoding(xxxx)\*(R" layer which typically sits above the buffering layer.
.IP "\(bu" 4
A layer can be added that does \*(L"\en\*(R" to \s-1CRLF\s0 translation. This layer
can be used on any platform, not just those that normally do such
things.
.SS "Per-instance flag bits"
.IX Subsection "Per-instance flag bits"
The generic flag bits are a hybrid of \f(CW\*(C`O_XXXXX\*(C'\fR style flags deduced
from the mode string passed to \f(CW\*(C`PerlIO_open()\*(C'\fR, and state bits for
typical buffer layers.
.IP "\s-1PERLIO_F_EOF\s0" 4
.IX Item "PERLIO_F_EOF"
End of file.
.IP "\s-1PERLIO_F_CANWRITE\s0" 4
.IX Item "PERLIO_F_CANWRITE"
Writes are permitted, i.e. opened as \*(L"w\*(R" or \*(L"r+\*(R" or \*(L"a\*(R", etc.
.IP "\s-1PERLIO_F_CANREAD\s0" 4
.IX Item "PERLIO_F_CANREAD"
Reads are permitted i.e. opened \*(L"r\*(R" or \*(L"w+\*(R" (or even \*(L"a+\*(R" \- ick).
.IP "\s-1PERLIO_F_ERROR\s0" 4
.IX Item "PERLIO_F_ERROR"
An error has occurred (for \f(CW\*(C`PerlIO_error()\*(C'\fR).
.IP "\s-1PERLIO_F_TRUNCATE\s0" 4
.IX Item "PERLIO_F_TRUNCATE"
Truncate file suggested by open mode.
.IP "\s-1PERLIO_F_APPEND\s0" 4
.IX Item "PERLIO_F_APPEND"
All writes should be appends.
.IP "\s-1PERLIO_F_CRLF\s0" 4
.IX Item "PERLIO_F_CRLF"
Layer is performing Win32\-like \*(L"\en\*(R" mapped to \s-1CR,LF\s0 for output and \s-1CR,LF\s0
mapped to \*(L"\en\*(R" for input. Normally the provided \*(L"crlf\*(R" layer is the only
layer that need bother about this. \f(CW\*(C`PerlIO_binmode()\*(C'\fR will mess with this
flag rather than add/remove layers if the \f(CW\*(C`PERLIO_K_CANCRLF\*(C'\fR bit is set
for the layers class.
.IP "\s-1PERLIO_F_UTF8\s0" 4
.IX Item "PERLIO_F_UTF8"
Data written to this layer should be \s-1UTF\-8\s0 encoded; data provided
by this layer should be considered \s-1UTF\-8\s0 encoded. Can be set on any layer
by \*(L":utf8\*(R" dummy layer. Also set on \*(L":encoding\*(R" layer.
.IP "\s-1PERLIO_F_UNBUF\s0" 4
.IX Item "PERLIO_F_UNBUF"
Layer is unbuffered \- i.e. write to next layer down should occur for
each write to this layer.
.IP "\s-1PERLIO_F_WRBUF\s0" 4
.IX Item "PERLIO_F_WRBUF"
The buffer for this layer currently holds data written to it but not sent
to next layer.
.IP "\s-1PERLIO_F_RDBUF\s0" 4
.IX Item "PERLIO_F_RDBUF"
The buffer for this layer currently holds unconsumed data read from
layer below.
.IP "\s-1PERLIO_F_LINEBUF\s0" 4
.IX Item "PERLIO_F_LINEBUF"
Layer is line buffered. Write data should be passed to next layer down
whenever a \*(L"\en\*(R" is seen. Any data beyond the \*(L"\en\*(R" should then be
processed.
.IP "\s-1PERLIO_F_TEMP\s0" 4
.IX Item "PERLIO_F_TEMP"
File has been \f(CW\*(C`unlink()\*(C'\fRed, or should be deleted on \f(CW\*(C`close()\*(C'\fR.
.IP "\s-1PERLIO_F_OPEN\s0" 4
.IX Item "PERLIO_F_OPEN"
Handle is open.
.IP "\s-1PERLIO_F_FASTGETS\s0" 4
.IX Item "PERLIO_F_FASTGETS"
This instance of this layer supports the "fast \f(CW\*(C`gets\*(C'\fR" interface.
Normally set based on \f(CW\*(C`PERLIO_K_FASTGETS\*(C'\fR for the class and by the
existence of the function(s) in the table. However a class that
normally provides that interface may need to avoid it on a
particular instance. The \*(L"pending\*(R" layer needs to do this when
it is pushed above a layer which does not support the interface.
(Perl's \f(CW\*(C`sv_gets()\*(C'\fR does not expect the streams fast \f(CW\*(C`gets\*(C'\fR behaviour
to change during one \*(L"get\*(R".)
.SS "Methods in Detail"
.IX Subsection "Methods in Detail"
.IP "fsize" 4
.IX Item "fsize"
.Vb 1
\&        Size_t fsize;
.Ve
.Sp
Size of the function table. This is compared against the value PerlIO
code \*(L"knows\*(R" as a compatibility check. Future versions \fImay\fR be able
to tolerate layers compiled against an old version of the headers.
.IP "name" 4
.IX Item "name"
.Vb 1
\&        char * name;
.Ve
.Sp
The name of the layer whose \fIopen()\fR method Perl should invoke on
\&\fIopen()\fR.  For example if the layer is called \s-1APR,\s0 you will call:
.Sp
.Vb 1
\&  open $fh, ">:APR", ...
.Ve
.Sp
and Perl knows that it has to invoke the \fIPerlIOAPR_open()\fR method
implemented by the \s-1APR\s0 layer.
.IP "size" 4
.IX Item "size"
.Vb 1
\&        Size_t size;
.Ve
.Sp
The size of the per-instance data structure, e.g.:
.Sp
.Vb 1
\&  sizeof(PerlIOAPR)
.Ve
.Sp
If this field is zero then \f(CW\*(C`PerlIO_pushed\*(C'\fR does not malloc anything
and assumes layer's Pushed function will do any required layer stack
manipulation \- used to avoid malloc/free overhead for dummy layers.
If the field is non-zero it must be at least the size of \f(CW\*(C`PerlIOl\*(C'\fR,
\&\f(CW\*(C`PerlIO_pushed\*(C'\fR will allocate memory for the layer's data structures
and link new layer onto the stream's stack. (If the layer's Pushed
method returns an error indication the layer is popped again.)
.IP "kind" 4
.IX Item "kind"
.Vb 1
\&        IV kind;
.Ve
.RS 4
.IP "\(bu" 4
\&\s-1PERLIO_K_BUFFERED\s0
.Sp
The layer is buffered.
.IP "\(bu" 4
\&\s-1PERLIO_K_RAW\s0
.Sp
The layer is acceptable to have in a binmode(\s-1FH\s0) stack \- i.e. it does not
(or will configure itself not to) transform bytes passing through it.
.IP "\(bu" 4
\&\s-1PERLIO_K_CANCRLF\s0
.Sp
Layer can translate between \*(L"\en\*(R" and \s-1CRLF\s0 line ends.
.IP "\(bu" 4
\&\s-1PERLIO_K_FASTGETS\s0
.Sp
Layer allows buffer snooping.
.IP "\(bu" 4
\&\s-1PERLIO_K_MULTIARG\s0
.Sp
Used when the layer's \fIopen()\fR accepts more arguments than usual. The
extra arguments should come not before the \f(CW\*(C`MODE\*(C'\fR argument. When this
flag is used it's up to the layer to validate the args.
.RE
.RS 4
.RE
.IP "Pushed" 4
.IX Item "Pushed"
.Vb 1
\&        IV      (*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);
.Ve
.Sp
The only absolutely mandatory method. Called when the layer is pushed
onto the stack.  The \f(CW\*(C`mode\*(C'\fR argument may be \s-1NULL\s0 if this occurs
post-open. The \f(CW\*(C`arg\*(C'\fR will be non\-\f(CW\*(C`NULL\*(C'\fR if an argument string was
passed. In most cases this should call \f(CW\*(C`PerlIOBase_pushed()\*(C'\fR to
convert \f(CW\*(C`mode\*(C'\fR into the appropriate \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags in
addition to any actions the layer itself takes.  If a layer is not
expecting an argument it need neither save the one passed to it, nor
provide \f(CW\*(C`Getarg()\*(C'\fR (it could perhaps \f(CW\*(C`Perl_warn\*(C'\fR that the argument
was un-expected).
.Sp
Returns 0 on success. On failure returns \-1 and should set errno.
.IP "Popped" 4
.IX Item "Popped"
.Vb 1
\&        IV      (*Popped)(pTHX_ PerlIO *f);
.Ve
.Sp
Called when the layer is popped from the stack. A layer will normally
be popped after \f(CW\*(C`Close()\*(C'\fR is called. But a layer can be popped
without being closed if the program is dynamically managing layers on
the stream. In such cases \f(CW\*(C`Popped()\*(C'\fR should free any resources
(buffers, translation tables, ...) not held directly in the layer's
struct.  It should also \f(CW\*(C`Unread()\*(C'\fR any unconsumed data that has been
read and buffered from the layer below back to that layer, so that it
can be re-provided to what ever is now above.
.Sp
Returns 0 on success and failure.  If \f(CW\*(C`Popped()\*(C'\fR returns \fItrue\fR then
\&\fIperlio.c\fR assumes that either the layer has popped itself, or the
layer is super special and needs to be retained for other reasons.
In most cases it should return \fIfalse\fR.
.IP "Open" 4
.IX Item "Open"
.Vb 1
\&        PerlIO *        (*Open)(...);
.Ve
.Sp
The \f(CW\*(C`Open()\*(C'\fR method has lots of arguments because it combines the
functions of perl's \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`PerlIO_open\*(C'\fR, perl's \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`PerlIO_fdopen\*(C'\fR and \f(CW\*(C`PerlIO_reopen\*(C'\fR.  The full prototype is as
follows:
.Sp
.Vb 6
\& PerlIO *       (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
.Ve
.Sp
Open should (perhaps indirectly) call \f(CW\*(C`PerlIO_allocate()\*(C'\fR to allocate
a slot in the table and associate it with the layers information for
the opened file, by calling \f(CW\*(C`PerlIO_push\*(C'\fR.  The \fIlayers\fR is an
array of all the layers destined for the \f(CW\*(C`PerlIO *\*(C'\fR, and any
arguments passed to them, \fIn\fR is the index into that array of the
layer being called. The macro \f(CW\*(C`PerlIOArg\*(C'\fR will return a (possibly
\&\f(CW\*(C`NULL\*(C'\fR) \s-1SV\s0 * for the argument passed to the layer.
.Sp
The \fImode\fR string is an "\f(CW\*(C`fopen()\*(C'\fR\-like" string which would match
the regular expression \f(CW\*(C`/^[I#]?[rwa]\e+?[bt]?$/\*(C'\fR.
.Sp
The \f(CW\*(AqI\*(Aq\fR prefix is used during creation of \f(CW\*(C`stdin\*(C'\fR..\f(CW\*(C`stderr\*(C'\fR via
special \f(CW\*(C`PerlIO_fdopen\*(C'\fR calls; the \f(CW\*(Aq#\*(Aq\fR prefix means that this is
\&\f(CW\*(C`sysopen\*(C'\fR and that \fIimode\fR and \fIperm\fR should be passed to
\&\f(CW\*(C`PerlLIO_open3\*(C'\fR; \f(CW\*(Aqr\*(Aq\fR means \fBr\fRead, \f(CW\*(Aqw\*(Aq\fR means \fBw\fRrite and
\&\f(CW\*(Aqa\*(Aq\fR means \fBa\fRppend. The \f(CW\*(Aq+\*(Aq\fR suffix means that both reading and
writing/appending are permitted.  The \f(CW\*(Aqb\*(Aq\fR suffix means file should
be binary, and \f(CW\*(Aqt\*(Aq\fR means it is text. (Almost all layers should do
the \s-1IO\s0 in binary mode, and ignore the b/t bits. The \f(CW\*(C`:crlf\*(C'\fR layer
should be pushed to handle the distinction.)
.Sp
If \fIold\fR is not \f(CW\*(C`NULL\*(C'\fR then this is a \f(CW\*(C`PerlIO_reopen\*(C'\fR. Perl itself
does not use this (yet?) and semantics are a little vague.
.Sp
If \fIfd\fR not negative then it is the numeric file descriptor \fIfd\fR,
which will be open in a manner compatible with the supplied mode
string, the call is thus equivalent to \f(CW\*(C`PerlIO_fdopen\*(C'\fR. In this case
\&\fInargs\fR will be zero.
.Sp
If \fInargs\fR is greater than zero then it gives the number of arguments
passed to \f(CW\*(C`open\*(C'\fR, otherwise it will be 1 if for example
\&\f(CW\*(C`PerlIO_open\*(C'\fR was called.  In simple cases SvPV_nolen(*args) is the
pathname to open.
.Sp
If a layer provides \f(CW\*(C`Open()\*(C'\fR it should normally call the \f(CW\*(C`Open()\*(C'\fR
method of next layer down (if any) and then push itself on top if that
succeeds.  \f(CW\*(C`PerlIOBase_open\*(C'\fR is provided to do exactly that, so in
most cases you don't have to write your own \f(CW\*(C`Open()\*(C'\fR method.  If this
method is not defined, other layers may have difficulty pushing
themselves on top of it during open.
.Sp
If \f(CW\*(C`PerlIO_push\*(C'\fR was performed and open has failed, it must
\&\f(CW\*(C`PerlIO_pop\*(C'\fR itself, since if it's not, the layer won't be removed
and may cause bad problems.
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Binmode" 4
.IX Item "Binmode"
.Vb 1
\&        IV        (*Binmode)(pTHX_ PerlIO *f);
.Ve
.Sp
Optional. Used when \f(CW\*(C`:raw\*(C'\fR layer is pushed (explicitly or as a result
of binmode(\s-1FH\s0)). If not present layer will be popped. If present
should configure layer as binary (or pop itself) and return 0.
If it returns \-1 for error \f(CW\*(C`binmode\*(C'\fR will fail with layer
still on the stack.
.IP "Getarg" 4
.IX Item "Getarg"
.Vb 2
\&        SV *      (*Getarg)(pTHX_ PerlIO *f,
\&                            CLONE_PARAMS *param, int flags);
.Ve
.Sp
Optional. If present should return an \s-1SV\s0 * representing the string
argument passed to the layer when it was
pushed. e.g. \*(L":encoding(ascii)\*(R" would return an SvPV with value
\&\*(L"ascii\*(R". (\fIparam\fR and \fIflags\fR arguments can be ignored in most
cases)
.Sp
\&\f(CW\*(C`Dup\*(C'\fR uses \f(CW\*(C`Getarg\*(C'\fR to retrieve the argument originally passed to
\&\f(CW\*(C`Pushed\*(C'\fR, so you must implement this function if your layer has an
extra argument to \f(CW\*(C`Pushed\*(C'\fR and will ever be \f(CW\*(C`Dup\*(C'\fRed.
.IP "Fileno" 4
.IX Item "Fileno"
.Vb 1
\&        IV        (*Fileno)(pTHX_ PerlIO *f);
.Ve
.Sp
Returns the Unix/Posix numeric file descriptor for the handle. Normally
\&\f(CW\*(C`PerlIOBase_fileno()\*(C'\fR (which just asks next layer down) will suffice
for this.
.Sp
Returns \-1 on error, which is considered to include the case where the
layer cannot provide such a file descriptor.
.IP "Dup" 4
.IX Item "Dup"
.Vb 2
\&        PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
\&                        CLONE_PARAMS *param, int flags);
.Ve
.Sp
\&\s-1XXX:\s0 Needs more docs.
.Sp
Used as part of the \*(L"clone\*(R" process when a thread is spawned (in which
case param will be non-NULL) and when a stream is being duplicated via
\&'&' in the \f(CW\*(C`open\*(C'\fR.
.Sp
Similar to \f(CW\*(C`Open\*(C'\fR, returns PerlIO* on success, \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Read" 4
.IX Item "Read"
.Vb 1
\&        SSize_t (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
.Ve
.Sp
Basic read operation.
.Sp
Typically will call \f(CW\*(C`Fill\*(C'\fR and manipulate pointers (possibly via the
\&\s-1API\s0).  \f(CW\*(C`PerlIOBuf_read()\*(C'\fR may be suitable for derived classes which
provide \*(L"fast gets\*(R" methods.
.Sp
Returns actual bytes read, or \-1 on an error.
.IP "Unread" 4
.IX Item "Unread"
.Vb 2
\&        SSize_t (*Unread)(pTHX_ PerlIO *f,
\&                          const void *vbuf, Size_t count);
.Ve
.Sp
A superset of stdio's \f(CW\*(C`ungetc()\*(C'\fR. Should arrange for future reads to
see the bytes in \f(CW\*(C`vbuf\*(C'\fR. If there is no obviously better implementation
then \f(CW\*(C`PerlIOBase_unread()\*(C'\fR provides the function by pushing a \*(L"fake\*(R"
\&\*(L"pending\*(R" layer above the calling layer.
.Sp
Returns the number of unread chars.
.IP "Write" 4
.IX Item "Write"
.Vb 1
\&        SSize_t (*Write)(PerlIO *f, const void *vbuf, Size_t count);
.Ve
.Sp
Basic write operation.
.Sp
Returns bytes written or \-1 on an error.
.IP "Seek" 4
.IX Item "Seek"
.Vb 1
\&        IV      (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
.Ve
.Sp
Position the file pointer. Should normally call its own \f(CW\*(C`Flush\*(C'\fR
method and then the \f(CW\*(C`Seek\*(C'\fR method of next layer down.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Tell" 4
.IX Item "Tell"
.Vb 1
\&        Off_t   (*Tell)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the file pointer. May be based on layers cached concept of
position to avoid overhead.
.Sp
Returns \-1 on failure to get the file pointer.
.IP "Close" 4
.IX Item "Close"
.Vb 1
\&        IV      (*Close)(pTHX_ PerlIO *f);
.Ve
.Sp
Close the stream. Should normally call \f(CW\*(C`PerlIOBase_close()\*(C'\fR to flush
itself and close layers below, and then deallocate any data structures
(buffers, translation tables, ...) not  held directly in the data
structure.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Flush" 4
.IX Item "Flush"
.Vb 1
\&        IV      (*Flush)(pTHX_ PerlIO *f);
.Ve
.Sp
Should make stream's state consistent with layers below. That is, any
buffered write data should be written, and file position of lower layers
adjusted for data read from below but not actually consumed.
(Should perhaps \f(CW\*(C`Unread()\*(C'\fR such data to the lower layer.)
.Sp
Returns 0 on success, \-1 on failure.
.IP "Fill" 4
.IX Item "Fill"
.Vb 1
\&        IV      (*Fill)(pTHX_ PerlIO *f);
.Ve
.Sp
The buffer for this layer should be filled (for read) from layer
below.  When you \*(L"subclass\*(R" PerlIOBuf layer, you want to use its
\&\fI_read\fR method and to supply your own fill method, which fills the
PerlIOBuf's buffer.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Eof" 4
.IX Item "Eof"
.Vb 1
\&        IV      (*Eof)(pTHX_ PerlIO *f);
.Ve
.Sp
Return end-of-file indicator. \f(CW\*(C`PerlIOBase_eof()\*(C'\fR is normally sufficient.
.Sp
Returns 0 on end-of-file, 1 if not end-of-file, \-1 on error.
.IP "Error" 4
.IX Item "Error"
.Vb 1
\&        IV      (*Error)(pTHX_ PerlIO *f);
.Ve
.Sp
Return error indicator. \f(CW\*(C`PerlIOBase_error()\*(C'\fR is normally sufficient.
.Sp
Returns 1 if there is an error (usually when \f(CW\*(C`PERLIO_F_ERROR\*(C'\fR is set),
0 otherwise.
.IP "Clearerr" 4
.IX Item "Clearerr"
.Vb 1
\&        void    (*Clearerr)(pTHX_ PerlIO *f);
.Ve
.Sp
Clear end-of-file and error indicators. Should call \f(CW\*(C`PerlIOBase_clearerr()\*(C'\fR
to set the \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags, which may suffice.
.IP "Setlinebuf" 4
.IX Item "Setlinebuf"
.Vb 1
\&        void    (*Setlinebuf)(pTHX_ PerlIO *f);
.Ve
.Sp
Mark the stream as line buffered. \f(CW\*(C`PerlIOBase_setlinebuf()\*(C'\fR sets the
\&\s-1PERLIO_F_LINEBUF\s0 flag and is normally sufficient.
.IP "Get_base" 4
.IX Item "Get_base"
.Vb 1
\&        STDCHAR *       (*Get_base)(pTHX_ PerlIO *f);
.Ve
.Sp
Allocate (if not already done so) the read buffer for this layer and
return pointer to it. Return \s-1NULL\s0 on failure.
.IP "Get_bufsiz" 4
.IX Item "Get_bufsiz"
.Vb 1
\&        Size_t  (*Get_bufsiz)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes that last \f(CW\*(C`Fill()\*(C'\fR put in the buffer.
.IP "Get_ptr" 4
.IX Item "Get_ptr"
.Vb 1
\&        STDCHAR *       (*Get_ptr)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the current read pointer relative to this layer's buffer.
.IP "Get_cnt" 4
.IX Item "Get_cnt"
.Vb 1
\&        SSize_t (*Get_cnt)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes left to be read in the current buffer.
.IP "Set_ptrcnt" 4
.IX Item "Set_ptrcnt"
.Vb 2
\&        void    (*Set_ptrcnt)(pTHX_ PerlIO *f,
\&                              STDCHAR *ptr, SSize_t cnt);
.Ve
.Sp
Adjust the read pointer and count of bytes to match \f(CW\*(C`ptr\*(C'\fR and/or \f(CW\*(C`cnt\*(C'\fR.
The application (or layer above) must ensure they are consistent.
(Checking is allowed by the paranoid.)
.SS "Utilities"
.IX Subsection "Utilities"
To ask for the next layer down use PerlIONext(PerlIO *f).
.PP
To check that a PerlIO* is valid use PerlIOValid(PerlIO *f).  (All
this does is really just to check that the pointer is non-NULL and
that the pointer behind that is non-NULL.)
.PP
PerlIOBase(PerlIO *f) returns the \*(L"Base\*(R" pointer, or in other words,
the \f(CW\*(C`PerlIOl*\*(C'\fR pointer.
.PP
PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.
.PP
Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either
calls the \fIcallback\fR from the functions of the layer \fIf\fR (just by
the name of the \s-1IO\s0 function, like \*(L"Read\*(R") with the \fIargs\fR, or if
there is no such callback, calls the \fIbase\fR version of the callback
with the same args, or if the f is invalid, set errno to \s-1EBADF\s0 and
return \fIfailure\fR.
.PP
Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, set errno to \s-1EINVAL. \s0 Or if the f is
invalid, set errno to \s-1EBADF\s0 and return \fIfailure\fR.
.PP
Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, calls the \fIbase\fR version of the
callback with the same args, or if the f is invalid, set errno to
\&\s-1EBADF.\s0
.PP
Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the
\&\fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR, or if
there is no such callback, set errno to \s-1EINVAL. \s0 Or if the f is
invalid, set errno to \s-1EBADF.\s0
.SS "Implementing PerlIO Layers"
.IX Subsection "Implementing PerlIO Layers"
If you find the implementation document unclear or not sufficient,
look at the existing PerlIO layer implementations, which include:
.IP "\(bu" 4
C implementations
.Sp
The \fIperlio.c\fR and \fIperliol.h\fR in the Perl core implement the
\&\*(L"unix\*(R", \*(L"perlio\*(R", \*(L"stdio\*(R", \*(L"crlf\*(R", \*(L"utf8\*(R", \*(L"byte\*(R", \*(L"raw\*(R", \*(L"pending\*(R"
layers, and also the \*(L"mmap\*(R" and \*(L"win32\*(R" layers if applicable.
(The \*(L"win32\*(R" is currently unfinished and unused, to see what is used
instead in Win32, see \*(L"Querying the layers of filehandles\*(R" in PerlIO .)
.Sp
PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.
.Sp
PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on \s-1CPAN.\s0
.IP "\(bu" 4
Perl implementations
.Sp
PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on \s-1CPAN.\s0
.PP
If you are creating a PerlIO layer, you may want to be lazy, in other
words, implement only the methods that interest you.  The other methods
you can either replace with the \*(L"blank\*(R" methods
.PP
.Vb 2
\&    PerlIOBase_noop_ok
\&    PerlIOBase_noop_fail
.Ve
.PP
(which do nothing, and return zero and \-1, respectively) or for
certain methods you may assume a default behaviour by using a \s-1NULL\s0
method.  The Open method looks for help in the 'parent' layer.
The following table summarizes the behaviour:
.PP
.Vb 1
\&    method      behaviour with NULL
\&
\&    Clearerr    PerlIOBase_clearerr
\&    Close       PerlIOBase_close
\&    Dup         PerlIOBase_dup
\&    Eof         PerlIOBase_eof
\&    Error       PerlIOBase_error
\&    Fileno      PerlIOBase_fileno
\&    Fill        FAILURE
\&    Flush       SUCCESS
\&    Getarg      SUCCESS
\&    Get_base    FAILURE
\&    Get_bufsiz  FAILURE
\&    Get_cnt     FAILURE
\&    Get_ptr     FAILURE
\&    Open        INHERITED
\&    Popped      SUCCESS
\&    Pushed      SUCCESS
\&    Read        PerlIOBase_read
\&    Seek        FAILURE
\&    Set_cnt     FAILURE
\&    Set_ptrcnt  FAILURE
\&    Setlinebuf  PerlIOBase_setlinebuf
\&    Tell        FAILURE
\&    Unread      PerlIOBase_unread
\&    Write       FAILURE
\&
\& FAILURE        Set errno (to EINVAL in Unixish, to LIB$_INVARG in VMS) and
\&                return \-1 (for numeric return values) or NULL (for pointers)
\& INHERITED      Inherited from the layer below
\& SUCCESS        Return 0 (for numeric return values) or a pointer
.Ve
.SS "Core Layers"
.IX Subsection "Core Layers"
The file \f(CW\*(C`perlio.c\*(C'\fR provides the following layers:
.ie n .IP """unix""" 4
.el .IP "``unix''" 4
.IX Item "unix"
A basic non-buffered layer which calls Unix/POSIX \f(CW\*(C`read()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR,
\&\f(CW\*(C`lseek()\*(C'\fR, \f(CW\*(C`close()\*(C'\fR. No buffering. Even on platforms that distinguish
between O_TEXT and O_BINARY this layer is always O_BINARY.
.ie n .IP """perlio""" 4
.el .IP "``perlio''" 4
.IX Item "perlio"
A very complete generic buffering layer which provides the whole of
PerlIO \s-1API.\s0 It is also intended to be used as a \*(L"base class\*(R" for other
layers. (For example its \f(CW\*(C`Read()\*(C'\fR method is implemented in terms of
the \f(CW\*(C`Get_cnt()\*(C'\fR/\f(CW\*(C`Get_ptr()\*(C'\fR/\f(CW\*(C`Set_ptrcnt()\*(C'\fR methods).
.Sp
\&\*(L"perlio\*(R" over \*(L"unix\*(R" provides a complete replacement for stdio as seen
via PerlIO \s-1API.\s0 This is the default for \s-1USE_PERLIO\s0 when system's stdio
does not permit perl's \*(L"fast gets\*(R" access, and which do not
distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """stdio""" 4
.el .IP "``stdio''" 4
.IX Item "stdio"
A layer which provides the PerlIO \s-1API\s0 via the layer scheme, but
implements it by calling system's stdio. This is (currently) the default
if system's stdio provides sufficient access to allow perl's \*(L"fast gets\*(R"
access and which do not distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """crlf""" 4
.el .IP "``crlf''" 4
.IX Item "crlf"
A layer derived using \*(L"perlio\*(R" as a base class. It provides Win32\-like
\&\*(L"\en\*(R" to \s-1CR,LF\s0 translation. Can either be applied above \*(L"perlio\*(R" or serve
as the buffer layer itself. \*(L"crlf\*(R" over \*(L"unix\*(R" is the default if system
distinguishes between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR opens. (At some point
\&\*(L"unix\*(R" will be replaced by a \*(L"native\*(R" Win32 \s-1IO\s0 layer on that platform,
as Win32's read/write layer has various drawbacks.) The \*(L"crlf\*(R" layer is
a reasonable model for a layer which transforms data in some way.
.ie n .IP """mmap""" 4
.el .IP "``mmap''" 4
.IX Item "mmap"
If Configure detects \f(CW\*(C`mmap()\*(C'\fR functions this layer is provided (with
\&\*(L"perlio\*(R" as a \*(L"base\*(R") which does \*(L"read\*(R" operations by \fImmap()\fRing the
file. Performance improvement is marginal on modern systems, so it is
mainly there as a proof of concept. It is likely to be unbundled from
the core at some point. The \*(L"mmap\*(R" layer is a reasonable model for a
minimalist \*(L"derived\*(R" layer.
.ie n .IP """pending""" 4
.el .IP "``pending''" 4
.IX Item "pending"
An \*(L"internal\*(R" derivative of \*(L"perlio\*(R" which can be used to provide
\&\fIUnread()\fR function for layers which have no buffer or cannot be
bothered.  (Basically this layer's \f(CW\*(C`Fill()\*(C'\fR pops itself off the stack
and so resumes reading from layer below.)
.ie n .IP """raw""" 4
.el .IP "``raw''" 4
.IX Item "raw"
A dummy layer which never exists on the layer stack. Instead when
\&\*(L"pushed\*(R" it actually pops the stack removing itself, it then calls
Binmode function table entry on all the layers in the stack \- normally
this (via PerlIOBase_binmode) removes any layers which do not have
\&\f(CW\*(C`PERLIO_K_RAW\*(C'\fR bit set. Layers can modify that behaviour by defining
their own Binmode entry.
.ie n .IP """utf8""" 4
.el .IP "``utf8''" 4
.IX Item "utf8"
Another dummy layer. When pushed it pops itself and sets the
\&\f(CW\*(C`PERLIO_F_UTF8\*(C'\fR flag on the layer which was (and now is once more)
the top of the stack.
.PP
In addition \fIperlio.c\fR also provides a number of \f(CW\*(C`PerlIOBase_xxxx()\*(C'\fR
functions which are intended to be used in the table slots of classes
which do not need to do anything special for a particular method.
.SS "Extension Layers"
.IX Subsection "Extension Layers"
Layers can be made available by extension modules. When an unknown layer
is encountered the PerlIO code will perform the equivalent of :
.PP
.Vb 1
\&   use PerlIO \*(Aqlayer\*(Aq;
.Ve
.PP
Where \fIlayer\fR is the unknown layer. \fIPerlIO.pm\fR will then attempt to:
.PP
.Vb 1
\&   require PerlIO::layer;
.Ve
.PP
If after that process the layer is still not defined then the \f(CW\*(C`open\*(C'\fR
will fail.
.PP
The following extension layers are bundled with perl:
.ie n .IP """:encoding""" 4
.el .IP "``:encoding''" 4
.IX Item ":encoding"
.Vb 1
\&   use Encoding;
.Ve
.Sp
makes this layer available, although \fIPerlIO.pm\fR \*(L"knows\*(R" where to
find it.  It is an example of a layer which takes an argument as it is
called thus:
.Sp
.Vb 1
\&   open( $fh, "<:encoding(iso\-8859\-7)", $pathname );
.Ve
.ie n .IP """:scalar""" 4
.el .IP "``:scalar''" 4
.IX Item ":scalar"
Provides support for reading data from and writing data to a scalar.
.Sp
.Vb 1
\&   open( $fh, "+<:scalar", \e$scalar );
.Ve
.Sp
When a handle is so opened, then reads get bytes from the string value
of \fI\f(CI$scalar\fI\fR, and writes change the value. In both cases the position
in \fI\f(CI$scalar\fI\fR starts as zero but can be altered via \f(CW\*(C`seek\*(C'\fR, and
determined via \f(CW\*(C`tell\*(C'\fR.
.Sp
Please note that this layer is implied when calling \fIopen()\fR thus:
.Sp
.Vb 1
\&   open( $fh, "+<", \e$scalar );
.Ve
.ie n .IP """:via""" 4
.el .IP "``:via''" 4
.IX Item ":via"
Provided to allow layers to be implemented as Perl code.  For instance:
.Sp
.Vb 2
\&   use PerlIO::via::StripHTML;
\&   open( my $fh, "<:via(StripHTML)", "index.html" );
.Ve
.Sp
See PerlIO::via for details.
.SH "TODO"
.IX Header "TODO"
Things that need to be done to improve this document.
.IP "\(bu" 4
Explain how to make a valid fh without going through \fIopen()\fR(i.e. apply
a layer). For example if the file is not opened through perl, but we
want to get back a fh, like it was opened by Perl.
.Sp
How PerlIO_apply_layera fits in, where its docs, was it made public?
.Sp
Currently the example could be something like this:
.Sp
.Vb 8
\&  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
\&  {
\&      char *mode; /* "w", "r", etc */
\&      const char *layers = ":APR"; /* the layer name */
\&      PerlIO *f = PerlIO_allocate(aTHX);
\&      if (!f) {
\&          return NULL;
\&      }
\&
\&      PerlIO_apply_layers(aTHX_ f, mode, layers);
\&
\&      if (f) {
\&          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
\&          /* fill in the st struct, as in _open() */
\&          st\->file = file;
\&          PerlIOBase(f)\->flags |= PERLIO_F_OPEN;
\&
\&          return f;
\&      }
\&      return NULL;
\&  }
.Ve
.IP "\(bu" 4
fix/add the documentation in places marked as \s-1XXX.\s0
.IP "\(bu" 4
The handling of errors by the layer is not specified. e.g. when $!
should be set explicitly, when the error handling should be just
delegated to the top layer.
.Sp
Probably give some hints on using \s-1\fISETERRNO\s0()\fR or pointers to where they
can be found.
.IP "\(bu" 4
I think it would help to give some concrete examples to make it easier
to understand the \s-1API.\s0 Of course I agree that the \s-1API\s0 has to be
concise, but since there is no second document that is more of a
guide, I think that it'd make it easier to start with the doc which is
an \s-1API,\s0 but has examples in it in places where things are unclear, to
a person who is not a PerlIO guru (yet).
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perliol5.16.1                                0100644 0001750 0001750 00000130704 12566207421 022722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIOL 1"
.TH PERLIOL 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perliol \- C API for Perl's implementation of IO in Layers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    /* Defining a layer ... */
\&    #include <perliol.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the behavior and implementation of the PerlIO
abstraction described in perlapio when \f(CW\*(C`USE_PERLIO\*(C'\fR is defined (and
\&\f(CW\*(C`USE_SFIO\*(C'\fR is not).
.SS "History and Background"
.IX Subsection "History and Background"
The PerlIO abstraction was introduced in perl5.003_02 but languished as
just an abstraction until perl5.7.0. However during that time a number
of perl extensions switched to using it, so the \s-1API\s0 is mostly fixed to
maintain (source) compatibility.
.PP
The aim of the implementation is to provide the PerlIO \s-1API\s0 in a flexible
and platform neutral manner. It is also a trial of an \*(L"Object Oriented
C, with vtables\*(R" approach which may be applied to Perl 6.
.SS "Basic Structure"
.IX Subsection "Basic Structure"
PerlIO is a stack of layers.
.PP
The low levels of the stack work with the low-level operating system
calls (file descriptors in C) getting bytes in and out, the higher
layers of the stack buffer, filter, and otherwise manipulate the I/O,
and return characters (or bytes) to Perl.  Terms \fIabove\fR and \fIbelow\fR
are used to refer to the relative positioning of the stack layers.
.PP
A layer contains a \*(L"vtable\*(R", the table of I/O operations (at C level
a table of function pointers), and status flags.  The functions in the
vtable implement operations like \*(L"open\*(R", \*(L"read\*(R", and \*(L"write\*(R".
.PP
When I/O, for example \*(L"read\*(R", is requested, the request goes from Perl
first down the stack using \*(L"read\*(R" functions of each layer, then at the
bottom the input is requested from the operating system services, then
the result is returned up the stack, finally being interpreted as Perl
data.
.PP
The requests do not necessarily go always all the way down to the
operating system: that's where PerlIO buffering comes into play.
.PP
When you do an \fIopen()\fR and specify extra PerlIO layers to be deployed,
the layers you specify are \*(L"pushed\*(R" on top of the already existing
default stack.  One way to see it is that \*(L"operating system is
on the left\*(R" and \*(L"Perl is on the right\*(R".
.PP
What exact layers are in this default stack depends on a lot of
things: your operating system, Perl version, Perl compile time
configuration, and Perl runtime configuration.  See PerlIO,
\&\*(L"\s-1PERLIO\s0\*(R" in perlrun, and open for more information.
.PP
\&\fIbinmode()\fR operates similarly to \fIopen()\fR: by default the specified
layers are pushed on top of the existing stack.
.PP
However, note that even as the specified layers are \*(L"pushed on top\*(R"
for \fIopen()\fR and \fIbinmode()\fR, this doesn't mean that the effects are
limited to the \*(L"top\*(R": PerlIO layers can be very 'active' and inspect
and affect layers also deeper in the stack.  As an example there
is a layer called \*(L"raw\*(R" which repeatedly \*(L"pops\*(R" layers until
it reaches the first layer that has declared itself capable of
handling binary data.  The \*(L"pushed\*(R" layers are processed in left-to-right
order.
.PP
\&\fIsysopen()\fR operates (unsurprisingly) at a lower level in the stack than
\&\fIopen()\fR.  For example in Unix or Unix-like systems \fIsysopen()\fR operates
directly at the level of file descriptors: in the terms of PerlIO
layers, it uses only the \*(L"unix\*(R" layer, which is a rather thin wrapper
on top of the Unix file descriptors.
.SS "Layers vs Disciplines"
.IX Subsection "Layers vs Disciplines"
Initial discussion of the ability to modify \s-1IO\s0 streams behaviour used
the term \*(L"discipline\*(R" for the entities which were added. This came (I
believe) from the use of the term in \*(L"sfio\*(R", which in turn borrowed it
from \*(L"line disciplines\*(R" on Unix terminals. However, this document (and
the C code) uses the term \*(L"layer\*(R".
.PP
This is, I hope, a natural term given the implementation, and should
avoid connotations that are inherent in earlier uses of \*(L"discipline\*(R"
for things which are rather different.
.SS "Data Structures"
.IX Subsection "Data Structures"
The basic data structure is a PerlIOl:
.PP
.Vb 3
\&        typedef struct _PerlIO PerlIOl;
\&        typedef struct _PerlIO_funcs PerlIO_funcs;
\&        typedef PerlIOl *PerlIO;
\&
\&        struct _PerlIO
\&        {
\&         PerlIOl *      next;       /* Lower layer */
\&         PerlIO_funcs * tab;        /* Functions for this layer */
\&         IV             flags;      /* Various flags for state */
\&        };
.Ve
.PP
A \f(CW\*(C`PerlIOl *\*(C'\fR is a pointer to the struct, and the \fIapplication\fR
level \f(CW\*(C`PerlIO *\*(C'\fR is a pointer to a \f(CW\*(C`PerlIOl *\*(C'\fR \- i.e. a pointer
to a pointer to the struct. This allows the application level \f(CW\*(C`PerlIO *\*(C'\fR
to remain constant while the actual \f(CW\*(C`PerlIOl *\*(C'\fR underneath
changes. (Compare perl's \f(CW\*(C`SV *\*(C'\fR which remains constant while its
\&\f(CW\*(C`sv_any\*(C'\fR field changes as the scalar's type changes.) An \s-1IO\s0 stream is
then in general represented as a pointer to this linked-list of
\&\*(L"layers\*(R".
.PP
It should be noted that because of the double indirection in a \f(CW\*(C`PerlIO *\*(C'\fR,
a \f(CW\*(C`&(perlio\->next)\*(C'\fR \*(L"is\*(R" a \f(CW\*(C`PerlIO *\*(C'\fR, and so to some degree
at least one layer can use the \*(L"standard\*(R" \s-1API\s0 on the next layer down.
.PP
A \*(L"layer\*(R" is composed of two parts:
.IP "1." 4
The functions and attributes of the \*(L"layer class\*(R".
.IP "2." 4
The per-instance data for a particular handle.
.SS "Functions and Attributes"
.IX Subsection "Functions and Attributes"
The functions and attributes are accessed via the \*(L"tab\*(R" (for table)
member of \f(CW\*(C`PerlIOl\*(C'\fR. The functions (methods of the layer \*(L"class\*(R") are
fixed, and are defined by the \f(CW\*(C`PerlIO_funcs\*(C'\fR type. They are broadly the
same as the public \f(CW\*(C`PerlIO_xxxxx\*(C'\fR functions:
.PP
.Vb 10
\&  struct _PerlIO_funcs
\&  {
\&   Size_t               fsize;
\&   char *               name;
\&   Size_t               size;
\&   IV           kind;
\&   IV           (*Pushed)(pTHX_ PerlIO *f,const char *mode,SV *arg, PerlIO_funcs *tab);
\&   IV           (*Popped)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
\&   IV           (*Binmode)(pTHX_ PerlIO *f);
\&   SV *         (*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
\&   IV           (*Fileno)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Dup)(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
\&   /* Unix\-like functions \- cf sfio line disciplines */
\&   SSize_t      (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
\&   SSize_t      (*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   SSize_t      (*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   IV           (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
\&   Off_t        (*Tell)(pTHX_ PerlIO *f);
\&   IV           (*Close)(pTHX_ PerlIO *f);
\&   /* Stdio\-like buffered IO functions */
\&   IV           (*Flush)(pTHX_ PerlIO *f);
\&   IV           (*Fill)(pTHX_ PerlIO *f);
\&   IV           (*Eof)(pTHX_ PerlIO *f);
\&   IV           (*Error)(pTHX_ PerlIO *f);
\&   void         (*Clearerr)(pTHX_ PerlIO *f);
\&   void         (*Setlinebuf)(pTHX_ PerlIO *f);
\&   /* Perl\*(Aqs snooping functions */
\&   STDCHAR *    (*Get_base)(pTHX_ PerlIO *f);
\&   Size_t       (*Get_bufsiz)(pTHX_ PerlIO *f);
\&   STDCHAR *    (*Get_ptr)(pTHX_ PerlIO *f);
\&   SSize_t      (*Get_cnt)(pTHX_ PerlIO *f);
\&   void         (*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
\&  };
.Ve
.PP
The first few members of the struct give a function table size for
compatibility check \*(L"name\*(R" for the layer, the  size to \f(CW\*(C`malloc\*(C'\fR for the per-instance data,
and some flags which are attributes of the class as whole (such as whether it is a buffering
layer), then follow the functions which fall into four basic groups:
.IP "1." 4
Opening and setup functions
.IP "2." 4
Basic \s-1IO\s0 operations
.IP "3." 4
Stdio class buffering options.
.IP "4." 4
Functions to support Perl's traditional \*(L"fast\*(R" access to the buffer.
.PP
A layer does not have to implement all the functions, but the whole
table has to be present. Unimplemented slots can be \s-1NULL\s0 (which will
result in an error when called) or can be filled in with stubs to
\&\*(L"inherit\*(R" behaviour from a \*(L"base class\*(R". This \*(L"inheritance\*(R" is fixed
for all instances of the layer, but as the layer chooses which stubs
to populate the table, limited \*(L"multiple inheritance\*(R" is possible.
.SS "Per-instance Data"
.IX Subsection "Per-instance Data"
The per-instance data are held in memory beyond the basic PerlIOl
struct, by making a PerlIOl the first member of the layer's struct
thus:
.PP
.Vb 10
\&        typedef struct
\&        {
\&         struct _PerlIO base;       /* Base "class" info */
\&         STDCHAR *      buf;        /* Start of buffer */
\&         STDCHAR *      end;        /* End of valid part of buffer */
\&         STDCHAR *      ptr;        /* Current position in buffer */
\&         Off_t          posn;       /* Offset of buf into the file */
\&         Size_t         bufsiz;     /* Real size of buffer */
\&         IV             oneword;    /* Emergency buffer */
\&        } PerlIOBuf;
.Ve
.PP
In this way (as for perl's scalars) a pointer to a PerlIOBuf can be
treated as a pointer to a PerlIOl.
.SS "Layers in action."
.IX Subsection "Layers in action."
.Vb 8
\&                table           perlio          unix
\&            |           |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&   PerlIO \->|           |\-\-\->|  next    |\-\-\->|  NULL  |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&            |           |    |  buffer  |    |   fd   |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    |          |    +\-\-\-\-\-\-\-\-+
\&            |           |    +\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
The above attempts to show how the layer scheme works in a simple case.
The application's \f(CW\*(C`PerlIO *\*(C'\fR points to an entry in the table(s)
representing open (allocated) handles. For example the first three slots
in the table correspond to \f(CW\*(C`stdin\*(C'\fR,\f(CW\*(C`stdout\*(C'\fR and \f(CW\*(C`stderr\*(C'\fR. The table
in turn points to the current \*(L"top\*(R" layer for the handle \- in this case
an instance of the generic buffering layer \*(L"perlio\*(R". That layer in turn
points to the next layer down \- in this case the low-level \*(L"unix\*(R" layer.
.PP
The above is roughly equivalent to a \*(L"stdio\*(R" buffered stream, but with
much more flexibility:
.IP "\(bu" 4
If Unix level \f(CW\*(C`read\*(C'\fR/\f(CW\*(C`write\*(C'\fR/\f(CW\*(C`lseek\*(C'\fR is not appropriate for (say)
sockets then the \*(L"unix\*(R" layer can be replaced (at open time or even
dynamically) with a \*(L"socket\*(R" layer.
.IP "\(bu" 4
Different handles can have different buffering schemes. The \*(L"top\*(R"
layer could be the \*(L"mmap\*(R" layer if reading disk files was quicker
using \f(CW\*(C`mmap\*(C'\fR than \f(CW\*(C`read\*(C'\fR. An \*(L"unbuffered\*(R" stream can be implemented
simply by not having a buffer layer.
.IP "\(bu" 4
Extra layers can be inserted to process the data as it flows through.
This was the driving need for including the scheme in perl 5.7.0+ \- we
needed a mechanism to allow data to be translated between perl's
internal encoding (conceptually at least Unicode as \s-1UTF\-8\s0), and the
\&\*(L"native\*(R" format used by the system. This is provided by the
\&\*(L":encoding(xxxx)\*(R" layer which typically sits above the buffering layer.
.IP "\(bu" 4
A layer can be added that does \*(L"\en\*(R" to \s-1CRLF\s0 translation. This layer
can be used on any platform, not just those that normally do such
things.
.SS "Per-instance flag bits"
.IX Subsection "Per-instance flag bits"
The generic flag bits are a hybrid of \f(CW\*(C`O_XXXXX\*(C'\fR style flags deduced
from the mode string passed to \f(CW\*(C`PerlIO_open()\*(C'\fR, and state bits for
typical buffer layers.
.IP "\s-1PERLIO_F_EOF\s0" 4
.IX Item "PERLIO_F_EOF"
End of file.
.IP "\s-1PERLIO_F_CANWRITE\s0" 4
.IX Item "PERLIO_F_CANWRITE"
Writes are permitted, i.e. opened as \*(L"w\*(R" or \*(L"r+\*(R" or \*(L"a\*(R", etc.
.IP "\s-1PERLIO_F_CANREAD\s0" 4
.IX Item "PERLIO_F_CANREAD"
Reads are permitted i.e. opened \*(L"r\*(R" or \*(L"w+\*(R" (or even \*(L"a+\*(R" \- ick).
.IP "\s-1PERLIO_F_ERROR\s0" 4
.IX Item "PERLIO_F_ERROR"
An error has occurred (for \f(CW\*(C`PerlIO_error()\*(C'\fR).
.IP "\s-1PERLIO_F_TRUNCATE\s0" 4
.IX Item "PERLIO_F_TRUNCATE"
Truncate file suggested by open mode.
.IP "\s-1PERLIO_F_APPEND\s0" 4
.IX Item "PERLIO_F_APPEND"
All writes should be appends.
.IP "\s-1PERLIO_F_CRLF\s0" 4
.IX Item "PERLIO_F_CRLF"
Layer is performing Win32\-like \*(L"\en\*(R" mapped to \s-1CR\s0,LF for output and \s-1CR\s0,LF
mapped to \*(L"\en\*(R" for input. Normally the provided \*(L"crlf\*(R" layer is the only
layer that need bother about this. \f(CW\*(C`PerlIO_binmode()\*(C'\fR will mess with this
flag rather than add/remove layers if the \f(CW\*(C`PERLIO_K_CANCRLF\*(C'\fR bit is set
for the layers class.
.IP "\s-1PERLIO_F_UTF8\s0" 4
.IX Item "PERLIO_F_UTF8"
Data written to this layer should be \s-1UTF\-8\s0 encoded; data provided
by this layer should be considered \s-1UTF\-8\s0 encoded. Can be set on any layer
by \*(L":utf8\*(R" dummy layer. Also set on \*(L":encoding\*(R" layer.
.IP "\s-1PERLIO_F_UNBUF\s0" 4
.IX Item "PERLIO_F_UNBUF"
Layer is unbuffered \- i.e. write to next layer down should occur for
each write to this layer.
.IP "\s-1PERLIO_F_WRBUF\s0" 4
.IX Item "PERLIO_F_WRBUF"
The buffer for this layer currently holds data written to it but not sent
to next layer.
.IP "\s-1PERLIO_F_RDBUF\s0" 4
.IX Item "PERLIO_F_RDBUF"
The buffer for this layer currently holds unconsumed data read from
layer below.
.IP "\s-1PERLIO_F_LINEBUF\s0" 4
.IX Item "PERLIO_F_LINEBUF"
Layer is line buffered. Write data should be passed to next layer down
whenever a \*(L"\en\*(R" is seen. Any data beyond the \*(L"\en\*(R" should then be
processed.
.IP "\s-1PERLIO_F_TEMP\s0" 4
.IX Item "PERLIO_F_TEMP"
File has been \f(CW\*(C`unlink()\*(C'\fRed, or should be deleted on \f(CW\*(C`close()\*(C'\fR.
.IP "\s-1PERLIO_F_OPEN\s0" 4
.IX Item "PERLIO_F_OPEN"
Handle is open.
.IP "\s-1PERLIO_F_FASTGETS\s0" 4
.IX Item "PERLIO_F_FASTGETS"
This instance of this layer supports the "fast \f(CW\*(C`gets\*(C'\fR" interface.
Normally set based on \f(CW\*(C`PERLIO_K_FASTGETS\*(C'\fR for the class and by the
existence of the function(s) in the table. However a class that
normally provides that interface may need to avoid it on a
particular instance. The \*(L"pending\*(R" layer needs to do this when
it is pushed above a layer which does not support the interface.
(Perl's \f(CW\*(C`sv_gets()\*(C'\fR does not expect the streams fast \f(CW\*(C`gets\*(C'\fR behaviour
to change during one \*(L"get\*(R".)
.SS "Methods in Detail"
.IX Subsection "Methods in Detail"
.IP "fsize" 4
.IX Item "fsize"
.Vb 1
\&        Size_t fsize;
.Ve
.Sp
Size of the function table. This is compared against the value PerlIO
code \*(L"knows\*(R" as a compatibility check. Future versions \fImay\fR be able
to tolerate layers compiled against an old version of the headers.
.IP "name" 4
.IX Item "name"
.Vb 1
\&        char * name;
.Ve
.Sp
The name of the layer whose \fIopen()\fR method Perl should invoke on
\&\fIopen()\fR.  For example if the layer is called \s-1APR\s0, you will call:
.Sp
.Vb 1
\&  open $fh, ">:APR", ...
.Ve
.Sp
and Perl knows that it has to invoke the \fIPerlIOAPR_open()\fR method
implemented by the \s-1APR\s0 layer.
.IP "size" 4
.IX Item "size"
.Vb 1
\&        Size_t size;
.Ve
.Sp
The size of the per-instance data structure, e.g.:
.Sp
.Vb 1
\&  sizeof(PerlIOAPR)
.Ve
.Sp
If this field is zero then \f(CW\*(C`PerlIO_pushed\*(C'\fR does not malloc anything
and assumes layer's Pushed function will do any required layer stack
manipulation \- used to avoid malloc/free overhead for dummy layers.
If the field is non-zero it must be at least the size of \f(CW\*(C`PerlIOl\*(C'\fR,
\&\f(CW\*(C`PerlIO_pushed\*(C'\fR will allocate memory for the layer's data structures
and link new layer onto the stream's stack. (If the layer's Pushed
method returns an error indication the layer is popped again.)
.IP "kind" 4
.IX Item "kind"
.Vb 1
\&        IV kind;
.Ve
.RS 4
.IP "\(bu" 4
\&\s-1PERLIO_K_BUFFERED\s0
.Sp
The layer is buffered.
.IP "\(bu" 4
\&\s-1PERLIO_K_RAW\s0
.Sp
The layer is acceptable to have in a binmode(\s-1FH\s0) stack \- i.e. it does not
(or will configure itself not to) transform bytes passing through it.
.IP "\(bu" 4
\&\s-1PERLIO_K_CANCRLF\s0
.Sp
Layer can translate between \*(L"\en\*(R" and \s-1CRLF\s0 line ends.
.IP "\(bu" 4
\&\s-1PERLIO_K_FASTGETS\s0
.Sp
Layer allows buffer snooping.
.IP "\(bu" 4
\&\s-1PERLIO_K_MULTIARG\s0
.Sp
Used when the layer's \fIopen()\fR accepts more arguments than usual. The
extra arguments should come not before the \f(CW\*(C`MODE\*(C'\fR argument. When this
flag is used it's up to the layer to validate the args.
.RE
.RS 4
.RE
.IP "Pushed" 4
.IX Item "Pushed"
.Vb 1
\&        IV      (*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);
.Ve
.Sp
The only absolutely mandatory method. Called when the layer is pushed
onto the stack.  The \f(CW\*(C`mode\*(C'\fR argument may be \s-1NULL\s0 if this occurs
post-open. The \f(CW\*(C`arg\*(C'\fR will be non\-\f(CW\*(C`NULL\*(C'\fR if an argument string was
passed. In most cases this should call \f(CW\*(C`PerlIOBase_pushed()\*(C'\fR to
convert \f(CW\*(C`mode\*(C'\fR into the appropriate \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags in
addition to any actions the layer itself takes.  If a layer is not
expecting an argument it need neither save the one passed to it, nor
provide \f(CW\*(C`Getarg()\*(C'\fR (it could perhaps \f(CW\*(C`Perl_warn\*(C'\fR that the argument
was un-expected).
.Sp
Returns 0 on success. On failure returns \-1 and should set errno.
.IP "Popped" 4
.IX Item "Popped"
.Vb 1
\&        IV      (*Popped)(pTHX_ PerlIO *f);
.Ve
.Sp
Called when the layer is popped from the stack. A layer will normally
be popped after \f(CW\*(C`Close()\*(C'\fR is called. But a layer can be popped
without being closed if the program is dynamically managing layers on
the stream. In such cases \f(CW\*(C`Popped()\*(C'\fR should free any resources
(buffers, translation tables, ...) not held directly in the layer's
struct.  It should also \f(CW\*(C`Unread()\*(C'\fR any unconsumed data that has been
read and buffered from the layer below back to that layer, so that it
can be re-provided to what ever is now above.
.Sp
Returns 0 on success and failure.  If \f(CW\*(C`Popped()\*(C'\fR returns \fItrue\fR then
\&\fIperlio.c\fR assumes that either the layer has popped itself, or the
layer is super special and needs to be retained for other reasons.
In most cases it should return \fIfalse\fR.
.IP "Open" 4
.IX Item "Open"
.Vb 1
\&        PerlIO *        (*Open)(...);
.Ve
.Sp
The \f(CW\*(C`Open()\*(C'\fR method has lots of arguments because it combines the
functions of perl's \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`PerlIO_open\*(C'\fR, perl's \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`PerlIO_fdopen\*(C'\fR and \f(CW\*(C`PerlIO_reopen\*(C'\fR.  The full prototype is as
follows:
.Sp
.Vb 6
\& PerlIO *       (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
.Ve
.Sp
Open should (perhaps indirectly) call \f(CW\*(C`PerlIO_allocate()\*(C'\fR to allocate
a slot in the table and associate it with the layers information for
the opened file, by calling \f(CW\*(C`PerlIO_push\*(C'\fR.  The \fIlayers\fR is an
array of all the layers destined for the \f(CW\*(C`PerlIO *\*(C'\fR, and any
arguments passed to them, \fIn\fR is the index into that array of the
layer being called. The macro \f(CW\*(C`PerlIOArg\*(C'\fR will return a (possibly
\&\f(CW\*(C`NULL\*(C'\fR) \s-1SV\s0 * for the argument passed to the layer.
.Sp
The \fImode\fR string is an "\f(CW\*(C`fopen()\*(C'\fR\-like" string which would match
the regular expression \f(CW\*(C`/^[I#]?[rwa]\e+?[bt]?$/\*(C'\fR.
.Sp
The \f(CW\*(AqI\*(Aq\fR prefix is used during creation of \f(CW\*(C`stdin\*(C'\fR..\f(CW\*(C`stderr\*(C'\fR via
special \f(CW\*(C`PerlIO_fdopen\*(C'\fR calls; the \f(CW\*(Aq#\*(Aq\fR prefix means that this is
\&\f(CW\*(C`sysopen\*(C'\fR and that \fIimode\fR and \fIperm\fR should be passed to
\&\f(CW\*(C`PerlLIO_open3\*(C'\fR; \f(CW\*(Aqr\*(Aq\fR means \fBr\fRead, \f(CW\*(Aqw\*(Aq\fR means \fBw\fRrite and
\&\f(CW\*(Aqa\*(Aq\fR means \fBa\fRppend. The \f(CW\*(Aq+\*(Aq\fR suffix means that both reading and
writing/appending are permitted.  The \f(CW\*(Aqb\*(Aq\fR suffix means file should
be binary, and \f(CW\*(Aqt\*(Aq\fR means it is text. (Almost all layers should do
the \s-1IO\s0 in binary mode, and ignore the b/t bits. The \f(CW\*(C`:crlf\*(C'\fR layer
should be pushed to handle the distinction.)
.Sp
If \fIold\fR is not \f(CW\*(C`NULL\*(C'\fR then this is a \f(CW\*(C`PerlIO_reopen\*(C'\fR. Perl itself
does not use this (yet?) and semantics are a little vague.
.Sp
If \fIfd\fR not negative then it is the numeric file descriptor \fIfd\fR,
which will be open in a manner compatible with the supplied mode
string, the call is thus equivalent to \f(CW\*(C`PerlIO_fdopen\*(C'\fR. In this case
\&\fInargs\fR will be zero.
.Sp
If \fInargs\fR is greater than zero then it gives the number of arguments
passed to \f(CW\*(C`open\*(C'\fR, otherwise it will be 1 if for example
\&\f(CW\*(C`PerlIO_open\*(C'\fR was called.  In simple cases SvPV_nolen(*args) is the
pathname to open.
.Sp
If a layer provides \f(CW\*(C`Open()\*(C'\fR it should normally call the \f(CW\*(C`Open()\*(C'\fR
method of next layer down (if any) and then push itself on top if that
succeeds.  \f(CW\*(C`PerlIOBase_open\*(C'\fR is provided to do exactly that, so in
most cases you don't have to write your own \f(CW\*(C`Open()\*(C'\fR method.  If this
method is not defined, other layers may have difficulty pushing
themselves on top of it during open.
.Sp
If \f(CW\*(C`PerlIO_push\*(C'\fR was performed and open has failed, it must
\&\f(CW\*(C`PerlIO_pop\*(C'\fR itself, since if it's not, the layer won't be removed
and may cause bad problems.
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Binmode" 4
.IX Item "Binmode"
.Vb 1
\&        IV        (*Binmode)(pTHX_ PerlIO *f);
.Ve
.Sp
Optional. Used when \f(CW\*(C`:raw\*(C'\fR layer is pushed (explicitly or as a result
of binmode(\s-1FH\s0)). If not present layer will be popped. If present
should configure layer as binary (or pop itself) and return 0.
If it returns \-1 for error \f(CW\*(C`binmode\*(C'\fR will fail with layer
still on the stack.
.IP "Getarg" 4
.IX Item "Getarg"
.Vb 2
\&        SV *      (*Getarg)(pTHX_ PerlIO *f,
\&                            CLONE_PARAMS *param, int flags);
.Ve
.Sp
Optional. If present should return an \s-1SV\s0 * representing the string
argument passed to the layer when it was
pushed. e.g. \*(L":encoding(ascii)\*(R" would return an SvPV with value
\&\*(L"ascii\*(R". (\fIparam\fR and \fIflags\fR arguments can be ignored in most
cases)
.Sp
\&\f(CW\*(C`Dup\*(C'\fR uses \f(CW\*(C`Getarg\*(C'\fR to retrieve the argument originally passed to
\&\f(CW\*(C`Pushed\*(C'\fR, so you must implement this function if your layer has an
extra argument to \f(CW\*(C`Pushed\*(C'\fR and will ever be \f(CW\*(C`Dup\*(C'\fRed.
.IP "Fileno" 4
.IX Item "Fileno"
.Vb 1
\&        IV        (*Fileno)(pTHX_ PerlIO *f);
.Ve
.Sp
Returns the Unix/Posix numeric file descriptor for the handle. Normally
\&\f(CW\*(C`PerlIOBase_fileno()\*(C'\fR (which just asks next layer down) will suffice
for this.
.Sp
Returns \-1 on error, which is considered to include the case where the
layer cannot provide such a file descriptor.
.IP "Dup" 4
.IX Item "Dup"
.Vb 2
\&        PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
\&                        CLONE_PARAMS *param, int flags);
.Ve
.Sp
\&\s-1XXX:\s0 Needs more docs.
.Sp
Used as part of the \*(L"clone\*(R" process when a thread is spawned (in which
case param will be non-NULL) and when a stream is being duplicated via
\&'&' in the \f(CW\*(C`open\*(C'\fR.
.Sp
Similar to \f(CW\*(C`Open\*(C'\fR, returns PerlIO* on success, \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Read" 4
.IX Item "Read"
.Vb 1
\&        SSize_t (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
.Ve
.Sp
Basic read operation.
.Sp
Typically will call \f(CW\*(C`Fill\*(C'\fR and manipulate pointers (possibly via the
\&\s-1API\s0).  \f(CW\*(C`PerlIOBuf_read()\*(C'\fR may be suitable for derived classes which
provide \*(L"fast gets\*(R" methods.
.Sp
Returns actual bytes read, or \-1 on an error.
.IP "Unread" 4
.IX Item "Unread"
.Vb 2
\&        SSize_t (*Unread)(pTHX_ PerlIO *f,
\&                          const void *vbuf, Size_t count);
.Ve
.Sp
A superset of stdio's \f(CW\*(C`ungetc()\*(C'\fR. Should arrange for future reads to
see the bytes in \f(CW\*(C`vbuf\*(C'\fR. If there is no obviously better implementation
then \f(CW\*(C`PerlIOBase_unread()\*(C'\fR provides the function by pushing a \*(L"fake\*(R"
\&\*(L"pending\*(R" layer above the calling layer.
.Sp
Returns the number of unread chars.
.IP "Write" 4
.IX Item "Write"
.Vb 1
\&        SSize_t (*Write)(PerlIO *f, const void *vbuf, Size_t count);
.Ve
.Sp
Basic write operation.
.Sp
Returns bytes written or \-1 on an error.
.IP "Seek" 4
.IX Item "Seek"
.Vb 1
\&        IV      (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
.Ve
.Sp
Position the file pointer. Should normally call its own \f(CW\*(C`Flush\*(C'\fR
method and then the \f(CW\*(C`Seek\*(C'\fR method of next layer down.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Tell" 4
.IX Item "Tell"
.Vb 1
\&        Off_t   (*Tell)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the file pointer. May be based on layers cached concept of
position to avoid overhead.
.Sp
Returns \-1 on failure to get the file pointer.
.IP "Close" 4
.IX Item "Close"
.Vb 1
\&        IV      (*Close)(pTHX_ PerlIO *f);
.Ve
.Sp
Close the stream. Should normally call \f(CW\*(C`PerlIOBase_close()\*(C'\fR to flush
itself and close layers below, and then deallocate any data structures
(buffers, translation tables, ...) not  held directly in the data
structure.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Flush" 4
.IX Item "Flush"
.Vb 1
\&        IV      (*Flush)(pTHX_ PerlIO *f);
.Ve
.Sp
Should make stream's state consistent with layers below. That is, any
buffered write data should be written, and file position of lower layers
adjusted for data read from below but not actually consumed.
(Should perhaps \f(CW\*(C`Unread()\*(C'\fR such data to the lower layer.)
.Sp
Returns 0 on success, \-1 on failure.
.IP "Fill" 4
.IX Item "Fill"
.Vb 1
\&        IV      (*Fill)(pTHX_ PerlIO *f);
.Ve
.Sp
The buffer for this layer should be filled (for read) from layer
below.  When you \*(L"subclass\*(R" PerlIOBuf layer, you want to use its
\&\fI_read\fR method and to supply your own fill method, which fills the
PerlIOBuf's buffer.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Eof" 4
.IX Item "Eof"
.Vb 1
\&        IV      (*Eof)(pTHX_ PerlIO *f);
.Ve
.Sp
Return end-of-file indicator. \f(CW\*(C`PerlIOBase_eof()\*(C'\fR is normally sufficient.
.Sp
Returns 0 on end-of-file, 1 if not end-of-file, \-1 on error.
.IP "Error" 4
.IX Item "Error"
.Vb 1
\&        IV      (*Error)(pTHX_ PerlIO *f);
.Ve
.Sp
Return error indicator. \f(CW\*(C`PerlIOBase_error()\*(C'\fR is normally sufficient.
.Sp
Returns 1 if there is an error (usually when \f(CW\*(C`PERLIO_F_ERROR\*(C'\fR is set,
0 otherwise.
.IP "Clearerr" 4
.IX Item "Clearerr"
.Vb 1
\&        void    (*Clearerr)(pTHX_ PerlIO *f);
.Ve
.Sp
Clear end-of-file and error indicators. Should call \f(CW\*(C`PerlIOBase_clearerr()\*(C'\fR
to set the \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags, which may suffice.
.IP "Setlinebuf" 4
.IX Item "Setlinebuf"
.Vb 1
\&        void    (*Setlinebuf)(pTHX_ PerlIO *f);
.Ve
.Sp
Mark the stream as line buffered. \f(CW\*(C`PerlIOBase_setlinebuf()\*(C'\fR sets the
\&\s-1PERLIO_F_LINEBUF\s0 flag and is normally sufficient.
.IP "Get_base" 4
.IX Item "Get_base"
.Vb 1
\&        STDCHAR *       (*Get_base)(pTHX_ PerlIO *f);
.Ve
.Sp
Allocate (if not already done so) the read buffer for this layer and
return pointer to it. Return \s-1NULL\s0 on failure.
.IP "Get_bufsiz" 4
.IX Item "Get_bufsiz"
.Vb 1
\&        Size_t  (*Get_bufsiz)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes that last \f(CW\*(C`Fill()\*(C'\fR put in the buffer.
.IP "Get_ptr" 4
.IX Item "Get_ptr"
.Vb 1
\&        STDCHAR *       (*Get_ptr)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the current read pointer relative to this layer's buffer.
.IP "Get_cnt" 4
.IX Item "Get_cnt"
.Vb 1
\&        SSize_t (*Get_cnt)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes left to be read in the current buffer.
.IP "Set_ptrcnt" 4
.IX Item "Set_ptrcnt"
.Vb 2
\&        void    (*Set_ptrcnt)(pTHX_ PerlIO *f,
\&                              STDCHAR *ptr, SSize_t cnt);
.Ve
.Sp
Adjust the read pointer and count of bytes to match \f(CW\*(C`ptr\*(C'\fR and/or \f(CW\*(C`cnt\*(C'\fR.
The application (or layer above) must ensure they are consistent.
(Checking is allowed by the paranoid.)
.SS "Utilities"
.IX Subsection "Utilities"
To ask for the next layer down use PerlIONext(PerlIO *f).
.PP
To check that a PerlIO* is valid use PerlIOValid(PerlIO *f).  (All
this does is really just to check that the pointer is non-NULL and
that the pointer behind that is non-NULL.)
.PP
PerlIOBase(PerlIO *f) returns the \*(L"Base\*(R" pointer, or in other words,
the \f(CW\*(C`PerlIOl*\*(C'\fR pointer.
.PP
PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.
.PP
Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either
calls the \fIcallback\fR from the functions of the layer \fIf\fR (just by
the name of the \s-1IO\s0 function, like \*(L"Read\*(R") with the \fIargs\fR, or if
there is no such callback, calls the \fIbase\fR version of the callback
with the same args, or if the f is invalid, set errno to \s-1EBADF\s0 and
return \fIfailure\fR.
.PP
Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, set errno to \s-1EINVAL\s0.  Or if the f is
invalid, set errno to \s-1EBADF\s0 and return \fIfailure\fR.
.PP
Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, calls the \fIbase\fR version of the
callback with the same args, or if the f is invalid, set errno to
\&\s-1EBADF\s0.
.PP
Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the
\&\fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR, or if
there is no such callback, set errno to \s-1EINVAL\s0.  Or if the f is
invalid, set errno to \s-1EBADF\s0.
.SS "Implementing PerlIO Layers"
.IX Subsection "Implementing PerlIO Layers"
If you find the implementation document unclear or not sufficient,
look at the existing PerlIO layer implementations, which include:
.IP "\(bu" 4
C implementations
.Sp
The \fIperlio.c\fR and \fIperliol.h\fR in the Perl core implement the
\&\*(L"unix\*(R", \*(L"perlio\*(R", \*(L"stdio\*(R", \*(L"crlf\*(R", \*(L"utf8\*(R", \*(L"byte\*(R", \*(L"raw\*(R", \*(L"pending\*(R"
layers, and also the \*(L"mmap\*(R" and \*(L"win32\*(R" layers if applicable.
(The \*(L"win32\*(R" is currently unfinished and unused, to see what is used
instead in Win32, see \*(L"Querying the layers of filehandles\*(R" in PerlIO .)
.Sp
PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.
.Sp
PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on \s-1CPAN\s0.
.IP "\(bu" 4
Perl implementations
.Sp
PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on \s-1CPAN\s0.
.PP
If you are creating a PerlIO layer, you may want to be lazy, in other
words, implement only the methods that interest you.  The other methods
you can either replace with the \*(L"blank\*(R" methods
.PP
.Vb 2
\&    PerlIOBase_noop_ok
\&    PerlIOBase_noop_fail
.Ve
.PP
(which do nothing, and return zero and \-1, respectively) or for
certain methods you may assume a default behaviour by using a \s-1NULL\s0
method.  The Open method looks for help in the 'parent' layer.
The following table summarizes the behaviour:
.PP
.Vb 1
\&    method      behaviour with NULL
\&
\&    Clearerr    PerlIOBase_clearerr
\&    Close       PerlIOBase_close
\&    Dup         PerlIOBase_dup
\&    Eof         PerlIOBase_eof
\&    Error       PerlIOBase_error
\&    Fileno      PerlIOBase_fileno
\&    Fill        FAILURE
\&    Flush       SUCCESS
\&    Getarg      SUCCESS
\&    Get_base    FAILURE
\&    Get_bufsiz  FAILURE
\&    Get_cnt     FAILURE
\&    Get_ptr     FAILURE
\&    Open        INHERITED
\&    Popped      SUCCESS
\&    Pushed      SUCCESS
\&    Read        PerlIOBase_read
\&    Seek        FAILURE
\&    Set_cnt     FAILURE
\&    Set_ptrcnt  FAILURE
\&    Setlinebuf  PerlIOBase_setlinebuf
\&    Tell        FAILURE
\&    Unread      PerlIOBase_unread
\&    Write       FAILURE
\&
\& FAILURE        Set errno (to EINVAL in Unixish, to LIB$_INVARG in VMS) and
\&                return \-1 (for numeric return values) or NULL (for pointers)
\& INHERITED      Inherited from the layer below
\& SUCCESS        Return 0 (for numeric return values) or a pointer
.Ve
.SS "Core Layers"
.IX Subsection "Core Layers"
The file \f(CW\*(C`perlio.c\*(C'\fR provides the following layers:
.ie n .IP """unix""" 4
.el .IP "``unix''" 4
.IX Item "unix"
A basic non-buffered layer which calls Unix/POSIX \f(CW\*(C`read()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR,
\&\f(CW\*(C`lseek()\*(C'\fR, \f(CW\*(C`close()\*(C'\fR. No buffering. Even on platforms that distinguish
between O_TEXT and O_BINARY this layer is always O_BINARY.
.ie n .IP """perlio""" 4
.el .IP "``perlio''" 4
.IX Item "perlio"
A very complete generic buffering layer which provides the whole of
PerlIO \s-1API\s0. It is also intended to be used as a \*(L"base class\*(R" for other
layers. (For example its \f(CW\*(C`Read()\*(C'\fR method is implemented in terms of
the \f(CW\*(C`Get_cnt()\*(C'\fR/\f(CW\*(C`Get_ptr()\*(C'\fR/\f(CW\*(C`Set_ptrcnt()\*(C'\fR methods).
.Sp
\&\*(L"perlio\*(R" over \*(L"unix\*(R" provides a complete replacement for stdio as seen
via PerlIO \s-1API\s0. This is the default for \s-1USE_PERLIO\s0 when system's stdio
does not permit perl's \*(L"fast gets\*(R" access, and which do not
distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """stdio""" 4
.el .IP "``stdio''" 4
.IX Item "stdio"
A layer which provides the PerlIO \s-1API\s0 via the layer scheme, but
implements it by calling system's stdio. This is (currently) the default
if system's stdio provides sufficient access to allow perl's \*(L"fast gets\*(R"
access and which do not distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """crlf""" 4
.el .IP "``crlf''" 4
.IX Item "crlf"
A layer derived using \*(L"perlio\*(R" as a base class. It provides Win32\-like
\&\*(L"\en\*(R" to \s-1CR\s0,LF translation. Can either be applied above \*(L"perlio\*(R" or serve
as the buffer layer itself. \*(L"crlf\*(R" over \*(L"unix\*(R" is the default if system
distinguishes between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR opens. (At some point
\&\*(L"unix\*(R" will be replaced by a \*(L"native\*(R" Win32 \s-1IO\s0 layer on that platform,
as Win32's read/write layer has various drawbacks.) The \*(L"crlf\*(R" layer is
a reasonable model for a layer which transforms data in some way.
.ie n .IP """mmap""" 4
.el .IP "``mmap''" 4
.IX Item "mmap"
If Configure detects \f(CW\*(C`mmap()\*(C'\fR functions this layer is provided (with
\&\*(L"perlio\*(R" as a \*(L"base\*(R") which does \*(L"read\*(R" operations by \fImmap()\fRing the
file. Performance improvement is marginal on modern systems, so it is
mainly there as a proof of concept. It is likely to be unbundled from
the core at some point. The \*(L"mmap\*(R" layer is a reasonable model for a
minimalist \*(L"derived\*(R" layer.
.ie n .IP """pending""" 4
.el .IP "``pending''" 4
.IX Item "pending"
An \*(L"internal\*(R" derivative of \*(L"perlio\*(R" which can be used to provide
\&\fIUnread()\fR function for layers which have no buffer or cannot be
bothered.  (Basically this layer's \f(CW\*(C`Fill()\*(C'\fR pops itself off the stack
and so resumes reading from layer below.)
.ie n .IP """raw""" 4
.el .IP "``raw''" 4
.IX Item "raw"
A dummy layer which never exists on the layer stack. Instead when
\&\*(L"pushed\*(R" it actually pops the stack removing itself, it then calls
Binmode function table entry on all the layers in the stack \- normally
this (via PerlIOBase_binmode) removes any layers which do not have
\&\f(CW\*(C`PERLIO_K_RAW\*(C'\fR bit set. Layers can modify that behaviour by defining
their own Binmode entry.
.ie n .IP """utf8""" 4
.el .IP "``utf8''" 4
.IX Item "utf8"
Another dummy layer. When pushed it pops itself and sets the
\&\f(CW\*(C`PERLIO_F_UTF8\*(C'\fR flag on the layer which was (and now is once more)
the top of the stack.
.PP
In addition \fIperlio.c\fR also provides a number of \f(CW\*(C`PerlIOBase_xxxx()\*(C'\fR
functions which are intended to be used in the table slots of classes
which do not need to do anything special for a particular method.
.SS "Extension Layers"
.IX Subsection "Extension Layers"
Layers can be made available by extension modules. When an unknown layer
is encountered the PerlIO code will perform the equivalent of :
.PP
.Vb 1
\&   use PerlIO \*(Aqlayer\*(Aq;
.Ve
.PP
Where \fIlayer\fR is the unknown layer. \fIPerlIO.pm\fR will then attempt to:
.PP
.Vb 1
\&   require PerlIO::layer;
.Ve
.PP
If after that process the layer is still not defined then the \f(CW\*(C`open\*(C'\fR
will fail.
.PP
The following extension layers are bundled with perl:
.ie n .IP """:encoding""" 4
.el .IP "``:encoding''" 4
.IX Item ":encoding"
.Vb 1
\&   use Encoding;
.Ve
.Sp
makes this layer available, although \fIPerlIO.pm\fR \*(L"knows\*(R" where to
find it.  It is an example of a layer which takes an argument as it is
called thus:
.Sp
.Vb 1
\&   open( $fh, "<:encoding(iso\-8859\-7)", $pathname );
.Ve
.ie n .IP """:scalar""" 4
.el .IP "``:scalar''" 4
.IX Item ":scalar"
Provides support for reading data from and writing data to a scalar.
.Sp
.Vb 1
\&   open( $fh, "+<:scalar", \e$scalar );
.Ve
.Sp
When a handle is so opened, then reads get bytes from the string value
of \fI\f(CI$scalar\fI\fR, and writes change the value. In both cases the position
in \fI\f(CI$scalar\fI\fR starts as zero but can be altered via \f(CW\*(C`seek\*(C'\fR, and
determined via \f(CW\*(C`tell\*(C'\fR.
.Sp
Please note that this layer is implied when calling \fIopen()\fR thus:
.Sp
.Vb 1
\&   open( $fh, "+<", \e$scalar );
.Ve
.ie n .IP """:via""" 4
.el .IP "``:via''" 4
.IX Item ":via"
Provided to allow layers to be implemented as Perl code.  For instance:
.Sp
.Vb 2
\&   use PerlIO::via::StripHTML;
\&   open( my $fh, "<:via(StripHTML)", "index.html" );
.Ve
.Sp
See PerlIO::via for details.
.SH "TODO"
.IX Header "TODO"
Things that need to be done to improve this document.
.IP "\(bu" 4
Explain how to make a valid fh without going through \fIopen()\fR(i.e. apply
a layer). For example if the file is not opened through perl, but we
want to get back a fh, like it was opened by Perl.
.Sp
How PerlIO_apply_layera fits in, where its docs, was it made public?
.Sp
Currently the example could be something like this:
.Sp
.Vb 8
\&  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
\&  {
\&      char *mode; /* "w", "r", etc */
\&      const char *layers = ":APR"; /* the layer name */
\&      PerlIO *f = PerlIO_allocate(aTHX);
\&      if (!f) {
\&          return NULL;
\&      }
\&
\&      PerlIO_apply_layers(aTHX_ f, mode, layers);
\&
\&      if (f) {
\&          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
\&          /* fill in the st struct, as in _open() */
\&          st\->file = file;
\&          PerlIOBase(f)\->flags |= PERLIO_F_OPEN;
\&
\&          return f;
\&      }
\&      return NULL;
\&  }
.Ve
.IP "\(bu" 4
fix/add the documentation in places marked as \s-1XXX\s0.
.IP "\(bu" 4
The handling of errors by the layer is not specified. e.g. when $!
should be set explicitly, when the error handling should be just
delegated to the top layer.
.Sp
Probably give some hints on using \s-1\fISETERRNO\s0()\fR or pointers to where they
can be found.
.IP "\(bu" 4
I think it would help to give some concrete examples to make it easier
to understand the \s-1API\s0. Of course I agree that the \s-1API\s0 has to be
concise, but since there is no second document that is more of a
guide, I think that it'd make it easier to start with the doc which is
an \s-1API\s0, but has examples in it in places where things are unclear, to
a person who is not a PerlIO guru (yet).
                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perliol5.18.1                                0100644 0001750 0001750 00000131226 12566207441 022726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIOL 1"
.TH PERLIOL 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perliol \- C API for Perl's implementation of IO in Layers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    /* Defining a layer ... */
\&    #include <perliol.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the behavior and implementation of the PerlIO
abstraction described in perlapio when \f(CW\*(C`USE_PERLIO\*(C'\fR is defined (and
\&\f(CW\*(C`USE_SFIO\*(C'\fR is not).
.SS "History and Background"
.IX Subsection "History and Background"
The PerlIO abstraction was introduced in perl5.003_02 but languished as
just an abstraction until perl5.7.0. However during that time a number
of perl extensions switched to using it, so the \s-1API\s0 is mostly fixed to
maintain (source) compatibility.
.PP
The aim of the implementation is to provide the PerlIO \s-1API\s0 in a flexible
and platform neutral manner. It is also a trial of an \*(L"Object Oriented
C, with vtables\*(R" approach which may be applied to Perl 6.
.SS "Basic Structure"
.IX Subsection "Basic Structure"
PerlIO is a stack of layers.
.PP
The low levels of the stack work with the low-level operating system
calls (file descriptors in C) getting bytes in and out, the higher
layers of the stack buffer, filter, and otherwise manipulate the I/O,
and return characters (or bytes) to Perl.  Terms \fIabove\fR and \fIbelow\fR
are used to refer to the relative positioning of the stack layers.
.PP
A layer contains a \*(L"vtable\*(R", the table of I/O operations (at C level
a table of function pointers), and status flags.  The functions in the
vtable implement operations like \*(L"open\*(R", \*(L"read\*(R", and \*(L"write\*(R".
.PP
When I/O, for example \*(L"read\*(R", is requested, the request goes from Perl
first down the stack using \*(L"read\*(R" functions of each layer, then at the
bottom the input is requested from the operating system services, then
the result is returned up the stack, finally being interpreted as Perl
data.
.PP
The requests do not necessarily go always all the way down to the
operating system: that's where PerlIO buffering comes into play.
.PP
When you do an \fIopen()\fR and specify extra PerlIO layers to be deployed,
the layers you specify are \*(L"pushed\*(R" on top of the already existing
default stack.  One way to see it is that \*(L"operating system is
on the left\*(R" and \*(L"Perl is on the right\*(R".
.PP
What exact layers are in this default stack depends on a lot of
things: your operating system, Perl version, Perl compile time
configuration, and Perl runtime configuration.  See PerlIO,
\&\*(L"\s-1PERLIO\*(R"\s0 in perlrun, and open for more information.
.PP
\&\fIbinmode()\fR operates similarly to \fIopen()\fR: by default the specified
layers are pushed on top of the existing stack.
.PP
However, note that even as the specified layers are \*(L"pushed on top\*(R"
for \fIopen()\fR and \fIbinmode()\fR, this doesn't mean that the effects are
limited to the \*(L"top\*(R": PerlIO layers can be very 'active' and inspect
and affect layers also deeper in the stack.  As an example there
is a layer called \*(L"raw\*(R" which repeatedly \*(L"pops\*(R" layers until
it reaches the first layer that has declared itself capable of
handling binary data.  The \*(L"pushed\*(R" layers are processed in left-to-right
order.
.PP
\&\fIsysopen()\fR operates (unsurprisingly) at a lower level in the stack than
\&\fIopen()\fR.  For example in Unix or Unix-like systems \fIsysopen()\fR operates
directly at the level of file descriptors: in the terms of PerlIO
layers, it uses only the \*(L"unix\*(R" layer, which is a rather thin wrapper
on top of the Unix file descriptors.
.SS "Layers vs Disciplines"
.IX Subsection "Layers vs Disciplines"
Initial discussion of the ability to modify \s-1IO\s0 streams behaviour used
the term \*(L"discipline\*(R" for the entities which were added. This came (I
believe) from the use of the term in \*(L"sfio\*(R", which in turn borrowed it
from \*(L"line disciplines\*(R" on Unix terminals. However, this document (and
the C code) uses the term \*(L"layer\*(R".
.PP
This is, I hope, a natural term given the implementation, and should
avoid connotations that are inherent in earlier uses of \*(L"discipline\*(R"
for things which are rather different.
.SS "Data Structures"
.IX Subsection "Data Structures"
The basic data structure is a PerlIOl:
.PP
.Vb 3
\&        typedef struct _PerlIO PerlIOl;
\&        typedef struct _PerlIO_funcs PerlIO_funcs;
\&        typedef PerlIOl *PerlIO;
\&
\&        struct _PerlIO
\&        {
\&         PerlIOl *      next;       /* Lower layer */
\&         PerlIO_funcs * tab;        /* Functions for this layer */
\&         IV             flags;      /* Various flags for state */
\&        };
.Ve
.PP
A \f(CW\*(C`PerlIOl *\*(C'\fR is a pointer to the struct, and the \fIapplication\fR
level \f(CW\*(C`PerlIO *\*(C'\fR is a pointer to a \f(CW\*(C`PerlIOl *\*(C'\fR \- i.e. a pointer
to a pointer to the struct. This allows the application level \f(CW\*(C`PerlIO *\*(C'\fR
to remain constant while the actual \f(CW\*(C`PerlIOl *\*(C'\fR underneath
changes. (Compare perl's \f(CW\*(C`SV *\*(C'\fR which remains constant while its
\&\f(CW\*(C`sv_any\*(C'\fR field changes as the scalar's type changes.) An \s-1IO\s0 stream is
then in general represented as a pointer to this linked-list of
\&\*(L"layers\*(R".
.PP
It should be noted that because of the double indirection in a \f(CW\*(C`PerlIO *\*(C'\fR,
a \f(CW\*(C`&(perlio\->next)\*(C'\fR \*(L"is\*(R" a \f(CW\*(C`PerlIO *\*(C'\fR, and so to some degree
at least one layer can use the \*(L"standard\*(R" \s-1API\s0 on the next layer down.
.PP
A \*(L"layer\*(R" is composed of two parts:
.IP "1." 4
The functions and attributes of the \*(L"layer class\*(R".
.IP "2." 4
The per-instance data for a particular handle.
.SS "Functions and Attributes"
.IX Subsection "Functions and Attributes"
The functions and attributes are accessed via the \*(L"tab\*(R" (for table)
member of \f(CW\*(C`PerlIOl\*(C'\fR. The functions (methods of the layer \*(L"class\*(R") are
fixed, and are defined by the \f(CW\*(C`PerlIO_funcs\*(C'\fR type. They are broadly the
same as the public \f(CW\*(C`PerlIO_xxxxx\*(C'\fR functions:
.PP
.Vb 10
\&  struct _PerlIO_funcs
\&  {
\&   Size_t               fsize;
\&   char *               name;
\&   Size_t               size;
\&   IV           kind;
\&   IV           (*Pushed)(pTHX_ PerlIO *f,const char *mode,SV *arg, PerlIO_funcs *tab);
\&   IV           (*Popped)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
\&   IV           (*Binmode)(pTHX_ PerlIO *f);
\&   SV *         (*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
\&   IV           (*Fileno)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Dup)(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
\&   /* Unix\-like functions \- cf sfio line disciplines */
\&   SSize_t      (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
\&   SSize_t      (*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   SSize_t      (*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   IV           (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
\&   Off_t        (*Tell)(pTHX_ PerlIO *f);
\&   IV           (*Close)(pTHX_ PerlIO *f);
\&   /* Stdio\-like buffered IO functions */
\&   IV           (*Flush)(pTHX_ PerlIO *f);
\&   IV           (*Fill)(pTHX_ PerlIO *f);
\&   IV           (*Eof)(pTHX_ PerlIO *f);
\&   IV           (*Error)(pTHX_ PerlIO *f);
\&   void         (*Clearerr)(pTHX_ PerlIO *f);
\&   void         (*Setlinebuf)(pTHX_ PerlIO *f);
\&   /* Perl\*(Aqs snooping functions */
\&   STDCHAR *    (*Get_base)(pTHX_ PerlIO *f);
\&   Size_t       (*Get_bufsiz)(pTHX_ PerlIO *f);
\&   STDCHAR *    (*Get_ptr)(pTHX_ PerlIO *f);
\&   SSize_t      (*Get_cnt)(pTHX_ PerlIO *f);
\&   void         (*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
\&  };
.Ve
.PP
The first few members of the struct give a function table size for
compatibility check \*(L"name\*(R" for the layer, the  size to \f(CW\*(C`malloc\*(C'\fR for the per-instance data,
and some flags which are attributes of the class as whole (such as whether it is a buffering
layer), then follow the functions which fall into four basic groups:
.IP "1." 4
Opening and setup functions
.IP "2." 4
Basic \s-1IO\s0 operations
.IP "3." 4
Stdio class buffering options.
.IP "4." 4
Functions to support Perl's traditional \*(L"fast\*(R" access to the buffer.
.PP
A layer does not have to implement all the functions, but the whole
table has to be present. Unimplemented slots can be \s-1NULL \s0(which will
result in an error when called) or can be filled in with stubs to
\&\*(L"inherit\*(R" behaviour from a \*(L"base class\*(R". This \*(L"inheritance\*(R" is fixed
for all instances of the layer, but as the layer chooses which stubs
to populate the table, limited \*(L"multiple inheritance\*(R" is possible.
.SS "Per-instance Data"
.IX Subsection "Per-instance Data"
The per-instance data are held in memory beyond the basic PerlIOl
struct, by making a PerlIOl the first member of the layer's struct
thus:
.PP
.Vb 10
\&        typedef struct
\&        {
\&         struct _PerlIO base;       /* Base "class" info */
\&         STDCHAR *      buf;        /* Start of buffer */
\&         STDCHAR *      end;        /* End of valid part of buffer */
\&         STDCHAR *      ptr;        /* Current position in buffer */
\&         Off_t          posn;       /* Offset of buf into the file */
\&         Size_t         bufsiz;     /* Real size of buffer */
\&         IV             oneword;    /* Emergency buffer */
\&        } PerlIOBuf;
.Ve
.PP
In this way (as for perl's scalars) a pointer to a PerlIOBuf can be
treated as a pointer to a PerlIOl.
.SS "Layers in action."
.IX Subsection "Layers in action."
.Vb 8
\&                table           perlio          unix
\&            |           |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&   PerlIO \->|           |\-\-\->|  next    |\-\-\->|  NULL  |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&            |           |    |  buffer  |    |   fd   |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    |          |    +\-\-\-\-\-\-\-\-+
\&            |           |    +\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
The above attempts to show how the layer scheme works in a simple case.
The application's \f(CW\*(C`PerlIO *\*(C'\fR points to an entry in the table(s)
representing open (allocated) handles. For example the first three slots
in the table correspond to \f(CW\*(C`stdin\*(C'\fR,\f(CW\*(C`stdout\*(C'\fR and \f(CW\*(C`stderr\*(C'\fR. The table
in turn points to the current \*(L"top\*(R" layer for the handle \- in this case
an instance of the generic buffering layer \*(L"perlio\*(R". That layer in turn
points to the next layer down \- in this case the low-level \*(L"unix\*(R" layer.
.PP
The above is roughly equivalent to a \*(L"stdio\*(R" buffered stream, but with
much more flexibility:
.IP "\(bu" 4
If Unix level \f(CW\*(C`read\*(C'\fR/\f(CW\*(C`write\*(C'\fR/\f(CW\*(C`lseek\*(C'\fR is not appropriate for (say)
sockets then the \*(L"unix\*(R" layer can be replaced (at open time or even
dynamically) with a \*(L"socket\*(R" layer.
.IP "\(bu" 4
Different handles can have different buffering schemes. The \*(L"top\*(R"
layer could be the \*(L"mmap\*(R" layer if reading disk files was quicker
using \f(CW\*(C`mmap\*(C'\fR than \f(CW\*(C`read\*(C'\fR. An \*(L"unbuffered\*(R" stream can be implemented
simply by not having a buffer layer.
.IP "\(bu" 4
Extra layers can be inserted to process the data as it flows through.
This was the driving need for including the scheme in perl 5.7.0+ \- we
needed a mechanism to allow data to be translated between perl's
internal encoding (conceptually at least Unicode as \s-1UTF\-8\s0), and the
\&\*(L"native\*(R" format used by the system. This is provided by the
\&\*(L":encoding(xxxx)\*(R" layer which typically sits above the buffering layer.
.IP "\(bu" 4
A layer can be added that does \*(L"\en\*(R" to \s-1CRLF\s0 translation. This layer
can be used on any platform, not just those that normally do such
things.
.SS "Per-instance flag bits"
.IX Subsection "Per-instance flag bits"
The generic flag bits are a hybrid of \f(CW\*(C`O_XXXXX\*(C'\fR style flags deduced
from the mode string passed to \f(CW\*(C`PerlIO_open()\*(C'\fR, and state bits for
typical buffer layers.
.IP "\s-1PERLIO_F_EOF\s0" 4
.IX Item "PERLIO_F_EOF"
End of file.
.IP "\s-1PERLIO_F_CANWRITE\s0" 4
.IX Item "PERLIO_F_CANWRITE"
Writes are permitted, i.e. opened as \*(L"w\*(R" or \*(L"r+\*(R" or \*(L"a\*(R", etc.
.IP "\s-1PERLIO_F_CANREAD\s0" 4
.IX Item "PERLIO_F_CANREAD"
Reads are permitted i.e. opened \*(L"r\*(R" or \*(L"w+\*(R" (or even \*(L"a+\*(R" \- ick).
.IP "\s-1PERLIO_F_ERROR\s0" 4
.IX Item "PERLIO_F_ERROR"
An error has occurred (for \f(CW\*(C`PerlIO_error()\*(C'\fR).
.IP "\s-1PERLIO_F_TRUNCATE\s0" 4
.IX Item "PERLIO_F_TRUNCATE"
Truncate file suggested by open mode.
.IP "\s-1PERLIO_F_APPEND\s0" 4
.IX Item "PERLIO_F_APPEND"
All writes should be appends.
.IP "\s-1PERLIO_F_CRLF\s0" 4
.IX Item "PERLIO_F_CRLF"
Layer is performing Win32\-like \*(L"\en\*(R" mapped to \s-1CR,LF\s0 for output and \s-1CR,LF\s0
mapped to \*(L"\en\*(R" for input. Normally the provided \*(L"crlf\*(R" layer is the only
layer that need bother about this. \f(CW\*(C`PerlIO_binmode()\*(C'\fR will mess with this
flag rather than add/remove layers if the \f(CW\*(C`PERLIO_K_CANCRLF\*(C'\fR bit is set
for the layers class.
.IP "\s-1PERLIO_F_UTF8\s0" 4
.IX Item "PERLIO_F_UTF8"
Data written to this layer should be \s-1UTF\-8\s0 encoded; data provided
by this layer should be considered \s-1UTF\-8\s0 encoded. Can be set on any layer
by \*(L":utf8\*(R" dummy layer. Also set on \*(L":encoding\*(R" layer.
.IP "\s-1PERLIO_F_UNBUF\s0" 4
.IX Item "PERLIO_F_UNBUF"
Layer is unbuffered \- i.e. write to next layer down should occur for
each write to this layer.
.IP "\s-1PERLIO_F_WRBUF\s0" 4
.IX Item "PERLIO_F_WRBUF"
The buffer for this layer currently holds data written to it but not sent
to next layer.
.IP "\s-1PERLIO_F_RDBUF\s0" 4
.IX Item "PERLIO_F_RDBUF"
The buffer for this layer currently holds unconsumed data read from
layer below.
.IP "\s-1PERLIO_F_LINEBUF\s0" 4
.IX Item "PERLIO_F_LINEBUF"
Layer is line buffered. Write data should be passed to next layer down
whenever a \*(L"\en\*(R" is seen. Any data beyond the \*(L"\en\*(R" should then be
processed.
.IP "\s-1PERLIO_F_TEMP\s0" 4
.IX Item "PERLIO_F_TEMP"
File has been \f(CW\*(C`unlink()\*(C'\fRed, or should be deleted on \f(CW\*(C`close()\*(C'\fR.
.IP "\s-1PERLIO_F_OPEN\s0" 4
.IX Item "PERLIO_F_OPEN"
Handle is open.
.IP "\s-1PERLIO_F_FASTGETS\s0" 4
.IX Item "PERLIO_F_FASTGETS"
This instance of this layer supports the "fast \f(CW\*(C`gets\*(C'\fR" interface.
Normally set based on \f(CW\*(C`PERLIO_K_FASTGETS\*(C'\fR for the class and by the
existence of the function(s) in the table. However a class that
normally provides that interface may need to avoid it on a
particular instance. The \*(L"pending\*(R" layer needs to do this when
it is pushed above a layer which does not support the interface.
(Perl's \f(CW\*(C`sv_gets()\*(C'\fR does not expect the streams fast \f(CW\*(C`gets\*(C'\fR behaviour
to change during one \*(L"get\*(R".)
.SS "Methods in Detail"
.IX Subsection "Methods in Detail"
.IP "fsize" 4
.IX Item "fsize"
.Vb 1
\&        Size_t fsize;
.Ve
.Sp
Size of the function table. This is compared against the value PerlIO
code \*(L"knows\*(R" as a compatibility check. Future versions \fImay\fR be able
to tolerate layers compiled against an old version of the headers.
.IP "name" 4
.IX Item "name"
.Vb 1
\&        char * name;
.Ve
.Sp
The name of the layer whose \fIopen()\fR method Perl should invoke on
\&\fIopen()\fR.  For example if the layer is called \s-1APR,\s0 you will call:
.Sp
.Vb 1
\&  open $fh, ">:APR", ...
.Ve
.Sp
and Perl knows that it has to invoke the \fIPerlIOAPR_open()\fR method
implemented by the \s-1APR\s0 layer.
.IP "size" 4
.IX Item "size"
.Vb 1
\&        Size_t size;
.Ve
.Sp
The size of the per-instance data structure, e.g.:
.Sp
.Vb 1
\&  sizeof(PerlIOAPR)
.Ve
.Sp
If this field is zero then \f(CW\*(C`PerlIO_pushed\*(C'\fR does not malloc anything
and assumes layer's Pushed function will do any required layer stack
manipulation \- used to avoid malloc/free overhead for dummy layers.
If the field is non-zero it must be at least the size of \f(CW\*(C`PerlIOl\*(C'\fR,
\&\f(CW\*(C`PerlIO_pushed\*(C'\fR will allocate memory for the layer's data structures
and link new layer onto the stream's stack. (If the layer's Pushed
method returns an error indication the layer is popped again.)
.IP "kind" 4
.IX Item "kind"
.Vb 1
\&        IV kind;
.Ve
.RS 4
.IP "\(bu" 4
\&\s-1PERLIO_K_BUFFERED\s0
.Sp
The layer is buffered.
.IP "\(bu" 4
\&\s-1PERLIO_K_RAW\s0
.Sp
The layer is acceptable to have in a binmode(\s-1FH\s0) stack \- i.e. it does not
(or will configure itself not to) transform bytes passing through it.
.IP "\(bu" 4
\&\s-1PERLIO_K_CANCRLF\s0
.Sp
Layer can translate between \*(L"\en\*(R" and \s-1CRLF\s0 line ends.
.IP "\(bu" 4
\&\s-1PERLIO_K_FASTGETS\s0
.Sp
Layer allows buffer snooping.
.IP "\(bu" 4
\&\s-1PERLIO_K_MULTIARG\s0
.Sp
Used when the layer's \fIopen()\fR accepts more arguments than usual. The
extra arguments should come not before the \f(CW\*(C`MODE\*(C'\fR argument. When this
flag is used it's up to the layer to validate the args.
.RE
.RS 4
.RE
.IP "Pushed" 4
.IX Item "Pushed"
.Vb 1
\&        IV      (*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);
.Ve
.Sp
The only absolutely mandatory method. Called when the layer is pushed
onto the stack.  The \f(CW\*(C`mode\*(C'\fR argument may be \s-1NULL\s0 if this occurs
post-open. The \f(CW\*(C`arg\*(C'\fR will be non\-\f(CW\*(C`NULL\*(C'\fR if an argument string was
passed. In most cases this should call \f(CW\*(C`PerlIOBase_pushed()\*(C'\fR to
convert \f(CW\*(C`mode\*(C'\fR into the appropriate \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags in
addition to any actions the layer itself takes.  If a layer is not
expecting an argument it need neither save the one passed to it, nor
provide \f(CW\*(C`Getarg()\*(C'\fR (it could perhaps \f(CW\*(C`Perl_warn\*(C'\fR that the argument
was un-expected).
.Sp
Returns 0 on success. On failure returns \-1 and should set errno.
.IP "Popped" 4
.IX Item "Popped"
.Vb 1
\&        IV      (*Popped)(pTHX_ PerlIO *f);
.Ve
.Sp
Called when the layer is popped from the stack. A layer will normally
be popped after \f(CW\*(C`Close()\*(C'\fR is called. But a layer can be popped
without being closed if the program is dynamically managing layers on
the stream. In such cases \f(CW\*(C`Popped()\*(C'\fR should free any resources
(buffers, translation tables, ...) not held directly in the layer's
struct.  It should also \f(CW\*(C`Unread()\*(C'\fR any unconsumed data that has been
read and buffered from the layer below back to that layer, so that it
can be re-provided to what ever is now above.
.Sp
Returns 0 on success and failure.  If \f(CW\*(C`Popped()\*(C'\fR returns \fItrue\fR then
\&\fIperlio.c\fR assumes that either the layer has popped itself, or the
layer is super special and needs to be retained for other reasons.
In most cases it should return \fIfalse\fR.
.IP "Open" 4
.IX Item "Open"
.Vb 1
\&        PerlIO *        (*Open)(...);
.Ve
.Sp
The \f(CW\*(C`Open()\*(C'\fR method has lots of arguments because it combines the
functions of perl's \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`PerlIO_open\*(C'\fR, perl's \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`PerlIO_fdopen\*(C'\fR and \f(CW\*(C`PerlIO_reopen\*(C'\fR.  The full prototype is as
follows:
.Sp
.Vb 6
\& PerlIO *       (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
.Ve
.Sp
Open should (perhaps indirectly) call \f(CW\*(C`PerlIO_allocate()\*(C'\fR to allocate
a slot in the table and associate it with the layers information for
the opened file, by calling \f(CW\*(C`PerlIO_push\*(C'\fR.  The \fIlayers\fR is an
array of all the layers destined for the \f(CW\*(C`PerlIO *\*(C'\fR, and any
arguments passed to them, \fIn\fR is the index into that array of the
layer being called. The macro \f(CW\*(C`PerlIOArg\*(C'\fR will return a (possibly
\&\f(CW\*(C`NULL\*(C'\fR) \s-1SV\s0 * for the argument passed to the layer.
.Sp
The \fImode\fR string is an "\f(CW\*(C`fopen()\*(C'\fR\-like" string which would match
the regular expression \f(CW\*(C`/^[I#]?[rwa]\e+?[bt]?$/\*(C'\fR.
.Sp
The \f(CW\*(AqI\*(Aq\fR prefix is used during creation of \f(CW\*(C`stdin\*(C'\fR..\f(CW\*(C`stderr\*(C'\fR via
special \f(CW\*(C`PerlIO_fdopen\*(C'\fR calls; the \f(CW\*(Aq#\*(Aq\fR prefix means that this is
\&\f(CW\*(C`sysopen\*(C'\fR and that \fIimode\fR and \fIperm\fR should be passed to
\&\f(CW\*(C`PerlLIO_open3\*(C'\fR; \f(CW\*(Aqr\*(Aq\fR means \fBr\fRead, \f(CW\*(Aqw\*(Aq\fR means \fBw\fRrite and
\&\f(CW\*(Aqa\*(Aq\fR means \fBa\fRppend. The \f(CW\*(Aq+\*(Aq\fR suffix means that both reading and
writing/appending are permitted.  The \f(CW\*(Aqb\*(Aq\fR suffix means file should
be binary, and \f(CW\*(Aqt\*(Aq\fR means it is text. (Almost all layers should do
the \s-1IO\s0 in binary mode, and ignore the b/t bits. The \f(CW\*(C`:crlf\*(C'\fR layer
should be pushed to handle the distinction.)
.Sp
If \fIold\fR is not \f(CW\*(C`NULL\*(C'\fR then this is a \f(CW\*(C`PerlIO_reopen\*(C'\fR. Perl itself
does not use this (yet?) and semantics are a little vague.
.Sp
If \fIfd\fR not negative then it is the numeric file descriptor \fIfd\fR,
which will be open in a manner compatible with the supplied mode
string, the call is thus equivalent to \f(CW\*(C`PerlIO_fdopen\*(C'\fR. In this case
\&\fInargs\fR will be zero.
.Sp
If \fInargs\fR is greater than zero then it gives the number of arguments
passed to \f(CW\*(C`open\*(C'\fR, otherwise it will be 1 if for example
\&\f(CW\*(C`PerlIO_open\*(C'\fR was called.  In simple cases SvPV_nolen(*args) is the
pathname to open.
.Sp
If a layer provides \f(CW\*(C`Open()\*(C'\fR it should normally call the \f(CW\*(C`Open()\*(C'\fR
method of next layer down (if any) and then push itself on top if that
succeeds.  \f(CW\*(C`PerlIOBase_open\*(C'\fR is provided to do exactly that, so in
most cases you don't have to write your own \f(CW\*(C`Open()\*(C'\fR method.  If this
method is not defined, other layers may have difficulty pushing
themselves on top of it during open.
.Sp
If \f(CW\*(C`PerlIO_push\*(C'\fR was performed and open has failed, it must
\&\f(CW\*(C`PerlIO_pop\*(C'\fR itself, since if it's not, the layer won't be removed
and may cause bad problems.
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Binmode" 4
.IX Item "Binmode"
.Vb 1
\&        IV        (*Binmode)(pTHX_ PerlIO *f);
.Ve
.Sp
Optional. Used when \f(CW\*(C`:raw\*(C'\fR layer is pushed (explicitly or as a result
of binmode(\s-1FH\s0)). If not present layer will be popped. If present
should configure layer as binary (or pop itself) and return 0.
If it returns \-1 for error \f(CW\*(C`binmode\*(C'\fR will fail with layer
still on the stack.
.IP "Getarg" 4
.IX Item "Getarg"
.Vb 2
\&        SV *      (*Getarg)(pTHX_ PerlIO *f,
\&                            CLONE_PARAMS *param, int flags);
.Ve
.Sp
Optional. If present should return an \s-1SV\s0 * representing the string
argument passed to the layer when it was
pushed. e.g. \*(L":encoding(ascii)\*(R" would return an SvPV with value
\&\*(L"ascii\*(R". (\fIparam\fR and \fIflags\fR arguments can be ignored in most
cases)
.Sp
\&\f(CW\*(C`Dup\*(C'\fR uses \f(CW\*(C`Getarg\*(C'\fR to retrieve the argument originally passed to
\&\f(CW\*(C`Pushed\*(C'\fR, so you must implement this function if your layer has an
extra argument to \f(CW\*(C`Pushed\*(C'\fR and will ever be \f(CW\*(C`Dup\*(C'\fRed.
.IP "Fileno" 4
.IX Item "Fileno"
.Vb 1
\&        IV        (*Fileno)(pTHX_ PerlIO *f);
.Ve
.Sp
Returns the Unix/Posix numeric file descriptor for the handle. Normally
\&\f(CW\*(C`PerlIOBase_fileno()\*(C'\fR (which just asks next layer down) will suffice
for this.
.Sp
Returns \-1 on error, which is considered to include the case where the
layer cannot provide such a file descriptor.
.IP "Dup" 4
.IX Item "Dup"
.Vb 2
\&        PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
\&                        CLONE_PARAMS *param, int flags);
.Ve
.Sp
\&\s-1XXX:\s0 Needs more docs.
.Sp
Used as part of the \*(L"clone\*(R" process when a thread is spawned (in which
case param will be non-NULL) and when a stream is being duplicated via
\&'&' in the \f(CW\*(C`open\*(C'\fR.
.Sp
Similar to \f(CW\*(C`Open\*(C'\fR, returns PerlIO* on success, \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Read" 4
.IX Item "Read"
.Vb 1
\&        SSize_t (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
.Ve
.Sp
Basic read operation.
.Sp
Typically will call \f(CW\*(C`Fill\*(C'\fR and manipulate pointers (possibly via the
\&\s-1API\s0).  \f(CW\*(C`PerlIOBuf_read()\*(C'\fR may be suitable for derived classes which
provide \*(L"fast gets\*(R" methods.
.Sp
Returns actual bytes read, or \-1 on an error.
.IP "Unread" 4
.IX Item "Unread"
.Vb 2
\&        SSize_t (*Unread)(pTHX_ PerlIO *f,
\&                          const void *vbuf, Size_t count);
.Ve
.Sp
A superset of stdio's \f(CW\*(C`ungetc()\*(C'\fR. Should arrange for future reads to
see the bytes in \f(CW\*(C`vbuf\*(C'\fR. If there is no obviously better implementation
then \f(CW\*(C`PerlIOBase_unread()\*(C'\fR provides the function by pushing a \*(L"fake\*(R"
\&\*(L"pending\*(R" layer above the calling layer.
.Sp
Returns the number of unread chars.
.IP "Write" 4
.IX Item "Write"
.Vb 1
\&        SSize_t (*Write)(PerlIO *f, const void *vbuf, Size_t count);
.Ve
.Sp
Basic write operation.
.Sp
Returns bytes written or \-1 on an error.
.IP "Seek" 4
.IX Item "Seek"
.Vb 1
\&        IV      (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
.Ve
.Sp
Position the file pointer. Should normally call its own \f(CW\*(C`Flush\*(C'\fR
method and then the \f(CW\*(C`Seek\*(C'\fR method of next layer down.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Tell" 4
.IX Item "Tell"
.Vb 1
\&        Off_t   (*Tell)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the file pointer. May be based on layers cached concept of
position to avoid overhead.
.Sp
Returns \-1 on failure to get the file pointer.
.IP "Close" 4
.IX Item "Close"
.Vb 1
\&        IV      (*Close)(pTHX_ PerlIO *f);
.Ve
.Sp
Close the stream. Should normally call \f(CW\*(C`PerlIOBase_close()\*(C'\fR to flush
itself and close layers below, and then deallocate any data structures
(buffers, translation tables, ...) not  held directly in the data
structure.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Flush" 4
.IX Item "Flush"
.Vb 1
\&        IV      (*Flush)(pTHX_ PerlIO *f);
.Ve
.Sp
Should make stream's state consistent with layers below. That is, any
buffered write data should be written, and file position of lower layers
adjusted for data read from below but not actually consumed.
(Should perhaps \f(CW\*(C`Unread()\*(C'\fR such data to the lower layer.)
.Sp
Returns 0 on success, \-1 on failure.
.IP "Fill" 4
.IX Item "Fill"
.Vb 1
\&        IV      (*Fill)(pTHX_ PerlIO *f);
.Ve
.Sp
The buffer for this layer should be filled (for read) from layer
below.  When you \*(L"subclass\*(R" PerlIOBuf layer, you want to use its
\&\fI_read\fR method and to supply your own fill method, which fills the
PerlIOBuf's buffer.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Eof" 4
.IX Item "Eof"
.Vb 1
\&        IV      (*Eof)(pTHX_ PerlIO *f);
.Ve
.Sp
Return end-of-file indicator. \f(CW\*(C`PerlIOBase_eof()\*(C'\fR is normally sufficient.
.Sp
Returns 0 on end-of-file, 1 if not end-of-file, \-1 on error.
.IP "Error" 4
.IX Item "Error"
.Vb 1
\&        IV      (*Error)(pTHX_ PerlIO *f);
.Ve
.Sp
Return error indicator. \f(CW\*(C`PerlIOBase_error()\*(C'\fR is normally sufficient.
.Sp
Returns 1 if there is an error (usually when \f(CW\*(C`PERLIO_F_ERROR\*(C'\fR is set),
0 otherwise.
.IP "Clearerr" 4
.IX Item "Clearerr"
.Vb 1
\&        void    (*Clearerr)(pTHX_ PerlIO *f);
.Ve
.Sp
Clear end-of-file and error indicators. Should call \f(CW\*(C`PerlIOBase_clearerr()\*(C'\fR
to set the \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags, which may suffice.
.IP "Setlinebuf" 4
.IX Item "Setlinebuf"
.Vb 1
\&        void    (*Setlinebuf)(pTHX_ PerlIO *f);
.Ve
.Sp
Mark the stream as line buffered. \f(CW\*(C`PerlIOBase_setlinebuf()\*(C'\fR sets the
\&\s-1PERLIO_F_LINEBUF\s0 flag and is normally sufficient.
.IP "Get_base" 4
.IX Item "Get_base"
.Vb 1
\&        STDCHAR *       (*Get_base)(pTHX_ PerlIO *f);
.Ve
.Sp
Allocate (if not already done so) the read buffer for this layer and
return pointer to it. Return \s-1NULL\s0 on failure.
.IP "Get_bufsiz" 4
.IX Item "Get_bufsiz"
.Vb 1
\&        Size_t  (*Get_bufsiz)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes that last \f(CW\*(C`Fill()\*(C'\fR put in the buffer.
.IP "Get_ptr" 4
.IX Item "Get_ptr"
.Vb 1
\&        STDCHAR *       (*Get_ptr)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the current read pointer relative to this layer's buffer.
.IP "Get_cnt" 4
.IX Item "Get_cnt"
.Vb 1
\&        SSize_t (*Get_cnt)(pTHX_ PerlIO *f);
.Ve
.Sp
Return the number of bytes left to be read in the current buffer.
.IP "Set_ptrcnt" 4
.IX Item "Set_ptrcnt"
.Vb 2
\&        void    (*Set_ptrcnt)(pTHX_ PerlIO *f,
\&                              STDCHAR *ptr, SSize_t cnt);
.Ve
.Sp
Adjust the read pointer and count of bytes to match \f(CW\*(C`ptr\*(C'\fR and/or \f(CW\*(C`cnt\*(C'\fR.
The application (or layer above) must ensure they are consistent.
(Checking is allowed by the paranoid.)
.SS "Utilities"
.IX Subsection "Utilities"
To ask for the next layer down use PerlIONext(PerlIO *f).
.PP
To check that a PerlIO* is valid use PerlIOValid(PerlIO *f).  (All
this does is really just to check that the pointer is non-NULL and
that the pointer behind that is non-NULL.)
.PP
PerlIOBase(PerlIO *f) returns the \*(L"Base\*(R" pointer, or in other words,
the \f(CW\*(C`PerlIOl*\*(C'\fR pointer.
.PP
PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.
.PP
Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either
calls the \fIcallback\fR from the functions of the layer \fIf\fR (just by
the name of the \s-1IO\s0 function, like \*(L"Read\*(R") with the \fIargs\fR, or if
there is no such callback, calls the \fIbase\fR version of the callback
with the same args, or if the f is invalid, set errno to \s-1EBADF\s0 and
return \fIfailure\fR.
.PP
Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, set errno to \s-1EINVAL. \s0 Or if the f is
invalid, set errno to \s-1EBADF\s0 and return \fIfailure\fR.
.PP
Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls
the \fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR,
or if there is no such callback, calls the \fIbase\fR version of the
callback with the same args, or if the f is invalid, set errno to
\&\s-1EBADF.\s0
.PP
Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the
\&\fIcallback\fR of the functions of the layer \fIf\fR with the \fIargs\fR, or if
there is no such callback, set errno to \s-1EINVAL. \s0 Or if the f is
invalid, set errno to \s-1EBADF.\s0
.SS "Implementing PerlIO Layers"
.IX Subsection "Implementing PerlIO Layers"
If you find the implementation document unclear or not sufficient,
look at the existing PerlIO layer implementations, which include:
.IP "\(bu" 4
C implementations
.Sp
The \fIperlio.c\fR and \fIperliol.h\fR in the Perl core implement the
\&\*(L"unix\*(R", \*(L"perlio\*(R", \*(L"stdio\*(R", \*(L"crlf\*(R", \*(L"utf8\*(R", \*(L"byte\*(R", \*(L"raw\*(R", \*(L"pending\*(R"
layers, and also the \*(L"mmap\*(R" and \*(L"win32\*(R" layers if applicable.
(The \*(L"win32\*(R" is currently unfinished and unused, to see what is used
instead in Win32, see \*(L"Querying the layers of filehandles\*(R" in PerlIO .)
.Sp
PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.
.Sp
PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on \s-1CPAN.\s0
.IP "\(bu" 4
Perl implementations
.Sp
PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on \s-1CPAN.\s0
.PP
If you are creating a PerlIO layer, you may want to be lazy, in other
words, implement only the methods that interest you.  The other methods
you can either replace with the \*(L"blank\*(R" methods
.PP
.Vb 2
\&    PerlIOBase_noop_ok
\&    PerlIOBase_noop_fail
.Ve
.PP
(which do nothing, and return zero and \-1, respectively) or for
certain methods you may assume a default behaviour by using a \s-1NULL\s0
method.  The Open method looks for help in the 'parent' layer.
The following table summarizes the behaviour:
.PP
.Vb 1
\&    method      behaviour with NULL
\&
\&    Clearerr    PerlIOBase_clearerr
\&    Close       PerlIOBase_close
\&    Dup         PerlIOBase_dup
\&    Eof         PerlIOBase_eof
\&    Error       PerlIOBase_error
\&    Fileno      PerlIOBase_fileno
\&    Fill        FAILURE
\&    Flush       SUCCESS
\&    Getarg      SUCCESS
\&    Get_base    FAILURE
\&    Get_bufsiz  FAILURE
\&    Get_cnt     FAILURE
\&    Get_ptr     FAILURE
\&    Open        INHERITED
\&    Popped      SUCCESS
\&    Pushed      SUCCESS
\&    Read        PerlIOBase_read
\&    Seek        FAILURE
\&    Set_cnt     FAILURE
\&    Set_ptrcnt  FAILURE
\&    Setlinebuf  PerlIOBase_setlinebuf
\&    Tell        FAILURE
\&    Unread      PerlIOBase_unread
\&    Write       FAILURE
\&
\& FAILURE        Set errno (to EINVAL in Unixish, to LIB$_INVARG in VMS) and
\&                return \-1 (for numeric return values) or NULL (for pointers)
\& INHERITED      Inherited from the layer below
\& SUCCESS        Return 0 (for numeric return values) or a pointer
.Ve
.SS "Core Layers"
.IX Subsection "Core Layers"
The file \f(CW\*(C`perlio.c\*(C'\fR provides the following layers:
.ie n .IP """unix""" 4
.el .IP "``unix''" 4
.IX Item "unix"
A basic non-buffered layer which calls Unix/POSIX \f(CW\*(C`read()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR,
\&\f(CW\*(C`lseek()\*(C'\fR, \f(CW\*(C`close()\*(C'\fR. No buffering. Even on platforms that distinguish
between O_TEXT and O_BINARY this layer is always O_BINARY.
.ie n .IP """perlio""" 4
.el .IP "``perlio''" 4
.IX Item "perlio"
A very complete generic buffering layer which provides the whole of
PerlIO \s-1API.\s0 It is also intended to be used as a \*(L"base class\*(R" for other
layers. (For example its \f(CW\*(C`Read()\*(C'\fR method is implemented in terms of
the \f(CW\*(C`Get_cnt()\*(C'\fR/\f(CW\*(C`Get_ptr()\*(C'\fR/\f(CW\*(C`Set_ptrcnt()\*(C'\fR methods).
.Sp
\&\*(L"perlio\*(R" over \*(L"unix\*(R" provides a complete replacement for stdio as seen
via PerlIO \s-1API.\s0 This is the default for \s-1USE_PERLIO\s0 when system's stdio
does not permit perl's \*(L"fast gets\*(R" access, and which do not
distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """stdio""" 4
.el .IP "``stdio''" 4
.IX Item "stdio"
A layer which provides the PerlIO \s-1API\s0 via the layer scheme, but
implements it by calling system's stdio. This is (currently) the default
if system's stdio provides sufficient access to allow perl's \*(L"fast gets\*(R"
access and which do not distinguish between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """crlf""" 4
.el .IP "``crlf''" 4
.IX Item "crlf"
A layer derived using \*(L"perlio\*(R" as a base class. It provides Win32\-like
\&\*(L"\en\*(R" to \s-1CR,LF\s0 translation. Can either be applied above \*(L"perlio\*(R" or serve
as the buffer layer itself. \*(L"crlf\*(R" over \*(L"unix\*(R" is the default if system
distinguishes between \f(CW\*(C`O_TEXT\*(C'\fR and \f(CW\*(C`O_BINARY\*(C'\fR opens. (At some point
\&\*(L"unix\*(R" will be replaced by a \*(L"native\*(R" Win32 \s-1IO\s0 layer on that platform,
as Win32's read/write layer has various drawbacks.) The \*(L"crlf\*(R" layer is
a reasonable model for a layer which transforms data in some way.
.ie n .IP """mmap""" 4
.el .IP "``mmap''" 4
.IX Item "mmap"
If Configure detects \f(CW\*(C`mmap()\*(C'\fR functions this layer is provided (with
\&\*(L"perlio\*(R" as a \*(L"base\*(R") which does \*(L"read\*(R" operations by \fImmap()\fRing the
file. Performance improvement is marginal on modern systems, so it is
mainly there as a proof of concept. It is likely to be unbundled from
the core at some point. The \*(L"mmap\*(R" layer is a reasonable model for a
minimalist \*(L"derived\*(R" layer.
.ie n .IP """pending""" 4
.el .IP "``pending''" 4
.IX Item "pending"
An \*(L"internal\*(R" derivative of \*(L"perlio\*(R" which can be used to provide
\&\fIUnread()\fR function for layers which have no buffer or cannot be
bothered.  (Basically this layer's \f(CW\*(C`Fill()\*(C'\fR pops itself off the stack
and so resumes reading from layer below.)
.ie n .IP """raw""" 4
.el .IP "``raw''" 4
.IX Item "raw"
A dummy layer which never exists on the layer stack. Instead when
\&\*(L"pushed\*(R" it actually pops the stack removing itself, it then calls
Binmode function table entry on all the layers in the stack \- normally
this (via PerlIOBase_binmode) removes any layers which do not have
\&\f(CW\*(C`PERLIO_K_RAW\*(C'\fR bit set. Layers can modify that behaviour by defining
their own Binmode entry.
.ie n .IP """utf8""" 4
.el .IP "``utf8''" 4
.IX Item "utf8"
Another dummy layer. When pushed it pops itself and sets the
\&\f(CW\*(C`PERLIO_F_UTF8\*(C'\fR flag on the layer which was (and now is once more)
the top of the stack.
.PP
In addition \fIperlio.c\fR also provides a number of \f(CW\*(C`PerlIOBase_xxxx()\*(C'\fR
functions which are intended to be used in the table slots of classes
which do not need to do anything special for a particular method.
.SS "Extension Layers"
.IX Subsection "Extension Layers"
Layers can be made available by extension modules. When an unknown layer
is encountered the PerlIO code will perform the equivalent of :
.PP
.Vb 1
\&   use PerlIO \*(Aqlayer\*(Aq;
.Ve
.PP
Where \fIlayer\fR is the unknown layer. \fIPerlIO.pm\fR will then attempt to:
.PP
.Vb 1
\&   require PerlIO::layer;
.Ve
.PP
If after that process the layer is still not defined then the \f(CW\*(C`open\*(C'\fR
will fail.
.PP
The following extension layers are bundled with perl:
.ie n .IP """:encoding""" 4
.el .IP "``:encoding''" 4
.IX Item ":encoding"
.Vb 1
\&   use Encoding;
.Ve
.Sp
makes this layer available, although \fIPerlIO.pm\fR \*(L"knows\*(R" where to
find it.  It is an example of a layer which takes an argument as it is
called thus:
.Sp
.Vb 1
\&   open( $fh, "<:encoding(iso\-8859\-7)", $pathname );
.Ve
.ie n .IP """:scalar""" 4
.el .IP "``:scalar''" 4
.IX Item ":scalar"
Provides support for reading data from and writing data to a scalar.
.Sp
.Vb 1
\&   open( $fh, "+<:scalar", \e$scalar );
.Ve
.Sp
When a handle is so opened, then reads get bytes from the string value
of \fI\f(CI$scalar\fI\fR, and writes change the value. In both cases the position
in \fI\f(CI$scalar\fI\fR starts as zero but can be altered via \f(CW\*(C`seek\*(C'\fR, and
determined via \f(CW\*(C`tell\*(C'\fR.
.Sp
Please note that this layer is implied when calling \fIopen()\fR thus:
.Sp
.Vb 1
\&   open( $fh, "+<", \e$scalar );
.Ve
.ie n .IP """:via""" 4
.el .IP "``:via''" 4
.IX Item ":via"
Provided to allow layers to be implemented as Perl code.  For instance:
.Sp
.Vb 2
\&   use PerlIO::via::StripHTML;
\&   open( my $fh, "<:via(StripHTML)", "index.html" );
.Ve
.Sp
See PerlIO::via for details.
.SH "TODO"
.IX Header "TODO"
Things that need to be done to improve this document.
.IP "\(bu" 4
Explain how to make a valid fh without going through \fIopen()\fR(i.e. apply
a layer). For example if the file is not opened through perl, but we
want to get back a fh, like it was opened by Perl.
.Sp
How PerlIO_apply_layera fits in, where its docs, was it made public?
.Sp
Currently the example could be something like this:
.Sp
.Vb 8
\&  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
\&  {
\&      char *mode; /* "w", "r", etc */
\&      const char *layers = ":APR"; /* the layer name */
\&      PerlIO *f = PerlIO_allocate(aTHX);
\&      if (!f) {
\&          return NULL;
\&      }
\&
\&      PerlIO_apply_layers(aTHX_ f, mode, layers);
\&
\&      if (f) {
\&          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
\&          /* fill in the st struct, as in _open() */
\&          st\->file = file;
\&          PerlIOBase(f)\->flags |= PERLIO_F_OPEN;
\&
\&          return f;
\&      }
\&      return NULL;
\&  }
.Ve
.IP "\(bu" 4
fix/add the documentation in places marked as \s-1XXX.\s0
.IP "\(bu" 4
The handling of errors by the layer is not specified. e.g. when $!
should be set explicitly, when the error handling should be just
delegated to the top layer.
.Sp
Probably give some hints on using \s-1\fISETERRNO\s0()\fR or pointers to where they
can be found.
.IP "\(bu" 4
I think it would help to give some concrete examples to make it easier
to understand the \s-1API.\s0 Of course I agree that the \s-1API\s0 has to be
concise, but since there is no second document that is more of a
guide, I think that it'd make it easier to start with the doc which is
an \s-1API,\s0 but has examples in it in places where things are unclear, to
a person who is not a PerlIO guru (yet).
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlipc.1                                    0100644 0001750 0001750 00000242551 12566207441 022406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIPC 1"
.TH PERLIPC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlipc \- Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The basic \s-1IPC\s0 facilities of Perl are built out of the good old Unix
signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
\&\s-1IPC\s0 calls.  Each is used in slightly different situations.
.SH "Signals"
.IX Header "Signals"
Perl uses a simple signal handling model: the \f(CW%SIG\fR hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.
.PP
For example, to trap an interrupt signal, set up a handler like this:
.PP
.Vb 1
\&    our $shucks;
\&
\&    sub catch_zap {
\&        my $signame = shift;
\&        $shucks++;
\&        die "Somebody sent me a SIG$signame";
\&    }
\&    $SIG{INT} = _\|_PACKAGE_\|_ . "::catch_zap";  
\&    $SIG{INT} = \e&catch_zap;  # best strategy
.Ve
.PP
Prior to Perl 5.8.0 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly \fIanything\fR in your
handler could in theory trigger a memory fault and subsequent core
dump \- see \*(L"Deferred Signals (Safe Signals)\*(R" below.
.PP
The names of the signals are the ones listed out by \f(CW\*(C`kill \-l\*(C'\fR on your
system, or you can retrieve them using the \s-1CPAN\s0 module IPC::Signal.
.PP
You may also choose to assign the strings \f(CW"IGNORE"\fR or \f(CW"DEFAULT"\fR as
the handler, in which case Perl will try to discard the signal or do the
default thing.
.PP
On most Unix platforms, the \f(CW\*(C`CHLD\*(C'\fR (sometimes also known as \f(CW\*(C`CLD\*(C'\fR) signal
has special behavior with respect to a value of \f(CW"IGNORE"\fR.
Setting \f(CW$SIG{CHLD}\fR to \f(CW"IGNORE"\fR on such a platform has the effect of
not creating zombie processes when the parent process fails to \f(CW\*(C`wait()\*(C'\fR
on its child processes (i.e., child processes are automatically reaped).
Calling \f(CW\*(C`wait()\*(C'\fR with \f(CW$SIG{CHLD}\fR set to \f(CW"IGNORE"\fR usually returns
\&\f(CW\*(C`\-1\*(C'\fR on such platforms.
.PP
Some signals can be neither trapped nor ignored, such as the \s-1KILL\s0 and \s-1STOP
\&\s0(but not the \s-1TSTP\s0) signals. Note that ignoring signals makes them disappear.
If you only want them blocked temporarily without them getting lost you'll
have to use \s-1POSIX\s0' sigprocmask.
.PP
Sending a signal to a negative process \s-1ID\s0 means that you send the signal
to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets \f(CW$SIG\fR{\s-1HUP\s0} to \f(CW"IGNORE"\fR 
so it doesn't kill itself:
.PP
.Vb 6
\&    # block scope for local
\&    {
\&        local $SIG{HUP} = "IGNORE";
\&        kill HUP => \-$$;
\&        # snazzy writing of: kill("HUP", \-$$)
\&    }
.Ve
.PP
Another interesting signal to send is signal number zero.  This doesn't
actually affect a child process, but instead checks whether it's alive
or has changed its UIDs.
.PP
.Vb 3
\&    unless (kill 0 => $kid_pid) {
\&        warn "something wicked happened to $kid_pid";
\&    }
.Ve
.PP
Signal number zero may fail because you lack permission to send the
signal when directed at a process whose real or saved \s-1UID\s0 is not
identical to the real or effective \s-1UID\s0 of the sending process, even
though the process is alive.  You may be able to determine the cause of
failure using \f(CW$!\fR or \f(CW\*(C`%!\*(C'\fR.
.PP
.Vb 3
\&    unless (kill(0 => $pid) || $!{EPERM}) {
\&        warn "$pid looks dead";
\&    }
.Ve
.PP
You might also want to employ anonymous functions for simple signal
handlers:
.PP
.Vb 1
\&    $SIG{INT} = sub { die "\enOutta here!\en" };
.Ve
.PP
\&\s-1SIGCHLD\s0 handlers require some special care.  If a second child dies
while in the signal handler caused by the first death, we won't get
another signal. So must loop here else we will leave the unreaped child
as a zombie. And the next time two children die we get another zombie.
And so on.
.PP
.Vb 7
\&    use POSIX ":sys_wait_h";
\&    $SIG{CHLD} = sub {
\&        while ((my $child = waitpid(\-1, WNOHANG)) > 0) {
\&            $Kid_Status{$child} = $?;
\&        }
\&    };
\&    # do something that forks...
.Ve
.PP
Be careful: \fIqx()\fR, \fIsystem()\fR, and some modules for calling external commands
do a \fIfork()\fR, then \fIwait()\fR for the result. Thus, your signal handler
will be called. Because \fIwait()\fR was already called by \fIsystem()\fR or \fIqx()\fR,
the \fIwait()\fR in the signal handler will see no more zombies and will
therefore block.
.PP
The best way to prevent this issue is to use \fIwaitpid()\fR, as in the following
example:
.PP
.Vb 1
\&    use POSIX ":sys_wait_h"; # for nonblocking read
\&
\&    my %children;
\&
\&    $SIG{CHLD} = sub {
\&        # don\*(Aqt change $! and $? outside handler
\&        local ($!, $?);
\&        my $pid = waitpid(\-1, WNOHANG);
\&        return if $pid == \-1;
\&        return unless defined $children{$pid};
\&        delete $children{$pid};
\&        cleanup_child($pid, $?);
\&    };
\&
\&    while (1) {
\&        my $pid = fork();
\&        die "cannot fork" unless defined $pid;
\&        if ($pid == 0) {
\&            # ...
\&            exit 0;
\&        } else {
\&            $children{$pid}=1;
\&            # ...
\&            system($command);
\&            # ...
\&       }
\&    }
.Ve
.PP
Signal handling is also used for timeouts in Unix.  While safely
protected within an \f(CW\*(C`eval{}\*(C'\fR block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your \f(CW\*(C`eval{}\*(C'\fR block.  If it
goes off, you'll use \fIdie()\fR to jump out of the block.
.PP
Here's an example:
.PP
.Vb 9
\&    my $ALARM_EXCEPTION = "alarm clock restart";
\&    eval {
\&        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
\&        alarm 10;
\&        flock(FH, 2)    # blocking write lock
\&                        || die "cannot flock: $!";
\&        alarm 0;
\&    };
\&    if ($@ && $@ !~ quotemeta($ALARM_EXCEPTION)) { die }
.Ve
.PP
If the operation being timed out is \fIsystem()\fR or \fIqx()\fR, this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own \fIfork()\fR and \fIexec()\fR, and kill the errant child process.
.PP
For more complex signal handling, you might see the standard \s-1POSIX\s0
module.  Lamentably, this is almost entirely undocumented, but
the \fIt/lib/posix.t\fR file from the Perl source distribution has some
examples in it.
.SS "Handling the \s-1SIGHUP\s0 Signal in Daemons"
.IX Subsection "Handling the SIGHUP Signal in Daemons"
A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a \f(CW\*(C`SIGHUP\*(C'\fR
signal handler. When you want to tell the daemon to reread the file,
simply send it the \f(CW\*(C`SIGHUP\*(C'\fR signal.
.PP
The following example implements a simple daemon, which restarts
itself every time the \f(CW\*(C`SIGHUP\*(C'\fR signal is received. The actual code is
located in the subroutine \f(CW\*(C`code()\*(C'\fR, which just prints some debugging
info to show that it works; it should be replaced with the real code.
.PP
.Vb 1
\&  #!/usr/bin/perl \-w
\&
\&  use POSIX ();
\&  use FindBin ();
\&  use File::Basename ();
\&  use File::Spec::Functions;
\&
\&  $| = 1;
\&
\&  # make the daemon cross\-platform, so exec always calls the script
\&  # itself with the right path, no matter how the script was invoked.
\&  my $script = File::Basename::basename($0);
\&  my $SELF  = catfile($FindBin::Bin, $script);
\&
\&  # POSIX unmasks the sigprocmask properly
\&  $SIG{HUP} = sub {
\&      print "got SIGHUP\en";
\&      exec($SELF, @ARGV)        || die "$0: couldn\*(Aqt restart: $!";
\&  };
\&
\&  code();
\&
\&  sub code {
\&      print "PID: $$\en";
\&      print "ARGV: @ARGV\en";
\&      my $count = 0;
\&      while (++$count) {
\&          sleep 2;
\&          print "$count\en";
\&      }
\&  }
.Ve
.SS "Deferred Signals (Safe Signals)"
.IX Subsection "Deferred Signals (Safe Signals)"
Before Perl 5.8.0, installing Perl code to deal with signals exposed you to
danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like \fImalloc\fR\|(3) or \fIprintf\fR\|(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior\*(--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.
.PP
There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to \f(CW\*(C`die\*(C'\fR to \fIlongjmp\fR\|(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids \f(CW\*(C`die\*(C'\fR in a handler because the system \fIis\fR out to get you.
The pragmatic approach was to say \*(L"I know the risks, but prefer the
convenience\*(R", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.
.PP
Perl 5.8.0 and later avoid these problems by \*(L"deferring\*(R" signals.  That is,
when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic \*(L"safe\*(R" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from \f(CW%SIG\fR is executed. The \*(L"deferred\*(R" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library
function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:
.IP "Long-running opcodes" 4
.IX Item "Long-running opcodes"
As the Perl interpreter looks at signal flags only when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.
.Sp
If a signal of any given type fires multiple times during an opcode 
(such as from a fine-grained timer), the handler for that signal will
be called only once, after the opcode completes; all other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling \f(CWalarm(0)\fR as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.
.IP "Interrupting \s-1IO\s0" 4
.IX Item "Interrupting IO"
When a signal is delivered (e.g., \s-1SIGINT\s0 from a control-C) the operating
system breaks into \s-1IO\s0 operations like \fIread\fR(2), which is used to
implement Perl's \fIreadline()\fR function, the \f(CW\*(C`<>\*(C'\fR operator. On older
Perls the handler was called immediately (and as \f(CW\*(C`read\*(C'\fR is not \*(L"unsafe\*(R",
this worked well). With the \*(L"deferred\*(R" scheme the handler is \fInot\fR called
immediately, and if Perl is using the system's \f(CW\*(C`stdio\*(C'\fR library that
library may restart the \f(CW\*(C`read\*(C'\fR without returning to Perl to give it a
chance to call the \f(CW%SIG\fR handler. If this happens on your system the
solution is to use the \f(CW\*(C`:perlio\*(C'\fR layer to do IO\*(--at least on those handles
that you want to be able to break into with signals. (The \f(CW\*(C`:perlio\*(C'\fR layer
checks the signal flags and calls \f(CW%SIG\fR handlers before resuming \s-1IO\s0
operation.)
.Sp
The default in Perl 5.8.0 and later is to automatically use
the \f(CW\*(C`:perlio\*(C'\fR layer.
.Sp
Note that it is not advisable to access a file handle within a signal
handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.
.Sp
Some networking library functions like \fIgethostbyname()\fR are known to have
their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the \s-1POSIX\s0
\&\fIsigaction()\fR function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.
.Sp
Instead of setting \f(CW$SIG{ALRM}\fR:
.Sp
.Vb 1
\&   local $SIG{ALRM} = sub { die "alarm" };
.Ve
.Sp
try something like the following:
.Sp
.Vb 3
\&  use POSIX qw(SIGALRM);
\&  POSIX::sigaction(SIGALRM, POSIX::SigAction\->new(sub { die "alarm" }))
\&          || die "Error setting SIGALRM handler: $!\en";
.Ve
.Sp
Another way to disable the safe signal behavior locally is to use
the \f(CW\*(C`Perl::Unsafe::Signals\*(C'\fR module from \s-1CPAN,\s0 which affects
all signals.
.IP "Restartable system calls" 4
.IX Item "Restartable system calls"
On systems that supported it, older versions of Perl used the
\&\s-1SA_RESTART\s0 flag when installing \f(CW%SIG\fR handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.8.0 and later do \fInot\fR use \s-1SA_RESTART. \s0 Consequently, 
restartable system calls can fail (with $! set to \f(CW\*(C`EINTR\*(C'\fR) in places
where they previously would have succeeded.
.Sp
The default \f(CW\*(C`:perlio\*(C'\fR layer retries \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`write\*(C'\fR
and \f(CW\*(C`close\*(C'\fR as described above; interrupted \f(CW\*(C`wait\*(C'\fR and 
\&\f(CW\*(C`waitpid\*(C'\fR calls will always be retried.
.ie n .IP "Signals as ""faults""" 4
.el .IP "Signals as ``faults''" 4
.IX Item "Signals as faults"
Certain signals like \s-1SEGV, ILL,\s0 and \s-1BUS\s0 are generated by virtual memory
addressing errors and similar \*(L"faults\*(R". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl delivers them
immediately rather than attempting to defer them.
.IP "Signals triggered by operating system state" 4
.IX Item "Signals triggered by operating system state"
On some operating systems certain signal handlers are supposed to \*(L"do
something\*(R" before returning. One example can be \s-1CHLD\s0 or \s-1CLD,\s0 which
indicates a child process has completed. On some operating systems the
signal handler is expected to \f(CW\*(C`wait\*(C'\fR for the completed child
process. On such systems the deferred signal scheme will not work for
those signals: it does not do the \f(CW\*(C`wait\*(C'\fR. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been \f(CW\*(C`wait\*(C'\fRed for.
.PP
If you want the old signal behavior back despite possible
memory corruption, set the environment variable \f(CW\*(C`PERL_SIGNALS\*(C'\fR to
\&\f(CW"unsafe"\fR.  This feature first appeared in Perl 5.8.1.
.SH "Named Pipes"
.IX Header "Named Pipes"
A named pipe (often referred to as a \s-1FIFO\s0) is an old Unix \s-1IPC\s0
mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.
.PP
To create a named pipe, use the \f(CW\*(C`POSIX::mkfifo()\*(C'\fR function.
.PP
.Vb 2
\&    use POSIX qw(mkfifo);
\&    mkfifo($path, 0700)     ||  die "mkfifo $path failed: $!";
.Ve
.PP
You can also use the Unix command \fImknod\fR\|(1), or on some
systems, \fImkfifo\fR\|(1).  These may not be in your normal path, though.
.PP
.Vb 8
\&    # system return val is backwards, so && not ||
\&    #
\&    $ENV{PATH} .= ":/etc:/usr/etc";
\&    if  (      system("mknod",  $path, "p")
\&            && system("mkfifo", $path) )
\&    {
\&        die "mk{nod,fifo} $path failed";
\&    }
.Ve
.PP
A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.
.PP
For example, let's say you'd like to have your \fI.signature\fR file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, \fB\-p\fR, to find
out whether anyone (or anything) has accidentally removed our fifo.
.PP
.Vb 2
\&    chdir();    # go home
\&    my $FIFO = ".signature";
\&
\&    while (1) {
\&        unless (\-p $FIFO) {
\&            unlink $FIFO;   # discard any failure, will catch later
\&            require POSIX;  # delayed loading of heavy module
\&            POSIX::mkfifo($FIFO, 0700)
\&                                || die "can\*(Aqt mkfifo $FIFO: $!";
\&        }
\&
\&        # next line blocks till there\*(Aqs a reader
\&        open (FIFO, "> $FIFO")  || die "can\*(Aqt open $FIFO: $!";
\&        print FIFO "John Smith (smith\e@host.org)\en", \`fortune \-s\`;
\&        close(FIFO)             || die "can\*(Aqt close $FIFO: $!";
\&        sleep 2;                # to avoid dup signals
\&    }
.Ve
.SH "Using \fIopen()\fP for IPC"
.IX Header "Using open() for IPC"
Perl's basic \fIopen()\fR statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to \fIopen()\fR.  Here's how to start
something up in a child process you intend to write to:
.PP
.Vb 5
\&    open(SPOOLER, "| cat \-v | lpr \-h 2>/dev/null")
\&                        || die "can\*(Aqt fork: $!";
\&    local $SIG{PIPE} = sub { die "spooler pipe broke" };
\&    print SPOOLER "stuff\en";
\&    close SPOOLER       || die "bad spool: $! $?";
.Ve
.PP
And here's how to start up a child process you intend to read from:
.PP
.Vb 7
\&    open(STATUS, "netstat \-an 2>&1 |")
\&                        || die "can\*(Aqt fork: $!";
\&    while (<STATUS>) {
\&        next if /^(tcp|udp)/;
\&        print;
\&    }
\&    close STATUS        || die "bad netstat: $! $?";
.Ve
.PP
If one can be sure that a particular program is a Perl script expecting
filenames in \f(CW@ARGV\fR, the clever programmer can write something like this:
.PP
.Vb 1
\&    % program f1 "cmd1|" \- f2 "cmd2|" f3 < tmpfile
.Ve
.PP
and no matter which sort of shell it's called from, the Perl program will
read from the file \fIf1\fR, the process \fIcmd1\fR, standard input (\fItmpfile\fR
in this case), the \fIf2\fR file, the \fIcmd2\fR command, and finally the \fIf3\fR
file.  Pretty nifty, eh?
.PP
You might notice that you could use backticks for much the
same effect as opening a pipe for reading:
.PP
.Vb 2
\&    print grep { !/^(tcp|udp)/ } \`netstat \-an 2>&1\`;
\&    die "bad netstatus ($?)" if $?;
.Ve
.PP
While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you kill off the child process early if you'd like.
.PP
Be careful to check the return values from both \fIopen()\fR and \fIclose()\fR.  If
you're \fIwriting\fR to a pipe, you should also trap \s-1SIGPIPE. \s0 Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the \fIopen()\fR will in all likelihood succeed (it only reflects the
\&\fIfork()\fR's success), but then your output will fail\*(--spectacularly.  Perl
can't know whether the command worked, because your command is actually
running in a separate process whose \fIexec()\fR might have failed.  Therefore,
while readers of bogus commands return just a quick \s-1EOF,\s0 writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:
.PP
.Vb 4
\&    open(FH, "|bogus")      || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";      #  neither necessary nor sufficient 
\&                            #  to check print retval!
\&    close(FH)               || die "can\*(Aqt close: $!";
.Ve
.PP
The reason for not checking the return value from \fIprint()\fR is because of
pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a \s-1SIGPIPE. \s0 To catch it, you could use
this:
.PP
.Vb 4
\&    $SIG{PIPE} = "IGNORE";
\&    open(FH, "|bogus")  || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";
\&    close(FH)           || die "can\*(Aqt close: status=$?";
.Ve
.SS "Filehandles"
.IX Subsection "Filehandles"
Both the main process and any child processes it forks share the same
\&\s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with \fIopen()\fR, but on some systems this means that the
child process cannot outlive the parent.
.SS "Background Processes"
.IX Subsection "Background Processes"
You can run a command in the background with:
.PP
.Vb 1
\&    system("cmd &");
.Ve
.PP
The command's \s-1STDOUT\s0 and \s-1STDERR \s0(and possibly \s-1STDIN,\s0 depending on your
shell) will be the same as the parent's.  You won't need to catch
\&\s-1SIGCHLD\s0 because of the double-fork taking place; see below for details.
.SS "Complete Dissociation of Child from Parent"
.IX Subsection "Complete Dissociation of Child from Parent"
In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well-behaved daemon will also \fIchdir()\fR
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to \fI/dev/null\fR so that random
output doesn't wind up on the user's terminal.
.PP
.Vb 1
\&    use POSIX "setsid";
\&
\&    sub daemonize {
\&        chdir("/")                      || die "can\*(Aqt chdir to /: $!";
\&        open(STDIN,  "< /dev/null")     || die "can\*(Aqt read /dev/null: $!";
\&        open(STDOUT, "> /dev/null")     || die "can\*(Aqt write to /dev/null: $!";
\&        defined(my $pid = fork())       || die "can\*(Aqt fork: $!";
\&        exit if $pid;                   # non\-zero now means I am the parent
\&        (setsid() != \-1)                || die "Can\*(Aqt start a new session: $!";
\&        open(STDERR, ">&STDOUT")        || die "can\*(Aqt dup stdout: $!";
\&    }
.Ve
.PP
The \fIfork()\fR has to come before the \fIsetsid()\fR to ensure you aren't a
process group leader; the \fIsetsid()\fR will fail if you are.  If your
system doesn't have the \fIsetsid()\fR function, open \fI/dev/tty\fR and use the
\&\f(CW\*(C`TIOCNOTTY\*(C'\fR \fIioctl()\fR on it instead.  See \fItty\fR\|(4) for details.
.PP
Non-Unix users should check their \f(CW\*(C`\f(CIYour_OS\f(CW::Process\*(C'\fR module for 
other possible solutions.
.SS "Safe Pipe Opens"
.IX Subsection "Safe Pipe Opens"
Another interesting approach to \s-1IPC\s0 is making your single program go
multiprocess and communicate between\*(--or even amongst\*(--yourselves.  The
\&\fIopen()\fR function will accept a file argument of either \f(CW"\-|"\fR or \f(CW"|\-"\fR
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed \s-1UID\s0 or \s-1GID,\s0 for example.  If you open a pipe \fIto\fR minus, you can
write to the filehandle you opened and your kid will find it in \fIhis\fR
\&\s-1STDIN. \s0 If you open a pipe \fIfrom\fR minus, you can read from the filehandle
you opened whatever your kid writes to \fIhis\fR \s-1STDOUT.\s0
.PP
.Vb 4
\&    use English qw[ \-no_match_vars ];
\&    my $PRECIOUS = "/path/to/some/safe/file";
\&    my $sleep_count;
\&    my $pid;
\&
\&    do {
\&        $pid = open(KID_TO_WRITE, "|\-");
\&        unless (defined $pid) {
\&            warn "cannot fork: $!";
\&            die "bailing out" if $sleep_count++ > 6;
\&            sleep 10;
\&        }
\&    } until defined $pid;
\&
\&    if ($pid) {                 # I am the parent 
\&        print KID_TO_WRITE @some_data;
\&        close(KID_TO_WRITE)     || warn "kid exited $?";
\&    } else {                    # I am the child
\&        # drop permissions in setuid and/or setgid programs:
\&        ($EUID, $EGID) = ($UID, $GID);  
\&        open (OUTFILE, "> $PRECIOUS") 
\&                                || die "can\*(Aqt open $PRECIOUS: $!";
\&        while (<STDIN>) {
\&            print OUTFILE;      # child\*(Aqs STDIN is parent\*(Aqs KID_TO_WRITE
\&        }
\&        close(OUTFILE)          || die "can\*(Aqt close $PRECIOUS: $!";
\&        exit(0);                # don\*(Aqt forget this!!
\&    }
.Ve
.PP
Another common use for this construct is when you need to execute
something without the shell's interference.  With \fIsystem()\fR, it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call \fIexec()\fR directly.
.PP
Here's a safe backtick or pipe open for read:
.PP
.Vb 2
\&    my $pid = open(KID_TO_READ, "\-|");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    if ($pid) {             # parent
\&        while (<KID_TO_READ>) {
\&                            # do something interesting
\&        }
\&        close(KID_TO_READ)  || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID); # suid only
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
And here's a safe pipe open for writing:
.PP
.Vb 2
\&    my $pid = open(KID_TO_WRITE, "|\-");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };
\&
\&    if ($pid) {             # parent
\&        print KID_TO_WRITE @data;
\&        close(KID_TO_WRITE) || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID);
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
It is very easy to dead-lock a process using this form of \fIopen()\fR, or
indeed with any use of \fIpipe()\fR with multiple subprocesses.  The 
example above is \*(L"safe\*(R" because it is simple and calls \fIexec()\fR.  See
\&\*(L"Avoiding Pipe Deadlocks\*(R" for general safety principles, but there
are extra gotchas with Safe Pipe Opens.
.PP
In particular, if you opened the pipe using \f(CW\*(C`open FH, "|\-"\*(C'\fR, then you
cannot simply use \fIclose()\fR in the parent process to close an unwanted
writer.  Consider this code:
.PP
.Vb 10
\&    my $pid = open(WRITER, "|\-");        # fork open a kid
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "second fork failed: $!";
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            # now do something else...
\&        }
\&        else {
\&            # first write to WRITER
\&            # ...
\&            # then when finished
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&    }
\&    else {
\&        # first do something with STDIN, then
\&        exit(0);
\&    }
.Ve
.PP
In the example above, the true parent does not want to write to the \s-1WRITER\s0
filehandle, so it closes it.  However, because \s-1WRITER\s0 was opened using
\&\f(CW\*(C`open FH, "|\-"\*(C'\fR, it has a special behavior: closing it calls
\&\fIwaitpid()\fR (see \*(L"waitpid\*(R" in perlfunc), which waits for the subprocess
to exit.  If the child process ends up waiting for something happening
in the section marked \*(L"do something else\*(R", you have deadlock.
.PP
This can also be a problem with intermediate subprocesses in more
complicated code, which will call \fIwaitpid()\fR on all open filehandles
during global destruction\*(--in no predictable order.
.PP
To solve this, you must manually use \fIpipe()\fR, \fIfork()\fR, and the form of
\&\fIopen()\fR which sets one file descriptor to another, as shown below:
.PP
.Vb 10
\&    pipe(READER, WRITER)        || die "pipe failed: $!";
\&    $pid = fork();
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        close READER;
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "first fork failed: $!";
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&        }
\&        else {
\&            # write to WRITER...
\&            # ...
\&            # then  when finished
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&        # write to WRITER...
\&    }
\&    else {
\&        open(STDIN, "<&READER") || die "can\*(Aqt reopen STDIN: $!";
\&        close(WRITER)           || die "can\*(Aqt close WRITER: $!";
\&        # do something...
\&        exit(0);
\&    }
.Ve
.PP
Since Perl 5.8.0, you can also use the list form of \f(CW\*(C`open\*(C'\fR for pipes.
This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.
.PP
So for example, instead of using:
.PP
.Vb 1
\&    open(PS_PIPE, "ps aux|")    || die "can\*(Aqt open ps pipe: $!";
.Ve
.PP
One would use either of these:
.PP
.Vb 2
\&    open(PS_PIPE, "\-|", "ps", "aux") 
\&                                || die "can\*(Aqt open ps pipe: $!";
\&
\&    @ps_args = qw[ ps aux ];
\&    open(PS_PIPE, "\-|", @ps_args)
\&                                || die "can\*(Aqt open @ps_args|: $!";
.Ve
.PP
Because there are more than three arguments to \fIopen()\fR, forks the \fIps\fR\|(1)
command \fIwithout\fR spawning a shell, and reads its standard output via the
\&\f(CW\*(C`PS_PIPE\*(C'\fR filehandle.  The corresponding syntax to \fIwrite\fR to command
pipes is to use \f(CW"|\-"\fR in place of \f(CW"\-|"\fR.
.PP
This was admittedly a rather silly example, because you're using string
literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe \fIopen()\fR.  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of \fIopen()\fR should be used.  For example:
.PP
.Vb 3
\&    @grep_args = ("egrep", "\-i", $some_pattern, @many_files);
\&    open(GREP_PIPE, "\-|", @grep_args)
\&                        || die "can\*(Aqt open @grep_args|: $!";
.Ve
.PP
Here the multi-argument form of pipe \fIopen()\fR is preferred because the
pattern and indeed even the filenames themselves might hold metacharacters.
.PP
Be aware that these operations are full Unix forks, which means they may
not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the \fImodules\fR
file mentioned below in the \s-1SEE ALSO\s0 section.
.SS "Avoiding Pipe Deadlocks"
.IX Subsection "Avoiding Pipe Deadlocks"
Whenever you have more than one subprocess, you must be careful that each
closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an \s-1EOF\s0 will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read \s-1EOF.\s0
.PP
Certain built-in Unix features help prevent this most of the time.  For
instance, filehandles have a \*(L"close on exec\*(R" flag, which is set \fIen masse\fR
under control of the \f(CW$^F\fR variable.  This is so any filehandles you
didn't explicitly route to the \s-1STDIN, STDOUT\s0 or \s-1STDERR\s0 of a child
\&\fIprogram\fR will be automatically closed.
.PP
Always explicitly and immediately call \fIclose()\fR on the writable end of any
pipe, unless that process is actually writing to it.  Even if you don't
explicitly call \fIclose()\fR, Perl will still \fIclose()\fR all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling \fIwaitpid()\fR,
which may again deadlock.
.SS "Bidirectional Communication with Another Process"
.IX Subsection "Bidirectional Communication with Another Process"
While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The most obvious approach doesn't work:
.PP
.Vb 2
\&    # THIS DOES NOT WORK!!
\&    open(PROG_FOR_READING_AND_WRITING, "| some program |")
.Ve
.PP
If you forget to \f(CW\*(C`use warnings\*(C'\fR, you'll miss out entirely on the
helpful diagnostic message:
.PP
.Vb 1
\&    Can\*(Aqt do bidirectional pipe at \-e line 1.
.Ve
.PP
If you really want to, you can use the standard \fIopen2()\fR from the
\&\f(CW\*(C`IPC::Open2\*(C'\fR module to catch both ends.  There's also an \fIopen3()\fR in
\&\f(CW\*(C`IPC::Open3\*(C'\fR for tridirectional I/O so you can also catch your child's
\&\s-1STDERR,\s0 but doing so would then require an awkward \fIselect()\fR loop and
wouldn't allow you to use normal Perl input operations.
.PP
If you look at its source, you'll see that \fIopen2()\fR uses low-level
primitives like the \fIpipe()\fR and \fIexec()\fR syscalls to create all the
connections.  Although it might have been more efficient by using
\&\fIsocketpair()\fR, this would have been even less portable than it already
is. The \fIopen2()\fR and \fIopen3()\fR functions are unlikely to work anywhere
except on a Unix system, or at least one purporting \s-1POSIX\s0 compliance.
.PP
Here's an example of using \fIopen2()\fR:
.PP
.Vb 5
\&    use FileHandle;
\&    use IPC::Open2;
\&    $pid = open2(*Reader, *Writer, "cat \-un");
\&    print Writer "stuff\en";
\&    $got = <Reader>;
.Ve
.PP
The problem with this is that buffering is really going to ruin your
day.  Even though your \f(CW\*(C`Writer\*(C'\fR filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
\&\fIcat\fR a \fB\-u\fR flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.
.PP
A solution to this is to use a library which uses pseudottys to make your
program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The \f(CW\*(C`Expect\*(C'\fR module
from \s-1CPAN\s0 also addresses this kind of thing.  This module requires two
other modules from \s-1CPAN, \s0\f(CW\*(C`IO::Pty\*(C'\fR and \f(CW\*(C`IO::Stty\*(C'\fR.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.
.SS "Bidirectional Communication with Yourself"
.IX Subsection "Bidirectional Communication with Yourself"
If you want, you may make low-level \fIpipe()\fR and \fIfork()\fR syscalls to stitch
this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to \s-1STDIN\s0 and \s-1STDOUT\s0 and call other processes.
(The following example lacks proper error checking.)
.PP
.Vb 8
\&    #!/usr/bin/perl \-w
\&    # pipe1 \- bidirectional communication using two pipe pairs
\&    #         designed for the socketpair\-challenged
\&    use IO::Handle;               # thousands of lines just for autoflush :\-(
\&    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
\&    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
\&    CHILD_WTR\->autoflush(1);
\&    PARENT_WTR\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        print CHILD_WTR "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD_RDR>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD_RDR; close CHILD_WTR;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD_RDR; 
\&        close CHILD_WTR;
\&        chomp($line = <PARENT_RDR>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT_WTR "Child Pid $$ is sending this\en";
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        exit(0);
\&    }
.Ve
.PP
But you don't actually have to make two pipe calls.  If you
have the \fIsocketpair()\fR system call, it will do this all for you.
.PP
.Vb 3
\&    #!/usr/bin/perl \-w
\&    # pipe2 \- bidirectional communication using socketpair
\&    #   "the best ones always go both ways"
\&
\&    use Socket;
\&    use IO::Handle;  # thousands of lines just for autoflush :\-(
\&
\&    # We say AF_UNIX because although *_LOCAL is the
\&    # POSIX 1003.1g form of the constant, many machines
\&    # still don\*(Aqt have it.
\&    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
\&                                ||  die "socketpair: $!";
\&
\&    CHILD\->autoflush(1);
\&    PARENT\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT;
\&        print CHILD "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD;
\&        chomp($line = <PARENT>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT "Child Pid $$ is sending this\en";
\&        close PARENT;
\&        exit(0);
\&    }
.Ve
.SH "Sockets: Client/Server Communication"
.IX Header "Sockets: Client/Server Communication"
While not entirely limited to Unix-derived operating systems (e.g., WinSock
on PCs provides socket support, as do some \s-1VMS\s0 libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like \s-1TCP\s0
streams and datagrams like \s-1UDP\s0 packets.  You may be able to do even more
depending on your system.
.PP
The Perl functions for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons.  First, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.
.PP
One of the major problems with ancient, antemillennial socket code in Perl
was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting \f(CW\*(C`$AF_INET = 2\*(C'\fR, you know you're in for big trouble.  
An immeasurably superior approach is to use the \f(CW\*(C`Socket\*(C'\fR module, which more
reliably grants access to the various constants and functions you'll need.
.PP
If you're not writing a server/client for an existing protocol like
\&\s-1NNTP\s0 or \s-1SMTP,\s0 you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a \*(L"\en\*(R" is received) or multi-line
messages and responses that end with a period on an empty line
(\*(L"\en.\en\*(R" terminates a message/response).
.SS "Internet Line Terminators"
.IX Subsection "Internet Line Terminators"
The Internet line terminator is \*(L"\e015\e012\*(R".  Under \s-1ASCII\s0 variants of
Unix, that could usually be written as \*(L"\er\en\*(R", but under other systems,
\&\*(L"\er\en\*(R" might at times be \*(L"\e015\e015\e012\*(R", \*(L"\e012\e012\e015\*(R", or something
completely different.  The standards specify writing \*(L"\e015\e012\*(R" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone \*(L"\e012\*(R" on input (be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll 
probably be ok.
.SS "Internet \s-1TCP\s0 Clients and Servers"
.IX Subsection "Internet TCP Clients and Servers"
Use Internet-domain sockets when you want to do client-server
communication that might extend to machines outside of your own system.
.PP
Here's a sample \s-1TCP\s0 client using Internet-domain sockets:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    my ($remote, $port, $iaddr, $paddr, $proto, $line);
\&
\&    $remote  = shift || "localhost";
\&    $port    = shift || 2345;  # random port
\&    if ($port =~ /\eD/) { $port = getservbyname($port, "tcp") }
\&    die "No port" unless $port;
\&    $iaddr   = inet_aton($remote)       || die "no host: $remote";
\&    $paddr   = sockaddr_in($port, $iaddr);
\&
\&    $proto   = getprotobyname("tcp");
\&    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
\&    connect(SOCK, $paddr)               || die "connect: $!";
\&    while ($line = <SOCK>) {
\&        print $line;
\&    }
\&
\&    close (SOCK)                        || die "close: $!";
\&    exit(0);
.Ve
.PP
And here's a corresponding server to go along with it.  We'll
leave the address as \f(CW\*(C`INADDR_ANY\*(C'\fR so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), fill this in with your real address instead.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $paddr;
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    for ( ; $paddr = accept(Client, Server); close Client) {
\&        my($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&                inet_ntoa($iaddr), "]
\&                at port $port";
\&
\&        print Client "Hello there, $name, it\*(Aqs now ",
\&                        scalar localtime(), $EOL;
\&    }
.Ve
.PP
And here's a multithreaded version.  It's multithreaded in that
like most typical servers, it spawns (\fIfork()\fRs) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $waitedpid = 0;
\&    my $paddr;
\&
\&    use POSIX ":sys_wait_h";
\&    use Errno;
\&
\&    sub REAPER {
\&        local $!;   # don\*(Aqt let waitpid() overwrite current error
\&        while ((my $pid = waitpid(\-1, WNOHANG)) > 0 && WIFEXITED($?)) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    while (1) {
\&        $paddr = accept(Client, Server) || do {
\&            # try again if accept() returned because got a signal
\&            next if $!{EINTR};
\&            die "accept: $!";
\&        };
\&        my ($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&               inet_ntoa($iaddr),
\&               "] at port $port";
\&
\&        spawn sub {
\&            $| = 1;
\&            print "Hello there, $name, it\*(Aqs now ", scalar localtime(), $EOL;
\&            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
\&                or confess "can\*(Aqt exec fortune: $!";
\&        };
\&        close Client;
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift;
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        }
\&        # else I\*(Aqm the child \-\- go spawn
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
This server takes the trouble to clone off a child version via \fIfork()\fR
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't \fIfork()\fR, the
\&\fIlisten()\fR will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called \*(L"zombies\*(R" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The \s-1REAPER\s0 subroutine is used here to
call \fIwaitpid()\fR for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.
.PP
Within the while loop we call \fIaccept()\fR and check to see if it returns
a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
\&\*(L"Deferred Signals (Safe Signals)\*(R" above) in Perl 5.8.0 means that
\&\fIaccept()\fR might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
notifies the parent process with a \s-1CHLD\s0 signal.
.PP
If \fIaccept()\fR is interrupted by a signal, $! will be set to \s-1EINTR.\s0
If this happens, we can safely continue to the next iteration of
the loop and another call to \fIaccept()\fR.  It is important that your
signal handling code not modify the value of $!, or else this test 
will likely fail.  In the \s-1REAPER\s0 subroutine we create a local version
of $! before calling \fIwaitpid()\fR.  When \fIwaitpid()\fR sets $! to \s-1ECHILD\s0 as
it inevitably does when it has no more children waiting, it 
updates the local copy and leaves the original unchanged.
.PP
You should use the \fB\-T\fR flag to enable taint checking (see perlsec)
even if we aren't running setuid or setgid.  This is always a good idea
for servers or any program run on behalf of someone else (like \s-1CGI\s0
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.
.PP
Let's look at another \s-1TCP\s0 client.  This one connects to the \s-1TCP \s0\*(L"time\*(R"
service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:
.PP
.Vb 3
\&    #!/usr/bin/perl  \-w
\&    use strict;
\&    use Socket;
\&
\&    my $SECS_OF_70_YEARS = 2208988800;
\&    sub ctime { scalar localtime(shift() || time()) }
\&
\&    my $iaddr = gethostbyname("localhost");
\&    my $proto = getprotobyname("tcp");
\&    my $port = getservbyname("time", "tcp");
\&    my $paddr = sockaddr_in(0, $iaddr);
\&    my($host);
\&
\&    $| = 1;
\&    printf "%\-24s %8s %s\en", "localhost", 0, ctime();
\&
\&    foreach $host (@ARGV) {
\&        printf "%\-24s ", $host;
\&        my $hisiaddr = inet_aton($host)     || die "unknown host";
\&        my $hispaddr = sockaddr_in($port, $hisiaddr);
\&        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
\&                                            || die "socket: $!";
\&        connect(SOCKET, $hispaddr)          || die "connect: $!";
\&        my $rtime = pack("C4", ());
\&        read(SOCKET, $rtime, 4);
\&        close(SOCKET);
\&        my $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%8d %s\en", $histime \- time(), ctime($histime);
\&    }
.Ve
.SS "Unix-Domain \s-1TCP\s0 Clients and Servers"
.IX Subsection "Unix-Domain TCP Clients and Servers"
That's fine for Internet-domain clients and servers, but what about local
communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an \fIls\fR\|(1) listing.
.PP
.Vb 2
\&    % ls \-l /dev/log
\&    srw\-rw\-rw\-  1 root            0 Oct 31 07:23 /dev/log
.Ve
.PP
You can test for these with Perl's \fB\-S\fR file test:
.PP
.Vb 3
\&    unless (\-S "/dev/log") {
\&        die "something\*(Aqs wicked with the log system";
\&    }
.Ve
.PP
Here's a sample Unix-domain client:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use Socket;
\&    use strict;
\&    my ($rendezvous, $line);
\&
\&    $rendezvous = shift || "catsock";
\&    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die "socket: $!";
\&    connect(SOCK, sockaddr_un($rendezvous))   || die "connect: $!";
\&    while (defined($line = <SOCK>)) {
\&        print $line;
\&    }
\&    exit(0);
.Ve
.PP
And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use Socket;
\&    use Carp;
\&
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $NAME = "catsock";
\&    my $uaddr = sockaddr_un($NAME);
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die "socket: $!";
\&    unlink($NAME);
\&    bind  (Server, $uaddr)                  || die "bind: $!";
\&    listen(Server, SOMAXCONN)               || die "listen: $!";
\&
\&    logmsg "server started on $NAME";
\&
\&    my $waitedpid;
\&
\&    use POSIX ":sys_wait_h";
\&    sub REAPER {
\&        my $child;
\&        while (($waitedpid = waitpid(\-1, WNOHANG)) > 0) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&
\&    for ( $waitedpid = 0;
\&          accept(Client, Server) || $waitedpid;
\&          $waitedpid = 0, close Client)
\&    {
\&        next if $waitedpid;
\&        logmsg "connection on $NAME";
\&        spawn sub {
\&            print "Hello there, it\*(Aqs now ", scalar localtime(), "\en";
\&            exec("/usr/games/fortune")  || die "can\*(Aqt exec fortune: $!";
\&        };
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift();
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        } 
\&        else {
\&            # I\*(Aqm the child \-\- go spawn
\&        }
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
As you see, it's remarkably similar to the Internet domain \s-1TCP\s0 server, so
much so, in fact, that we've omitted several duplicate functions\*(--\fIspawn()\fR,
\&\fIlogmsg()\fR, \fIctime()\fR, and \s-1\fIREAPER\s0()\fR\-\-which are the same as in the other server.
.PP
So why would you ever want to use a Unix domain socket instead of a
simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client; that's why \fIaccept()\fR takes two
arguments.
.PP
For example, let's say that you have a long-running database server daemon
that you want folks to be able to access from the Web, but only
if they go through a \s-1CGI\s0 interface.  You'd have a small, simple \s-1CGI\s0
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.
.SH "TCP Clients with IO::Socket"
.IX Header "TCP Clients with IO::Socket"
For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  If for some reason
you lack this module, you can just fetch IO::Socket from \s-1CPAN,\s0 where you'll also
find modules providing easy interfaces to the following systems: \s-1DNS, FTP,\s0
Ident (\s-1RFC 931\s0), \s-1NIS\s0 and NISPlus, \s-1NNTP,\s0 Ping, \s-1POP3, SMTP, SNMP,\s0 SSLeay,
Telnet, and Time\*(--to name just a few.
.SS "A Simple Client"
.IX Subsection "A Simple Client"
Here's a client that creates a \s-1TCP\s0 connection to the \*(L"daytime\*(R"
service at port 13 of the host name \*(L"localhost\*(R" and prints out everything
that the server there cares to provide.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    $remote = IO::Socket::INET\->new(
\&                        Proto    => "tcp",
\&                        PeerAddr => "localhost",
\&                        PeerPort => "daytime(13)",
\&                    )
\&                  || die "can\*(Aqt connect to daytime service on localhost";
\&    while (<$remote>) { print }
.Ve
.PP
When you run this program, you should get something back that
looks like this:
.PP
.Vb 1
\&    Wed May 14 08:40:46 MDT 1997
.Ve
.PP
Here are what those parameters to the \fInew()\fR constructor mean:
.ie n .IP """Proto""" 4
.el .IP "\f(CWProto\fR" 4
.IX Item "Proto"
This is which protocol to use.  In this case, the socket handle returned
will be connected to a \s-1TCP\s0 socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the \s-1UDP\s0 protocol
can be used to make a datagram socket, used for message-passing.
.ie n .IP """PeerAddr""" 4
.el .IP "\f(CWPeerAddr\fR" 4
.IX Item "PeerAddr"
This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like \f(CW"www.perl.com"\fR,
or an address like \f(CW"207.171.7.72"\fR.  For demonstration purposes, we've
used the special hostname \f(CW"localhost"\fR, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is \f(CW"127.0.0.1"\fR, if you'd rather use that.
.ie n .IP """PeerPort""" 4
.el .IP "\f(CWPeerPort\fR" 4
.IX Item "PeerPort"
This is the service name or port number we'd like to connect to.
We could have gotten away with using just \f(CW"daytime"\fR on systems with a
well-configured system services file,[\s-1FOOTNOTE:\s0 The system services file
is found in \fI/etc/services\fR under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.
.PP
Notice how the return value from the \f(CW\*(C`new\*(C'\fR constructor is used as
a filehandle in the \f(CW\*(C`while\*(C'\fR loop?  That's what's called an \fIindirect
filehandle\fR, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:
.PP
.Vb 1
\&    $line = <$handle>;
.Ve
.PP
all remaining lines from is this way:
.PP
.Vb 1
\&    @lines = <$handle>;
.Ve
.PP
and send a line of data to it this way:
.PP
.Vb 1
\&    print $handle "some data\en";
.Ve
.SS "A Webget Client"
.IX Subsection "A Webget Client"
Here's a simple client that takes a remote host to fetch a document
from, and then a list of files to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.
.PP
.Vb 10
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    unless (@ARGV > 1) { die "usage: $0 host url ..." }
\&    $host = shift(@ARGV);
\&    $EOL = "\e015\e012";
\&    $BLANK = $EOL x 2;
\&    for my $document (@ARGV) {
\&        $remote = IO::Socket::INET\->new( Proto     => "tcp",
\&                                         PeerAddr  => $host,
\&                                         PeerPort  => "http(80)",
\&                  )     || die "cannot connect to httpd on $host";
\&        $remote\->autoflush(1);
\&        print $remote "GET $document HTTP/1.0" . $BLANK;
\&        while ( <$remote> ) { print }
\&        close $remote;
\&    }
.Ve
.PP
The web server handling the \s-1HTTP\s0 service is assumed to be at
its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
as the named-parameter pair, \f(CW\*(C`PeerPort => 8080\*(C'\fR.  The \f(CW\*(C`autoflush\*(C'\fR
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every \f(CW"\en"\fR in your code that sends data over the network
to be a \f(CW"\e015\e012"\fR instead.)
.PP
Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with \*(L"\s-1GET\*(R"\s0 is in
\&\s-1HTTP\s0 syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak \s-1HTTP.\s0
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.
.PP
Here's an example of running that program, which we'll call \fIwebget\fR:
.PP
.Vb 6
\&    % webget www.perl.com /guanaco.html
\&    HTTP/1.1 404 File Not Found
\&    Date: Thu, 08 May 1997 18:02:32 GMT
\&    Server: Apache/1.2b6
\&    Connection: close
\&    Content\-type: text/html
\&
\&    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
\&    <BODY><H1>File Not Found</H1>
\&    The requested URL /guanaco.html was not found on this server.<P>
\&    </BODY>
.Ve
.PP
Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.
.PP
For a more featureful version of this program, you should look to
the \fIlwp-request\fR program included with the \s-1LWP\s0 modules from \s-1CPAN.\s0
.SS "Interactive Client with IO::Socket"
.IX Subsection "Interactive Client with IO::Socket"
Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way \fItelnet\fR works?  That way you can type a line, get the answer,
type a line, get the answer, etc.
.PP
This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful \f(CW\*(C`fork\*(C'\fR call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call \f(CW\*(C`fork\*(C'\fR to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be \fImuch\fR
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)
.PP
Here's the code:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use IO::Socket;
\&    my ($host, $port, $kidpid, $handle, $line);
\&
\&    unless (@ARGV == 2) { die "usage: $0 host port" }
\&    ($host, $port) = @ARGV;
\&
\&    # create a tcp connection to the specified host and port
\&    $handle = IO::Socket::INET\->new(Proto     => "tcp",
\&                                    PeerAddr  => $host,
\&                                    PeerPort  => $port)
\&               || die "can\*(Aqt connect to port $port on $host: $!";
\&
\&    $handle\->autoflush(1);       # so output gets there right away
\&    print STDERR "[Connected to $host:$port]\en";
\&
\&    # split the program into two processes, identical twins
\&    die "can\*(Aqt fork: $!" unless defined($kidpid = fork());
\&
\&    # the if{} block runs only in the parent process
\&    if ($kidpid) {
\&        # copy the socket to standard output
\&        while (defined ($line = <$handle>)) {
\&            print STDOUT $line;
\&        }
\&        kill("TERM", $kidpid);   # send SIGTERM to child
\&    }
\&    # the else{} block runs only in the child process
\&    else {
\&        # copy standard input to the socket
\&        while (defined ($line = <STDIN>)) {
\&            print $handle $line;
\&        }
\&        exit(0);                # just in case
\&    }
.Ve
.PP
The \f(CW\*(C`kill\*(C'\fR function in the parent's \f(CW\*(C`if\*(C'\fR block is there to send a
signal to our child process, currently running in the \f(CW\*(C`else\*(C'\fR block,
as soon as the remote server has closed its end of the connection.
.PP
If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the \f(CW\*(C`while\*(C'\fR loop in the parent with the
following:
.PP
.Vb 4
\&    my $byte;
\&    while (sysread($handle, $byte, 1) == 1) {
\&        print STDOUT $byte;
\&    }
.Ve
.PP
Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.
.SH "TCP Servers with IO::Socket"
.IX Header "TCP Servers with IO::Socket"
As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the \f(CW\*(C`IO::Socket::INET\->new()\*(C'\fR method with
slightly different arguments than the client did.
.IP "Proto" 4
.IX Item "Proto"
This is which protocol to use.  Like our clients, we'll
still specify \f(CW"tcp"\fR here.
.IP "LocalPort" 4
.IX Item "LocalPort"
We specify a local
port in the \f(CW\*(C`LocalPort\*(C'\fR argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an \*(L"Address already in use\*(R"
message.  Under Unix, the \f(CW\*(C`netstat \-a\*(C'\fR command will show
which services current have servers.
.IP "Listen" 4
.IX Item "Listen"
The \f(CW\*(C`Listen\*(C'\fR parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is \s-1SOMAXCONN.\s0
.IP "Reuse" 4
.IX Item "Reuse"
The \f(CW\*(C`Reuse\*(C'\fR parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.
.PP
Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the \f(CW\*(C`accept\*(C'\fR method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)
.PP
To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the \f(CW\*(C`sysread\*(C'\fR variant of the interactive client above.
.PP
This server accepts one of five different commands, sending output back to
the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multithreaded servers are covered in 
Chapter 16 of the Camel.
.PP
Here's the code.  We'll
.PP
.Vb 3
\& #!/usr/bin/perl \-w
\& use IO::Socket;
\& use Net::hostent;      # for OOish version of gethostbyaddr
\&
\& $PORT = 9000;          # pick something not in use
\&
\& $server = IO::Socket::INET\->new( Proto     => "tcp",
\&                                  LocalPort => $PORT,
\&                                  Listen    => SOMAXCONN,
\&                                  Reuse     => 1);
\&
\& die "can\*(Aqt setup server" unless $server;
\& print "[Server $0 accepting clients]\en";
\&
\& while ($client = $server\->accept()) {
\&   $client\->autoflush(1);
\&   print $client "Welcome to $0; type help for command list.\en";
\&   $hostinfo = gethostbyaddr($client\->peeraddr);
\&   printf "[Connect from %s]\en", $hostinfo ? $hostinfo\->name : $client\->peerhost;
\&   print $client "Command? ";
\&   while ( <$client>) {
\&     next unless /\eS/;       # blank line
\&     if    (/quit|exit/i)    { last                                      }
\&     elsif (/date|time/i)    { printf $client "%s\en", scalar localtime() }
\&     elsif (/who/i )         { print  $client \`who 2>&1\`                 }
\&     elsif (/cookie/i )      { print  $client \`/usr/games/fortune 2>&1\`  }
\&     elsif (/motd/i )        { print  $client \`cat /etc/motd 2>&1\`       }
\&     else {
\&       print $client "Commands: quit date who cookie motd\en";
\&     }
\&   } continue {
\&      print $client "Command? ";
\&   }
\&   close $client;
\& }
.Ve
.SH "UDP: Message Passing"
.IX Header "UDP: Message Passing"
Another kind of client-server setup is one that uses not connections, but
messages.  \s-1UDP\s0 communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, \s-1UDP\s0 offers some advantages
over \s-1TCP,\s0 including being able to \*(L"broadcast\*(R" or \*(L"multicast\*(R" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just \s-1TCP\s0 to start
with.
.PP
\&\s-1UDP\s0 datagrams are \fInot\fR a bytestream and should not be treated as such.
This makes using I/O mechanisms with internal buffering like stdio (i.e.
\&\fIprint()\fR and friends) especially cumbersome. Use \fIsyswrite()\fR, or better
\&\fIsend()\fR, like in the example below.
.PP
Here's a \s-1UDP\s0 program similar to the sample Internet \s-1TCP\s0 client given
earlier.  However, instead of checking one host at a time, the \s-1UDP\s0 version
will check many of them asynchronously by simulating a multicast and then
using \fIselect()\fR to do a timed-out wait for I/O.  To do something similar
with \s-1TCP,\s0 you'd have to use a different socket handle for each host.
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    use Sys::Hostname;
\&
\&    my ( $count, $hisiaddr, $hispaddr, $histime,
\&         $host, $iaddr, $paddr, $port, $proto,
\&         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
\&
\&    $SECS_OF_70_YEARS = 2_208_988_800;
\&
\&    $iaddr = gethostbyname(hostname());
\&    $proto = getprotobyname("udp");
\&    $port = getservbyname("time", "udp");
\&    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
\&
\&    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
\&    bind(SOCKET, $paddr)                          || die "bind: $!";
\&
\&    $| = 1;
\&    printf "%\-12s %8s %s\en",  "localhost", 0, scalar localtime();
\&    $count = 0;
\&    for $host (@ARGV) {
\&        $count++;
\&        $hisiaddr = inet_aton($host)              || die "unknown host";
\&        $hispaddr = sockaddr_in($port, $hisiaddr);
\&        defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
\&    }
\&
\&    $rin = "";
\&    vec($rin, fileno(SOCKET), 1) = 1;
\&
\&    # timeout after 10.0 seconds
\&    while ($count && select($rout = $rin, undef, undef, 10.0)) {
\&        $rtime = "";
\&        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
\&        ($port, $hisiaddr) = sockaddr_in($hispaddr);
\&        $host = gethostbyaddr($hisiaddr, AF_INET);
\&        $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%\-12s ", $host;
\&        printf "%8d %s\en", $histime \- time(), scalar localtime($histime);
\&        $count\-\-;
\&    }
.Ve
.PP
This example does not include any retries and may consequently fail to
contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.
.SH "SysV IPC"
.IX Header "SysV IPC"
While System V \s-1IPC\s0 isn't so widely used as sockets, it still has some
interesting uses.  However, you cannot use SysV \s-1IPC\s0 or Berkeley \fImmap()\fR to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the \f(CW\*(C`IPC::Shareable\*(C'\fR or \f(CW\*(C`threads::shared\*(C'\fR modules for that.
.PP
Here's a small example showing shared memory usage.
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
\&
\&    $size = 2000;
\&    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
\&    defined($id)                    || die "shmget: $!";
\&    print "shm key $id\en";
\&
\&    $message = "Message #1";
\&    shmwrite($id, $message, 0, 60)  || die "shmwrite: $!";
\&    print "wrote: \*(Aq$message\*(Aq\en";
\&    shmread($id, $buff, 0, 60)      || die "shmread: $!";
\&    print "read : \*(Aq$buff\*(Aq\en";
\&
\&    # the buffer of shmread is zero\-character end\-padded.
\&    substr($buff, index($buff, "\e0")) = "";
\&    print "un" unless $buff eq $message;
\&    print "swell\en";
\&
\&    print "deleting shm $id\en";
\&    shmctl($id, IPC_RMID, 0)        || die "shmctl: $!";
.Ve
.PP
Here's an example of a semaphore:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_CREAT);
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
\&    defined($id)                    || die "semget: $!";
\&    print "sem id $id\en";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call the file \fItake\fR:
.PP
.Vb 1
\&    # create a semaphore
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    defined($id)                    || die "semget: $!";
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # "take" semaphore
\&    # wait for semaphore to be zero
\&    $semop = 0;
\&    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    # Increment the semaphore count
\&    $semop = 1;
\&    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
\&    $opstring  = $opstring1 . $opstring2;
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call this file \fIgive\fR:
.PP
.Vb 3
\&    # "give" the semaphore
\&    # run this in the original process and you will see
\&    # that the second process continues
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    die unless defined($id);
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # Decrement the semaphore count
\&    $semop = \-1;
\&    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
The SysV \s-1IPC\s0 code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module.
.PP
A small example demonstrating SysV message queues:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
\&
\&    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
\&    defined($id)                || die "msgget failed: $!";
\&
\&    my $sent      = "message";
\&    my $type_sent = 1234;
\&
\&    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
\&                                || die "msgsnd failed: $!";
\&
\&    msgrcv($id, my $rcvd_buf, 60, 0, 0)
\&                                || die "msgrcv failed: $!";
\&
\&    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);
\&
\&    if ($rcvd eq $sent) {
\&        print "okay\en";
\&    } else {
\&        print "not okay\en";
\&    }
\&
\&    msgctl($id, IPC_RMID, 0)    || die "msgctl failed: $!\en";
.Ve
.SH "NOTES"
.IX Header "NOTES"
Most of these routines quietly but politely return \f(CW\*(C`undef\*(C'\fR when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new \fISocket\fR conversion
functions do \fIcroak()\fR on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add the \fB\-T\fR
taint-checking flag to the \f(CW\*(C`#!\*(C'\fR line for servers:
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use sigtrap;
\&    use Socket;
.Ve
.SH "BUGS"
.IX Header "BUGS"
These routines all create system-specific portability problems.  As noted
elsewhere, Perl is at the mercy of your C libraries for much of its system
behavior.  It's probably safest to assume broken SysV semantics for
signals and to stick with simple \s-1TCP\s0 and \s-1UDP\s0 socket operations; e.g., don't
try to pass open file descriptors over a local \s-1UDP\s0 datagram socket if you
want your code to stand a chance of being portable.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There's a lot more to networking than this, but this should get you
started.
.PP
For intrepid programmers, the indispensable textbook is \fIUnix Network
Programming, 2nd Edition, Volume 1\fR by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.
.PP
The \fIIO::Socket\fR\|(3) manpage describes the object library, and the \fISocket\fR\|(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in perlfunc, you should also check out the \fImodules\fR file at
your nearest \s-1CPAN\s0 site, especially
<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
See perlmodlib or best yet, the \fIPerl \s-1FAQ\s0\fR for a description
of what \s-1CPAN\s0 is and where to get it if the previous link doesn't work 
for you.
.PP
Section 5 of \s-1CPAN\s0's \fImodules\fR file is devoted to \*(L"Networking, Device
Control (modems), and Interprocess Communication\*(R", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
\&\s-1CGI\s0 programming, \s-1DCE, FTP, IPC, NNTP,\s0 Proxy, Ptty, \s-1RPC, SNMP, SMTP,\s0 Telnet,
Threads, and ToolTalk\*(--to name just a few.
                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlipc5.16.1                                0100644 0001750 0001750 00000242647 12566207421 022724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIPC 1"
.TH PERLIPC 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlipc \- Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The basic \s-1IPC\s0 facilities of Perl are built out of the good old Unix
signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
\&\s-1IPC\s0 calls.  Each is used in slightly different situations.
.SH "Signals"
.IX Header "Signals"
Perl uses a simple signal handling model: the \f(CW%SIG\fR hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.
.PP
For example, to trap an interrupt signal, set up a handler like this:
.PP
.Vb 1
\&    our $shucks;
\&
\&    sub catch_zap {
\&        my $signame = shift;
\&        $shucks++;
\&        die "Somebody sent me a SIG$signame";
\&    }
\&    $SIG{INT} = _\|_PACKAGE_\|_ . "::catch_zap";  
\&    $SIG{INT} = \e&catch_zap;  # best strategy
.Ve
.PP
Prior to Perl 5.7.3 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly \fIanything\fR in your
handler could in theory trigger a memory fault and subsequent core
dump \- see \*(L"Deferred Signals (Safe Signals)\*(R" below.
.PP
The names of the signals are the ones listed out by \f(CW\*(C`kill \-l\*(C'\fR on your
system, or you can retrieve them using the \s-1CPAN\s0 module IPC::Signal.
.PP
You may also choose to assign the strings \f(CW"IGNORE"\fR or \f(CW"DEFAULT"\fR as
the handler, in which case Perl will try to discard the signal or do the
default thing.
.PP
On most Unix platforms, the \f(CW\*(C`CHLD\*(C'\fR (sometimes also known as \f(CW\*(C`CLD\*(C'\fR) signal
has special behavior with respect to a value of \f(CW"IGNORE"\fR.
Setting \f(CW$SIG{CHLD}\fR to \f(CW"IGNORE"\fR on such a platform has the effect of
not creating zombie processes when the parent process fails to \f(CW\*(C`wait()\*(C'\fR
on its child processes (i.e., child processes are automatically reaped).
Calling \f(CW\*(C`wait()\*(C'\fR with \f(CW$SIG{CHLD}\fR set to \f(CW"IGNORE"\fR usually returns
\&\f(CW\*(C`\-1\*(C'\fR on such platforms.
.PP
Some signals can be neither trapped nor ignored, such as the \s-1KILL\s0 and \s-1STOP\s0
(but not the \s-1TSTP\s0) signals. Note that ignoring signals makes them disappear.
If you only want them blocked temporarily without them getting lost you'll
have to use \s-1POSIX\s0' sigprocmask.
.PP
Sending a signal to a negative process \s-1ID\s0 means that you send the signal
to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets \f(CW$SIG\fR{\s-1HUP\s0} to \f(CW"IGNORE"\fR 
so it doesn't kill itself:
.PP
.Vb 6
\&    # block scope for local
\&    {
\&        local $SIG{HUP} = "IGNORE";
\&        kill HUP => \-$$;
\&        # snazzy writing of: kill("HUP", \-$$)
\&    }
.Ve
.PP
Another interesting signal to send is signal number zero.  This doesn't
actually affect a child process, but instead checks whether it's alive
or has changed its UIDs.
.PP
.Vb 3
\&    unless (kill 0 => $kid_pid) {
\&        warn "something wicked happened to $kid_pid";
\&    }
.Ve
.PP
Signal number zero may fail because you lack permission to send the
signal when directed at a process whose real or saved \s-1UID\s0 is not
identical to the real or effective \s-1UID\s0 of the sending process, even
though the process is alive.  You may be able to determine the cause of
failure using \f(CW$!\fR or \f(CW\*(C`%!\*(C'\fR.
.PP
.Vb 3
\&    unless (kill(0 => $pid) || $!{EPERM}) {
\&        warn "$pid looks dead";
\&    }
.Ve
.PP
You might also want to employ anonymous functions for simple signal
handlers:
.PP
.Vb 1
\&    $SIG{INT} = sub { die "\enOutta here!\en" };
.Ve
.PP
\&\s-1SIGCHLD\s0 handlers require some special care.  If a second child dies
while in the signal handler caused by the first death, we won't get
another signal. So must loop here else we will leave the unreaped child
as a zombie. And the next time two children die we get another zombie.
And so on.
.PP
.Vb 7
\&    use POSIX ":sys_wait_h";
\&    $SIG{CHLD} = sub {
\&        while ((my $child = waitpid(\-1, WNOHANG)) > 0) {
\&            $Kid_Status{$child} = $?;
\&        }
\&    };
\&    # do something that forks...
.Ve
.PP
Be careful: \fIqx()\fR, \fIsystem()\fR, and some modules for calling external commands
do a \fIfork()\fR, then \fIwait()\fR for the result. Thus, your signal handler
will be called. Because \fIwait()\fR was already called by \fIsystem()\fR or \fIqx()\fR,
the \fIwait()\fR in the signal handler will see no more zombies and will
therefore block.
.PP
The best way to prevent this issue is to use \fIwaitpid()\fR, as in the following
example:
.PP
.Vb 1
\&    use POSIX ":sys_wait_h"; # for nonblocking read
\&
\&    my %children;
\&
\&    $SIG{CHLD} = sub {
\&        # don\*(Aqt change $! and $? outside handler
\&        local ($!, $?);
\&        my $pid = waitpid(\-1, WNOHANG);
\&        return if $pid == \-1;
\&        return unless defined $children{$pid};
\&        delete $children{$pid};
\&        cleanup_child($pid, $?);
\&    };
\&
\&    while (1) {
\&        my $pid = fork();
\&        die "cannot fork" unless defined $pid;
\&        if ($pid == 0) {
\&            # ...
\&            exit 0;
\&        } else {
\&            $children{$pid}=1;
\&            # ...
\&            system($command);
\&            # ...
\&       }
\&    }
.Ve
.PP
Signal handling is also used for timeouts in Unix.  While safely
protected within an \f(CW\*(C`eval{}\*(C'\fR block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your \f(CW\*(C`eval{}\*(C'\fR block.  If it
goes off, you'll use \fIdie()\fR to jump out of the block.
.PP
Here's an example:
.PP
.Vb 9
\&    my $ALARM_EXCEPTION = "alarm clock restart";
\&    eval {
\&        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
\&        alarm 10;
\&        flock(FH, 2)    # blocking write lock
\&                        || die "cannot flock: $!";
\&        alarm 0;
\&    };
\&    if ($@ && $@ !~ quotemeta($ALARM_EXCEPTION)) { die }
.Ve
.PP
If the operation being timed out is \fIsystem()\fR or \fIqx()\fR, this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own \fIfork()\fR and \fIexec()\fR, and kill the errant child process.
.PP
For more complex signal handling, you might see the standard \s-1POSIX\s0
module.  Lamentably, this is almost entirely undocumented, but
the \fIt/lib/posix.t\fR file from the Perl source distribution has some
examples in it.
.SS "Handling the \s-1SIGHUP\s0 Signal in Daemons"
.IX Subsection "Handling the SIGHUP Signal in Daemons"
A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a \f(CW\*(C`SIGHUP\*(C'\fR
signal handler. When you want to tell the daemon to reread the file,
simply send it the \f(CW\*(C`SIGHUP\*(C'\fR signal.
.PP
The following example implements a simple daemon, which restarts
itself every time the \f(CW\*(C`SIGHUP\*(C'\fR signal is received. The actual code is
located in the subroutine \f(CW\*(C`code()\*(C'\fR, which just prints some debugging
info to show that it works; it should be replaced with the real code.
.PP
.Vb 1
\&  #!/usr/bin/perl \-w
\&
\&  use POSIX ();
\&  use FindBin ();
\&  use File::Basename ();
\&  use File::Spec::Functions;
\&
\&  $| = 1;
\&
\&  # make the daemon cross\-platform, so exec always calls the script
\&  # itself with the right path, no matter how the script was invoked.
\&  my $script = File::Basename::basename($0);
\&  my $SELF  = catfile($FindBin::Bin, $script);
\&
\&  # POSIX unmasks the sigprocmask properly
\&  $SIG{HUP} = sub {
\&      print "got SIGHUP\en";
\&      exec($SELF, @ARGV)        || die "$0: couldn\*(Aqt restart: $!";
\&  };
\&
\&  code();
\&
\&  sub code {
\&      print "PID: $$\en";
\&      print "ARGV: @ARGV\en";
\&      my $count = 0;
\&      while (++$count) {
\&          sleep 2;
\&          print "$count\en";
\&      }
\&  }
.Ve
.SS "Deferred Signals (Safe Signals)"
.IX Subsection "Deferred Signals (Safe Signals)"
Before Perl 5.7.3, installing Perl code to deal with signals exposed you to
danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like \fImalloc\fR\|(3) or \fIprintf\fR\|(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior\*(--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.
.PP
There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to \f(CW\*(C`die\*(C'\fR to \fIlongjmp\fR\|(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids \f(CW\*(C`die\*(C'\fR in a handler because the system \fIis\fR out to get you.
The pragmatic approach was to say \*(L"I know the risks, but prefer the
convenience\*(R", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.
.PP
Perl 5.7.3 and later avoid these problems by \*(L"deferring\*(R" signals.  That is,
when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic \*(L"safe\*(R" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from \f(CW%SIG\fR is executed. The \*(L"deferred\*(R" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library
function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:
.IP "Long-running opcodes" 4
.IX Item "Long-running opcodes"
As the Perl interpreter looks at signal flags only when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.
.Sp
If a signal of any given type fires multiple times during an opcode 
(such as from a fine-grained timer), the handler for that signal will
be called only once, after the opcode completes; all other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling \f(CWalarm(0)\fR as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.
.IP "Interrupting \s-1IO\s0" 4
.IX Item "Interrupting IO"
When a signal is delivered (e.g., \s-1SIGINT\s0 from a control-C) the operating
system breaks into \s-1IO\s0 operations like \fIread\fR(2), which is used to
implement Perl's \fIreadline()\fR function, the \f(CW\*(C`<>\*(C'\fR operator. On older
Perls the handler was called immediately (and as \f(CW\*(C`read\*(C'\fR is not \*(L"unsafe\*(R",
this worked well). With the \*(L"deferred\*(R" scheme the handler is \fInot\fR called
immediately, and if Perl is using the system's \f(CW\*(C`stdio\*(C'\fR library that
library may restart the \f(CW\*(C`read\*(C'\fR without returning to Perl to give it a
chance to call the \f(CW%SIG\fR handler. If this happens on your system the
solution is to use the \f(CW\*(C`:perlio\*(C'\fR layer to do IO\*(--at least on those handles
that you want to be able to break into with signals. (The \f(CW\*(C`:perlio\*(C'\fR layer
checks the signal flags and calls \f(CW%SIG\fR handlers before resuming \s-1IO\s0
operation.)
.Sp
The default in Perl 5.7.3 and later is to automatically use
the \f(CW\*(C`:perlio\*(C'\fR layer.
.Sp
Note that it is not advisable to access a file handle within a signal
handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.
.Sp
Some networking library functions like \fIgethostbyname()\fR are known to have
their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the \s-1POSIX\s0
\&\fIsigaction()\fR function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.
.Sp
Instead of setting \f(CW$SIG{ALRM}\fR:
.Sp
.Vb 1
\&   local $SIG{ALRM} = sub { die "alarm" };
.Ve
.Sp
try something like the following:
.Sp
.Vb 3
\&  use POSIX qw(SIGALRM);
\&  POSIX::sigaction(SIGALRM, POSIX::SigAction\->new(sub { die "alarm" }))
\&          || die "Error setting SIGALRM handler: $!\en";
.Ve
.Sp
Another way to disable the safe signal behavior locally is to use
the \f(CW\*(C`Perl::Unsafe::Signals\*(C'\fR module from \s-1CPAN\s0, which affects
all signals.
.IP "Restartable system calls" 4
.IX Item "Restartable system calls"
On systems that supported it, older versions of Perl used the
\&\s-1SA_RESTART\s0 flag when installing \f(CW%SIG\fR handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.7.3 and later do \fInot\fR use \s-1SA_RESTART\s0.  Consequently, 
restartable system calls can fail (with $! set to \f(CW\*(C`EINTR\*(C'\fR) in places
where they previously would have succeeded.
.Sp
The default \f(CW\*(C`:perlio\*(C'\fR layer retries \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`write\*(C'\fR
and \f(CW\*(C`close\*(C'\fR as described above; interrupted \f(CW\*(C`wait\*(C'\fR and 
\&\f(CW\*(C`waitpid\*(C'\fR calls will always be retried.
.ie n .IP "Signals as ""faults""" 4
.el .IP "Signals as ``faults''" 4
.IX Item "Signals as faults"
Certain signals like \s-1SEGV\s0, \s-1ILL\s0, and \s-1BUS\s0 are generated by virtual memory
addressing errors and similar \*(L"faults\*(R". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl delivers them
immediately rather than attempting to defer them.
.IP "Signals triggered by operating system state" 4
.IX Item "Signals triggered by operating system state"
On some operating systems certain signal handlers are supposed to \*(L"do
something\*(R" before returning. One example can be \s-1CHLD\s0 or \s-1CLD\s0, which
indicates a child process has completed. On some operating systems the
signal handler is expected to \f(CW\*(C`wait\*(C'\fR for the completed child
process. On such systems the deferred signal scheme will not work for
those signals: it does not do the \f(CW\*(C`wait\*(C'\fR. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been \f(CW\*(C`wait\*(C'\fRed for.
.PP
If you want the old signal behavior back despite possible
memory corruption, set the environment variable \f(CW\*(C`PERL_SIGNALS\*(C'\fR to
\&\f(CW"unsafe"\fR.  This feature first appeared in Perl 5.8.1.
.SH "Named Pipes"
.IX Header "Named Pipes"
A named pipe (often referred to as a \s-1FIFO\s0) is an old Unix \s-1IPC\s0
mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.
.PP
To create a named pipe, use the \f(CW\*(C`POSIX::mkfifo()\*(C'\fR function.
.PP
.Vb 2
\&    use POSIX qw(mkfifo);
\&    mkfifo($path, 0700)     ||  die "mkfifo $path failed: $!";
.Ve
.PP
You can also use the Unix command \fImknod\fR\|(1), or on some
systems, \fImkfifo\fR\|(1).  These may not be in your normal path, though.
.PP
.Vb 8
\&    # system return val is backwards, so && not ||
\&    #
\&    $ENV{PATH} .= ":/etc:/usr/etc";
\&    if  (      system("mknod",  $path, "p")
\&            && system("mkfifo", $path) )
\&    {
\&        die "mk{nod,fifo} $path failed";
\&    }
.Ve
.PP
A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.
.PP
For example, let's say you'd like to have your \fI.signature\fR file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, \fB\-p\fR, to find
out whether anyone (or anything) has accidentally removed our fifo.
.PP
.Vb 2
\&    chdir();    # go home
\&    my $FIFO = ".signature";
\&
\&    while (1) {
\&        unless (\-p $FIFO) {
\&            unlink $FIFO;   # discard any failure, will catch later
\&            require POSIX;  # delayed loading of heavy module
\&            POSIX::mkfifo($FIFO, 0700)
\&                                || die "can\*(Aqt mkfifo $FIFO: $!";
\&        }
\&
\&        # next line blocks till there\*(Aqs a reader
\&        open (FIFO, "> $FIFO")  || die "can\*(Aqt open $FIFO: $!";
\&        print FIFO "John Smith (smith\e@host.org)\en", \`fortune \-s\`;
\&        close(FIFO)             || die "can\*(Aqt close $FIFO: $!";
\&        sleep 2;                # to avoid dup signals
\&    }
.Ve
.SH "Using \fIopen()\fP for IPC"
.IX Header "Using open() for IPC"
Perl's basic \fIopen()\fR statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to \fIopen()\fR.  Here's how to start
something up in a child process you intend to write to:
.PP
.Vb 5
\&    open(SPOOLER, "| cat \-v | lpr \-h 2>/dev/null")
\&                        || die "can\*(Aqt fork: $!";
\&    local $SIG{PIPE} = sub { die "spooler pipe broke" };
\&    print SPOOLER "stuff\en";
\&    close SPOOLER       || die "bad spool: $! $?";
.Ve
.PP
And here's how to start up a child process you intend to read from:
.PP
.Vb 7
\&    open(STATUS, "netstat \-an 2>&1 |")
\&                        || die "can\*(Aqt fork: $!";
\&    while (<STATUS>) {
\&        next if /^(tcp|udp)/;
\&        print;
\&    }
\&    close STATUS        || die "bad netstat: $! $?";
.Ve
.PP
If one can be sure that a particular program is a Perl script expecting
filenames in \f(CW@ARGV\fR, the clever programmer can write something like this:
.PP
.Vb 1
\&    % program f1 "cmd1|" \- f2 "cmd2|" f3 < tmpfile
.Ve
.PP
and no matter which sort of shell it's called from, the Perl program will
read from the file \fIf1\fR, the process \fIcmd1\fR, standard input (\fItmpfile\fR
in this case), the \fIf2\fR file, the \fIcmd2\fR command, and finally the \fIf3\fR
file.  Pretty nifty, eh?
.PP
You might notice that you could use backticks for much the
same effect as opening a pipe for reading:
.PP
.Vb 2
\&    print grep { !/^(tcp|udp)/ } \`netstat \-an 2>&1\`;
\&    die "bad netstatus ($?)" if $?;
.Ve
.PP
While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you kill off the child process early if you'd like.
.PP
Be careful to check the return values from both \fIopen()\fR and \fIclose()\fR.  If
you're \fIwriting\fR to a pipe, you should also trap \s-1SIGPIPE\s0.  Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the \fIopen()\fR will in all likelihood succeed (it only reflects the
\&\fIfork()\fR's success), but then your output will fail\*(--spectacularly.  Perl
can't know whether the command worked, because your command is actually
running in a separate process whose \fIexec()\fR might have failed.  Therefore,
while readers of bogus commands return just a quick \s-1EOF\s0, writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:
.PP
.Vb 4
\&    open(FH, "|bogus")      || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";      #  neither necessary nor sufficient 
\&                            #  to check print retval!
\&    close(FH)               || die "can\*(Aqt close: $!";
.Ve
.PP
The reason for not checking the return value from \fIprint()\fR is because of
pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a \s-1SIGPIPE\s0.  To catch it, you could use
this:
.PP
.Vb 4
\&    $SIG{PIPE} = "IGNORE";
\&    open(FH, "|bogus")  || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";
\&    close(FH)           || die "can\*(Aqt close: status=$?";
.Ve
.SS "Filehandles"
.IX Subsection "Filehandles"
Both the main process and any child processes it forks share the same
\&\s-1STDIN\s0, \s-1STDOUT\s0, and \s-1STDERR\s0 filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with \fIopen()\fR, but on some systems this means that the
child process cannot outlive the parent.
.SS "Background Processes"
.IX Subsection "Background Processes"
You can run a command in the background with:
.PP
.Vb 1
\&    system("cmd &");
.Ve
.PP
The command's \s-1STDOUT\s0 and \s-1STDERR\s0 (and possibly \s-1STDIN\s0, depending on your
shell) will be the same as the parent's.  You won't need to catch
\&\s-1SIGCHLD\s0 because of the double-fork taking place; see below for details.
.SS "Complete Dissociation of Child from Parent"
.IX Subsection "Complete Dissociation of Child from Parent"
In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well-behaved daemon will also \fIchdir()\fR
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to \fI/dev/null\fR so that random
output doesn't wind up on the user's terminal.
.PP
.Vb 1
\&    use POSIX "setsid";
\&
\&    sub daemonize {
\&        chdir("/")                      || die "can\*(Aqt chdir to /: $!";
\&        open(STDIN,  "< /dev/null")     || die "can\*(Aqt read /dev/null: $!";
\&        open(STDOUT, "> /dev/null")     || die "can\*(Aqt write to /dev/null: $!";
\&        defined(my $pid = fork())       || die "can\*(Aqt fork: $!";
\&        exit if $pid;                   # non\-zero now means I am the parent
\&        (setsid() != \-1)                || die "Can\*(Aqt start a new session: $!" 
\&        open(STDERR, ">&STDOUT")        || die "can\*(Aqt dup stdout: $!";
\&    }
.Ve
.PP
The \fIfork()\fR has to come before the \fIsetsid()\fR to ensure you aren't a
process group leader; the \fIsetsid()\fR will fail if you are.  If your
system doesn't have the \fIsetsid()\fR function, open \fI/dev/tty\fR and use the
\&\f(CW\*(C`TIOCNOTTY\*(C'\fR \fIioctl()\fR on it instead.  See \fItty\fR\|(4) for details.
.PP
Non-Unix users should check their \f(CW\*(C`\f(CIYour_OS\f(CW::Process\*(C'\fR module for 
other possible solutions.
.SS "Safe Pipe Opens"
.IX Subsection "Safe Pipe Opens"
Another interesting approach to \s-1IPC\s0 is making your single program go
multiprocess and communicate between\*(--or even amongst\*(--yourselves.  The
\&\fIopen()\fR function will accept a file argument of either \f(CW"\-|"\fR or \f(CW"|\-"\fR
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed \s-1UID\s0 or \s-1GID\s0, for example.  If you open a pipe \fIto\fR minus, you can
write to the filehandle you opened and your kid will find it in \fIhis\fR
\&\s-1STDIN\s0.  If you open a pipe \fIfrom\fR minus, you can read from the filehandle
you opened whatever your kid writes to \fIhis\fR \s-1STDOUT\s0.
.PP
.Vb 4
\&    use English qw[ \-no_match_vars ];
\&    my $PRECIOUS = "/path/to/some/safe/file";
\&    my $sleep_count;
\&    my $pid;
\&
\&    do {
\&        $pid = open(KID_TO_WRITE, "|\-");
\&        unless (defined $pid) {
\&            warn "cannot fork: $!";
\&            die "bailing out" if $sleep_count++ > 6;
\&            sleep 10;
\&        }
\&    } until defined $pid;
\&
\&    if ($pid) {                 # I am the parent 
\&        print KID_TO_WRITE @some_data;
\&        close(KID_TO_WRITE)     || warn "kid exited $?";
\&    } else {                    # I am the child
\&        # drop permissions in setuid and/or setgid programs:
\&        ($EUID, $EGID) = ($UID, $GID);  
\&        open (OUTFILE, "> $PRECIOUS") 
\&                                || die "can\*(Aqt open $PRECIOUS: $!";
\&        while (<STDIN>) {
\&            print OUTFILE;      # child\*(Aqs STDIN is parent\*(Aqs KID_TO_WRITE
\&        }
\&        close(OUTFILE)          || die "can\*(Aqt close $PRECIOUS: $!";
\&        exit(0);                # don\*(Aqt forget this!!
\&    }
.Ve
.PP
Another common use for this construct is when you need to execute
something without the shell's interference.  With \fIsystem()\fR, it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call \fIexec()\fR directly.
.PP
Here's a safe backtick or pipe open for read:
.PP
.Vb 2
\&    my $pid = open(KID_TO_READ, "\-|");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    if ($pid) {             # parent
\&        while (<KID_TO_READ>) {
\&                            # do something interesting
\&        }
\&        close(KID_TO_READ)  || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID); # suid only
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
And here's a safe pipe open for writing:
.PP
.Vb 2
\&    my $pid = open(KID_TO_WRITE, "|\-");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };
\&
\&    if ($pid) {             # parent
\&        print KID_TO_WRITE @data;
\&        close(KID_TO_WRITE) || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID);
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
It is very easy to dead-lock a process using this form of \fIopen()\fR, or
indeed with any use of \fIpipe()\fR with multiple subprocesses.  The 
example above is \*(L"safe\*(R" because it is simple and calls \fIexec()\fR.  See
\&\*(L"Avoiding Pipe Deadlocks\*(R" for general safety principles, but there
are extra gotchas with Safe Pipe Opens.
.PP
In particular, if you opened the pipe using \f(CW\*(C`open FH, "|\-"\*(C'\fR, then you
cannot simply use \fIclose()\fR in the parent process to close an unwanted
writer.  Consider this code:
.PP
.Vb 10
\&    my $pid = open(WRITER, "|\-");        # fork open a kid
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "second fork failed: $!";
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            # now do something else...
\&        }
\&        else {
\&            # first write to WRITER
\&            # ...
\&            # then when finished
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&    }
\&    else {
\&        # first do something with STDIN, then
\&        exit(0);
\&    }
.Ve
.PP
In the example above, the true parent does not want to write to the \s-1WRITER\s0
filehandle, so it closes it.  However, because \s-1WRITER\s0 was opened using
\&\f(CW\*(C`open FH, "|\-"\*(C'\fR, it has a special behavior: closing it calls
\&\fIwaitpid()\fR (see \*(L"waitpid\*(R" in perlfunc), which waits for the subprocess
to exit.  If the child process ends up waiting for something happening
in the section marked \*(L"do something else\*(R", you have deadlock.
.PP
This can also be a problem with intermediate subprocesses in more
complicated code, which will call \fIwaitpid()\fR on all open filehandles
during global destruction\*(--in no predictable order.
.PP
To solve this, you must manually use \fIpipe()\fR, \fIfork()\fR, and the form of
\&\fIopen()\fR which sets one file descriptor to another, as shown below:
.PP
.Vb 10
\&    pipe(READER, WRITER)        || die "pipe failed: $!";
\&    $pid = fork();
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        close READER;
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "first fork failed: $!";
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&        }
\&        else {
\&            # write to WRITER...
\&            # ...
\&            # then  when finished
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&        # write to WRITER...
\&    }
\&    else {
\&        open(STDIN, "<&READER") || die "can\*(Aqt reopen STDIN: $!";
\&        close(WRITER)           || die "can\*(Aqt close WRITER: $!";
\&        # do something...
\&        exit(0);
\&    }
.Ve
.PP
Since Perl 5.8.0, you can also use the list form of \f(CW\*(C`open\*(C'\fR for pipes.
This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.
.PP
So for example, instead of using:
.PP
.Vb 1
\&    open(PS_PIPE, "ps aux|")    || die "can\*(Aqt open ps pipe: $!";
.Ve
.PP
One would use either of these:
.PP
.Vb 2
\&    open(PS_PIPE, "\-|", "ps", "aux") 
\&                                || die "can\*(Aqt open ps pipe: $!";
\&
\&    @ps_args = qw[ ps aux ];
\&    open(PS_PIPE, "\-|", @ps_args)
\&                                || die "can\*(Aqt open @ps_args|: $!";
.Ve
.PP
Because there are more than three arguments to \fIopen()\fR, forks the \fIps\fR\|(1)
command \fIwithout\fR spawning a shell, and reads its standard output via the
\&\f(CW\*(C`PS_PIPE\*(C'\fR filehandle.  The corresponding syntax to \fIwrite\fR to command
pipes is to use \f(CW"|\-"\fR in place of \f(CW"\-|"\fR.
.PP
This was admittedly a rather silly example, because you're using string
literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe \fIopen()\fR.  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of \fIopen()\fR should be used.  For example:
.PP
.Vb 3
\&    @grep_args = ("egrep", "\-i", $some_pattern, @many_files);
\&    open(GREP_PIPE, "\-|", @grep_args)
\&                        || die "can\*(Aqt open @grep_args|: $!";
.Ve
.PP
Here the multi-argument form of pipe \fIopen()\fR is preferred because the
pattern and indeed even the filenames themselves might hold metacharacters.
.PP
Be aware that these operations are full Unix forks, which means they may
not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the \fImodules\fR
file mentioned below in the \s-1SEE\s0 \s-1ALSO\s0 section.
.SS "Avoiding Pipe Deadlocks"
.IX Subsection "Avoiding Pipe Deadlocks"
Whenever you have more than one subprocess, you must be careful that each
closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an \s-1EOF\s0 will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read \s-1EOF\s0.
.PP
Certain built-in Unix features help prevent this most of the time.  For
instance, filehandles have a \*(L"close on exec\*(R" flag, which is set \fIen masse\fR
under control of the \f(CW$^F\fR variable.  This is so any filehandles you
didn't explicitly route to the \s-1STDIN\s0, \s-1STDOUT\s0 or \s-1STDERR\s0 of a child
\&\fIprogram\fR will be automatically closed.
.PP
Always explicitly and immediately call \fIclose()\fR on the writable end of any
pipe, unless that process is actually writing to it.  Even if you don't
explicitly call \fIclose()\fR, Perl will still \fIclose()\fR all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling \fIwaitpid()\fR,
which may again deadlock.
.SS "Bidirectional Communication with Another Process"
.IX Subsection "Bidirectional Communication with Another Process"
While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The most obvious approach doesn't work:
.PP
.Vb 2
\&    # THIS DOES NOT WORK!!
\&    open(PROG_FOR_READING_AND_WRITING, "| some program |")
.Ve
.PP
If you forget to \f(CW\*(C`use warnings\*(C'\fR, you'll miss out entirely on the
helpful diagnostic message:
.PP
.Vb 1
\&    Can\*(Aqt do bidirectional pipe at \-e line 1.
.Ve
.PP
If you really want to, you can use the standard \fIopen2()\fR from the
\&\f(CW\*(C`IPC::Open2\*(C'\fR module to catch both ends.  There's also an \fIopen3()\fR in
\&\f(CW\*(C`IPC::Open3\*(C'\fR for tridirectional I/O so you can also catch your child's
\&\s-1STDERR\s0, but doing so would then require an awkward \fIselect()\fR loop and
wouldn't allow you to use normal Perl input operations.
.PP
If you look at its source, you'll see that \fIopen2()\fR uses low-level
primitives like the \fIpipe()\fR and \fIexec()\fR syscalls to create all the
connections.  Although it might have been more efficient by using
\&\fIsocketpair()\fR, this would have been even less portable than it already
is. The \fIopen2()\fR and \fIopen3()\fR functions are unlikely to work anywhere
except on a Unix system, or at least one purporting \s-1POSIX\s0 compliance.
.PP
Here's an example of using \fIopen2()\fR:
.PP
.Vb 5
\&    use FileHandle;
\&    use IPC::Open2;
\&    $pid = open2(*Reader, *Writer, "cat \-un");
\&    print Writer "stuff\en";
\&    $got = <Reader>;
.Ve
.PP
The problem with this is that buffering is really going to ruin your
day.  Even though your \f(CW\*(C`Writer\*(C'\fR filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
\&\fIcat\fR a \fB\-u\fR flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.
.PP
A solution to this is to use a library which uses pseudottys to make your
program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The \f(CW\*(C`Expect\*(C'\fR module
from \s-1CPAN\s0 also addresses this kind of thing.  This module requires two
other modules from \s-1CPAN\s0, \f(CW\*(C`IO::Pty\*(C'\fR and \f(CW\*(C`IO::Stty\*(C'\fR.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.
.SS "Bidirectional Communication with Yourself"
.IX Subsection "Bidirectional Communication with Yourself"
If you want, you may make low-level \fIpipe()\fR and \fIfork()\fR syscalls to stitch
this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to \s-1STDIN\s0 and \s-1STDOUT\s0 and call other processes.
(The following example lacks proper error checking.)
.PP
.Vb 8
\&    #!/usr/bin/perl \-w
\&    # pipe1 \- bidirectional communication using two pipe pairs
\&    #         designed for the socketpair\-challenged
\&    use IO::Handle;               # thousands of lines just for autoflush :\-(
\&    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
\&    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
\&    CHILD_WTR\->autoflush(1);
\&    PARENT_WTR\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        print CHILD_WTR "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD_RDR>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD_RDR; close CHILD_WTR;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD_RDR; 
\&        close CHILD_WTR;
\&        chomp($line = <PARENT_RDR>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT_WTR "Child Pid $$ is sending this\en";
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        exit(0);
\&    }
.Ve
.PP
But you don't actually have to make two pipe calls.  If you
have the \fIsocketpair()\fR system call, it will do this all for you.
.PP
.Vb 3
\&    #!/usr/bin/perl \-w
\&    # pipe2 \- bidirectional communication using socketpair
\&    #   "the best ones always go both ways"
\&
\&    use Socket;
\&    use IO::Handle;  # thousands of lines just for autoflush :\-(
\&
\&    # We say AF_UNIX because although *_LOCAL is the
\&    # POSIX 1003.1g form of the constant, many machines
\&    # still don\*(Aqt have it.
\&    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
\&                                ||  die "socketpair: $!";
\&
\&    CHILD\->autoflush(1);
\&    PARENT\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT;
\&        print CHILD "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD;
\&        chomp($line = <PARENT>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT "Child Pid $$ is sending this\en";
\&        close PARENT;
\&        exit(0);
\&    }
.Ve
.SH "Sockets: Client/Server Communication"
.IX Header "Sockets: Client/Server Communication"
While not entirely limited to Unix-derived operating systems (e.g., WinSock
on PCs provides socket support, as do some \s-1VMS\s0 libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like \s-1TCP\s0
streams and datagrams like \s-1UDP\s0 packets.  You may be able to do even more
depending on your system.
.PP
The Perl functions for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons.  First, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.
.PP
One of the major problems with ancient, antemillennial socket code in Perl
was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting \f(CW\*(C`$AF_INET = 2\*(C'\fR, you know you're in for big trouble.  
An immeasurably superior approach is to use the \f(CW\*(C`Socket\*(C'\fR module, which more
reliably grants access to the various constants and functions you'll need.
.PP
If you're not writing a server/client for an existing protocol like
\&\s-1NNTP\s0 or \s-1SMTP\s0, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a \*(L"\en\*(R" is received) or multi-line
messages and responses that end with a period on an empty line
(\*(L"\en.\en\*(R" terminates a message/response).
.SS "Internet Line Terminators"
.IX Subsection "Internet Line Terminators"
The Internet line terminator is \*(L"\e015\e012\*(R".  Under \s-1ASCII\s0 variants of
Unix, that could usually be written as \*(L"\er\en\*(R", but under other systems,
\&\*(L"\er\en\*(R" might at times be \*(L"\e015\e015\e012\*(R", \*(L"\e012\e012\e015\*(R", or something
completely different.  The standards specify writing \*(L"\e015\e012\*(R" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone \*(L"\e012\*(R" on input (be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll 
probably be ok.
.SS "Internet \s-1TCP\s0 Clients and Servers"
.IX Subsection "Internet TCP Clients and Servers"
Use Internet-domain sockets when you want to do client-server
communication that might extend to machines outside of your own system.
.PP
Here's a sample \s-1TCP\s0 client using Internet-domain sockets:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    my ($remote, $port, $iaddr, $paddr, $proto, $line);
\&
\&    $remote  = shift || "localhost";
\&    $port    = shift || 2345;  # random port
\&    if ($port =~ /\eD/) { $port = getservbyname($port, "tcp") }
\&    die "No port" unless $port;
\&    $iaddr   = inet_aton($remote)       || die "no host: $remote";
\&    $paddr   = sockaddr_in($port, $iaddr);
\&
\&    $proto   = getprotobyname("tcp");
\&    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
\&    connect(SOCK, $paddr)               || die "connect: $!";
\&    while ($line = <SOCK>) {
\&        print $line;
\&    }
\&
\&    close (SOCK)                        || die "close: $!";
\&    exit(0);
.Ve
.PP
And here's a corresponding server to go along with it.  We'll
leave the address as \f(CW\*(C`INADDR_ANY\*(C'\fR so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), fill this in with your real address instead.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $paddr;
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    for ( ; $paddr = accept(Client, Server); close Client) {
\&        my($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&                inet_ntoa($iaddr), "]
\&                at port $port";
\&
\&        print Client "Hello there, $name, it\*(Aqs now ",
\&                        scalar localtime(), $EOL;
\&    }
.Ve
.PP
And here's a multithreaded version.  It's multithreaded in that
like most typical servers, it spawns (\fIfork()\fRs) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $waitedpid = 0;
\&    my $paddr;
\&
\&    use POSIX ":sys_wait_h";
\&    use Errno;
\&
\&    sub REAPER {
\&        local $!;   # don\*(Aqt let waitpid() overwrite current error
\&        while ((my $pid = waitpid(\-1, WNOHANG)) > 0 && WIFEXITED($?)) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    while (1) {
\&        $paddr = accept(Client, Server) || do {
\&            # try again if accept() returned because got a signal
\&            next if $!{EINTR};
\&            die "accept: $!";
\&        };
\&        my ($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&               inet_ntoa($iaddr),
\&               "] at port $port";
\&
\&        spawn sub {
\&            $| = 1;
\&            print "Hello there, $name, it\*(Aqs now ", scalar localtime(), $EOL;
\&            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
\&                or confess "can\*(Aqt exec fortune: $!";
\&        };
\&        close Client;
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift;
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        }
\&        # else I\*(Aqm the child \-\- go spawn
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
This server takes the trouble to clone off a child version via \fIfork()\fR
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't \fIfork()\fR, the
\&\fIlisten()\fR will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called \*(L"zombies\*(R" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The \s-1REAPER\s0 subroutine is used here to
call \fIwaitpid()\fR for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.
.PP
Within the while loop we call \fIaccept()\fR and check to see if it returns
a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
\&\*(L"Deferred Signals (Safe Signals)\*(R" above) in Perl 5.7.3 means that
\&\fIaccept()\fR might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
notifies the parent process with a \s-1CHLD\s0 signal.
.PP
If \fIaccept()\fR is interrupted by a signal, $! will be set to \s-1EINTR\s0.
If this happens, we can safely continue to the next iteration of
the loop and another call to \fIaccept()\fR.  It is important that your
signal handling code not modify the value of $!, or else this test 
will likely fail.  In the \s-1REAPER\s0 subroutine we create a local version
of $! before calling \fIwaitpid()\fR.  When \fIwaitpid()\fR sets $! to \s-1ECHILD\s0 as
it inevitably does when it has no more children waiting, it 
updates the local copy and leaves the original unchanged.
.PP
You should use the \fB\-T\fR flag to enable taint checking (see perlsec)
even if we aren't running setuid or setgid.  This is always a good idea
for servers or any program run on behalf of someone else (like \s-1CGI\s0
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.
.PP
Let's look at another \s-1TCP\s0 client.  This one connects to the \s-1TCP\s0 \*(L"time\*(R"
service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:
.PP
.Vb 3
\&    #!/usr/bin/perl  \-w
\&    use strict;
\&    use Socket;
\&
\&    my $SECS_OF_70_YEARS = 2208988800;
\&    sub ctime { scalar localtime(shift() || time()) }
\&
\&    my $iaddr = gethostbyname("localhost");
\&    my $proto = getprotobyname("tcp");
\&    my $port = getservbyname("time", "tcp");
\&    my $paddr = sockaddr_in(0, $iaddr);
\&    my($host);
\&
\&    $| = 1;
\&    printf "%\-24s %8s %s\en", "localhost", 0, ctime();
\&
\&    foreach $host (@ARGV) {
\&        printf "%\-24s ", $host;
\&        my $hisiaddr = inet_aton($host)     || die "unknown host";
\&        my $hispaddr = sockaddr_in($port, $hisiaddr);
\&        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
\&                                            || die "socket: $!";
\&        connect(SOCKET, $hispaddr)          || die "connect: $!";
\&        my $rtime = pack("C4", ());
\&        read(SOCKET, $rtime, 4);
\&        close(SOCKET);
\&        my $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%8d %s\en", $histime \- time(), ctime($histime);
\&    }
.Ve
.SS "Unix-Domain \s-1TCP\s0 Clients and Servers"
.IX Subsection "Unix-Domain TCP Clients and Servers"
That's fine for Internet-domain clients and servers, but what about local
communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an \fIls\fR\|(1) listing.
.PP
.Vb 2
\&    % ls \-l /dev/log
\&    srw\-rw\-rw\-  1 root            0 Oct 31 07:23 /dev/log
.Ve
.PP
You can test for these with Perl's \fB\-S\fR file test:
.PP
.Vb 3
\&    unless (\-S "/dev/log") {
\&        die "something\*(Aqs wicked with the log system";
\&    }
.Ve
.PP
Here's a sample Unix-domain client:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use Socket;
\&    use strict;
\&    my ($rendezvous, $line);
\&
\&    $rendezvous = shift || "catsock";
\&    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die "socket: $!";
\&    connect(SOCK, sockaddr_un($rendezvous))   || die "connect: $!";
\&    while (defined($line = <SOCK>)) {
\&        print $line;
\&    }
\&    exit(0);
.Ve
.PP
And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use Socket;
\&    use Carp;
\&
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $NAME = "catsock";
\&    my $uaddr = sockaddr_un($NAME);
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die "socket: $!";
\&    unlink($NAME);
\&    bind  (Server, $uaddr)                  || die "bind: $!";
\&    listen(Server, SOMAXCONN)               || die "listen: $!";
\&
\&    logmsg "server started on $NAME";
\&
\&    my $waitedpid;
\&
\&    use POSIX ":sys_wait_h";
\&    sub REAPER {
\&        my $child;
\&        while (($waitedpid = waitpid(\-1, WNOHANG)) > 0) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&
\&    for ( $waitedpid = 0;
\&          accept(Client, Server) || $waitedpid;
\&          $waitedpid = 0, close Client)
\&    {
\&        next if $waitedpid;
\&        logmsg "connection on $NAME";
\&        spawn sub {
\&            print "Hello there, it\*(Aqs now ", scalar localtime(), "\en";
\&            exec("/usr/games/fortune")  || die "can\*(Aqt exec fortune: $!";
\&        };
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift();
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        } 
\&        else {
\&            # I\*(Aqm the child \-\- go spawn
\&        }
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
As you see, it's remarkably similar to the Internet domain \s-1TCP\s0 server, so
much so, in fact, that we've omitted several duplicate functions\*(--\fIspawn()\fR,
\&\fIlogmsg()\fR, \fIctime()\fR, and \s-1\fIREAPER\s0()\fR\-\-which are the same as in the other server.
.PP
So why would you ever want to use a Unix domain socket instead of a
simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client; that's why \fIaccept()\fR takes two
arguments.
.PP
For example, let's say that you have a long-running database server daemon
that you want folks to be able to access from the Web, but only
if they go through a \s-1CGI\s0 interface.  You'd have a small, simple \s-1CGI\s0
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.
.SH "TCP Clients with IO::Socket"
.IX Header "TCP Clients with IO::Socket"
For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  IO::Socket has
been included in the standard Perl distribution ever since Perl 5.004.  If
you're running an earlier version of Perl (in which case, how are you
reading this manpage?), just fetch IO::Socket from \s-1CPAN\s0, where you'll also
find modules providing easy interfaces to the following systems: \s-1DNS\s0, \s-1FTP\s0,
Ident (\s-1RFC\s0 931), \s-1NIS\s0 and NISPlus, \s-1NNTP\s0, Ping, \s-1POP3\s0, \s-1SMTP\s0, \s-1SNMP\s0, SSLeay,
Telnet, and Time\*(--to name just a few.
.SS "A Simple Client"
.IX Subsection "A Simple Client"
Here's a client that creates a \s-1TCP\s0 connection to the \*(L"daytime\*(R"
service at port 13 of the host name \*(L"localhost\*(R" and prints out everything
that the server there cares to provide.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    $remote = IO::Socket::INET\->new(
\&                        Proto    => "tcp",
\&                        PeerAddr => "localhost",
\&                        PeerPort => "daytime(13)",
\&                    )
\&                  || die "can\*(Aqt connect to daytime service on localhost";
\&    while (<$remote>) { print }
.Ve
.PP
When you run this program, you should get something back that
looks like this:
.PP
.Vb 1
\&    Wed May 14 08:40:46 MDT 1997
.Ve
.PP
Here are what those parameters to the \fInew()\fR constructor mean:
.ie n .IP """Proto""" 4
.el .IP "\f(CWProto\fR" 4
.IX Item "Proto"
This is which protocol to use.  In this case, the socket handle returned
will be connected to a \s-1TCP\s0 socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the \s-1UDP\s0 protocol
can be used to make a datagram socket, used for message-passing.
.ie n .IP """PeerAddr""" 4
.el .IP "\f(CWPeerAddr\fR" 4
.IX Item "PeerAddr"
This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like \f(CW"www.perl.com"\fR,
or an address like \f(CW"207.171.7.72"\fR.  For demonstration purposes, we've
used the special hostname \f(CW"localhost"\fR, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is \f(CW"127.0.0.1"\fR, if you'd rather use that.
.ie n .IP """PeerPort""" 4
.el .IP "\f(CWPeerPort\fR" 4
.IX Item "PeerPort"
This is the service name or port number we'd like to connect to.
We could have gotten away with using just \f(CW"daytime"\fR on systems with a
well-configured system services file,[\s-1FOOTNOTE:\s0 The system services file
is found in \fI/etc/services\fR under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.
.PP
Notice how the return value from the \f(CW\*(C`new\*(C'\fR constructor is used as
a filehandle in the \f(CW\*(C`while\*(C'\fR loop?  That's what's called an \fIindirect
filehandle\fR, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:
.PP
.Vb 1
\&    $line = <$handle>;
.Ve
.PP
all remaining lines from is this way:
.PP
.Vb 1
\&    @lines = <$handle>;
.Ve
.PP
and send a line of data to it this way:
.PP
.Vb 1
\&    print $handle "some data\en";
.Ve
.SS "A Webget Client"
.IX Subsection "A Webget Client"
Here's a simple client that takes a remote host to fetch a document
from, and then a list of files to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.
.PP
.Vb 10
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    unless (@ARGV > 1) { die "usage: $0 host url ..." }
\&    $host = shift(@ARGV);
\&    $EOL = "\e015\e012";
\&    $BLANK = $EOL x 2;
\&    for my $document (@ARGV) {
\&        $remote = IO::Socket::INET\->new( Proto     => "tcp",
\&                                         PeerAddr  => $host,
\&                                         PeerPort  => "http(80)",
\&                  )     || die "cannot connect to httpd on $host";
\&        $remote\->autoflush(1);
\&        print $remote "GET $document HTTP/1.0" . $BLANK;
\&        while ( <$remote> ) { print }
\&        close $remote;
\&    }
.Ve
.PP
The web server handling the \s-1HTTP\s0 service is assumed to be at
its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
as the named-parameter pair, \f(CW\*(C`PeerPort => 8080\*(C'\fR.  The \f(CW\*(C`autoflush\*(C'\fR
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every \f(CW"\en"\fR in your code that sends data over the network
to be a \f(CW"\e015\e012"\fR instead.)
.PP
Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with \*(L"\s-1GET\s0\*(R" is in
\&\s-1HTTP\s0 syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak \s-1HTTP\s0.
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.
.PP
Here's an example of running that program, which we'll call \fIwebget\fR:
.PP
.Vb 6
\&    % webget www.perl.com /guanaco.html
\&    HTTP/1.1 404 File Not Found
\&    Date: Thu, 08 May 1997 18:02:32 GMT
\&    Server: Apache/1.2b6
\&    Connection: close
\&    Content\-type: text/html
\&
\&    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
\&    <BODY><H1>File Not Found</H1>
\&    The requested URL /guanaco.html was not found on this server.<P>
\&    </BODY>
.Ve
.PP
Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.
.PP
For a more featureful version of this program, you should look to
the \fIlwp-request\fR program included with the \s-1LWP\s0 modules from \s-1CPAN\s0.
.SS "Interactive Client with IO::Socket"
.IX Subsection "Interactive Client with IO::Socket"
Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way \fItelnet\fR works?  That way you can type a line, get the answer,
type a line, get the answer, etc.
.PP
This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful \f(CW\*(C`fork\*(C'\fR call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call \f(CW\*(C`fork\*(C'\fR to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be \fImuch\fR
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)
.PP
Here's the code:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use IO::Socket;
\&    my ($host, $port, $kidpid, $handle, $line);
\&
\&    unless (@ARGV == 2) { die "usage: $0 host port" }
\&    ($host, $port) = @ARGV;
\&
\&    # create a tcp connection to the specified host and port
\&    $handle = IO::Socket::INET\->new(Proto     => "tcp",
\&                                    PeerAddr  => $host,
\&                                    PeerPort  => $port)
\&               || die "can\*(Aqt connect to port $port on $host: $!";
\&
\&    $handle\->autoflush(1);       # so output gets there right away
\&    print STDERR "[Connected to $host:$port]\en";
\&
\&    # split the program into two processes, identical twins
\&    die "can\*(Aqt fork: $!" unless defined($kidpid = fork());
\&
\&    # the if{} block runs only in the parent process
\&    if ($kidpid) {
\&        # copy the socket to standard output
\&        while (defined ($line = <$handle>)) {
\&            print STDOUT $line;
\&        }
\&        kill("TERM", $kidpid);   # send SIGTERM to child
\&    }
\&    # the else{} block runs only in the child process
\&    else {
\&        # copy standard input to the socket
\&        while (defined ($line = <STDIN>)) {
\&            print $handle $line;
\&        }
\&        exit(0);                # just in case
\&    }
.Ve
.PP
The \f(CW\*(C`kill\*(C'\fR function in the parent's \f(CW\*(C`if\*(C'\fR block is there to send a
signal to our child process, currently running in the \f(CW\*(C`else\*(C'\fR block,
as soon as the remote server has closed its end of the connection.
.PP
If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the \f(CW\*(C`while\*(C'\fR loop in the parent with the
following:
.PP
.Vb 4
\&    my $byte;
\&    while (sysread($handle, $byte, 1) == 1) {
\&        print STDOUT $byte;
\&    }
.Ve
.PP
Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.
.SH "TCP Servers with IO::Socket"
.IX Header "TCP Servers with IO::Socket"
As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the \f(CW\*(C`IO::Socket::INET\->new()\*(C'\fR method with
slightly different arguments than the client did.
.IP "Proto" 4
.IX Item "Proto"
This is which protocol to use.  Like our clients, we'll
still specify \f(CW"tcp"\fR here.
.IP "LocalPort" 4
.IX Item "LocalPort"
We specify a local
port in the \f(CW\*(C`LocalPort\*(C'\fR argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an \*(L"Address already in use\*(R"
message.  Under Unix, the \f(CW\*(C`netstat \-a\*(C'\fR command will show
which services current have servers.
.IP "Listen" 4
.IX Item "Listen"
The \f(CW\*(C`Listen\*(C'\fR parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is \s-1SOMAXCONN\s0.
.IP "Reuse" 4
.IX Item "Reuse"
The \f(CW\*(C`Reuse\*(C'\fR parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.
.PP
Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the \f(CW\*(C`accept\*(C'\fR method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)
.PP
To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the \f(CW\*(C`sysread\*(C'\fR variant of the interactive client above.
.PP
This server accepts one of five different commands, sending output back to
the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multithreaded servers are covered in 
Chapter 16 of the Camel.
.PP
Here's the code.  We'll
.PP
.Vb 3
\& #!/usr/bin/perl \-w
\& use IO::Socket;
\& use Net::hostent;      # for OOish version of gethostbyaddr
\&
\& $PORT = 9000;          # pick something not in use
\&
\& $server = IO::Socket::INET\->new( Proto     => "tcp",
\&                                  LocalPort => $PORT,
\&                                  Listen    => SOMAXCONN,
\&                                  Reuse     => 1);
\&
\& die "can\*(Aqt setup server" unless $server;
\& print "[Server $0 accepting clients]\en";
\&
\& while ($client = $server\->accept()) {
\&   $client\->autoflush(1);
\&   print $client "Welcome to $0; type help for command list.\en";
\&   $hostinfo = gethostbyaddr($client\->peeraddr);
\&   printf "[Connect from %s]\en", $hostinfo ? $hostinfo\->name : $client\->peerhost;
\&   print $client "Command? ";
\&   while ( <$client>) {
\&     next unless /\eS/;       # blank line
\&     if    (/quit|exit/i)    { last                                      }
\&     elsif (/date|time/i)    { printf $client "%s\en", scalar localtime() }
\&     elsif (/who/i )         { print  $client \`who 2>&1\`                 }
\&     elsif (/cookie/i )      { print  $client \`/usr/games/fortune 2>&1\`  }
\&     elsif (/motd/i )        { print  $client \`cat /etc/motd 2>&1\`       }
\&     else {
\&       print $client "Commands: quit date who cookie motd\en";
\&     }
\&   } continue {
\&      print $client "Command? ";
\&   }
\&   close $client;
\& }
.Ve
.SH "UDP: Message Passing"
.IX Header "UDP: Message Passing"
Another kind of client-server setup is one that uses not connections, but
messages.  \s-1UDP\s0 communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, \s-1UDP\s0 offers some advantages
over \s-1TCP\s0, including being able to \*(L"broadcast\*(R" or \*(L"multicast\*(R" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just \s-1TCP\s0 to start
with.
.PP
\&\s-1UDP\s0 datagrams are \fInot\fR a bytestream and should not be treated as such.
This makes using I/O mechanisms with internal buffering like stdio (i.e.
\&\fIprint()\fR and friends) especially cumbersome. Use \fIsyswrite()\fR, or better
\&\fIsend()\fR, like in the example below.
.PP
Here's a \s-1UDP\s0 program similar to the sample Internet \s-1TCP\s0 client given
earlier.  However, instead of checking one host at a time, the \s-1UDP\s0 version
will check many of them asynchronously by simulating a multicast and then
using \fIselect()\fR to do a timed-out wait for I/O.  To do something similar
with \s-1TCP\s0, you'd have to use a different socket handle for each host.
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    use Sys::Hostname;
\&
\&    my ( $count, $hisiaddr, $hispaddr, $histime,
\&         $host, $iaddr, $paddr, $port, $proto,
\&         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
\&
\&    $SECS_OF_70_YEARS = 2_208_988_800;
\&
\&    $iaddr = gethostbyname(hostname());
\&    $proto = getprotobyname("udp");
\&    $port = getservbyname("time", "udp");
\&    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
\&
\&    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
\&    bind(SOCKET, $paddr)                          || die "bind: $!";
\&
\&    $| = 1;
\&    printf "%\-12s %8s %s\en",  "localhost", 0, scalar localtime();
\&    $count = 0;
\&    for $host (@ARGV) {
\&        $count++;
\&        $hisiaddr = inet_aton($host)              || die "unknown host";
\&        $hispaddr = sockaddr_in($port, $hisiaddr);
\&        defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
\&    }
\&
\&    $rin = "";
\&    vec($rin, fileno(SOCKET), 1) = 1;
\&
\&    # timeout after 10.0 seconds
\&    while ($count && select($rout = $rin, undef, undef, 10.0)) {
\&        $rtime = "";
\&        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
\&        ($port, $hisiaddr) = sockaddr_in($hispaddr);
\&        $host = gethostbyaddr($hisiaddr, AF_INET);
\&        $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%\-12s ", $host;
\&        printf "%8d %s\en", $histime \- time(), scalar localtime($histime);
\&        $count\-\-;
\&    }
.Ve
.PP
This example does not include any retries and may consequently fail to
contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.
.SH "SysV IPC"
.IX Header "SysV IPC"
While System V \s-1IPC\s0 isn't so widely used as sockets, it still has some
interesting uses.  However, you cannot use SysV \s-1IPC\s0 or Berkeley \fImmap()\fR to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the \f(CW\*(C`IPC::Shareable\*(C'\fR or \f(CW\*(C`threads::shared\*(C'\fR modules for that.
.PP
Here's a small example showing shared memory usage.
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
\&
\&    $size = 2000;
\&    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
\&    defined($id)                    || die "shmget: $!";
\&    print "shm key $id\en";
\&
\&    $message = "Message #1";
\&    shmwrite($id, $message, 0, 60)  || die "shmwrite: $!";
\&    print "wrote: \*(Aq$message\*(Aq\en";
\&    shmread($id, $buff, 0, 60)      || die "shmread: $!";
\&    print "read : \*(Aq$buff\*(Aq\en";
\&
\&    # the buffer of shmread is zero\-character end\-padded.
\&    substr($buff, index($buff, "\e0")) = "";
\&    print "un" unless $buff eq $message;
\&    print "swell\en";
\&
\&    print "deleting shm $id\en";
\&    shmctl($id, IPC_RMID, 0)        || die "shmctl: $!";
.Ve
.PP
Here's an example of a semaphore:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_CREAT);
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
\&    defined($id)                    || die "shmget: $!";
\&    print "shm key $id\en";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call the file \fItake\fR:
.PP
.Vb 1
\&    # create a semaphore
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    defined($id)                    || die "shmget: $!";
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # "take" semaphore
\&    # wait for semaphore to be zero
\&    $semop = 0;
\&    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    # Increment the semaphore count
\&    $semop = 1;
\&    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
\&    $opstring  = $opstring1 . $opstring2;
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call this file \fIgive\fR:
.PP
.Vb 3
\&    # "give" the semaphore
\&    # run this in the original process and you will see
\&    # that the second process continues
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    die unless defined($id);
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # Decrement the semaphore count
\&    $semop = \-1;
\&    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
The SysV \s-1IPC\s0 code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.
.PP
A small example demonstrating SysV message queues:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
\&
\&    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
\&    defined($id)                || die "msgget failed: $!";
\&
\&    my $sent      = "message";
\&    my $type_sent = 1234;
\&
\&    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
\&                                || die "msgsnd failed: $!";
\&
\&    msgrcv($id, my $rcvd_buf, 60, 0, 0)
\&                                || die "msgrcv failed: $!";
\&
\&    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);
\&
\&    if ($rcvd eq $sent) {
\&        print "okay\en";
\&    } else {
\&        print "not okay\en";
\&    }
\&
\&    msgctl($id, IPC_RMID, 0)    || die "msgctl failed: $!\en";
.Ve
.SH "NOTES"
.IX Header "NOTES"
Most of these routines quietly but politely return \f(CW\*(C`undef\*(C'\fR when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new \fISocket\fR conversion
functions do \fIcroak()\fR on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add the \fB\-T\fR
taint-checking flag to the \f(CW\*(C`#!\*(C'\fR line for servers:
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use sigtrap;
\&    use Socket;
.Ve
.SH "BUGS"
.IX Header "BUGS"
These routines all create system-specific portability problems.  As noted
elsewhere, Perl is at the mercy of your C libraries for much of its system
behavior.  It's probably safest to assume broken SysV semantics for
signals and to stick with simple \s-1TCP\s0 and \s-1UDP\s0 socket operations; e.g., don't
try to pass open file descriptors over a local \s-1UDP\s0 datagram socket if you
want your code to stand a chance of being portable.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There's a lot more to networking than this, but this should get you
started.
.PP
For intrepid programmers, the indispensable textbook is \fIUnix Network
Programming, 2nd Edition, Volume 1\fR by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.
.PP
The \fIIO::Socket\fR\|(3) manpage describes the object library, and the \fISocket\fR\|(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in perlfunc, you should also check out the \fImodules\fR file at
your nearest \s-1CPAN\s0 site, especially
<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
See perlmodlib or best yet, the \fIPerl \s-1FAQ\s0\fR for a description
of what \s-1CPAN\s0 is and where to get it if the previous link doesn't work 
for you.
.PP
Section 5 of \s-1CPAN\s0's \fImodules\fR file is devoted to \*(L"Networking, Device
Control (modems), and Interprocess Communication\*(R", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
\&\s-1CGI\s0 programming, \s-1DCE\s0, \s-1FTP\s0, \s-1IPC\s0, \s-1NNTP\s0, Proxy, Ptty, \s-1RPC\s0, \s-1SNMP\s0, \s-1SMTP\s0, Telnet,
Threads, and ToolTalk\*(--to name just a few.
                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlipc5.18.1                                0100644 0001750 0001750 00000242551 12566207441 022722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIPC 1"
.TH PERLIPC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlipc \- Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, and semaphores)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The basic \s-1IPC\s0 facilities of Perl are built out of the good old Unix
signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
\&\s-1IPC\s0 calls.  Each is used in slightly different situations.
.SH "Signals"
.IX Header "Signals"
Perl uses a simple signal handling model: the \f(CW%SIG\fR hash contains names
or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.
.PP
For example, to trap an interrupt signal, set up a handler like this:
.PP
.Vb 1
\&    our $shucks;
\&
\&    sub catch_zap {
\&        my $signame = shift;
\&        $shucks++;
\&        die "Somebody sent me a SIG$signame";
\&    }
\&    $SIG{INT} = _\|_PACKAGE_\|_ . "::catch_zap";  
\&    $SIG{INT} = \e&catch_zap;  # best strategy
.Ve
.PP
Prior to Perl 5.8.0 it was necessary to do as little as you possibly
could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly \fIanything\fR in your
handler could in theory trigger a memory fault and subsequent core
dump \- see \*(L"Deferred Signals (Safe Signals)\*(R" below.
.PP
The names of the signals are the ones listed out by \f(CW\*(C`kill \-l\*(C'\fR on your
system, or you can retrieve them using the \s-1CPAN\s0 module IPC::Signal.
.PP
You may also choose to assign the strings \f(CW"IGNORE"\fR or \f(CW"DEFAULT"\fR as
the handler, in which case Perl will try to discard the signal or do the
default thing.
.PP
On most Unix platforms, the \f(CW\*(C`CHLD\*(C'\fR (sometimes also known as \f(CW\*(C`CLD\*(C'\fR) signal
has special behavior with respect to a value of \f(CW"IGNORE"\fR.
Setting \f(CW$SIG{CHLD}\fR to \f(CW"IGNORE"\fR on such a platform has the effect of
not creating zombie processes when the parent process fails to \f(CW\*(C`wait()\*(C'\fR
on its child processes (i.e., child processes are automatically reaped).
Calling \f(CW\*(C`wait()\*(C'\fR with \f(CW$SIG{CHLD}\fR set to \f(CW"IGNORE"\fR usually returns
\&\f(CW\*(C`\-1\*(C'\fR on such platforms.
.PP
Some signals can be neither trapped nor ignored, such as the \s-1KILL\s0 and \s-1STOP
\&\s0(but not the \s-1TSTP\s0) signals. Note that ignoring signals makes them disappear.
If you only want them blocked temporarily without them getting lost you'll
have to use \s-1POSIX\s0' sigprocmask.
.PP
Sending a signal to a negative process \s-1ID\s0 means that you send the signal
to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets \f(CW$SIG\fR{\s-1HUP\s0} to \f(CW"IGNORE"\fR 
so it doesn't kill itself:
.PP
.Vb 6
\&    # block scope for local
\&    {
\&        local $SIG{HUP} = "IGNORE";
\&        kill HUP => \-$$;
\&        # snazzy writing of: kill("HUP", \-$$)
\&    }
.Ve
.PP
Another interesting signal to send is signal number zero.  This doesn't
actually affect a child process, but instead checks whether it's alive
or has changed its UIDs.
.PP
.Vb 3
\&    unless (kill 0 => $kid_pid) {
\&        warn "something wicked happened to $kid_pid";
\&    }
.Ve
.PP
Signal number zero may fail because you lack permission to send the
signal when directed at a process whose real or saved \s-1UID\s0 is not
identical to the real or effective \s-1UID\s0 of the sending process, even
though the process is alive.  You may be able to determine the cause of
failure using \f(CW$!\fR or \f(CW\*(C`%!\*(C'\fR.
.PP
.Vb 3
\&    unless (kill(0 => $pid) || $!{EPERM}) {
\&        warn "$pid looks dead";
\&    }
.Ve
.PP
You might also want to employ anonymous functions for simple signal
handlers:
.PP
.Vb 1
\&    $SIG{INT} = sub { die "\enOutta here!\en" };
.Ve
.PP
\&\s-1SIGCHLD\s0 handlers require some special care.  If a second child dies
while in the signal handler caused by the first death, we won't get
another signal. So must loop here else we will leave the unreaped child
as a zombie. And the next time two children die we get another zombie.
And so on.
.PP
.Vb 7
\&    use POSIX ":sys_wait_h";
\&    $SIG{CHLD} = sub {
\&        while ((my $child = waitpid(\-1, WNOHANG)) > 0) {
\&            $Kid_Status{$child} = $?;
\&        }
\&    };
\&    # do something that forks...
.Ve
.PP
Be careful: \fIqx()\fR, \fIsystem()\fR, and some modules for calling external commands
do a \fIfork()\fR, then \fIwait()\fR for the result. Thus, your signal handler
will be called. Because \fIwait()\fR was already called by \fIsystem()\fR or \fIqx()\fR,
the \fIwait()\fR in the signal handler will see no more zombies and will
therefore block.
.PP
The best way to prevent this issue is to use \fIwaitpid()\fR, as in the following
example:
.PP
.Vb 1
\&    use POSIX ":sys_wait_h"; # for nonblocking read
\&
\&    my %children;
\&
\&    $SIG{CHLD} = sub {
\&        # don\*(Aqt change $! and $? outside handler
\&        local ($!, $?);
\&        my $pid = waitpid(\-1, WNOHANG);
\&        return if $pid == \-1;
\&        return unless defined $children{$pid};
\&        delete $children{$pid};
\&        cleanup_child($pid, $?);
\&    };
\&
\&    while (1) {
\&        my $pid = fork();
\&        die "cannot fork" unless defined $pid;
\&        if ($pid == 0) {
\&            # ...
\&            exit 0;
\&        } else {
\&            $children{$pid}=1;
\&            # ...
\&            system($command);
\&            # ...
\&       }
\&    }
.Ve
.PP
Signal handling is also used for timeouts in Unix.  While safely
protected within an \f(CW\*(C`eval{}\*(C'\fR block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your \f(CW\*(C`eval{}\*(C'\fR block.  If it
goes off, you'll use \fIdie()\fR to jump out of the block.
.PP
Here's an example:
.PP
.Vb 9
\&    my $ALARM_EXCEPTION = "alarm clock restart";
\&    eval {
\&        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
\&        alarm 10;
\&        flock(FH, 2)    # blocking write lock
\&                        || die "cannot flock: $!";
\&        alarm 0;
\&    };
\&    if ($@ && $@ !~ quotemeta($ALARM_EXCEPTION)) { die }
.Ve
.PP
If the operation being timed out is \fIsystem()\fR or \fIqx()\fR, this technique
is liable to generate zombies.    If this matters to you, you'll
need to do your own \fIfork()\fR and \fIexec()\fR, and kill the errant child process.
.PP
For more complex signal handling, you might see the standard \s-1POSIX\s0
module.  Lamentably, this is almost entirely undocumented, but
the \fIt/lib/posix.t\fR file from the Perl source distribution has some
examples in it.
.SS "Handling the \s-1SIGHUP\s0 Signal in Daemons"
.IX Subsection "Handling the SIGHUP Signal in Daemons"
A process that usually starts when the system boots and shuts down
when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a \f(CW\*(C`SIGHUP\*(C'\fR
signal handler. When you want to tell the daemon to reread the file,
simply send it the \f(CW\*(C`SIGHUP\*(C'\fR signal.
.PP
The following example implements a simple daemon, which restarts
itself every time the \f(CW\*(C`SIGHUP\*(C'\fR signal is received. The actual code is
located in the subroutine \f(CW\*(C`code()\*(C'\fR, which just prints some debugging
info to show that it works; it should be replaced with the real code.
.PP
.Vb 1
\&  #!/usr/bin/perl \-w
\&
\&  use POSIX ();
\&  use FindBin ();
\&  use File::Basename ();
\&  use File::Spec::Functions;
\&
\&  $| = 1;
\&
\&  # make the daemon cross\-platform, so exec always calls the script
\&  # itself with the right path, no matter how the script was invoked.
\&  my $script = File::Basename::basename($0);
\&  my $SELF  = catfile($FindBin::Bin, $script);
\&
\&  # POSIX unmasks the sigprocmask properly
\&  $SIG{HUP} = sub {
\&      print "got SIGHUP\en";
\&      exec($SELF, @ARGV)        || die "$0: couldn\*(Aqt restart: $!";
\&  };
\&
\&  code();
\&
\&  sub code {
\&      print "PID: $$\en";
\&      print "ARGV: @ARGV\en";
\&      my $count = 0;
\&      while (++$count) {
\&          sleep 2;
\&          print "$count\en";
\&      }
\&  }
.Ve
.SS "Deferred Signals (Safe Signals)"
.IX Subsection "Deferred Signals (Safe Signals)"
Before Perl 5.8.0, installing Perl code to deal with signals exposed you to
danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like \fImalloc\fR\|(3) or \fIprintf\fR\|(3)), and your signal handler then calls the same
function again, you could get unpredictable behavior\*(--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.
.PP
There were two things you could do, knowing this: be paranoid or be
pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to \f(CW\*(C`die\*(C'\fR to \fIlongjmp\fR\|(3) out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids \f(CW\*(C`die\*(C'\fR in a handler because the system \fIis\fR out to get you.
The pragmatic approach was to say \*(L"I know the risks, but prefer the
convenience\*(R", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.
.PP
Perl 5.8.0 and later avoid these problems by \*(L"deferring\*(R" signals.  That is,
when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic \*(L"safe\*(R" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from \f(CW%SIG\fR is executed. The \*(L"deferred\*(R" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library
function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:
.IP "Long-running opcodes" 4
.IX Item "Long-running opcodes"
As the Perl interpreter looks at signal flags only when it is about
to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.
.Sp
If a signal of any given type fires multiple times during an opcode 
(such as from a fine-grained timer), the handler for that signal will
be called only once, after the opcode completes; all other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling \f(CWalarm(0)\fR as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.
.IP "Interrupting \s-1IO\s0" 4
.IX Item "Interrupting IO"
When a signal is delivered (e.g., \s-1SIGINT\s0 from a control-C) the operating
system breaks into \s-1IO\s0 operations like \fIread\fR(2), which is used to
implement Perl's \fIreadline()\fR function, the \f(CW\*(C`<>\*(C'\fR operator. On older
Perls the handler was called immediately (and as \f(CW\*(C`read\*(C'\fR is not \*(L"unsafe\*(R",
this worked well). With the \*(L"deferred\*(R" scheme the handler is \fInot\fR called
immediately, and if Perl is using the system's \f(CW\*(C`stdio\*(C'\fR library that
library may restart the \f(CW\*(C`read\*(C'\fR without returning to Perl to give it a
chance to call the \f(CW%SIG\fR handler. If this happens on your system the
solution is to use the \f(CW\*(C`:perlio\*(C'\fR layer to do IO\*(--at least on those handles
that you want to be able to break into with signals. (The \f(CW\*(C`:perlio\*(C'\fR layer
checks the signal flags and calls \f(CW%SIG\fR handlers before resuming \s-1IO\s0
operation.)
.Sp
The default in Perl 5.8.0 and later is to automatically use
the \f(CW\*(C`:perlio\*(C'\fR layer.
.Sp
Note that it is not advisable to access a file handle within a signal
handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.
.Sp
Some networking library functions like \fIgethostbyname()\fR are known to have
their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the \s-1POSIX\s0
\&\fIsigaction()\fR function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.
.Sp
Instead of setting \f(CW$SIG{ALRM}\fR:
.Sp
.Vb 1
\&   local $SIG{ALRM} = sub { die "alarm" };
.Ve
.Sp
try something like the following:
.Sp
.Vb 3
\&  use POSIX qw(SIGALRM);
\&  POSIX::sigaction(SIGALRM, POSIX::SigAction\->new(sub { die "alarm" }))
\&          || die "Error setting SIGALRM handler: $!\en";
.Ve
.Sp
Another way to disable the safe signal behavior locally is to use
the \f(CW\*(C`Perl::Unsafe::Signals\*(C'\fR module from \s-1CPAN,\s0 which affects
all signals.
.IP "Restartable system calls" 4
.IX Item "Restartable system calls"
On systems that supported it, older versions of Perl used the
\&\s-1SA_RESTART\s0 flag when installing \f(CW%SIG\fR handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.8.0 and later do \fInot\fR use \s-1SA_RESTART. \s0 Consequently, 
restartable system calls can fail (with $! set to \f(CW\*(C`EINTR\*(C'\fR) in places
where they previously would have succeeded.
.Sp
The default \f(CW\*(C`:perlio\*(C'\fR layer retries \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`write\*(C'\fR
and \f(CW\*(C`close\*(C'\fR as described above; interrupted \f(CW\*(C`wait\*(C'\fR and 
\&\f(CW\*(C`waitpid\*(C'\fR calls will always be retried.
.ie n .IP "Signals as ""faults""" 4
.el .IP "Signals as ``faults''" 4
.IX Item "Signals as faults"
Certain signals like \s-1SEGV, ILL,\s0 and \s-1BUS\s0 are generated by virtual memory
addressing errors and similar \*(L"faults\*(R". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl delivers them
immediately rather than attempting to defer them.
.IP "Signals triggered by operating system state" 4
.IX Item "Signals triggered by operating system state"
On some operating systems certain signal handlers are supposed to \*(L"do
something\*(R" before returning. One example can be \s-1CHLD\s0 or \s-1CLD,\s0 which
indicates a child process has completed. On some operating systems the
signal handler is expected to \f(CW\*(C`wait\*(C'\fR for the completed child
process. On such systems the deferred signal scheme will not work for
those signals: it does not do the \f(CW\*(C`wait\*(C'\fR. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been \f(CW\*(C`wait\*(C'\fRed for.
.PP
If you want the old signal behavior back despite possible
memory corruption, set the environment variable \f(CW\*(C`PERL_SIGNALS\*(C'\fR to
\&\f(CW"unsafe"\fR.  This feature first appeared in Perl 5.8.1.
.SH "Named Pipes"
.IX Header "Named Pipes"
A named pipe (often referred to as a \s-1FIFO\s0) is an old Unix \s-1IPC\s0
mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.
.PP
To create a named pipe, use the \f(CW\*(C`POSIX::mkfifo()\*(C'\fR function.
.PP
.Vb 2
\&    use POSIX qw(mkfifo);
\&    mkfifo($path, 0700)     ||  die "mkfifo $path failed: $!";
.Ve
.PP
You can also use the Unix command \fImknod\fR\|(1), or on some
systems, \fImkfifo\fR\|(1).  These may not be in your normal path, though.
.PP
.Vb 8
\&    # system return val is backwards, so && not ||
\&    #
\&    $ENV{PATH} .= ":/etc:/usr/etc";
\&    if  (      system("mknod",  $path, "p")
\&            && system("mkfifo", $path) )
\&    {
\&        die "mk{nod,fifo} $path failed";
\&    }
.Ve
.PP
A fifo is convenient when you want to connect a process to an unrelated
one.  When you open a fifo, the program will block until there's something
on the other end.
.PP
For example, let's say you'd like to have your \fI.signature\fR file be a
named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, \fB\-p\fR, to find
out whether anyone (or anything) has accidentally removed our fifo.
.PP
.Vb 2
\&    chdir();    # go home
\&    my $FIFO = ".signature";
\&
\&    while (1) {
\&        unless (\-p $FIFO) {
\&            unlink $FIFO;   # discard any failure, will catch later
\&            require POSIX;  # delayed loading of heavy module
\&            POSIX::mkfifo($FIFO, 0700)
\&                                || die "can\*(Aqt mkfifo $FIFO: $!";
\&        }
\&
\&        # next line blocks till there\*(Aqs a reader
\&        open (FIFO, "> $FIFO")  || die "can\*(Aqt open $FIFO: $!";
\&        print FIFO "John Smith (smith\e@host.org)\en", \`fortune \-s\`;
\&        close(FIFO)             || die "can\*(Aqt close $FIFO: $!";
\&        sleep 2;                # to avoid dup signals
\&    }
.Ve
.SH "Using \fIopen()\fP for IPC"
.IX Header "Using open() for IPC"
Perl's basic \fIopen()\fR statement can also be used for unidirectional
interprocess communication by either appending or prepending a pipe
symbol to the second argument to \fIopen()\fR.  Here's how to start
something up in a child process you intend to write to:
.PP
.Vb 5
\&    open(SPOOLER, "| cat \-v | lpr \-h 2>/dev/null")
\&                        || die "can\*(Aqt fork: $!";
\&    local $SIG{PIPE} = sub { die "spooler pipe broke" };
\&    print SPOOLER "stuff\en";
\&    close SPOOLER       || die "bad spool: $! $?";
.Ve
.PP
And here's how to start up a child process you intend to read from:
.PP
.Vb 7
\&    open(STATUS, "netstat \-an 2>&1 |")
\&                        || die "can\*(Aqt fork: $!";
\&    while (<STATUS>) {
\&        next if /^(tcp|udp)/;
\&        print;
\&    }
\&    close STATUS        || die "bad netstat: $! $?";
.Ve
.PP
If one can be sure that a particular program is a Perl script expecting
filenames in \f(CW@ARGV\fR, the clever programmer can write something like this:
.PP
.Vb 1
\&    % program f1 "cmd1|" \- f2 "cmd2|" f3 < tmpfile
.Ve
.PP
and no matter which sort of shell it's called from, the Perl program will
read from the file \fIf1\fR, the process \fIcmd1\fR, standard input (\fItmpfile\fR
in this case), the \fIf2\fR file, the \fIcmd2\fR command, and finally the \fIf3\fR
file.  Pretty nifty, eh?
.PP
You might notice that you could use backticks for much the
same effect as opening a pipe for reading:
.PP
.Vb 2
\&    print grep { !/^(tcp|udp)/ } \`netstat \-an 2>&1\`;
\&    die "bad netstatus ($?)" if $?;
.Ve
.PP
While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you kill off the child process early if you'd like.
.PP
Be careful to check the return values from both \fIopen()\fR and \fIclose()\fR.  If
you're \fIwriting\fR to a pipe, you should also trap \s-1SIGPIPE. \s0 Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the \fIopen()\fR will in all likelihood succeed (it only reflects the
\&\fIfork()\fR's success), but then your output will fail\*(--spectacularly.  Perl
can't know whether the command worked, because your command is actually
running in a separate process whose \fIexec()\fR might have failed.  Therefore,
while readers of bogus commands return just a quick \s-1EOF,\s0 writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:
.PP
.Vb 4
\&    open(FH, "|bogus")      || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";      #  neither necessary nor sufficient 
\&                            #  to check print retval!
\&    close(FH)               || die "can\*(Aqt close: $!";
.Ve
.PP
The reason for not checking the return value from \fIprint()\fR is because of
pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a \s-1SIGPIPE. \s0 To catch it, you could use
this:
.PP
.Vb 4
\&    $SIG{PIPE} = "IGNORE";
\&    open(FH, "|bogus")  || die "can\*(Aqt fork: $!";
\&    print FH "bang\en";
\&    close(FH)           || die "can\*(Aqt close: status=$?";
.Ve
.SS "Filehandles"
.IX Subsection "Filehandles"
Both the main process and any child processes it forks share the same
\&\s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with \fIopen()\fR, but on some systems this means that the
child process cannot outlive the parent.
.SS "Background Processes"
.IX Subsection "Background Processes"
You can run a command in the background with:
.PP
.Vb 1
\&    system("cmd &");
.Ve
.PP
The command's \s-1STDOUT\s0 and \s-1STDERR \s0(and possibly \s-1STDIN,\s0 depending on your
shell) will be the same as the parent's.  You won't need to catch
\&\s-1SIGCHLD\s0 because of the double-fork taking place; see below for details.
.SS "Complete Dissociation of Child from Parent"
.IX Subsection "Complete Dissociation of Child from Parent"
In some cases (starting server processes, for instance) you'll want to
completely dissociate the child process from the parent.  This is
often called daemonization.  A well-behaved daemon will also \fIchdir()\fR
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to \fI/dev/null\fR so that random
output doesn't wind up on the user's terminal.
.PP
.Vb 1
\&    use POSIX "setsid";
\&
\&    sub daemonize {
\&        chdir("/")                      || die "can\*(Aqt chdir to /: $!";
\&        open(STDIN,  "< /dev/null")     || die "can\*(Aqt read /dev/null: $!";
\&        open(STDOUT, "> /dev/null")     || die "can\*(Aqt write to /dev/null: $!";
\&        defined(my $pid = fork())       || die "can\*(Aqt fork: $!";
\&        exit if $pid;                   # non\-zero now means I am the parent
\&        (setsid() != \-1)                || die "Can\*(Aqt start a new session: $!";
\&        open(STDERR, ">&STDOUT")        || die "can\*(Aqt dup stdout: $!";
\&    }
.Ve
.PP
The \fIfork()\fR has to come before the \fIsetsid()\fR to ensure you aren't a
process group leader; the \fIsetsid()\fR will fail if you are.  If your
system doesn't have the \fIsetsid()\fR function, open \fI/dev/tty\fR and use the
\&\f(CW\*(C`TIOCNOTTY\*(C'\fR \fIioctl()\fR on it instead.  See \fItty\fR\|(4) for details.
.PP
Non-Unix users should check their \f(CW\*(C`\f(CIYour_OS\f(CW::Process\*(C'\fR module for 
other possible solutions.
.SS "Safe Pipe Opens"
.IX Subsection "Safe Pipe Opens"
Another interesting approach to \s-1IPC\s0 is making your single program go
multiprocess and communicate between\*(--or even amongst\*(--yourselves.  The
\&\fIopen()\fR function will accept a file argument of either \f(CW"\-|"\fR or \f(CW"|\-"\fR
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed \s-1UID\s0 or \s-1GID,\s0 for example.  If you open a pipe \fIto\fR minus, you can
write to the filehandle you opened and your kid will find it in \fIhis\fR
\&\s-1STDIN. \s0 If you open a pipe \fIfrom\fR minus, you can read from the filehandle
you opened whatever your kid writes to \fIhis\fR \s-1STDOUT.\s0
.PP
.Vb 4
\&    use English qw[ \-no_match_vars ];
\&    my $PRECIOUS = "/path/to/some/safe/file";
\&    my $sleep_count;
\&    my $pid;
\&
\&    do {
\&        $pid = open(KID_TO_WRITE, "|\-");
\&        unless (defined $pid) {
\&            warn "cannot fork: $!";
\&            die "bailing out" if $sleep_count++ > 6;
\&            sleep 10;
\&        }
\&    } until defined $pid;
\&
\&    if ($pid) {                 # I am the parent 
\&        print KID_TO_WRITE @some_data;
\&        close(KID_TO_WRITE)     || warn "kid exited $?";
\&    } else {                    # I am the child
\&        # drop permissions in setuid and/or setgid programs:
\&        ($EUID, $EGID) = ($UID, $GID);  
\&        open (OUTFILE, "> $PRECIOUS") 
\&                                || die "can\*(Aqt open $PRECIOUS: $!";
\&        while (<STDIN>) {
\&            print OUTFILE;      # child\*(Aqs STDIN is parent\*(Aqs KID_TO_WRITE
\&        }
\&        close(OUTFILE)          || die "can\*(Aqt close $PRECIOUS: $!";
\&        exit(0);                # don\*(Aqt forget this!!
\&    }
.Ve
.PP
Another common use for this construct is when you need to execute
something without the shell's interference.  With \fIsystem()\fR, it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call \fIexec()\fR directly.
.PP
Here's a safe backtick or pipe open for read:
.PP
.Vb 2
\&    my $pid = open(KID_TO_READ, "\-|");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    if ($pid) {             # parent
\&        while (<KID_TO_READ>) {
\&                            # do something interesting
\&        }
\&        close(KID_TO_READ)  || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID); # suid only
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
And here's a safe pipe open for writing:
.PP
.Vb 2
\&    my $pid = open(KID_TO_WRITE, "|\-");
\&    defined($pid)           || die "can\*(Aqt fork: $!";
\&
\&    $SIG{PIPE} = sub { die "whoops, $program pipe broke" };
\&
\&    if ($pid) {             # parent
\&        print KID_TO_WRITE @data;
\&        close(KID_TO_WRITE) || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID);
\&        exec($program, @options, @args)
\&                            || die "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
It is very easy to dead-lock a process using this form of \fIopen()\fR, or
indeed with any use of \fIpipe()\fR with multiple subprocesses.  The 
example above is \*(L"safe\*(R" because it is simple and calls \fIexec()\fR.  See
\&\*(L"Avoiding Pipe Deadlocks\*(R" for general safety principles, but there
are extra gotchas with Safe Pipe Opens.
.PP
In particular, if you opened the pipe using \f(CW\*(C`open FH, "|\-"\*(C'\fR, then you
cannot simply use \fIclose()\fR in the parent process to close an unwanted
writer.  Consider this code:
.PP
.Vb 10
\&    my $pid = open(WRITER, "|\-");        # fork open a kid
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "second fork failed: $!";
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            # now do something else...
\&        }
\&        else {
\&            # first write to WRITER
\&            # ...
\&            # then when finished
\&            close(WRITER)       || die "couldn\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&    }
\&    else {
\&        # first do something with STDIN, then
\&        exit(0);
\&    }
.Ve
.PP
In the example above, the true parent does not want to write to the \s-1WRITER\s0
filehandle, so it closes it.  However, because \s-1WRITER\s0 was opened using
\&\f(CW\*(C`open FH, "|\-"\*(C'\fR, it has a special behavior: closing it calls
\&\fIwaitpid()\fR (see \*(L"waitpid\*(R" in perlfunc), which waits for the subprocess
to exit.  If the child process ends up waiting for something happening
in the section marked \*(L"do something else\*(R", you have deadlock.
.PP
This can also be a problem with intermediate subprocesses in more
complicated code, which will call \fIwaitpid()\fR on all open filehandles
during global destruction\*(--in no predictable order.
.PP
To solve this, you must manually use \fIpipe()\fR, \fIfork()\fR, and the form of
\&\fIopen()\fR which sets one file descriptor to another, as shown below:
.PP
.Vb 10
\&    pipe(READER, WRITER)        || die "pipe failed: $!";
\&    $pid = fork();
\&    defined($pid)               || die "first fork failed: $!";
\&    if ($pid) {
\&        close READER;
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || die "first fork failed: $!";
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&        }
\&        else {
\&            # write to WRITER...
\&            # ...
\&            # then  when finished
\&            close(WRITER)       || die "can\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&        # write to WRITER...
\&    }
\&    else {
\&        open(STDIN, "<&READER") || die "can\*(Aqt reopen STDIN: $!";
\&        close(WRITER)           || die "can\*(Aqt close WRITER: $!";
\&        # do something...
\&        exit(0);
\&    }
.Ve
.PP
Since Perl 5.8.0, you can also use the list form of \f(CW\*(C`open\*(C'\fR for pipes.
This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.
.PP
So for example, instead of using:
.PP
.Vb 1
\&    open(PS_PIPE, "ps aux|")    || die "can\*(Aqt open ps pipe: $!";
.Ve
.PP
One would use either of these:
.PP
.Vb 2
\&    open(PS_PIPE, "\-|", "ps", "aux") 
\&                                || die "can\*(Aqt open ps pipe: $!";
\&
\&    @ps_args = qw[ ps aux ];
\&    open(PS_PIPE, "\-|", @ps_args)
\&                                || die "can\*(Aqt open @ps_args|: $!";
.Ve
.PP
Because there are more than three arguments to \fIopen()\fR, forks the \fIps\fR\|(1)
command \fIwithout\fR spawning a shell, and reads its standard output via the
\&\f(CW\*(C`PS_PIPE\*(C'\fR filehandle.  The corresponding syntax to \fIwrite\fR to command
pipes is to use \f(CW"|\-"\fR in place of \f(CW"\-|"\fR.
.PP
This was admittedly a rather silly example, because you're using string
literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe \fIopen()\fR.  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of \fIopen()\fR should be used.  For example:
.PP
.Vb 3
\&    @grep_args = ("egrep", "\-i", $some_pattern, @many_files);
\&    open(GREP_PIPE, "\-|", @grep_args)
\&                        || die "can\*(Aqt open @grep_args|: $!";
.Ve
.PP
Here the multi-argument form of pipe \fIopen()\fR is preferred because the
pattern and indeed even the filenames themselves might hold metacharacters.
.PP
Be aware that these operations are full Unix forks, which means they may
not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the \fImodules\fR
file mentioned below in the \s-1SEE ALSO\s0 section.
.SS "Avoiding Pipe Deadlocks"
.IX Subsection "Avoiding Pipe Deadlocks"
Whenever you have more than one subprocess, you must be careful that each
closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an \s-1EOF\s0 will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read \s-1EOF.\s0
.PP
Certain built-in Unix features help prevent this most of the time.  For
instance, filehandles have a \*(L"close on exec\*(R" flag, which is set \fIen masse\fR
under control of the \f(CW$^F\fR variable.  This is so any filehandles you
didn't explicitly route to the \s-1STDIN, STDOUT\s0 or \s-1STDERR\s0 of a child
\&\fIprogram\fR will be automatically closed.
.PP
Always explicitly and immediately call \fIclose()\fR on the writable end of any
pipe, unless that process is actually writing to it.  Even if you don't
explicitly call \fIclose()\fR, Perl will still \fIclose()\fR all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling \fIwaitpid()\fR,
which may again deadlock.
.SS "Bidirectional Communication with Another Process"
.IX Subsection "Bidirectional Communication with Another Process"
While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The most obvious approach doesn't work:
.PP
.Vb 2
\&    # THIS DOES NOT WORK!!
\&    open(PROG_FOR_READING_AND_WRITING, "| some program |")
.Ve
.PP
If you forget to \f(CW\*(C`use warnings\*(C'\fR, you'll miss out entirely on the
helpful diagnostic message:
.PP
.Vb 1
\&    Can\*(Aqt do bidirectional pipe at \-e line 1.
.Ve
.PP
If you really want to, you can use the standard \fIopen2()\fR from the
\&\f(CW\*(C`IPC::Open2\*(C'\fR module to catch both ends.  There's also an \fIopen3()\fR in
\&\f(CW\*(C`IPC::Open3\*(C'\fR for tridirectional I/O so you can also catch your child's
\&\s-1STDERR,\s0 but doing so would then require an awkward \fIselect()\fR loop and
wouldn't allow you to use normal Perl input operations.
.PP
If you look at its source, you'll see that \fIopen2()\fR uses low-level
primitives like the \fIpipe()\fR and \fIexec()\fR syscalls to create all the
connections.  Although it might have been more efficient by using
\&\fIsocketpair()\fR, this would have been even less portable than it already
is. The \fIopen2()\fR and \fIopen3()\fR functions are unlikely to work anywhere
except on a Unix system, or at least one purporting \s-1POSIX\s0 compliance.
.PP
Here's an example of using \fIopen2()\fR:
.PP
.Vb 5
\&    use FileHandle;
\&    use IPC::Open2;
\&    $pid = open2(*Reader, *Writer, "cat \-un");
\&    print Writer "stuff\en";
\&    $got = <Reader>;
.Ve
.PP
The problem with this is that buffering is really going to ruin your
day.  Even though your \f(CW\*(C`Writer\*(C'\fR filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
\&\fIcat\fR a \fB\-u\fR flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.
.PP
A solution to this is to use a library which uses pseudottys to make your
program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The \f(CW\*(C`Expect\*(C'\fR module
from \s-1CPAN\s0 also addresses this kind of thing.  This module requires two
other modules from \s-1CPAN, \s0\f(CW\*(C`IO::Pty\*(C'\fR and \f(CW\*(C`IO::Stty\*(C'\fR.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.
.SS "Bidirectional Communication with Yourself"
.IX Subsection "Bidirectional Communication with Yourself"
If you want, you may make low-level \fIpipe()\fR and \fIfork()\fR syscalls to stitch
this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to \s-1STDIN\s0 and \s-1STDOUT\s0 and call other processes.
(The following example lacks proper error checking.)
.PP
.Vb 8
\&    #!/usr/bin/perl \-w
\&    # pipe1 \- bidirectional communication using two pipe pairs
\&    #         designed for the socketpair\-challenged
\&    use IO::Handle;               # thousands of lines just for autoflush :\-(
\&    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
\&    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
\&    CHILD_WTR\->autoflush(1);
\&    PARENT_WTR\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        print CHILD_WTR "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD_RDR>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD_RDR; close CHILD_WTR;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD_RDR; 
\&        close CHILD_WTR;
\&        chomp($line = <PARENT_RDR>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT_WTR "Child Pid $$ is sending this\en";
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        exit(0);
\&    }
.Ve
.PP
But you don't actually have to make two pipe calls.  If you
have the \fIsocketpair()\fR system call, it will do this all for you.
.PP
.Vb 3
\&    #!/usr/bin/perl \-w
\&    # pipe2 \- bidirectional communication using socketpair
\&    #   "the best ones always go both ways"
\&
\&    use Socket;
\&    use IO::Handle;  # thousands of lines just for autoflush :\-(
\&
\&    # We say AF_UNIX because although *_LOCAL is the
\&    # POSIX 1003.1g form of the constant, many machines
\&    # still don\*(Aqt have it.
\&    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
\&                                ||  die "socketpair: $!";
\&
\&    CHILD\->autoflush(1);
\&    PARENT\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT;
\&        print CHILD "Parent Pid $$ is sending this\en";
\&        chomp($line = <CHILD>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD;
\&        waitpid($pid, 0);
\&    } else {
\&        die "cannot fork: $!" unless defined $pid;
\&        close CHILD;
\&        chomp($line = <PARENT>);
\&        print "Child Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT "Child Pid $$ is sending this\en";
\&        close PARENT;
\&        exit(0);
\&    }
.Ve
.SH "Sockets: Client/Server Communication"
.IX Header "Sockets: Client/Server Communication"
While not entirely limited to Unix-derived operating systems (e.g., WinSock
on PCs provides socket support, as do some \s-1VMS\s0 libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like \s-1TCP\s0
streams and datagrams like \s-1UDP\s0 packets.  You may be able to do even more
depending on your system.
.PP
The Perl functions for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons.  First, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.
.PP
One of the major problems with ancient, antemillennial socket code in Perl
was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting \f(CW\*(C`$AF_INET = 2\*(C'\fR, you know you're in for big trouble.  
An immeasurably superior approach is to use the \f(CW\*(C`Socket\*(C'\fR module, which more
reliably grants access to the various constants and functions you'll need.
.PP
If you're not writing a server/client for an existing protocol like
\&\s-1NNTP\s0 or \s-1SMTP,\s0 you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a \*(L"\en\*(R" is received) or multi-line
messages and responses that end with a period on an empty line
(\*(L"\en.\en\*(R" terminates a message/response).
.SS "Internet Line Terminators"
.IX Subsection "Internet Line Terminators"
The Internet line terminator is \*(L"\e015\e012\*(R".  Under \s-1ASCII\s0 variants of
Unix, that could usually be written as \*(L"\er\en\*(R", but under other systems,
\&\*(L"\er\en\*(R" might at times be \*(L"\e015\e015\e012\*(R", \*(L"\e012\e012\e015\*(R", or something
completely different.  The standards specify writing \*(L"\e015\e012\*(R" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone \*(L"\e012\*(R" on input (be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll 
probably be ok.
.SS "Internet \s-1TCP\s0 Clients and Servers"
.IX Subsection "Internet TCP Clients and Servers"
Use Internet-domain sockets when you want to do client-server
communication that might extend to machines outside of your own system.
.PP
Here's a sample \s-1TCP\s0 client using Internet-domain sockets:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    my ($remote, $port, $iaddr, $paddr, $proto, $line);
\&
\&    $remote  = shift || "localhost";
\&    $port    = shift || 2345;  # random port
\&    if ($port =~ /\eD/) { $port = getservbyname($port, "tcp") }
\&    die "No port" unless $port;
\&    $iaddr   = inet_aton($remote)       || die "no host: $remote";
\&    $paddr   = sockaddr_in($port, $iaddr);
\&
\&    $proto   = getprotobyname("tcp");
\&    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
\&    connect(SOCK, $paddr)               || die "connect: $!";
\&    while ($line = <SOCK>) {
\&        print $line;
\&    }
\&
\&    close (SOCK)                        || die "close: $!";
\&    exit(0);
.Ve
.PP
And here's a corresponding server to go along with it.  We'll
leave the address as \f(CW\*(C`INADDR_ANY\*(C'\fR so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), fill this in with your real address instead.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $paddr;
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    for ( ; $paddr = accept(Client, Server); close Client) {
\&        my($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&                inet_ntoa($iaddr), "]
\&                at port $port";
\&
\&        print Client "Hello there, $name, it\*(Aqs now ",
\&                        scalar localtime(), $EOL;
\&    }
.Ve
.PP
And here's a multithreaded version.  It's multithreaded in that
like most typical servers, it spawns (\fIfork()\fRs) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    my $EOL = "\e015\e012";
\&
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $port  = shift || 2345;
\&    die "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || die "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
\&                                                    || die "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || die "bind: $!";
\&    listen(Server, SOMAXCONN)                       || die "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    my $waitedpid = 0;
\&    my $paddr;
\&
\&    use POSIX ":sys_wait_h";
\&    use Errno;
\&
\&    sub REAPER {
\&        local $!;   # don\*(Aqt let waitpid() overwrite current error
\&        while ((my $pid = waitpid(\-1, WNOHANG)) > 0 && WIFEXITED($?)) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    while (1) {
\&        $paddr = accept(Client, Server) || do {
\&            # try again if accept() returned because got a signal
\&            next if $!{EINTR};
\&            die "accept: $!";
\&        };
\&        my ($port, $iaddr) = sockaddr_in($paddr);
\&        my $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&               inet_ntoa($iaddr),
\&               "] at port $port";
\&
\&        spawn sub {
\&            $| = 1;
\&            print "Hello there, $name, it\*(Aqs now ", scalar localtime(), $EOL;
\&            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
\&                or confess "can\*(Aqt exec fortune: $!";
\&        };
\&        close Client;
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift;
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        }
\&        # else I\*(Aqm the child \-\- go spawn
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
This server takes the trouble to clone off a child version via \fIfork()\fR
for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't \fIfork()\fR, the
\&\fIlisten()\fR will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called \*(L"zombies\*(R" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The \s-1REAPER\s0 subroutine is used here to
call \fIwaitpid()\fR for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.
.PP
Within the while loop we call \fIaccept()\fR and check to see if it returns
a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
\&\*(L"Deferred Signals (Safe Signals)\*(R" above) in Perl 5.8.0 means that
\&\fIaccept()\fR might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
notifies the parent process with a \s-1CHLD\s0 signal.
.PP
If \fIaccept()\fR is interrupted by a signal, $! will be set to \s-1EINTR.\s0
If this happens, we can safely continue to the next iteration of
the loop and another call to \fIaccept()\fR.  It is important that your
signal handling code not modify the value of $!, or else this test 
will likely fail.  In the \s-1REAPER\s0 subroutine we create a local version
of $! before calling \fIwaitpid()\fR.  When \fIwaitpid()\fR sets $! to \s-1ECHILD\s0 as
it inevitably does when it has no more children waiting, it 
updates the local copy and leaves the original unchanged.
.PP
You should use the \fB\-T\fR flag to enable taint checking (see perlsec)
even if we aren't running setuid or setgid.  This is always a good idea
for servers or any program run on behalf of someone else (like \s-1CGI\s0
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.
.PP
Let's look at another \s-1TCP\s0 client.  This one connects to the \s-1TCP \s0\*(L"time\*(R"
service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:
.PP
.Vb 3
\&    #!/usr/bin/perl  \-w
\&    use strict;
\&    use Socket;
\&
\&    my $SECS_OF_70_YEARS = 2208988800;
\&    sub ctime { scalar localtime(shift() || time()) }
\&
\&    my $iaddr = gethostbyname("localhost");
\&    my $proto = getprotobyname("tcp");
\&    my $port = getservbyname("time", "tcp");
\&    my $paddr = sockaddr_in(0, $iaddr);
\&    my($host);
\&
\&    $| = 1;
\&    printf "%\-24s %8s %s\en", "localhost", 0, ctime();
\&
\&    foreach $host (@ARGV) {
\&        printf "%\-24s ", $host;
\&        my $hisiaddr = inet_aton($host)     || die "unknown host";
\&        my $hispaddr = sockaddr_in($port, $hisiaddr);
\&        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
\&                                            || die "socket: $!";
\&        connect(SOCKET, $hispaddr)          || die "connect: $!";
\&        my $rtime = pack("C4", ());
\&        read(SOCKET, $rtime, 4);
\&        close(SOCKET);
\&        my $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%8d %s\en", $histime \- time(), ctime($histime);
\&    }
.Ve
.SS "Unix-Domain \s-1TCP\s0 Clients and Servers"
.IX Subsection "Unix-Domain TCP Clients and Servers"
That's fine for Internet-domain clients and servers, but what about local
communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an \fIls\fR\|(1) listing.
.PP
.Vb 2
\&    % ls \-l /dev/log
\&    srw\-rw\-rw\-  1 root            0 Oct 31 07:23 /dev/log
.Ve
.PP
You can test for these with Perl's \fB\-S\fR file test:
.PP
.Vb 3
\&    unless (\-S "/dev/log") {
\&        die "something\*(Aqs wicked with the log system";
\&    }
.Ve
.PP
Here's a sample Unix-domain client:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use Socket;
\&    use strict;
\&    my ($rendezvous, $line);
\&
\&    $rendezvous = shift || "catsock";
\&    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die "socket: $!";
\&    connect(SOCK, sockaddr_un($rendezvous))   || die "connect: $!";
\&    while (defined($line = <SOCK>)) {
\&        print $line;
\&    }
\&    exit(0);
.Ve
.PP
And here's a corresponding server.  You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use Socket;
\&    use Carp;
\&
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    my $NAME = "catsock";
\&    my $uaddr = sockaddr_un($NAME);
\&    my $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die "socket: $!";
\&    unlink($NAME);
\&    bind  (Server, $uaddr)                  || die "bind: $!";
\&    listen(Server, SOMAXCONN)               || die "listen: $!";
\&
\&    logmsg "server started on $NAME";
\&
\&    my $waitedpid;
\&
\&    use POSIX ":sys_wait_h";
\&    sub REAPER {
\&        my $child;
\&        while (($waitedpid = waitpid(\-1, WNOHANG)) > 0) {
\&            logmsg "reaped $waitedpid" . ($? ? " with exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&
\&    for ( $waitedpid = 0;
\&          accept(Client, Server) || $waitedpid;
\&          $waitedpid = 0, close Client)
\&    {
\&        next if $waitedpid;
\&        logmsg "connection on $NAME";
\&        spawn sub {
\&            print "Hello there, it\*(Aqs now ", scalar localtime(), "\en";
\&            exec("/usr/games/fortune")  || die "can\*(Aqt exec fortune: $!";
\&        };
\&    }
\&
\&    sub spawn {
\&        my $coderef = shift();
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        my $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm the parent
\&        } 
\&        else {
\&            # I\*(Aqm the child \-\- go spawn
\&        }
\&
\&        open(STDIN,  "<&Client")    || die "can\*(Aqt dup client to stdin";
\&        open(STDOUT, ">&Client")    || die "can\*(Aqt dup client to stdout";
\&        ## open(STDERR, ">&STDOUT") || die "can\*(Aqt dup stdout to stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
As you see, it's remarkably similar to the Internet domain \s-1TCP\s0 server, so
much so, in fact, that we've omitted several duplicate functions\*(--\fIspawn()\fR,
\&\fIlogmsg()\fR, \fIctime()\fR, and \s-1\fIREAPER\s0()\fR\-\-which are the same as in the other server.
.PP
So why would you ever want to use a Unix domain socket instead of a
simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client; that's why \fIaccept()\fR takes two
arguments.
.PP
For example, let's say that you have a long-running database server daemon
that you want folks to be able to access from the Web, but only
if they go through a \s-1CGI\s0 interface.  You'd have a small, simple \s-1CGI\s0
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.
.SH "TCP Clients with IO::Socket"
.IX Header "TCP Clients with IO::Socket"
For those preferring a higher-level interface to socket programming, the
IO::Socket module provides an object-oriented approach.  If for some reason
you lack this module, you can just fetch IO::Socket from \s-1CPAN,\s0 where you'll also
find modules providing easy interfaces to the following systems: \s-1DNS, FTP,\s0
Ident (\s-1RFC 931\s0), \s-1NIS\s0 and NISPlus, \s-1NNTP,\s0 Ping, \s-1POP3, SMTP, SNMP,\s0 SSLeay,
Telnet, and Time\*(--to name just a few.
.SS "A Simple Client"
.IX Subsection "A Simple Client"
Here's a client that creates a \s-1TCP\s0 connection to the \*(L"daytime\*(R"
service at port 13 of the host name \*(L"localhost\*(R" and prints out everything
that the server there cares to provide.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    $remote = IO::Socket::INET\->new(
\&                        Proto    => "tcp",
\&                        PeerAddr => "localhost",
\&                        PeerPort => "daytime(13)",
\&                    )
\&                  || die "can\*(Aqt connect to daytime service on localhost";
\&    while (<$remote>) { print }
.Ve
.PP
When you run this program, you should get something back that
looks like this:
.PP
.Vb 1
\&    Wed May 14 08:40:46 MDT 1997
.Ve
.PP
Here are what those parameters to the \fInew()\fR constructor mean:
.ie n .IP """Proto""" 4
.el .IP "\f(CWProto\fR" 4
.IX Item "Proto"
This is which protocol to use.  In this case, the socket handle returned
will be connected to a \s-1TCP\s0 socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the \s-1UDP\s0 protocol
can be used to make a datagram socket, used for message-passing.
.ie n .IP """PeerAddr""" 4
.el .IP "\f(CWPeerAddr\fR" 4
.IX Item "PeerAddr"
This is the name or Internet address of the remote host the server is
running on.  We could have specified a longer name like \f(CW"www.perl.com"\fR,
or an address like \f(CW"207.171.7.72"\fR.  For demonstration purposes, we've
used the special hostname \f(CW"localhost"\fR, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is \f(CW"127.0.0.1"\fR, if you'd rather use that.
.ie n .IP """PeerPort""" 4
.el .IP "\f(CWPeerPort\fR" 4
.IX Item "PeerPort"
This is the service name or port number we'd like to connect to.
We could have gotten away with using just \f(CW"daytime"\fR on systems with a
well-configured system services file,[\s-1FOOTNOTE:\s0 The system services file
is found in \fI/etc/services\fR under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.
.PP
Notice how the return value from the \f(CW\*(C`new\*(C'\fR constructor is used as
a filehandle in the \f(CW\*(C`while\*(C'\fR loop?  That's what's called an \fIindirect
filehandle\fR, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:
.PP
.Vb 1
\&    $line = <$handle>;
.Ve
.PP
all remaining lines from is this way:
.PP
.Vb 1
\&    @lines = <$handle>;
.Ve
.PP
and send a line of data to it this way:
.PP
.Vb 1
\&    print $handle "some data\en";
.Ve
.SS "A Webget Client"
.IX Subsection "A Webget Client"
Here's a simple client that takes a remote host to fetch a document
from, and then a list of files to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.
.PP
.Vb 10
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    unless (@ARGV > 1) { die "usage: $0 host url ..." }
\&    $host = shift(@ARGV);
\&    $EOL = "\e015\e012";
\&    $BLANK = $EOL x 2;
\&    for my $document (@ARGV) {
\&        $remote = IO::Socket::INET\->new( Proto     => "tcp",
\&                                         PeerAddr  => $host,
\&                                         PeerPort  => "http(80)",
\&                  )     || die "cannot connect to httpd on $host";
\&        $remote\->autoflush(1);
\&        print $remote "GET $document HTTP/1.0" . $BLANK;
\&        while ( <$remote> ) { print }
\&        close $remote;
\&    }
.Ve
.PP
The web server handling the \s-1HTTP\s0 service is assumed to be at
its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
as the named-parameter pair, \f(CW\*(C`PeerPort => 8080\*(C'\fR.  The \f(CW\*(C`autoflush\*(C'\fR
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every \f(CW"\en"\fR in your code that sends data over the network
to be a \f(CW"\e015\e012"\fR instead.)
.PP
Connecting to the server is only the first part of the process: once you
have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with \*(L"\s-1GET\*(R"\s0 is in
\&\s-1HTTP\s0 syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak \s-1HTTP.\s0
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.
.PP
Here's an example of running that program, which we'll call \fIwebget\fR:
.PP
.Vb 6
\&    % webget www.perl.com /guanaco.html
\&    HTTP/1.1 404 File Not Found
\&    Date: Thu, 08 May 1997 18:02:32 GMT
\&    Server: Apache/1.2b6
\&    Connection: close
\&    Content\-type: text/html
\&
\&    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
\&    <BODY><H1>File Not Found</H1>
\&    The requested URL /guanaco.html was not found on this server.<P>
\&    </BODY>
.Ve
.PP
Ok, so that's not very interesting, because it didn't find that
particular document.  But a long response wouldn't have fit on this page.
.PP
For a more featureful version of this program, you should look to
the \fIlwp-request\fR program included with the \s-1LWP\s0 modules from \s-1CPAN.\s0
.SS "Interactive Client with IO::Socket"
.IX Subsection "Interactive Client with IO::Socket"
Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like
the way \fItelnet\fR works?  That way you can type a line, get the answer,
type a line, get the answer, etc.
.PP
This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful \f(CW\*(C`fork\*(C'\fR call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call \f(CW\*(C`fork\*(C'\fR to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be \fImuch\fR
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)
.PP
Here's the code:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use IO::Socket;
\&    my ($host, $port, $kidpid, $handle, $line);
\&
\&    unless (@ARGV == 2) { die "usage: $0 host port" }
\&    ($host, $port) = @ARGV;
\&
\&    # create a tcp connection to the specified host and port
\&    $handle = IO::Socket::INET\->new(Proto     => "tcp",
\&                                    PeerAddr  => $host,
\&                                    PeerPort  => $port)
\&               || die "can\*(Aqt connect to port $port on $host: $!";
\&
\&    $handle\->autoflush(1);       # so output gets there right away
\&    print STDERR "[Connected to $host:$port]\en";
\&
\&    # split the program into two processes, identical twins
\&    die "can\*(Aqt fork: $!" unless defined($kidpid = fork());
\&
\&    # the if{} block runs only in the parent process
\&    if ($kidpid) {
\&        # copy the socket to standard output
\&        while (defined ($line = <$handle>)) {
\&            print STDOUT $line;
\&        }
\&        kill("TERM", $kidpid);   # send SIGTERM to child
\&    }
\&    # the else{} block runs only in the child process
\&    else {
\&        # copy standard input to the socket
\&        while (defined ($line = <STDIN>)) {
\&            print $handle $line;
\&        }
\&        exit(0);                # just in case
\&    }
.Ve
.PP
The \f(CW\*(C`kill\*(C'\fR function in the parent's \f(CW\*(C`if\*(C'\fR block is there to send a
signal to our child process, currently running in the \f(CW\*(C`else\*(C'\fR block,
as soon as the remote server has closed its end of the connection.
.PP
If the remote server sends data a byte at time, and you need that
data immediately without waiting for a newline (which might not happen),
you may wish to replace the \f(CW\*(C`while\*(C'\fR loop in the parent with the
following:
.PP
.Vb 4
\&    my $byte;
\&    while (sysread($handle, $byte, 1) == 1) {
\&        print STDOUT $byte;
\&    }
.Ve
.PP
Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.
.SH "TCP Servers with IO::Socket"
.IX Header "TCP Servers with IO::Socket"
As always, setting up a server is little bit more involved than running a client.
The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the \f(CW\*(C`IO::Socket::INET\->new()\*(C'\fR method with
slightly different arguments than the client did.
.IP "Proto" 4
.IX Item "Proto"
This is which protocol to use.  Like our clients, we'll
still specify \f(CW"tcp"\fR here.
.IP "LocalPort" 4
.IX Item "LocalPort"
We specify a local
port in the \f(CW\*(C`LocalPort\*(C'\fR argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an \*(L"Address already in use\*(R"
message.  Under Unix, the \f(CW\*(C`netstat \-a\*(C'\fR command will show
which services current have servers.
.IP "Listen" 4
.IX Item "Listen"
The \f(CW\*(C`Listen\*(C'\fR parameter is set to the maximum number of
pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is \s-1SOMAXCONN.\s0
.IP "Reuse" 4
.IX Item "Reuse"
The \f(CW\*(C`Reuse\*(C'\fR parameter is needed so that we restart our server
manually without waiting a few minutes to allow system buffers to
clear out.
.PP
Once the generic server socket has been created using the parameters
listed above, the server then waits for a new client to connect
to it.  The server blocks in the \f(CW\*(C`accept\*(C'\fR method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)
.PP
To add to user-friendliness, our server prompts the user for commands.
Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the \f(CW\*(C`sysread\*(C'\fR variant of the interactive client above.
.PP
This server accepts one of five different commands, sending output back to
the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multithreaded servers are covered in 
Chapter 16 of the Camel.
.PP
Here's the code.  We'll
.PP
.Vb 3
\& #!/usr/bin/perl \-w
\& use IO::Socket;
\& use Net::hostent;      # for OOish version of gethostbyaddr
\&
\& $PORT = 9000;          # pick something not in use
\&
\& $server = IO::Socket::INET\->new( Proto     => "tcp",
\&                                  LocalPort => $PORT,
\&                                  Listen    => SOMAXCONN,
\&                                  Reuse     => 1);
\&
\& die "can\*(Aqt setup server" unless $server;
\& print "[Server $0 accepting clients]\en";
\&
\& while ($client = $server\->accept()) {
\&   $client\->autoflush(1);
\&   print $client "Welcome to $0; type help for command list.\en";
\&   $hostinfo = gethostbyaddr($client\->peeraddr);
\&   printf "[Connect from %s]\en", $hostinfo ? $hostinfo\->name : $client\->peerhost;
\&   print $client "Command? ";
\&   while ( <$client>) {
\&     next unless /\eS/;       # blank line
\&     if    (/quit|exit/i)    { last                                      }
\&     elsif (/date|time/i)    { printf $client "%s\en", scalar localtime() }
\&     elsif (/who/i )         { print  $client \`who 2>&1\`                 }
\&     elsif (/cookie/i )      { print  $client \`/usr/games/fortune 2>&1\`  }
\&     elsif (/motd/i )        { print  $client \`cat /etc/motd 2>&1\`       }
\&     else {
\&       print $client "Commands: quit date who cookie motd\en";
\&     }
\&   } continue {
\&      print $client "Command? ";
\&   }
\&   close $client;
\& }
.Ve
.SH "UDP: Message Passing"
.IX Header "UDP: Message Passing"
Another kind of client-server setup is one that uses not connections, but
messages.  \s-1UDP\s0 communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, \s-1UDP\s0 offers some advantages
over \s-1TCP,\s0 including being able to \*(L"broadcast\*(R" or \*(L"multicast\*(R" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just \s-1TCP\s0 to start
with.
.PP
\&\s-1UDP\s0 datagrams are \fInot\fR a bytestream and should not be treated as such.
This makes using I/O mechanisms with internal buffering like stdio (i.e.
\&\fIprint()\fR and friends) especially cumbersome. Use \fIsyswrite()\fR, or better
\&\fIsend()\fR, like in the example below.
.PP
Here's a \s-1UDP\s0 program similar to the sample Internet \s-1TCP\s0 client given
earlier.  However, instead of checking one host at a time, the \s-1UDP\s0 version
will check many of them asynchronously by simulating a multicast and then
using \fIselect()\fR to do a timed-out wait for I/O.  To do something similar
with \s-1TCP,\s0 you'd have to use a different socket handle for each host.
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    use Sys::Hostname;
\&
\&    my ( $count, $hisiaddr, $hispaddr, $histime,
\&         $host, $iaddr, $paddr, $port, $proto,
\&         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
\&
\&    $SECS_OF_70_YEARS = 2_208_988_800;
\&
\&    $iaddr = gethostbyname(hostname());
\&    $proto = getprotobyname("udp");
\&    $port = getservbyname("time", "udp");
\&    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
\&
\&    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die "socket: $!";
\&    bind(SOCKET, $paddr)                          || die "bind: $!";
\&
\&    $| = 1;
\&    printf "%\-12s %8s %s\en",  "localhost", 0, scalar localtime();
\&    $count = 0;
\&    for $host (@ARGV) {
\&        $count++;
\&        $hisiaddr = inet_aton($host)              || die "unknown host";
\&        $hispaddr = sockaddr_in($port, $hisiaddr);
\&        defined(send(SOCKET, 0, 0, $hispaddr))    || die "send $host: $!";
\&    }
\&
\&    $rin = "";
\&    vec($rin, fileno(SOCKET), 1) = 1;
\&
\&    # timeout after 10.0 seconds
\&    while ($count && select($rout = $rin, undef, undef, 10.0)) {
\&        $rtime = "";
\&        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die "recv: $!";
\&        ($port, $hisiaddr) = sockaddr_in($hispaddr);
\&        $host = gethostbyaddr($hisiaddr, AF_INET);
\&        $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%\-12s ", $host;
\&        printf "%8d %s\en", $histime \- time(), scalar localtime($histime);
\&        $count\-\-;
\&    }
.Ve
.PP
This example does not include any retries and may consequently fail to
contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.
.SH "SysV IPC"
.IX Header "SysV IPC"
While System V \s-1IPC\s0 isn't so widely used as sockets, it still has some
interesting uses.  However, you cannot use SysV \s-1IPC\s0 or Berkeley \fImmap()\fR to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the \f(CW\*(C`IPC::Shareable\*(C'\fR or \f(CW\*(C`threads::shared\*(C'\fR modules for that.
.PP
Here's a small example showing shared memory usage.
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
\&
\&    $size = 2000;
\&    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
\&    defined($id)                    || die "shmget: $!";
\&    print "shm key $id\en";
\&
\&    $message = "Message #1";
\&    shmwrite($id, $message, 0, 60)  || die "shmwrite: $!";
\&    print "wrote: \*(Aq$message\*(Aq\en";
\&    shmread($id, $buff, 0, 60)      || die "shmread: $!";
\&    print "read : \*(Aq$buff\*(Aq\en";
\&
\&    # the buffer of shmread is zero\-character end\-padded.
\&    substr($buff, index($buff, "\e0")) = "";
\&    print "un" unless $buff eq $message;
\&    print "swell\en";
\&
\&    print "deleting shm $id\en";
\&    shmctl($id, IPC_RMID, 0)        || die "shmctl: $!";
.Ve
.PP
Here's an example of a semaphore:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_CREAT);
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
\&    defined($id)                    || die "semget: $!";
\&    print "sem id $id\en";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call the file \fItake\fR:
.PP
.Vb 1
\&    # create a semaphore
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    defined($id)                    || die "semget: $!";
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # "take" semaphore
\&    # wait for semaphore to be zero
\&    $semop = 0;
\&    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    # Increment the semaphore count
\&    $semop = 1;
\&    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
\&    $opstring  = $opstring1 . $opstring2;
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
Put this code in a separate file to be run in more than one process.
Call this file \fIgive\fR:
.PP
.Vb 3
\&    # "give" the semaphore
\&    # run this in the original process and you will see
\&    # that the second process continues
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    die unless defined($id);
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # Decrement the semaphore count
\&    $semop = \-1;
\&    $opstring = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    semop($id, $opstring)   || die "semop: $!";
.Ve
.PP
The SysV \s-1IPC\s0 code above was written long ago, and it's definitely
clunky looking.  For a more modern look, see the IPC::SysV module.
.PP
A small example demonstrating SysV message queues:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
\&
\&    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
\&    defined($id)                || die "msgget failed: $!";
\&
\&    my $sent      = "message";
\&    my $type_sent = 1234;
\&
\&    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
\&                                || die "msgsnd failed: $!";
\&
\&    msgrcv($id, my $rcvd_buf, 60, 0, 0)
\&                                || die "msgrcv failed: $!";
\&
\&    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);
\&
\&    if ($rcvd eq $sent) {
\&        print "okay\en";
\&    } else {
\&        print "not okay\en";
\&    }
\&
\&    msgctl($id, IPC_RMID, 0)    || die "msgctl failed: $!\en";
.Ve
.SH "NOTES"
.IX Header "NOTES"
Most of these routines quietly but politely return \f(CW\*(C`undef\*(C'\fR when they
fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new \fISocket\fR conversion
functions do \fIcroak()\fR on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add the \fB\-T\fR
taint-checking flag to the \f(CW\*(C`#!\*(C'\fR line for servers:
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use sigtrap;
\&    use Socket;
.Ve
.SH "BUGS"
.IX Header "BUGS"
These routines all create system-specific portability problems.  As noted
elsewhere, Perl is at the mercy of your C libraries for much of its system
behavior.  It's probably safest to assume broken SysV semantics for
signals and to stick with simple \s-1TCP\s0 and \s-1UDP\s0 socket operations; e.g., don't
try to pass open file descriptors over a local \s-1UDP\s0 datagram socket if you
want your code to stand a chance of being portable.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen, with occasional vestiges of Larry Wall's original
version and suggestions from the Perl Porters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There's a lot more to networking than this, but this should get you
started.
.PP
For intrepid programmers, the indispensable textbook is \fIUnix Network
Programming, 2nd Edition, Volume 1\fR by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.
.PP
The \fIIO::Socket\fR\|(3) manpage describes the object library, and the \fISocket\fR\|(3)
manpage describes the low-level interface to sockets.  Besides the obvious
functions in perlfunc, you should also check out the \fImodules\fR file at
your nearest \s-1CPAN\s0 site, especially
<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
See perlmodlib or best yet, the \fIPerl \s-1FAQ\s0\fR for a description
of what \s-1CPAN\s0 is and where to get it if the previous link doesn't work 
for you.
.PP
Section 5 of \s-1CPAN\s0's \fImodules\fR file is devoted to \*(L"Networking, Device
Control (modems), and Interprocess Communication\*(R", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
\&\s-1CGI\s0 programming, \s-1DCE, FTP, IPC, NNTP,\s0 Proxy, Ptty, \s-1RPC, SNMP, SMTP,\s0 Telnet,
Threads, and ToolTalk\*(--to name just a few.
                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlirix.1                                   0100644 0001750 0001750 00000021516 12566207441 022602  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIRIX 1"
.TH PERLIRIX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlirix \- Perl version 5 on Irix systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Irix that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Building 32\-bit Perl in Irix"
.IX Subsection "Building 32-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq
.Ve
.PP
to compile Perl 32\-bit.  Don't bother with \-n32 unless you have 7.1
or later compilers (use cc \-version to check).
.PP
(Building 'cc \-n32' is the default.)
.SS "Building 64\-bit Perl in Irix"
.IX Subsection "Building 64-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitint
.Ve
.PP
This requires require a 64\-bit \s-1MIPS CPU \s0(R8000, R10000, ...)
.PP
You can also use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitall
.Ve
.PP
but that makes no difference compared with the \-Duse64bitint because
of the \f(CW\*(C`cc \-64\*(C'\fR.
.PP
You can also do
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq \-Duse64bitint
.Ve
.PP
to use long longs for the 64\-bit integer type, in case you don't
have a 64\-bit \s-1CPU.\s0
.PP
If you are using gcc, just
.PP
.Vb 1
\&        sh Configure \-Dcc=gcc \-Duse64bitint
.Ve
.PP
should be enough, the Configure should automatically probe for the
correct 64\-bit settings.
.SS "About Compiler Versions of Irix"
.IX Subsection "About Compiler Versions of Irix"
Some Irix cc versions, e.g. 7.3.1.1m (try cc \-version) have been known
to have issues (coredumps) when compiling perl.c.  If you've used
\&\-OPT:fast_io=ON and this happens, try removing it.  If that fails, or
you didn't use that, then try adjusting other optimization options
(\-LNO, \-INLINE, \-O3 to \-O2, etcetera).  The compiler bug has been
reported to \s-1SGI.  \s0(Allen Smith <easmith@beatrice.rutgers.edu>)
.SS "Linker Problems in Irix"
.IX Subsection "Linker Problems in Irix"
If you get complaints about so_locations then search in the file
hints/irix_6.sh for \*(L"lddflags\*(R" and do the suggested adjustments.
(David Billinghurst <David.Billinghurst@riotinto.com.au>)
.SS "Malloc in Irix"
.IX Subsection "Malloc in Irix"
Do not try to use Perl's malloc, this will lead into very mysterious
errors (especially with \-Duse64bitall).
.SS "Building with threads in Irix"
.IX Subsection "Building with threads in Irix"
Run Configure with \-Duseithreads which will configure Perl with
the Perl 5.8.0 \*(L"interpreter threads\*(R", see threads.
.PP
For Irix 6.2 with perl threads, you have to have the following
patches installed:
.PP
.Vb 5
\&        1404 Irix 6.2 Posix 1003.1b man pages
\&        1645 Irix 6.2 & 6.3 POSIX header file updates
\&        2000 Irix 6.2 Posix 1003.1b support modules
\&        2254 Pthread library fixes
\&        2401 6.2 all platform kernel rollup
.Ve
.PP
\&\fB\s-1IMPORTANT\s0\fR: Without patch 2401, a kernel bug in Irix 6.2 will cause
your machine to panic and crash when running threaded perl.  Irix 6.3
and later are okay.
.PP
.Vb 2
\&    Thanks to Hannu Napari <Hannu.Napari@hut.fi> for the IRIX
\&    pthreads patches information.
.Ve
.SS "Irix 5.3"
.IX Subsection "Irix 5.3"
While running Configure and when building, you are likely to get
quite a few of these warnings:
.PP
.Vb 3
\&  ld:
\&  The shared object /usr/lib/libm.so did not resolve any symbols.
\&        You may want to remove it from your link line.
.Ve
.PP
Ignore them: in \s-1IRIX 5.3\s0 there is no way to quieten ld about this.
.PP
During compilation you will see this warning from toke.c:
.PP
.Vb 3
\&  uopt: Warning: Perl_yylex: this procedure not optimized because it
\&        exceeds size threshold; to optimize this procedure, use \-Olimit option
\&        with value >= 4252.
.Ve
.PP
Ignore the warning.
.PP
In \s-1IRIX 5.3\s0 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in \s-1IRIX 5.3\s0)
the following failures are known.
.PP
.Vb 7
\& Failed Test                  Stat Wstat Total Fail  Failed  List of Failed
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& ../ext/List/Util/t/shuffle.t    0   139    ??   ??       %  ??
\& ../lib/Math/Trig.t            255 65280    29   12  41.38%  24\-29
\& ../lib/sort.t                   0   138   119   72  60.50%  48\-119
\& 56 tests and 474 subtests skipped.
\& Failed 3/811 test scripts, 99.63% okay. 78/75813 subtests failed, 99.90% okay.
.Ve
.PP
They are suspected to be compiler errors (at least the shuffle.t
failure is known from some \s-1IRIX 6\s0 setups) and math library errors
(the Trig.t failure), but since \s-1IRIX 5\s0 is long since end-of-lifed,
further fixes for the \s-1IRIX\s0 are unlikely.  If you can get gcc for 5.3,
you could try that, too, since gcc in \s-1IRIX 6\s0 is a known workaround for
at least the shuffle.t and sort.t failures.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlirix5.16.1                               0100644 0001750 0001750 00000021204 12566207421 023104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIRIX 1"
.TH PERLIRIX 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlirix \- Perl version 5 on Irix systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Irix that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Building 32\-bit Perl in Irix"
.IX Subsection "Building 32-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq
.Ve
.PP
to compile Perl 32\-bit.  Don't bother with \-n32 unless you have 7.1
or later compilers (use cc \-version to check).
.PP
(Building 'cc \-n32' is the default.)
.SS "Building 64\-bit Perl in Irix"
.IX Subsection "Building 64-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitint
.Ve
.PP
This requires require a 64\-bit \s-1MIPS\s0 \s-1CPU\s0 (R8000, R10000, ...)
.PP
You can also use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitall
.Ve
.PP
but that makes no difference compared with the \-Duse64bitint because
of the \f(CW\*(C`cc \-64\*(C'\fR.
.PP
You can also do
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq \-Duse64bitint
.Ve
.PP
to use long longs for the 64\-bit integer type, in case you don't
have a 64\-bit \s-1CPU\s0.
.PP
If you are using gcc, just
.PP
.Vb 1
\&        sh Configure \-Dcc=gcc \-Duse64bitint
.Ve
.PP
should be enough, the Configure should automatically probe for the
correct 64\-bit settings.
.SS "About Compiler Versions of Irix"
.IX Subsection "About Compiler Versions of Irix"
Some Irix cc versions, e.g. 7.3.1.1m (try cc \-version) have been known
to have issues (coredumps) when compiling perl.c.  If you've used
\&\-OPT:fast_io=ON and this happens, try removing it.  If that fails, or
you didn't use that, then try adjusting other optimization options
(\-LNO, \-INLINE, \-O3 to \-O2, etcetera).  The compiler bug has been
reported to \s-1SGI\s0.  (Allen Smith <easmith@beatrice.rutgers.edu>)
.SS "Linker Problems in Irix"
.IX Subsection "Linker Problems in Irix"
If you get complaints about so_locations then search in the file
hints/irix_6.sh for \*(L"lddflags\*(R" and do the suggested adjustments.
(David Billinghurst <David.Billinghurst@riotinto.com.au>)
.SS "Malloc in Irix"
.IX Subsection "Malloc in Irix"
Do not try to use Perl's malloc, this will lead into very mysterious
errors (especially with \-Duse64bitall).
.SS "Building with threads in Irix"
.IX Subsection "Building with threads in Irix"
Run Configure with \-Duseithreads which will configure Perl with
the Perl 5.8.0 \*(L"interpreter threads\*(R", see threads.
.PP
For Irix 6.2 with perl threads, you have to have the following
patches installed:
.PP
.Vb 5
\&        1404 Irix 6.2 Posix 1003.1b man pages
\&        1645 Irix 6.2 & 6.3 POSIX header file updates
\&        2000 Irix 6.2 Posix 1003.1b support modules
\&        2254 Pthread library fixes
\&        2401 6.2 all platform kernel rollup
.Ve
.PP
\&\fB\s-1IMPORTANT\s0\fR: Without patch 2401, a kernel bug in Irix 6.2 will cause
your machine to panic and crash when running threaded perl.  Irix 6.3
and later are okay.
.PP
.Vb 2
\&    Thanks to Hannu Napari <Hannu.Napari@hut.fi> for the IRIX
\&    pthreads patches information.
.Ve
.SS "Irix 5.3"
.IX Subsection "Irix 5.3"
While running Configure and when building, you are likely to get
quite a few of these warnings:
.PP
.Vb 3
\&  ld:
\&  The shared object /usr/lib/libm.so did not resolve any symbols.
\&        You may want to remove it from your link line.
.Ve
.PP
Ignore them: in \s-1IRIX\s0 5.3 there is no way to quieten ld about this.
.PP
During compilation you will see this warning from toke.c:
.PP
.Vb 3
\&  uopt: Warning: Perl_yylex: this procedure not optimized because it
\&        exceeds size threshold; to optimize this procedure, use \-Olimit option
\&        with value >= 4252.
.Ve
.PP
Ignore the warning.
.PP
In \s-1IRIX\s0 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in \s-1IRIX\s0 5.3)
the following failures are known.
.PP
.Vb 7
\& Failed Test                  Stat Wstat Total Fail  Failed  List of Failed
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& ../ext/List/Util/t/shuffle.t    0   139    ??   ??       %  ??
\& ../lib/Math/Trig.t            255 65280    29   12  41.38%  24\-29
\& ../lib/sort.t                   0   138   119   72  60.50%  48\-119
\& 56 tests and 474 subtests skipped.
\& Failed 3/811 test scripts, 99.63% okay. 78/75813 subtests failed, 99.90% okay.
.Ve
.PP
They are suspected to be compiler errors (at least the shuffle.t
failure is known from some \s-1IRIX\s0 6 setups) and math library errors
(the Trig.t failure), but since \s-1IRIX\s0 5 is long since end-of-lifed,
further fixes for the \s-1IRIX\s0 are unlikely.  If you can get gcc for 5.3,
you could try that, too, since gcc in \s-1IRIX\s0 6 is a known workaround for
at least the shuffle.t and sort.t failures.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlirix5.18.1                               0100644 0001750 0001750 00000021516 12566207441 023116  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIRIX 1"
.TH PERLIRIX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlirix \- Perl version 5 on Irix systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Irix that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Building 32\-bit Perl in Irix"
.IX Subsection "Building 32-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq
.Ve
.PP
to compile Perl 32\-bit.  Don't bother with \-n32 unless you have 7.1
or later compilers (use cc \-version to check).
.PP
(Building 'cc \-n32' is the default.)
.SS "Building 64\-bit Perl in Irix"
.IX Subsection "Building 64-bit Perl in Irix"
Use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitint
.Ve
.PP
This requires require a 64\-bit \s-1MIPS CPU \s0(R8000, R10000, ...)
.PP
You can also use
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-64\*(Aq \-Duse64bitall
.Ve
.PP
but that makes no difference compared with the \-Duse64bitint because
of the \f(CW\*(C`cc \-64\*(C'\fR.
.PP
You can also do
.PP
.Vb 1
\&        sh Configure \-Dcc=\*(Aqcc \-n32\*(Aq \-Duse64bitint
.Ve
.PP
to use long longs for the 64\-bit integer type, in case you don't
have a 64\-bit \s-1CPU.\s0
.PP
If you are using gcc, just
.PP
.Vb 1
\&        sh Configure \-Dcc=gcc \-Duse64bitint
.Ve
.PP
should be enough, the Configure should automatically probe for the
correct 64\-bit settings.
.SS "About Compiler Versions of Irix"
.IX Subsection "About Compiler Versions of Irix"
Some Irix cc versions, e.g. 7.3.1.1m (try cc \-version) have been known
to have issues (coredumps) when compiling perl.c.  If you've used
\&\-OPT:fast_io=ON and this happens, try removing it.  If that fails, or
you didn't use that, then try adjusting other optimization options
(\-LNO, \-INLINE, \-O3 to \-O2, etcetera).  The compiler bug has been
reported to \s-1SGI.  \s0(Allen Smith <easmith@beatrice.rutgers.edu>)
.SS "Linker Problems in Irix"
.IX Subsection "Linker Problems in Irix"
If you get complaints about so_locations then search in the file
hints/irix_6.sh for \*(L"lddflags\*(R" and do the suggested adjustments.
(David Billinghurst <David.Billinghurst@riotinto.com.au>)
.SS "Malloc in Irix"
.IX Subsection "Malloc in Irix"
Do not try to use Perl's malloc, this will lead into very mysterious
errors (especially with \-Duse64bitall).
.SS "Building with threads in Irix"
.IX Subsection "Building with threads in Irix"
Run Configure with \-Duseithreads which will configure Perl with
the Perl 5.8.0 \*(L"interpreter threads\*(R", see threads.
.PP
For Irix 6.2 with perl threads, you have to have the following
patches installed:
.PP
.Vb 5
\&        1404 Irix 6.2 Posix 1003.1b man pages
\&        1645 Irix 6.2 & 6.3 POSIX header file updates
\&        2000 Irix 6.2 Posix 1003.1b support modules
\&        2254 Pthread library fixes
\&        2401 6.2 all platform kernel rollup
.Ve
.PP
\&\fB\s-1IMPORTANT\s0\fR: Without patch 2401, a kernel bug in Irix 6.2 will cause
your machine to panic and crash when running threaded perl.  Irix 6.3
and later are okay.
.PP
.Vb 2
\&    Thanks to Hannu Napari <Hannu.Napari@hut.fi> for the IRIX
\&    pthreads patches information.
.Ve
.SS "Irix 5.3"
.IX Subsection "Irix 5.3"
While running Configure and when building, you are likely to get
quite a few of these warnings:
.PP
.Vb 3
\&  ld:
\&  The shared object /usr/lib/libm.so did not resolve any symbols.
\&        You may want to remove it from your link line.
.Ve
.PP
Ignore them: in \s-1IRIX 5.3\s0 there is no way to quieten ld about this.
.PP
During compilation you will see this warning from toke.c:
.PP
.Vb 3
\&  uopt: Warning: Perl_yylex: this procedure not optimized because it
\&        exceeds size threshold; to optimize this procedure, use \-Olimit option
\&        with value >= 4252.
.Ve
.PP
Ignore the warning.
.PP
In \s-1IRIX 5.3\s0 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in \s-1IRIX 5.3\s0)
the following failures are known.
.PP
.Vb 7
\& Failed Test                  Stat Wstat Total Fail  Failed  List of Failed
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& ../ext/List/Util/t/shuffle.t    0   139    ??   ??       %  ??
\& ../lib/Math/Trig.t            255 65280    29   12  41.38%  24\-29
\& ../lib/sort.t                   0   138   119   72  60.50%  48\-119
\& 56 tests and 474 subtests skipped.
\& Failed 3/811 test scripts, 99.63% okay. 78/75813 subtests failed, 99.90% okay.
.Ve
.PP
They are suspected to be compiler errors (at least the shuffle.t
failure is known from some \s-1IRIX 6\s0 setups) and math library errors
(the Trig.t failure), but since \s-1IRIX 5\s0 is long since end-of-lifed,
further fixes for the \s-1IRIX\s0 are unlikely.  If you can get gcc for 5.3,
you could try that, too, since gcc in \s-1IRIX 6\s0 is a known workaround for
at least the shuffle.t and sort.t failures.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlivp.1                                    0100644 0001750 0001750 00000016114 12566207466 022432  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIVP 1"
.TH PERLIVP 1 "2015-08-22" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlivp \- Perl Installation Verification Procedure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperlivp\fR [\fB\-p\fR] [\fB\-v\fR] [\fB\-h\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBperlivp\fR program is set up at Perl source code build time to test the
Perl version it was built under.  It can be used after running:
.PP
.Vb 1
\&    make install
.Ve
.PP
(or your platform's equivalent procedure) to verify that \fBperl\fR and its
libraries have been installed correctly.  A correct installation is verified
by output that looks like:
.PP
.Vb 2
\&    ok 1
\&    ok 2
.Ve
.PP
etc.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-h\fR help" 5
.IX Item "-h help"
Prints out a brief help message.
.IP "\fB\-p\fR print preface" 5
.IX Item "-p print preface"
Gives a description of each test prior to performing it.
.IP "\fB\-v\fR verbose" 5
.IX Item "-v verbose"
Gives more detailed information about each test, after it has been performed.
Note that any failed tests ought to print out some extra information whether
or not \-v is thrown.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "\(bu" 4
print \*(L"# Perl binary '$perlpath' does not appear executable.\en\*(R";
.Sp
Likely to occur for a perl binary that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl version '$]' installed, expected \f(CW$ivp_VERSION\fR.\en\*(R";
.Sp
Likely to occur for a perl that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl \e@INC directory '$_' does not appear to exist.\en\*(R";
.Sp
Likely to occur for a perl library tree that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Needed module '$_' does not appear to be properly installed.\en\*(R";
.Sp
One of the two modules that is used by perlivp was not present in the 
installation.  This is a serious error since it adversely affects perlivp's
ability to function.  You may be able to correct this by performing a
proper perl installation.
.IP "\(bu" 4
print \*(L"# Required module '$_' does not appear to be properly installed.\en\*(R";
.Sp
An attempt to \f(CW\*(C`eval "require $module"\*(C'\fR failed, even though the list of 
extensions indicated that it should succeed.  Correct by conducting a proper 
installation.
.IP "\(bu" 4
print \*(L"# Unnecessary module 'bLuRfle' appears to be installed.\en\*(R";
.Sp
This test not coming out ok could indicate that you have in fact installed 
a bLuRfle.pm module or that the \f(CW\*(C`eval " require \e"$module_name.pm\e"; "\*(C'\fR
test may give misleading results with your installation of perl.  If yours
is the latter case then please let the author know.
.IP "\(bu" 4
print \*(L"# file\*(R",+($#missing == 0) ? '' : 's',\*(L" missing from installation:\en\*(R";
.Sp
One or more files turned up missing according to a run of 
\&\f(CW\*(C`ExtUtils::Installed \-> validate()\*(C'\fR over your installation.
Correct by conducting a proper installation.
.PP
For further information on how to conduct a proper installation consult the 
\&\s-1INSTALL\s0 file that comes with the perl source and the \s-1README\s0 file for your 
platform.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer
                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlivp5.16.1                                0100644 0001750 0001750 00000015573 12566207443 022747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIVP 1"
.TH PERLIVP 1 "2015-08-22" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlivp \- Perl Installation Verification Procedure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperlivp\fR [\fB\-p\fR] [\fB\-v\fR] [\fB\-h\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBperlivp\fR program is set up at Perl source code build time to test the
Perl version it was built under.  It can be used after running:
.PP
.Vb 1
\&    make install
.Ve
.PP
(or your platform's equivalent procedure) to verify that \fBperl\fR and its
libraries have been installed correctly.  A correct installation is verified
by output that looks like:
.PP
.Vb 2
\&    ok 1
\&    ok 2
.Ve
.PP
etc.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-h\fR help" 5
.IX Item "-h help"
Prints out a brief help message.
.IP "\fB\-p\fR print preface" 5
.IX Item "-p print preface"
Gives a description of each test prior to performing it.
.IP "\fB\-v\fR verbose" 5
.IX Item "-v verbose"
Gives more detailed information about each test, after it has been performed.
Note that any failed tests ought to print out some extra information whether
or not \-v is thrown.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "\(bu" 4
print \*(L"# Perl binary '$perlpath' does not appear executable.\en\*(R";
.Sp
Likely to occur for a perl binary that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl version '$]' installed, expected \f(CW$ivp_VERSION\fR.\en\*(R";
.Sp
Likely to occur for a perl that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl \e@INC directory '$_' does not appear to exist.\en\*(R";
.Sp
Likely to occur for a perl library tree that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Needed module '$_' does not appear to be properly installed.\en\*(R";
.Sp
One of the two modules that is used by perlivp was not present in the 
installation.  This is a serious error since it adversely affects perlivp's
ability to function.  You may be able to correct this by performing a
proper perl installation.
.IP "\(bu" 4
print \*(L"# Required module '$_' does not appear to be properly installed.\en\*(R";
.Sp
An attempt to \f(CW\*(C`eval "require $module"\*(C'\fR failed, even though the list of 
extensions indicated that it should succeed.  Correct by conducting a proper 
installation.
.IP "\(bu" 4
print \*(L"# Unnecessary module 'bLuRfle' appears to be installed.\en\*(R";
.Sp
This test not coming out ok could indicate that you have in fact installed 
a bLuRfle.pm module or that the \f(CW\*(C`eval " require \e"$module_name.pm\e"; "\*(C'\fR
test may give misleading results with your installation of perl.  If yours
is the latter case then please let the author know.
.IP "\(bu" 4
print \*(L"# file\*(R",+($#missing == 0) ? '' : 's',\*(L" missing from installation:\en\*(R";
.Sp
One or more files turned up missing according to a run of 
\&\f(CW\*(C`ExtUtils::Installed \-> validate()\*(C'\fR over your installation.
Correct by conducting a proper installation.
.PP
For further information on how to conduct a proper installation consult the 
\&\s-1INSTALL\s0 file that comes with the perl source and the \s-1README\s0 file for your 
platform.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer
                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlivp5.18.1                                0100644 0001750 0001750 00000016114 12566207466 022746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIVP 1"
.TH PERLIVP 1 "2015-08-22" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlivp \- Perl Installation Verification Procedure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperlivp\fR [\fB\-p\fR] [\fB\-v\fR] [\fB\-h\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBperlivp\fR program is set up at Perl source code build time to test the
Perl version it was built under.  It can be used after running:
.PP
.Vb 1
\&    make install
.Ve
.PP
(or your platform's equivalent procedure) to verify that \fBperl\fR and its
libraries have been installed correctly.  A correct installation is verified
by output that looks like:
.PP
.Vb 2
\&    ok 1
\&    ok 2
.Ve
.PP
etc.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-h\fR help" 5
.IX Item "-h help"
Prints out a brief help message.
.IP "\fB\-p\fR print preface" 5
.IX Item "-p print preface"
Gives a description of each test prior to performing it.
.IP "\fB\-v\fR verbose" 5
.IX Item "-v verbose"
Gives more detailed information about each test, after it has been performed.
Note that any failed tests ought to print out some extra information whether
or not \-v is thrown.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "\(bu" 4
print \*(L"# Perl binary '$perlpath' does not appear executable.\en\*(R";
.Sp
Likely to occur for a perl binary that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl version '$]' installed, expected \f(CW$ivp_VERSION\fR.\en\*(R";
.Sp
Likely to occur for a perl that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Perl \e@INC directory '$_' does not appear to exist.\en\*(R";
.Sp
Likely to occur for a perl library tree that was not properly installed.
Correct by conducting a proper installation.
.IP "\(bu" 4
print \*(L"# Needed module '$_' does not appear to be properly installed.\en\*(R";
.Sp
One of the two modules that is used by perlivp was not present in the 
installation.  This is a serious error since it adversely affects perlivp's
ability to function.  You may be able to correct this by performing a
proper perl installation.
.IP "\(bu" 4
print \*(L"# Required module '$_' does not appear to be properly installed.\en\*(R";
.Sp
An attempt to \f(CW\*(C`eval "require $module"\*(C'\fR failed, even though the list of 
extensions indicated that it should succeed.  Correct by conducting a proper 
installation.
.IP "\(bu" 4
print \*(L"# Unnecessary module 'bLuRfle' appears to be installed.\en\*(R";
.Sp
This test not coming out ok could indicate that you have in fact installed 
a bLuRfle.pm module or that the \f(CW\*(C`eval " require \e"$module_name.pm\e"; "\*(C'\fR
test may give misleading results with your installation of perl.  If yours
is the latter case then please let the author know.
.IP "\(bu" 4
print \*(L"# file\*(R",+($#missing == 0) ? '' : 's',\*(L" missing from installation:\en\*(R";
.Sp
One or more files turned up missing according to a run of 
\&\f(CW\*(C`ExtUtils::Installed \-> validate()\*(C'\fR over your installation.
Correct by conducting a proper installation.
.PP
For further information on how to conduct a proper installation consult the 
\&\s-1INSTALL\s0 file that comes with the perl source and the \s-1README\s0 file for your 
platform.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer
                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perljp.1                                     0100644 0001750 0001750 00000024245 12566207441 022242  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLJP 1"
.TH PERLJP 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perljp \- XXX Perl XXX
.SH "XX"
.IX Header "XX"
Perl \s-1XXXXXXXX\s0!
.PP
Perl 5.8.0 XXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \s-1CJK \s0(\s-1XXXXXXXXXXXX\s0)XXXXXXXXXXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOSXXXXXXXXXXXXXXX(PCXXXMacintosh)XXXXXXXXXXXX
.PP
Perl \s-1XXX\s0 Unicode XXXXXXXPerl \s-1XXXXXXXXXXXXXXXXXXXX\s0 Unicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0 Encode XXXXXXXXXXXXUnicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXX\s0 Encode \s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 10
\&  7bit\-jis      AdobeStandardEncoding AdobeSymbol       AdobeZdingbat
\&  ascii             big5              big5\-hkscs        cp1006
\&  cp1026            cp1047            cp1250            cp1251
\&  cp1252            cp1253            cp1254            cp1255
\&  cp1256            cp1257            cp1258            cp37
\&  cp424             cp437             cp500             cp737
\&  cp775             cp850             cp852             cp855
\&  cp856             cp857             cp860             cp861
\&  cp862             cp863             cp864             cp865
\&  cp866             cp869             cp874             cp875
\&  cp932             cp936             cp949             cp950
\&  dingbats          euc\-cn            euc\-jp            euc\-kr
\&  gb12345\-raw       gb2312\-raw        gsm0338           hp\-roman8
\&  hz                iso\-2022\-jp       iso\-2022\-jp\-1     iso\-8859\-1
\&  iso\-8859\-10       iso\-8859\-11       iso\-8859\-13       iso\-8859\-14
\&  iso\-8859\-15       iso\-8859\-16       iso\-8859\-2        iso\-8859\-3
\&  iso\-8859\-4        iso\-8859\-5        iso\-8859\-6        iso\-8859\-7
\&  iso\-8859\-8        iso\-8859\-9        iso\-ir\-165        jis0201\-raw
\&  jis0208\-raw       jis0212\-raw       johab             koi8\-f
\&  koi8\-r            koi8\-u            ksc5601\-raw       MacArabic
\&  MacCentralEurRoman  MacChineseSimp    MacChineseTrad    MacCroatian
\&  MacCyrillic       MacDingbats       MacFarsi          MacGreek
\&  MacHebrew         MacIcelandic      MacJapanese       MacKorean
\&  MacRoman          MacRomanian       MacRumanian       MacSami
\&  MacSymbol         MacThai           MacTurkish        MacUkrainian
\&  nextstep          posix\-bc          shiftjis          symbol
\&  UCS\-2BE           UCS\-2LE           UTF\-16            UTF\-16BE
\&  UTF\-16LE          UTF\-32            UTF\-32BE          UTF\-32LE
\&  utf8              viscii
.Ve
.PP
(X114XX)
.PP
\&\s-1XXXXXXXXXFOOXXXXXXUTF\-8XXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 1
\&    perl \-Mencoding=FOO,STDOUT,utf8 \-pe1 < file.FOO > file.utf8
.Ve
.PP
XXXPerlXXXXXXPerlXXXXXXXXXXXXXXXXXXXXpiconvXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 2
\&   piconv \-f FOO \-t utf8 < file.FOO > file.utf8
\&   piconv \-f utf8 \-t FOO < file.utf8 > file.FOO
.Ve
.SS "About (jcode.pl|Jcode.pm|JPerl)"
.IX Subsection "About (jcode.pl|Jcode.pm|JPerl)"
5.8XXXXXXXXXXEUC\-JPXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXJcode.pmX( http://openlab.ring.gr.jp/Jcode/ )Xperl4XXXXXXXXXXXXXjcode.plXXXXXXXXXXXXXXXXCGIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
5.005XXXPerlXXXXXXXXXXXXXXXXXXXJperlXXXXXXX( http://homepage2.nifty.com/kipp/perl/jperl/index.html )XXXXMac \s-1OS 9\s0.x/ClassicXXPerlXMacPerlXXXXXXMacJPerlXXXXXXXXXXX( http://habilis.net/macjperl/ ).XXXXXXXXXXXXXEUC\-JPXXXShift_JISXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
Perl5.8XXXXXXXXXXXXXPerlXXXXXXXXXXXXXXXXXXXXXXX114XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXCPANXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.IP "\(bu" 4
\&\s-1XXX\s0
.Sp
XXXXXXXXXShift_JISXXXXEUC\-JPXXXXXXXXXXX
.Sp
.Vb 10
\&  # jcode.pl
\&  require "jcode.pl";
\&  while(<>){
\&    jcode::convert(*_, \*(Aqeuc\*(Aq, \*(Aqsjis\*(Aq);
\&    print;
\&  }
\&  # Jcode.pm
\&  use Jcode;
\&  while(<>){
\&        print Jcode\->new($_, \*(Aqsjis\*(Aq)\->euc;
\&  }
\&  # Perl 5.8
\&  use Encode;
\&  while(<>){
\&    from_to($_, \*(Aqshiftjis\*(Aq, \*(Aqeuc\-jp\*(Aq);
\&    print;
\&  }
\&  # Perl 5.8 \- encoding XXXXX
\&  use encoding \*(Aqeuc\-jp\*(Aq, STDIN => \*(Aqshiftjis\*(Aq;
\&  while(<>){
\&        print;
\&  }
.Ve
.IP "\(bu" 4
Jperl \s-1XXXXXXX\s0
.Sp
\&\s-1XXXX\s0\*(L"shebang\*(R"XXXXXXXXXJperlXXscriptXXXXXXXXXXXXXXXXXXXXXXX
.Sp
.Vb 3
\&   #!/path/to/jperl
\&   X
\&   #!/path/to/perl \-Mencoding=euc\-jp
.Ve
.Sp
\&\s-1XXXX\s0 perldoc encoding \s-1XXXXXXXXXX\s0
.SS "\s-1XXXXXX\s0"
.IX Subsection "XXXXXX"
PerlXXXXXXXXXXXXXXXPerlXXXXXUnicodeXXXXXXXXEncodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 3
\&  perldoc perlunicode # PerlXUnicodeXXXXXX
\&  perldoc Encode      # EncodeXXXXXXXXX
\&  perldoc Encode::JP  # XXXXXXXXXXXXXX
.Ve
.SS "PerlXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXX URL"
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
Perl \s-1XXXXXX \s0(O'Reilly and Associates)
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
\&\s-1CPAN \s0(Comprehensive Perl Archive Network)
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
Perl \s-1XXXXXXXXX\s0
.SS "PerlXXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXXX URL"
.IP "<http://www.oreilly.com.tw/>" 4
.IX Item "<http://www.oreilly.com.tw/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.com.cn/>" 4
.IX Item "<http://www.oreilly.com.cn/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.co.jp/catalog/>" 4
.IX Item "<http://www.oreilly.co.jp/catalog/>"
XXXXXXXPerlXXXX(\s-1XXX\s0)
.SS "Perl \s-1XXXXXXXX\s0"
.IX Subsection "Perl XXXXXXXX"
.IP "<http://www.pm.org/groups/asia.html>" 4
.IX Item "<http://www.pm.org/groups/asia.html>"
.SS "UnicodeXXXURL"
.IX Subsection "UnicodeXXXURL"
.PD 0
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.PD
Unicode \s-1XXXXXXX \s0(UnicodeXXXXXXX)
.IP "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux
.IP "<http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html>" 4
.IX Item "<http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux (\s-1XXXXX\s0)
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Dan Kogai (\s-1XXXX\s0) <dankogai@dan.co.jp>
                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perljp5.16.1                                 0100644 0001750 0001750 00000024127 12566207421 022551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLJP 1"
.TH PERLJP 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perljp \- XXX Perl XXX
.SH "XX"
.IX Header "XX"
Perl \s-1XXXXXXXX\s0!
.PP
Perl 5.8.0 XXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \s-1CJK\s0 (\s-1XXXXXXXXXXXX\s0)XXXXXXXXXXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOSXXXXXXXXXXXXXXX(PCXXXMacintosh)XXXXXXXXXXXX
.PP
Perl \s-1XXX\s0 Unicode XXXXXXXPerl \s-1XXXXXXXXXXXXXXXXXXXX\s0 Unicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0 Encode XXXXXXXXXXXXUnicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXX\s0 Encode \s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 10
\&  7bit\-jis      AdobeStandardEncoding AdobeSymbol       AdobeZdingbat
\&  ascii             big5              big5\-hkscs        cp1006
\&  cp1026            cp1047            cp1250            cp1251
\&  cp1252            cp1253            cp1254            cp1255
\&  cp1256            cp1257            cp1258            cp37
\&  cp424             cp437             cp500             cp737
\&  cp775             cp850             cp852             cp855
\&  cp856             cp857             cp860             cp861
\&  cp862             cp863             cp864             cp865
\&  cp866             cp869             cp874             cp875
\&  cp932             cp936             cp949             cp950
\&  dingbats          euc\-cn            euc\-jp            euc\-kr
\&  gb12345\-raw       gb2312\-raw        gsm0338           hp\-roman8
\&  hz                iso\-2022\-jp       iso\-2022\-jp\-1     iso\-8859\-1
\&  iso\-8859\-10       iso\-8859\-11       iso\-8859\-13       iso\-8859\-14
\&  iso\-8859\-15       iso\-8859\-16       iso\-8859\-2        iso\-8859\-3
\&  iso\-8859\-4        iso\-8859\-5        iso\-8859\-6        iso\-8859\-7
\&  iso\-8859\-8        iso\-8859\-9        iso\-ir\-165        jis0201\-raw
\&  jis0208\-raw       jis0212\-raw       johab             koi8\-f
\&  koi8\-r            koi8\-u            ksc5601\-raw       MacArabic
\&  MacCentralEurRoman  MacChineseSimp    MacChineseTrad    MacCroatian
\&  MacCyrillic       MacDingbats       MacFarsi          MacGreek
\&  MacHebrew         MacIcelandic      MacJapanese       MacKorean
\&  MacRoman          MacRomanian       MacRumanian       MacSami
\&  MacSymbol         MacThai           MacTurkish        MacUkrainian
\&  nextstep          posix\-bc          shiftjis          symbol
\&  UCS\-2BE           UCS\-2LE           UTF\-16            UTF\-16BE
\&  UTF\-16LE          UTF\-32            UTF\-32BE          UTF\-32LE
\&  utf8              viscii
.Ve
.PP
(X114XX)
.PP
\&\s-1XXXXXXXXXFOOXXXXXXUTF\-8XXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 1
\&    perl \-Mencoding=FOO,STDOUT,utf8 \-pe1 < file.FOO > file.utf8
.Ve
.PP
XXXPerlXXXXXXPerlXXXXXXXXXXXXXXXXXXXXpiconvXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 2
\&   piconv \-f FOO \-t utf8 < file.FOO > file.utf8
\&   piconv \-f utf8 \-t FOO < file.utf8 > file.FOO
.Ve
.SS "About (jcode.pl|Jcode.pm|JPerl)"
.IX Subsection "About (jcode.pl|Jcode.pm|JPerl)"
5.8XXXXXXXXXXEUC\-JPXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXJcode.pmX( http://openlab.ring.gr.jp/Jcode/ )Xperl4XXXXXXXXXXXXXjcode.plXXXXXXXXXXXXXXXXCGIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
5.005XXXPerlXXXXXXXXXXXXXXXXXXXJperlXXXXXXX( http://homepage2.nifty.com/kipp/perl/jperl/index.html )XXXXMac \s-1OS\s0 9.x/ClassicXXPerlXMacPerlXXXXXXMacJPerlXXXXXXXXXXX( http://habilis.net/macjperl/ ).XXXXXXXXXXXXXEUC\-JPXXXShift_JISXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
Perl5.8XXXXXXXXXXXXXPerlXXXXXXXXXXXXXXXXXXXXXXX114XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXCPANXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.IP "\(bu" 4
\&\s-1XXX\s0
.Sp
XXXXXXXXXShift_JISXXXXEUC\-JPXXXXXXXXXXX
.Sp
.Vb 10
\&  # jcode.pl
\&  require "jcode.pl";
\&  while(<>){
\&    jcode::convert(*_, \*(Aqeuc\*(Aq, \*(Aqsjis\*(Aq);
\&    print;
\&  }
\&  # Jcode.pm
\&  use Jcode;
\&  while(<>){
\&        print Jcode\->new($_, \*(Aqsjis\*(Aq)\->euc;
\&  }
\&  # Perl 5.8
\&  use Encode;
\&  while(<>){
\&    from_to($_, \*(Aqshiftjis\*(Aq, \*(Aqeuc\-jp\*(Aq);
\&    print;
\&  }
\&  # Perl 5.8 \- encoding XXXXX
\&  use encoding \*(Aqeuc\-jp\*(Aq, STDIN => \*(Aqshiftjis\*(Aq;
\&  while(<>){
\&        print;
\&  }
.Ve
.IP "\(bu" 4
Jperl \s-1XXXXXXX\s0
.Sp
.Vb 1
\& XXXX"shebang"XXXXXXXXXJperlXXscriptXXXXXXXXXXXXXXXXXXXXXXX
\&
\&   #!/path/to/jperl
\&   X
\&   #!/path/to/perl \-Mencoding=euc\-jp
\&
\& XXXX perldoc encoding XXXXXXXXXX
.Ve
.SS "\s-1XXXXXX\s0"
.IX Subsection "XXXXXX"
PerlXXXXXXXXXXXXXXXPerlXXXXXUnicodeXXXXXXXXEncodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 3
\&  perldoc perlunicode # PerlXUnicodeXXXXXX
\&  perldoc Encode      # EncodeXXXXXXXXX
\&  perldoc Encode::JP  # XXXXXXXXXXXXXX
.Ve
.SS "PerlXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXX URL"
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
Perl \s-1XXXXXX\s0 (O'Reilly and Associates)
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
\&\s-1CPAN\s0 (Comprehensive Perl Archive Network)
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
Perl \s-1XXXXXXXXX\s0
.SS "PerlXXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXXX URL"
.IP "<http://www.oreilly.com.tw/>" 4
.IX Item "<http://www.oreilly.com.tw/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.com.cn/>" 4
.IX Item "<http://www.oreilly.com.cn/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.co.jp/catalog/>" 4
.IX Item "<http://www.oreilly.co.jp/catalog/>"
XXXXXXXPerlXXXX(\s-1XXX\s0)
.SS "Perl \s-1XXXXXXXX\s0"
.IX Subsection "Perl XXXXXXXX"
.IP "<http://www.pm.org/groups/asia.html>" 4
.IX Item "<http://www.pm.org/groups/asia.html>"
.SS "UnicodeXXXURL"
.IX Subsection "UnicodeXXXURL"
.PD 0
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.PD
Unicode \s-1XXXXXXX\s0 (UnicodeXXXXXXX)
.IP "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux
.IP "http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html <http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>" 4
.IX Item "http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html <http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux (\s-1XXXXX\s0)
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Dan Kogai (\s-1XXXX\s0) <dankogai@dan.co.jp>
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perljp5.18.1                                 0100644 0001750 0001750 00000024245 12566207441 022556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLJP 1"
.TH PERLJP 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perljp \- XXX Perl XXX
.SH "XX"
.IX Header "XX"
Perl \s-1XXXXXXXX\s0!
.PP
Perl 5.8.0 XXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \s-1CJK \s0(\s-1XXXXXXXXXXXX\s0)XXXXXXXXXXXUnicodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOSXXXXXXXXXXXXXXX(PCXXXMacintosh)XXXXXXXXXXXX
.PP
Perl \s-1XXX\s0 Unicode XXXXXXXPerl \s-1XXXXXXXXXXXXXXXXXXXX\s0 Unicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0 Encode XXXXXXXXXXXXUnicode \s-1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\s0
.PP
\&\s-1XXXX\s0 Encode \s-1XXXXXXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 10
\&  7bit\-jis      AdobeStandardEncoding AdobeSymbol       AdobeZdingbat
\&  ascii             big5              big5\-hkscs        cp1006
\&  cp1026            cp1047            cp1250            cp1251
\&  cp1252            cp1253            cp1254            cp1255
\&  cp1256            cp1257            cp1258            cp37
\&  cp424             cp437             cp500             cp737
\&  cp775             cp850             cp852             cp855
\&  cp856             cp857             cp860             cp861
\&  cp862             cp863             cp864             cp865
\&  cp866             cp869             cp874             cp875
\&  cp932             cp936             cp949             cp950
\&  dingbats          euc\-cn            euc\-jp            euc\-kr
\&  gb12345\-raw       gb2312\-raw        gsm0338           hp\-roman8
\&  hz                iso\-2022\-jp       iso\-2022\-jp\-1     iso\-8859\-1
\&  iso\-8859\-10       iso\-8859\-11       iso\-8859\-13       iso\-8859\-14
\&  iso\-8859\-15       iso\-8859\-16       iso\-8859\-2        iso\-8859\-3
\&  iso\-8859\-4        iso\-8859\-5        iso\-8859\-6        iso\-8859\-7
\&  iso\-8859\-8        iso\-8859\-9        iso\-ir\-165        jis0201\-raw
\&  jis0208\-raw       jis0212\-raw       johab             koi8\-f
\&  koi8\-r            koi8\-u            ksc5601\-raw       MacArabic
\&  MacCentralEurRoman  MacChineseSimp    MacChineseTrad    MacCroatian
\&  MacCyrillic       MacDingbats       MacFarsi          MacGreek
\&  MacHebrew         MacIcelandic      MacJapanese       MacKorean
\&  MacRoman          MacRomanian       MacRumanian       MacSami
\&  MacSymbol         MacThai           MacTurkish        MacUkrainian
\&  nextstep          posix\-bc          shiftjis          symbol
\&  UCS\-2BE           UCS\-2LE           UTF\-16            UTF\-16BE
\&  UTF\-16LE          UTF\-32            UTF\-32BE          UTF\-32LE
\&  utf8              viscii
.Ve
.PP
(X114XX)
.PP
\&\s-1XXXXXXXXXFOOXXXXXXUTF\-8XXXXXXXXXXXXXXXXXX\s0
.PP
.Vb 1
\&    perl \-Mencoding=FOO,STDOUT,utf8 \-pe1 < file.FOO > file.utf8
.Ve
.PP
XXXPerlXXXXXXPerlXXXXXXXXXXXXXXXXXXXXpiconvXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 2
\&   piconv \-f FOO \-t utf8 < file.FOO > file.utf8
\&   piconv \-f utf8 \-t FOO < file.utf8 > file.FOO
.Ve
.SS "About (jcode.pl|Jcode.pm|JPerl)"
.IX Subsection "About (jcode.pl|Jcode.pm|JPerl)"
5.8XXXXXXXXXXEUC\-JPXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXJcode.pmX( http://openlab.ring.gr.jp/Jcode/ )Xperl4XXXXXXXXXXXXXjcode.plXXXXXXXXXXXXXXXXCGIXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
5.005XXXPerlXXXXXXXXXXXXXXXXXXXJperlXXXXXXX( http://homepage2.nifty.com/kipp/perl/jperl/index.html )XXXXMac \s-1OS 9\s0.x/ClassicXXPerlXMacPerlXXXXXXMacJPerlXXXXXXXXXXX( http://habilis.net/macjperl/ ).XXXXXXXXXXXXXEUC\-JPXXXShift_JISXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
Perl5.8XXXXXXXXXXXXXPerlXXXXXXXXXXXXXXXXXXXXXXX114XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXCPANXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.IP "\(bu" 4
\&\s-1XXX\s0
.Sp
XXXXXXXXXShift_JISXXXXEUC\-JPXXXXXXXXXXX
.Sp
.Vb 10
\&  # jcode.pl
\&  require "jcode.pl";
\&  while(<>){
\&    jcode::convert(*_, \*(Aqeuc\*(Aq, \*(Aqsjis\*(Aq);
\&    print;
\&  }
\&  # Jcode.pm
\&  use Jcode;
\&  while(<>){
\&        print Jcode\->new($_, \*(Aqsjis\*(Aq)\->euc;
\&  }
\&  # Perl 5.8
\&  use Encode;
\&  while(<>){
\&    from_to($_, \*(Aqshiftjis\*(Aq, \*(Aqeuc\-jp\*(Aq);
\&    print;
\&  }
\&  # Perl 5.8 \- encoding XXXXX
\&  use encoding \*(Aqeuc\-jp\*(Aq, STDIN => \*(Aqshiftjis\*(Aq;
\&  while(<>){
\&        print;
\&  }
.Ve
.IP "\(bu" 4
Jperl \s-1XXXXXXX\s0
.Sp
\&\s-1XXXX\s0\*(L"shebang\*(R"XXXXXXXXXJperlXXscriptXXXXXXXXXXXXXXXXXXXXXXX
.Sp
.Vb 3
\&   #!/path/to/jperl
\&   X
\&   #!/path/to/perl \-Mencoding=euc\-jp
.Ve
.Sp
\&\s-1XXXX\s0 perldoc encoding \s-1XXXXXXXXXX\s0
.SS "\s-1XXXXXX\s0"
.IX Subsection "XXXXXX"
PerlXXXXXXXXXXXXXXXPerlXXXXXUnicodeXXXXXXXXEncodeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
.PP
.Vb 3
\&  perldoc perlunicode # PerlXUnicodeXXXXXX
\&  perldoc Encode      # EncodeXXXXXXXXX
\&  perldoc Encode::JP  # XXXXXXXXXXXXXX
.Ve
.SS "PerlXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXX URL"
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
Perl \s-1XXXXXX \s0(O'Reilly and Associates)
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
\&\s-1CPAN \s0(Comprehensive Perl Archive Network)
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
Perl \s-1XXXXXXXXX\s0
.SS "PerlXXXXXXX \s-1URL\s0"
.IX Subsection "PerlXXXXXXX URL"
.IP "<http://www.oreilly.com.tw/>" 4
.IX Item "<http://www.oreilly.com.tw/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.com.cn/>" 4
.IX Item "<http://www.oreilly.com.cn/>"
O'Reilly XXPerlXXXX(\s-1XXXXXX\s0)
.IP "<http://www.oreilly.co.jp/catalog/>" 4
.IX Item "<http://www.oreilly.co.jp/catalog/>"
XXXXXXXPerlXXXX(\s-1XXX\s0)
.SS "Perl \s-1XXXXXXXX\s0"
.IX Subsection "Perl XXXXXXXX"
.IP "<http://www.pm.org/groups/asia.html>" 4
.IX Item "<http://www.pm.org/groups/asia.html>"
.SS "UnicodeXXXURL"
.IX Subsection "UnicodeXXXURL"
.PD 0
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.PD
Unicode \s-1XXXXXXX \s0(UnicodeXXXXXXX)
.IP "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/%7Emgk25/unicode.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux
.IP "<http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html>" 4
.IX Item "<http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
\&\s-1UTF\-8\s0 and Unicode \s-1FAQ\s0 for Unix/Linux (\s-1XXXXX\s0)
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Dan Kogai (\s-1XXXX\s0) <dankogai@dan.co.jp>
                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlko.1                                     0100644 0001750 0001750 00000023400 12566207441 022232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLKO 1"
.TH PERLKO 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
X \s-1XXX\s0 perldocX \s-1XX XX XX XX XX XXXX X XXX
XXX XXXX XX XX\s0 =head, =item, 'L' \s-1XX XXXXXX.
X XXX XX\s0 perldocX \s-1XX XX XXXX XXX X XXX
XX POD XXXX XX XXXX.  X XXX XX\s0 perlpod
\&\s-1XXXX XXXXXX. \s0
.SH "NAME"
perlko \- PerlX XXX XXX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PerlX \s-1XXX XX XX XXXXX \s0!
.PP
PerlX 5.8.0XXX \s-1XXXX/ISO 10646X XX XXXX XXX XXX.
XXXX XXX XXXX XXXX XXX XX XXXX
XXXX XXX XX XXX XXX XX XXX XX XXX XXXX
XXXXX.  XXXXX X XXXX XXX XX XXX XX XX XX \-
XXX XX XXX, XX XXX, XXX XXX, XXX XX XXXX
XXX XX XXXX, XX XX, XXX XX, XXXX XX, XXXX XX,
XXXX XX, XX XXXX XX XX X\-X XXXX XX XXX XX
XX XXX XXX XXX  X XX X XX XXX XX XXX XXX
XX XXX XXXX X X XX XX XXX XXXX  XX XX XXXX
XXXX XX XX XX XX XXX  XXXX XXXX.\s0
.PP
PerlX \s-1XXXXX XXXXX XX XXX XX XXXXX. XX XXXXX
XXX\s0 Perl \s-1XXXX XXX  UTF\-8 XXXX X X XX, 
XX XXX XXX\s0(\s-1XX XX, XXX,\s0 index, substr)X \s-1XXX XX
XX XXXX XX XXX XXXXX. \s0(X \s-1XXX XX \s0
perlunicode \s-1XXXX XXXXXX.\s0) \s-1XXXXX XX XXXX XX
XX XXX XXX, XXX XX XXX XX XX/X XXX XXXXX
XXXX XX XX XXXXX X XXXX XXX XXX XX XX XX
\&\s0'Encode'X  \s-1XXXXX. XXXX \s0'Encode'X  \s-1XX XXX XXX XXX
XXX XX X X XXXX.\s0
.PP
\&'Encode'X \s-1XXX XX XXX XXXX XXXXX.\s0
.IP "\(bu" 4
euc-kr
.Sp
US-ASCIIX \s-1KS X 1001X XX XX XXXXX XXX \s0(\s-1XX XXXXXX
XX.\s0) \s-1KS X 2901X RFC 1557 XX.\s0
.IP "\(bu" 4
cp949
.Sp
MS-Windows 9x/MEXX \s-1XXX XX XXX. \s0 euc-krX 8,822XX
\&\s-1XX XXX XX XX. \s0 aliasX uhc, windows\-949, x\-windows\-949,
ks_c_5601\-1987. X \s-1XXX XXX XXXX XX XXXXX,\s0 Microsoft
\&\s-1XXXX CP949X XXX XXX XX.\s0
.IP "\(bu" 4
johab
.Sp
\&\s-1KS X 1001:1998 XX 3XX XXX XXX.  XX XXXXX\s0 cp949X
\&\s-1XXXXX\s0 US-ASCIIX  \s-1KS X 1001X 8,822XX XX XXX XX XX.
XXX XXX XX XX. \s0
.IP "\(bu" 4
iso\-2022\-kr
.Sp
\&\s-1RFC 1557XX XXX XXX XXX XX XXX XXXXX\s0 US-ASCIIX
\&\s-1KS X 1001X XXXXX XX XXX\s0 euc-krX \s-1XXX XXX XXX XX.
1997\-8X XXX XXXX X XX XX XXX XXX XX.\s0
.IP "\(bu" 4
ksc5601\-raw
.Sp
\&\s-1KS X 1001\s0(\s-1KS C 5601\s0)X \s-1GL\s0(X, \s-1MSBX 0XX X XX\s0) X \s-1XXX XX
XXX.\s0 US-ASCIIX \s-1XXXX XX XXXX XXX XX X11 XXX XX
XXX \s0(ksc5601.1987\-0. '0'X \s-1GLX XXX.\s0)XX \s-1XXX XX XXXXX
XX XX. KS C 5601X 1997X KS X 1001X XXX XXXX.  1998XXX  X
XX \s0(\s-1XXX XXX XX XX XX\s0)X \s-1XXXX.\s0
.PP
X \s-1XX XX XXX XXX XXXX. \s0
.PP
\&\s-1XX XX,\s0 euc-kr \s-1XXXXX X XXX UTF\-8X XXXXX XXX
XX XX XXX. \s0
.PP
.Vb 1
\&    perl \-Mencoding=euc\-kr,STDOUT,utf8 \-pe1  < file.euckr > file.utf8
.Ve
.PP
\&\s-1XXXX XXX XX X X XXXX. \s0
.PP
.Vb 1
\&    perl \-Mencoding=utf8,STDOUT,euc\-kr \-pe1  < file.utf8  > file.euckr
.Ve
.PP
\&\s-1XX XXX XX XXXX X X XXX\s0 Encode \s-1XXX XX 
XXXX\s0 PerlXX \s-1XX\s0 piconvX PerlX \s-1XX XXXX.
X XXXX X X XXX\s0 piconvX UnixX \s-1XX\s0 iconvX
\&\s-1XXX X XXXX. X XXXX XXX XXXX.\s0
.PP
.Vb 2
\&   piconv \-f euc\-kr \-t utf8 < file.euckr > file.utf8
\&   piconv \-f utf8 \-t euc\-kr < file.utf8 > file.euckr
.Ve
.PP
X, 'PerlIO::encoding' \s-1XXX XX XXX XXXX XXX XX XX
\&\s0(\s-1XXX XXX XXX\s0) \s-1XXX XX X X XXXX.\s0
.PP
.Vb 1
\&  #!/path/to/perl 
\&
\&  use encoding \*(Aqeuc\-kr\*(Aq, STDIN => \*(Aqeuc\-kr\*(Aq,
\&                         STDOUT\-> \*(Aqeuc\-kr\*(Aq, STDERR=>\*(Aqeuc\-kr\*(Aq;
\&
\&  print length("XX");        # 2  (X XXXX XX XX XXX XX)
\&  print length(\*(AqXX\*(Aq);        # 4  (XX XXXX XXX XX XXX XX)
\&  print index("XX, XXX", "X");   # \-1 (\*(AqX\*(AqX XX)
\&  print index(\*(AqXX, XXX\*(Aq, \*(AqX\*(Aq);   # 7 (8XXX 9XX XXXX \*(AqX\*(AqX
\&                                            XXXX XXX.)
.Ve
.SS "X \s-1XXX XX XXX...\s0"
.IX Subsection "X XXX XX XXX..."
PerlX \s-1XXXX  XXX XXX XXX XX XX XX, X XXX XX\s0
Perl \s-1XX X XXX XXXX XX,\s0 EncodeX \s-1XXX XX XX XX
XX X XXXX.  XX X XXX XX XX XXX XX XXXX.\s0
.SS "Perl \s-1XX XX\s0"
.IX Subsection "Perl XX XX"
\&\s-1XXX XXX  XX XXX XXX XX XXX XXXX. X XXX XX
XXX XX XXX XX XXXX XX XX XXXX.\s0
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
.Vb 1
\&   O\*(AqReillyX Perl X XXX
.Ve
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
.Vb 1
\&        Comprehensive Perl Archive Network
.Ve
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
.Vb 2
\&  Perl XXX XXX. XX XXX XXX
\&  perl\-unicodeXX \*(AqEncode\*(AqX XX XXX.
.Ve
.SS "PerlX X \s-1XX XXXXX XXX X X XX XXX XX XXX\s0"
.IX Subsection "PerlX X XX XXXXX XXX X X XX XXX XX XXX"
.IP "<http://www.perl.or.kr/>" 4
.IX Item "<http://www.perl.or.kr/>"
.Vb 1
\&  Perl XX XXX XX
.Ve
.IP "<news:han.comp.lang.perl/>" 4
.IX Item "<news:han.comp.lang.perl/>"
.Vb 1
\&  XXX Perl XX XX
.Ve
.IP "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>" 4
.IX Item "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>"
.Vb 1
\&  O\*(AqReillyXX XX XXX Perl XX XX
.Ve
.IP "<http://www.perlschool.net/>" 4
.IX Item "<http://www.perlschool.net/>"
.Vb 1
\&  Perl XX XX X XX, XX XX, XX XX XXX XX
.Ve
.IP "<http://www.perl.co.kr>" 4
.IX Item "<http://www.perl.co.kr>"
.Vb 1
\&  PerlX XXX CGI, DB, XX XX XX  XX X XX XX
.Ve
.SS "\s-1XXXX X XXX XXX XX XX\s0"
.IX Subsection "XXXX X XXX XXX XX XX"
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.Vb 1
\&  XXXX XXXX.
.Ve
.IP "<http://std.dkuug.dk/JTC1/SC2/WG2>" 4
.IX Item "<http://std.dkuug.dk/JTC1/SC2/WG2>"
\&\s-1XXXXX\s0 UnicodeX \s-1XX ISO XXX  ISO/IEC 10646 UCS\s0(Universal
Character Set)X \s-1XXX  ISO/IEC JTC1/SC2/WG2X X XXX. \s0
.IP "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)
.Ve
.IP "<http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html>" 4
.IX Item "<http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)X  XXX XX
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::KR, encoding, perluniintro, perlunicode
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
\&\s-1XXX\s0 <jshin@mailaps.org>
                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlko5.16.1                                 0100644 0001750 0001750 00000025652 12566207421 022555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLKO 1"
.TH PERLKO 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlko \- PerlX XXX XXX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PerlX \s-1XXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XXXXX\s0 !
.PP
PerlX 5.8.0XXX \s-1XXXX/ISO\s0 10646X \s-1XX\s0 \s-1XXXX\s0 \s-1XXX\s0 \s-1XXX\s0.
\&\s-1XXXX\s0 \s-1XXX\s0 \s-1XXXX\s0 \s-1XXXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXXX\s0
\&\s-1XXXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXXX\s0
\&\s-1XXXXX\s0.  \s-1XXXXX\s0 X \s-1XXXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XX\s0 \-
\&\s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0, \s-1XX\s0 \s-1XXX\s0, \s-1XXX\s0 \s-1XXX\s0, \s-1XXX\s0 \s-1XX\s0 \s-1XXXX\s0
\&\s-1XXX\s0 \s-1XX\s0 \s-1XXXX\s0, \s-1XX\s0 \s-1XX\s0, \s-1XXX\s0 \s-1XX\s0, \s-1XXXX\s0 \s-1XX\s0, \s-1XXXX\s0 \s-1XX\s0,
\&\s-1XXXX\s0 \s-1XX\s0, \s-1XX\s0 \s-1XXXX\s0 \s-1XX\s0 \s-1XX\s0 X\-X \s-1XXXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0
\&\s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0 \s-1XXX\s0  X \s-1XX\s0 X \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0
\&\s-1XX\s0 \s-1XXX\s0 \s-1XXXX\s0 X X \s-1XX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXXX\s0  \s-1XX\s0 \s-1XX\s0 \s-1XXXX\s0
\&\s-1XXXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XXX\s0  \s-1XXXX\s0 \s-1XXXX\s0.
.PP
PerlX \s-1XXXXX\s0 \s-1XXXXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXXXX\s0. \s-1XX\s0 \s-1XXXXX\s0
\&\s-1XXX\s0 Perl \s-1XXXX\s0 \s-1XXX\s0  \s-1UTF\-8\s0 \s-1XXXX\s0 X X \s-1XX\s0, 
\&\s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0(\s-1XX\s0 \s-1XX\s0, \s-1XXX\s0, index, substr)X \s-1XXX\s0 \s-1XX\s0
\&\s-1XX\s0 \s-1XXXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXXXX\s0. (X \s-1XXX\s0 \s-1XX\s0 
perlunicode \s-1XXXX\s0 \s-1XXXXXX\s0.) \s-1XXXXX\s0 \s-1XX\s0 \s-1XXXX\s0 \s-1XX\s0
\&\s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0, \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XX/X\s0 \s-1XXX\s0 \s-1XXXXX\s0
\&\s-1XXXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XXXXX\s0 X \s-1XXXX\s0 \s-1XXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XX\s0
\&'Encode'X  \s-1XXXXX\s0. \s-1XXXX\s0 'Encode'X  \s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0 \s-1XXX\s0
\&\s-1XXX\s0 \s-1XX\s0 X X \s-1XXXX\s0.
.PP
\&'Encode'X \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXXX\s0 \s-1XXXXX\s0.
.IP "euc-kr" 4
.IX Item "euc-kr"
.Vb 2
\&  US\-ASCIIX KS X 1001X XX XX XXXXX XXX (XX XXXXXX
\&  XX.) KS X 2901X RFC 1557 XX.
.Ve
.IP "cp949" 4
.IX Item "cp949"
.Vb 4
\&        MS\-Windows 9x/MEXX XXX XX XXX.  euc\-krX 8,822XX
\&        XX XXX XX XX.  aliasX uhc, windows\-949, x\-windows\-949,
\&        ks_c_5601\-1987. X XXX XXX XXXX XX XXXXX, Microsoft
\&        XXXX CP949X XXX XXX XX.
.Ve
.IP "johab" 4
.IX Item "johab"
.Vb 3
\&        KS X 1001:1998 XX 3XX XXX XXX.  XX XXXXX cp949X
\&        XXXXX US\-ASCIIX  KS X 1001X 8,822XX XX XXX XX XX.
\&        XXX XXX XX XX.
.Ve
.IP "iso\-2022\-kr" 4
.IX Item "iso-2022-kr"
.Vb 3
\&        RFC 1557XX XXX XXX XXX XX XXX XXXXX US\-ASCIIX
\&        KS X 1001X XXXXX XX XXX euc\-krX XXX XXX XXX XX.
\&        1997\-8X XXX XXXX X XX XX XXX XXX XX.
.Ve
.IP "ksc5601\-raw" 4
.IX Item "ksc5601-raw"
.Vb 5
\&        KS X 1001(KS C 5601)X GL(X, MSBX 0XX X XX) X XXX XX
\&        XXX. US\-ASCIIX XXXX XX XXXX XXX XX X11 XXX XX
\&        XXX (ksc5601.1987\-0. \*(Aq0\*(AqX GLX XXX.)XX XXX XX XXXXX
\&        XX XX. KS C 5601X 1997X KS X 1001X XXX XXXX.  1998XXX  X
\&        XX (XXX XXX XX XX XX)X XXXX.
.Ve
.PP
.Vb 1
\& X XX XX XXX XXX XXXX.
.Ve
.PP
\&\s-1XX\s0 \s-1XX\s0, euc-kr \s-1XXXXX\s0 X \s-1XXX\s0 \s-1UTF\-8X\s0 \s-1XXXXX\s0 \s-1XXX\s0
\&\s-1XX\s0 \s-1XX\s0 \s-1XXX\s0.
.PP
.Vb 1
\&    perl \-Mencoding=euc\-kr,STDOUT,utf8 \-pe1  < file.euckr > file.utf8
.Ve
.PP
\&\s-1XXXX\s0 \s-1XXX\s0 \s-1XX\s0 X X \s-1XXXX\s0.
.PP
.Vb 1
\&    perl \-Mencoding=utf8,STDOUT,euc\-kr \-pe1  < file.utf8  > file.euckr
\&
\&  XX XXX XX XXXX X X XXX Encode XXX XX 
\&XXXX PerlXX XX piconvX PerlX XX XXXX.
\&X XXXX X X XXX piconvX UnixX XX iconvX
\&XXX X XXXX. X XXXX XXX XXXX.
\&
\&   piconv \-f euc\-kr \-t utf8 < file.euckr > file.utf8
\&   piconv \-f utf8 \-t euc\-kr < file.utf8 > file.euckr
\&
\&  X, \*(AqPerlIO::encoding\*(Aq XXX XX XXX XXXX XXX XX XX
\&(XXX XXX XXX) XXX XX X X XXXX.
\&
\&  #!/path/to/perl 
\&
\&  use encoding \*(Aqeuc\-kr\*(Aq, STDIN => \*(Aqeuc\-kr\*(Aq,
\&                         STDOUT\-> \*(Aqeuc\-kr\*(Aq, STDERR=>\*(Aqeuc\-kr\*(Aq;
\&
\&  print length("XX");        # 2  (X XXXX XX XX XXX XX)
\&  print length(\*(AqXX\*(Aq);        # 4  (XX XXXX XXX XX XXX XX)
\&  print index("XX, XXX", "X");   # \-1 (\*(AqX\*(AqX XX)
\&  print index(\*(AqXX, XXX\*(Aq, \*(AqX\*(Aq);   # 7 (8XXX 9XX XXXX \*(AqX\*(AqX
\&                                            XXXX XXX.)
.Ve
.SS "X \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0..."
.IX Subsection "X XXX XX XXX..."
.Vb 3
\&  PerlX XXXX  XXX XXX XXX XX XX XX, X XXX XX
\&Perl XX X XXX XXXX XX, EncodeX XXX XX XX XX
\&XX X XXXX.  XX X XXX XX XX XXX XX XXXX.
.Ve
.SS "Perl \s-1XX\s0 \s-1XX\s0"
.IX Subsection "Perl XX XX"
\&\s-1XXX\s0 \s-1XXX\s0  \s-1XX\s0 \s-1XXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XXXX\s0. X \s-1XXX\s0 \s-1XX\s0
\&\s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXXX\s0 \s-1XX\s0 \s-1XX\s0 \s-1XXXX\s0.
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
.Vb 1
\&   O\*(AqReillyX Perl X XXX
.Ve
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
.Vb 1
\&        Comprehensive Perl Archive Network
.Ve
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
.Vb 2
\&  Perl XXX XXX. XX XXX XXX
\&  perl\-unicodeXX \*(AqEncode\*(AqX XX XXX.
.Ve
.SS "PerlX X \s-1XX\s0 \s-1XXXXX\s0 \s-1XXX\s0 X X \s-1XX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XXX\s0"
.IX Subsection "PerlX X XX XXXXX XXX X X XX XXX XX XXX"
.IP "<http://www.perl.or.kr/>" 4
.IX Item "<http://www.perl.or.kr/>"
.Vb 1
\&  Perl XX XXX XX
.Ve
.IP "<news:han.comp.lang.perl/>" 4
.IX Item "<news:han.comp.lang.perl/>"
.Vb 1
\&  XXX Perl XX XX
.Ve
.IP "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>" 4
.IX Item "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>"
.Vb 1
\&  O\*(AqReillyXX XX XXX Perl XX XX
.Ve
.IP "<http://www.perlschool.net/>" 4
.IX Item "<http://www.perlschool.net/>"
.Vb 1
\&  Perl XX XX X XX, XX XX, XX XX XXX XX
.Ve
.IP "<http://www.perl.co.kr>" 4
.IX Item "<http://www.perl.co.kr>"
.Vb 1
\&  PerlX XXX CGI, DB, XX XX XX  XX X XX XX
.Ve
.SS "\s-1XXXX\s0 X \s-1XXX\s0 \s-1XXX\s0 \s-1XX\s0 \s-1XX\s0"
.IX Subsection "XXXX X XXX XXX XX XX"
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.Vb 1
\&  XXXX XXXX.
.Ve
.IP "<http://std.dkuug.dk/JTC1/SC2/WG2>" 4
.IX Item "<http://std.dkuug.dk/JTC1/SC2/WG2>"
\&\s-1XXXXX\s0 UnicodeX \s-1XX\s0 \s-1ISO\s0 \s-1XXX\s0  \s-1ISO/IEC\s0 10646 \s-1UCS\s0(Universal
Character Set)X \s-1XXX\s0  \s-1ISO/IEC\s0 \s-1JTC1/SC2/WG2X\s0 X \s-1XXX\s0.
.IP "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)
.Ve
.IP "http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html <http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>" 4
.IX Item "http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html <http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)X  XXX XX
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::KR, encoding, perluniintro, perlunicode
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
\&\s-1XXX\s0 <jshin@mailaps.org>
                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlko5.18.1                                 0100644 0001750 0001750 00000023400 12566207441 022546  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLKO 1"
.TH PERLKO 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
X \s-1XXX\s0 perldocX \s-1XX XX XX XX XX XXXX X XXX
XXX XXXX XX XX\s0 =head, =item, 'L' \s-1XX XXXXXX.
X XXX XX\s0 perldocX \s-1XX XX XXXX XXX X XXX
XX POD XXXX XX XXXX.  X XXX XX\s0 perlpod
\&\s-1XXXX XXXXXX. \s0
.SH "NAME"
perlko \- PerlX XXX XXX
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PerlX \s-1XXX XX XX XXXXX \s0!
.PP
PerlX 5.8.0XXX \s-1XXXX/ISO 10646X XX XXXX XXX XXX.
XXXX XXX XXXX XXXX XXX XX XXXX
XXXX XXX XX XXX XXX XX XXX XX XXX XXXX
XXXXX.  XXXXX X XXXX XXX XX XXX XX XX XX \-
XXX XX XXX, XX XXX, XXX XXX, XXX XX XXXX
XXX XX XXXX, XX XX, XXX XX, XXXX XX, XXXX XX,
XXXX XX, XX XXXX XX XX X\-X XXXX XX XXX XX
XX XXX XXX XXX  X XX X XX XXX XX XXX XXX
XX XXX XXXX X X XX XX XXX XXXX  XX XX XXXX
XXXX XX XX XX XX XXX  XXXX XXXX.\s0
.PP
PerlX \s-1XXXXX XXXXX XX XXX XX XXXXX. XX XXXXX
XXX\s0 Perl \s-1XXXX XXX  UTF\-8 XXXX X X XX, 
XX XXX XXX\s0(\s-1XX XX, XXX,\s0 index, substr)X \s-1XXX XX
XX XXXX XX XXX XXXXX. \s0(X \s-1XXX XX \s0
perlunicode \s-1XXXX XXXXXX.\s0) \s-1XXXXX XX XXXX XX
XX XXX XXX, XXX XX XXX XX XX/X XXX XXXXX
XXXX XX XX XXXXX X XXXX XXX XXX XX XX XX
\&\s0'Encode'X  \s-1XXXXX. XXXX \s0'Encode'X  \s-1XX XXX XXX XXX
XXX XX X X XXXX.\s0
.PP
\&'Encode'X \s-1XXX XX XXX XXXX XXXXX.\s0
.IP "\(bu" 4
euc-kr
.Sp
US-ASCIIX \s-1KS X 1001X XX XX XXXXX XXX \s0(\s-1XX XXXXXX
XX.\s0) \s-1KS X 2901X RFC 1557 XX.\s0
.IP "\(bu" 4
cp949
.Sp
MS-Windows 9x/MEXX \s-1XXX XX XXX. \s0 euc-krX 8,822XX
\&\s-1XX XXX XX XX. \s0 aliasX uhc, windows\-949, x\-windows\-949,
ks_c_5601\-1987. X \s-1XXX XXX XXXX XX XXXXX,\s0 Microsoft
\&\s-1XXXX CP949X XXX XXX XX.\s0
.IP "\(bu" 4
johab
.Sp
\&\s-1KS X 1001:1998 XX 3XX XXX XXX.  XX XXXXX\s0 cp949X
\&\s-1XXXXX\s0 US-ASCIIX  \s-1KS X 1001X 8,822XX XX XXX XX XX.
XXX XXX XX XX. \s0
.IP "\(bu" 4
iso\-2022\-kr
.Sp
\&\s-1RFC 1557XX XXX XXX XXX XX XXX XXXXX\s0 US-ASCIIX
\&\s-1KS X 1001X XXXXX XX XXX\s0 euc-krX \s-1XXX XXX XXX XX.
1997\-8X XXX XXXX X XX XX XXX XXX XX.\s0
.IP "\(bu" 4
ksc5601\-raw
.Sp
\&\s-1KS X 1001\s0(\s-1KS C 5601\s0)X \s-1GL\s0(X, \s-1MSBX 0XX X XX\s0) X \s-1XXX XX
XXX.\s0 US-ASCIIX \s-1XXXX XX XXXX XXX XX X11 XXX XX
XXX \s0(ksc5601.1987\-0. '0'X \s-1GLX XXX.\s0)XX \s-1XXX XX XXXXX
XX XX. KS C 5601X 1997X KS X 1001X XXX XXXX.  1998XXX  X
XX \s0(\s-1XXX XXX XX XX XX\s0)X \s-1XXXX.\s0
.PP
X \s-1XX XX XXX XXX XXXX. \s0
.PP
\&\s-1XX XX,\s0 euc-kr \s-1XXXXX X XXX UTF\-8X XXXXX XXX
XX XX XXX. \s0
.PP
.Vb 1
\&    perl \-Mencoding=euc\-kr,STDOUT,utf8 \-pe1  < file.euckr > file.utf8
.Ve
.PP
\&\s-1XXXX XXX XX X X XXXX. \s0
.PP
.Vb 1
\&    perl \-Mencoding=utf8,STDOUT,euc\-kr \-pe1  < file.utf8  > file.euckr
.Ve
.PP
\&\s-1XX XXX XX XXXX X X XXX\s0 Encode \s-1XXX XX 
XXXX\s0 PerlXX \s-1XX\s0 piconvX PerlX \s-1XX XXXX.
X XXXX X X XXX\s0 piconvX UnixX \s-1XX\s0 iconvX
\&\s-1XXX X XXXX. X XXXX XXX XXXX.\s0
.PP
.Vb 2
\&   piconv \-f euc\-kr \-t utf8 < file.euckr > file.utf8
\&   piconv \-f utf8 \-t euc\-kr < file.utf8 > file.euckr
.Ve
.PP
X, 'PerlIO::encoding' \s-1XXX XX XXX XXXX XXX XX XX
\&\s0(\s-1XXX XXX XXX\s0) \s-1XXX XX X X XXXX.\s0
.PP
.Vb 1
\&  #!/path/to/perl 
\&
\&  use encoding \*(Aqeuc\-kr\*(Aq, STDIN => \*(Aqeuc\-kr\*(Aq,
\&                         STDOUT\-> \*(Aqeuc\-kr\*(Aq, STDERR=>\*(Aqeuc\-kr\*(Aq;
\&
\&  print length("XX");        # 2  (X XXXX XX XX XXX XX)
\&  print length(\*(AqXX\*(Aq);        # 4  (XX XXXX XXX XX XXX XX)
\&  print index("XX, XXX", "X");   # \-1 (\*(AqX\*(AqX XX)
\&  print index(\*(AqXX, XXX\*(Aq, \*(AqX\*(Aq);   # 7 (8XXX 9XX XXXX \*(AqX\*(AqX
\&                                            XXXX XXX.)
.Ve
.SS "X \s-1XXX XX XXX...\s0"
.IX Subsection "X XXX XX XXX..."
PerlX \s-1XXXX  XXX XXX XXX XX XX XX, X XXX XX\s0
Perl \s-1XX X XXX XXXX XX,\s0 EncodeX \s-1XXX XX XX XX
XX X XXXX.  XX X XXX XX XX XXX XX XXXX.\s0
.SS "Perl \s-1XX XX\s0"
.IX Subsection "Perl XX XX"
\&\s-1XXX XXX  XX XXX XXX XX XXX XXXX. X XXX XX
XXX XX XXX XX XXXX XX XX XXXX.\s0
.IP "<http://www.perl.com/>" 4
.IX Item "<http://www.perl.com/>"
.Vb 1
\&   O\*(AqReillyX Perl X XXX
.Ve
.IP "<http://www.cpan.org/>" 4
.IX Item "<http://www.cpan.org/>"
.Vb 1
\&        Comprehensive Perl Archive Network
.Ve
.IP "<http://lists.perl.org/>" 4
.IX Item "<http://lists.perl.org/>"
.Vb 2
\&  Perl XXX XXX. XX XXX XXX
\&  perl\-unicodeXX \*(AqEncode\*(AqX XX XXX.
.Ve
.SS "PerlX X \s-1XX XXXXX XXX X X XX XXX XX XXX\s0"
.IX Subsection "PerlX X XX XXXXX XXX X X XX XXX XX XXX"
.IP "<http://www.perl.or.kr/>" 4
.IX Item "<http://www.perl.or.kr/>"
.Vb 1
\&  Perl XX XXX XX
.Ve
.IP "<news:han.comp.lang.perl/>" 4
.IX Item "<news:han.comp.lang.perl/>"
.Vb 1
\&  XXX Perl XX XX
.Ve
.IP "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>" 4
.IX Item "<http://www.hanb.co.kr/search/searchResult.html?keyword=perl>"
.Vb 1
\&  O\*(AqReillyXX XX XXX Perl XX XX
.Ve
.IP "<http://www.perlschool.net/>" 4
.IX Item "<http://www.perlschool.net/>"
.Vb 1
\&  Perl XX XX X XX, XX XX, XX XX XXX XX
.Ve
.IP "<http://www.perl.co.kr>" 4
.IX Item "<http://www.perl.co.kr>"
.Vb 1
\&  PerlX XXX CGI, DB, XX XX XX  XX X XX XX
.Ve
.SS "\s-1XXXX X XXX XXX XX XX\s0"
.IX Subsection "XXXX X XXX XXX XX XX"
.IP "<http://www.unicode.org/>" 4
.IX Item "<http://www.unicode.org/>"
.Vb 1
\&  XXXX XXXX.
.Ve
.IP "<http://std.dkuug.dk/JTC1/SC2/WG2>" 4
.IX Item "<http://std.dkuug.dk/JTC1/SC2/WG2>"
\&\s-1XXXXX\s0 UnicodeX \s-1XX ISO XXX  ISO/IEC 10646 UCS\s0(Universal
Character Set)X \s-1XXX  ISO/IEC JTC1/SC2/WG2X X XXX. \s0
.IP "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>" 4
.IX Item "<http://www.cl.cam.ac.uk/~mgk25/unicode.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)
.Ve
.IP "<http://wiki.kldp.org/Translations/html/UTF8\-Unicode\-KLDP/UTF8\-Unicode\-KLDP.html>" 4
.IX Item "<http://wiki.kldp.org/Translations/html/UTF8-Unicode-KLDP/UTF8-Unicode-KLDP.html>"
.Vb 1
\&  XXX/XXXXX XXXXX UTF\-8 XXX XX XXX(FAQ)X  XXX XX
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::KR, encoding, perluniintro, perlunicode
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
\&\s-1XXX\s0 <jshin@mailaps.org>
                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllexwarn.1                                0100644 0001750 0001750 00000052612 12566207441 023310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLEXWARN 1"
.TH PERLLEXWARN 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllexwarn \- Perl Lexical Warnings
.IX Xref "warning, lexical warnings warning"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use warnings\*(C'\fR pragma enables to control precisely what warnings are
to be enabled in which parts of a Perl program. It's a more flexible
alternative for both the command line flag \fB\-w\fR and the equivalent Perl
variable, \f(CW$^W\fR.
.PP
This pragma works just like the \f(CW\*(C`strict\*(C'\fR pragma.
This means that the scope of the warning pragma is limited to the
enclosing block. It also means that the pragma setting will not
leak across files (via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR). This allows
authors to independently define the degree of warning checks that will
be applied to their module.
.PP
By default, optional warnings are disabled, so any legacy code that
doesn't attempt to control the warnings will work unchanged.
.PP
All warnings are enabled in a block by either of these:
.PP
.Vb 2
\&    use warnings;
\&    use warnings \*(Aqall\*(Aq;
.Ve
.PP
Similarly all warnings are disabled in a block by either of these:
.PP
.Vb 2
\&    no warnings;
\&    no warnings \*(Aqall\*(Aq;
.Ve
.PP
For example, consider the code below:
.PP
.Vb 7
\&    use warnings;
\&    my @a;
\&    {
\&        no warnings;
\&        my $b = @a[0];
\&    }
\&    my $c = @a[0];
.Ve
.PP
The code in the enclosing block has warnings enabled, but the inner
block has them disabled. In this case that means the assignment to the
scalar \f(CW$c\fR will trip the \f(CW"Scalar value @a[0] better written as $a[0]"\fR
warning, but the assignment to the scalar \f(CW$b\fR will not.
.SS "Default Warnings and Optional Warnings"
.IX Subsection "Default Warnings and Optional Warnings"
Before the introduction of lexical warnings, Perl had two classes of
warnings: mandatory and optional.
.PP
As its name suggests, if your code tripped a mandatory warning, you
would get a warning whether you wanted it or not.
For example, the code below would always produce an \f(CW"isn\*(Aqt numeric"\fR
warning about the \*(L"2:\*(R".
.PP
.Vb 1
\&    my $a = "2:" + 3;
.Ve
.PP
With the introduction of lexical warnings, mandatory warnings now become
\&\fIdefault\fR warnings. The difference is that although the previously
mandatory warnings are still enabled by default, they can then be
subsequently enabled or disabled with the lexical warning pragma. For
example, in the code below, an \f(CW"isn\*(Aqt numeric"\fR warning will only
be reported for the \f(CW$a\fR variable.
.PP
.Vb 3
\&    my $a = "2:" + 3;
\&    no warnings;
\&    my $b = "2:" + 3;
.Ve
.PP
Note that neither the \fB\-w\fR flag or the \f(CW$^W\fR can be used to
disable/enable default warnings. They are still mandatory in this case.
.ie n .SS "What's wrong with \fB\-w\fP and $^W"
.el .SS "What's wrong with \fB\-w\fP and \f(CW$^W\fP"
.IX Subsection "What's wrong with -w and $^W"
Although very useful, the big problem with using \fB\-w\fR on the command
line to enable warnings is that it is all or nothing. Take the typical
scenario when you are writing a Perl program. Parts of the code you
will write yourself, but it's very likely that you will make use of
pre-written Perl modules. If you use the \fB\-w\fR flag in this case, you
end up enabling warnings in pieces of code that you haven't written.
.PP
Similarly, using \f(CW$^W\fR to either disable or enable blocks of code is
fundamentally flawed. For a start, say you want to disable warnings in
a block of code. You might expect this to be enough to do the trick:
.PP
.Vb 5
\&     {
\&         local ($^W) = 0;
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
When this code is run with the \fB\-w\fR flag, a warning will be produced
for the \f(CW$a\fR line:  \f(CW"Reversed += operator"\fR.
.PP
The problem is that Perl has both compile-time and run-time warnings. To
disable compile-time warnings you need to rewrite the code like this:
.PP
.Vb 5
\&     {
\&         BEGIN { $^W = 0 }
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
The other big problem with \f(CW$^W\fR is the way you can inadvertently
change the warning setting in unexpected places in your code. For example,
when the code below is run (without the \fB\-w\fR flag), the second call
to \f(CW\*(C`doit\*(C'\fR will trip a \f(CW"Use of uninitialized value"\fR warning, whereas
the first will not.
.PP
.Vb 4
\&    sub doit
\&    {
\&        my $b; chop $b;
\&    }
\&
\&    doit();
\&
\&    {
\&        local ($^W) = 1;
\&        doit()
\&    }
.Ve
.PP
This is a side-effect of \f(CW$^W\fR being dynamically scoped.
.PP
Lexical warnings get around these limitations by allowing finer control
over where warnings can or can't be tripped.
.SS "Controlling Warnings from the Command Line"
.IX Subsection "Controlling Warnings from the Command Line"
There are three Command Line flags that can be used to control when
warnings are (or aren't) produced:
.IP "\fB\-w\fR" 5
.IX Xref "-w"
.IX Item "-w"
This is  the existing flag. If the lexical warnings pragma is \fBnot\fR
used in any of you code, or any of the modules that you use, this flag
will enable warnings everywhere. See \*(L"Backward Compatibility\*(R" for
details of how this flag interacts with lexical warnings.
.IP "\fB\-W\fR" 5
.IX Xref "-W"
.IX Item "-W"
If the \fB\-W\fR flag is used on the command line, it will enable all warnings
throughout the program regardless of whether warnings were disabled
locally using \f(CW\*(C`no warnings\*(C'\fR or \f(CW\*(C`$^W =0\*(C'\fR. This includes all files that get
included via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR.
Think of it as the Perl equivalent of the \*(L"lint\*(R" command.
.IP "\fB\-X\fR" 5
.IX Xref "-X"
.IX Item "-X"
Does the exact opposite to the \fB\-W\fR flag, i.e. it disables all warnings.
.SS "Backward Compatibility"
.IX Subsection "Backward Compatibility"
If you are used to working with a version of Perl prior to the
introduction of lexically scoped warnings, or have code that uses both
lexical warnings and \f(CW$^W\fR, this section will describe how they interact.
.PP
How Lexical Warnings interact with \fB\-w\fR/\f(CW$^W\fR:
.IP "1." 5
If none of the three command line flags (\fB\-w\fR, \fB\-W\fR or \fB\-X\fR) that
control warnings is used and neither \f(CW$^W\fR nor the \f(CW\*(C`warnings\*(C'\fR pragma
are used, then default warnings will be enabled and optional warnings
disabled.
This means that legacy code that doesn't attempt to control the warnings
will work unchanged.
.IP "2." 5
The \fB\-w\fR flag just sets the global \f(CW$^W\fR variable as in 5.005. This
means that any legacy code that currently relies on manipulating \f(CW$^W\fR
to control warning behavior will still work as is.
.IP "3." 5
Apart from now being a boolean, the \f(CW$^W\fR variable operates in exactly
the same horrible uncontrolled global way, except that it cannot
disable/enable default warnings.
.IP "4." 5
If a piece of code is under the control of the \f(CW\*(C`warnings\*(C'\fR pragma,
both the \f(CW$^W\fR variable and the \fB\-w\fR flag will be ignored for the
scope of the lexical warning.
.IP "5." 5
The only way to override a lexical warnings setting is with the \fB\-W\fR
or \fB\-X\fR command line flags.
.PP
The combined effect of 3 & 4 is that it will allow code which uses
the \f(CW\*(C`warnings\*(C'\fR pragma to control the warning behavior of $^W\-type
code (using a \f(CW\*(C`local $^W=0\*(C'\fR) if it really wants to, but not vice-versa.
.SS "Category Hierarchy"
.IX Xref "warning, categories"
.IX Subsection "Category Hierarchy"
A hierarchy of \*(L"categories\*(R" have been defined to allow groups of warnings
to be enabled/disabled in isolation.
.PP
The current hierarchy is:
.PP
.Vb 10
\&    all \-+
\&         |
\&         +\- closure
\&         |
\&         +\- deprecated
\&         |
\&         +\- exiting
\&         |
\&         +\- experimental \-\-+
\&         |                 |
\&         |                 +\- experimental::lexical_subs
\&         |
\&         +\- glob
\&         |
\&         +\- imprecision
\&         |
\&         +\- io \-\-\-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- closed
\&         |                 |
\&         |                 +\- exec
\&         |                 |
\&         |                 +\- layer
\&         |                 |
\&         |                 +\- newline
\&         |                 |
\&         |                 +\- pipe
\&         |                 |
\&         |                 +\- unopened
\&         |
\&         +\- misc
\&         |
\&         +\- numeric
\&         |
\&         +\- once
\&         |
\&         +\- overflow
\&         |
\&         +\- pack
\&         |
\&         +\- portable
\&         |
\&         +\- recursion
\&         |
\&         +\- redefine
\&         |
\&         +\- regexp
\&         |
\&         +\- severe \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- debugging
\&         |                 |
\&         |                 +\- inplace
\&         |                 |
\&         |                 +\- internal
\&         |                 |
\&         |                 +\- malloc
\&         |
\&         +\- signal
\&         |
\&         +\- substr
\&         |
\&         +\- syntax \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- ambiguous
\&         |                 |
\&         |                 +\- bareword
\&         |                 |
\&         |                 +\- digit
\&         |                 |
\&         |                 +\- illegalproto
\&         |                 |
\&         |                 +\- parenthesis
\&         |                 |
\&         |                 +\- precedence
\&         |                 |
\&         |                 +\- printf
\&         |                 |
\&         |                 +\- prototype
\&         |                 |
\&         |                 +\- qw
\&         |                 |
\&         |                 +\- reserved
\&         |                 |
\&         |                 +\- semicolon
\&         |
\&         +\- taint
\&         |
\&         +\- threads
\&         |
\&         +\- uninitialized
\&         |
\&         +\- unpack
\&         |
\&         +\- untie
\&         |
\&         +\- utf8 \-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- non_unicode
\&         |                 |
\&         |                 +\- nonchar
\&         |                 |
\&         |                 +\- surrogate
\&         |
\&         +\- void
.Ve
.PP
Just like the \*(L"strict\*(R" pragma any of these categories can be combined
.PP
.Vb 2
\&    use warnings qw(void redefine);
\&    no warnings qw(io syntax untie);
.Ve
.PP
Also like the \*(L"strict\*(R" pragma, if there is more than one instance of the
\&\f(CW\*(C`warnings\*(C'\fR pragma in a given scope the cumulative effect is additive.
.PP
.Vb 5
\&    use warnings qw(void); # only "void" warnings enabled
\&    ...
\&    use warnings qw(io);   # only "void" & "io" warnings enabled
\&    ...
\&    no warnings qw(void);  # only "io" warnings enabled
.Ve
.PP
To determine which category a specific warning has been assigned to see
perldiag.
.PP
Note: In Perl 5.6.1, the lexical warnings category \*(L"deprecated\*(R" was a
sub-category of the \*(L"syntax\*(R" category. It is now a top-level category
in its own right.
.SS "Fatal Warnings"
.IX Xref "warning, fatal"
.IX Subsection "Fatal Warnings"
The presence of the word \*(L"\s-1FATAL\*(R"\s0 in the category list will escalate any
warnings detected from the categories specified in the lexical scope
into fatal errors. In the code below, the use of \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`length\*(C'\fR
and \f(CW\*(C`join\*(C'\fR can all produce a \f(CW"Useless use of xxx in void context"\fR
warning.
.PP
.Vb 1
\&    use warnings;
\&
\&    time;
\&
\&    {
\&        use warnings FATAL => qw(void);
\&        length "abc";
\&    }
\&
\&    join "", 1,2,3;
\&
\&    print "done\en";
.Ve
.PP
When run it produces this output
.PP
.Vb 2
\&    Useless use of time in void context at fatal line 3.
\&    Useless use of length in void context at fatal line 7.
.Ve
.PP
The scope where \f(CW\*(C`length\*(C'\fR is used has escalated the \f(CW\*(C`void\*(C'\fR warnings
category into a fatal error, so the program terminates immediately it
encounters the warning.
.PP
To explicitly turn off a \*(L"\s-1FATAL\*(R"\s0 warning you just disable the warning
it is associated with.  So, for example, to disable the \*(L"void\*(R" warning
in the example above, either of these will do the trick:
.PP
.Vb 2
\&    no warnings qw(void);
\&    no warnings FATAL => qw(void);
.Ve
.PP
If you want to downgrade a warning that has been escalated into a fatal
error back to a normal warning, you can use the \*(L"\s-1NONFATAL\*(R"\s0 keyword. For
example, the code below will promote all warnings into fatal errors,
except for those in the \*(L"syntax\*(R" category.
.PP
.Vb 1
\&    use warnings FATAL => \*(Aqall\*(Aq, NONFATAL => \*(Aqsyntax\*(Aq;
.Ve
.SS "Reporting Warnings from a Module"
.IX Xref "warning, reporting warning, registering"
.IX Subsection "Reporting Warnings from a Module"
The \f(CW\*(C`warnings\*(C'\fR pragma provides a number of functions that are useful for
module authors. These are used when you want to report a module-specific
warning to a calling module has enabled warnings via the \f(CW\*(C`warnings\*(C'\fR
pragma.
.PP
Consider the module \f(CW\*(C`MyMod::Abc\*(C'\fR below.
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    use warnings::register;
\&
\&    sub open {
\&        my $path = shift;
\&        if ($path !~ m#^/#) {
\&            warnings::warn("changing relative path to /var/abc")
\&                if warnings::enabled();
\&            $path = "/var/abc/$path";
\&        }
\&    }
\&
\&    1;
.Ve
.PP
The call to \f(CW\*(C`warnings::register\*(C'\fR will create a new warnings category
called \*(L"MyMod::Abc\*(R", i.e. the new category name matches the current
package name. The \f(CW\*(C`open\*(C'\fR function in the module will display a warning
message if it gets given a relative path as a parameter. This warnings
will only be displayed if the code that uses \f(CW\*(C`MyMod::Abc\*(C'\fR has actually
enabled them with the \f(CW\*(C`warnings\*(C'\fR pragma like below.
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    abc::open("../fred.txt");
.Ve
.PP
It is also possible to test whether the pre-defined warnings categories are
set in the calling module with the \f(CW\*(C`warnings::enabled\*(C'\fR function. Consider
this snippet of code:
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    sub open {
\&        warnings::warnif("deprecated", 
\&                         "open is deprecated, use new instead");
\&        new(@_);
\&    }
\&
\&    sub new
\&    ...
\&    1;
.Ve
.PP
The function \f(CW\*(C`open\*(C'\fR has been deprecated, so code has been included to
display a warning message whenever the calling module has (at least) the
\&\*(L"deprecated\*(R" warnings category enabled. Something like this, say.
.PP
.Vb 4
\&    use warnings \*(Aqdeprecated\*(Aq;
\&    use MyMod::Abc;
\&    ...
\&    MyMod::Abc::open($filename);
.Ve
.PP
Either the \f(CW\*(C`warnings::warn\*(C'\fR or \f(CW\*(C`warnings::warnif\*(C'\fR function should be
used to actually display the warnings message. This is because they can
make use of the feature that allows warnings to be escalated into fatal
errors. So in this case
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings FATAL => \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    MyMod::Abc::open(\*(Aq../fred.txt\*(Aq);
.Ve
.PP
the \f(CW\*(C`warnings::warnif\*(C'\fR function will detect this and die after
displaying the warning message.
.PP
The three warnings functions, \f(CW\*(C`warnings::warn\*(C'\fR, \f(CW\*(C`warnings::warnif\*(C'\fR
and \f(CW\*(C`warnings::enabled\*(C'\fR can optionally take an object reference in place
of a category name. In this case the functions will use the class name
of the object as the warnings category.
.PP
Consider this example:
.PP
.Vb 1
\&    package Original;
\&
\&    no warnings;
\&    use warnings::register;
\&
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&    sub check
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&
\&        if ($value % 2 && warnings::enabled($self))
\&          { warnings::warn($self, "Odd numbers are unsafe") }
\&    }
\&
\&    sub doit
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&        $self\->check($value);
\&        # ...
\&    }
\&
\&    1;
\&
\&    package Derived;
\&
\&    use warnings::register;
\&    use Original;
\&    our @ISA = qw( Original );
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&
\&    1;
.Ve
.PP
The code below makes use of both modules, but it only enables warnings from 
\&\f(CW\*(C`Derived\*(C'\fR.
.PP
.Vb 7
\&    use Original;
\&    use Derived;
\&    use warnings \*(AqDerived\*(Aq;
\&    my $a = Original\->new();
\&    $a\->doit(1);
\&    my $b = Derived\->new();
\&    $a\->doit(1);
.Ve
.PP
When this code is run only the \f(CW\*(C`Derived\*(C'\fR object, \f(CW$b\fR, will generate
a warning.
.PP
.Vb 1
\&    Odd numbers are unsafe at main.pl line 7
.Ve
.PP
Notice also that the warning is reported at the line where the object is first
used.
.PP
When registering new categories of warning, you can supply more names to
warnings::register like this:
.PP
.Vb 2
\&    package MyModule;
\&    use warnings::register qw(format precision);
\&
\&    ...
\&
\&    warnings::warnif(\*(AqMyModule::format\*(Aq, \*(Aq...\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, perldiag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess
                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllexwarn5.16.1                            0100644 0001750 0001750 00000051456 12566207421 023625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLEXWARN 1"
.TH PERLLEXWARN 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllexwarn \- Perl Lexical Warnings
.IX Xref "warning, lexical warnings warning"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use warnings\*(C'\fR pragma enables to control precisely what warnings are
to be enabled in which parts of a Perl program. It's a more flexible
alternative for both the command line flag \fB\-w\fR and the equivalent Perl
variable, \f(CW$^W\fR.
.PP
This pragma works just like the \f(CW\*(C`strict\*(C'\fR pragma.
This means that the scope of the warning pragma is limited to the
enclosing block. It also means that the pragma setting will not
leak across files (via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR). This allows
authors to independently define the degree of warning checks that will
be applied to their module.
.PP
By default, optional warnings are disabled, so any legacy code that
doesn't attempt to control the warnings will work unchanged.
.PP
All warnings are enabled in a block by either of these:
.PP
.Vb 2
\&    use warnings;
\&    use warnings \*(Aqall\*(Aq;
.Ve
.PP
Similarly all warnings are disabled in a block by either of these:
.PP
.Vb 2
\&    no warnings;
\&    no warnings \*(Aqall\*(Aq;
.Ve
.PP
For example, consider the code below:
.PP
.Vb 7
\&    use warnings;
\&    my @a;
\&    {
\&        no warnings;
\&        my $b = @a[0];
\&    }
\&    my $c = @a[0];
.Ve
.PP
The code in the enclosing block has warnings enabled, but the inner
block has them disabled. In this case that means the assignment to the
scalar \f(CW$c\fR will trip the \f(CW"Scalar value @a[0] better written as $a[0]"\fR
warning, but the assignment to the scalar \f(CW$b\fR will not.
.SS "Default Warnings and Optional Warnings"
.IX Subsection "Default Warnings and Optional Warnings"
Before the introduction of lexical warnings, Perl had two classes of
warnings: mandatory and optional.
.PP
As its name suggests, if your code tripped a mandatory warning, you
would get a warning whether you wanted it or not.
For example, the code below would always produce an \f(CW"isn\*(Aqt numeric"\fR
warning about the \*(L"2:\*(R".
.PP
.Vb 1
\&    my $a = "2:" + 3;
.Ve
.PP
With the introduction of lexical warnings, mandatory warnings now become
\&\fIdefault\fR warnings. The difference is that although the previously
mandatory warnings are still enabled by default, they can then be
subsequently enabled or disabled with the lexical warning pragma. For
example, in the code below, an \f(CW"isn\*(Aqt numeric"\fR warning will only
be reported for the \f(CW$a\fR variable.
.PP
.Vb 3
\&    my $a = "2:" + 3;
\&    no warnings;
\&    my $b = "2:" + 3;
.Ve
.PP
Note that neither the \fB\-w\fR flag or the \f(CW$^W\fR can be used to
disable/enable default warnings. They are still mandatory in this case.
.ie n .SS "What's wrong with \fB\-w\fP and $^W"
.el .SS "What's wrong with \fB\-w\fP and \f(CW$^W\fP"
.IX Subsection "What's wrong with -w and $^W"
Although very useful, the big problem with using \fB\-w\fR on the command
line to enable warnings is that it is all or nothing. Take the typical
scenario when you are writing a Perl program. Parts of the code you
will write yourself, but it's very likely that you will make use of
pre-written Perl modules. If you use the \fB\-w\fR flag in this case, you
end up enabling warnings in pieces of code that you haven't written.
.PP
Similarly, using \f(CW$^W\fR to either disable or enable blocks of code is
fundamentally flawed. For a start, say you want to disable warnings in
a block of code. You might expect this to be enough to do the trick:
.PP
.Vb 5
\&     {
\&         local ($^W) = 0;
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
When this code is run with the \fB\-w\fR flag, a warning will be produced
for the \f(CW$a\fR line:  \f(CW"Reversed += operator"\fR.
.PP
The problem is that Perl has both compile-time and run-time warnings. To
disable compile-time warnings you need to rewrite the code like this:
.PP
.Vb 5
\&     {
\&         BEGIN { $^W = 0 }
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
The other big problem with \f(CW$^W\fR is the way you can inadvertently
change the warning setting in unexpected places in your code. For example,
when the code below is run (without the \fB\-w\fR flag), the second call
to \f(CW\*(C`doit\*(C'\fR will trip a \f(CW"Use of uninitialized value"\fR warning, whereas
the first will not.
.PP
.Vb 4
\&    sub doit
\&    {
\&        my $b; chop $b;
\&    }
\&
\&    doit();
\&
\&    {
\&        local ($^W) = 1;
\&        doit()
\&    }
.Ve
.PP
This is a side-effect of \f(CW$^W\fR being dynamically scoped.
.PP
Lexical warnings get around these limitations by allowing finer control
over where warnings can or can't be tripped.
.SS "Controlling Warnings from the Command Line"
.IX Subsection "Controlling Warnings from the Command Line"
There are three Command Line flags that can be used to control when
warnings are (or aren't) produced:
.IP "\fB\-w\fR" 5
.IX Xref "-w"
.IX Item "-w"
This is  the existing flag. If the lexical warnings pragma is \fBnot\fR
used in any of you code, or any of the modules that you use, this flag
will enable warnings everywhere. See \*(L"Backward Compatibility\*(R" for
details of how this flag interacts with lexical warnings.
.IP "\fB\-W\fR" 5
.IX Xref "-W"
.IX Item "-W"
If the \fB\-W\fR flag is used on the command line, it will enable all warnings
throughout the program regardless of whether warnings were disabled
locally using \f(CW\*(C`no warnings\*(C'\fR or \f(CW\*(C`$^W =0\*(C'\fR. This includes all files that get
included via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR.
Think of it as the Perl equivalent of the \*(L"lint\*(R" command.
.IP "\fB\-X\fR" 5
.IX Xref "-X"
.IX Item "-X"
Does the exact opposite to the \fB\-W\fR flag, i.e. it disables all warnings.
.SS "Backward Compatibility"
.IX Subsection "Backward Compatibility"
If you are used to working with a version of Perl prior to the
introduction of lexically scoped warnings, or have code that uses both
lexical warnings and \f(CW$^W\fR, this section will describe how they interact.
.PP
How Lexical Warnings interact with \fB\-w\fR/\f(CW$^W\fR:
.IP "1." 5
If none of the three command line flags (\fB\-w\fR, \fB\-W\fR or \fB\-X\fR) that
control warnings is used and neither \f(CW$^W\fR nor the \f(CW\*(C`warnings\*(C'\fR pragma
are used, then default warnings will be enabled and optional warnings
disabled.
This means that legacy code that doesn't attempt to control the warnings
will work unchanged.
.IP "2." 5
The \fB\-w\fR flag just sets the global \f(CW$^W\fR variable as in 5.005. This
means that any legacy code that currently relies on manipulating \f(CW$^W\fR
to control warning behavior will still work as is.
.IP "3." 5
Apart from now being a boolean, the \f(CW$^W\fR variable operates in exactly
the same horrible uncontrolled global way, except that it cannot
disable/enable default warnings.
.IP "4." 5
If a piece of code is under the control of the \f(CW\*(C`warnings\*(C'\fR pragma,
both the \f(CW$^W\fR variable and the \fB\-w\fR flag will be ignored for the
scope of the lexical warning.
.IP "5." 5
The only way to override a lexical warnings setting is with the \fB\-W\fR
or \fB\-X\fR command line flags.
.PP
The combined effect of 3 & 4 is that it will allow code which uses
the \f(CW\*(C`warnings\*(C'\fR pragma to control the warning behavior of $^W\-type
code (using a \f(CW\*(C`local $^W=0\*(C'\fR) if it really wants to, but not vice-versa.
.SS "Category Hierarchy"
.IX Xref "warning, categories"
.IX Subsection "Category Hierarchy"
A hierarchy of \*(L"categories\*(R" have been defined to allow groups of warnings
to be enabled/disabled in isolation.
.PP
The current hierarchy is:
.PP
.Vb 10
\&  all \-+
\&       |
\&       +\- closure
\&       |
\&       +\- deprecated
\&       |
\&       +\- exiting
\&       |
\&       +\- glob
\&       |
\&       +\- io \-\-\-\-\-\-\-\-\-\-\-+
\&       |                |
\&       |                +\- closed
\&       |                |
\&       |                +\- exec
\&       |                |
\&       |                +\- layer
\&       |                |
\&       |                +\- newline
\&       |                |
\&       |                +\- pipe
\&       |                |
\&       |                +\- unopened
\&       |
\&       +\- imprecision
\&       |
\&       +\- misc
\&       |
\&       +\- numeric
\&       |
\&       +\- once
\&       |
\&       +\- overflow
\&       |
\&       +\- pack
\&       |
\&       +\- portable
\&       |
\&       +\- recursion
\&       |
\&       +\- redefine
\&       |
\&       +\- regexp
\&       |
\&       +\- severe \-\-\-\-\-\-\-+
\&       |                |
\&       |                +\- debugging
\&       |                |
\&       |                +\- inplace
\&       |                |
\&       |                +\- internal
\&       |                |
\&       |                +\- malloc
\&       |
\&       +\- signal
\&       |
\&       +\- substr
\&       |
\&       +\- syntax \-\-\-\-\-\-\-+
\&       |                |
\&       |                +\- ambiguous
\&       |                |
\&       |                +\- bareword
\&       |                |
\&       |                +\- digit
\&       |                |
\&       |                +\- illegalproto
\&       |                |
\&       |                +\- parenthesis
\&       |                |
\&       |                +\- precedence
\&       |                |
\&       |                +\- printf
\&       |                |
\&       |                +\- prototype
\&       |                |
\&       |                +\- qw
\&       |                |
\&       |                +\- reserved
\&       |                |
\&       |                +\- semicolon
\&       |
\&       +\- taint
\&       |
\&       +\- threads
\&       |
\&       +\- uninitialized
\&       |
\&       +\- unpack
\&       |
\&       +\- untie
\&       |
\&       +\- utf8\-\-\-\-\-\-\-\-\-\-+
\&       |                |
\&       |                +\- surrogate
\&       |                |
\&       |                +\- non_unicode
\&       |                |
\&       |                +\- nonchar
\&       |
\&       +\- void
.Ve
.PP
Just like the \*(L"strict\*(R" pragma any of these categories can be combined
.PP
.Vb 2
\&    use warnings qw(void redefine);
\&    no warnings qw(io syntax untie);
.Ve
.PP
Also like the \*(L"strict\*(R" pragma, if there is more than one instance of the
\&\f(CW\*(C`warnings\*(C'\fR pragma in a given scope the cumulative effect is additive.
.PP
.Vb 5
\&    use warnings qw(void); # only "void" warnings enabled
\&    ...
\&    use warnings qw(io);   # only "void" & "io" warnings enabled
\&    ...
\&    no warnings qw(void);  # only "io" warnings enabled
.Ve
.PP
To determine which category a specific warning has been assigned to see
perldiag.
.PP
Note: In Perl 5.6.1, the lexical warnings category \*(L"deprecated\*(R" was a
sub-category of the \*(L"syntax\*(R" category. It is now a top-level category
in its own right.
.SS "Fatal Warnings"
.IX Xref "warning, fatal"
.IX Subsection "Fatal Warnings"
The presence of the word \*(L"\s-1FATAL\s0\*(R" in the category list will escalate any
warnings detected from the categories specified in the lexical scope
into fatal errors. In the code below, the use of \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`length\*(C'\fR
and \f(CW\*(C`join\*(C'\fR can all produce a \f(CW"Useless use of xxx in void context"\fR
warning.
.PP
.Vb 1
\&    use warnings;
\&
\&    time;
\&
\&    {
\&        use warnings FATAL => qw(void);
\&        length "abc";
\&    }
\&
\&    join "", 1,2,3;
\&
\&    print "done\en";
.Ve
.PP
When run it produces this output
.PP
.Vb 2
\&    Useless use of time in void context at fatal line 3.
\&    Useless use of length in void context at fatal line 7.
.Ve
.PP
The scope where \f(CW\*(C`length\*(C'\fR is used has escalated the \f(CW\*(C`void\*(C'\fR warnings
category into a fatal error, so the program terminates immediately it
encounters the warning.
.PP
To explicitly turn off a \*(L"\s-1FATAL\s0\*(R" warning you just disable the warning
it is associated with.  So, for example, to disable the \*(L"void\*(R" warning
in the example above, either of these will do the trick:
.PP
.Vb 2
\&    no warnings qw(void);
\&    no warnings FATAL => qw(void);
.Ve
.PP
If you want to downgrade a warning that has been escalated into a fatal
error back to a normal warning, you can use the \*(L"\s-1NONFATAL\s0\*(R" keyword. For
example, the code below will promote all warnings into fatal errors,
except for those in the \*(L"syntax\*(R" category.
.PP
.Vb 1
\&    use warnings FATAL => \*(Aqall\*(Aq, NONFATAL => \*(Aqsyntax\*(Aq;
.Ve
.SS "Reporting Warnings from a Module"
.IX Xref "warning, reporting warning, registering"
.IX Subsection "Reporting Warnings from a Module"
The \f(CW\*(C`warnings\*(C'\fR pragma provides a number of functions that are useful for
module authors. These are used when you want to report a module-specific
warning to a calling module has enabled warnings via the \f(CW\*(C`warnings\*(C'\fR
pragma.
.PP
Consider the module \f(CW\*(C`MyMod::Abc\*(C'\fR below.
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    use warnings::register;
\&
\&    sub open {
\&        my $path = shift;
\&        if ($path !~ m#^/#) {
\&            warnings::warn("changing relative path to /var/abc")
\&                if warnings::enabled();
\&            $path = "/var/abc/$path";
\&        }
\&    }
\&
\&    1;
.Ve
.PP
The call to \f(CW\*(C`warnings::register\*(C'\fR will create a new warnings category
called \*(L"MyMod::Abc\*(R", i.e. the new category name matches the current
package name. The \f(CW\*(C`open\*(C'\fR function in the module will display a warning
message if it gets given a relative path as a parameter. This warnings
will only be displayed if the code that uses \f(CW\*(C`MyMod::Abc\*(C'\fR has actually
enabled them with the \f(CW\*(C`warnings\*(C'\fR pragma like below.
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    abc::open("../fred.txt");
.Ve
.PP
It is also possible to test whether the pre-defined warnings categories are
set in the calling module with the \f(CW\*(C`warnings::enabled\*(C'\fR function. Consider
this snippet of code:
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    sub open {
\&        warnings::warnif("deprecated", 
\&                         "open is deprecated, use new instead");
\&        new(@_);
\&    }
\&
\&    sub new
\&    ...
\&    1;
.Ve
.PP
The function \f(CW\*(C`open\*(C'\fR has been deprecated, so code has been included to
display a warning message whenever the calling module has (at least) the
\&\*(L"deprecated\*(R" warnings category enabled. Something like this, say.
.PP
.Vb 4
\&    use warnings \*(Aqdeprecated\*(Aq;
\&    use MyMod::Abc;
\&    ...
\&    MyMod::Abc::open($filename);
.Ve
.PP
Either the \f(CW\*(C`warnings::warn\*(C'\fR or \f(CW\*(C`warnings::warnif\*(C'\fR function should be
used to actually display the warnings message. This is because they can
make use of the feature that allows warnings to be escalated into fatal
errors. So in this case
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings FATAL => \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    MyMod::Abc::open(\*(Aq../fred.txt\*(Aq);
.Ve
.PP
the \f(CW\*(C`warnings::warnif\*(C'\fR function will detect this and die after
displaying the warning message.
.PP
The three warnings functions, \f(CW\*(C`warnings::warn\*(C'\fR, \f(CW\*(C`warnings::warnif\*(C'\fR
and \f(CW\*(C`warnings::enabled\*(C'\fR can optionally take an object reference in place
of a category name. In this case the functions will use the class name
of the object as the warnings category.
.PP
Consider this example:
.PP
.Vb 1
\&    package Original;
\&
\&    no warnings;
\&    use warnings::register;
\&
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&    sub check
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&
\&        if ($value % 2 && warnings::enabled($self))
\&          { warnings::warn($self, "Odd numbers are unsafe") }
\&    }
\&
\&    sub doit
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&        $self\->check($value);
\&        # ...
\&    }
\&
\&    1;
\&
\&    package Derived;
\&
\&    use warnings::register;
\&    use Original;
\&    our @ISA = qw( Original );
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&
\&    1;
.Ve
.PP
The code below makes use of both modules, but it only enables warnings from 
\&\f(CW\*(C`Derived\*(C'\fR.
.PP
.Vb 7
\&    use Original;
\&    use Derived;
\&    use warnings \*(AqDerived\*(Aq;
\&    my $a = Original\->new();
\&    $a\->doit(1);
\&    my $b = Derived\->new();
\&    $a\->doit(1);
.Ve
.PP
When this code is run only the \f(CW\*(C`Derived\*(C'\fR object, \f(CW$b\fR, will generate
a warning.
.PP
.Vb 1
\&    Odd numbers are unsafe at main.pl line 7
.Ve
.PP
Notice also that the warning is reported at the line where the object is first
used.
.PP
When registering new categories of warning, you can supply more names to
warnings::register like this:
.PP
.Vb 2
\&    package MyModule;
\&    use warnings::register qw(format precision);
\&
\&    ...
\&
\&    warnings::warnif(\*(AqMyModule::format\*(Aq, \*(Aq...\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, perldiag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess
                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllexwarn5.18.1                            0100644 0001750 0001750 00000052612 12566207441 023624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLEXWARN 1"
.TH PERLLEXWARN 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllexwarn \- Perl Lexical Warnings
.IX Xref "warning, lexical warnings warning"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use warnings\*(C'\fR pragma enables to control precisely what warnings are
to be enabled in which parts of a Perl program. It's a more flexible
alternative for both the command line flag \fB\-w\fR and the equivalent Perl
variable, \f(CW$^W\fR.
.PP
This pragma works just like the \f(CW\*(C`strict\*(C'\fR pragma.
This means that the scope of the warning pragma is limited to the
enclosing block. It also means that the pragma setting will not
leak across files (via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR). This allows
authors to independently define the degree of warning checks that will
be applied to their module.
.PP
By default, optional warnings are disabled, so any legacy code that
doesn't attempt to control the warnings will work unchanged.
.PP
All warnings are enabled in a block by either of these:
.PP
.Vb 2
\&    use warnings;
\&    use warnings \*(Aqall\*(Aq;
.Ve
.PP
Similarly all warnings are disabled in a block by either of these:
.PP
.Vb 2
\&    no warnings;
\&    no warnings \*(Aqall\*(Aq;
.Ve
.PP
For example, consider the code below:
.PP
.Vb 7
\&    use warnings;
\&    my @a;
\&    {
\&        no warnings;
\&        my $b = @a[0];
\&    }
\&    my $c = @a[0];
.Ve
.PP
The code in the enclosing block has warnings enabled, but the inner
block has them disabled. In this case that means the assignment to the
scalar \f(CW$c\fR will trip the \f(CW"Scalar value @a[0] better written as $a[0]"\fR
warning, but the assignment to the scalar \f(CW$b\fR will not.
.SS "Default Warnings and Optional Warnings"
.IX Subsection "Default Warnings and Optional Warnings"
Before the introduction of lexical warnings, Perl had two classes of
warnings: mandatory and optional.
.PP
As its name suggests, if your code tripped a mandatory warning, you
would get a warning whether you wanted it or not.
For example, the code below would always produce an \f(CW"isn\*(Aqt numeric"\fR
warning about the \*(L"2:\*(R".
.PP
.Vb 1
\&    my $a = "2:" + 3;
.Ve
.PP
With the introduction of lexical warnings, mandatory warnings now become
\&\fIdefault\fR warnings. The difference is that although the previously
mandatory warnings are still enabled by default, they can then be
subsequently enabled or disabled with the lexical warning pragma. For
example, in the code below, an \f(CW"isn\*(Aqt numeric"\fR warning will only
be reported for the \f(CW$a\fR variable.
.PP
.Vb 3
\&    my $a = "2:" + 3;
\&    no warnings;
\&    my $b = "2:" + 3;
.Ve
.PP
Note that neither the \fB\-w\fR flag or the \f(CW$^W\fR can be used to
disable/enable default warnings. They are still mandatory in this case.
.ie n .SS "What's wrong with \fB\-w\fP and $^W"
.el .SS "What's wrong with \fB\-w\fP and \f(CW$^W\fP"
.IX Subsection "What's wrong with -w and $^W"
Although very useful, the big problem with using \fB\-w\fR on the command
line to enable warnings is that it is all or nothing. Take the typical
scenario when you are writing a Perl program. Parts of the code you
will write yourself, but it's very likely that you will make use of
pre-written Perl modules. If you use the \fB\-w\fR flag in this case, you
end up enabling warnings in pieces of code that you haven't written.
.PP
Similarly, using \f(CW$^W\fR to either disable or enable blocks of code is
fundamentally flawed. For a start, say you want to disable warnings in
a block of code. You might expect this to be enough to do the trick:
.PP
.Vb 5
\&     {
\&         local ($^W) = 0;
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
When this code is run with the \fB\-w\fR flag, a warning will be produced
for the \f(CW$a\fR line:  \f(CW"Reversed += operator"\fR.
.PP
The problem is that Perl has both compile-time and run-time warnings. To
disable compile-time warnings you need to rewrite the code like this:
.PP
.Vb 5
\&     {
\&         BEGIN { $^W = 0 }
\&         my $a =+ 2;
\&         my $b; chop $b;
\&     }
.Ve
.PP
The other big problem with \f(CW$^W\fR is the way you can inadvertently
change the warning setting in unexpected places in your code. For example,
when the code below is run (without the \fB\-w\fR flag), the second call
to \f(CW\*(C`doit\*(C'\fR will trip a \f(CW"Use of uninitialized value"\fR warning, whereas
the first will not.
.PP
.Vb 4
\&    sub doit
\&    {
\&        my $b; chop $b;
\&    }
\&
\&    doit();
\&
\&    {
\&        local ($^W) = 1;
\&        doit()
\&    }
.Ve
.PP
This is a side-effect of \f(CW$^W\fR being dynamically scoped.
.PP
Lexical warnings get around these limitations by allowing finer control
over where warnings can or can't be tripped.
.SS "Controlling Warnings from the Command Line"
.IX Subsection "Controlling Warnings from the Command Line"
There are three Command Line flags that can be used to control when
warnings are (or aren't) produced:
.IP "\fB\-w\fR" 5
.IX Xref "-w"
.IX Item "-w"
This is  the existing flag. If the lexical warnings pragma is \fBnot\fR
used in any of you code, or any of the modules that you use, this flag
will enable warnings everywhere. See \*(L"Backward Compatibility\*(R" for
details of how this flag interacts with lexical warnings.
.IP "\fB\-W\fR" 5
.IX Xref "-W"
.IX Item "-W"
If the \fB\-W\fR flag is used on the command line, it will enable all warnings
throughout the program regardless of whether warnings were disabled
locally using \f(CW\*(C`no warnings\*(C'\fR or \f(CW\*(C`$^W =0\*(C'\fR. This includes all files that get
included via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR.
Think of it as the Perl equivalent of the \*(L"lint\*(R" command.
.IP "\fB\-X\fR" 5
.IX Xref "-X"
.IX Item "-X"
Does the exact opposite to the \fB\-W\fR flag, i.e. it disables all warnings.
.SS "Backward Compatibility"
.IX Subsection "Backward Compatibility"
If you are used to working with a version of Perl prior to the
introduction of lexically scoped warnings, or have code that uses both
lexical warnings and \f(CW$^W\fR, this section will describe how they interact.
.PP
How Lexical Warnings interact with \fB\-w\fR/\f(CW$^W\fR:
.IP "1." 5
If none of the three command line flags (\fB\-w\fR, \fB\-W\fR or \fB\-X\fR) that
control warnings is used and neither \f(CW$^W\fR nor the \f(CW\*(C`warnings\*(C'\fR pragma
are used, then default warnings will be enabled and optional warnings
disabled.
This means that legacy code that doesn't attempt to control the warnings
will work unchanged.
.IP "2." 5
The \fB\-w\fR flag just sets the global \f(CW$^W\fR variable as in 5.005. This
means that any legacy code that currently relies on manipulating \f(CW$^W\fR
to control warning behavior will still work as is.
.IP "3." 5
Apart from now being a boolean, the \f(CW$^W\fR variable operates in exactly
the same horrible uncontrolled global way, except that it cannot
disable/enable default warnings.
.IP "4." 5
If a piece of code is under the control of the \f(CW\*(C`warnings\*(C'\fR pragma,
both the \f(CW$^W\fR variable and the \fB\-w\fR flag will be ignored for the
scope of the lexical warning.
.IP "5." 5
The only way to override a lexical warnings setting is with the \fB\-W\fR
or \fB\-X\fR command line flags.
.PP
The combined effect of 3 & 4 is that it will allow code which uses
the \f(CW\*(C`warnings\*(C'\fR pragma to control the warning behavior of $^W\-type
code (using a \f(CW\*(C`local $^W=0\*(C'\fR) if it really wants to, but not vice-versa.
.SS "Category Hierarchy"
.IX Xref "warning, categories"
.IX Subsection "Category Hierarchy"
A hierarchy of \*(L"categories\*(R" have been defined to allow groups of warnings
to be enabled/disabled in isolation.
.PP
The current hierarchy is:
.PP
.Vb 10
\&    all \-+
\&         |
\&         +\- closure
\&         |
\&         +\- deprecated
\&         |
\&         +\- exiting
\&         |
\&         +\- experimental \-\-+
\&         |                 |
\&         |                 +\- experimental::lexical_subs
\&         |
\&         +\- glob
\&         |
\&         +\- imprecision
\&         |
\&         +\- io \-\-\-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- closed
\&         |                 |
\&         |                 +\- exec
\&         |                 |
\&         |                 +\- layer
\&         |                 |
\&         |                 +\- newline
\&         |                 |
\&         |                 +\- pipe
\&         |                 |
\&         |                 +\- unopened
\&         |
\&         +\- misc
\&         |
\&         +\- numeric
\&         |
\&         +\- once
\&         |
\&         +\- overflow
\&         |
\&         +\- pack
\&         |
\&         +\- portable
\&         |
\&         +\- recursion
\&         |
\&         +\- redefine
\&         |
\&         +\- regexp
\&         |
\&         +\- severe \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- debugging
\&         |                 |
\&         |                 +\- inplace
\&         |                 |
\&         |                 +\- internal
\&         |                 |
\&         |                 +\- malloc
\&         |
\&         +\- signal
\&         |
\&         +\- substr
\&         |
\&         +\- syntax \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- ambiguous
\&         |                 |
\&         |                 +\- bareword
\&         |                 |
\&         |                 +\- digit
\&         |                 |
\&         |                 +\- illegalproto
\&         |                 |
\&         |                 +\- parenthesis
\&         |                 |
\&         |                 +\- precedence
\&         |                 |
\&         |                 +\- printf
\&         |                 |
\&         |                 +\- prototype
\&         |                 |
\&         |                 +\- qw
\&         |                 |
\&         |                 +\- reserved
\&         |                 |
\&         |                 +\- semicolon
\&         |
\&         +\- taint
\&         |
\&         +\- threads
\&         |
\&         +\- uninitialized
\&         |
\&         +\- unpack
\&         |
\&         +\- untie
\&         |
\&         +\- utf8 \-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- non_unicode
\&         |                 |
\&         |                 +\- nonchar
\&         |                 |
\&         |                 +\- surrogate
\&         |
\&         +\- void
.Ve
.PP
Just like the \*(L"strict\*(R" pragma any of these categories can be combined
.PP
.Vb 2
\&    use warnings qw(void redefine);
\&    no warnings qw(io syntax untie);
.Ve
.PP
Also like the \*(L"strict\*(R" pragma, if there is more than one instance of the
\&\f(CW\*(C`warnings\*(C'\fR pragma in a given scope the cumulative effect is additive.
.PP
.Vb 5
\&    use warnings qw(void); # only "void" warnings enabled
\&    ...
\&    use warnings qw(io);   # only "void" & "io" warnings enabled
\&    ...
\&    no warnings qw(void);  # only "io" warnings enabled
.Ve
.PP
To determine which category a specific warning has been assigned to see
perldiag.
.PP
Note: In Perl 5.6.1, the lexical warnings category \*(L"deprecated\*(R" was a
sub-category of the \*(L"syntax\*(R" category. It is now a top-level category
in its own right.
.SS "Fatal Warnings"
.IX Xref "warning, fatal"
.IX Subsection "Fatal Warnings"
The presence of the word \*(L"\s-1FATAL\*(R"\s0 in the category list will escalate any
warnings detected from the categories specified in the lexical scope
into fatal errors. In the code below, the use of \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`length\*(C'\fR
and \f(CW\*(C`join\*(C'\fR can all produce a \f(CW"Useless use of xxx in void context"\fR
warning.
.PP
.Vb 1
\&    use warnings;
\&
\&    time;
\&
\&    {
\&        use warnings FATAL => qw(void);
\&        length "abc";
\&    }
\&
\&    join "", 1,2,3;
\&
\&    print "done\en";
.Ve
.PP
When run it produces this output
.PP
.Vb 2
\&    Useless use of time in void context at fatal line 3.
\&    Useless use of length in void context at fatal line 7.
.Ve
.PP
The scope where \f(CW\*(C`length\*(C'\fR is used has escalated the \f(CW\*(C`void\*(C'\fR warnings
category into a fatal error, so the program terminates immediately it
encounters the warning.
.PP
To explicitly turn off a \*(L"\s-1FATAL\*(R"\s0 warning you just disable the warning
it is associated with.  So, for example, to disable the \*(L"void\*(R" warning
in the example above, either of these will do the trick:
.PP
.Vb 2
\&    no warnings qw(void);
\&    no warnings FATAL => qw(void);
.Ve
.PP
If you want to downgrade a warning that has been escalated into a fatal
error back to a normal warning, you can use the \*(L"\s-1NONFATAL\*(R"\s0 keyword. For
example, the code below will promote all warnings into fatal errors,
except for those in the \*(L"syntax\*(R" category.
.PP
.Vb 1
\&    use warnings FATAL => \*(Aqall\*(Aq, NONFATAL => \*(Aqsyntax\*(Aq;
.Ve
.SS "Reporting Warnings from a Module"
.IX Xref "warning, reporting warning, registering"
.IX Subsection "Reporting Warnings from a Module"
The \f(CW\*(C`warnings\*(C'\fR pragma provides a number of functions that are useful for
module authors. These are used when you want to report a module-specific
warning to a calling module has enabled warnings via the \f(CW\*(C`warnings\*(C'\fR
pragma.
.PP
Consider the module \f(CW\*(C`MyMod::Abc\*(C'\fR below.
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    use warnings::register;
\&
\&    sub open {
\&        my $path = shift;
\&        if ($path !~ m#^/#) {
\&            warnings::warn("changing relative path to /var/abc")
\&                if warnings::enabled();
\&            $path = "/var/abc/$path";
\&        }
\&    }
\&
\&    1;
.Ve
.PP
The call to \f(CW\*(C`warnings::register\*(C'\fR will create a new warnings category
called \*(L"MyMod::Abc\*(R", i.e. the new category name matches the current
package name. The \f(CW\*(C`open\*(C'\fR function in the module will display a warning
message if it gets given a relative path as a parameter. This warnings
will only be displayed if the code that uses \f(CW\*(C`MyMod::Abc\*(C'\fR has actually
enabled them with the \f(CW\*(C`warnings\*(C'\fR pragma like below.
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    abc::open("../fred.txt");
.Ve
.PP
It is also possible to test whether the pre-defined warnings categories are
set in the calling module with the \f(CW\*(C`warnings::enabled\*(C'\fR function. Consider
this snippet of code:
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    sub open {
\&        warnings::warnif("deprecated", 
\&                         "open is deprecated, use new instead");
\&        new(@_);
\&    }
\&
\&    sub new
\&    ...
\&    1;
.Ve
.PP
The function \f(CW\*(C`open\*(C'\fR has been deprecated, so code has been included to
display a warning message whenever the calling module has (at least) the
\&\*(L"deprecated\*(R" warnings category enabled. Something like this, say.
.PP
.Vb 4
\&    use warnings \*(Aqdeprecated\*(Aq;
\&    use MyMod::Abc;
\&    ...
\&    MyMod::Abc::open($filename);
.Ve
.PP
Either the \f(CW\*(C`warnings::warn\*(C'\fR or \f(CW\*(C`warnings::warnif\*(C'\fR function should be
used to actually display the warnings message. This is because they can
make use of the feature that allows warnings to be escalated into fatal
errors. So in this case
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings FATAL => \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    MyMod::Abc::open(\*(Aq../fred.txt\*(Aq);
.Ve
.PP
the \f(CW\*(C`warnings::warnif\*(C'\fR function will detect this and die after
displaying the warning message.
.PP
The three warnings functions, \f(CW\*(C`warnings::warn\*(C'\fR, \f(CW\*(C`warnings::warnif\*(C'\fR
and \f(CW\*(C`warnings::enabled\*(C'\fR can optionally take an object reference in place
of a category name. In this case the functions will use the class name
of the object as the warnings category.
.PP
Consider this example:
.PP
.Vb 1
\&    package Original;
\&
\&    no warnings;
\&    use warnings::register;
\&
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&    sub check
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&
\&        if ($value % 2 && warnings::enabled($self))
\&          { warnings::warn($self, "Odd numbers are unsafe") }
\&    }
\&
\&    sub doit
\&    {
\&        my $self = shift;
\&        my $value = shift;
\&        $self\->check($value);
\&        # ...
\&    }
\&
\&    1;
\&
\&    package Derived;
\&
\&    use warnings::register;
\&    use Original;
\&    our @ISA = qw( Original );
\&    sub new
\&    {
\&        my $class = shift;
\&        bless [], $class;
\&    }
\&
\&
\&    1;
.Ve
.PP
The code below makes use of both modules, but it only enables warnings from 
\&\f(CW\*(C`Derived\*(C'\fR.
.PP
.Vb 7
\&    use Original;
\&    use Derived;
\&    use warnings \*(AqDerived\*(Aq;
\&    my $a = Original\->new();
\&    $a\->doit(1);
\&    my $b = Derived\->new();
\&    $a\->doit(1);
.Ve
.PP
When this code is run only the \f(CW\*(C`Derived\*(C'\fR object, \f(CW$b\fR, will generate
a warning.
.PP
.Vb 1
\&    Odd numbers are unsafe at main.pl line 7
.Ve
.PP
Notice also that the warning is reported at the line where the object is first
used.
.PP
When registering new categories of warning, you can supply more names to
warnings::register like this:
.PP
.Vb 2
\&    package MyModule;
\&    use warnings::register qw(format precision);
\&
\&    ...
\&
\&    warnings::warnif(\*(AqMyModule::format\*(Aq, \*(Aq...\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, perldiag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Marquess
                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllinux.1                                  0100644 0001750 0001750 00000012655 12566207441 022772  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLINUX 1"
.TH PERLLINUX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllinux \- Perl version 5 on Linux systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Linux that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0"
.IX Subsection "Experimental Support for Sun Studio Compilers for Linux OS"
Sun Microsystems has released a port of their Sun Studio compilers for
Linux.  As of November 2005, only an alpha version has been released.  
Until a release of these compilers is made, support for compiling Perl with
these compiler experimental.
.PP
Also, some special instructions for building Perl with Sun Studio on Linux.
Following the normal \f(CW\*(C`Configure\*(C'\fR, you have to run make as follows:
.PP
.Vb 1
\&    LDLOADLIBS=\-lc make
.Ve
.PP
\&\f(CW\*(C`LDLOADLIBS\*(C'\fR is an environment variable used by the linker to link modules
\&\f(CW\*(C`/ext\*(C'\fR modules to glibc.  Currently, that environment variable is not getting
populated by a combination of \f(CW\*(C`Config\*(C'\fR entries and \f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR.
While there may be a bug somewhere in Perl's configuration or
\&\f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR causing the problem, the most likely cause is an
incomplete understanding of Sun Studio by this author.  Further investigation
is needed to get this working better.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Peters <steve@fisharerojo.org>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllinux5.16.1                              0100644 0001750 0001750 00000012334 12566207421 023274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLINUX 1"
.TH PERLLINUX 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllinux \- Perl version 5 on Linux systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Linux that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0"
.IX Subsection "Experimental Support for Sun Studio Compilers for Linux OS"
Sun Microsystems has released a port of their Sun Studio compilers for
Linux.  As of November 2005, only an alpha version has been released.  
Until a release of these compilers is made, support for compiling Perl with
these compiler experimental.
.PP
Also, some special instructions for building Perl with Sun Studio on Linux.
Following the normal \f(CW\*(C`Configure\*(C'\fR, you have to run make as follows:
.PP
.Vb 1
\&    LDLOADLIBS=\-lc make
.Ve
.PP
\&\f(CW\*(C`LDLOADLIBS\*(C'\fR is an environment variable used by the linker to link modules
\&\f(CW\*(C`/ext\*(C'\fR modules to glibc.  Currently, that environment variable is not getting
populated by a combination of \f(CW\*(C`Config\*(C'\fR entries and \f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR.
While there may be a bug somewhere in Perl's configuration or
\&\f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR causing the problem, the most likely cause is an
incomplete understanding of Sun Studio by this author.  Further investigation
is needed to get this working better.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Peters <steve@fisharerojo.org>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllinux5.18.1                              0100644 0001750 0001750 00000012655 12566207441 023306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLINUX 1"
.TH PERLLINUX 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllinux \- Perl version 5 on Linux systems
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of Linux that will affect how Perl
version 5 (hereafter just Perl) is compiled and/or runs.
.SS "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0"
.IX Subsection "Experimental Support for Sun Studio Compilers for Linux OS"
Sun Microsystems has released a port of their Sun Studio compilers for
Linux.  As of November 2005, only an alpha version has been released.  
Until a release of these compilers is made, support for compiling Perl with
these compiler experimental.
.PP
Also, some special instructions for building Perl with Sun Studio on Linux.
Following the normal \f(CW\*(C`Configure\*(C'\fR, you have to run make as follows:
.PP
.Vb 1
\&    LDLOADLIBS=\-lc make
.Ve
.PP
\&\f(CW\*(C`LDLOADLIBS\*(C'\fR is an environment variable used by the linker to link modules
\&\f(CW\*(C`/ext\*(C'\fR modules to glibc.  Currently, that environment variable is not getting
populated by a combination of \f(CW\*(C`Config\*(C'\fR entries and \f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR.
While there may be a bug somewhere in Perl's configuration or
\&\f(CW\*(C`ExtUtil::MakeMaker\*(C'\fR causing the problem, the most likely cause is an
incomplete understanding of Sun Studio by this author.  Further investigation
is needed to get this working better.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Peters <steve@fisharerojo.org>
.PP
Please report any errors, updates, or suggestions to \fIperlbug@perl.org\fR.
                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllocale.1                                 0100644 0001750 0001750 00000177775 12566207441 023111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLOCALE 1"
.TH PERLLOCALE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllocale \- Perl locale handling (internationalization and localization)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In the beginning there was \s-1ASCII,\s0 the \*(L"American Standard Code for
Information Interchange\*(R", which works quite well for Americans with
their English alphabet and dollar-denominated currency.  But it doesn't
work so well even for other English speakers, who may use different
currencies, such as the pound sterling (as the symbol for that currency
is not in \s-1ASCII\s0); and it's hopelessly inadequate for many of the
thousands of the world's other languages.
.PP
To address these deficiencies, the concept of locales was invented
(formally the \s-1ISO C, XPG4, POSIX 1\s0.c \*(L"locale system\*(R").  And applications
were and are being written that use the locale mechanism.  The process of
making such an application take account of its users' preferences in
these kinds of matters is called \fBinternationalization\fR (often
abbreviated as \fBi18n\fR); telling such an application about a particular
set of preferences is known as \fBlocalization\fR (\fBl10n\fR).
.PP
Perl was extended to support the locale system.  This
is controlled per application by using one pragma, one function call,
and several environment variables.
.PP
Unfortunately, there are quite a few deficiencies with the design (and
often, the implementations) of locales, and their use for character sets
has mostly been supplanted by Unicode (see perlunitut for an
introduction to that, and keep on reading here for how Unicode interacts
with locales in Perl).
.PP
Perl continues to support the old locale system, and starting in v5.16,
provides a hybrid way to use the Unicode character set, along with the
other portions of locales that may not be so problematic.
(Unicode is also creating \f(CW\*(C`CLDR\*(C'\fR, the \*(L"Common Locale Data Repository\*(R",
<http://cldr.unicode.org/> which includes more types of information than
are available in the \s-1POSIX\s0 locale system.  At the time of this writing,
there was no \s-1CPAN\s0 module that provides access to this XML-encoded data.
However, many of its locales have the POSIX-only data extracted, and are
available at <http://unicode.org/Public/cldr/latest/>.)
.SH "WHAT IS A LOCALE"
.IX Header "WHAT IS A LOCALE"
A locale is a set of data that describes various aspects of how various
communities in the world categorize their world.  These categories are
broken down into the following types (some of which include a brief
note here):
.IP "Category \s-1LC_NUMERIC:\s0 Numeric formatting" 4
.IX Item "Category LC_NUMERIC: Numeric formatting"
This indicates how numbers should be formatted for human readability,
for example the character used as the decimal point.
.IP "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts" 4
.IX Item "Category LC_MONETARY: Formatting of monetary amounts"
\&\ 
.IP "Category \s-1LC_TIME:\s0 Date/Time formatting" 4
.IX Item "Category LC_TIME: Date/Time formatting"
\&\ 
.IP "Category \s-1LC_MESSAGES:\s0 Error and other messages" 4
.IX Item "Category LC_MESSAGES: Error and other messages"
This for the most part is beyond the scope of Perl
.IP "Category \s-1LC_COLLATE:\s0 Collation" 4
.IX Item "Category LC_COLLATE: Collation"
This indicates the ordering of letters for comparison and sorting.
In Latin alphabets, for example, \*(L"b\*(R", generally follows \*(L"a\*(R".
.IP "Category \s-1LC_CTYPE:\s0 Character Types" 4
.IX Item "Category LC_CTYPE: Character Types"
This indicates, for example if a character is an uppercase letter.
.PP
More details on the categories are given below in \*(L"\s-1LOCALE CATEGORIES\*(R"\s0.
.PP
Together, these categories go a long way towards being able to customize
a single program to run in many different locations.  But there are
deficiencies, so keep reading.
.SH "PREPARING TO USE LOCALES"
.IX Header "PREPARING TO USE LOCALES"
Perl will not use locales unless specifically requested to (see \*(L"\s-1NOTES\*(R"\s0 below
for the partial exception of \f(CW\*(C`write()\*(C'\fR).  But even if there is such a
request, \fBall\fR of the following must be true for it to work properly:
.IP "\(bu" 4
\&\fBYour operating system must support the locale system\fR.  If it does,
you should find that the \fIsetlocale()\fR function is a documented part of
its C library.
.IP "\(bu" 4
\&\fBDefinitions for locales that you use must be installed\fR.  You, or
your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system.  Some systems
provide only a few, hard-wired locales and do not allow more to be
added.  Others allow you to add \*(L"canned\*(R" locales provided by the system
supplier.  Still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales that are not delivered with your operating
system.)  Read your system documentation for further illumination.
.IP "\(bu" 4
\&\fBPerl must believe that the locale system is supported\fR.  If it does,
\&\f(CW\*(C`perl \-V:d_setlocale\*(C'\fR will say that the value for \f(CW\*(C`d_setlocale\*(C'\fR is
\&\f(CW\*(C`define\*(C'\fR.
.PP
If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the \f(CW\*(C`use\ locale\*(C'\fR pragma (see \*(L"The use locale pragma\*(R") where
appropriate, and \fBat least one\fR of the following must be true:
.IP "1." 4
\&\fBThe locale-determining environment variables (see \*(L"\s-1ENVIRONMENT\*(R"\s0)
must be correctly set up\fR at the time the application is started, either
by yourself or by whomever set up your system account; or
.IP "2." 4
\&\fBThe application must set its own locale\fR using the method described in
\&\*(L"The setlocale function\*(R".
.SH "USING LOCALES"
.IX Header "USING LOCALES"
.SS "The use locale pragma"
.IX Subsection "The use locale pragma"
By default, Perl ignores the current locale.  The \f(CW\*(C`use\ locale\*(C'\fR
pragma tells Perl to use the current locale for some operations.
Starting in v5.16, there is an optional parameter to this pragma:
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
This parameter allows better mixing of locales and Unicode, and is
described fully in \*(L"Unicode and \s-1UTF\-8\*(R"\s0, but briefly, it tells Perl to
not use the character portions of the locale definition, that is
the \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR categories.  Instead it will use the
native (extended by Unicode) character set.  When using this parameter,
you are responsible for getting the external character set translated
into the native/Unicode one (which it already will be if it is one of
the increasingly popular \s-1UTF\-8\s0 locales).  There are convenient ways of
doing this, as described in \*(L"Unicode and \s-1UTF\-8\*(R"\s0.
.PP
The current locale is set at execution time by
\&\fIsetlocale()\fR described below.  If that function
hasn't yet been called in the course of the program's execution, the
current locale is that which was determined by the \*(L"\s-1ENVIRONMENT\*(R"\s0 in
effect at the start of the program, except that
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR is always
initialized to the C locale (mentioned under \*(L"Finding locales\*(R").
If there is no valid environment, the current locale is undefined.  It
is likely, but not necessarily, the \*(L"C\*(R" locale.
.PP
The operations that are affected by locale are:
.ie n .IP "\fBUnder \fB""use locale \*(Aq:not_characters\*(Aq;""\fB\fR" 4
.el .IP "\fBUnder \f(CBuse locale \*(Aq:not_characters\*(Aq;\fB\fR" 4
.IX Item "Under use locale :not_characters;"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
\&\fBFormat declarations\fR (\fIformat()\fR) use \f(CW\*(C`LC_NUMERIC\*(C'\fR
.IP "\(bu" 4
\&\fBThe \s-1POSIX\s0 date formatting function\fR (\fIstrftime()\fR) uses \f(CW\*(C`LC_TIME\*(C'\fR.
.RE
.RS 4
.Sp
\&\ 
.RE
.ie n .IP "\fBUnder just plain \fB""use locale;""\fB\fR" 4
.el .IP "\fBUnder just plain \f(CBuse locale;\fB\fR" 4
.IX Item "Under just plain use locale;"
The above operations are affected, as well as the following:
.RS 4
.IP "\(bu" 4
\&\fBThe comparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, and \f(CW\*(C`gt\*(C'\fR) and
the \s-1POSIX\s0 string collation functions \fIstrcoll()\fR and \fIstrxfrm()\fR use
\&\f(CW\*(C`LC_COLLATE\*(C'\fR.  \fIsort()\fR is also affected if used without an
explicit comparison function, because it uses \f(CW\*(C`cmp\*(C'\fR by default.
.Sp
\&\fBNote:\fR \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`ne\*(C'\fR are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if \f(CW\*(C`cmp\*(C'\fR finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns \fI0\fR (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings\*(--which \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR may consider different\*(--are equal
as far as collation in the locale is concerned, see the discussion in
\&\*(L"Category \s-1LC_COLLATE:\s0 Collation\*(R".
.IP "\(bu" 4
\&\fBRegular expressions and case-modification functions\fR (\fIuc()\fR, \fIlc()\fR,
\&\fIucfirst()\fR, and \fIlcfirst()\fR) use \f(CW\*(C`LC_CTYPE\*(C'\fR
.RE
.RS 4
.RE
.PP
The default behavior is restored with the \f(CW\*(C`no\ locale\*(C'\fR pragma, or
upon reaching the end of the block enclosing \f(CW\*(C`use locale\*(C'\fR.
Note that \f(CW\*(C`use locale\*(C'\fR and \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR may be
nested, and that what is in effect within an inner scope will revert to
the outer scope's rules at the end of the inner scope.
.PP
The string result of any operation that uses locale
information is tainted, as it is possible for a locale to be
untrustworthy.  See \*(L"\s-1SECURITY\*(R"\s0.
.SS "The setlocale function"
.IX Subsection "The setlocale function"
You can switch locales as often as you wish at run time with the
\&\fIPOSIX::setlocale()\fR function:
.PP
.Vb 4
\&        # Import locale\-handling tool set from POSIX module.
\&        # This example uses: setlocale \-\- the function call
\&        #                    LC_CTYPE \-\- explained below
\&        use POSIX qw(locale_h);
\&
\&        # query and save the old locale
\&        $old_locale = setlocale(LC_CTYPE);
\&
\&        setlocale(LC_CTYPE, "fr_CA.ISO8859\-1");
\&        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859\-1"
\&
\&        setlocale(LC_CTYPE, "");
\&        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
\&        # environment variables.  See below for documentation.
\&
\&        # restore the old locale
\&        setlocale(LC_CTYPE, $old_locale);
.Ve
.PP
The first argument of \fIsetlocale()\fR gives the \fBcategory\fR, the second the
\&\fBlocale\fR.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
\&\*(L"\s-1LOCALE CATEGORIES\*(R"\s0 and \*(L"\s-1ENVIRONMENT\*(R"\s0.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.
.PP
If no second argument is provided and the category is something else
than \s-1LC_ALL,\s0 the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to \fIsetlocale()\fR.
.PP
If no second argument is provided and the category is \s-1LC_ALL,\s0 the
result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your \fIsetlocale\fR\|(3) man page for
details.
.PP
If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to \fIsetlocale()\fR.  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument\*(--think of it as an alias for the value you gave.)
.PP
As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.
.PP
If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns \fIundef\fR.
.PP
Note that Perl ignores the current \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR locales
within the scope of a \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR.
.PP
For further information about the categories, consult \fIsetlocale\fR\|(3).
.SS "Finding locales"
.IX Subsection "Finding locales"
For locales available in your system, consult also \fIsetlocale\fR\|(3) to
see whether it leads to the list of available locales (search for the
\&\fI\s-1SEE ALSO\s0\fR section).  If that fails, try the following command lines:
.PP
.Vb 1
\&        locale \-a
\&
\&        nlsinfo
\&
\&        ls /usr/lib/nls/loc
\&
\&        ls /usr/lib/locale
\&
\&        ls /usr/lib/nls
\&
\&        ls /usr/share/locale
.Ve
.PP
and see whether they list something resembling these
.PP
.Vb 7
\&        en_US.ISO8859\-1     de_DE.ISO8859\-1     ru_RU.ISO8859\-5
\&        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
\&        en_US               de_DE               ru_RU
\&        en                  de                  ru
\&        english             german              russian
\&        english.iso88591    german.iso88591     russian.iso88595
\&        english.roman8                          russian.koi8r
.Ve
.PP
Sadly, even though the calling interface for \fIsetlocale()\fR has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
\&\fIlanguage_territory\fR\fB.\fR\fIcodeset\fR, but the latter parts after
\&\fIlanguage\fR are not always present.  The \fIlanguage\fR and \fIcountry\fR
are usually from the standards \fB\s-1ISO 3166\s0\fR and \fB\s-1ISO 639\s0\fR, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The \fIcodeset\fR part often mentions some \fB\s-1ISO
8859\s0\fR character set, the Latin codesets.  For example, \f(CW\*(C`ISO 8859\-1\*(C'\fR
is the so-called \*(L"Western European codeset\*(R" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.
.PP
Two special locales are worth particular mention: \*(L"C\*(R" and \*(L"\s-1POSIX\*(R".\s0
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the \s-1POSIX\s0 standard.  They define the \fBdefault locale\fR in which
every program starts in the absence of locale information in its
environment.  (The \fIdefault\fR default locale, if you will.)  Its language
is (American) English and its character codeset \s-1ASCII.
\&\s0\fBWarning\fR. The C locale delivered by some vendors may not
actually exactly match what the C standard calls for.  So beware.
.PP
\&\fB\s-1NOTE\s0\fR: Not all systems have the \*(L"\s-1POSIX\*(R"\s0 locale (not all systems are
POSIX-conformant), so use \*(L"C\*(R" when you need explicitly to specify this
default locale.
.SS "\s-1LOCALE PROBLEMS\s0"
.IX Subsection "LOCALE PROBLEMS"
You may encounter the following warning message at Perl startup:
.PP
.Vb 6
\&        perl: warning: Setting locale failed.
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
\&        perl: warning: Falling back to the standard locale ("C").
.Ve
.PP
This means that your locale settings had \s-1LC_ALL\s0 set to \*(L"En_US\*(R" and
\&\s-1LANG\s0 exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the \*(L"C\*(R" locale, the default locale
that is supposed to work no matter what.  This usually means your locale
settings were wrong, they mention locales your system has never heard
of, or the locale installation in your system has problems (for example,
some system files are broken or missing).  There are quick and temporary
fixes to these problems, as well as more thorough and lasting fixes.
.SS "Temporarily fixing locale problems"
.IX Subsection "Temporarily fixing locale problems"
The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale \*(L"C\*(R".
.PP
Perl's moaning about locale problems can be silenced by setting the
environment variable \s-1PERL_BADLANG\s0 to a zero value, for example \*(L"0\*(R".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.
.PP
Perl can be run under the \*(L"C\*(R" locale by setting the environment
variable \s-1LC_ALL\s0 to \*(L"C\*(R".  This method is perhaps a bit more civilized
than the \s-1PERL_BADLANG\s0 approach, but setting \s-1LC_ALL \s0(or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See \*(L"\s-1ENVIRONMENT\*(R"\s0 for
the full list of relevant environment variables and \*(L"\s-1USING LOCALES\*(R"\s0
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable \s-1LC_COLLATE\s0 may well affect
your \fBsort\fR program (or whatever the program that arranges \*(L"records\*(R"
alphabetically in your system is called).
.PP
You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For in
Bourne-like shells (\fBsh\fR, \fBksh\fR, \fBbash\fR, \fBzsh\fR):
.PP
.Vb 2
\&        LC_ALL=en_US.ISO8859\-1
\&        export LC_ALL
.Ve
.PP
This assumes that we saw the locale \*(L"en_US.ISO8859\-1\*(R" using the commands
discussed above.  We decided to try that instead of the above faulty
locale \*(L"En_US\*(R"\-\-and in Cshish shells (\fBcsh\fR, \fBtcsh\fR)
.PP
.Vb 1
\&        setenv LC_ALL en_US.ISO8859\-1
.Ve
.PP
or if you have the \*(L"env\*(R" application you can do in any shell
.PP
.Vb 1
\&        env LC_ALL=en_US.ISO8859\-1 perl ...
.Ve
.PP
If you do not know what shell you have, consult your local
helpdesk or the equivalent.
.SS "Permanently fixing locale problems"
.IX Subsection "Permanently fixing locale problems"
The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your friendly system administrator.
.PP
First, see earlier in this document about \*(L"Finding locales\*(R".  That tells
how to find which locales are really supported\*(--and more importantly,
installed\*(--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
\&\s-1LC_ALL\s0 set to \*(L"En_US\*(R" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.
.PP
Second, if using the listed commands you see something \fBexactly\fR
(prefix matches do not count and case usually counts) like \*(L"En_US\*(R"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see \*(L"Permanently fixing your system's locale configuration\*(R".
.SS "Permanently fixing your system's locale configuration"
.IX Subsection "Permanently fixing your system's locale configuration"
This is when you see something like:
.PP
.Vb 4
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
.Ve
.PP
but then cannot see that \*(L"En_US\*(R" listed by the above-mentioned
commands.  You may see things like \*(L"en_US.ISO8859\-1\*(R", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
\&\*(L"Finding locales\*(R" about general rules.
.SS "Fixing system locale configuration"
.IX Subsection "Fixing system locale configuration"
Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The \*(L"Finding locales\*(R"
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.
.SS "The localeconv function"
.IX Subsection "The localeconv function"
The \fIPOSIX::localeconv()\fR function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR locales.  (If you just want the name of
the current locale for a particular category, use \fIPOSIX::setlocale()\fR
with a single parameter\*(--see \*(L"The setlocale function\*(R".)
.PP
.Vb 1
\&        use POSIX qw(locale_h);
\&
\&        # Get a reference to a hash of locale\-dependent info
\&        $locale_values = localeconv();
\&
\&        # Output sorted list of the values
\&        for (sort keys %$locale_values) {
\&            printf "%\-20s = %s\en", $_, $locale_values\->{$_}
\&        }
.Ve
.PP
\&\fIlocaleconv()\fR takes no arguments, and returns \fBa reference to\fR a hash.
The keys of this hash are variable names for formatting, such as
\&\f(CW\*(C`decimal_point\*(C'\fR and \f(CW\*(C`thousands_sep\*(C'\fR.  The values are the
corresponding, er, values.  See \*(L"localeconv\*(R" in \s-1POSIX\s0 for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit \f(CW\*(C`use locale\*(C'\fR, because \fIlocaleconv()\fR always observes the
current locale.
.PP
Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:
.PP
.Vb 1
\&    use POSIX qw(locale_h);
\&
\&    # Get some of locale\*(Aqs numeric formatting parameters
\&    my ($thousands_sep, $grouping) =
\&            @{localeconv()}{\*(Aqthousands_sep\*(Aq, \*(Aqgrouping\*(Aq};
\&
\&    # Apply defaults if values are missing
\&    $thousands_sep = \*(Aq,\*(Aq unless $thousands_sep;
\&
\&    # grouping and mon_grouping are packed lists
\&    # of small integers (characters) telling the
\&    # grouping (thousand_seps and mon_thousand_seps
\&    # being the group dividers) of numbers and
\&    # monetary quantities.  The integers\*(Aq meanings:
\&    # 255 means no more grouping, 0 means repeat
\&    # the previous grouping, 1\-254 means use that
\&    # as the current grouping.  Grouping goes from
\&    # right to left (low to high digits).  In the
\&    # below we cheat slightly by never using anything
\&    # else than the first grouping (whatever that is).
\&    if ($grouping) {
\&        @grouping = unpack("C*", $grouping);
\&    } else {
\&        @grouping = (3);
\&    }
\&
\&    # Format command line params for current locale
\&    for (@ARGV) {
\&        $_ = int;    # Chop non\-integer part
\&        1 while
\&        s/(\ed)(\ed{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
\&        print "$_";
\&    }
\&    print "\en";
.Ve
.SS "I18N::Langinfo"
.IX Subsection "I18N::Langinfo"
Another interface for querying locale-dependent information is the
\&\fII18N::Langinfo::langinfo()\fR function, available at least in Unix-like
systems and \s-1VMS.\s0
.PP
The following example will import the \fIlanginfo()\fR function itself and
three constants to be used as arguments to \fIlanginfo()\fR: a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.
.PP
.Vb 1
\&    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);
\&
\&    my ($abday_1, $yesstr, $nostr)
\&                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);
\&
\&    print "$abday_1? [$yesstr/$nostr] ";
.Ve
.PP
In other words, in the \*(L"C\*(R" (or English) locale the above will probably
print something like:
.PP
.Vb 1
\&    Sun? [yes/no]
.Ve
.PP
See I18N::Langinfo for more information.
.SH "LOCALE CATEGORIES"
.IX Header "LOCALE CATEGORIES"
The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See \*(L"\s-1ENVIRONMENT\*(R"\s0 for a discussion of these.
.SS "Category \s-1LC_COLLATE:\s0 Collation"
.IX Subsection "Category LC_COLLATE: Collation"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl looks to the \f(CW\*(C`LC_COLLATE\*(C'\fR
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, \*(L"b\*(R" follows \*(L"a\*(R" in Latin
alphabets, but where do \*(L"a\*'\*(R" and \*(L"a\*o\*(R" belong?  And while
\&\*(L"color\*(R" follows \*(L"chocolate\*(R" in English, what about in traditional Spanish?
.PP
The following collations all make sense and you may meet any of them
if you \*(L"use locale\*(R".
.PP
.Vb 4
\&        A B C D E a b c d e
\&        A a B b C c D d E e
\&        a A b B c C d D e E
\&        a b c d e A B C D E
.Ve
.PP
Here is a code snippet to tell what \*(L"word\*(R"
characters are in the current locale, in that locale's order:
.PP
.Vb 2
\&        use locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:
.PP
.Vb 2
\&        no locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
This machine-native collation (which is what you get unless \f(CW\*(C`use\ locale\*(C'\fR has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.
.PP
As noted in \*(L"\s-1USING LOCALES\*(R"\s0, \f(CW\*(C`cmp\*(C'\fR compares according to the current
collation locale when \f(CW\*(C`use locale\*(C'\fR is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use \fIPOSIX::strcoll()\fR if you don't want this fall-back:
.PP
.Vb 3
\&        use POSIX qw(strcoll);
\&        $equal_in_locale =
\&            !strcoll("space and case ignored", "SpaceAndCaseIgnored");
.Ve
.PP
\&\f(CW$equal_in_locale\fR will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.
.PP
If you have a single string that you want to check for \*(L"equality in
locale\*(R" against several others, you might think you could gain a little
efficiency by using \fIPOSIX::strxfrm()\fR in conjunction with \f(CW\*(C`eq\*(C'\fR:
.PP
.Vb 8
\&        use POSIX qw(strxfrm);
\&        $xfrm_string = strxfrm("Mixed\-case string");
\&        print "locale collation ignores spaces\en"
\&            if $xfrm_string eq strxfrm("Mixed\-casestring");
\&        print "locale collation ignores hyphens\en"
\&            if $xfrm_string eq strxfrm("Mixedcase string");
\&        print "locale collation ignores case\en"
\&            if $xfrm_string eq strxfrm("mixed\-case string");
.Ve
.PP
\&\fIstrxfrm()\fR takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  \*(L"Under the hood\*(R", locale-affected Perl comparison operators
call \fIstrxfrm()\fR for both operands, then do a char-by-char
comparison of the transformed strings.  By calling \fIstrxfrm()\fR explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see \*(L"Magic Variables\*(R" in perlguts) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
\&\f(CW\*(C`cmp\*(C'\fR runs just about as fast.  It also copes with null characters
embedded in strings; if you call \fIstrxfrm()\fR directly, it treats the first
null it finds as a terminator.  don't expect the transformed strings
it produces to be portable across systems\*(--or even from one revision
of your operating system to the next.  In short, don't call \fIstrxfrm()\fR
directly: let Perl do it for you.
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't shown in some of these examples because it isn't
needed: \fIstrcoll()\fR and \fIstrxfrm()\fR exist only to generate locale-dependent
results, and so always obey the current \f(CW\*(C`LC_COLLATE\*(C'\fR locale.
.SS "Category \s-1LC_CTYPE:\s0 Character Types"
.IX Subsection "Category LC_CTYPE: Character Types"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl obeys the \f(CW\*(C`LC_CTYPE\*(C'\fR locale
setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's \f(CW\*(C`\ew\*(C'\fR regular expression metanotation,
which stands for alphanumeric characters\*(--that is, alphabetic,
numeric, and including other special characters such as the underscore or
hyphen.  (Consult perlre for more information about
regular expressions.)  Thanks to \f(CW\*(C`LC_CTYPE\*(C'\fR, depending on your locale
setting, characters like \*(L"\*(ae\*(R", \*(L"\*(d-\*(R", \*(L"\*8\*(R", and
\&\*(L"o\*/\*(R" may be understood as \f(CW\*(C`\ew\*(C'\fR characters.
.PP
The \f(CW\*(C`LC_CTYPE\*(C'\fR locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions\*(--\fIlc()\fR, lcfirst, \fIuc()\fR, and \fIucfirst()\fR; case-mapping
interpolation with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR in double-quoted strings
and \f(CW\*(C`s///\*(C'\fR substitutions; and case-independent regular expression
pattern matching using the \f(CW\*(C`i\*(C'\fR modifier.
.PP
Finally, \f(CW\*(C`LC_CTYPE\*(C'\fR affects the \s-1POSIX\s0 character-class test
functions\*(--\fIisalpha()\fR, \fIislower()\fR, and so on.  For example, if you move
from the \*(L"C\*(R" locale to a 7\-bit Scandinavian one, you may find\*(--possibly
to your surprise\*(--that \*(L"|\*(R" moves from the \fIispunct()\fR class to \fIisalpha()\fR.
Unfortunately, this creates big problems for regular expressions. \*(L"|\*(R" still
means alternation even though it matches \f(CW\*(C`\ew\*(C'\fR.
.PP
Note that there are quite a few things that are unaffected by the
current locale.  All the escape sequences for particular characters,
\&\f(CW\*(C`\en\*(C'\fR for example, always mean the platform's native one.  This means,
for example, that \f(CW\*(C`\eN\*(C'\fR in regular expressions (every character
but new-line) work on the platform character set.
.PP
\&\fBNote:\fR A broken or malicious \f(CW\*(C`LC_CTYPE\*(C'\fR locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) \s-1ASCII\s0 letters and
digits\*(--for example, in command strings\*(--locale\-aware applications
should use \f(CW\*(C`\ew\*(C'\fR with the \f(CW\*(C`/a\*(C'\fR regular expression modifier.  See \*(L"\s-1SECURITY\*(R"\s0.
.SS "Category \s-1LC_NUMERIC:\s0 Numeric Formatting"
.IX Subsection "Category LC_NUMERIC: Numeric Formatting"
After a proper \fIPOSIX::setlocale()\fR call, Perl obeys the \f(CW\*(C`LC_NUMERIC\*(C'\fR
locale information, which controls an application's idea of how numbers
should be formatted for human readability by the \fIprintf()\fR, \fIsprintf()\fR, and
\&\fIwrite()\fR functions. String-to-numeric conversion by the \fIPOSIX::strtod()\fR
function is also affected.  In most implementations the only effect is to
change the character used for the decimal point\*(--perhaps from \*(L".\*(R"  to \*(L",\*(R".
These functions aren't aware of such niceties as thousands separation and
so on. (See \*(L"The localeconv function\*(R" if you care about these things.)
.PP
Output produced by \fIprint()\fR is also affected by the current locale: it
corresponds to what you'd get from \fIprintf()\fR in the \*(L"C\*(R" locale.  The
same is true for Perl's internal conversions between numeric and
string formats:
.PP
.Vb 1
\&        use POSIX qw(strtod setlocale LC_NUMERIC);
\&
\&        setlocale LC_NUMERIC, "";
\&
\&        $n = 5/2;   # Assign numeric 2.5 to $n
\&
\&        $a = " $n"; # Locale\-dependent conversion to string
\&
\&        print "half five is $n\en";       # Locale\-dependent output
\&
\&        printf "half five is %g\en", $n;  # Locale\-dependent output
\&
\&        print "DECIMAL POINT IS COMMA\en"
\&            if $n == (strtod("2,5"))[0]; # Locale\-dependent conversion
.Ve
.PP
See also I18N::Langinfo and \f(CW\*(C`RADIXCHAR\*(C'\fR.
.SS "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts"
.IX Subsection "Category LC_MONETARY: Formatting of monetary amounts"
The C standard defines the \f(CW\*(C`LC_MONETARY\*(C'\fR category, but not a function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use \f(CW\*(C`LC_MONETARY\*(C'\fR, you can query its contents\*(--see
\&\*(L"The localeconv function\*(R"\-\-and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.
.PP
See also I18N::Langinfo and \f(CW\*(C`CRNCYSTR\*(C'\fR.
.SS "\s-1LC_TIME\s0"
.IX Subsection "LC_TIME"
Output produced by \fIPOSIX::strftime()\fR, which builds a formatted
human-readable date/time string, is affected by the current \f(CW\*(C`LC_TIME\*(C'\fR
locale.  Thus, in a French locale, the output produced by the \f(CW%B\fR
format element (full month name) for the first month of the year would
be \*(L"janvier\*(R".  Here's how to get a list of long month names in the
current locale:
.PP
.Vb 5
\&        use POSIX qw(strftime);
\&        for (0..11) {
\&            $long_month_name[$_] =
\&                strftime("%B", 0, 0, 0, 1, $_, 96);
\&        }
.Ve
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't needed in this example: as a function that
exists only to generate locale-dependent results, \fIstrftime()\fR always
obeys the current \f(CW\*(C`LC_TIME\*(C'\fR locale.
.PP
See also I18N::Langinfo and \f(CW\*(C`ABDAY_1\*(C'\fR..\f(CW\*(C`ABDAY_7\*(C'\fR, \f(CW\*(C`DAY_1\*(C'\fR..\f(CW\*(C`DAY_7\*(C'\fR,
\&\f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR, and \f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR.
.SS "Other categories"
.IX Subsection "Other categories"
The remaining locale category, \f(CW\*(C`LC_MESSAGES\*(C'\fR (possibly supplemented
by others in particular implementations) is not currently used by
Perl\*(--except possibly to affect the behavior of library functions
called by extensions outside the standard Perl distribution and by the
operating system and its utilities.  Note especially that the string
value of \f(CW$!\fR and the error messages given by external utilities may
be changed by \f(CW\*(C`LC_MESSAGES\*(C'\fR.  If you want to have portable error
codes, use \f(CW\*(C`%!\*(C'\fR.  See Errno.
.SH "SECURITY"
.IX Header "SECURITY"
Although the main discussion of Perl security issues can be found in
perlsec, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales\*(--particularly on systems that allow unprivileged users to
build their own locales\*(--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:
.IP "\(bu" 4
Regular expression checks for safe file names or mail addresses using
\&\f(CW\*(C`\ew\*(C'\fR may be spoofed by an \f(CW\*(C`LC_CTYPE\*(C'\fR locale that claims that
characters such as \*(L">\*(R" and \*(L"|\*(R" are alphanumeric.
.IP "\(bu" 4
String interpolation with case-mapping, as in, say, \f(CW\*(C`$dest =
"C:\eU$name.$ext"\*(C'\fR, may produce dangerous results if a bogus \s-1LC_CTYPE\s0
case-mapping table is in effect.
.IP "\(bu" 4
A sneaky \f(CW\*(C`LC_COLLATE\*(C'\fR locale could result in the names of students with
\&\*(L"D\*(R" grades appearing ahead of those with \*(L"A\*(R"s.
.IP "\(bu" 4
An application that takes the trouble to use information in
\&\f(CW\*(C`LC_MONETARY\*(C'\fR may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in \s-1US\s0
dollars instead of Hong Kong dollars.
.IP "\(bu" 4
The date and day names in dates formatted by \fIstrftime()\fR could be
manipulated to advantage by a malicious user able to subvert the
\&\f(CW\*(C`LC_DATE\*(C'\fR locale.  (\*(L"Look\*(--it says I wasn't in the building on
Sunday.\*(R")
.PP
Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.
.PP
Perl cannot protect you from all possibilities shown in the
examples\*(--there is no substitute for your own vigilance\*(--but, when
\&\f(CW\*(C`use locale\*(C'\fR is in effect, Perl uses the tainting mechanism (see
perlsec) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions that may be affected by
the locale:
.IP "\(bu" 4
\&\fBComparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`gt\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR):
.Sp
Scalar true/false (or less/equal/greater) result is never tainted.
.IP "\(bu" 4
\&\fBCase-mapping interpolation\fR (with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR)
.Sp
Result string containing interpolated material is tainted if
\&\f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fBMatching operator\fR (\f(CW\*(C`m//\*(C'\fR):
.Sp
Scalar true/false result never tainted.
.Sp
Subpatterns, either delivered as a list-context result or as \f(CW$1\fR etc.
are tainted if \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR)
is in effect, and the subpattern regular
expression contains \f(CW\*(C`\ew\*(C'\fR (to match an alphanumeric character), \f(CW\*(C`\eW\*(C'\fR
(non-alphanumeric character), \f(CW\*(C`\es\*(C'\fR (whitespace character), or \f(CW\*(C`\eS\*(C'\fR
(non whitespace character).  The matched-pattern variable, $&, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
\&\f(CW\*(C`use locale\*(C'\fR is in effect and the regular expression contains \f(CW\*(C`\ew\*(C'\fR,
\&\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR.
.IP "\(bu" 4
\&\fBSubstitution operator\fR (\f(CW\*(C`s///\*(C'\fR):
.Sp
Has the same behavior as the match operator.  Also, the left
operand of \f(CW\*(C`=~\*(C'\fR becomes tainted when \f(CW\*(C`use locale\*(C'\fR
(but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect if modified as
a result of a substitution based on a regular
expression match involving \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR; or of
case-mapping with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR,\f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR.
.IP "\(bu" 4
\&\fBOutput formatting functions\fR (\fIprintf()\fR and \fIwrite()\fR):
.Sp
Results are never tainted because otherwise even output from print,
for example \f(CW\*(C`print(1/7)\*(C'\fR, should be tainted if \f(CW\*(C`use locale\*(C'\fR is in
effect.
.IP "\(bu" 4
\&\fBCase-mapping functions\fR (\fIlc()\fR, \fIlcfirst()\fR, \fIuc()\fR, \fIucfirst()\fR):
.Sp
Results are tainted if \f(CW\*(C`use locale\*(C'\fR (but not
\&\f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 locale-dependent functions\fR (\fIlocaleconv()\fR, \fIstrcoll()\fR,
\&\fIstrftime()\fR, \fIstrxfrm()\fR):
.Sp
Results are never tainted.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 character class tests\fR (\fIisalnum()\fR, \fIisalpha()\fR, \fIisdigit()\fR,
\&\fIisgraph()\fR, \fIislower()\fR, \fIisprint()\fR, \fIispunct()\fR, \fIisspace()\fR, \fIisupper()\fR,
\&\fIisxdigit()\fR):
.Sp
True/false results are never tainted.
.PP
Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.
.PP
.Vb 2
\&        #/usr/local/bin/perl \-T
\&        # Run with taint checking
\&
\&        # Command line sanity check omitted...
\&        $tainted_output_file = shift;
\&
\&        open(F, ">$tainted_output_file")
\&            or warn "Open of $tainted_output_file failed: $!\en";
.Ve
.PP
The program can be made to run by \*(L"laundering\*(R" the tainted value through
a regular expression: the second example\*(--which still ignores locale
information\*(--runs, creating the file named on its command line
if it can.
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $untainted_output_file = $&;
\&
\&        open(F, ">$untainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
Compare this with a similar but locale-aware program:
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        use locale;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $localized_output_file = $&;
\&
\&        open(F, ">$localized_output_file")
\&            or warn "Open of $localized_output_file failed: $!\en";
.Ve
.PP
This third program fails to run because $& is tainted: it is the result
of a match involving \f(CW\*(C`\ew\*(C'\fR while \f(CW\*(C`use locale\*(C'\fR is in effect.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1PERL_BADLANG\s0" 12
.IX Item "PERL_BADLANG"
A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way\*(--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value that does not evaluate to integer
zero\*(--that is, \*(L"0\*(R" or ""\-\- Perl will complain about locale setting
failures.
.Sp
\&\fB\s-1NOTE\s0\fR: \s-1PERL_BADLANG\s0 only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.
.PP
The following environment variables are not specific to Perl: They are
part of the standardized (\s-1ISO C, XPG4, POSIX 1\s0.c) \fIsetlocale()\fR method
for controlling an application's opinion on data.
.IP "\s-1LC_ALL\s0" 12
.IX Item "LC_ALL"
\&\f(CW\*(C`LC_ALL\*(C'\fR is the \*(L"override-all\*(R" locale environment variable. If
set, it overrides all the rest of the locale environment variables.
.IP "\s-1LANGUAGE\s0" 12
.IX Item "LANGUAGE"
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`LANGUAGE\*(C'\fR is a \s-1GNU\s0 extension, it affects you only if you
are using the \s-1GNU\s0 libc.  This is the case if you are using e.g. Linux.
If you are using \*(L"commercial\*(R" Unixes you are most probably \fInot\fR
using \s-1GNU\s0 libc and you can ignore \f(CW\*(C`LANGUAGE\*(C'\fR.
.Sp
However, in the case you are using \f(CW\*(C`LANGUAGE\*(C'\fR: it affects the
language of informational, warning, and error messages output by
commands (in other words, it's like \f(CW\*(C`LC_MESSAGES\*(C'\fR) but it has higher
priority than \f(CW\*(C`LC_ALL\*(C'\fR.  Moreover, it's not a single value but
instead a \*(L"path\*(R" (\*(L":\*(R"\-separated list) of \fIlanguages\fR (not locales).
See the \s-1GNU \s0\f(CW\*(C`gettext\*(C'\fR library documentation for more information.
.IP "\s-1LC_CTYPE\s0" 12
.IX Item "LC_CTYPE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_CTYPE\*(C'\fR chooses the character type
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_CTYPE\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the character type locale.
.IP "\s-1LC_COLLATE\s0" 12
.IX Item "LC_COLLATE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_COLLATE\*(C'\fR chooses the collation
(sorting) locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the collation locale.
.IP "\s-1LC_MONETARY\s0" 12
.IX Item "LC_MONETARY"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_MONETARY\*(C'\fR chooses the monetary
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the monetary formatting locale.
.IP "\s-1LC_NUMERIC\s0" 12
.IX Item "LC_NUMERIC"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_NUMERIC\*(C'\fR chooses the numeric format
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_NUMERIC\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the numeric format.
.IP "\s-1LC_TIME\s0" 12
.IX Item "LC_TIME"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_TIME\*(C'\fR chooses the date and time
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_TIME\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the date and time formatting locale.
.IP "\s-1LANG\s0" 12
.IX Item "LANG"
\&\f(CW\*(C`LANG\*(C'\fR is the \*(L"catch-all\*(R" locale environment variable. If it is set, it
is used as the last resort after the overall \f(CW\*(C`LC_ALL\*(C'\fR and the
category-specific \f(CW\*(C`LC_...\*(C'\fR.
.SS "Examples"
.IX Subsection "Examples"
The \s-1LC_NUMERIC\s0 controls the numeric output:
.PP
.Vb 4
\&   use locale;
\&   use POSIX qw(locale_h); # Imports setlocale() and the LC_ constants.
\&   setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
\&   printf "%g\en", 1.23; # If the "fr_FR" succeeded, probably shows 1,23.
.Ve
.PP
and also how strings are parsed by \fIPOSIX::strtod()\fR as numbers:
.PP
.Vb 5
\&   use locale;
\&   use POSIX qw(locale_h strtod);
\&   setlocale(LC_NUMERIC, "de_DE") or die "Entschuldigung";
\&   my $x = strtod("2,34") + 5;
\&   print $x, "\en"; # Probably shows 7,34.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS "Backward compatibility"
.IX Subsection "Backward compatibility"
Versions of Perl prior to 5.004 \fBmostly\fR ignored locale information,
generally behaving as if something similar to the \f(CW"C"\fR locale were
always in force, even if the program environment suggested otherwise
(see \*(L"The setlocale function\*(R").  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you \fBmust\fR use the \f(CW\*(C`use\ locale\*(C'\fR
pragma (see \*(L"The use locale pragma\*(R") or, in the unlikely event
that you want to do so for just pattern matching, the
\&\f(CW\*(C`/l\*(C'\fR regular expression modifier (see \*(L"Character set
modifiers\*(R" in perlre) to instruct it to do so.
.PP
Versions of Perl from 5.002 to 5.003 did use the \f(CW\*(C`LC_CTYPE\*(C'\fR
information if available; that is, \f(CW\*(C`\ew\*(C'\fR did understand what
were the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.
.SS "I18N:Collate obsolete"
.IX Subsection "I18N:Collate obsolete"
In versions of Perl prior to 5.004, per-locale collation was possible
using the \f(CW\*(C`I18N::Collate\*(C'\fR library module.  This module is now mildly
obsolete and should be avoided in new applications.  The \f(CW\*(C`LC_COLLATE\*(C'\fR
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with \f(CW\*(C`use locale\*(C'\fR,
so there is no longer any need to juggle with the scalar references of
\&\f(CW\*(C`I18N::Collate\*(C'\fR.
.SS "Sort speed and memory use impacts"
.IX Subsection "Sort speed and memory use impacts"
Comparing and sorting by locale is usually slower than the default
sorting; slow-downs of two to four times have been observed.  It will
also consume more memory: once a Perl scalar variable has participated
in any string comparison or sorting operation obeying the locale
collation rules, it will take 3\-15 times more memory than before.  (The
exact multiplier depends on the string's contents, the operating system
and the locale.) These downsides are dictated more by the operating
system's implementation of the locale system than by Perl.
.SS "\fIwrite()\fP and \s-1LC_NUMERIC\s0"
.IX Subsection "write() and LC_NUMERIC"
If a program's environment specifies an \s-1LC_NUMERIC\s0 locale and \f(CW\*(C`use
locale\*(C'\fR is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by \f(CW\*(C`use locale\*(C'\fR at the time when \fIwrite()\fR
is called.
.SS "Freely available locale definitions"
.IX Subsection "Freely available locale definitions"
The Unicode \s-1CLDR\s0 project extracts the \s-1POSIX\s0 portion of many of its
locales, available at
.PP
.Vb 1
\&  http://unicode.org/Public/cldr/latest/
.Ve
.PP
There is a large collection of locale definitions at:
.PP
.Vb 1
\&  http://std.dkuug.dk/i18n/WG15\-collection/locales/
.Ve
.PP
You should be aware that it is
unsupported, and is not claimed to be fit for any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.
.SS "I18n and l10n"
.IX Subsection "I18n and l10n"
\&\*(L"Internationalization\*(R" is often abbreviated as \fBi18n\fR because its first
and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, \*(L"localization\*(R" is often abbreviated to \fBl10n\fR.
.SS "An imperfect standard"
.IX Subsection "An imperfect standard"
Internationalization, as defined in the C and \s-1POSIX\s0 standards, can be
criticized as incomplete, ungainly, and having too large a granularity.
(Locales apply to a whole process, when it would arguably be more useful
to have them apply to a single thread, window group, or whatever.)  They
also have a tendency, like standards groups, to divide the world into
nations, when we all know that the world can equally well be divided
into bankers, bikers, gamers, and so on.
.SH "Unicode and UTF\-8"
.IX Header "Unicode and UTF-8"
The support of Unicode is new starting from Perl version v5.6, and more fully
implemented in version v5.8 and later.  See perluniintro.  It is
strongly recommended that when combining Unicode and locale (starting in
v5.16), you use
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
When this form of the pragma is used, only the non-character portions of
locales are used by Perl, for example \f(CW\*(C`LC_NUMERIC\*(C'\fR.  Perl assumes that
you have translated all the characters it is to operate on into Unicode
(actually the platform's native character set (\s-1ASCII\s0 or \s-1EBCDIC\s0) plus
Unicode).  For data in files, this can conveniently be done by also
specifying
.PP
.Vb 1
\&    use open \*(Aq:locale\*(Aq;
.Ve
.PP
This pragma arranges for all inputs from files to be translated into
Unicode from the current locale as specified in the environment (see
\&\*(L"\s-1ENVIRONMENT\*(R"\s0), and all outputs to files to be translated back
into the locale.  (See open).  On a per-filehandle basis, you can
instead use the PerlIO::locale module, or the Encode::Locale
module, both available from \s-1CPAN. \s0 The latter module also has methods to
ease the handling of \f(CW\*(C`ARGV\*(C'\fR and environment variables, and can be used
on individual strings.  Also, if you know that all your locales will be
\&\s-1UTF\-8,\s0 as many are these days, you can use the \fB\-C\fR
command line switch.
.PP
This form of the pragma allows essentially seamless handling of locales
with Unicode.  The collation order will be Unicode's.  It is strongly
recommended that when you need to order and sort strings that you use
the standard module Unicode::Collate which gives much better results
in many instances than you can get with the old-style locale handling.
.PP
For pre\-v5.16 Perls, or if you use the locale pragma without the
\&\f(CW\*(C`:not_characters\*(C'\fR parameter, Perl tries to work with both Unicode and
locales\*(--but there are problems.
.PP
Perl does not handle multi-byte locales in this case, such as have been
used for various
Asian languages, such as Big5 or Shift \s-1JIS. \s0 However, the increasingly
common multi-byte \s-1UTF\-8\s0 locales, if properly implemented, may work
reasonably well (depending on your C library implementation) in this
form of the locale pragma, simply because both
they and Perl store characters that take up multiple bytes the same way.
However, some, if not most, C library implementations may not process
the characters in the upper half of the Latin\-1 range (128 \- 255)
properly under \s-1LC_CTYPE. \s0 To see if a character is a particular type
under a locale, Perl uses the functions like \f(CW\*(C`isalnum()\*(C'\fR.  Your C
library may not work for \s-1UTF\-8\s0 locales with those functions, instead
only working under the newer wide library functions like \f(CW\*(C`iswalnum()\*(C'\fR.
.PP
Perl generally takes the tack to use locale rules on code points that can fit
in a single byte, and Unicode rules for those that can't (though this
isn't uniformly applied, see the note at the end of this section).  This
prevents many problems in locales that aren't \s-1UTF\-8. \s0 Suppose the locale
is \s-1ISO8859\-7,\s0 Greek.  The character at 0xD7 there is a capital Chi. But
in the \s-1ISO8859\-1\s0 locale, Latin1, it is a multiplication sign.  The \s-1POSIX\s0
regular expression character class \f(CW\*(C`[[:alpha:]]\*(C'\fR will magically match
0xD7 in the Greek locale but not in the Latin one.
.PP
However, there are places where this breaks down.  Certain constructs are
for Unicode only, such as \f(CW\*(C`\ep{Alpha}\*(C'\fR.  They assume that 0xD7 always has its
Unicode meaning (or the equivalent on \s-1EBCDIC\s0 platforms).  Since Latin1 is a
subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and
Unicode, \f(CW\*(C`\ep{Alpha}\*(C'\fR will never match it, regardless of locale.  A similar
issue occurs with \f(CW\*(C`\eN{...}\*(C'\fR.  It is therefore a bad idea to use \f(CW\*(C`\ep{}\*(C'\fR or
\&\f(CW\*(C`\eN{}\*(C'\fR under plain \f(CW\*(C`use locale\*(C'\fR\-\-\fIunless\fR you can guarantee that the
locale will be a \s-1ISO8859\-1. \s0 Use \s-1POSIX\s0 character classes instead.
.PP
Another problem with this approach is that operations that cross the
single byte/multiple byte boundary are not well-defined, and so are
disallowed.  (This boundary is between the codepoints at 255/256.).
For example, lower casing \s-1LATIN CAPITAL LETTER Y WITH DIAERESIS \s0(U+0178)
should return \s-1LATIN SMALL LETTER Y WITH DIAERESIS \s0(U+00FF).  But in the
Greek locale, for example, there is no character at 0xFF, and Perl
has no way of knowing what the character at 0xFF is really supposed to
represent.  Thus it disallows the operation.  In this mode, the
lowercase of U+0178 is itself.
.PP
The same problems ensue if you enable automatic UTF\-8\-ification of your
standard file handles, default \f(CW\*(C`open()\*(C'\fR layer, and \f(CW@ARGV\fR on non\-ISO8859\-1,
non\-UTF\-8 locales (by using either the \fB\-C\fR command line switch or the
\&\f(CW\*(C`PERL_UNICODE\*(C'\fR environment variable; see perlrun).
Things are read in as \s-1UTF\-8,\s0 which would normally imply a Unicode
interpretation, but the presence of a locale causes them to be interpreted
in that locale instead.  For example, a 0xD7 code point in the Unicode
input, which should mean the multiplication sign, won't be interpreted by
Perl that way under the Greek locale.  This is not a problem
\&\fIprovided\fR you make certain that all locales will always and only be either
an \s-1ISO8859\-1,\s0 or, if you don't have a deficient C library, a \s-1UTF\-8\s0 locale.
.PP
Vendor locales are notoriously buggy, and it is difficult for Perl to test
its locale-handling code because this interacts with code that Perl has no
control over; therefore the locale-handling code in Perl may be buggy as
well.  (However, the Unicode-supplied locales should be better, and
there is a feed back mechanism to correct any problems.  See
\&\*(L"Freely available locale definitions\*(R".)
.PP
If you have Perl v5.16, the problems mentioned above go away if you use
the \f(CW\*(C`:not_characters\*(C'\fR parameter to the locale pragma (except for vendor
bugs in the non-character portions).  If you don't have v5.16, and you
\&\fIdo\fR have locales that work, using them may be worthwhile for certain
specific purposes, as long as you keep in mind the gotchas already
mentioned.  For example, if the collation for your locales works, it
runs faster under locales than under Unicode::Collate; and you gain
access to such things as the local currency symbol and the names of the
months and days of the week.  (But to hammer home the point, in v5.16,
you get this access without the downsides of locales by using the
\&\f(CW\*(C`:not_characters\*(C'\fR form of the pragma.)
.PP
Note: The policy of using locale rules for code points that can fit in a
byte, and Unicode rules for those that can't is not uniformly applied.
Pre\-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly
consistently to regular expression matching except for bracketed
character classes; in v5.14 it was extended to all regex matches; and in
v5.16 to the casing operations such as \f(CW"\eL"\fR and \f(CW\*(C`uc()\*(C'\fR.  For
collation, in all releases, the system's \f(CW\*(C`strxfrm()\*(C'\fR function is called,
and whatever it does is what you get.
.SH "BUGS"
.IX Header "BUGS"
.SS "Broken systems"
.IX Subsection "Broken systems"
In certain systems, the operating system's locale support
is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when
\&\f(CW\*(C`use locale\*(C'\fR is in effect.  When confronted with such a system,
please report in excruciating detail to <\fIperlbug@perl.org\fR>, and
also contact your vendor: bug fixes may exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I18N::Langinfo, perluniintro, perlunicode, open,
\&\*(L"isalnum\*(R" in \s-1POSIX\s0, \*(L"isalpha\*(R" in \s-1POSIX\s0,
\&\*(L"isdigit\*(R" in \s-1POSIX\s0, \*(L"isgraph\*(R" in \s-1POSIX\s0, \*(L"islower\*(R" in \s-1POSIX\s0,
\&\*(L"isprint\*(R" in \s-1POSIX\s0, \*(L"ispunct\*(R" in \s-1POSIX\s0, \*(L"isspace\*(R" in \s-1POSIX\s0,
\&\*(L"isupper\*(R" in \s-1POSIX\s0, \*(L"isxdigit\*(R" in \s-1POSIX\s0, \*(L"localeconv\*(R" in \s-1POSIX\s0,
\&\*(L"setlocale\*(R" in \s-1POSIX\s0, \*(L"strcoll\*(R" in \s-1POSIX\s0, \*(L"strftime\*(R" in \s-1POSIX\s0,
\&\*(L"strtod\*(R" in \s-1POSIX\s0, \*(L"strxfrm\*(R" in \s-1POSIX\s0.
.SH "HISTORY"
.IX Header "HISTORY"
Jarkko Hietaniemi's original \fIperli18n.pod\fR heavily hacked by Dominic
Dunlop, assisted by the perl5\-porters.  Prose worked over a bit by
Tom Christiansen, and updated by Perl 5 porters.
   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perllocale5.16.1                             0100644 0001750 0001750 00000177347 12566207421 023414  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLOCALE 1"
.TH PERLLOCALE 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllocale \- Perl locale handling (internationalization and localization)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In the beginning there was \s-1ASCII\s0, the \*(L"American Standard Code for
Information Interchange\*(R", which works quite well for Americans with
their English alphabet and dollar-denominated currency.  But it doesn't
work so well even for other English speakers, who may use different
currencies, such as the pound sterling (as the symbol for that currency
is not in \s-1ASCII\s0); and it's hopelessly inadequate for many of the
thousands of the world's other languages.
.PP
To address these deficiencies, the concept of locales was invented
(formally the \s-1ISO\s0 C, \s-1XPG4\s0, \s-1POSIX\s0 1.c \*(L"locale system\*(R").  And applications
were and are being written that use the locale mechanism.  The process of
making such an application take account of its users' preferences in
these kinds of matters is called \fBinternationalization\fR (often
abbreviated as \fBi18n\fR); telling such an application about a particular
set of preferences is known as \fBlocalization\fR (\fBl10n\fR).
.PP
Perl was extended, starting in 5.004, to support the locale system.  This
is controlled per application by using one pragma, one function call,
and several environment variables.
.PP
Unfortunately, there are quite a few deficiencies with the design (and
often, the implementations) of locales, and their use for character sets
has mostly been supplanted by Unicode (see perlunitut for an
introduction to that, and keep on reading here for how Unicode interacts
with locales in Perl).
.PP
Perl continues to support the old locale system, and starting in v5.16,
provides a hybrid way to use the Unicode character set, along with the
other portions of locales that may not be so problematic.
(Unicode is also creating \f(CW\*(C`CLDR\*(C'\fR, the \*(L"Common Locale Data Repository\*(R",
<http://cldr.unicode.org/> which includes more types of information than
are available in the \s-1POSIX\s0 locale system.  At the time of this writing,
there was no \s-1CPAN\s0 module that provides access to this XML-encoded data.
However, many of its locales have the POSIX-only data extracted, and are
available at <http://unicode.org/Public/cldr/latest/>.)
.SH "WHAT IS A LOCALE"
.IX Header "WHAT IS A LOCALE"
A locale is a set of data that describes various aspects of how various
communities in the world categorize their world.  These categories are
broken down into the following types (some of which include a brief
note here):
.IP "Category \s-1LC_NUMERIC:\s0 Numeric formatting" 4
.IX Item "Category LC_NUMERIC: Numeric formatting"
This indicates how numbers should be formatted for human readability,
for example the character used as the decimal point.
.IP "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts" 4
.IX Item "Category LC_MONETARY: Formatting of monetary amounts"
\&\ 
.IP "Category \s-1LC_TIME:\s0 Date/Time formatting" 4
.IX Item "Category LC_TIME: Date/Time formatting"
\&\ 
.IP "Category \s-1LC_MESSAGES:\s0 Error and other messages" 4
.IX Item "Category LC_MESSAGES: Error and other messages"
This for the most part is beyond the scope of Perl
.IP "Category \s-1LC_COLLATE:\s0 Collation" 4
.IX Item "Category LC_COLLATE: Collation"
This indicates the ordering of letters for comparision and sorting.
In Latin alphabets, for example, \*(L"b\*(R", generally follows \*(L"a\*(R".
.IP "Category \s-1LC_CTYPE:\s0 Character Types" 4
.IX Item "Category LC_CTYPE: Character Types"
This indicates, for example if a character is an uppercase letter.
.PP
More details on the categories are given below in \*(L"\s-1LOCALE\s0 \s-1CATEGORIES\s0\*(R".
.PP
Together, these categories go a long way towards being able to customize
a single program to run in many different locations.  But there are
deficiencies, so keep reading.
.SH "PREPARING TO USE LOCALES"
.IX Header "PREPARING TO USE LOCALES"
Perl will not use locales unless specifically requested to (see \*(L"\s-1NOTES\s0\*(R" below
for the partial exception of \f(CW\*(C`write()\*(C'\fR).  But even if there is such a
request, \fBall\fR of the following must be true for it to work properly:
.IP "\(bu" 4
\&\fBYour operating system must support the locale system\fR.  If it does,
you should find that the \fIsetlocale()\fR function is a documented part of
its C library.
.IP "\(bu" 4
\&\fBDefinitions for locales that you use must be installed\fR.  You, or
your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system.  Some systems
provide only a few, hard-wired locales and do not allow more to be
added.  Others allow you to add \*(L"canned\*(R" locales provided by the system
supplier.  Still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales that are not delivered with your operating
system.)  Read your system documentation for further illumination.
.IP "\(bu" 4
\&\fBPerl must believe that the locale system is supported\fR.  If it does,
\&\f(CW\*(C`perl \-V:d_setlocale\*(C'\fR will say that the value for \f(CW\*(C`d_setlocale\*(C'\fR is
\&\f(CW\*(C`define\*(C'\fR.
.PP
If you want a Perl application to process and present your data
according to a particular locale, the application code should include
the \f(CW\*(C`use\ locale\*(C'\fR pragma (see \*(L"The use locale pragma\*(R") where
appropriate, and \fBat least one\fR of the following must be true:
.IP "1." 4
\&\fBThe locale-determining environment variables (see \*(L"\s-1ENVIRONMENT\s0\*(R")
must be correctly set up\fR at the time the application is started, either
by yourself or by whomever set up your system account; or
.IP "2." 4
\&\fBThe application must set its own locale\fR using the method described in
\&\*(L"The setlocale function\*(R".
.SH "USING LOCALES"
.IX Header "USING LOCALES"
.SS "The use locale pragma"
.IX Subsection "The use locale pragma"
By default, Perl ignores the current locale.  The \f(CW\*(C`use\ locale\*(C'\fR
pragma tells Perl to use the current locale for some operations.
Starting in v5.16, there is an optional parameter to this pragma:
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
This parameter allows better mixing of locales and Unicode, and is
described fully in \*(L"Unicode and \s-1UTF\-8\s0\*(R", but briefly, it tells Perl to
not use the character portions of the locale definition, that is
the \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR categories.  Instead it will use the
native (extended by Unicode) character set.  When using this parameter,
you are responsible for getting the external character set translated
into the native/Unicode one (which it already will be if it is one of
the increasingly popular \s-1UTF\-8\s0 locales).  There are convenient ways of
doing this, as described in \*(L"Unicode and \s-1UTF\-8\s0\*(R".
.PP
The current locale is set at execution time by
\&\fIsetlocale()\fR described below.  If that function
hasn't yet been called in the course of the program's execution, the
current locale is that which was determined by the \*(L"\s-1ENVIRONMENT\s0\*(R" in
effect at the start of the program, except that
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR is always
initialized to the C locale (mentioned under \*(L"Finding locales\*(R").
If there is no valid environment, the current locale is undefined.  It
is likely, but not necessarily, the \*(L"C\*(R" locale.
.PP
The operations that are affected by locale are:
.ie n .IP "\fBUnder \fB""use locale \*(Aq:not_characters\*(Aq;""\fB\fR" 4
.el .IP "\fBUnder \f(CBuse locale \*(Aq:not_characters\*(Aq;\fB\fR" 4
.IX Item "Under use locale :not_characters;"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
\&\fBFormat declarations\fR (\fIformat()\fR) use \f(CW\*(C`LC_NUMERIC\*(C'\fR
.IP "\(bu" 4
\&\fBThe \s-1POSIX\s0 date formatting function\fR (\fIstrftime()\fR) uses \f(CW\*(C`LC_TIME\*(C'\fR.
.RE
.RS 4
.Sp
\&\ 
.RE
.ie n .IP "\fBUnder just plain \fB""use locale;""\fB\fR" 4
.el .IP "\fBUnder just plain \f(CBuse locale;\fB\fR" 4
.IX Item "Under just plain use locale;"
The above operations are affected, as well as the following:
.RS 4
.IP "\(bu" 4
\&\fBThe comparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, and \f(CW\*(C`gt\*(C'\fR) and
the \s-1POSIX\s0 string collation functions \fIstrcoll()\fR and \fIstrxfrm()\fR use
\&\f(CW\*(C`LC_COLLATE\*(C'\fR.  \fIsort()\fR is also affected if used without an
explicit comparison function, because it uses \f(CW\*(C`cmp\*(C'\fR by default.
.Sp
\&\fBNote:\fR \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`ne\*(C'\fR are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if \f(CW\*(C`cmp\*(C'\fR finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns \fI0\fR (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings\*(--which \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR may consider different\*(--are equal
as far as collation in the locale is concerned, see the discussion in
\&\*(L"Category \s-1LC_COLLATE:\s0 Collation\*(R".
.IP "\(bu" 4
\&\fBRegular expressions and case-modification functions\fR (\fIuc()\fR, \fIlc()\fR,
\&\fIucfirst()\fR, and \fIlcfirst()\fR) use \f(CW\*(C`LC_CTYPE\*(C'\fR
.RE
.RS 4
.RE
.PP
The default behavior is restored with the \f(CW\*(C`no\ locale\*(C'\fR pragma, or
upon reaching the end of the block enclosing \f(CW\*(C`use locale\*(C'\fR.
Note that \f(CW\*(C`use locale\*(C'\fR and \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR may be
nested, and that what is in effect within an inner scope will revert to
the outer scope's rules at the end of the inner scope.
.PP
The string result of any operation that uses locale
information is tainted, as it is possible for a locale to be
untrustworthy.  See \*(L"\s-1SECURITY\s0\*(R".
.SS "The setlocale function"
.IX Subsection "The setlocale function"
You can switch locales as often as you wish at run time with the
\&\fIPOSIX::setlocale()\fR function:
.PP
.Vb 2
\&        # This functionality not usable prior to Perl 5.004
\&        require 5.004;
\&
\&        # Import locale\-handling tool set from POSIX module.
\&        # This example uses: setlocale \-\- the function call
\&        #                    LC_CTYPE \-\- explained below
\&        use POSIX qw(locale_h);
\&
\&        # query and save the old locale
\&        $old_locale = setlocale(LC_CTYPE);
\&
\&        setlocale(LC_CTYPE, "fr_CA.ISO8859\-1");
\&        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859\-1"
\&
\&        setlocale(LC_CTYPE, "");
\&        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
\&        # environment variables.  See below for documentation.
\&
\&        # restore the old locale
\&        setlocale(LC_CTYPE, $old_locale);
.Ve
.PP
The first argument of \fIsetlocale()\fR gives the \fBcategory\fR, the second the
\&\fBlocale\fR.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
\&\*(L"\s-1LOCALE\s0 \s-1CATEGORIES\s0\*(R" and \*(L"\s-1ENVIRONMENT\s0\*(R".  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.
.PP
If no second argument is provided and the category is something else
than \s-1LC_ALL\s0, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to \fIsetlocale()\fR.
.PP
If no second argument is provided and the category is \s-1LC_ALL\s0, the
result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your \fIsetlocale\fR\|(3) man page for
details.
.PP
If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to \fIsetlocale()\fR.  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument\*(--think of it as an alias for the value you gave.)
.PP
As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.
.PP
If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns \fIundef\fR.
.PP
Note that Perl ignores the current \f(CW\*(C`LC_CTYPE\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR locales
within the scope of a \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR.
.PP
For further information about the categories, consult \fIsetlocale\fR\|(3).
.SS "Finding locales"
.IX Subsection "Finding locales"
For locales available in your system, consult also \fIsetlocale\fR\|(3) to
see whether it leads to the list of available locales (search for the
\&\fI\s-1SEE\s0 \s-1ALSO\s0\fR section).  If that fails, try the following command lines:
.PP
.Vb 1
\&        locale \-a
\&
\&        nlsinfo
\&
\&        ls /usr/lib/nls/loc
\&
\&        ls /usr/lib/locale
\&
\&        ls /usr/lib/nls
\&
\&        ls /usr/share/locale
.Ve
.PP
and see whether they list something resembling these
.PP
.Vb 7
\&        en_US.ISO8859\-1     de_DE.ISO8859\-1     ru_RU.ISO8859\-5
\&        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
\&        en_US               de_DE               ru_RU
\&        en                  de                  ru
\&        english             german              russian
\&        english.iso88591    german.iso88591     russian.iso88595
\&        english.roman8                          russian.koi8r
.Ve
.PP
Sadly, even though the calling interface for \fIsetlocale()\fR has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
\&\fIlanguage_territory\fR\fB.\fR\fIcodeset\fR, but the latter parts after
\&\fIlanguage\fR are not always present.  The \fIlanguage\fR and \fIcountry\fR
are usually from the standards \fB\s-1ISO\s0 3166\fR and \fB\s-1ISO\s0 639\fR, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The \fIcodeset\fR part often mentions some \fB\s-1ISO\s0
8859\fR character set, the Latin codesets.  For example, \f(CW\*(C`ISO 8859\-1\*(C'\fR
is the so-called \*(L"Western European codeset\*(R" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.
.PP
Two special locales are worth particular mention: \*(L"C\*(R" and \*(L"\s-1POSIX\s0\*(R".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the \s-1POSIX\s0 standard.  They define the \fBdefault locale\fR in which
every program starts in the absence of locale information in its
environment.  (The \fIdefault\fR default locale, if you will.)  Its language
is (American) English and its character codeset \s-1ASCII\s0.
\&\fBWarning\fR. The C locale delivered by some vendors may not
actually exactly match what the C standard calls for.  So beware.
.PP
\&\fB\s-1NOTE\s0\fR: Not all systems have the \*(L"\s-1POSIX\s0\*(R" locale (not all systems are
POSIX-conformant), so use \*(L"C\*(R" when you need explicitly to specify this
default locale.
.SS "\s-1LOCALE\s0 \s-1PROBLEMS\s0"
.IX Subsection "LOCALE PROBLEMS"
You may encounter the following warning message at Perl startup:
.PP
.Vb 6
\&        perl: warning: Setting locale failed.
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
\&        perl: warning: Falling back to the standard locale ("C").
.Ve
.PP
This means that your locale settings had \s-1LC_ALL\s0 set to \*(L"En_US\*(R" and
\&\s-1LANG\s0 exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the \*(L"C\*(R" locale, the default locale
that is supposed to work no matter what.  This usually means your locale
settings were wrong, they mention locales your system has never heard
of, or the locale installation in your system has problems (for example,
some system files are broken or missing).  There are quick and temporary
fixes to these problems, as well as more thorough and lasting fixes.
.SS "Temporarily fixing locale problems"
.IX Subsection "Temporarily fixing locale problems"
The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale \*(L"C\*(R".
.PP
Perl's moaning about locale problems can be silenced by setting the
environment variable \s-1PERL_BADLANG\s0 to a zero value, for example \*(L"0\*(R".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.
.PP
Perl can be run under the \*(L"C\*(R" locale by setting the environment
variable \s-1LC_ALL\s0 to \*(L"C\*(R".  This method is perhaps a bit more civilized
than the \s-1PERL_BADLANG\s0 approach, but setting \s-1LC_ALL\s0 (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See \*(L"\s-1ENVIRONMENT\s0\*(R" for
the full list of relevant environment variables and \*(L"\s-1USING\s0 \s-1LOCALES\s0\*(R"
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable \s-1LC_COLLATE\s0 may well affect
your \fBsort\fR program (or whatever the program that arranges \*(L"records\*(R"
alphabetically in your system is called).
.PP
You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For in
Bourne-like shells (\fBsh\fR, \fBksh\fR, \fBbash\fR, \fBzsh\fR):
.PP
.Vb 2
\&        LC_ALL=en_US.ISO8859\-1
\&        export LC_ALL
.Ve
.PP
This assumes that we saw the locale \*(L"en_US.ISO8859\-1\*(R" using the commands
discussed above.  We decided to try that instead of the above faulty
locale \*(L"En_US\*(R"\-\-and in Cshish shells (\fBcsh\fR, \fBtcsh\fR)
.PP
.Vb 1
\&        setenv LC_ALL en_US.ISO8859\-1
.Ve
.PP
or if you have the \*(L"env\*(R" application you can do in any shell
.PP
.Vb 1
\&        env LC_ALL=en_US.ISO8859\-1 perl ...
.Ve
.PP
If you do not know what shell you have, consult your local
helpdesk or the equivalent.
.SS "Permanently fixing locale problems"
.IX Subsection "Permanently fixing locale problems"
The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your friendly system administrator.
.PP
First, see earlier in this document about \*(L"Finding locales\*(R".  That tells
how to find which locales are really supported\*(--and more importantly,
installed\*(--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
\&\s-1LC_ALL\s0 set to \*(L"En_US\*(R" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.
.PP
Second, if using the listed commands you see something \fBexactly\fR
(prefix matches do not count and case usually counts) like \*(L"En_US\*(R"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see \*(L"Permanently fixing your system's locale configuration\*(R".
.SS "Permanently fixing your system's locale configuration"
.IX Subsection "Permanently fixing your system's locale configuration"
This is when you see something like:
.PP
.Vb 4
\&        perl: warning: Please check that your locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            are supported and installed on your system.
.Ve
.PP
but then cannot see that \*(L"En_US\*(R" listed by the above-mentioned
commands.  You may see things like \*(L"en_US.ISO8859\-1\*(R", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
\&\*(L"Finding locales\*(R" about general rules.
.SS "Fixing system locale configuration"
.IX Subsection "Fixing system locale configuration"
Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The \*(L"Finding locales\*(R"
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.
.SS "The localeconv function"
.IX Subsection "The localeconv function"
The \fIPOSIX::localeconv()\fR function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR locales.  (If you just want the name of
the current locale for a particular category, use \fIPOSIX::setlocale()\fR
with a single parameter\*(--see \*(L"The setlocale function\*(R".)
.PP
.Vb 1
\&        use POSIX qw(locale_h);
\&
\&        # Get a reference to a hash of locale\-dependent info
\&        $locale_values = localeconv();
\&
\&        # Output sorted list of the values
\&        for (sort keys %$locale_values) {
\&            printf "%\-20s = %s\en", $_, $locale_values\->{$_}
\&        }
.Ve
.PP
\&\fIlocaleconv()\fR takes no arguments, and returns \fBa reference to\fR a hash.
The keys of this hash are variable names for formatting, such as
\&\f(CW\*(C`decimal_point\*(C'\fR and \f(CW\*(C`thousands_sep\*(C'\fR.  The values are the
corresponding, er, values.  See \*(L"localeconv\*(R" in \s-1POSIX\s0 for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit \f(CW\*(C`use locale\*(C'\fR, because \fIlocaleconv()\fR always observes the
current locale.
.PP
Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:
.PP
.Vb 3
\&    # See comments in previous example
\&    require 5.004;
\&    use POSIX qw(locale_h);
\&
\&    # Get some of locale\*(Aqs numeric formatting parameters
\&    my ($thousands_sep, $grouping) =
\&            @{localeconv()}{\*(Aqthousands_sep\*(Aq, \*(Aqgrouping\*(Aq};
\&
\&    # Apply defaults if values are missing
\&    $thousands_sep = \*(Aq,\*(Aq unless $thousands_sep;
\&
\&    # grouping and mon_grouping are packed lists
\&    # of small integers (characters) telling the
\&    # grouping (thousand_seps and mon_thousand_seps
\&    # being the group dividers) of numbers and
\&    # monetary quantities.  The integers\*(Aq meanings:
\&    # 255 means no more grouping, 0 means repeat
\&    # the previous grouping, 1\-254 means use that
\&    # as the current grouping.  Grouping goes from
\&    # right to left (low to high digits).  In the
\&    # below we cheat slightly by never using anything
\&    # else than the first grouping (whatever that is).
\&    if ($grouping) {
\&        @grouping = unpack("C*", $grouping);
\&    } else {
\&        @grouping = (3);
\&    }
\&
\&    # Format command line params for current locale
\&    for (@ARGV) {
\&        $_ = int;    # Chop non\-integer part
\&        1 while
\&        s/(\ed)(\ed{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
\&        print "$_";
\&    }
\&    print "\en";
.Ve
.SS "I18N::Langinfo"
.IX Subsection "I18N::Langinfo"
Another interface for querying locale-dependent information is the
\&\fII18N::Langinfo::langinfo()\fR function, available at least in Unix-like
systems and \s-1VMS\s0.
.PP
The following example will import the \fIlanginfo()\fR function itself and
three constants to be used as arguments to \fIlanginfo()\fR: a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.
.PP
.Vb 1
\&    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);
\&
\&    my ($abday_1, $yesstr, $nostr)
\&                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);
\&
\&    print "$abday_1? [$yesstr/$nostr] ";
.Ve
.PP
In other words, in the \*(L"C\*(R" (or English) locale the above will probably
print something like:
.PP
.Vb 1
\&    Sun? [yes/no]
.Ve
.PP
See I18N::Langinfo for more information.
.SH "LOCALE CATEGORIES"
.IX Header "LOCALE CATEGORIES"
The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See \*(L"\s-1ENVIRONMENT\s0\*(R" for a discussion of these.
.SS "Category \s-1LC_COLLATE:\s0 Collation"
.IX Subsection "Category LC_COLLATE: Collation"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl looks to the \f(CW\*(C`LC_COLLATE\*(C'\fR
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, \*(L"b\*(R" follows \*(L"a\*(R" in Latin
alphabets, but where do \*(L"a\*'\*(R" and \*(L"a\*o\*(R" belong?  And while
\&\*(L"color\*(R" follows \*(L"chocolate\*(R" in English, what about in Spanish?
.PP
The following collations all make sense and you may meet any of them
if you \*(L"use locale\*(R".
.PP
.Vb 4
\&        A B C D E a b c d e
\&        A a B b C c D d E e
\&        a A b B c C d D e E
\&        a b c d e A B C D E
.Ve
.PP
Here is a code snippet to tell what \*(L"word\*(R"
characters are in the current locale, in that locale's order:
.PP
.Vb 2
\&        use locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:
.PP
.Vb 2
\&        no locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
This machine-native collation (which is what you get unless \f(CW\*(C`use\ locale\*(C'\fR has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.
.PP
As noted in \*(L"\s-1USING\s0 \s-1LOCALES\s0\*(R", \f(CW\*(C`cmp\*(C'\fR compares according to the current
collation locale when \f(CW\*(C`use locale\*(C'\fR is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use \fIPOSIX::strcoll()\fR if you don't want this fall-back:
.PP
.Vb 3
\&        use POSIX qw(strcoll);
\&        $equal_in_locale =
\&            !strcoll("space and case ignored", "SpaceAndCaseIgnored");
.Ve
.PP
\&\f(CW$equal_in_locale\fR will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.
.PP
If you have a single string that you want to check for \*(L"equality in
locale\*(R" against several others, you might think you could gain a little
efficiency by using \fIPOSIX::strxfrm()\fR in conjunction with \f(CW\*(C`eq\*(C'\fR:
.PP
.Vb 8
\&        use POSIX qw(strxfrm);
\&        $xfrm_string = strxfrm("Mixed\-case string");
\&        print "locale collation ignores spaces\en"
\&            if $xfrm_string eq strxfrm("Mixed\-casestring");
\&        print "locale collation ignores hyphens\en"
\&            if $xfrm_string eq strxfrm("Mixedcase string");
\&        print "locale collation ignores case\en"
\&            if $xfrm_string eq strxfrm("mixed\-case string");
.Ve
.PP
\&\fIstrxfrm()\fR takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  \*(L"Under the hood\*(R", locale-affected Perl comparison operators
call \fIstrxfrm()\fR for both operands, then do a char-by-char
comparison of the transformed strings.  By calling \fIstrxfrm()\fR explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see \*(L"Magic Variables\*(R" in perlguts) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
\&\f(CW\*(C`cmp\*(C'\fR runs just about as fast.  It also copes with null characters
embedded in strings; if you call \fIstrxfrm()\fR directly, it treats the first
null it finds as a terminator.  don't expect the transformed strings
it produces to be portable across systems\*(--or even from one revision
of your operating system to the next.  In short, don't call \fIstrxfrm()\fR
directly: let Perl do it for you.
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't shown in some of these examples because it isn't
needed: \fIstrcoll()\fR and \fIstrxfrm()\fR exist only to generate locale-dependent
results, and so always obey the current \f(CW\*(C`LC_COLLATE\*(C'\fR locale.
.SS "Category \s-1LC_CTYPE:\s0 Character Types"
.IX Subsection "Category LC_CTYPE: Character Types"
In the scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl obeys the \f(CW\*(C`LC_CTYPE\*(C'\fR locale
setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's \f(CW\*(C`\ew\*(C'\fR regular expression metanotation,
which stands for alphanumeric characters\*(--that is, alphabetic,
numeric, and including other special characters such as the underscore or
hyphen.  (Consult perlre for more information about
regular expressions.)  Thanks to \f(CW\*(C`LC_CTYPE\*(C'\fR, depending on your locale
setting, characters like \*(L"\*(ae\*(R", \*(L"\*(d-\*(R", \*(L"\*8\*(R", and
\&\*(L"o\*/\*(R" may be understood as \f(CW\*(C`\ew\*(C'\fR characters.
.PP
The \f(CW\*(C`LC_CTYPE\*(C'\fR locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions\*(--\fIlc()\fR, lcfirst, \fIuc()\fR, and \fIucfirst()\fR; case-mapping
interpolation with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR in double-quoted strings
and \f(CW\*(C`s///\*(C'\fR substitutions; and case-independent regular expression
pattern matching using the \f(CW\*(C`i\*(C'\fR modifier.
.PP
Finally, \f(CW\*(C`LC_CTYPE\*(C'\fR affects the \s-1POSIX\s0 character-class test
functions\*(--\fIisalpha()\fR, \fIislower()\fR, and so on.  For example, if you move
from the \*(L"C\*(R" locale to a 7\-bit Scandinavian one, you may find\*(--possibly
to your surprise\*(--that \*(L"|\*(R" moves from the \fIispunct()\fR class to \fIisalpha()\fR.
Unfortunately, this creates big problems for regular expressions. \*(L"|\*(R" still
means alternation even though it matches \f(CW\*(C`\ew\*(C'\fR.
.PP
\&\fBNote:\fR A broken or malicious \f(CW\*(C`LC_CTYPE\*(C'\fR locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) \s-1ASCII\s0 letters and
digits\*(--for example, in command strings\*(--locale\-aware applications
should use \f(CW\*(C`\ew\*(C'\fR with the \f(CW\*(C`/a\*(C'\fR regular expression modifier.  See \*(L"\s-1SECURITY\s0\*(R".
.SS "Category \s-1LC_NUMERIC:\s0 Numeric Formatting"
.IX Subsection "Category LC_NUMERIC: Numeric Formatting"
After a proper \fIPOSIX::setlocale()\fR call, Perl obeys the \f(CW\*(C`LC_NUMERIC\*(C'\fR
locale information, which controls an application's idea of how numbers
should be formatted for human readability by the \fIprintf()\fR, \fIsprintf()\fR, and
\&\fIwrite()\fR functions. String-to-numeric conversion by the \fIPOSIX::strtod()\fR
function is also affected.  In most implementations the only effect is to
change the character used for the decimal point\*(--perhaps from \*(L".\*(R"  to \*(L",\*(R".
These functions aren't aware of such niceties as thousands separation and
so on. (See \*(L"The localeconv function\*(R" if you care about these things.)
.PP
Output produced by \fIprint()\fR is also affected by the current locale: it
corresponds to what you'd get from \fIprintf()\fR in the \*(L"C\*(R" locale.  The
same is true for Perl's internal conversions between numeric and
string formats:
.PP
.Vb 1
\&        use POSIX qw(strtod setlocale LC_NUMERIC);
\&
\&        setlocale LC_NUMERIC, "";
\&
\&        $n = 5/2;   # Assign numeric 2.5 to $n
\&
\&        $a = " $n"; # Locale\-dependent conversion to string
\&
\&        print "half five is $n\en";       # Locale\-dependent output
\&
\&        printf "half five is %g\en", $n;  # Locale\-dependent output
\&
\&        print "DECIMAL POINT IS COMMA\en"
\&            if $n == (strtod("2,5"))[0]; # Locale\-dependent conversion
.Ve
.PP
See also I18N::Langinfo and \f(CW\*(C`RADIXCHAR\*(C'\fR.
.SS "Category \s-1LC_MONETARY:\s0 Formatting of monetary amounts"
.IX Subsection "Category LC_MONETARY: Formatting of monetary amounts"
The C standard defines the \f(CW\*(C`LC_MONETARY\*(C'\fR category, but not a function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use \f(CW\*(C`LC_MONETARY\*(C'\fR, you can query its contents\*(--see
\&\*(L"The localeconv function\*(R"\-\-and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.
.PP
See also I18N::Langinfo and \f(CW\*(C`CRNCYSTR\*(C'\fR.
.SS "\s-1LC_TIME\s0"
.IX Subsection "LC_TIME"
Output produced by \fIPOSIX::strftime()\fR, which builds a formatted
human-readable date/time string, is affected by the current \f(CW\*(C`LC_TIME\*(C'\fR
locale.  Thus, in a French locale, the output produced by the \f(CW%B\fR
format element (full month name) for the first month of the year would
be \*(L"janvier\*(R".  Here's how to get a list of long month names in the
current locale:
.PP
.Vb 5
\&        use POSIX qw(strftime);
\&        for (0..11) {
\&            $long_month_name[$_] =
\&                strftime("%B", 0, 0, 0, 1, $_, 96);
\&        }
.Ve
.PP
Note: \f(CW\*(C`use locale\*(C'\fR isn't needed in this example: as a function that
exists only to generate locale-dependent results, \fIstrftime()\fR always
obeys the current \f(CW\*(C`LC_TIME\*(C'\fR locale.
.PP
See also I18N::Langinfo and \f(CW\*(C`ABDAY_1\*(C'\fR..\f(CW\*(C`ABDAY_7\*(C'\fR, \f(CW\*(C`DAY_1\*(C'\fR..\f(CW\*(C`DAY_7\*(C'\fR,
\&\f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR, and \f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR.
.SS "Other categories"
.IX Subsection "Other categories"
The remaining locale category, \f(CW\*(C`LC_MESSAGES\*(C'\fR (possibly supplemented
by others in particular implementations) is not currently used by
Perl\*(--except possibly to affect the behavior of library functions
called by extensions outside the standard Perl distribution and by the
operating system and its utilities.  Note especially that the string
value of \f(CW$!\fR and the error messages given by external utilities may
be changed by \f(CW\*(C`LC_MESSAGES\*(C'\fR.  If you want to have portable error
codes, use \f(CW\*(C`%!\*(C'\fR.  See Errno.
.SH "SECURITY"
.IX Header "SECURITY"
Although the main discussion of Perl security issues can be found in
perlsec, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales\*(--particularly on systems that allow unprivileged users to
build their own locales\*(--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:
.IP "\(bu" 4
Regular expression checks for safe file names or mail addresses using
\&\f(CW\*(C`\ew\*(C'\fR may be spoofed by an \f(CW\*(C`LC_CTYPE\*(C'\fR locale that claims that
characters such as \*(L">\*(R" and \*(L"|\*(R" are alphanumeric.
.IP "\(bu" 4
String interpolation with case-mapping, as in, say, \f(CW\*(C`$dest =
"C:\eU$name.$ext"\*(C'\fR, may produce dangerous results if a bogus \s-1LC_CTYPE\s0
case-mapping table is in effect.
.IP "\(bu" 4
A sneaky \f(CW\*(C`LC_COLLATE\*(C'\fR locale could result in the names of students with
\&\*(L"D\*(R" grades appearing ahead of those with \*(L"A\*(R"s.
.IP "\(bu" 4
An application that takes the trouble to use information in
\&\f(CW\*(C`LC_MONETARY\*(C'\fR may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in \s-1US\s0
dollars instead of Hong Kong dollars.
.IP "\(bu" 4
The date and day names in dates formatted by \fIstrftime()\fR could be
manipulated to advantage by a malicious user able to subvert the
\&\f(CW\*(C`LC_DATE\*(C'\fR locale.  (\*(L"Look\*(--it says I wasn't in the building on
Sunday.\*(R")
.PP
Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.
.PP
Perl cannot protect you from all possibilities shown in the
examples\*(--there is no substitute for your own vigilance\*(--but, when
\&\f(CW\*(C`use locale\*(C'\fR is in effect, Perl uses the tainting mechanism (see
perlsec) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions that may be affected by
the locale:
.IP "\(bu" 4
\&\fBComparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`gt\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR):
.Sp
Scalar true/false (or less/equal/greater) result is never tainted.
.IP "\(bu" 4
\&\fBCase-mapping interpolation\fR (with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR)
.Sp
Result string containing interpolated material is tainted if
\&\f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fBMatching operator\fR (\f(CW\*(C`m//\*(C'\fR):
.Sp
Scalar true/false result never tainted.
.Sp
Subpatterns, either delivered as a list-context result or as \f(CW$1\fR etc.
are tainted if \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR)
is in effect, and the subpattern regular
expression contains \f(CW\*(C`\ew\*(C'\fR (to match an alphanumeric character), \f(CW\*(C`\eW\*(C'\fR
(non-alphanumeric character), \f(CW\*(C`\es\*(C'\fR (whitespace character), or \f(CW\*(C`\eS\*(C'\fR
(non whitespace character).  The matched-pattern variable, $&, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
\&\f(CW\*(C`use locale\*(C'\fR is in effect and the regular expression contains \f(CW\*(C`\ew\*(C'\fR,
\&\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR.
.IP "\(bu" 4
\&\fBSubstitution operator\fR (\f(CW\*(C`s///\*(C'\fR):
.Sp
Has the same behavior as the match operator.  Also, the left
operand of \f(CW\*(C`=~\*(C'\fR becomes tainted when \f(CW\*(C`use locale\*(C'\fR
(but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect if modified as
a result of a substitution based on a regular
expression match involving \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR; or of
case-mapping with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR,\f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR.
.IP "\(bu" 4
\&\fBOutput formatting functions\fR (\fIprintf()\fR and \fIwrite()\fR):
.Sp
Results are never tainted because otherwise even output from print,
for example \f(CW\*(C`print(1/7)\*(C'\fR, should be tainted if \f(CW\*(C`use locale\*(C'\fR is in
effect.
.IP "\(bu" 4
\&\fBCase-mapping functions\fR (\fIlc()\fR, \fIlcfirst()\fR, \fIuc()\fR, \fIucfirst()\fR):
.Sp
Results are tainted if \f(CW\*(C`use locale\*(C'\fR (but not
\&\f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is in effect.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 locale-dependent functions\fR (\fIlocaleconv()\fR, \fIstrcoll()\fR,
\&\fIstrftime()\fR, \fIstrxfrm()\fR):
.Sp
Results are never tainted.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 character class tests\fR (\fIisalnum()\fR, \fIisalpha()\fR, \fIisdigit()\fR,
\&\fIisgraph()\fR, \fIislower()\fR, \fIisprint()\fR, \fIispunct()\fR, \fIisspace()\fR, \fIisupper()\fR,
\&\fIisxdigit()\fR):
.Sp
True/false results are never tainted.
.PP
Three examples illustrate locale-dependent tainting.
The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.
.PP
.Vb 2
\&        #/usr/local/bin/perl \-T
\&        # Run with taint checking
\&
\&        # Command line sanity check omitted...
\&        $tainted_output_file = shift;
\&
\&        open(F, ">$tainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
The program can be made to run by \*(L"laundering\*(R" the tainted value through
a regular expression: the second example\*(--which still ignores locale
information\*(--runs, creating the file named on its command line
if it can.
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $untainted_output_file = $&;
\&
\&        open(F, ">$untainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
Compare this with a similar but locale-aware program:
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        use locale;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $localized_output_file = $&;
\&
\&        open(F, ">$localized_output_file")
\&            or warn "Open of $localized_output_file failed: $!\en";
.Ve
.PP
This third program fails to run because $& is tainted: it is the result
of a match involving \f(CW\*(C`\ew\*(C'\fR while \f(CW\*(C`use locale\*(C'\fR is in effect.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1PERL_BADLANG\s0" 12
.IX Item "PERL_BADLANG"
A string that can suppress Perl's warning about failed locale settings
at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way\*(--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value that does not evaluate to integer
zero\*(--that is, \*(L"0\*(R" or ""\-\- Perl will complain about locale setting
failures.
.Sp
\&\fB\s-1NOTE\s0\fR: \s-1PERL_BADLANG\s0 only gives you a way to hide the warning message.
The message tells about some problem in your system's locale support,
and you should investigate what the problem is.
.PP
The following environment variables are not specific to Perl: They are
part of the standardized (\s-1ISO\s0 C, \s-1XPG4\s0, \s-1POSIX\s0 1.c) \fIsetlocale()\fR method
for controlling an application's opinion on data.
.IP "\s-1LC_ALL\s0" 12
.IX Item "LC_ALL"
\&\f(CW\*(C`LC_ALL\*(C'\fR is the \*(L"override-all\*(R" locale environment variable. If
set, it overrides all the rest of the locale environment variables.
.IP "\s-1LANGUAGE\s0" 12
.IX Item "LANGUAGE"
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`LANGUAGE\*(C'\fR is a \s-1GNU\s0 extension, it affects you only if you
are using the \s-1GNU\s0 libc.  This is the case if you are using e.g. Linux.
If you are using \*(L"commercial\*(R" Unixes you are most probably \fInot\fR
using \s-1GNU\s0 libc and you can ignore \f(CW\*(C`LANGUAGE\*(C'\fR.
.Sp
However, in the case you are using \f(CW\*(C`LANGUAGE\*(C'\fR: it affects the
language of informational, warning, and error messages output by
commands (in other words, it's like \f(CW\*(C`LC_MESSAGES\*(C'\fR) but it has higher
priority than \f(CW\*(C`LC_ALL\*(C'\fR.  Moreover, it's not a single value but
instead a \*(L"path\*(R" (\*(L":\*(R"\-separated list) of \fIlanguages\fR (not locales).
See the \s-1GNU\s0 \f(CW\*(C`gettext\*(C'\fR library documentation for more information.
.IP "\s-1LC_CTYPE\s0" 12
.IX Item "LC_CTYPE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_CTYPE\*(C'\fR chooses the character type
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_CTYPE\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the character type locale.
.IP "\s-1LC_COLLATE\s0" 12
.IX Item "LC_COLLATE"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_COLLATE\*(C'\fR chooses the collation
(sorting) locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_COLLATE\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the collation locale.
.IP "\s-1LC_MONETARY\s0" 12
.IX Item "LC_MONETARY"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_MONETARY\*(C'\fR chooses the monetary
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_MONETARY\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the monetary formatting locale.
.IP "\s-1LC_NUMERIC\s0" 12
.IX Item "LC_NUMERIC"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_NUMERIC\*(C'\fR chooses the numeric format
locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_NUMERIC\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses the numeric format.
.IP "\s-1LC_TIME\s0" 12
.IX Item "LC_TIME"
In the absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_TIME\*(C'\fR chooses the date and time
formatting locale.  In the absence of both \f(CW\*(C`LC_ALL\*(C'\fR and \f(CW\*(C`LC_TIME\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chooses the date and time formatting locale.
.IP "\s-1LANG\s0" 12
.IX Item "LANG"
\&\f(CW\*(C`LANG\*(C'\fR is the \*(L"catch-all\*(R" locale environment variable. If it is set, it
is used as the last resort after the overall \f(CW\*(C`LC_ALL\*(C'\fR and the
category-specific \f(CW\*(C`LC_...\*(C'\fR.
.SS "Examples"
.IX Subsection "Examples"
The \s-1LC_NUMERIC\s0 controls the numeric output:
.PP
.Vb 4
\&   use locale;
\&   use POSIX qw(locale_h); # Imports setlocale() and the LC_ constants.
\&   setlocale(LC_NUMERIC, "fr_FR") or die "Pardon";
\&   printf "%g\en", 1.23; # If the "fr_FR" succeeded, probably shows 1,23.
.Ve
.PP
and also how strings are parsed by \fIPOSIX::strtod()\fR as numbers:
.PP
.Vb 5
\&   use locale;
\&   use POSIX qw(locale_h strtod);
\&   setlocale(LC_NUMERIC, "de_DE") or die "Entschuldigung";
\&   my $x = strtod("2,34") + 5;
\&   print $x, "\en"; # Probably shows 7,34.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS "Backward compatibility"
.IX Subsection "Backward compatibility"
Versions of Perl prior to 5.004 \fBmostly\fR ignored locale information,
generally behaving as if something similar to the \f(CW"C"\fR locale were
always in force, even if the program environment suggested otherwise
(see \*(L"The setlocale function\*(R").  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you \fBmust\fR use the \f(CW\*(C`use\ locale\*(C'\fR
pragma (see \*(L"The use locale pragma\*(R") or, in the unlikely event
that you want to do so for just pattern matching, the
\&\f(CW\*(C`/l\*(C'\fR regular expression modifier (see \*(L"Character set
mod