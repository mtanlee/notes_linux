e aware
.IP "\(bu" 2
\&\f(CW\*(C`predicate\*(C'\fR
.Sp
Takes a method name which will return true if an attribute has a value.
.Sp
If you set this to just \f(CW1\fR, the predicate is automatically named
\&\f(CW\*(C`has_${attr_name}\*(C'\fR if your attribute's name does not start with an
underscore, or \f(CW\*(C`_has_${attr_name_without_the_underscore}\*(C'\fR if it does.
This feature comes from MooseX::AttributeShortcuts.
.IP "\(bu" 2
\&\f(CW\*(C`builder\*(C'\fR
.Sp
Takes a method name which will be called to create the attribute \- functions
exactly like default except that instead of calling
.Sp
.Vb 1
\&  $default\->($self);
.Ve
.Sp
Moo will call
.Sp
.Vb 1
\&  $self\->$builder;
.Ve
.Sp
The following features come from MooseX::AttributeShortcuts:
.Sp
If you set this to just \f(CW1\fR, the builder is automatically named
\&\f(CW\*(C`_build_${attr_name}\*(C'\fR.
.Sp
If you set this to a coderef or code-convertible object, that variable will be
installed under \f(CW\*(C`$class::_build_${attr_name}\*(C'\fR and the builder set to the same
name.
.IP "\(bu" 2
\&\f(CW\*(C`clearer\*(C'\fR
.Sp
Takes a method name which will clear the attribute.
.Sp
If you set this to just \f(CW1\fR, the clearer is automatically named
\&\f(CW\*(C`clear_${attr_name}\*(C'\fR if your attribute's name does not start with an
underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
This feature comes from MooseX::AttributeShortcuts.
.IP "\(bu" 2
\&\f(CW\*(C`lazy\*(C'\fR
.Sp
\&\fBBoolean\fR.  Set this if you want values for the attribute to be grabbed
lazily.  This is usually a good idea if you have a \*(L"builder\*(R" which requires
another attribute to be set.
.IP "\(bu" 2
\&\f(CW\*(C`required\*(C'\fR
.Sp
\&\fBBoolean\fR.  Set this if the attribute must be passed on instantiation.
.IP "\(bu" 2
\&\f(CW\*(C`reader\*(C'\fR
.Sp
The value of this attribute will be the name of the method to get the value of
the attribute.  If you like Java style methods, you might set this to
\&\f(CW\*(C`get_foo\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`writer\*(C'\fR
.Sp
The value of this attribute will be the name of the method to set the value of
the attribute.  If you like Java style methods, you might set this to
\&\f(CW\*(C`set_foo\*(C'\fR.
.IP "\(bu" 2
\&\f(CW\*(C`weak_ref\*(C'\fR
.Sp
\&\fBBoolean\fR.  Set this if you want the reference that the attribute contains to
be weakened; use this when circular references are possible, which will cause
leaks.
.IP "\(bu" 2
\&\f(CW\*(C`init_arg\*(C'\fR
.Sp
Takes the name of the key to look for at instantiation time of the object.  A
common use of this is to make an underscored attribute have a non-underscored
initialization name. \f(CW\*(C`undef\*(C'\fR means that passing the value in on instantiation
is ignored.
.IP "\(bu" 2
\&\f(CW\*(C`moosify\*(C'\fR
.Sp
Takes either a coderef or array of coderefs which is meant to transform the
given attributes specifications if necessary when upgrading to a Moose role or
class. You shouldn't need this by default, but is provided as a means of
possible extensibility.
.SS "before"
.IX Subsection "before"
.Vb 1
\& before foo => sub { ... };
.Ve
.PP
See \*(L"before method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SS "around"
.IX Subsection "around"
.Vb 1
\& around foo => sub { ... };
.Ve
.PP
See \*(L"around method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SS "after"
.IX Subsection "after"
.Vb 1
\& after foo => sub { ... };
.Ve
.PP
See \*(L"after method(s) => sub { ... }\*(R" in Class::Method::Modifiers for full
documentation.
.SH "SUB QUOTE AWARE"
.IX Header "SUB QUOTE AWARE"
\&\*(L"quote_sub\*(R" in Sub::Quote allows us to create coderefs that are \*(L"inlineable,\*(R"
giving us a handy, XS-free speed boost.  Any option that is Sub::Quote
aware can take advantage of this.
.PP
To do this, you can write
.PP
.Vb 1
\&  use Sub::Quote;
\&
\&  use Moo;
\&  use namespace::clean;
\&
\&  has foo => (
\&    is => \*(Aqro\*(Aq,
\&    isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
\&  );
.Ve
.PP
which will be inlined as
.PP
.Vb 4
\&  do {
\&    local @_ = ($_[0]\->{foo});
\&    die "Not <3" unless $_[0] < 3;
\&  }
.Ve
.PP
or to avoid localizing \f(CW@_\fR,
.PP
.Vb 4
\&  has foo => (
\&    is => \*(Aqro\*(Aq,
\&    isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
\&  );
.Ve
.PP
which will be inlined as
.PP
.Vb 4
\&  do {
\&    my ($val) = ($_[0]\->{foo});
\&    die "Not <3" unless $val < 3;
\&  }
.Ve
.PP
See Sub::Quote for more information, including how to pass lexical
captures that will also be compiled into the subroutine.
.SH "CLEANING UP IMPORTS"
.IX Header "CLEANING UP IMPORTS"
Moo will not clean up imported subroutines for you; you will have
to do that manually. The recommended way to do this is to declare your
imports first, then \f(CW\*(C`use Moo\*(C'\fR, then \f(CW\*(C`use namespace::clean\*(C'\fR.
Anything imported before namespace::clean will be scrubbed.
Anything imported or declared after will be still be available.
.PP
.Vb 1
\& package Record;
\&
\& use Digest::MD5 qw(md5_hex);
\&
\& use Moo;
\& use namespace::clean;
\&
\& has name => (is => \*(Aqro\*(Aq, required => 1);
\& has id => (is => \*(Aqlazy\*(Aq);
\& sub _build_id {
\&   my ($self) = @_;
\&   return md5_hex($self\->name);
\& }
\&
\& 1;
.Ve
.PP
If you were to import \f(CW\*(C`md5_hex\*(C'\fR after namespace::clean you would
be able to call \f(CW\*(C`\->md5_hex()\*(C'\fR on your \f(CW\*(C`Record\*(C'\fR instances (and it
probably wouldn't do what you expect!).
.PP
Moo::Roles behave slightly differently.  Since their methods are
composed into the consuming class, they can do a little more for you
automatically.  As long as you declare your imports before calling
\&\f(CW\*(C`use Moo::Role\*(C'\fR, those imports and the ones Moo::Role itself
provides will not be composed into consuming classes, so there's usually
no need to use namespace::clean.
.PP
\&\fBOn namespace::autoclean:\fR If you're coming to Moo from the Moose
world, you may be accustomed to using namespace::autoclean in all
your packages. This is not recommended for Moo packages, because
namespace::autoclean will inflate your class to a full Moose
class.  It'll work, but you will lose the benefits of Moo.  Instead
you are recommended to just use namespace::clean.
.SH "INCOMPATIBILITIES WITH MOOSE"
.IX Header "INCOMPATIBILITIES WITH MOOSE"
There is no built-in type system.  \f(CW\*(C`isa\*(C'\fR is verified with a coderef; if you
need complex types, just make a library of coderefs, or better yet, functions
that return quoted subs. MooX::Types::MooseLike provides a similar \s-1API\s0
to MooseX::Types::Moose so that you can write
.PP
.Vb 1
\&  has days_to_live => (is => \*(Aqro\*(Aq, isa => Int);
.Ve
.PP
and have it work with both; it is hoped that providing only subrefs as an
\&\s-1API\s0 will encourage the use of other type systems as well, since it's
probably the weakest part of Moose design-wise.
.PP
\&\f(CW\*(C`initializer\*(C'\fR is not supported in core since the author considers it to be a
bad idea and Moose best practices recommend avoiding it. Meanwhile \f(CW\*(C`trigger\*(C'\fR or
\&\f(CW\*(C`coerce\*(C'\fR are more likely to be able to fulfill your needs.
.PP
There is no meta object.  If you need this level of complexity you wanted
Moose \- Moo succeeds at being small because it explicitly does not
provide a metaprotocol. However, if you load Moose, then
.PP
.Vb 1
\&  Class::MOP::class_of($moo_class_or_role)
.Ve
.PP
will return an appropriate metaclass pre-populated by Moo.
.PP
No support for \f(CW\*(C`super\*(C'\fR, \f(CW\*(C`override\*(C'\fR, \f(CW\*(C`inner\*(C'\fR, or \f(CW\*(C`augment\*(C'\fR \- the author
considers augment to be a bad idea, and override can be translated:
.PP
.Vb 5
\&  override foo => sub {
\&    ...
\&    super();
\&    ...
\&  };
\&
\&  around foo => sub {
\&    my ($orig, $self) = (shift, shift);
\&    ...
\&    $self\->$orig(@_);
\&    ...
\&  };
.Ve
.PP
The \f(CW\*(C`dump\*(C'\fR method is not provided by default. The author suggests loading
Devel::Dwarn into \f(CW\*(C`main::\*(C'\fR (via \f(CW\*(C`perl \-MDevel::Dwarn ...\*(C'\fR for example) and
using \f(CW\*(C`$obj\->$::Dwarn()\*(C'\fR instead.
.PP
\&\*(L"default\*(R" only supports coderefs and plain scalars, because passing a hash
or array reference as a default is almost always incorrect since the value is
then shared between all objects using that default.
.PP
\&\f(CW\*(C`lazy_build\*(C'\fR is not supported; you are instead encouraged to use the
\&\f(CW\*(C`is => \*(Aqlazy\*(Aq\*(C'\fR option supported by Moo and MooseX::AttributeShortcuts.
.PP
\&\f(CW\*(C`auto_deref\*(C'\fR is not supported since the author considers it a bad idea and
it has been considered best practice to avoid it for some time.
.PP
\&\f(CW\*(C`documentation\*(C'\fR will show up in a Moose metaclass created from your class
but is otherwise ignored. Then again, Moose ignores it as well, so this
is arguably not an incompatibility.
.PP
Since \f(CW\*(C`coerce\*(C'\fR does not require \f(CW\*(C`isa\*(C'\fR to be defined but Moose does
require it, the metaclass inflation for coerce alone is a trifle insane
and if you attempt to subtype the result will almost certainly break.
.PP
\&\f(CW\*(C`BUILDARGS\*(C'\fR is not triggered if your class does not have any attributes.
Without attributes, \f(CW\*(C`BUILDARGS\*(C'\fR return value would be ignored, so we just
skip calling the method instead.
.PP
Handling of warnings: when you \f(CW\*(C`use Moo\*(C'\fR we enable \s-1FATAL\s0 warnings, and some
several extra pragmas when used in development: indirect,
multidimensional, and bareword::filehandles.  See the strictures
documentation for the details on this.
.PP
A similar invocation for Moose would be:
.PP
.Vb 2
\&  use Moose;
\&  use warnings FATAL => "all";
.Ve
.PP
Additionally, Moo supports a set of attribute option shortcuts intended to
reduce common boilerplate.  The set of shortcuts is the same as in the Moose
module MooseX::AttributeShortcuts as of its version 0.009+.  So if you:
.PP
.Vb 2
\&    package MyClass;
\&    use Moo;
.Ve
.PP
The nearest Moose invocation would be:
.PP
.Vb 1
\&    package MyClass;
\&
\&    use Moose;
\&    use warnings FATAL => "all";
\&    use MooseX::AttributeShortcuts;
.Ve
.PP
or, if you're inheriting from a non-Moose class,
.PP
.Vb 1
\&    package MyClass;
\&
\&    use Moose;
\&    use MooseX::NonMoose;
\&    use warnings FATAL => "all";
\&    use MooseX::AttributeShortcuts;
.Ve
.PP
Finally, Moose requires you to call
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
at the end of your class to get an inlined (i.e. not horribly slow)
constructor. Moo does it automatically the first time \->new is called
on your class. (\f(CW\*(C`make_immutable\*(C'\fR is a no-op in Moo to ease migration.)
.PP
An extension MooX::late exists to ease translating Moose packages
to Moo by providing a more Moose-like interface.
.SH "SUPPORT"
.IX Header "SUPPORT"
Users' \s-1IRC:\s0 #moose on irc.perl.org
.PP
Development and contribution \s-1IRC:\s0 #web\-simple on irc.perl.org
.PP
Bugtracker: <https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
.PP
Git repository: <git://github.com/moose/Moo.git>
.PP
Git browser: <https://github.com/moose/Moo>
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
dg \- David Leadbeater (cpan:DGL) <dgl@dgl.cx>
.PP
frew \- Arthur Axel \*(L"fREW\*(R" Schmidt (cpan:FREW) <frioux@gmail.com>
.PP
hobbs \- Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
.PP
jnap \- John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
.PP
ribasushi \- Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
.PP
chip \- Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
.PP
ajgb \- Alex J. G. BurzyXski (cpan:AJGB) <ajgb@cpan.org>
.PP
doy \- Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
.PP
perigrin \- Chris Prather (cpan:PERIGRIN) <chris@prather.org>
.PP
Mithaldu \- Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
.PP
ilmari \- Dagfinn Ilmari Mannsa\*oker (cpan:ILMARI) <ilmari@ilmari.org>
.PP
tobyink \- Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
.PP
haarg \- Graham Knop (cpan:HAARG) <haarg@cpan.org>
.PP
mattp \- Matt Phillips (cpan:MATTP) <mattp@cpan.org>
.PP
bluefeet \- Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2011 the Moo \*(L"\s-1AUTHOR\*(R"\s0 and \*(L"\s-1CONTRIBUTORS\*(R"\s0
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself. See <http://dev.perl.org/licenses/>.
                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moo::Role.3pm                                0100644 0001750 0001750 00000014271 12566242373 023050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moo::Role 3"
.TH Moo::Role 3 "2013-12-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moo::Role \- Minimal Object Orientation support for Roles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package My::Role;
\&
\& use Moo::Role;
\&
\& sub foo { ... }
\&
\& sub bar { ... }
\&
\& has baz => (
\&   is => \*(Aqro\*(Aq,
\& );
\&
\& 1;
.Ve
.PP
And elsewhere:
.PP
.Vb 1
\& package Some::Class;
\&
\& use Moo;
\&
\& # bar gets imported, but not foo
\& with(\*(AqMy::Role\*(Aq);
\&
\& sub foo { ... }
\&
\& 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Moo::Role\*(C'\fR builds upon Role::Tiny, so look there for most of the
documentation on how this works.  The main addition here is extra bits to make
the roles more \*(L"Moosey;\*(R" which is to say, it adds \*(L"has\*(R".
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
See \*(L"\s-1IMPORTED SUBROUTINES\*(R"\s0 in Role::Tiny for all the other subroutines that are
imported by this module.
.SS "has"
.IX Subsection "has"
.Vb 3
\& has attr => (
\&   is => \*(Aqro\*(Aq,
\& );
.Ve
.PP
Declares an attribute for the class to be composed into.  See
\&\*(L"has\*(R" in Moo for all options.
.SH "CLEANING UP IMPORTS"
.IX Header "CLEANING UP IMPORTS"
Moo::Role cleans up its own imported methods and any imports
declared before the \f(CW\*(C`use Moo::Role\*(C'\fR statement automatically.
Anything imported after \f(CW\*(C`use Moo::Role\*(C'\fR will be composed into
consuming packages.  A package that consumes this role:
.PP
.Vb 1
\& package My::Role::ID;
\&
\& use Digest::MD5 qw(md5_hex);
\& use Moo::Role;
\& use Digest::SHA qw(sha1_hex);
\&
\& requires \*(Aqname\*(Aq;
\&
\& sub as_md5  { my ($self) = @_; return md5_hex($self\->name);  }
\& sub as_sha1 { my ($self) = @_; return sha1_hex($self\->name); }
\&
\& 1;
.Ve
.PP
\&..will now have a \f(CW\*(C`$self\->sha1_hex()\*(C'\fR method available to it
that probably does not do what you expect.  On the other hand, a call
to \f(CW\*(C`$self\->md5_hex()\*(C'\fR will die with the helpful error message:
\&\f(CW\*(C`Can\*(Aqt locate object method "md5_hex"\*(C'\fR.
.PP
See \*(L"\s-1CLEANING UP IMPORTS\*(R"\s0 in Moo for more details.
.SH "SUPPORT"
.IX Header "SUPPORT"
See Moo for support and contact information.
.SH "AUTHORS"
.IX Header "AUTHORS"
See Moo for authors.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
See Moo for the copyright and license.
                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moo::Role5.16.3pm                            0100644 0001750 0001750 00000011670 12566242356 023363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moo::Role 3"
.TH Moo::Role 3 "2012-10-08" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moo::Role \- Minimal Object Orientation support for Roles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package My::Role;
\&
\& use Moo::Role;
\&
\& sub foo { ... }
\&
\& sub bar { ... }
\&
\& has baz => (
\&   is => \*(Aqro\*(Aq,
\& );
\&
\& 1;
.Ve
.PP
And elsewhere:
.PP
.Vb 1
\& package Some::Class;
\&
\& use Moo;
\&
\& # bar gets imported, but not foo
\& with(\*(AqMy::Role\*(Aq);
\&
\& sub foo { ... }
\&
\& 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Moo::Role\*(C'\fR builds upon Role::Tiny, so look there for most of the
documentation on how this works.  The main addition here is extra bits to make
the roles more \*(L"Moosey;\*(R" which is to say, it adds \*(L"has\*(R".
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
See \*(L"\s-1IMPORTED\s0 \s-1SUBROUTINES\s0\*(R" in Role::Tiny for all the other subroutines that are
imported by this module.
.SS "has"
.IX Subsection "has"
.Vb 3
\& has attr => (
\&   is => \*(Aqro\*(Aq,
\& );
.Ve
.PP
Declares an attribute for the class to be composed into.  See
\&\*(L"has\*(R" in Moo for all options.
.SH "AUTHORS"
.IX Header "AUTHORS"
See Moo for authors.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
See Moo for the copyright and license.
                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moo::Role5.18.3pm                            0100644 0001750 0001750 00000014271 12566242373 023364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moo::Role 3"
.TH Moo::Role 3 "2013-12-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moo::Role \- Minimal Object Orientation support for Roles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package My::Role;
\&
\& use Moo::Role;
\&
\& sub foo { ... }
\&
\& sub bar { ... }
\&
\& has baz => (
\&   is => \*(Aqro\*(Aq,
\& );
\&
\& 1;
.Ve
.PP
And elsewhere:
.PP
.Vb 1
\& package Some::Class;
\&
\& use Moo;
\&
\& # bar gets imported, but not foo
\& with(\*(AqMy::Role\*(Aq);
\&
\& sub foo { ... }
\&
\& 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Moo::Role\*(C'\fR builds upon Role::Tiny, so look there for most of the
documentation on how this works.  The main addition here is extra bits to make
the roles more \*(L"Moosey;\*(R" which is to say, it adds \*(L"has\*(R".
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
See \*(L"\s-1IMPORTED SUBROUTINES\*(R"\s0 in Role::Tiny for all the other subroutines that are
imported by this module.
.SS "has"
.IX Subsection "has"
.Vb 3
\& has attr => (
\&   is => \*(Aqro\*(Aq,
\& );
.Ve
.PP
Declares an attribute for the class to be composed into.  See
\&\*(L"has\*(R" in Moo for all options.
.SH "CLEANING UP IMPORTS"
.IX Header "CLEANING UP IMPORTS"
Moo::Role cleans up its own imported methods and any imports
declared before the \f(CW\*(C`use Moo::Role\*(C'\fR statement automatically.
Anything imported after \f(CW\*(C`use Moo::Role\*(C'\fR will be composed into
consuming packages.  A package that consumes this role:
.PP
.Vb 1
\& package My::Role::ID;
\&
\& use Digest::MD5 qw(md5_hex);
\& use Moo::Role;
\& use Digest::SHA qw(sha1_hex);
\&
\& requires \*(Aqname\*(Aq;
\&
\& sub as_md5  { my ($self) = @_; return md5_hex($self\->name);  }
\& sub as_sha1 { my ($self) = @_; return sha1_hex($self\->name); }
\&
\& 1;
.Ve
.PP
\&..will now have a \f(CW\*(C`$self\->sha1_hex()\*(C'\fR method available to it
that probably does not do what you expect.  On the other hand, a call
to \f(CW\*(C`$self\->md5_hex()\*(C'\fR will die with the helpful error message:
\&\f(CW\*(C`Can\*(Aqt locate object method "md5_hex"\*(C'\fR.
.PP
See \*(L"\s-1CLEANING UP IMPORTS\*(R"\s0 in Moo for more details.
.SH "SUPPORT"
.IX Header "SUPPORT"
See Moo for support and contact information.
.SH "AUTHORS"
.IX Header "AUTHORS"
See Moo for authors.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
See Moo for the copyright and license.
                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose.3pm                                    0100644 0001750 0001750 00000117526 12566242161 022374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose 3"
.TH Moose 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose \- A postmodern object system for Perl 5
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose; # automatically turns on strict and warnings
\&
\&  has \*(Aqx\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&  has \*(Aqy\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose is an extension of the Perl 5 object system.
.PP
The main goal of Moose is to make Perl 5 Object Oriented programming
easier, more consistent, and less tedious. With Moose you can think
more about what you want to do and less about the mechanics of \s-1OOP.\s0
.PP
Additionally, Moose is built on top of Class::MOP, which is a
metaclass system for Perl 5. This means that Moose not only makes
building normal Perl 5 objects better, but it provides the power of
metaclass programming as well.
.SS "New to Moose?"
.IX Subsection "New to Moose?"
If you're new to Moose, the best place to start is the
Moose::Manual docs, followed by the Moose::Cookbook. The intro
will show you what Moose is, and how it makes Perl 5 \s-1OO\s0 better.
.PP
The cookbook recipes on Moose basics will get you up to speed with
many of Moose's features quickly. Once you have an idea of what Moose
can do, you can use the \s-1API\s0 documentation to get more detail on
features which interest you.
.SS "Moose Extensions"
.IX Subsection "Moose Extensions"
The \f(CW\*(C`MooseX::\*(C'\fR namespace is the official place to find Moose extensions.
These extensions can be found on the \s-1CPAN. \s0 The easiest way to find them
is to search for them (<https://metacpan.org/search?q=MooseX::>),
or to examine Task::Moose which aims to keep an up-to-date, easily
installable list of Moose extensions.
.SH "TRANSLATIONS"
.IX Header "TRANSLATIONS"
Much of the Moose documentation has been translated into other languages.
.IP "Japanese" 4
.IX Item "Japanese"
Japanese docs can be found at
<http://perldoc.perlassociation.org/pod/Moose\-Doc\-JA/index.html>. The
source \s-1POD\s0 files can be found in GitHub:
<http://github.com/jpa/Moose\-Doc\-JA>
.SH "BUILDING CLASSES WITH MOOSE"
.IX Header "BUILDING CLASSES WITH MOOSE"
Moose makes every attempt to provide as much convenience as possible during
class construction/definition, but still stay out of your way if you want it
to. Here are a few items to note when building classes with Moose.
.PP
When you \f(CW\*(C`use Moose\*(C'\fR, Moose will set the class's parent class to
Moose::Object, \fIunless\fR the class using Moose already has a parent
class. In addition, specifying a parent with \f(CW\*(C`extends\*(C'\fR will change the parent
class.
.PP
Moose will also manage all attributes (including inherited ones) that are
defined with \f(CW\*(C`has\*(C'\fR. And (assuming you call \f(CW\*(C`new\*(C'\fR, which is inherited from
Moose::Object) this includes properly initializing all instance slots,
setting defaults where appropriate, and performing any type constraint checking
or coercion.
.SH "PROVIDED METHODS"
.IX Header "PROVIDED METHODS"
Moose provides a number of methods to all your classes, mostly through the
inheritance of Moose::Object. There is however, one exception.
.IP "\fBmeta\fR" 4
.IX Item "meta"
This is a method which provides access to the current class's metaclass.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Moose will export a number of functions into the class's namespace which
may then be used to set up the class. These functions all work directly
on the current class.
.IP "\fBextends (@superclasses)\fR" 4
.IX Item "extends (@superclasses)"
This function will set the superclass(es) for the current class. If the parent
classes are not yet loaded, then \f(CW\*(C`extends\*(C'\fR tries to load them.
.Sp
This approach is recommended instead of \f(CW\*(C`use base\*(C'\fR/\f(CW\*(C`use parent\*(C'\fR, because
\&\f(CW\*(C`use base\*(C'\fR actually \f(CW\*(C`push\*(C'\fRes onto the class's \f(CW@ISA\fR, whereas \f(CW\*(C`extends\*(C'\fR will
replace it. This is important to ensure that classes which do not have
superclasses still properly inherit from Moose::Object.
.Sp
Each superclass can be followed by a hash reference with options. Currently,
only \-version is recognized:
.Sp
.Vb 2
\&    extends \*(AqMy::Parent\*(Aq      => { \-version => 0.01 },
\&            \*(AqMy::OtherParent\*(Aq => { \-version => 0.03 };
.Ve
.Sp
An exception will be thrown if the version requirements are not
satisfied.
.IP "\fBwith (@roles)\fR" 4
.IX Item "with (@roles)"
This will apply a given set of \f(CW@roles\fR to the local class.
.Sp
Like with \f(CW\*(C`extends\*(C'\fR, each specified role can be followed by a hash
reference with a \-version option:
.Sp
.Vb 2
\&    with \*(AqMy::Role\*(Aq      => { \-version => 0.32 },
\&         \*(AqMy::Otherrole\*(Aq => { \-version => 0.23 };
.Ve
.Sp
The specified version requirements must be satisfied, otherwise an
exception will be thrown.
.Sp
If your role takes options or arguments, they can be passed along in the
hash reference as well.
.ie n .IP "\fBhas \fB$name\fB|@$names => \f(BI%options\fB\fR" 4
.el .IP "\fBhas \f(CB$name\fB|@$names => \f(CB%options\fB\fR" 4
.IX Item "has $name|@$names => %options"
This will install an attribute of a given \f(CW$name\fR into the current class. If
the first parameter is an array reference, it will create an attribute for
every \f(CW$name\fR in the list. The \f(CW%options\fR will be passed to the constructor
for Moose::Meta::Attribute (which inherits from Class::MOP::Attribute),
so the full documentation for the valid options can be found there. These are
the most commonly used options:
.RS 4
.IP "\fIis => 'rw'|'ro'\fR" 4
.IX Item "is => 'rw'|'ro'"
The \fIis\fR option accepts either \fIrw\fR (for read/write) or \fIro\fR (for read
only). These will create either a read/write accessor or a read-only
accessor respectively, using the same name as the \f(CW$name\fR of the attribute.
.Sp
If you need more control over how your accessors are named, you can
use the reader,
writer and
accessor options inherited from
Class::MOP::Attribute, however if you use those, you won't need the
\&\fIis\fR option.
.ie n .IP "\fIisa => \fI$type_name\fI\fR" 4
.el .IP "\fIisa => \f(CI$type_name\fI\fR" 4
.IX Item "isa => $type_name"
The \fIisa\fR option uses Moose's type constraint facilities to set up runtime
type checking for this attribute. Moose will perform the checks during class
construction, and within any accessors. The \f(CW$type_name\fR argument must be a
string. The string may be either a class name or a type defined using
Moose's type definition features. (Refer to Moose::Util::TypeConstraints
for information on how to define a new type, and how to retrieve type meta-data).
.IP "\fIcoerce => (1|0)\fR" 4
.IX Item "coerce => (1|0)"
This will attempt to use coercion with the supplied type constraint to change
the value passed into any accessors or constructors. You \fBmust\fR supply a type
constraint, and that type constraint \fBmust\fR define a coercion. See
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion for an example.
.ie n .IP "\fIdoes => \fI$role_name\fI\fR" 4
.el .IP "\fIdoes => \f(CI$role_name\fI\fR" 4
.IX Item "does => $role_name"
This will accept the name of a role which the value stored in this attribute
is expected to have consumed.
.IP "\fIrequired => (1|0)\fR" 4
.IX Item "required => (1|0)"
This marks the attribute as being required. This means a value must be
supplied during class construction, \fIor\fR the attribute must be lazy
and have either a default or a builder. Note that c<required> does not
say anything about the attribute's value, which can be \f(CW\*(C`undef\*(C'\fR.
.IP "\fIweak_ref => (1|0)\fR" 4
.IX Item "weak_ref => (1|0)"
This will tell the class to store the value of this attribute as a weakened
reference. If an attribute is a weakened reference, it \fBcannot\fR also be
coerced. Note that when a weak ref expires, the attribute's value becomes
undefined, and is still considered to be set for purposes of predicate,
default, etc.
.IP "\fIlazy => (1|0)\fR" 4
.IX Item "lazy => (1|0)"
This will tell the class to not create this slot until absolutely necessary.
If an attribute is marked as lazy it \fBmust\fR have a default or builder
supplied.
.ie n .IP "\fItrigger => \fI$code\fI\fR" 4
.el .IP "\fItrigger => \f(CI$code\fI\fR" 4
.IX Item "trigger => $code"
The \fItrigger\fR option is a \s-1CODE\s0 reference which will be called after
the value of the attribute is set. The \s-1CODE\s0 ref is passed the
instance itself, the updated value, and the original value if the
attribute was already set.
.Sp
You \fBcan\fR have a trigger on a read-only attribute.
.Sp
\&\fB\s-1NOTE:\s0\fR Triggers will only fire when you \fBassign\fR to the attribute,
either in the constructor, or using the writer. Default and built values will
\&\fBnot\fR cause the trigger to be fired.
.IP "\fIhandles => \s-1ARRAY\s0 | \s-1HASH\s0 | \s-1REGEXP\s0 | \s-1ROLE\s0 | \s-1ROLETYPE\s0 | \s-1DUCKTYPE\s0 | \s-1CODE\s0\fR" 4
.IX Item "handles => ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE"
The \fIhandles\fR option provides Moose classes with automated delegation features.
This is a pretty complex and powerful option. It accepts many different option
formats, each with its own benefits and drawbacks.
.Sp
\&\fB\s-1NOTE:\s0\fR The class being delegated to does not need to be a Moose based class,
which is why this feature is especially useful when wrapping non-Moose classes.
.Sp
All \fIhandles\fR option formats share the following traits:
.Sp
You cannot override a locally defined method with a delegated method; an
exception will be thrown if you try. That is to say, if you define \f(CW\*(C`foo\*(C'\fR in
your class, you cannot override it with a delegated \f(CW\*(C`foo\*(C'\fR. This is almost never
something you would want to do, and if it is, you should do it by hand and not
use Moose.
.Sp
You cannot override any of the methods found in Moose::Object, or the \f(CW\*(C`BUILD\*(C'\fR
and \f(CW\*(C`DEMOLISH\*(C'\fR methods. These will not throw an exception, but will silently
move on to the next method in the list. My reasoning for this is that you would
almost never want to do this, since it usually breaks your class. As with
overriding locally defined methods, if you do want to do this, you should do it
manually, not with Moose.
.Sp
You do not \fIneed\fR to have a reader (or accessor) for the attribute in order
to delegate to it. Moose will create a means of accessing the value for you,
however this will be several times \fBless\fR efficient then if you had given
the attribute a reader (or accessor) to use.
.Sp
Below is the documentation for each option format:
.RS 4
.ie n .IP """ARRAY""" 4
.el .IP "\f(CWARRAY\fR" 4
.IX Item "ARRAY"
This is the most common usage for \fIhandles\fR. You basically pass a list of
method names to be delegated, and Moose will install a delegation method
for each one.
.ie n .IP """HASH""" 4
.el .IP "\f(CWHASH\fR" 4
.IX Item "HASH"
This is the second most common usage for \fIhandles\fR. Instead of a list of
method names, you pass a \s-1HASH\s0 ref where each key is the method name you
want installed locally, and its value is the name of the original method
in the class being delegated to.
.Sp
This can be very useful for recursive classes like trees. Here is a
quick example (soon to be expanded into a Moose::Cookbook recipe):
.Sp
.Vb 2
\&  package Tree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqchildren\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqArrayRef\*(Aq,
\&      default => sub { [] }
\&  );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is          => \*(Aqrw\*(Aq,
\&      isa         => \*(AqTree\*(Aq,
\&      weak_ref    => 1,
\&      handles     => {
\&          parent_node => \*(Aqnode\*(Aq,
\&          siblings    => \*(Aqchildren\*(Aq,
\&      }
\&  );
.Ve
.Sp
In this example, the Tree package gets \f(CW\*(C`parent_node\*(C'\fR and \f(CW\*(C`siblings\*(C'\fR methods,
which delegate to the \f(CW\*(C`node\*(C'\fR and \f(CW\*(C`children\*(C'\fR methods (respectively) of the Tree
instance stored in the \f(CW\*(C`parent\*(C'\fR slot.
.Sp
You may also use an array reference to curry arguments to the original method.
.Sp
.Vb 4
\&  has \*(Aqthing\*(Aq => (
\&      ...
\&      handles => { set_foo => [ set => \*(Aqfoo\*(Aq ] },
\&  );
\&
\&  # $self\->set_foo(...) calls $self\->thing\->set(\*(Aqfoo\*(Aq, ...)
.Ve
.Sp
The first element of the array reference is the original method name, and the
rest is a list of curried arguments.
.ie n .IP """REGEXP""" 4
.el .IP "\f(CWREGEXP\fR" 4
.IX Item "REGEXP"
The regexp option works very similar to the \s-1ARRAY\s0 option, except that it builds
the list of methods for you. It starts by collecting all possible methods of the
class being delegated to, then filters that list using the regexp supplied here.
.Sp
\&\fB\s-1NOTE:\s0\fR An \fIisa\fR option is required when using the regexp option format. This
is so that we can determine (at compile time) the method list from the class.
Without an \fIisa\fR this is just not possible.
.ie n .IP """ROLE"" or ""ROLETYPE""" 4
.el .IP "\f(CWROLE\fR or \f(CWROLETYPE\fR" 4
.IX Item "ROLE or ROLETYPE"
With the role option, you specify the name of a role or a
role type whose \*(L"interface\*(R" then becomes
the list of methods to handle. The \*(L"interface\*(R" can be defined as; the methods
of the role and any required methods of the role. It should be noted that this
does \fBnot\fR include any method modifiers or generated attribute methods (which
is consistent with role composition).
.ie n .IP """DUCKTYPE""" 4
.el .IP "\f(CWDUCKTYPE\fR" 4
.IX Item "DUCKTYPE"
With the duck type option, you pass a duck type object whose \*(L"interface\*(R" then
becomes the list of methods to handle. The \*(L"interface\*(R" can be defined as the
list of methods passed to \f(CW\*(C`duck_type\*(C'\fR to create a duck type object. For more
information on \f(CW\*(C`duck_type\*(C'\fR please check
Moose::Util::TypeConstraints.
.ie n .IP """CODE""" 4
.el .IP "\f(CWCODE\fR" 4
.IX Item "CODE"
This is the option to use when you really want to do something funky. You should
only use it if you really know what you are doing, as it involves manual
metaclass twiddling.
.Sp
This takes a code reference, which should expect two arguments. The first is the
attribute meta-object this \fIhandles\fR is attached to. The second is the
metaclass of the class being delegated to. It expects you to return a hash (not
a \s-1HASH\s0 ref) of the methods you want mapped.
.RE
.RS 4
.RE
.ie n .IP "\fItraits => [ \fI@role_names\fI ]\fR" 4
.el .IP "\fItraits => [ \f(CI@role_names\fI ]\fR" 4
.IX Item "traits => [ @role_names ]"
This tells Moose to take the list of \f(CW@role_names\fR and apply them to the
attribute meta-object. Custom attribute metaclass traits are useful for
extending the capabilities of the \fIhas\fR keyword: they are the simplest way to
extend the \s-1MOP,\s0 but they are still a fairly advanced topic and too much to
cover here.
.Sp
See \*(L"Metaclass and Trait Name Resolution\*(R" for details on how a trait name is
resolved to a role name.
.Sp
Also see Moose::Cookbook::Meta::Labeled_AttributeTrait for a metaclass
trait example.
.IP "\fIbuilder\fR => Str" 4
.IX Item "builder => Str"
The value of this key is the name of the method that will be called to obtain
the value used to initialize the attribute. See the builder option docs in
Class::MOP::Attribute and/or
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for more
information.
.IP "\fIdefault\fR => \s-1SCALAR\s0 | \s-1CODE\s0" 4
.IX Item "default => SCALAR | CODE"
The value of this key is the default value which will initialize the attribute.
.Sp
\&\s-1NOTE:\s0 If the value is a simple scalar (string or number), then it can
be just passed as is.  However, if you wish to initialize it with a
\&\s-1HASH\s0 or \s-1ARRAY\s0 ref, then you need to wrap that inside a \s-1CODE\s0 reference.
See the default option docs in
Class::MOP::Attribute for more
information.
.IP "\fIclearer\fR => Str" 4
.IX Item "clearer => Str"
Creates a method allowing you to clear the value. See the clearer option
docs in Class::MOP::Attribute for more
information.
.IP "\fIpredicate\fR => Str" 4
.IX Item "predicate => Str"
Creates a method to perform a basic test to see if a value has been set in the
attribute. See the predicate option docs in
Class::MOP::Attribute for more information.
.Sp
Note that the predicate will return true even for a \f(CW\*(C`weak_ref\*(C'\fR attribute
whose value has expired.
.ie n .IP "\fIdocumentation\fR => $string" 4
.el .IP "\fIdocumentation\fR => \f(CW$string\fR" 4
.IX Item "documentation => $string"
An arbitrary string that can be retrieved later by calling \f(CW\*(C`$attr\->documentation\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP "\fBhas +$name => \fB%options\fB\fR" 4
.el .IP "\fBhas +$name => \f(CB%options\fB\fR" 4
.IX Item "has +$name => %options"
This is variation on the normal attribute creator \f(CW\*(C`has\*(C'\fR which allows you to
clone and extend an attribute from a superclass or from a role. Here is an
example of the superclass usage:
.Sp
.Vb 2
\&  package Foo;
\&  use Moose;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  extends \*(AqFoo\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
What is happening here is that \fBMy::Foo\fR is cloning the \f(CW\*(C`message\*(C'\fR attribute
from its parent class \fBFoo\fR, retaining the \f(CW\*(C`is => \*(Aqrw\*(Aq\*(C'\fR and \f(CW\*(C`isa =>
\&\*(AqStr\*(Aq\*(C'\fR characteristics, but changing the value in \f(CW\*(C`default\*(C'\fR.
.Sp
Here is another example, but within the context of a role:
.Sp
.Vb 2
\&  package Foo::Role;
\&  use Moose::Role;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  with \*(AqFoo::Role\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
In this case, we are basically taking the attribute which the role supplied
and altering it within the bounds of this feature.
.Sp
Note that you can only extend an attribute from either a superclass or a role,
you cannot extend an attribute in a role that composes over an attribute from
another role.
.Sp
Aside from where the attributes come from (one from superclass, the other
from a role), this feature works exactly the same. This feature is restricted
somewhat, so as to try and force at least \fIsome\fR sanity into it. Most options work the same, but there are some exceptions:
.RS 4
.IP "\fIreader\fR" 4
.IX Item "reader"
.PD 0
.IP "\fIwriter\fR" 4
.IX Item "writer"
.IP "\fIaccessor\fR" 4
.IX Item "accessor"
.IP "\fIclearer\fR" 4
.IX Item "clearer"
.IP "\fIpredicate\fR" 4
.IX Item "predicate"
.PD
These options can be added, but cannot override a superclass definition.
.IP "\fItraits\fR" 4
.IX Item "traits"
You are allowed to \fBadd\fR additional traits to the \f(CW\*(C`traits\*(C'\fR definition.
These traits will be composed into the attribute, but preexisting traits
\&\fBare not\fR overridden, or removed.
.RE
.RS 4
.RE
.ie n .IP "\fBbefore \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBbefore \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "before $name|@names|@names|qr/.../ => sub { ... }"
.PD 0
.ie n .IP "\fBafter \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBafter \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "after $name|@names|@names|qr/.../ => sub { ... }"
.ie n .IP "\fBaround \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBaround \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "around $name|@names|@names|qr/.../ => sub { ... }"
.PD
These three items are syntactic sugar for the before, after, and around method
modifier features that Class::MOP provides. More information on these may be
found in Moose::Manual::MethodModifiers and the
Class::MOP::Class documentation.
.IP "\fBoverride ($name, &sub)\fR" 4
.IX Item "override ($name, &sub)"
An \f(CW\*(C`override\*(C'\fR method is a way of explicitly saying \*(L"I am overriding this
method from my superclass\*(R". You can call \f(CW\*(C`super\*(C'\fR within this method, and
it will work as expected. The same thing \fIcan\fR be accomplished with a normal
method call and the \f(CW\*(C`SUPER::\*(C'\fR pseudo-package; it is really your choice.
.IP "\fBsuper\fR" 4
.IX Item "super"
The keyword \f(CW\*(C`super\*(C'\fR is a no-op when called outside of an \f(CW\*(C`override\*(C'\fR method. In
the context of an \f(CW\*(C`override\*(C'\fR method, it will call the next most appropriate
superclass method with the same arguments as the original method.
.IP "\fBaugment ($name, &sub)\fR" 4
.IX Item "augment ($name, &sub)"
An \f(CW\*(C`augment\*(C'\fR method, is a way of explicitly saying \*(L"I am augmenting this
method from my superclass\*(R". Once again, the details of how \f(CW\*(C`inner\*(C'\fR and
\&\f(CW\*(C`augment\*(C'\fR work is best described in the
Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBinner\fR" 4
.IX Item "inner"
The keyword \f(CW\*(C`inner\*(C'\fR, much like \f(CW\*(C`super\*(C'\fR, is a no-op outside of the context of
an \f(CW\*(C`augment\*(C'\fR method. You can think of \f(CW\*(C`inner\*(C'\fR as being the inverse of
\&\f(CW\*(C`super\*(C'\fR; the details of how \f(CW\*(C`inner\*(C'\fR and \f(CW\*(C`augment\*(C'\fR work is best described in
the Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBblessed\fR" 4
.IX Item "blessed"
This is the \f(CW\*(C`Scalar::Util::blessed\*(C'\fR function. It is highly recommended that
this is used instead of \f(CW\*(C`ref\*(C'\fR anywhere you need to test for an object's class
name.
.IP "\fBconfess\fR" 4
.IX Item "confess"
This is the \f(CW\*(C`Carp::confess\*(C'\fR function, and exported here for historical
reasons.
.SH "METACLASS"
.IX Header "METACLASS"
When you use Moose, you can specify traits which will be applied to your
metaclass:
.PP
.Vb 1
\&    use Moose \-traits => \*(AqMy::Trait\*(Aq;
.Ve
.PP
This is very similar to the attribute traits feature. When you do
this, your class's \f(CW\*(C`meta\*(C'\fR object will have the specified traits
applied to it. See \*(L"Metaclass and Trait Name Resolution\*(R" for more
details.
.SS "Metaclass and Trait Name Resolution"
.IX Subsection "Metaclass and Trait Name Resolution"
By default, when given a trait name, Moose simply tries to load a
class of the same name. If such a class does not exist, it then looks
for a class matching
\&\fBMoose::Meta::$type::Custom::Trait::$trait_name\fR. The \f(CW$type\fR
variable here will be one of \fBAttribute\fR or \fBClass\fR, depending on
what the trait is being applied to.
.PP
If a class with this long name exists, Moose checks to see if it has
the method \f(CW\*(C`register_implementation\*(C'\fR. This method is expected to
return the \fIreal\fR class name of the trait. If there is no
\&\f(CW\*(C`register_implementation\*(C'\fR method, it will fall back to using
\&\fBMoose::Meta::$type::Custom::Trait::$trait\fR as the trait name.
.PP
The lookup method for metaclasses is the same, except that it looks
for a class matching \fBMoose::Meta::$type::Custom::$metaclass_name\fR.
.PP
If all this is confusing, take a look at
Moose::Cookbook::Meta::Labeled_AttributeTrait, which demonstrates how to
create an attribute trait.
.SH "UNIMPORTING FUNCTIONS"
.IX Header "UNIMPORTING FUNCTIONS"
.SS "\fBunimport\fP"
.IX Subsection "unimport"
Moose offers a way to remove the keywords it exports, through the \f(CW\*(C`unimport\*(C'\fR
method. You simply have to say \f(CW\*(C`no Moose\*(C'\fR at the bottom of your code for this
to work. Here is an example:
.PP
.Vb 2
\&    package Person;
\&    use Moose;
\&
\&    has \*(Aqfirst_name\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&    has \*(Aqlast_name\*(Aq  => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&
\&    sub full_name {
\&        my $self = shift;
\&        $self\->first_name . \*(Aq \*(Aq . $self\->last_name
\&    }
\&
\&    no Moose; # keywords are removed from the Person package
.Ve
.SH "EXTENDING AND EMBEDDING MOOSE"
.IX Header "EXTENDING AND EMBEDDING MOOSE"
To learn more about extending Moose, we recommend checking out the
\&\*(L"Extending\*(R" recipes in the Moose::Cookbook, starting with
Moose::Cookbook::Extending::ExtensionOverview, which provides an overview of
all the different ways you might extend Moose. Moose::Exporter and
Moose::Util::MetaRole are the modules which provide the majority of the
extension functionality, so reading their documentation should also be helpful.
.SS "The MooseX:: namespace"
.IX Subsection "The MooseX:: namespace"
Generally if you're writing an extension \fIfor\fR Moose itself you'll want
to put your extension in the \f(CW\*(C`MooseX::\*(C'\fR namespace. This namespace is
specifically for extensions that make Moose better or different in some
fundamental way. It is traditionally \fBnot\fR for a package that just happens
to use Moose. This namespace follows from the examples of the \f(CW\*(C`LWPx::\*(C'\fR
and \f(CW\*(C`DBIx::\*(C'\fR namespaces that perform the same function for \f(CW\*(C`LWP\*(C'\fR and \f(CW\*(C`DBI\*(C'\fR
respectively.
.SH "METACLASS COMPATIBILITY AND MOOSE"
.IX Header "METACLASS COMPATIBILITY AND MOOSE"
Metaclass compatibility is a thorny subject. You should start by
reading the \*(L"About Metaclass compatibility\*(R" section in the
\&\f(CW\*(C`Class::MOP\*(C'\fR docs.
.PP
Moose will attempt to resolve a few cases of metaclass incompatibility
when you set the superclasses for a class, in addition to the cases that
\&\f(CW\*(C`Class::MOP\*(C'\fR handles.
.PP
Moose tries to determine if the metaclasses only \*(L"differ by roles\*(R". This
means that the parent and child's metaclass share a common ancestor in
their respective hierarchies, and that the subclasses under the common
ancestor are only different because of role applications. This case is
actually fairly common when you mix and match various \f(CW\*(C`MooseX::*\*(C'\fR
modules, many of which apply roles to the metaclass.
.PP
If the parent and child do differ by roles, Moose replaces the
metaclass in the child with a newly created metaclass. This metaclass
is a subclass of the parent's metaclass which does all of the roles that
the child's metaclass did before being replaced. Effectively, this
means the new metaclass does all of the roles done by both the
parent's and child's original metaclasses.
.PP
Ultimately, this is all transparent to you except in the case of an
unresolvable conflict.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
It should be noted that \f(CW\*(C`super\*(C'\fR and \f(CW\*(C`inner\*(C'\fR \fBcannot\fR be used in the same
method. However, they may be combined within the same class hierarchy; see
\&\fIt/basics/override_augment_inner_super.t\fR for an example.
.Sp
The reason for this is that \f(CW\*(C`super\*(C'\fR is only valid within a method
with the \f(CW\*(C`override\*(C'\fR modifier, and \f(CW\*(C`inner\*(C'\fR will never be valid within an
\&\f(CW\*(C`override\*(C'\fR method. In fact, \f(CW\*(C`augment\*(C'\fR will skip over any \f(CW\*(C`override\*(C'\fR methods
when searching for its appropriate \f(CW\*(C`inner\*(C'\fR.
.Sp
This might seem like a restriction, but I am of the opinion that keeping these
two features separate (yet interoperable) actually makes them easy to use, since
their behavior is then easier to predict. Time will tell whether I am right or
not (\s-1UPDATE:\s0 so far so good).
.SH "GETTING HELP"
.IX Header "GETTING HELP"
We offer both a mailing list and a very active \s-1IRC\s0 channel.
.PP
The mailing list is <mailto:moose@perl.org>. You must be subscribed to send
a message. To subscribe, send an empty message to
<mailto:moose\-subscribe@perl.org>
.PP
You can also visit us at \f(CW\*(C`#moose\*(C'\fR on <irc://irc.perl.org/#moose>
This channel is quite active, and questions at all levels (on Moose-related
topics ;) are welcome.
.SH "WHAT DOES MOOSE STAND FOR?"
.IX Header "WHAT DOES MOOSE STAND FOR?"
Moose doesn't stand for one thing in particular, however, if you want, here
are a few of our favorites. Feel free to contribute more!
.IP "\(bu" 4
Make Other Object Systems Envious
.IP "\(bu" 4
Makes Object Orientation So Easy
.IP "\(bu" 4
Makes Object Orientation Spiffy\- Er (sorry ingy)
.IP "\(bu" 4
Most Other Object Systems Emasculate
.IP "\(bu" 4
Moose Often Ovulate Sorta Early
.IP "\(bu" 4
Moose Offers Often Super Extensions
.IP "\(bu" 4
Meta Object Obligates Salivary Excitation
.IP "\(bu" 4
Meta Object Orientation Syntax Extensions
.IP "\(bu" 4
Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "I blame Sam Vilain for introducing me to the insanity that is meta-models." 4
.IX Item "I blame Sam Vilain for introducing me to the insanity that is meta-models."
.PD 0
.IP "I blame Audrey Tang for then encouraging my meta-model habit in #perl6." 4
.IX Item "I blame Audrey Tang for then encouraging my meta-model habit in #perl6."
.ie n .IP "Without Yuval ""nothingmuch"" Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.el .IP "Without Yuval ``nothingmuch'' Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.IX Item "Without Yuval nothingmuch Kogman this module would not be possible, and it certainly wouldn't have this name ;P"
.IP "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it." 4
.IX Item "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it."
.IP "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature\-requests/encouragement/bug\-finding." 4
.IX Item "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature-requests/encouragement/bug-finding."
.ie n .IP "Thanks to David ""Theory"" Wheeler for meta-discussions and spelling fixes." 4
.el .IP "Thanks to David ``Theory'' Wheeler for meta-discussions and spelling fixes." 4
.IX Item "Thanks to David Theory Wheeler for meta-discussions and spelling fixes."
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://moose.perl.org/>" 4
.IX Item "<http://moose.perl.org/>"
This is the official web home of Moose. It contains links to our public git
repository, as well as links to a number of talks and articles on Moose and
Moose related technologies.
.IP "the Moose manual" 4
.IX Item "the Moose manual"
This is an introduction to Moose which covers most of the basics.
.IP "Modern Perl, by chromatic" 4
.IX Item "Modern Perl, by chromatic"
This is an introduction to modern Perl programming, which includes a section on
Moose. It is available in print and as a free download from
<http://onyxneon.com/books/modern_perl/>.
.IP "The Moose is flying, a tutorial by Randal Schwartz" 4
.IX Item "The Moose is flying, a tutorial by Randal Schwartz"
Part 1 \- <http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
.Sp
Part 2 \- <http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
.ie n .IP "Several Moose extension modules in the ""MooseX::"" namespace." 4
.el .IP "Several Moose extension modules in the \f(CWMooseX::\fR namespace." 4
.IX Item "Several Moose extension modules in the MooseX:: namespace."
See <https://metacpan.org/search?q=MooseX::> for extensions.
.SS "Books"
.IX Subsection "Books"
.IP "The Art of the MetaObject Protocol" 4
.IX Item "The Art of the MetaObject Protocol"
I mention this in the Class::MOP docs too, as this book was critical in
the development of both modules and is highly recommended.
.SS "Papers"
.IX Subsection "Papers"
.IP "<http://www.cs.utah.edu/plt/publications/oopsla04\-gff.pdf>" 4
.IX Item "<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>"
This paper (suggested by lbr on #moose) was what lead to the implementation
of the \f(CW\*(C`super\*(C'\fR/\f(CW\*(C`override\*(C'\fR and \f(CW\*(C`inner\*(C'\fR/\f(CW\*(C`augment\*(C'\fR features. If you really
want to understand them, I suggest you read this.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception.
.PP
Please report any bugs to \f(CW\*(C`bug\-moose@rt.cpan.org\*(C'\fR, or through the web
interface at <http://rt.cpan.org>. You can also submit a \f(CW\*(C`TODO\*(C'\fR test as a
pull request at <https://github.com/moose/Moose>.
.PP
You can also discuss feature requests or possible bugs on the Moose mailing
list (moose@perl.org) or on \s-1IRC\s0 at <irc://irc.perl.org/#moose>.
.SH "FEATURE REQUESTS"
.IX Header "FEATURE REQUESTS"
We are very strict about what features we add to the Moose core, especially
the user-visible features. Instead we have made sure that the underlying
meta-system of Moose is as extensible as possible so that you can add your
own features easily.
.PP
That said, occasionally there is a feature needed in the meta-system
to support your planned extension, in which case you should either
email the mailing list (moose@perl.org) or join us on \s-1IRC\s0 at
<irc://irc.perl.org/#moose> to discuss. The
Moose::Manual::Contributing has more detail about how and when you
can contribute.
.SH "CABAL"
.IX Header "CABAL"
There are only a few people with the rights to release a new version
of Moose. The Moose Cabal are the people to go to with questions regarding
the wider purview of Moose. They help maintain not just the code
but the community as well. See the list below under \f(CW\*(C`AUTHORS\*(C'\fR.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Moose is a community project, and as such, involves the work of many, many
members of the community beyond just the members in the cabal. In particular:
.PP
Dave (autarch) Rolsky wrote most of the documentation in Moose::Manual.
.PP
John (jgoulah) Goulah wrote Moose::Cookbook::Snack::Keywords.
.PP
Jess (castaway) Robinson wrote Moose::Cookbook::Snack::Types.
.PP
Aran (bluefeet) Clary Deltac wrote
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion.
.PP
Anders (Debolaz) Nor Berle contributed Test::Moose and Moose::Util.
.PP
Also, the code in Moose::Meta::Attribute::Native is based on code from the
MooseX::AttributeHelpers distribution, which had contributions from:
.PP
Chris (perigrin) Prather
.PP
Cory (gphat) Watson
.PP
Evan Carroll
.PP
Florian (rafl) Ragwitz
.PP
Jason May
.PP
Jay Hannah
.PP
Jesse (doy) Luehrs
.PP
Paul (frodwith) Driver
.PP
Robert (rlb3) Boone
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Shawn (Sartak) Moore
.PP
Stevan Little
.PP
Tom (dec) Lanyon
.PP
Yuval Kogman
.PP
Finally, these people also contributed various tests, bug fixes,
documentation, and features to the Moose codebase:
.PP
Aankhen
.PP
Adam (Alias) Kennedy
.PP
Christian (chansen) Hansen
.PP
Cory (gphat) Watson
.PP
Dylan Hardison (doc fixes)
.PP
Eric (ewilhelm) Wilhelm
.PP
Evan Carroll
.PP
Guillermo (groditi) Roditi
.PP
Jason May
.PP
Jay Hannah
.PP
Jonathan (jrockway) Rockway
.PP
Matt (mst) Trout
.PP
Nathan (kolibrie) Gray
.PP
Paul (frodwith) Driver
.PP
Piotr (dexter) Roszatycki
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Robert (rlb3) Boone
.PP
Sam (mugwump) Vilain
.PP
Scott (konobi) McWhirter
.PP
Shlomi (rindolf) Fish
.PP
Tom (dec) Lanyon
.PP
Wallace (wreis) Reis
.PP
\&... and many other #moose folks
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose5.16.3pm                                0100644 0001750 0001750 00000115727 12566242167 022715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose 3"
.TH Moose 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose \- A postmodern object system for Perl 5
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose; # automatically turns on strict and warnings
\&
\&  has \*(Aqx\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&  has \*(Aqy\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose is an extension of the Perl 5 object system.
.PP
The main goal of Moose is to make Perl 5 Object Oriented programming
easier, more consistent, and less tedious. With Moose you can think
more about what you want to do and less about the mechanics of \s-1OOP\s0.
.PP
Additionally, Moose is built on top of Class::MOP, which is a
metaclass system for Perl 5. This means that Moose not only makes
building normal Perl 5 objects better, but it provides the power of
metaclass programming as well.
.SS "New to Moose?"
.IX Subsection "New to Moose?"
If you're new to Moose, the best place to start is the
Moose::Manual docs, followed by the Moose::Cookbook. The intro
will show you what Moose is, and how it makes Perl 5 \s-1OO\s0 better.
.PP
The cookbook recipes on Moose basics will get you up to speed with
many of Moose's features quickly. Once you have an idea of what Moose
can do, you can use the \s-1API\s0 documentation to get more detail on
features which interest you.
.SS "Moose Extensions"
.IX Subsection "Moose Extensions"
The \f(CW\*(C`MooseX::\*(C'\fR namespace is the official place to find Moose extensions.
These extensions can be found on the \s-1CPAN\s0.  The easiest way to find them
is to search for them (<http://search.cpan.org/search?query=MooseX::>),
or to examine Task::Moose which aims to keep an up-to-date, easily
installable list of Moose extensions.
.SH "TRANSLATIONS"
.IX Header "TRANSLATIONS"
Much of the Moose documentation has been translated into other languages.
.IP "Japanese" 4
.IX Item "Japanese"
Japanese docs can be found at
http://perldoc.perlassociation.org/pod/Moose\-Doc\-JA/index.html <http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html>. The
source \s-1POD\s0 files can be found in GitHub:
http://github.com/jpa/Moose\-Doc\-JA <http://github.com/jpa/Moose-Doc-JA>
.SH "BUILDING CLASSES WITH MOOSE"
.IX Header "BUILDING CLASSES WITH MOOSE"
Moose makes every attempt to provide as much convenience as possible during
class construction/definition, but still stay out of your way if you want it
to. Here are a few items to note when building classes with Moose.
.PP
When you \f(CW\*(C`use Moose\*(C'\fR, Moose will set the class's parent class to
Moose::Object, \fIunless\fR the class using Moose already has a parent
class. In addition, specifying a parent with \f(CW\*(C`extends\*(C'\fR will change the parent
class.
.PP
Moose will also manage all attributes (including inherited ones) that are
defined with \f(CW\*(C`has\*(C'\fR. And (assuming you call \f(CW\*(C`new\*(C'\fR, which is inherited from
Moose::Object) this includes properly initializing all instance slots,
setting defaults where appropriate, and performing any type constraint checking
or coercion.
.SH "PROVIDED METHODS"
.IX Header "PROVIDED METHODS"
Moose provides a number of methods to all your classes, mostly through the
inheritance of Moose::Object. There is however, one exception.
.IP "\fBmeta\fR" 4
.IX Item "meta"
This is a method which provides access to the current class's metaclass.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Moose will export a number of functions into the class's namespace which
may then be used to set up the class. These functions all work directly
on the current class.
.IP "\fBextends (@superclasses)\fR" 4
.IX Item "extends (@superclasses)"
This function will set the superclass(es) for the current class.
.Sp
This approach is recommended instead of \f(CW\*(C`use base\*(C'\fR, because \f(CW\*(C`use base\*(C'\fR
actually \f(CW\*(C`push\*(C'\fRes onto the class's \f(CW@ISA\fR, whereas \f(CW\*(C`extends\*(C'\fR will
replace it. This is important to ensure that classes which do not have
superclasses still properly inherit from Moose::Object.
.Sp
Each superclass can be followed by a hash reference with options. Currently,
only \-version is recognized:
.Sp
.Vb 2
\&    extends \*(AqMy::Parent\*(Aq      => { \-version => 0.01 },
\&            \*(AqMy::OtherParent\*(Aq => { \-version => 0.03 };
.Ve
.Sp
An exception will be thrown if the version requirements are not
satisfied.
.IP "\fBwith (@roles)\fR" 4
.IX Item "with (@roles)"
This will apply a given set of \f(CW@roles\fR to the local class.
.Sp
Like with \f(CW\*(C`extends\*(C'\fR, each specified role can be followed by a hash
reference with a \-version option:
.Sp
.Vb 2
\&    with \*(AqMy::Role\*(Aq      => { \-version => 0.32 },
\&         \*(AqMy::Otherrole\*(Aq => { \-version => 0.23 };
.Ve
.Sp
The specified version requirements must be satisfied, otherwise an
exception will be thrown.
.Sp
If your role takes options or arguments, they can be passed along in the
hash reference as well.
.ie n .IP "\fBhas \fB$name\fB|@$names => \f(BI%options\fB\fR" 4
.el .IP "\fBhas \f(CB$name\fB|@$names => \f(CB%options\fB\fR" 4
.IX Item "has $name|@$names => %options"
This will install an attribute of a given \f(CW$name\fR into the current class. If
the first parameter is an array reference, it will create an attribute for
every \f(CW$name\fR in the list. The \f(CW%options\fR will be passed to the constructor
for Moose::Meta::Attribute (which inherits from Class::MOP::Attribute),
so the full documentation for the valid options can be found there. These are
the most commonly used options:
.RS 4
.IP "\fIis => 'rw'|'ro'\fR" 4
.IX Item "is => 'rw'|'ro'"
The \fIis\fR option accepts either \fIrw\fR (for read/write) or \fIro\fR (for read
only). These will create either a read/write accessor or a read-only
accessor respectively, using the same name as the \f(CW$name\fR of the attribute.
.Sp
If you need more control over how your accessors are named, you can
use the reader,
writer and
accessor options inherited from
Class::MOP::Attribute, however if you use those, you won't need the
\&\fIis\fR option.
.ie n .IP "\fIisa => \fI$type_name\fI\fR" 4
.el .IP "\fIisa => \f(CI$type_name\fI\fR" 4
.IX Item "isa => $type_name"
The \fIisa\fR option uses Moose's type constraint facilities to set up runtime
type checking for this attribute. Moose will perform the checks during class
construction, and within any accessors. The \f(CW$type_name\fR argument must be a
string. The string may be either a class name or a type defined using
Moose's type definition features. (Refer to Moose::Util::TypeConstraints
for information on how to define a new type, and how to retrieve type meta-data).
.IP "\fIcoerce => (1|0)\fR" 4
.IX Item "coerce => (1|0)"
This will attempt to use coercion with the supplied type constraint to change
the value passed into any accessors or constructors. You \fBmust\fR supply a type
constraint, and that type constraint \fBmust\fR define a coercion. See
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion for an example.
.ie n .IP "\fIdoes => \fI$role_name\fI\fR" 4
.el .IP "\fIdoes => \f(CI$role_name\fI\fR" 4
.IX Item "does => $role_name"
This will accept the name of a role which the value stored in this attribute
is expected to have consumed.
.IP "\fIrequired => (1|0)\fR" 4
.IX Item "required => (1|0)"
This marks the attribute as being required. This means a value must be
supplied during class construction, \fIor\fR the attribute must be lazy
and have either a default or a builder. Note that c<required> does not
say anything about the attribute's value, which can be \f(CW\*(C`undef\*(C'\fR.
.IP "\fIweak_ref => (1|0)\fR" 4
.IX Item "weak_ref => (1|0)"
This will tell the class to store the value of this attribute as a weakened
reference. If an attribute is a weakened reference, it \fBcannot\fR also be
coerced. Note that when a weak ref expires, the attribute's value becomes
undefined, and is still considered to be set for purposes of predicate,
default, etc.
.IP "\fIlazy => (1|0)\fR" 4
.IX Item "lazy => (1|0)"
This will tell the class to not create this slot until absolutely necessary.
If an attribute is marked as lazy it \fBmust\fR have a default or builder
supplied.
.ie n .IP "\fItrigger => \fI$code\fI\fR" 4
.el .IP "\fItrigger => \f(CI$code\fI\fR" 4
.IX Item "trigger => $code"
The \fItrigger\fR option is a \s-1CODE\s0 reference which will be called after
the value of the attribute is set. The \s-1CODE\s0 ref is passed the
instance itself, the updated value, and the original value if the
attribute was already set.
.Sp
You \fBcan\fR have a trigger on a read-only attribute.
.Sp
\&\fB\s-1NOTE:\s0\fR Triggers will only fire when you \fBassign\fR to the attribute,
either in the constructor, or using the writer. Default and built values will
\&\fBnot\fR cause the trigger to be fired.
.IP "\fIhandles => \s-1ARRAY\s0 | \s-1HASH\s0 | \s-1REGEXP\s0 | \s-1ROLE\s0 | \s-1ROLETYPE\s0 | \s-1DUCKTYPE\s0 | \s-1CODE\s0\fR" 4
.IX Item "handles => ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE"
The \fIhandles\fR option provides Moose classes with automated delegation features.
This is a pretty complex and powerful option. It accepts many different option
formats, each with its own benefits and drawbacks.
.Sp
\&\fB\s-1NOTE:\s0\fR The class being delegated to does not need to be a Moose based class,
which is why this feature is especially useful when wrapping non-Moose classes.
.Sp
All \fIhandles\fR option formats share the following traits:
.Sp
You cannot override a locally defined method with a delegated method; an
exception will be thrown if you try. That is to say, if you define \f(CW\*(C`foo\*(C'\fR in
your class, you cannot override it with a delegated \f(CW\*(C`foo\*(C'\fR. This is almost never
something you would want to do, and if it is, you should do it by hand and not
use Moose.
.Sp
You cannot override any of the methods found in Moose::Object, or the \f(CW\*(C`BUILD\*(C'\fR
and \f(CW\*(C`DEMOLISH\*(C'\fR methods. These will not throw an exception, but will silently
move on to the next method in the list. My reasoning for this is that you would
almost never want to do this, since it usually breaks your class. As with
overriding locally defined methods, if you do want to do this, you should do it
manually, not with Moose.
.Sp
You do not \fIneed\fR to have a reader (or accessor) for the attribute in order
to delegate to it. Moose will create a means of accessing the value for you,
however this will be several times \fBless\fR efficient then if you had given
the attribute a reader (or accessor) to use.
.Sp
Below is the documentation for each option format:
.RS 4
.ie n .IP """ARRAY""" 4
.el .IP "\f(CWARRAY\fR" 4
.IX Item "ARRAY"
This is the most common usage for \fIhandles\fR. You basically pass a list of
method names to be delegated, and Moose will install a delegation method
for each one.
.ie n .IP """HASH""" 4
.el .IP "\f(CWHASH\fR" 4
.IX Item "HASH"
This is the second most common usage for \fIhandles\fR. Instead of a list of
method names, you pass a \s-1HASH\s0 ref where each key is the method name you
want installed locally, and its value is the name of the original method
in the class being delegated to.
.Sp
This can be very useful for recursive classes like trees. Here is a
quick example (soon to be expanded into a Moose::Cookbook recipe):
.Sp
.Vb 2
\&  package Tree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqchildren\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqArrayRef\*(Aq,
\&      default => sub { [] }
\&  );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is          => \*(Aqrw\*(Aq,
\&      isa         => \*(AqTree\*(Aq,
\&      weak_ref    => 1,
\&      handles     => {
\&          parent_node => \*(Aqnode\*(Aq,
\&          siblings    => \*(Aqchildren\*(Aq,
\&      }
\&  );
.Ve
.Sp
In this example, the Tree package gets \f(CW\*(C`parent_node\*(C'\fR and \f(CW\*(C`siblings\*(C'\fR methods,
which delegate to the \f(CW\*(C`node\*(C'\fR and \f(CW\*(C`children\*(C'\fR methods (respectively) of the Tree
instance stored in the \f(CW\*(C`parent\*(C'\fR slot.
.Sp
You may also use an array reference to curry arguments to the original method.
.Sp
.Vb 4
\&  has \*(Aqthing\*(Aq => (
\&      ...
\&      handles => { set_foo => [ set => \*(Aqfoo\*(Aq ] },
\&  );
\&
\&  # $self\->set_foo(...) calls $self\->thing\->set(\*(Aqfoo\*(Aq, ...)
.Ve
.Sp
The first element of the array reference is the original method name, and the
rest is a list of curried arguments.
.ie n .IP """REGEXP""" 4
.el .IP "\f(CWREGEXP\fR" 4
.IX Item "REGEXP"
The regexp option works very similar to the \s-1ARRAY\s0 option, except that it builds
the list of methods for you. It starts by collecting all possible methods of the
class being delegated to, then filters that list using the regexp supplied here.
.Sp
\&\fB\s-1NOTE:\s0\fR An \fIisa\fR option is required when using the regexp option format. This
is so that we can determine (at compile time) the method list from the class.
Without an \fIisa\fR this is just not possible.
.ie n .IP """ROLE"" or ""ROLETYPE""" 4
.el .IP "\f(CWROLE\fR or \f(CWROLETYPE\fR" 4
.IX Item "ROLE or ROLETYPE"
With the role option, you specify the name of a role or a
role type whose \*(L"interface\*(R" then becomes
the list of methods to handle. The \*(L"interface\*(R" can be defined as; the methods
of the role and any required methods of the role. It should be noted that this
does \fBnot\fR include any method modifiers or generated attribute methods (which
is consistent with role composition).
.ie n .IP """DUCKTYPE""" 4
.el .IP "\f(CWDUCKTYPE\fR" 4
.IX Item "DUCKTYPE"
With the duck type option, you pass a duck type object whose \*(L"interface\*(R" then
becomes the list of methods to handle. The \*(L"interface\*(R" can be defined as the
list of methods passed to \f(CW\*(C`duck_type\*(C'\fR to create a duck type object. For more
information on \f(CW\*(C`duck_type\*(C'\fR please check
Moose::Util::TypeConstraints.
.ie n .IP """CODE""" 4
.el .IP "\f(CWCODE\fR" 4
.IX Item "CODE"
This is the option to use when you really want to do something funky. You should
only use it if you really know what you are doing, as it involves manual
metaclass twiddling.
.Sp
This takes a code reference, which should expect two arguments. The first is the
attribute meta-object this \fIhandles\fR is attached to. The second is the
metaclass of the class being delegated to. It expects you to return a hash (not
a \s-1HASH\s0 ref) of the methods you want mapped.
.RE
.RS 4
.RE
.ie n .IP "\fItraits => [ \fI@role_names\fI ]\fR" 4
.el .IP "\fItraits => [ \f(CI@role_names\fI ]\fR" 4
.IX Item "traits => [ @role_names ]"
This tells Moose to take the list of \f(CW@role_names\fR and apply them to the
attribute meta-object. Custom attribute metaclass traits are useful for
extending the capabilities of the \fIhas\fR keyword: they are the simplest way to
extend the \s-1MOP\s0, but they are still a fairly advanced topic and too much to
cover here.
.Sp
See \*(L"Metaclass and Trait Name Resolution\*(R" for details on how a trait name is
resolved to a role name.
.Sp
Also see Moose::Cookbook::Meta::Labeled_AttributeTrait for a metaclass
trait example.
.IP "\fIbuilder\fR => Str" 4
.IX Item "builder => Str"
The value of this key is the name of the method that will be called to obtain
the value used to initialize the attribute. See the builder option docs in
Class::MOP::Attribute and/or
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for more
information.
.IP "\fIdefault\fR => \s-1SCALAR\s0 | \s-1CODE\s0" 4
.IX Item "default => SCALAR | CODE"
The value of this key is the default value which will initialize the attribute.
.Sp
\&\s-1NOTE:\s0 If the value is a simple scalar (string or number), then it can
be just passed as is.  However, if you wish to initialize it with a
\&\s-1HASH\s0 or \s-1ARRAY\s0 ref, then you need to wrap that inside a \s-1CODE\s0 reference.
See the default option docs in
Class::MOP::Attribute for more
information.
.IP "\fIclearer\fR => Str" 4
.IX Item "clearer => Str"
Creates a method allowing you to clear the value. See the clearer option
docs in Class::MOP::Attribute for more
information.
.IP "\fIpredicate\fR => Str" 4
.IX Item "predicate => Str"
Creates a method to perform a basic test to see if a value has been set in the
attribute. See the predicate option docs in
Class::MOP::Attribute for more information.
.Sp
Note that the predicate will return true even for a \f(CW\*(C`weak_ref\*(C'\fR attribute
whose value has expired.
.ie n .IP "\fIdocumentation\fR => $string" 4
.el .IP "\fIdocumentation\fR => \f(CW$string\fR" 4
.IX Item "documentation => $string"
An arbitrary string that can be retrieved later by calling \f(CW\*(C`$attr\->documentation\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP "\fBhas +$name => \fB%options\fB\fR" 4
.el .IP "\fBhas +$name => \f(CB%options\fB\fR" 4
.IX Item "has +$name => %options"
This is variation on the normal attribute creator \f(CW\*(C`has\*(C'\fR which allows you to
clone and extend an attribute from a superclass or from a role. Here is an
example of the superclass usage:
.Sp
.Vb 2
\&  package Foo;
\&  use Moose;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  extends \*(AqFoo\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
What is happening here is that \fBMy::Foo\fR is cloning the \f(CW\*(C`message\*(C'\fR attribute
from its parent class \fBFoo\fR, retaining the \f(CW\*(C`is => \*(Aqrw\*(Aq\*(C'\fR and \f(CW\*(C`isa =>
\&\*(AqStr\*(Aq\*(C'\fR characteristics, but changing the value in \f(CW\*(C`default\*(C'\fR.
.Sp
Here is another example, but within the context of a role:
.Sp
.Vb 2
\&  package Foo::Role;
\&  use Moose::Role;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  with \*(AqFoo::Role\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
In this case, we are basically taking the attribute which the role supplied
and altering it within the bounds of this feature.
.Sp
Note that you can only extend an attribute from either a superclass or a role,
you cannot extend an attribute in a role that composes over an attribute from
another role.
.Sp
Aside from where the attributes come from (one from superclass, the other
from a role), this feature works exactly the same. This feature is restricted
somewhat, so as to try and force at least \fIsome\fR sanity into it. Most options work the same, but there are some exceptions:
.RS 4
.IP "\fIreader\fR" 4
.IX Item "reader"
.PD 0
.IP "\fIwriter\fR" 4
.IX Item "writer"
.IP "\fIaccessor\fR" 4
.IX Item "accessor"
.IP "\fIclearer\fR" 4
.IX Item "clearer"
.IP "\fIpredicate\fR" 4
.IX Item "predicate"
.PD
These options can be added, but cannot override a superclass definition.
.IP "\fItraits\fR" 4
.IX Item "traits"
You are allowed to \fBadd\fR additional traits to the \f(CW\*(C`traits\*(C'\fR definition.
These traits will be composed into the attribute, but preexisting traits
\&\fBare not\fR overridden, or removed.
.RE
.RS 4
.RE
.ie n .IP "\fBbefore \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBbefore \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "before $name|@names|@names|qr/.../ => sub { ... }"
.PD 0
.ie n .IP "\fBafter \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBafter \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "after $name|@names|@names|qr/.../ => sub { ... }"
.ie n .IP "\fBaround \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBaround \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "around $name|@names|@names|qr/.../ => sub { ... }"
.PD
These three items are syntactic sugar for the before, after, and around method
modifier features that Class::MOP provides. More information on these may be
found in Moose::Manual::MethodModifiers and the
Class::MOP::Class documentation.
.IP "\fBoverride ($name, &sub)\fR" 4
.IX Item "override ($name, &sub)"
An \f(CW\*(C`override\*(C'\fR method is a way of explicitly saying \*(L"I am overriding this
method from my superclass\*(R". You can call \f(CW\*(C`super\*(C'\fR within this method, and
it will work as expected. The same thing \fIcan\fR be accomplished with a normal
method call and the \f(CW\*(C`SUPER::\*(C'\fR pseudo-package; it is really your choice.
.IP "\fBsuper\fR" 4
.IX Item "super"
The keyword \f(CW\*(C`super\*(C'\fR is a no-op when called outside of an \f(CW\*(C`override\*(C'\fR method. In
the context of an \f(CW\*(C`override\*(C'\fR method, it will call the next most appropriate
superclass method with the same arguments as the original method.
.IP "\fBaugment ($name, &sub)\fR" 4
.IX Item "augment ($name, &sub)"
An \f(CW\*(C`augment\*(C'\fR method, is a way of explicitly saying \*(L"I am augmenting this
method from my superclass\*(R". Once again, the details of how \f(CW\*(C`inner\*(C'\fR and
\&\f(CW\*(C`augment\*(C'\fR work is best described in the
Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBinner\fR" 4
.IX Item "inner"
The keyword \f(CW\*(C`inner\*(C'\fR, much like \f(CW\*(C`super\*(C'\fR, is a no-op outside of the context of
an \f(CW\*(C`augment\*(C'\fR method. You can think of \f(CW\*(C`inner\*(C'\fR as being the inverse of
\&\f(CW\*(C`super\*(C'\fR; the details of how \f(CW\*(C`inner\*(C'\fR and \f(CW\*(C`augment\*(C'\fR work is best described in
the Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBblessed\fR" 4
.IX Item "blessed"
This is the \f(CW\*(C`Scalar::Util::blessed\*(C'\fR function. It is highly recommended that
this is used instead of \f(CW\*(C`ref\*(C'\fR anywhere you need to test for an object's class
name.
.IP "\fBconfess\fR" 4
.IX Item "confess"
This is the \f(CW\*(C`Carp::confess\*(C'\fR function, and exported here for historical
reasons.
.SH "METACLASS"
.IX Header "METACLASS"
When you use Moose, you can specify traits which will be applied to your
metaclass:
.PP
.Vb 1
\&    use Moose \-traits => \*(AqMy::Trait\*(Aq;
.Ve
.PP
This is very similar to the attribute traits feature. When you do
this, your class's \f(CW\*(C`meta\*(C'\fR object will have the specified traits
applied to it. See \*(L"Metaclass and Trait Name Resolution\*(R" for more
details.
.SS "Metaclass and Trait Name Resolution"
.IX Subsection "Metaclass and Trait Name Resolution"
By default, when given a trait name, Moose simply tries to load a
class of the same name. If such a class does not exist, it then looks
for for a class matching
\&\fBMoose::Meta::$type::Custom::Trait::$trait_name\fR. The \f(CW$type\fR
variable here will be one of \fBAttribute\fR or \fBClass\fR, depending on
what the trait is being applied to.
.PP
If a class with this long name exists, Moose checks to see if it has
the method \f(CW\*(C`register_implementation\*(C'\fR. This method is expected to
return the \fIreal\fR class name of the trait. If there is no
\&\f(CW\*(C`register_implementation\*(C'\fR method, it will fall back to using
\&\fBMoose::Meta::$type::Custom::Trait::$trait\fR as the trait name.
.PP
The lookup method for metaclasses is the same, except that it looks
for a class matching \fBMoose::Meta::$type::Custom::$metaclass_name\fR.
.PP
If all this is confusing, take a look at
Moose::Cookbook::Meta::Labeled_AttributeTrait, which demonstrates how to
create an attribute trait.
.SH "UNIMPORTING FUNCTIONS"
.IX Header "UNIMPORTING FUNCTIONS"
.SS "\fBunimport\fP"
.IX Subsection "unimport"
Moose offers a way to remove the keywords it exports, through the \f(CW\*(C`unimport\*(C'\fR
method. You simply have to say \f(CW\*(C`no Moose\*(C'\fR at the bottom of your code for this
to work. Here is an example:
.PP
.Vb 2
\&    package Person;
\&    use Moose;
\&
\&    has \*(Aqfirst_name\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&    has \*(Aqlast_name\*(Aq  => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&
\&    sub full_name {
\&        my $self = shift;
\&        $self\->first_name . \*(Aq \*(Aq . $self\->last_name
\&    }
\&
\&    no Moose; # keywords are removed from the Person package
.Ve
.SH "EXTENDING AND EMBEDDING MOOSE"
.IX Header "EXTENDING AND EMBEDDING MOOSE"
To learn more about extending Moose, we recommend checking out the
\&\*(L"Extending\*(R" recipes in the Moose::Cookbook, starting with
Moose::Cookbook::Extending::ExtensionOverview, which provides an overview of
all the different ways you might extend Moose. Moose::Exporter and
Moose::Util::MetaRole are the modules which provide the majority of the
extension functionality, so reading their documentation should also be helpful.
.SS "The MooseX:: namespace"
.IX Subsection "The MooseX:: namespace"
Generally if you're writing an extension \fIfor\fR Moose itself you'll want
to put your extension in the \f(CW\*(C`MooseX::\*(C'\fR namespace. This namespace is
specifically for extensions that make Moose better or different in some
fundamental way. It is traditionally \fBnot\fR for a package that just happens
to use Moose. This namespace follows from the examples of the \f(CW\*(C`LWPx::\*(C'\fR
and \f(CW\*(C`DBIx::\*(C'\fR namespaces that perform the same function for \f(CW\*(C`LWP\*(C'\fR and \f(CW\*(C`DBI\*(C'\fR
respectively.
.SH "METACLASS COMPATIBILITY AND MOOSE"
.IX Header "METACLASS COMPATIBILITY AND MOOSE"
Metaclass compatibility is a thorny subject. You should start by
reading the \*(L"About Metaclass compatibility\*(R" section in the
\&\f(CW\*(C`Class::MOP\*(C'\fR docs.
.PP
Moose will attempt to resolve a few cases of metaclass incompatibility
when you set the superclasses for a class, in addition to the cases that
\&\f(CW\*(C`Class::MOP\*(C'\fR handles.
.PP
Moose tries to determine if the metaclasses only \*(L"differ by roles\*(R". This
means that the parent and child's metaclass share a common ancestor in
their respective hierarchies, and that the subclasses under the common
ancestor are only different because of role applications. This case is
actually fairly common when you mix and match various \f(CW\*(C`MooseX::*\*(C'\fR
modules, many of which apply roles to the metaclass.
.PP
If the parent and child do differ by roles, Moose replaces the
metaclass in the child with a newly created metaclass. This metaclass
is a subclass of the parent's metaclass which does all of the roles that
the child's metaclass did before being replaced. Effectively, this
means the new metaclass does all of the roles done by both the
parent's and child's original metaclasses.
.PP
Ultimately, this is all transparent to you except in the case of an
unresolvable conflict.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
It should be noted that \f(CW\*(C`super\*(C'\fR and \f(CW\*(C`inner\*(C'\fR \fBcannot\fR be used in the same
method. However, they may be combined within the same class hierarchy; see
\&\fIt/basics/override_augment_inner_super.t\fR for an example.
.Sp
The reason for this is that \f(CW\*(C`super\*(C'\fR is only valid within a method
with the \f(CW\*(C`override\*(C'\fR modifier, and \f(CW\*(C`inner\*(C'\fR will never be valid within an
\&\f(CW\*(C`override\*(C'\fR method. In fact, \f(CW\*(C`augment\*(C'\fR will skip over any \f(CW\*(C`override\*(C'\fR methods
when searching for its appropriate \f(CW\*(C`inner\*(C'\fR.
.Sp
This might seem like a restriction, but I am of the opinion that keeping these
two features separate (yet interoperable) actually makes them easy to use, since
their behavior is then easier to predict. Time will tell whether I am right or
not (\s-1UPDATE:\s0 so far so good).
.SH "GETTING HELP"
.IX Header "GETTING HELP"
We offer both a mailing list and a very active \s-1IRC\s0 channel.
.PP
The mailing list is <mailto:moose@perl.org>. You must be subscribed to send
a message. To subscribe, send an empty message to
mailto:moose\-subscribe@perl.org <mailto:moose-subscribe@perl.org>
.PP
You can also visit us at \f(CW\*(C`#moose\*(C'\fR on <irc://irc.perl.org/#moose>
This channel is quite active, and questions at all levels (on Moose-related
topics ;) are welcome.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "I blame Sam Vilain for introducing me to the insanity that is meta-models." 4
.IX Item "I blame Sam Vilain for introducing me to the insanity that is meta-models."
.PD 0
.IP "I blame Audrey Tang for then encouraging my meta-model habit in #perl6." 4
.IX Item "I blame Audrey Tang for then encouraging my meta-model habit in #perl6."
.ie n .IP "Without Yuval ""nothingmuch"" Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.el .IP "Without Yuval ``nothingmuch'' Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.IX Item "Without Yuval nothingmuch Kogman this module would not be possible, and it certainly wouldn't have this name ;P"
.IP "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it." 4
.IX Item "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it."
.IP "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature\-requests/encouragement/bug\-finding." 4
.IX Item "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature-requests/encouragement/bug-finding."
.ie n .IP "Thanks to David ""Theory"" Wheeler for meta-discussions and spelling fixes." 4
.el .IP "Thanks to David ``Theory'' Wheeler for meta-discussions and spelling fixes." 4
.IX Item "Thanks to David Theory Wheeler for meta-discussions and spelling fixes."
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://www.iinteractive.com/moose>" 4
.IX Item "<http://www.iinteractive.com/moose>"
This is the official web home of Moose. It contains links to our public git
repository, as well as links to a number of talks and articles on Moose and
Moose related technologies.
.IP "the Moose manual" 4
.IX Item "the Moose manual"
This is an introduction to Moose which covers most of the basics.
.IP "Modern Perl, by chromatic" 4
.IX Item "Modern Perl, by chromatic"
This is an introduction to modern Perl programming, which includes a section on
Moose. It is available in print and as a free download from
<http://onyxneon.com/books/modern_perl/>.
.IP "The Moose is flying, a tutorial by Randal Schwartz" 4
.IX Item "The Moose is flying, a tutorial by Randal Schwartz"
Part 1 \- <http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
.Sp
Part 2 \- <http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
.ie n .IP "Several Moose extension modules in the ""MooseX::"" namespace." 4
.el .IP "Several Moose extension modules in the \f(CWMooseX::\fR namespace." 4
.IX Item "Several Moose extension modules in the MooseX:: namespace."
See <http://search.cpan.org/search?query=MooseX::> for extensions.
.SS "Books"
.IX Subsection "Books"
.IP "The Art of the MetaObject Protocol" 4
.IX Item "The Art of the MetaObject Protocol"
I mention this in the Class::MOP docs too, as this book was critical in
the development of both modules and is highly recommended.
.SS "Papers"
.IX Subsection "Papers"
.IP "http://www.cs.utah.edu/plt/publications/oopsla04\-gff.pdf <http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>" 4
.IX Item "http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf <http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>"
This paper (suggested by lbr on #moose) was what lead to the implementation
of the \f(CW\*(C`super\*(C'\fR/\f(CW\*(C`override\*(C'\fR and \f(CW\*(C`inner\*(C'\fR/\f(CW\*(C`augment\*(C'\fR features. If you really
want to understand them, I suggest you read this.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception.
.PP
Please report any bugs to \f(CW\*(C`bug\-moose@rt.cpan.org\*(C'\fR, or through the web
interface at <http://rt.cpan.org>.
.PP
You can also discuss feature requests or possible bugs on the Moose mailing
list (moose@perl.org) or on \s-1IRC\s0 at <irc://irc.perl.org/#moose>.
.SH "FEATURE REQUESTS"
.IX Header "FEATURE REQUESTS"
We are very strict about what features we add to the Moose core, especially
the user-visible features. Instead we have made sure that the underlying
meta-system of Moose is as extensible as possible so that you can add your
own features easily.
.PP
That said, occasionally there is a feature needed in the meta-system
to support your planned extension, in which case you should either
email the mailing list (moose@perl.org) or join us on \s-1IRC\s0 at
<irc://irc.perl.org/#moose> to discuss. The
Moose::Manual::Contributing has more detail about how and when you
can contribute.
.SH "CABAL"
.IX Header "CABAL"
There are only a few people with the rights to release a new version
of Moose. The Moose Cabal are the people to go to with questions regarding
the wider purview of Moose. They help maintain not just the code
but the community as well.
.PP
Stevan (stevan) Little <stevan@iinteractive.com>
.PP
Jesse (doy) Luehrs <doy at tozt dot net>
.PP
Yuval (nothingmuch) Kogman
.PP
Shawn (sartak) Moore <sartak@bestpractical.com>
.PP
Hans Dieter (confound) Pearcey <hdp@pobox.com>
.PP
Chris (perigrin) Prather
.PP
Florian Ragwitz <rafl@debian.org>
.PP
Dave (autarch) Rolsky <autarch@urth.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Moose is a community project, and as such, involves the work of many, many
members of the community beyond just the members in the cabal. In particular:
.PP
Dave (autarch) Rolsky wrote most of the documentation in Moose::Manual.
.PP
John (jgoulah) Goulah wrote Moose::Cookbook::Snack::Keywords.
.PP
Jess (castaway) Robinson wrote Moose::Cookbook::Snack::Types.
.PP
Aran (bluefeet) Clary Deltac wrote
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion.
.PP
Anders (Debolaz) Nor Berle contributed Test::Moose and Moose::Util.
.PP
Also, the code in Moose::Meta::Attribute::Native is based on code from the
MooseX::AttributeHelpers distribution, which had contributions from:
.PP
Chris (perigrin) Prather
.PP
Cory (gphat) Watson
.PP
Evan Carroll
.PP
Florian (rafl) Ragwitz
.PP
Jason May
.PP
Jay Hannah
.PP
Jesse (doy) Luehrs
.PP
Paul (frodwith) Driver
.PP
Robert (rlb3) Boone
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Shawn (Sartak) Moore
.PP
Stevan Little
.PP
Tom (dec) Lanyon
.PP
Yuval Kogman
.PP
Finally, these people also contributed various tests, bug fixes,
documentation, and features to the Moose codebase:
.PP
Aankhen
.PP
Adam (Alias) Kennedy
.PP
Christian (chansen) Hansen
.PP
Cory (gphat) Watson
.PP
Dylan Hardison (doc fixes)
.PP
Eric (ewilhelm) Wilhelm
.PP
Evan Carroll
.PP
Guillermo (groditi) Roditi
.PP
Jason May
.PP
Jay Hannah
.PP
Jonathan (jrockway) Rockway
.PP
Matt (mst) Trout
.PP
Nathan (kolibrie) Gray
.PP
Paul (frodwith) Driver
.PP
Piotr (dexter) Roszatycki
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Robert (rlb3) Boone
.PP
Sam (mugwump) Vilain
.PP
Scott (konobi) McWhirter
.PP
Shlomi (rindolf) Fish
.PP
Tom (dec) Lanyon
.PP
Wallace (wreis) Reis
.PP
\&... and many other #moose folks
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose5.18.3pm                                0100644 0001750 0001750 00000117526 12566242161 022710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose 3"
.TH Moose 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose \- A postmodern object system for Perl 5
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose; # automatically turns on strict and warnings
\&
\&  has \*(Aqx\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&  has \*(Aqy\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose is an extension of the Perl 5 object system.
.PP
The main goal of Moose is to make Perl 5 Object Oriented programming
easier, more consistent, and less tedious. With Moose you can think
more about what you want to do and less about the mechanics of \s-1OOP.\s0
.PP
Additionally, Moose is built on top of Class::MOP, which is a
metaclass system for Perl 5. This means that Moose not only makes
building normal Perl 5 objects better, but it provides the power of
metaclass programming as well.
.SS "New to Moose?"
.IX Subsection "New to Moose?"
If you're new to Moose, the best place to start is the
Moose::Manual docs, followed by the Moose::Cookbook. The intro
will show you what Moose is, and how it makes Perl 5 \s-1OO\s0 better.
.PP
The cookbook recipes on Moose basics will get you up to speed with
many of Moose's features quickly. Once you have an idea of what Moose
can do, you can use the \s-1API\s0 documentation to get more detail on
features which interest you.
.SS "Moose Extensions"
.IX Subsection "Moose Extensions"
The \f(CW\*(C`MooseX::\*(C'\fR namespace is the official place to find Moose extensions.
These extensions can be found on the \s-1CPAN. \s0 The easiest way to find them
is to search for them (<https://metacpan.org/search?q=MooseX::>),
or to examine Task::Moose which aims to keep an up-to-date, easily
installable list of Moose extensions.
.SH "TRANSLATIONS"
.IX Header "TRANSLATIONS"
Much of the Moose documentation has been translated into other languages.
.IP "Japanese" 4
.IX Item "Japanese"
Japanese docs can be found at
<http://perldoc.perlassociation.org/pod/Moose\-Doc\-JA/index.html>. The
source \s-1POD\s0 files can be found in GitHub:
<http://github.com/jpa/Moose\-Doc\-JA>
.SH "BUILDING CLASSES WITH MOOSE"
.IX Header "BUILDING CLASSES WITH MOOSE"
Moose makes every attempt to provide as much convenience as possible during
class construction/definition, but still stay out of your way if you want it
to. Here are a few items to note when building classes with Moose.
.PP
When you \f(CW\*(C`use Moose\*(C'\fR, Moose will set the class's parent class to
Moose::Object, \fIunless\fR the class using Moose already has a parent
class. In addition, specifying a parent with \f(CW\*(C`extends\*(C'\fR will change the parent
class.
.PP
Moose will also manage all attributes (including inherited ones) that are
defined with \f(CW\*(C`has\*(C'\fR. And (assuming you call \f(CW\*(C`new\*(C'\fR, which is inherited from
Moose::Object) this includes properly initializing all instance slots,
setting defaults where appropriate, and performing any type constraint checking
or coercion.
.SH "PROVIDED METHODS"
.IX Header "PROVIDED METHODS"
Moose provides a number of methods to all your classes, mostly through the
inheritance of Moose::Object. There is however, one exception.
.IP "\fBmeta\fR" 4
.IX Item "meta"
This is a method which provides access to the current class's metaclass.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Moose will export a number of functions into the class's namespace which
may then be used to set up the class. These functions all work directly
on the current class.
.IP "\fBextends (@superclasses)\fR" 4
.IX Item "extends (@superclasses)"
This function will set the superclass(es) for the current class. If the parent
classes are not yet loaded, then \f(CW\*(C`extends\*(C'\fR tries to load them.
.Sp
This approach is recommended instead of \f(CW\*(C`use base\*(C'\fR/\f(CW\*(C`use parent\*(C'\fR, because
\&\f(CW\*(C`use base\*(C'\fR actually \f(CW\*(C`push\*(C'\fRes onto the class's \f(CW@ISA\fR, whereas \f(CW\*(C`extends\*(C'\fR will
replace it. This is important to ensure that classes which do not have
superclasses still properly inherit from Moose::Object.
.Sp
Each superclass can be followed by a hash reference with options. Currently,
only \-version is recognized:
.Sp
.Vb 2
\&    extends \*(AqMy::Parent\*(Aq      => { \-version => 0.01 },
\&            \*(AqMy::OtherParent\*(Aq => { \-version => 0.03 };
.Ve
.Sp
An exception will be thrown if the version requirements are not
satisfied.
.IP "\fBwith (@roles)\fR" 4
.IX Item "with (@roles)"
This will apply a given set of \f(CW@roles\fR to the local class.
.Sp
Like with \f(CW\*(C`extends\*(C'\fR, each specified role can be followed by a hash
reference with a \-version option:
.Sp
.Vb 2
\&    with \*(AqMy::Role\*(Aq      => { \-version => 0.32 },
\&         \*(AqMy::Otherrole\*(Aq => { \-version => 0.23 };
.Ve
.Sp
The specified version requirements must be satisfied, otherwise an
exception will be thrown.
.Sp
If your role takes options or arguments, they can be passed along in the
hash reference as well.
.ie n .IP "\fBhas \fB$name\fB|@$names => \f(BI%options\fB\fR" 4
.el .IP "\fBhas \f(CB$name\fB|@$names => \f(CB%options\fB\fR" 4
.IX Item "has $name|@$names => %options"
This will install an attribute of a given \f(CW$name\fR into the current class. If
the first parameter is an array reference, it will create an attribute for
every \f(CW$name\fR in the list. The \f(CW%options\fR will be passed to the constructor
for Moose::Meta::Attribute (which inherits from Class::MOP::Attribute),
so the full documentation for the valid options can be found there. These are
the most commonly used options:
.RS 4
.IP "\fIis => 'rw'|'ro'\fR" 4
.IX Item "is => 'rw'|'ro'"
The \fIis\fR option accepts either \fIrw\fR (for read/write) or \fIro\fR (for read
only). These will create either a read/write accessor or a read-only
accessor respectively, using the same name as the \f(CW$name\fR of the attribute.
.Sp
If you need more control over how your accessors are named, you can
use the reader,
writer and
accessor options inherited from
Class::MOP::Attribute, however if you use those, you won't need the
\&\fIis\fR option.
.ie n .IP "\fIisa => \fI$type_name\fI\fR" 4
.el .IP "\fIisa => \f(CI$type_name\fI\fR" 4
.IX Item "isa => $type_name"
The \fIisa\fR option uses Moose's type constraint facilities to set up runtime
type checking for this attribute. Moose will perform the checks during class
construction, and within any accessors. The \f(CW$type_name\fR argument must be a
string. The string may be either a class name or a type defined using
Moose's type definition features. (Refer to Moose::Util::TypeConstraints
for information on how to define a new type, and how to retrieve type meta-data).
.IP "\fIcoerce => (1|0)\fR" 4
.IX Item "coerce => (1|0)"
This will attempt to use coercion with the supplied type constraint to change
the value passed into any accessors or constructors. You \fBmust\fR supply a type
constraint, and that type constraint \fBmust\fR define a coercion. See
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion for an example.
.ie n .IP "\fIdoes => \fI$role_name\fI\fR" 4
.el .IP "\fIdoes => \f(CI$role_name\fI\fR" 4
.IX Item "does => $role_name"
This will accept the name of a role which the value stored in this attribute
is expected to have consumed.
.IP "\fIrequired => (1|0)\fR" 4
.IX Item "required => (1|0)"
This marks the attribute as being required. This means a value must be
supplied during class construction, \fIor\fR the attribute must be lazy
and have either a default or a builder. Note that c<required> does not
say anything about the attribute's value, which can be \f(CW\*(C`undef\*(C'\fR.
.IP "\fIweak_ref => (1|0)\fR" 4
.IX Item "weak_ref => (1|0)"
This will tell the class to store the value of this attribute as a weakened
reference. If an attribute is a weakened reference, it \fBcannot\fR also be
coerced. Note that when a weak ref expires, the attribute's value becomes
undefined, and is still considered to be set for purposes of predicate,
default, etc.
.IP "\fIlazy => (1|0)\fR" 4
.IX Item "lazy => (1|0)"
This will tell the class to not create this slot until absolutely necessary.
If an attribute is marked as lazy it \fBmust\fR have a default or builder
supplied.
.ie n .IP "\fItrigger => \fI$code\fI\fR" 4
.el .IP "\fItrigger => \f(CI$code\fI\fR" 4
.IX Item "trigger => $code"
The \fItrigger\fR option is a \s-1CODE\s0 reference which will be called after
the value of the attribute is set. The \s-1CODE\s0 ref is passed the
instance itself, the updated value, and the original value if the
attribute was already set.
.Sp
You \fBcan\fR have a trigger on a read-only attribute.
.Sp
\&\fB\s-1NOTE:\s0\fR Triggers will only fire when you \fBassign\fR to the attribute,
either in the constructor, or using the writer. Default and built values will
\&\fBnot\fR cause the trigger to be fired.
.IP "\fIhandles => \s-1ARRAY\s0 | \s-1HASH\s0 | \s-1REGEXP\s0 | \s-1ROLE\s0 | \s-1ROLETYPE\s0 | \s-1DUCKTYPE\s0 | \s-1CODE\s0\fR" 4
.IX Item "handles => ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE"
The \fIhandles\fR option provides Moose classes with automated delegation features.
This is a pretty complex and powerful option. It accepts many different option
formats, each with its own benefits and drawbacks.
.Sp
\&\fB\s-1NOTE:\s0\fR The class being delegated to does not need to be a Moose based class,
which is why this feature is especially useful when wrapping non-Moose classes.
.Sp
All \fIhandles\fR option formats share the following traits:
.Sp
You cannot override a locally defined method with a delegated method; an
exception will be thrown if you try. That is to say, if you define \f(CW\*(C`foo\*(C'\fR in
your class, you cannot override it with a delegated \f(CW\*(C`foo\*(C'\fR. This is almost never
something you would want to do, and if it is, you should do it by hand and not
use Moose.
.Sp
You cannot override any of the methods found in Moose::Object, or the \f(CW\*(C`BUILD\*(C'\fR
and \f(CW\*(C`DEMOLISH\*(C'\fR methods. These will not throw an exception, but will silently
move on to the next method in the list. My reasoning for this is that you would
almost never want to do this, since it usually breaks your class. As with
overriding locally defined methods, if you do want to do this, you should do it
manually, not with Moose.
.Sp
You do not \fIneed\fR to have a reader (or accessor) for the attribute in order
to delegate to it. Moose will create a means of accessing the value for you,
however this will be several times \fBless\fR efficient then if you had given
the attribute a reader (or accessor) to use.
.Sp
Below is the documentation for each option format:
.RS 4
.ie n .IP """ARRAY""" 4
.el .IP "\f(CWARRAY\fR" 4
.IX Item "ARRAY"
This is the most common usage for \fIhandles\fR. You basically pass a list of
method names to be delegated, and Moose will install a delegation method
for each one.
.ie n .IP """HASH""" 4
.el .IP "\f(CWHASH\fR" 4
.IX Item "HASH"
This is the second most common usage for \fIhandles\fR. Instead of a list of
method names, you pass a \s-1HASH\s0 ref where each key is the method name you
want installed locally, and its value is the name of the original method
in the class being delegated to.
.Sp
This can be very useful for recursive classes like trees. Here is a
quick example (soon to be expanded into a Moose::Cookbook recipe):
.Sp
.Vb 2
\&  package Tree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqchildren\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqArrayRef\*(Aq,
\&      default => sub { [] }
\&  );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is          => \*(Aqrw\*(Aq,
\&      isa         => \*(AqTree\*(Aq,
\&      weak_ref    => 1,
\&      handles     => {
\&          parent_node => \*(Aqnode\*(Aq,
\&          siblings    => \*(Aqchildren\*(Aq,
\&      }
\&  );
.Ve
.Sp
In this example, the Tree package gets \f(CW\*(C`parent_node\*(C'\fR and \f(CW\*(C`siblings\*(C'\fR methods,
which delegate to the \f(CW\*(C`node\*(C'\fR and \f(CW\*(C`children\*(C'\fR methods (respectively) of the Tree
instance stored in the \f(CW\*(C`parent\*(C'\fR slot.
.Sp
You may also use an array reference to curry arguments to the original method.
.Sp
.Vb 4
\&  has \*(Aqthing\*(Aq => (
\&      ...
\&      handles => { set_foo => [ set => \*(Aqfoo\*(Aq ] },
\&  );
\&
\&  # $self\->set_foo(...) calls $self\->thing\->set(\*(Aqfoo\*(Aq, ...)
.Ve
.Sp
The first element of the array reference is the original method name, and the
rest is a list of curried arguments.
.ie n .IP """REGEXP""" 4
.el .IP "\f(CWREGEXP\fR" 4
.IX Item "REGEXP"
The regexp option works very similar to the \s-1ARRAY\s0 option, except that it builds
the list of methods for you. It starts by collecting all possible methods of the
class being delegated to, then filters that list using the regexp supplied here.
.Sp
\&\fB\s-1NOTE:\s0\fR An \fIisa\fR option is required when using the regexp option format. This
is so that we can determine (at compile time) the method list from the class.
Without an \fIisa\fR this is just not possible.
.ie n .IP """ROLE"" or ""ROLETYPE""" 4
.el .IP "\f(CWROLE\fR or \f(CWROLETYPE\fR" 4
.IX Item "ROLE or ROLETYPE"
With the role option, you specify the name of a role or a
role type whose \*(L"interface\*(R" then becomes
the list of methods to handle. The \*(L"interface\*(R" can be defined as; the methods
of the role and any required methods of the role. It should be noted that this
does \fBnot\fR include any method modifiers or generated attribute methods (which
is consistent with role composition).
.ie n .IP """DUCKTYPE""" 4
.el .IP "\f(CWDUCKTYPE\fR" 4
.IX Item "DUCKTYPE"
With the duck type option, you pass a duck type object whose \*(L"interface\*(R" then
becomes the list of methods to handle. The \*(L"interface\*(R" can be defined as the
list of methods passed to \f(CW\*(C`duck_type\*(C'\fR to create a duck type object. For more
information on \f(CW\*(C`duck_type\*(C'\fR please check
Moose::Util::TypeConstraints.
.ie n .IP """CODE""" 4
.el .IP "\f(CWCODE\fR" 4
.IX Item "CODE"
This is the option to use when you really want to do something funky. You should
only use it if you really know what you are doing, as it involves manual
metaclass twiddling.
.Sp
This takes a code reference, which should expect two arguments. The first is the
attribute meta-object this \fIhandles\fR is attached to. The second is the
metaclass of the class being delegated to. It expects you to return a hash (not
a \s-1HASH\s0 ref) of the methods you want mapped.
.RE
.RS 4
.RE
.ie n .IP "\fItraits => [ \fI@role_names\fI ]\fR" 4
.el .IP "\fItraits => [ \f(CI@role_names\fI ]\fR" 4
.IX Item "traits => [ @role_names ]"
This tells Moose to take the list of \f(CW@role_names\fR and apply them to the
attribute meta-object. Custom attribute metaclass traits are useful for
extending the capabilities of the \fIhas\fR keyword: they are the simplest way to
extend the \s-1MOP,\s0 but they are still a fairly advanced topic and too much to
cover here.
.Sp
See \*(L"Metaclass and Trait Name Resolution\*(R" for details on how a trait name is
resolved to a role name.
.Sp
Also see Moose::Cookbook::Meta::Labeled_AttributeTrait for a metaclass
trait example.
.IP "\fIbuilder\fR => Str" 4
.IX Item "builder => Str"
The value of this key is the name of the method that will be called to obtain
the value used to initialize the attribute. See the builder option docs in
Class::MOP::Attribute and/or
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for more
information.
.IP "\fIdefault\fR => \s-1SCALAR\s0 | \s-1CODE\s0" 4
.IX Item "default => SCALAR | CODE"
The value of this key is the default value which will initialize the attribute.
.Sp
\&\s-1NOTE:\s0 If the value is a simple scalar (string or number), then it can
be just passed as is.  However, if you wish to initialize it with a
\&\s-1HASH\s0 or \s-1ARRAY\s0 ref, then you need to wrap that inside a \s-1CODE\s0 reference.
See the default option docs in
Class::MOP::Attribute for more
information.
.IP "\fIclearer\fR => Str" 4
.IX Item "clearer => Str"
Creates a method allowing you to clear the value. See the clearer option
docs in Class::MOP::Attribute for more
information.
.IP "\fIpredicate\fR => Str" 4
.IX Item "predicate => Str"
Creates a method to perform a basic test to see if a value has been set in the
attribute. See the predicate option docs in
Class::MOP::Attribute for more information.
.Sp
Note that the predicate will return true even for a \f(CW\*(C`weak_ref\*(C'\fR attribute
whose value has expired.
.ie n .IP "\fIdocumentation\fR => $string" 4
.el .IP "\fIdocumentation\fR => \f(CW$string\fR" 4
.IX Item "documentation => $string"
An arbitrary string that can be retrieved later by calling \f(CW\*(C`$attr\->documentation\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP "\fBhas +$name => \fB%options\fB\fR" 4
.el .IP "\fBhas +$name => \f(CB%options\fB\fR" 4
.IX Item "has +$name => %options"
This is variation on the normal attribute creator \f(CW\*(C`has\*(C'\fR which allows you to
clone and extend an attribute from a superclass or from a role. Here is an
example of the superclass usage:
.Sp
.Vb 2
\&  package Foo;
\&  use Moose;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  extends \*(AqFoo\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
What is happening here is that \fBMy::Foo\fR is cloning the \f(CW\*(C`message\*(C'\fR attribute
from its parent class \fBFoo\fR, retaining the \f(CW\*(C`is => \*(Aqrw\*(Aq\*(C'\fR and \f(CW\*(C`isa =>
\&\*(AqStr\*(Aq\*(C'\fR characteristics, but changing the value in \f(CW\*(C`default\*(C'\fR.
.Sp
Here is another example, but within the context of a role:
.Sp
.Vb 2
\&  package Foo::Role;
\&  use Moose::Role;
\&
\&  has \*(Aqmessage\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(AqHello, I am a Foo\*(Aq
\&  );
\&
\&  package My::Foo;
\&  use Moose;
\&
\&  with \*(AqFoo::Role\*(Aq;
\&
\&  has \*(Aq+message\*(Aq => (default => \*(AqHello I am My::Foo\*(Aq);
.Ve
.Sp
In this case, we are basically taking the attribute which the role supplied
and altering it within the bounds of this feature.
.Sp
Note that you can only extend an attribute from either a superclass or a role,
you cannot extend an attribute in a role that composes over an attribute from
another role.
.Sp
Aside from where the attributes come from (one from superclass, the other
from a role), this feature works exactly the same. This feature is restricted
somewhat, so as to try and force at least \fIsome\fR sanity into it. Most options work the same, but there are some exceptions:
.RS 4
.IP "\fIreader\fR" 4
.IX Item "reader"
.PD 0
.IP "\fIwriter\fR" 4
.IX Item "writer"
.IP "\fIaccessor\fR" 4
.IX Item "accessor"
.IP "\fIclearer\fR" 4
.IX Item "clearer"
.IP "\fIpredicate\fR" 4
.IX Item "predicate"
.PD
These options can be added, but cannot override a superclass definition.
.IP "\fItraits\fR" 4
.IX Item "traits"
You are allowed to \fBadd\fR additional traits to the \f(CW\*(C`traits\*(C'\fR definition.
These traits will be composed into the attribute, but preexisting traits
\&\fBare not\fR overridden, or removed.
.RE
.RS 4
.RE
.ie n .IP "\fBbefore \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBbefore \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "before $name|@names|@names|qr/.../ => sub { ... }"
.PD 0
.ie n .IP "\fBafter \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBafter \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "after $name|@names|@names|qr/.../ => sub { ... }"
.ie n .IP "\fBaround \fB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.el .IP "\fBaround \f(CB$name\fB|@names|\e@names|qr/.../ => sub { ... }\fR" 4
.IX Item "around $name|@names|@names|qr/.../ => sub { ... }"
.PD
These three items are syntactic sugar for the before, after, and around method
modifier features that Class::MOP provides. More information on these may be
found in Moose::Manual::MethodModifiers and the
Class::MOP::Class documentation.
.IP "\fBoverride ($name, &sub)\fR" 4
.IX Item "override ($name, &sub)"
An \f(CW\*(C`override\*(C'\fR method is a way of explicitly saying \*(L"I am overriding this
method from my superclass\*(R". You can call \f(CW\*(C`super\*(C'\fR within this method, and
it will work as expected. The same thing \fIcan\fR be accomplished with a normal
method call and the \f(CW\*(C`SUPER::\*(C'\fR pseudo-package; it is really your choice.
.IP "\fBsuper\fR" 4
.IX Item "super"
The keyword \f(CW\*(C`super\*(C'\fR is a no-op when called outside of an \f(CW\*(C`override\*(C'\fR method. In
the context of an \f(CW\*(C`override\*(C'\fR method, it will call the next most appropriate
superclass method with the same arguments as the original method.
.IP "\fBaugment ($name, &sub)\fR" 4
.IX Item "augment ($name, &sub)"
An \f(CW\*(C`augment\*(C'\fR method, is a way of explicitly saying \*(L"I am augmenting this
method from my superclass\*(R". Once again, the details of how \f(CW\*(C`inner\*(C'\fR and
\&\f(CW\*(C`augment\*(C'\fR work is best described in the
Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBinner\fR" 4
.IX Item "inner"
The keyword \f(CW\*(C`inner\*(C'\fR, much like \f(CW\*(C`super\*(C'\fR, is a no-op outside of the context of
an \f(CW\*(C`augment\*(C'\fR method. You can think of \f(CW\*(C`inner\*(C'\fR as being the inverse of
\&\f(CW\*(C`super\*(C'\fR; the details of how \f(CW\*(C`inner\*(C'\fR and \f(CW\*(C`augment\*(C'\fR work is best described in
the Moose::Cookbook::Basics::Document_AugmentAndInner.
.IP "\fBblessed\fR" 4
.IX Item "blessed"
This is the \f(CW\*(C`Scalar::Util::blessed\*(C'\fR function. It is highly recommended that
this is used instead of \f(CW\*(C`ref\*(C'\fR anywhere you need to test for an object's class
name.
.IP "\fBconfess\fR" 4
.IX Item "confess"
This is the \f(CW\*(C`Carp::confess\*(C'\fR function, and exported here for historical
reasons.
.SH "METACLASS"
.IX Header "METACLASS"
When you use Moose, you can specify traits which will be applied to your
metaclass:
.PP
.Vb 1
\&    use Moose \-traits => \*(AqMy::Trait\*(Aq;
.Ve
.PP
This is very similar to the attribute traits feature. When you do
this, your class's \f(CW\*(C`meta\*(C'\fR object will have the specified traits
applied to it. See \*(L"Metaclass and Trait Name Resolution\*(R" for more
details.
.SS "Metaclass and Trait Name Resolution"
.IX Subsection "Metaclass and Trait Name Resolution"
By default, when given a trait name, Moose simply tries to load a
class of the same name. If such a class does not exist, it then looks
for a class matching
\&\fBMoose::Meta::$type::Custom::Trait::$trait_name\fR. The \f(CW$type\fR
variable here will be one of \fBAttribute\fR or \fBClass\fR, depending on
what the trait is being applied to.
.PP
If a class with this long name exists, Moose checks to see if it has
the method \f(CW\*(C`register_implementation\*(C'\fR. This method is expected to
return the \fIreal\fR class name of the trait. If there is no
\&\f(CW\*(C`register_implementation\*(C'\fR method, it will fall back to using
\&\fBMoose::Meta::$type::Custom::Trait::$trait\fR as the trait name.
.PP
The lookup method for metaclasses is the same, except that it looks
for a class matching \fBMoose::Meta::$type::Custom::$metaclass_name\fR.
.PP
If all this is confusing, take a look at
Moose::Cookbook::Meta::Labeled_AttributeTrait, which demonstrates how to
create an attribute trait.
.SH "UNIMPORTING FUNCTIONS"
.IX Header "UNIMPORTING FUNCTIONS"
.SS "\fBunimport\fP"
.IX Subsection "unimport"
Moose offers a way to remove the keywords it exports, through the \f(CW\*(C`unimport\*(C'\fR
method. You simply have to say \f(CW\*(C`no Moose\*(C'\fR at the bottom of your code for this
to work. Here is an example:
.PP
.Vb 2
\&    package Person;
\&    use Moose;
\&
\&    has \*(Aqfirst_name\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&    has \*(Aqlast_name\*(Aq  => (is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq);
\&
\&    sub full_name {
\&        my $self = shift;
\&        $self\->first_name . \*(Aq \*(Aq . $self\->last_name
\&    }
\&
\&    no Moose; # keywords are removed from the Person package
.Ve
.SH "EXTENDING AND EMBEDDING MOOSE"
.IX Header "EXTENDING AND EMBEDDING MOOSE"
To learn more about extending Moose, we recommend checking out the
\&\*(L"Extending\*(R" recipes in the Moose::Cookbook, starting with
Moose::Cookbook::Extending::ExtensionOverview, which provides an overview of
all the different ways you might extend Moose. Moose::Exporter and
Moose::Util::MetaRole are the modules which provide the majority of the
extension functionality, so reading their documentation should also be helpful.
.SS "The MooseX:: namespace"
.IX Subsection "The MooseX:: namespace"
Generally if you're writing an extension \fIfor\fR Moose itself you'll want
to put your extension in the \f(CW\*(C`MooseX::\*(C'\fR namespace. This namespace is
specifically for extensions that make Moose better or different in some
fundamental way. It is traditionally \fBnot\fR for a package that just happens
to use Moose. This namespace follows from the examples of the \f(CW\*(C`LWPx::\*(C'\fR
and \f(CW\*(C`DBIx::\*(C'\fR namespaces that perform the same function for \f(CW\*(C`LWP\*(C'\fR and \f(CW\*(C`DBI\*(C'\fR
respectively.
.SH "METACLASS COMPATIBILITY AND MOOSE"
.IX Header "METACLASS COMPATIBILITY AND MOOSE"
Metaclass compatibility is a thorny subject. You should start by
reading the \*(L"About Metaclass compatibility\*(R" section in the
\&\f(CW\*(C`Class::MOP\*(C'\fR docs.
.PP
Moose will attempt to resolve a few cases of metaclass incompatibility
when you set the superclasses for a class, in addition to the cases that
\&\f(CW\*(C`Class::MOP\*(C'\fR handles.
.PP
Moose tries to determine if the metaclasses only \*(L"differ by roles\*(R". This
means that the parent and child's metaclass share a common ancestor in
their respective hierarchies, and that the subclasses under the common
ancestor are only different because of role applications. This case is
actually fairly common when you mix and match various \f(CW\*(C`MooseX::*\*(C'\fR
modules, many of which apply roles to the metaclass.
.PP
If the parent and child do differ by roles, Moose replaces the
metaclass in the child with a newly created metaclass. This metaclass
is a subclass of the parent's metaclass which does all of the roles that
the child's metaclass did before being replaced. Effectively, this
means the new metaclass does all of the roles done by both the
parent's and child's original metaclasses.
.PP
Ultimately, this is all transparent to you except in the case of an
unresolvable conflict.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
It should be noted that \f(CW\*(C`super\*(C'\fR and \f(CW\*(C`inner\*(C'\fR \fBcannot\fR be used in the same
method. However, they may be combined within the same class hierarchy; see
\&\fIt/basics/override_augment_inner_super.t\fR for an example.
.Sp
The reason for this is that \f(CW\*(C`super\*(C'\fR is only valid within a method
with the \f(CW\*(C`override\*(C'\fR modifier, and \f(CW\*(C`inner\*(C'\fR will never be valid within an
\&\f(CW\*(C`override\*(C'\fR method. In fact, \f(CW\*(C`augment\*(C'\fR will skip over any \f(CW\*(C`override\*(C'\fR methods
when searching for its appropriate \f(CW\*(C`inner\*(C'\fR.
.Sp
This might seem like a restriction, but I am of the opinion that keeping these
two features separate (yet interoperable) actually makes them easy to use, since
their behavior is then easier to predict. Time will tell whether I am right or
not (\s-1UPDATE:\s0 so far so good).
.SH "GETTING HELP"
.IX Header "GETTING HELP"
We offer both a mailing list and a very active \s-1IRC\s0 channel.
.PP
The mailing list is <mailto:moose@perl.org>. You must be subscribed to send
a message. To subscribe, send an empty message to
<mailto:moose\-subscribe@perl.org>
.PP
You can also visit us at \f(CW\*(C`#moose\*(C'\fR on <irc://irc.perl.org/#moose>
This channel is quite active, and questions at all levels (on Moose-related
topics ;) are welcome.
.SH "WHAT DOES MOOSE STAND FOR?"
.IX Header "WHAT DOES MOOSE STAND FOR?"
Moose doesn't stand for one thing in particular, however, if you want, here
are a few of our favorites. Feel free to contribute more!
.IP "\(bu" 4
Make Other Object Systems Envious
.IP "\(bu" 4
Makes Object Orientation So Easy
.IP "\(bu" 4
Makes Object Orientation Spiffy\- Er (sorry ingy)
.IP "\(bu" 4
Most Other Object Systems Emasculate
.IP "\(bu" 4
Moose Often Ovulate Sorta Early
.IP "\(bu" 4
Moose Offers Often Super Extensions
.IP "\(bu" 4
Meta Object Obligates Salivary Excitation
.IP "\(bu" 4
Meta Object Orientation Syntax Extensions
.IP "\(bu" 4
Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "I blame Sam Vilain for introducing me to the insanity that is meta-models." 4
.IX Item "I blame Sam Vilain for introducing me to the insanity that is meta-models."
.PD 0
.IP "I blame Audrey Tang for then encouraging my meta-model habit in #perl6." 4
.IX Item "I blame Audrey Tang for then encouraging my meta-model habit in #perl6."
.ie n .IP "Without Yuval ""nothingmuch"" Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.el .IP "Without Yuval ``nothingmuch'' Kogman this module would not be possible, and it certainly wouldn't have this name ;P" 4
.IX Item "Without Yuval nothingmuch Kogman this module would not be possible, and it certainly wouldn't have this name ;P"
.IP "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it." 4
.IX Item "The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it."
.IP "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature\-requests/encouragement/bug\-finding." 4
.IX Item "Thanks to mst & chansen and the whole #moose posse for all the early ideas/feature-requests/encouragement/bug-finding."
.ie n .IP "Thanks to David ""Theory"" Wheeler for meta-discussions and spelling fixes." 4
.el .IP "Thanks to David ``Theory'' Wheeler for meta-discussions and spelling fixes." 4
.IX Item "Thanks to David Theory Wheeler for meta-discussions and spelling fixes."
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://moose.perl.org/>" 4
.IX Item "<http://moose.perl.org/>"
This is the official web home of Moose. It contains links to our public git
repository, as well as links to a number of talks and articles on Moose and
Moose related technologies.
.IP "the Moose manual" 4
.IX Item "the Moose manual"
This is an introduction to Moose which covers most of the basics.
.IP "Modern Perl, by chromatic" 4
.IX Item "Modern Perl, by chromatic"
This is an introduction to modern Perl programming, which includes a section on
Moose. It is available in print and as a free download from
<http://onyxneon.com/books/modern_perl/>.
.IP "The Moose is flying, a tutorial by Randal Schwartz" 4
.IX Item "The Moose is flying, a tutorial by Randal Schwartz"
Part 1 \- <http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
.Sp
Part 2 \- <http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
.ie n .IP "Several Moose extension modules in the ""MooseX::"" namespace." 4
.el .IP "Several Moose extension modules in the \f(CWMooseX::\fR namespace." 4
.IX Item "Several Moose extension modules in the MooseX:: namespace."
See <https://metacpan.org/search?q=MooseX::> for extensions.
.SS "Books"
.IX Subsection "Books"
.IP "The Art of the MetaObject Protocol" 4
.IX Item "The Art of the MetaObject Protocol"
I mention this in the Class::MOP docs too, as this book was critical in
the development of both modules and is highly recommended.
.SS "Papers"
.IX Subsection "Papers"
.IP "<http://www.cs.utah.edu/plt/publications/oopsla04\-gff.pdf>" 4
.IX Item "<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>"
This paper (suggested by lbr on #moose) was what lead to the implementation
of the \f(CW\*(C`super\*(C'\fR/\f(CW\*(C`override\*(C'\fR and \f(CW\*(C`inner\*(C'\fR/\f(CW\*(C`augment\*(C'\fR features. If you really
want to understand them, I suggest you read this.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception.
.PP
Please report any bugs to \f(CW\*(C`bug\-moose@rt.cpan.org\*(C'\fR, or through the web
interface at <http://rt.cpan.org>. You can also submit a \f(CW\*(C`TODO\*(C'\fR test as a
pull request at <https://github.com/moose/Moose>.
.PP
You can also discuss feature requests or possible bugs on the Moose mailing
list (moose@perl.org) or on \s-1IRC\s0 at <irc://irc.perl.org/#moose>.
.SH "FEATURE REQUESTS"
.IX Header "FEATURE REQUESTS"
We are very strict about what features we add to the Moose core, especially
the user-visible features. Instead we have made sure that the underlying
meta-system of Moose is as extensible as possible so that you can add your
own features easily.
.PP
That said, occasionally there is a feature needed in the meta-system
to support your planned extension, in which case you should either
email the mailing list (moose@perl.org) or join us on \s-1IRC\s0 at
<irc://irc.perl.org/#moose> to discuss. The
Moose::Manual::Contributing has more detail about how and when you
can contribute.
.SH "CABAL"
.IX Header "CABAL"
There are only a few people with the rights to release a new version
of Moose. The Moose Cabal are the people to go to with questions regarding
the wider purview of Moose. They help maintain not just the code
but the community as well. See the list below under \f(CW\*(C`AUTHORS\*(C'\fR.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Moose is a community project, and as such, involves the work of many, many
members of the community beyond just the members in the cabal. In particular:
.PP
Dave (autarch) Rolsky wrote most of the documentation in Moose::Manual.
.PP
John (jgoulah) Goulah wrote Moose::Cookbook::Snack::Keywords.
.PP
Jess (castaway) Robinson wrote Moose::Cookbook::Snack::Types.
.PP
Aran (bluefeet) Clary Deltac wrote
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion.
.PP
Anders (Debolaz) Nor Berle contributed Test::Moose and Moose::Util.
.PP
Also, the code in Moose::Meta::Attribute::Native is based on code from the
MooseX::AttributeHelpers distribution, which had contributions from:
.PP
Chris (perigrin) Prather
.PP
Cory (gphat) Watson
.PP
Evan Carroll
.PP
Florian (rafl) Ragwitz
.PP
Jason May
.PP
Jay Hannah
.PP
Jesse (doy) Luehrs
.PP
Paul (frodwith) Driver
.PP
Robert (rlb3) Boone
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Shawn (Sartak) Moore
.PP
Stevan Little
.PP
Tom (dec) Lanyon
.PP
Yuval Kogman
.PP
Finally, these people also contributed various tests, bug fixes,
documentation, and features to the Moose codebase:
.PP
Aankhen
.PP
Adam (Alias) Kennedy
.PP
Christian (chansen) Hansen
.PP
Cory (gphat) Watson
.PP
Dylan Hardison (doc fixes)
.PP
Eric (ewilhelm) Wilhelm
.PP
Evan Carroll
.PP
Guillermo (groditi) Roditi
.PP
Jason May
.PP
Jay Hannah
.PP
Jonathan (jrockway) Rockway
.PP
Matt (mst) Trout
.PP
Nathan (kolibrie) Gray
.PP
Paul (frodwith) Driver
.PP
Piotr (dexter) Roszatycki
.PP
Robert Buels
.PP
Robert (phaylon) Sedlacek
.PP
Robert (rlb3) Boone
.PP
Sam (mugwump) Vilain
.PP
Scott (konobi) McWhirter
.PP
Shlomi (rindolf) Fish
.PP
Tom (dec) Lanyon
.PP
Wallace (wreis) Reis
.PP
\&... and many other #moose folks
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox.3pm                           0100644 0001750 0001750 00000016510 12566242414 024112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox 3"
.TH Moose::Autobox 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox \- Autoboxed wrappers for Native Perl datatypes
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print \*(AqPrint squares from 1 to 10 : \*(Aq;
\&  print [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose::Autobox provides an implementation of \s-1SCALAR, ARRAY, HASH
& CODE\s0 for use with autobox. It does this using a hierarchy of 
roles in a manner similar to what Perl 6 \fImight\fR do. This module, 
like Class::MOP and Moose, was inspired by my work on the 
Perl 6 Object Space, and the 'core types' implemented there.
.SS "A quick word about autobox"
.IX Subsection "A quick word about autobox"
The autobox module provides the ability for calling 'methods' 
on normal Perl values like Scalars, Arrays, Hashes and Code 
references. This gives the illusion that Perl's types are first-class 
objects. However, this is only an illusion, albeit a very nice one.
I created this module because autobox itself does not actually 
provide an implementation for the Perl types but instead only provides 
the 'hooks' for others to add implementation too.
.SS "Is this for real? or just play?"
.IX Subsection "Is this for real? or just play?"
Several people are using this module in serious applications and 
it seems to be quite stable. The underlying technologies of autobox
and Moose::Role are also considered stable. There is some performance
hit, but as I am fond of saying, nothing in life is free.  Note that this hit
only applies to the \fIuse\fR of methods on native Perl values, not the mere act
of loading this module in your namespace.
.PP
If you have any questions regarding this module, either email me, or stop by
#moose on irc.perl.org and ask around.
.SS "Adding additional methods"
.IX Subsection "Adding additional methods"
\&\fBMoose::Autobox\fR asks autobox to use the \fBMoose::Autobox::*\fR namespace 
prefix so as to avoid stepping on the toes of other autobox modules. This 
means that if you want to add methods to a particular perl type 
(i.e. \- monkeypatch), then you must do this:
.PP
.Vb 1
\&  sub Moose::Autobox::SCALAR::bar { 42 }
.Ve
.PP
instead of this:
.PP
.Vb 1
\&  sub SCALAR::bar { 42 }
.Ve
.PP
as you would with vanilla autobox.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "\fBmixin_additional_role ($type, \fB$role\fB)\fR" 4
.el .IP "\fBmixin_additional_role ($type, \f(CB$role\fB)\fR" 4
.IX Item "mixin_additional_role ($type, $role)"
This will mixin an additional \f(CW$role\fR into a certain \f(CW$type\fR. The 
types can be \s-1SCALAR, ARRAY, HASH\s0 or \s-1CODE.\s0
.Sp
This can be used to add additional methods to the types, see the 
\&\fIexamples/units/\fR directory for some examples.
.SH "TODO"
.IX Header "TODO"
.IP "More docs" 4
.IX Item "More docs"
.PD 0
.IP "More tests" 4
.IX Item "More tests"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.PP
\&\fBwith contributions from:\fR
.PP
Anders (Debolaz) Nor Berle
.PP
Matt (mst) Trout
.PP
renormalist
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox5.16.3pm                       0100644 0001750 0001750 00000016231 12566242377 024434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox 3"
.TH Moose::Autobox 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox \- Autoboxed wrappers for Native Perl datatypes
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print \*(AqPrint squares from 1 to 10 : \*(Aq;
\&  print [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose::Autobox provides an implementation of \s-1SCALAR\s0, \s-1ARRAY\s0, \s-1HASH\s0
& \s-1CODE\s0 for use with autobox. It does this using a hierarchy of 
roles in a manner similar to what Perl 6 \fImight\fR do. This module, 
like Class::MOP and Moose, was inspired by my work on the 
Perl 6 Object Space, and the 'core types' implemented there.
.SS "A quick word about autobox"
.IX Subsection "A quick word about autobox"
The autobox module provides the ability for calling 'methods' 
on normal Perl values like Scalars, Arrays, Hashes and Code 
references. This gives the illusion that Perl's types are first-class 
objects. However, this is only an illusion, albeit a very nice one.
I created this module because autobox itself does not actually 
provide an implementation for the Perl types but instead only provides 
the 'hooks' for others to add implementation too.
.SS "Is this for real? or just play?"
.IX Subsection "Is this for real? or just play?"
Several people are using this module in serious applications and 
it seems to be quite stable. The underlying technologies of autobox
and Moose::Role are also considered stable. There is some performance
hit, but as I am fond of saying, nothing in life is free.  Note that this hit
only applies to the \fIuse\fR of methods on native Perl values, not the mere act
of loading this module in your namespace.
.PP
If you have any questions regarding this module, either email me, or stop by
#moose on irc.perl.org and ask around.
.SS "Adding additional methods"
.IX Subsection "Adding additional methods"
\&\fBMoose::Autobox\fR asks autobox to use the \fBMoose::Autobox::*\fR namespace 
prefix so as to avoid stepping on the toes of other autobox modules. This 
means that if you want to add methods to a particular perl type 
(i.e. \- monkeypatch), then you must do this:
.PP
.Vb 1
\&  sub Moose::Autobox::SCALAR::bar { 42 }
.Ve
.PP
instead of this:
.PP
.Vb 1
\&  sub SCALAR::bar { 42 }
.Ve
.PP
as you would with vanilla autobox.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "\fBmixin_additional_role ($type, \fB$role\fB)\fR" 4
.el .IP "\fBmixin_additional_role ($type, \f(CB$role\fB)\fR" 4
.IX Item "mixin_additional_role ($type, $role)"
This will mixin an additonal \f(CW$role\fR into a certain \f(CW$type\fR. The 
types can be \s-1SCALAR\s0, \s-1ARRAY\s0, \s-1HASH\s0 or \s-1CODE\s0.
.Sp
This can be used to add additional methods to the types, see the 
\&\fIexamples/units/\fR directory for some examples.
.SH "TODO"
.IX Header "TODO"
.IP "More docs" 4
.IX Item "More docs"
.PD 0
.IP "More tests" 4
.IX Item "More tests"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.PP
\&\fBwith contributions from:\fR
.PP
Anders (Debolaz) Nor Berle
.PP
Matt (mst) Trout
.PP
renormalist
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox5.18.3pm                       0100644 0001750 0001750 00000016510 12566242414 024426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox 3"
.TH Moose::Autobox 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox \- Autoboxed wrappers for Native Perl datatypes
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print \*(AqPrint squares from 1 to 10 : \*(Aq;
\&  print [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose::Autobox provides an implementation of \s-1SCALAR, ARRAY, HASH
& CODE\s0 for use with autobox. It does this using a hierarchy of 
roles in a manner similar to what Perl 6 \fImight\fR do. This module, 
like Class::MOP and Moose, was inspired by my work on the 
Perl 6 Object Space, and the 'core types' implemented there.
.SS "A quick word about autobox"
.IX Subsection "A quick word about autobox"
The autobox module provides the ability for calling 'methods' 
on normal Perl values like Scalars, Arrays, Hashes and Code 
references. This gives the illusion that Perl's types are first-class 
objects. However, this is only an illusion, albeit a very nice one.
I created this module because autobox itself does not actually 
provide an implementation for the Perl types but instead only provides 
the 'hooks' for others to add implementation too.
.SS "Is this for real? or just play?"
.IX Subsection "Is this for real? or just play?"
Several people are using this module in serious applications and 
it seems to be quite stable. The underlying technologies of autobox
and Moose::Role are also considered stable. There is some performance
hit, but as I am fond of saying, nothing in life is free.  Note that this hit
only applies to the \fIuse\fR of methods on native Perl values, not the mere act
of loading this module in your namespace.
.PP
If you have any questions regarding this module, either email me, or stop by
#moose on irc.perl.org and ask around.
.SS "Adding additional methods"
.IX Subsection "Adding additional methods"
\&\fBMoose::Autobox\fR asks autobox to use the \fBMoose::Autobox::*\fR namespace 
prefix so as to avoid stepping on the toes of other autobox modules. This 
means that if you want to add methods to a particular perl type 
(i.e. \- monkeypatch), then you must do this:
.PP
.Vb 1
\&  sub Moose::Autobox::SCALAR::bar { 42 }
.Ve
.PP
instead of this:
.PP
.Vb 1
\&  sub SCALAR::bar { 42 }
.Ve
.PP
as you would with vanilla autobox.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "\fBmixin_additional_role ($type, \fB$role\fB)\fR" 4
.el .IP "\fBmixin_additional_role ($type, \f(CB$role\fB)\fR" 4
.IX Item "mixin_additional_role ($type, $role)"
This will mixin an additional \f(CW$role\fR into a certain \f(CW$type\fR. The 
types can be \s-1SCALAR, ARRAY, HASH\s0 or \s-1CODE.\s0
.Sp
This can be used to add additional methods to the types, see the 
\&\fIexamples/units/\fR directory for some examples.
.SH "TODO"
.IX Header "TODO"
.IP "More docs" 4
.IX Item "More docs"
.PD 0
.IP "More tests" 4
.IX Item "More tests"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.PP
\&\fBwith contributions from:\fR
.PP
Anders (Debolaz) Nor Berle
.PP
Matt (mst) Trout
.PP
renormalist
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Array.3pm                    0100644 0001750 0001750 00000017061 12566242414 025277  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Array 3"
.TH Moose::Autobox::Array 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Array \- the Array role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&    
\&  [ 1..5 ]\->isa(\*(AqARRAY\*(Aq); # true
\&  [ a..z ]\->does(\*(AqMoose::Autobox::Array\*(Aq); # true
\&  [ 0..2 ]\->does(\*(AqMoose::Autobox::List\*(Aq); # true  
\&    
\&  print "Squares: " . [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
\&  
\&  print [ 1, \*(Aqnumber\*(Aq ]\->sprintf(\*(Aq%d is the loneliest %s\*(Aq);
\&  
\&  print ([ 1 .. 5 ]\->any == 3) ? \*(Aqtrue\*(Aq : \*(Aqfalse\*(Aq; # prints \*(Aqtrue\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Array type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBpop\fR" 4
.IX Item "pop"
.PD 0
.IP "\fBpush ($value)\fR" 4
.IX Item "push ($value)"
.IP "\fBshift\fR" 4
.IX Item "shift"
.IP "\fBunshift ($value)\fR" 4
.IX Item "unshift ($value)"
.IP "\fBdelete ($index)\fR" 4
.IX Item "delete ($index)"
.IP "\fBsprintf ($format_string)\fR" 4
.IX Item "sprintf ($format_string)"
.IP "\fBslice (@indices)\fR" 4
.IX Item "slice (@indices)"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.IP "\fBflatten_deep ($depth)\fR" 4
.IX Item "flatten_deep ($depth)"
.IP "\fBfirst\fR" 4
.IX Item "first"
.IP "\fBlast\fR" 4
.IX Item "last"
.PD
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.IP "\fBat ($index)\fR" 4
.IX Item "at ($index)"
.PD 0
.ie n .IP "\fBput ($index, \fB$value\fB)\fR" 4
.el .IP "\fBput ($index, \f(CB$value\fB)\fR" 4
.IX Item "put ($index, $value)"
.IP "\fBexists ($index)\fR" 4
.IX Item "exists ($index)"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.ie n .IP "\fBeach_n_values ($n, \fB$callback\fB)\fR" 4
.el .IP "\fBeach_n_values ($n, \f(CB$callback\fB)\fR" 4
.IX Item "each_n_values ($n, $callback)"
.PD
.SS "List implementation"
.IX Subsection "List implementation"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin (?$seperator)\fR" 4
.IX Item "join (?$seperator)"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap (\e&block)\fR" 4
.IX Item "map (&block)"
.IP "\fBgrep (\e&block)\fR" 4
.IX Item "grep (&block)"
.PD
Note that, in both the above, \f(CW$_\fR is in scope within the code block, as well as 
being passed as \f(CW$_\fR[0]. As per CORE::map and CORE::grep, \f(CW$_\fR is an alias to 
the list value, so can be used to modify the list, viz:
.Sp
.Vb 1
\&    use Moose::Autobox;
\&
\&    my $foo = [1, 2, 3]; 
\&    $foo\->map( sub {$_++} ); 
\&    print $foo\->dump;
.Ve
.Sp
yields
.Sp
.Vb 5
\&   $VAR1 = [
\&             2,
\&             3,
\&             4
\&           ];
.Ve
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.PD 0
.IP "\fBsort (?\e&block)\fR" 4
.IX Item "sort (?&block)"
.PD
.SS "Junctions"
.IX Subsection "Junctions"
.IP "\fBall\fR" 4
.IX Item "all"
.PD 0
.IP "\fBany\fR" 4
.IX Item "any"
.IP "\fBnone\fR" 4
.IX Item "none"
.IP "\fBone\fR" 4
.IX Item "one"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Array5.16.3pm                0100644 0001750 0001750 00000016543 12566242377 025625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Array 3"
.TH Moose::Autobox::Array 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Array \- the Array role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&    
\&  [ 1..5 ]\->isa(\*(AqARRAY\*(Aq); # true
\&  [ a..z ]\->does(\*(AqMoose::Autobox::Array\*(Aq); # true
\&  [ 0..2 ]\->does(\*(AqMoose::Autobox::List\*(Aq); # true  
\&    
\&  print "Squares: " . [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
\&  
\&  print [ 1, \*(Aqnumber\*(Aq ]\->sprintf(\*(Aq%d is the loneliest %s\*(Aq);
\&  
\&  print ([ 1 .. 5 ]\->any == 3) ? \*(Aqtrue\*(Aq : \*(Aqfalse\*(Aq; # prints \*(Aqtrue\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Array type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBpop\fR" 4
.IX Item "pop"
.PD 0
.IP "\fBpush ($value)\fR" 4
.IX Item "push ($value)"
.IP "\fBshift\fR" 4
.IX Item "shift"
.IP "\fBunshift ($value)\fR" 4
.IX Item "unshift ($value)"
.IP "\fBdelete ($index)\fR" 4
.IX Item "delete ($index)"
.IP "\fBsprintf ($format_string)\fR" 4
.IX Item "sprintf ($format_string)"
.IP "\fBslice (@indices)\fR" 4
.IX Item "slice (@indices)"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.IP "\fBflatten_deep ($depth)\fR" 4
.IX Item "flatten_deep ($depth)"
.IP "\fBfirst\fR" 4
.IX Item "first"
.IP "\fBlast\fR" 4
.IX Item "last"
.PD
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.IP "\fBat ($index)\fR" 4
.IX Item "at ($index)"
.PD 0
.ie n .IP "\fBput ($index, \fB$value\fB)\fR" 4
.el .IP "\fBput ($index, \f(CB$value\fB)\fR" 4
.IX Item "put ($index, $value)"
.IP "\fBexists ($index)\fR" 4
.IX Item "exists ($index)"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.ie n .IP "\fBeach_n_values ($n, \fB$callback\fB)\fR" 4
.el .IP "\fBeach_n_values ($n, \f(CB$callback\fB)\fR" 4
.IX Item "each_n_values ($n, $callback)"
.PD
.SS "List implementation"
.IX Subsection "List implementation"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin (?$seperator)\fR" 4
.IX Item "join (?$seperator)"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap (\e&block)\fR" 4
.IX Item "map (&block)"
.IP "\fBgrep (\e&block)\fR" 4
.IX Item "grep (&block)"
.PD
Note that, in both the above, \f(CW$_\fR is in scope within the code block, as well as 
being passed as \f(CW$_\fR[0]. As per CORE::map and CORE::grep, \f(CW$_\fR is an alias to 
the list value, so can be used to to modify the list, viz:
.Sp
.Vb 1
\&    use Moose::Autobox;
\&
\&    my $foo = [1, 2, 3]; 
\&    $foo\->map( sub {$_++} ); 
\&    print $foo\->dump;
.Ve
.Sp
yields
.Sp
.Vb 5
\&   $VAR1 = [
\&             2,
\&             3,
\&             4
\&           ];
.Ve
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.PD 0
.IP "\fBsort (?\e&block)\fR" 4
.IX Item "sort (?&block)"
.PD
.SS "Junctions"
.IX Subsection "Junctions"
.IP "\fBall\fR" 4
.IX Item "all"
.PD 0
.IP "\fBany\fR" 4
.IX Item "any"
.IP "\fBnone\fR" 4
.IX Item "none"
.IP "\fBone\fR" 4
.IX Item "one"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Array5.18.3pm                0100644 0001750 0001750 00000017061 12566242414 025613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Array 3"
.TH Moose::Autobox::Array 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Array \- the Array role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&    
\&  [ 1..5 ]\->isa(\*(AqARRAY\*(Aq); # true
\&  [ a..z ]\->does(\*(AqMoose::Autobox::Array\*(Aq); # true
\&  [ 0..2 ]\->does(\*(AqMoose::Autobox::List\*(Aq); # true  
\&    
\&  print "Squares: " . [ 1 .. 10 ]\->map(sub { $_ * $_ })\->join(\*(Aq, \*(Aq);
\&  
\&  print [ 1, \*(Aqnumber\*(Aq ]\->sprintf(\*(Aq%d is the loneliest %s\*(Aq);
\&  
\&  print ([ 1 .. 5 ]\->any == 3) ? \*(Aqtrue\*(Aq : \*(Aqfalse\*(Aq; # prints \*(Aqtrue\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Array type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBpop\fR" 4
.IX Item "pop"
.PD 0
.IP "\fBpush ($value)\fR" 4
.IX Item "push ($value)"
.IP "\fBshift\fR" 4
.IX Item "shift"
.IP "\fBunshift ($value)\fR" 4
.IX Item "unshift ($value)"
.IP "\fBdelete ($index)\fR" 4
.IX Item "delete ($index)"
.IP "\fBsprintf ($format_string)\fR" 4
.IX Item "sprintf ($format_string)"
.IP "\fBslice (@indices)\fR" 4
.IX Item "slice (@indices)"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.IP "\fBflatten_deep ($depth)\fR" 4
.IX Item "flatten_deep ($depth)"
.IP "\fBfirst\fR" 4
.IX Item "first"
.IP "\fBlast\fR" 4
.IX Item "last"
.PD
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.IP "\fBat ($index)\fR" 4
.IX Item "at ($index)"
.PD 0
.ie n .IP "\fBput ($index, \fB$value\fB)\fR" 4
.el .IP "\fBput ($index, \f(CB$value\fB)\fR" 4
.IX Item "put ($index, $value)"
.IP "\fBexists ($index)\fR" 4
.IX Item "exists ($index)"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.ie n .IP "\fBeach_n_values ($n, \fB$callback\fB)\fR" 4
.el .IP "\fBeach_n_values ($n, \f(CB$callback\fB)\fR" 4
.IX Item "each_n_values ($n, $callback)"
.PD
.SS "List implementation"
.IX Subsection "List implementation"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin (?$seperator)\fR" 4
.IX Item "join (?$seperator)"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap (\e&block)\fR" 4
.IX Item "map (&block)"
.IP "\fBgrep (\e&block)\fR" 4
.IX Item "grep (&block)"
.PD
Note that, in both the above, \f(CW$_\fR is in scope within the code block, as well as 
being passed as \f(CW$_\fR[0]. As per CORE::map and CORE::grep, \f(CW$_\fR is an alias to 
the list value, so can be used to modify the list, viz:
.Sp
.Vb 1
\&    use Moose::Autobox;
\&
\&    my $foo = [1, 2, 3]; 
\&    $foo\->map( sub {$_++} ); 
\&    print $foo\->dump;
.Ve
.Sp
yields
.Sp
.Vb 5
\&   $VAR1 = [
\&             2,
\&             3,
\&             4
\&           ];
.Ve
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.PD 0
.IP "\fBsort (?\e&block)\fR" 4
.IX Item "sort (?&block)"
.PD
.SS "Junctions"
.IX Subsection "Junctions"
.IP "\fBall\fR" 4
.IX Item "all"
.PD 0
.IP "\fBany\fR" 4
.IX Item "any"
.IP "\fBnone\fR" 4
.IX Item "none"
.IP "\fBone\fR" 4
.IX Item "one"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Code.3pm                     0100644 0001750 0001750 00000013765 12566242414 025102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Code 3"
.TH Moose::Autobox::Code 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Code \- the Code role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $adder = sub { $_[0] + $_[1] };
\&  my $add_2 = $adder\->curry(2);
\&  
\&  $add_2\->(2); # returns 4
\&  
\&  # create a recursive subroutine 
\&  # using the Y combinator
\&  *factorial = sub {
\&      my $f = shift;
\&      sub {
\&          my $n = shift;
\&          return 1 if $n < 2;
\&          return $n * $f\->($n \- 1);
\&      }
\&  }\->y;
\&  
\&  factorial(10) # returns 3628800
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Code type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBcurry (@values)\fR" 4
.IX Item "curry (@values)"
.PD 0
.IP "\fBrcurry (@values)\fR" 4
.IX Item "rcurry (@values)"
.IP "\fBconjoin (\e&sub)\fR" 4
.IX Item "conjoin (&sub)"
.IP "\fBdisjoin (\e&sub)\fR" 4
.IX Item "disjoin (&sub)"
.IP "\fBcompose (@subs)\fR" 4
.IX Item "compose (@subs)"
.PD
This will take a list of \f(CW@subs\fR and compose them all into a single 
subroutine where the output of one sub will be the input of another.
.IP "\fBy\fR" 4
.IX Item "y"
This implements the Y combinator.
.IP "\fBu\fR" 4
.IX Item "u"
This implements the U combinator.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "<http://en.wikipedia.org/wiki/Fixed_point_combinator>" 4
.IX Item "<http://en.wikipedia.org/wiki/Fixed_point_combinator>"
.IP "<http://blade.nagaokaut.ac.jp/cgi\-bin/scat.rb/ruby/ruby\-talk/20469>" 4
.IX Item "<http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/20469>"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Code5.16.3pm                 0100644 0001750 0001750 00000013650 12566242377 025415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Code 3"
.TH Moose::Autobox::Code 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Code \- the Code role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $adder = sub { $_[0] + $_[1] };
\&  my $add_2 = $adder\->curry(2);
\&  
\&  $add_2\->(2); # returns 4
\&  
\&  # create a recursive subroutine 
\&  # using the Y combinator
\&  *factorial = sub {
\&      my $f = shift;
\&      sub {
\&          my $n = shift;
\&          return 1 if $n < 2;
\&          return $n * $f\->($n \- 1);
\&      }
\&  }\->y;
\&  
\&  factorial(10) # returns 3628800
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Code type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBcurry (@values)\fR" 4
.IX Item "curry (@values)"
.PD 0
.IP "\fBrcurry (@values)\fR" 4
.IX Item "rcurry (@values)"
.IP "\fBconjoin (\e&sub)\fR" 4
.IX Item "conjoin (&sub)"
.IP "\fBdisjoin (\e&sub)\fR" 4
.IX Item "disjoin (&sub)"
.IP "\fBcompose (@subs)\fR" 4
.IX Item "compose (@subs)"
.PD
This will take a list of \f(CW@subs\fR and compose them all into a single 
subroutine where the output of one sub will be the input of another.
.IP "\fBy\fR" 4
.IX Item "y"
This implements the Y combinator.
.IP "\fBu\fR" 4
.IX Item "u"
This implements the U combinator.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "<http://en.wikipedia.org/wiki/Fixed_point_combinator>" 4
.IX Item "<http://en.wikipedia.org/wiki/Fixed_point_combinator>"
.IP "http://blade.nagaokaut.ac.jp/cgi\-bin/scat.rb/ruby/ruby\-talk/20469 <http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/20469>" 4
.IX Item "http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/20469 <http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/20469>"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Code5.18.3pm                 0100644 0001750 0001750 00000013765 12566242414 025416  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Code 3"
.TH Moose::Autobox::Code 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Code \- the Code role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $adder = sub { $_[0] + $_[1] };
\&  my $add_2 = $adder\->curry(2);
\&  
\&  $add_2\->(2); # returns 4
\&  
\&  # create a recursive subroutine 
\&  # using the Y combinator
\&  *factorial = sub {
\&      my $f = shift;
\&      sub {
\&          my $n = shift;
\&          return 1 if $n < 2;
\&          return $n * $f\->($n \- 1);
\&      }
\&  }\->y;
\&  
\&  factorial(10) # returns 3628800
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describe operations on the Code type.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBcurry (@values)\fR" 4
.IX Item "curry (@values)"
.PD 0
.IP "\fBrcurry (@values)\fR" 4
.IX Item "rcurry (@values)"
.IP "\fBconjoin (\e&sub)\fR" 4
.IX Item "conjoin (&sub)"
.IP "\fBdisjoin (\e&sub)\fR" 4
.IX Item "disjoin (&sub)"
.IP "\fBcompose (@subs)\fR" 4
.IX Item "compose (@subs)"
.PD
This will take a list of \f(CW@subs\fR and compose them all into a single 
subroutine where the output of one sub will be the input of another.
.IP "\fBy\fR" 4
.IX Item "y"
This implements the Y combinator.
.IP "\fBu\fR" 4
.IX Item "u"
This implements the U combinator.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.PD 0
.IP "<http://en.wikipedia.org/wiki/Fixed_point_combinator>" 4
.IX Item "<http://en.wikipedia.org/wiki/Fixed_point_combinator>"
.IP "<http://blade.nagaokaut.ac.jp/cgi\-bin/scat.rb/ruby/ruby\-talk/20469>" 4
.IX Item "<http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/20469>"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Defined.3pm                  0100644 0001750 0001750 00000011546 12566242414 025561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Defined 3"
.TH Moose::Autobox::Defined 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Defined \- the Defined role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $x;
\&  $x\->defined; # false
\&  
\&  $x = 10;
\&  $x\->defined; # true
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Defined5.16.3pm              0100644 0001750 0001750 00000011225 12566242377 026075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Defined 3"
.TH Moose::Autobox::Defined 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Defined \- the Defined role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $x;
\&  $x\->defined; # false
\&  
\&  $x = 10;
\&  $x\->defined; # true
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Defined5.18.3pm              0100644 0001750 0001750 00000011546 12566242414 026075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Defined 3"
.TH Moose::Autobox::Defined 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Defined \- the Defined role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  my $x;
\&  $x\->defined; # false
\&  
\&  $x = 10;
\&  $x\->defined; # true
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Hash.3pm                     0100644 0001750 0001750 00000013241 12566242414 025100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Hash 3"
.TH Moose::Autobox::Hash 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Hash \- the Hash role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print { one => 1, two => 2 }\->keys\->join(\*(Aq, \*(Aq); # prints \*(Aqone, two\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Hash value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdelete\fR" 4
.IX Item "delete"
.PD 0
.IP "\fBmerge\fR" 4
.IX Item "merge"
.PD
Takes a hashref and returns a new hashref with right precedence
shallow merging.
.IP "\fBhslice\fR" 4
.IX Item "hslice"
Slices a hash but returns the keys and values as a new hashref.
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.IP "\fBeach_n_values\fR" 4
.IX Item "each_n_values"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Hash5.16.3pm                 0100644 0001750 0001750 00000012720 12566242377 025423  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Hash 3"
.TH Moose::Autobox::Hash 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Hash \- the Hash role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print { one => 1, two => 2 }\->keys\->join(\*(Aq, \*(Aq); # prints \*(Aqone, two\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Hash value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdelete\fR" 4
.IX Item "delete"
.PD 0
.IP "\fBmerge\fR" 4
.IX Item "merge"
.PD
Takes a hashref and returns a new hashref with right precedence
shallow merging.
.IP "\fBhslice\fR" 4
.IX Item "hslice"
Slices a hash but returns the keys and values as a new hashref.
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.IP "\fBeach_n_values\fR" 4
.IX Item "each_n_values"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Hash5.18.3pm                 0100644 0001750 0001750 00000013241 12566242414 025414  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Hash 3"
.TH Moose::Autobox::Hash 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Hash \- the Hash role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  print { one => 1, two => 2 }\->keys\->join(\*(Aq, \*(Aq); # prints \*(Aqone, two\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Hash value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdelete\fR" 4
.IX Item "delete"
.PD 0
.IP "\fBmerge\fR" 4
.IX Item "merge"
.PD
Takes a hashref and returns a new hashref with right precedence
shallow merging.
.IP "\fBhslice\fR" 4
.IX Item "hslice"
Slices a hash but returns the keys and values as a new hashref.
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.SS "Indexed implementation"
.IX Subsection "Indexed implementation"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.IP "\fBeach_n_values\fR" 4
.IX Item "each_n_values"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Indexed.3pm                  0100644 0001750 0001750 00000012446 12566242414 025603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Indexed 3"
.TH Moose::Autobox::Indexed 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Indexed \- the Indexed role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes an collection whose values can be 
accessed by a key of some kind.
.PP
The role is entirely abstract, those which implement it must 
supply all it's methods. Currently both Moose::Autobox::Array
and Moose::Autobox::Hash implement this role.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Indexed5.16.3pm              0100644 0001750 0001750 00000012125 12566242377 026117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Indexed 3"
.TH Moose::Autobox::Indexed 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Indexed \- the Indexed role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes an collection whose values can be 
accessed by a key of some kind.
.PP
The role is entirely abstract, those which implement it must 
supply all it's methods. Currently both Moose::Autobox::Array
and Moose::Autobox::Hash implement this role.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Indexed5.18.3pm              0100644 0001750 0001750 00000012446 12566242414 026117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Indexed 3"
.TH Moose::Autobox::Indexed 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Indexed \- the Indexed role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes an collection whose values can be 
accessed by a key of some kind.
.PP
The role is entirely abstract, those which implement it must 
supply all it's methods. Currently both Moose::Autobox::Array
and Moose::Autobox::Hash implement this role.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBat\fR" 4
.IX Item "at"
.IP "\fBput\fR" 4
.IX Item "put"
.IP "\fBexists\fR" 4
.IX Item "exists"
.IP "\fBkeys\fR" 4
.IX Item "keys"
.IP "\fBvalues\fR" 4
.IX Item "values"
.IP "\fBkv\fR" 4
.IX Item "kv"
.IP "\fBslice\fR" 4
.IX Item "slice"
.IP "\fBeach\fR" 4
.IX Item "each"
.IP "\fBeach_key\fR" 4
.IX Item "each_key"
.IP "\fBeach_value\fR" 4
.IX Item "each_value"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Item.3pm                     0100644 0001750 0001750 00000011731 12566242414 025115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Item 3"
.TH Moose::Autobox::Item 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Item \- the Item role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the root of our role hierarchy.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdump\fR" 4
.IX Item "dump"
.PD
Calls Data::Dumper::Dumper.
.IP "\fBperl\fR" 4
.IX Item "perl"
Same as \fBdump\fR. For symmetry with Perl6's .perl method.
.Sp
Like &print with newline.
.IP "\fBprint2\fR" 4
.IX Item "print2"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Item5.16.3pm                 0100644 0001750 0001750 00000011410 12566242377 025431  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Item 3"
.TH Moose::Autobox::Item 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Item \- the Item role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the root of our role hierarchy.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdump\fR" 4
.IX Item "dump"
.PD
Calls Data::Dumper::Dumper.
.IP "\fBperl\fR" 4
.IX Item "perl"
Same as \fBdump\fR. For symmetry with Perl6's .perl method.
.Sp
Like &print with newline.
.IP "\fBprint2\fR" 4
.IX Item "print2"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Item5.18.3pm                 0100644 0001750 0001750 00000011731 12566242414 025431  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Item 3"
.TH Moose::Autobox::Item 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Item \- the Item role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the root of our role hierarchy.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdump\fR" 4
.IX Item "dump"
.PD
Calls Data::Dumper::Dumper.
.IP "\fBperl\fR" 4
.IX Item "perl"
Same as \fBdump\fR. For symmetry with Perl6's .perl method.
.Sp
Like &print with newline.
.IP "\fBprint2\fR" 4
.IX Item "print2"
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.PD 0
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::List.3pm                     0100644 0001750 0001750 00000012344 12566242414 025133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::List 3"
.TH Moose::Autobox::List 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::List \- the List role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a List interface. This is not 
meant to be any specific Perl type, but instead an interface
that certain Perl types might implement. Currenly only 
Moose::Autobox::Array implements this.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBreduce\fR" 4
.IX Item "reduce"
.PD 0
.IP "\fBzip\fR" 4
.IX Item "zip"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin\fR" 4
.IX Item "join"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap\fR" 4
.IX Item "map"
.IP "\fBgrep\fR" 4
.IX Item "grep"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBsort\fR" 4
.IX Item "sort"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::List5.16.3pm                 0100644 0001750 0001750 00000012023 12566242377 025447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::List 3"
.TH Moose::Autobox::List 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::List \- the List role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a List interface. This is not 
meant to be any specific Perl type, but instead an interface
that certain Perl types might implement. Currenly only 
Moose::Autobox::Array implements this.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBreduce\fR" 4
.IX Item "reduce"
.PD 0
.IP "\fBzip\fR" 4
.IX Item "zip"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin\fR" 4
.IX Item "join"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap\fR" 4
.IX Item "map"
.IP "\fBgrep\fR" 4
.IX Item "grep"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBsort\fR" 4
.IX Item "sort"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::List5.18.3pm                 0100644 0001750 0001750 00000012344 12566242414 025447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::List 3"
.TH Moose::Autobox::List 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::List \- the List role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a List interface. This is not 
meant to be any specific Perl type, but instead an interface
that certain Perl types might implement. Currenly only 
Moose::Autobox::Array implements this.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBreduce\fR" 4
.IX Item "reduce"
.PD 0
.IP "\fBzip\fR" 4
.IX Item "zip"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "REQUIRED METHODS"
.IX Header "REQUIRED METHODS"
.IP "\fBhead\fR" 4
.IX Item "head"
.PD 0
.IP "\fBtail\fR" 4
.IX Item "tail"
.IP "\fBjoin\fR" 4
.IX Item "join"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBmap\fR" 4
.IX Item "map"
.IP "\fBgrep\fR" 4
.IX Item "grep"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBsort\fR" 4
.IX Item "sort"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Number.3pm                   0100644 0001750 0001750 00000012002 12566242414 025437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Number 3"
.TH Moose::Autobox::Number 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Number \- the Number role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Numeric value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBto\fR" 4
.IX Item "to"
Takes another number as argument and produces an array ranging from
the number the method is called on to the number given as argument. In
some situations, this method intentionally behaves different from the
range operator in perl:
.Sp
.Vb 1
\&  $foo = [ 5 .. 1 ]; # $foo is []
\&
\&  $foo = 5\->to(1);   # $foo is [ 5, 4, 3, 2, 1 ]
.Ve
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Number5.16.3pm               0100644 0001750 0001750 00000011461 12566242377 025771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Number 3"
.TH Moose::Autobox::Number 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Number \- the Number role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Numeric value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBto\fR" 4
.IX Item "to"
Takes another number as argument and produces an array ranging from
the number the method is called on to the number given as argument. In
some situations, this method intentionally behaves different from the
range operator in perl:
.Sp
.Vb 1
\&  $foo = [ 5 .. 1 ]; # $foo is []
\&
\&  $foo = 5\->to(1);   # $foo is [ 5, 4, 3, 2, 1 ]
.Ve
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Number5.18.3pm               0100644 0001750 0001750 00000012002 12566242414 025753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Number 3"
.TH Moose::Autobox::Number 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Number \- the Number role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Numeric value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBto\fR" 4
.IX Item "to"
Takes another number as argument and produces an array ranging from
the number the method is called on to the number given as argument. In
some situations, this method intentionally behaves different from the
range operator in perl:
.Sp
.Vb 1
\&  $foo = [ 5 .. 1 ]; # $foo is []
\&
\&  $foo = 5\->to(1);   # $foo is [ 5, 4, 3, 2, 1 ]
.Ve
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Ref.3pm                      0100644 0001750 0001750 00000011207 12566242414 024731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Ref 3"
.TH Moose::Autobox::Ref 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Ref \- the Ref role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a reference value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Ref5.16.3pm                  0100644 0001750 0001750 00000010666 12566242377 025263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Ref 3"
.TH Moose::Autobox::Ref 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Ref \- the Ref role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a reference value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Ref5.18.3pm                  0100644 0001750 0001750 00000011207 12566242414 025245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Ref 3"
.TH Moose::Autobox::Ref 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Ref \- the Ref role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a reference value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Scalar.3pm                   0100644 0001750 0001750 00000012234 12566242414 025423  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Scalar 3"
.TH Moose::Autobox::Scalar 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Scalar \- the Scalar role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Scalar value, which is defined 
as the combination (union sort of) of a String and a Number.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.PD
Flattening a scalar just returns the scalar.  This means that you can say:
.Sp
.Vb 1
\&  my @array = $input\->flatten;
\&
\&  # Given $input of 5, @array is (5);
\&  # Given $input of [ 5, 2, 0], @array is (5, 2, 0)
.Ve
.IP "\fBfirst\fR" 4
.IX Item "first"
As per flatten.
.IP "\fBlast\fR" 4
.IX Item "last"
As per flatten.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Scalar5.16.3pm               0100644 0001750 0001750 00000011713 12566242377 025746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Scalar 3"
.TH Moose::Autobox::Scalar 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Scalar \- the Scalar role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Scalar value, which is defined 
as the combination (union sort of) of a String and a Number.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.PD
Flattening a scalar just returns the scalar.  This means that you can say:
.Sp
.Vb 1
\&  my @array = $input\->flatten;
\&
\&  # Given $input of 5, @array is (5);
\&  # Given $input of [ 5, 2, 0], @array is (5, 2, 0)
.Ve
.IP "\fBfirst\fR" 4
.IX Item "first"
As per flatten.
.IP "\fBlast\fR" 4
.IX Item "last"
As per flatten.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Scalar5.18.3pm               0100644 0001750 0001750 00000012234 12566242414 025737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Scalar 3"
.TH Moose::Autobox::Scalar 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Scalar \- the Scalar role
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a Scalar value, which is defined 
as the combination (union sort of) of a String and a Number.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBprint\fR" 4
.IX Item "print"
.IP "\fBsay\fR" 4
.IX Item "say"
.IP "\fBflatten\fR" 4
.IX Item "flatten"
.PD
Flattening a scalar just returns the scalar.  This means that you can say:
.Sp
.Vb 1
\&  my @array = $input\->flatten;
\&
\&  # Given $input of 5, @array is (5);
\&  # Given $input of [ 5, 2, 0], @array is (5, 2, 0)
.Ve
.IP "\fBfirst\fR" 4
.IX Item "first"
As per flatten.
.IP "\fBlast\fR" 4
.IX Item "last"
As per flatten.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::String.3pm                   0100644 0001750 0001750 00000012561 12566242414 025467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::String 3"
.TH Moose::Autobox::String 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::String \- the String role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  "Hello World"\->uc; # HELLO WORLD
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a String value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBchomp\fR" 4
.IX Item "chomp"
.PD 0
.IP "\fBchop\fR" 4
.IX Item "chop"
.IP "\fBindex\fR" 4
.IX Item "index"
.IP "\fBlc\fR" 4
.IX Item "lc"
.IP "\fBlcfirst\fR" 4
.IX Item "lcfirst"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBrindex\fR" 4
.IX Item "rindex"
.IP "\fBuc\fR" 4
.IX Item "uc"
.IP "\fBucfirst\fR" 4
.IX Item "ucfirst"
.IP "\fBsplit\fR" 4
.IX Item "split"
.PD
.Vb 1
\&  $string\->split($pattern);
.Ve
.IP "\fBwords\fR" 4
.IX Item "words"
This is equivalent to splitting on space.
.IP "\fBlines\fR" 4
.IX Item "lines"
This is equivalent to splitting on newlines.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::String5.16.3pm               0100644 0001750 0001750 00000012241 12566242377 026004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::String 3"
.TH Moose::Autobox::String 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::String \- the String role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  "Hello World"\->uc; # HELLO WORLD
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a String value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBchomp\fR" 4
.IX Item "chomp"
.PD 0
.IP "\fBchop\fR" 4
.IX Item "chop"
.IP "\fBindex\fR" 4
.IX Item "index"
.IP "\fBlc\fR" 4
.IX Item "lc"
.IP "\fBlcfirst\fR" 4
.IX Item "lcfirst"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBrindex\fR" 4
.IX Item "rindex"
.IP "\fBuc\fR" 4
.IX Item "uc"
.IP "\fBucfirst\fR" 4
.IX Item "ucfirst"
.IP "\fBsplit\fR" 4
.IX Item "split"
.PD
.Vb 1
\&  $string\->split($pattern);
.Ve
.IP "\fBwords\fR" 4
.IX Item "words"
This is equivalent to splitting on space.
.IP "\fBlines\fR" 4
.IX Item "lines"
This is equivalent to splitting on linelines.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::String5.18.3pm               0100644 0001750 0001750 00000012561 12566242414 026003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::String 3"
.TH Moose::Autobox::String 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::String \- the String role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  "Hello World"\->uc; # HELLO WORLD
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a String value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBchomp\fR" 4
.IX Item "chomp"
.PD 0
.IP "\fBchop\fR" 4
.IX Item "chop"
.IP "\fBindex\fR" 4
.IX Item "index"
.IP "\fBlc\fR" 4
.IX Item "lc"
.IP "\fBlcfirst\fR" 4
.IX Item "lcfirst"
.IP "\fBlength\fR" 4
.IX Item "length"
.IP "\fBreverse\fR" 4
.IX Item "reverse"
.IP "\fBrindex\fR" 4
.IX Item "rindex"
.IP "\fBuc\fR" 4
.IX Item "uc"
.IP "\fBucfirst\fR" 4
.IX Item "ucfirst"
.IP "\fBsplit\fR" 4
.IX Item "split"
.PD
.Vb 1
\&  $string\->split($pattern);
.Ve
.IP "\fBwords\fR" 4
.IX Item "words"
This is equivalent to splitting on space.
.IP "\fBlines\fR" 4
.IX Item "lines"
This is equivalent to splitting on newlines.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Undef.3pm                    0100644 0001750 0001750 00000011463 12566242414 025262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Undef 3"
.TH Moose::Autobox::Undef 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Undef \- the Undef role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&
\&  my $x;
\&  $x\->defined; # false
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a undefined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Undef5.16.3pm                0100644 0001750 0001750 00000011142 12566242377 025576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Undef 3"
.TH Moose::Autobox::Undef 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Undef \- the Undef role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&
\&  my $x;
\&  $x\->defined; # false
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a undefined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Undef5.18.3pm                0100644 0001750 0001750 00000011463 12566242414 025576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Undef 3"
.TH Moose::Autobox::Undef 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Undef \- the Undef role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&
\&  my $x;
\&  $x\->defined; # false
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a undefined value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdefined\fR" 4
.IX Item "defined"
.PD 0
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Value.3pm                    0100644 0001750 0001750 00000011577 12566242414 025303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Value 3"
.TH Moose::Autobox::Value 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Value \- the Value role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  # execute a sub on the value
\&  print 10\->do(sub { $_ * $_ }); # prints 100
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined (non-reference) Perl value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdo (\e&block)\fR" 4
.IX Item "do (&block)"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Value5.16.3pm                0100644 0001750 0001750 00000011256 12566242377 025617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Value 3"
.TH Moose::Autobox::Value 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Value \- the Value role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  # execute a sub on the value
\&  print 10\->do(sub { $_ * $_ }); # prints 100
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined (non-reference) Perl value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdo (\e&block)\fR" 4
.IX Item "do (&block)"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Autobox::Value5.18.3pm                0100644 0001750 0001750 00000011577 12566242414 025617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Autobox::Value 3"
.TH Moose::Autobox::Value 3 "2013-10-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Autobox::Value \- the Value role
.SH "SYNOPOSIS"
.IX Header "SYNOPOSIS"
.Vb 1
\&  use Moose::Autobox;
\&  
\&  # execute a sub on the value
\&  print 10\->do(sub { $_ * $_ }); # prints 100
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a role to describes a defined (non-reference) Perl value.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBmeta\fR" 4
.IX Item "meta"
.PD 0
.IP "\fBdo (\e&block)\fR" 4
.IX Item "do (&block)"
.PD
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no 
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2006\-2008 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Conflicts.3pm                         0100644 0001750 0001750 00000011540 12566242160 024411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Conflicts 3"
.TH Moose::Conflicts 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Conflicts \- Provide information on conflicts for Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Conflicts5.18.3pm                     0100644 0001750 0001750 00000011540 12566242160 024725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Conflicts 3"
.TH Moose::Conflicts 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Conflicts \- Provide information on conflicts for Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook.3pm                          0100644 0001750 0001750 00000032402 12566242160 024233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook 3"
.TH Moose::Cookbook 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook \- How to cook a Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose cookbook is a series of recipes showing various Moose
features. Most recipes present some code demonstrating some feature,
and then explain the details of the code.
.PP
You should probably read the Moose::Manual first. The manual
explains Moose concepts without being too code-heavy.
.SH "RECIPES"
.IX Header "RECIPES"
.SS "Basic Moose"
.IX Subsection "Basic Moose"
These recipes will give you a good overview of Moose's capabilities, starting
with simple attribute declaration, and moving on to more powerful features like
laziness, types, type coercion, method modifiers, and more.
.IP "Moose::Cookbook::Basics::Point_AttributesAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::Point_AttributesAndSubclassing"
A simple Moose-based class. Demonstrates basic Moose attributes and subclassing.
.IP "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing"
A slightly more complex Moose class. Demonstrates using a method modifier in a
subclass.
.IP "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures"
Demonstrates several attribute features, including types, weak
references, predicates (\*(L"does this object have a foo?\*(R"), defaults,
laziness, and triggers.
.IP "Moose::Cookbook::Basics::Company_Subtypes" 4
.IX Item "Moose::Cookbook::Basics::Company_Subtypes"
Introduces the creation and use of custom types, a \f(CW\*(C`BUILD\*(C'\fR method, and the
use of \f(CW\*(C`override\*(C'\fR in a subclass. This recipe also shows how to model a set of
classes that could be used to model companies, people, employees, etc.
.IP "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion"
This recipe covers more subtype creation, including the use of type coercions.
.IP "Moose::Cookbook::Basics::Immutable" 4
.IX Item "Moose::Cookbook::Basics::Immutable"
Making a class immutable greatly increases the speed of accessors and
object construction.
.IP "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild - Builder methods and lazy_build"
The builder feature provides an inheritable and role-composable way to
provide a default attribute value.
.IP "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion"
Demonstrates using operator overloading, coercion, and subtypes to
model how eye color is determined during reproduction.
.IP "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD" 4
.IX Item "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR to hook
into object construction.
.IP "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent" 4
.IX Item "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent"
In this recipe, we make a Moose-based subclass of DateTime, a
module which does not use Moose itself.
.IP "Moose::Cookbook::Basics::Document_AugmentAndInner" 4
.IX Item "Moose::Cookbook::Basics::Document_AugmentAndInner"
Demonstrates the use of \f(CW\*(C`augment\*(C'\fR method modifiers, a way of turning
the usual method overriding style \*(L"inside-out\*(R".
.SS "Moose Roles"
.IX Subsection "Moose Roles"
These recipes will show you how to use Moose roles.
.IP "Moose::Cookbook::Roles::Comparable_CodeReuse" 4
.IX Item "Moose::Cookbook::Roles::Comparable_CodeReuse"
Demonstrates roles, which are also sometimes known as traits or
mix-ins. Roles provide a method of code re-use which is orthogonal to
subclassing.
.IP "Moose::Cookbook::Roles::Restartable_AdvancedComposition" 4
.IX Item "Moose::Cookbook::Roles::Restartable_AdvancedComposition"
Sometimes you just want to include part of a role in your
class. Sometimes you want the whole role but one of its methods
conflicts with one in your class. With method exclusion and aliasing,
you can work around these problems.
.IP "Moose::Cookbook::Roles::ApplicationToInstance" 4
.IX Item "Moose::Cookbook::Roles::ApplicationToInstance"
In this recipe, we apply a role to an existing object instance.
.SS "Meta Moose"
.IX Subsection "Meta Moose"
These recipes show you how to write your own meta classes, which lets
you extend the object system provided by Moose.
.IP "Moose::Cookbook::Meta::WhyMeta" 4
.IX Item "Moose::Cookbook::Meta::WhyMeta"
If you're wondering what all this \*(L"meta\*(R" stuff is, and why you should
care about it, read this \*(L"recipe\*(R".
.IP "Moose::Cookbook::Meta::Labeled_AttributeTrait" 4
.IX Item "Moose::Cookbook::Meta::Labeled_AttributeTrait"
Extending Moose's attribute metaclass is a great way to add
functionality. However, attributes can only have one metaclass.
Applying roles to the attribute metaclass lets you provide
composable attribute functionality.
.IP "Moose::Cookbook::Meta::Table_MetaclassTrait" 4
.IX Item "Moose::Cookbook::Meta::Table_MetaclassTrait"
This recipe takes the class metaclass we saw in the previous recipe
and reimplements it as a metaclass trait.
.IP "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass" 4
.IX Item "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass"
This recipe shows a custom method metaclass that implements making a
method private.
.IP "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass" 4
.IX Item "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass"
This recipe shows an example of how you create your own meta-instance
class. The meta-instance determines the internal structure of object
instances and provide access to attribute slots.
.Sp
In this particular instance, we use a blessed glob reference as the instance
instead of a blessed hash reference.
.IP "Hooking into immutabilization (\s-1TODO\s0)" 4
.IX Item "Hooking into immutabilization (TODO)"
Moose has a feature known as \*(L"immutabilization\*(R". By calling \f(CW\*(C`_\|_PACKAGE_\|_\->meta()\->make_immutable()\*(C'\fR after defining your class
(attributes, roles, etc), you tell Moose to optimize things like
object creation, attribute access, and so on.
.Sp
If you are creating your own metaclasses, you may need to hook into
the immutabilization system. This cuts across a number of spots,
including the metaclass class, meta method classes, and possibly the
meta-instance class as well.
.Sp
This recipe shows you how to write extensions which immutabilize
properly.
.SS "Extending Moose"
.IX Subsection "Extending Moose"
These recipes cover some more ways to extend Moose, and will be useful
if you plan to write your own \f(CW\*(C`MooseX\*(C'\fR module.
.IP "Moose::Cookbook::Extending::ExtensionOverview" 4
.IX Item "Moose::Cookbook::Extending::ExtensionOverview"
There are quite a few ways to extend Moose. This recipe provides an
overview of each method, and provides recommendations for when each is
appropriate.
.IP "Moose::Cookbook::Extending::Debugging_BaseClassRole" 4
.IX Item "Moose::Cookbook::Extending::Debugging_BaseClassRole"
Many base object class extensions can be implemented as roles. This
example shows how to provide a base object class debugging role that
is applied to any class that uses a notional \f(CW\*(C`MooseX::Debugging\*(C'\fR
module.
.IP "Moose::Cookbook::Extending::Mooseish_MooseSugar" 4
.IX Item "Moose::Cookbook::Extending::Mooseish_MooseSugar"
This recipe shows how to provide a replacement for \f(CW\*(C`Moose.pm\*(C'\fR. You
may want to do this as part of the \s-1API\s0 for a \f(CW\*(C`MooseX\*(C'\fR module,
especially if you want to default to a new metaclass class or base
object class.
.SH "SNACKS"
.IX Header "SNACKS"
.IP "Moose::Cookbook::Snack::Keywords" 4
.IX Item "Moose::Cookbook::Snack::Keywords"
.PD 0
.IP "Moose::Cookbook::Snack::Types" 4
.IX Item "Moose::Cookbook::Snack::Types"
.PD
.SH "Legacy Recipes"
.IX Header "Legacy Recipes"
These cover topics that are no longer considered best practice. We've kept
them in case in you encounter these usages in the wild.
.IP "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass"
.PD 0
.IP "Moose::Cookbook::Legacy::Table_ClassMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Table_ClassMetaclass"
.IP "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement" 4
.IX Item "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://www.gsph.com/index.php?Lang=En&ID=291>" 4
.IX Item "<http://www.gsph.com/index.php?Lang=En&ID=291>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "\(bu" 4
.PD
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook5.16.3pm                      0100644 0001750 0001750 00000031322 12566242166 024553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook 3"
.TH Moose::Cookbook 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook \- How to cook a Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose cookbook is a series of recipes showing various Moose
features. Most recipes present some code demonstrating some feature,
and then explain the details of the code.
.PP
You should probably read the Moose::Manual first. The manual
explains Moose concepts without being too code-heavy.
.SH "RECIPES"
.IX Header "RECIPES"
.SS "Basic Moose"
.IX Subsection "Basic Moose"
These recipes will give you a good overview of Moose's capabilities, starting
with simple attribute declaration, and moving on to more powerful features like
laziness, types, type coercion, method modifiers, and more.
.IP "Moose::Cookbook::Basics::Point_AttributesAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::Point_AttributesAndSubclassing"
A simple Moose-based class. Demonstrates basic Moose attributes and subclassing.
.IP "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing"
A slightly more complex Moose class. Demonstrates using a method modifier in a
subclass.
.IP "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures"
Demonstrates several attribute features, including types, weak
references, predicates (\*(L"does this object have a foo?\*(R"), defaults,
laziness, and triggers.
.IP "Moose::Cookbook::Basics::Company_Subtypes" 4
.IX Item "Moose::Cookbook::Basics::Company_Subtypes"
Introduces the creation and use of custom types, a \f(CW\*(C`BUILD\*(C'\fR method, and the
use of \f(CW\*(C`override\*(C'\fR in a subclass. This recipe also shows how to model a set of
classes that could be used to model companies, people, employees, etc.
.IP "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion"
This recipe covers more subtype creation, including the use of type coercions.
.IP "Moose::Cookbook::Basics::Immutable" 4
.IX Item "Moose::Cookbook::Basics::Immutable"
Making a class immutable greatly increases the speed of accessors and
object construction.
.IP "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild - Builder methods and lazy_build"
The builder feature provides an inheritable and role-composable way to
provide a default attribute value.
.IP "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion"
Demonstrates using operator overloading, coercion, and subtypes to
model how eye color is determined during reproduction.
.IP "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD" 4
.IX Item "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR to hook
into object construction.
.IP "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent" 4
.IX Item "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent"
In this recipe, we make a Moose-based subclass of DateTime, a
module which does not use Moose itself.
.IP "Moose::Cookbook::Basics::Document_AugmentAndInner" 4
.IX Item "Moose::Cookbook::Basics::Document_AugmentAndInner"
Demonstrates the use of \f(CW\*(C`augment\*(C'\fR method modifiers, a way of turning
the usual method overriding style \*(L"inside-out\*(R".
.SS "Moose Roles"
.IX Subsection "Moose Roles"
These recipes will show you how to use Moose roles.
.IP "Moose::Cookbook::Roles::Comparable_CodeReuse" 4
.IX Item "Moose::Cookbook::Roles::Comparable_CodeReuse"
Demonstrates roles, which are also sometimes known as traits or
mix-ins. Roles provide a method of code re-use which is orthogonal to
subclassing.
.IP "Moose::Cookbook::Roles::Restartable_AdvancedComposition" 4
.IX Item "Moose::Cookbook::Roles::Restartable_AdvancedComposition"
Sometimes you just want to include part of a role in your
class. Sometimes you want the whole role but one of its methods
conflicts with one in your class. With method exclusion and aliasing,
you can work around these problems.
.IP "Moose::Cookbook::Roles::ApplicationToInstance" 4
.IX Item "Moose::Cookbook::Roles::ApplicationToInstance"
In this recipe, we apply a role to an existing object instance.
.SS "Meta Moose"
.IX Subsection "Meta Moose"
These recipes show you how to write your own meta classes, which lets
you extend the object system provided by Moose.
.IP "Moose::Cookbook::Meta::WhyMeta" 4
.IX Item "Moose::Cookbook::Meta::WhyMeta"
If you're wondering what all this \*(L"meta\*(R" stuff is, and why you should
care about it, read this \*(L"recipe\*(R".
.IP "Moose::Cookbook::Meta::Labeled_AttributeTrait" 4
.IX Item "Moose::Cookbook::Meta::Labeled_AttributeTrait"
Extending Moose's attribute metaclass is a great way to add
functionality. However, attributes can only have one metaclass.
Applying roles to the attribute metaclass lets you provide
composable attribute functionality.
.IP "Moose::Cookbook::Meta::Table_MetaclassTrait" 4
.IX Item "Moose::Cookbook::Meta::Table_MetaclassTrait"
This recipe takes the class metaclass we saw in the previous recipe
and reimplements it as a metaclass trait.
.IP "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass" 4
.IX Item "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass"
This recipe shows a custom method metaclass that implements making a
method private.
.IP "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass" 4
.IX Item "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass"
This recipe shows an example of how you create your own meta-instance
class. The meta-instance determines the internal structure of object
instances and provide access to attribute slots.
.Sp
In this particular instance, we use a blessed glob reference as the instance
instead of a blessed hash reference.
.IP "Hooking into immutabilization (\s-1TODO\s0)" 4
.IX Item "Hooking into immutabilization (TODO)"
Moose has a feature known as \*(L"immutabilization\*(R". By calling \f(CW\*(C`_\|_PACKAGE_\|_\->meta()\->make_immutable()\*(C'\fR after defining your class
(attributes, roles, etc), you tell Moose to optimize things like
object creation, attribute access, and so on.
.Sp
If you are creating your own metaclasses, you may need to hook into
the immutabilization system. This cuts across a number of spots,
including the metaclass class, meta method classes, and possibly the
meta-instance class as well.
.Sp
This recipe shows you how to write extensions which immutabilize
properly.
.SS "Extending Moose"
.IX Subsection "Extending Moose"
These recipes cover some more ways to extend Moose, and will be useful
if you plan to write your own \f(CW\*(C`MooseX\*(C'\fR module.
.IP "Moose::Cookbook::Extending::ExtensionOverview" 4
.IX Item "Moose::Cookbook::Extending::ExtensionOverview"
There are quite a few ways to extend Moose. This recipe provides an
overview of each method, and provides recommendations for when each is
appropriate.
.IP "Moose::Cookbook::Extending::Debugging_BaseClassRole" 4
.IX Item "Moose::Cookbook::Extending::Debugging_BaseClassRole"
Many base object class extensions can be implemented as roles. This
example shows how to provide a base object class debugging role that
is applied to any class that uses a notional \f(CW\*(C`MooseX::Debugging\*(C'\fR
module.
.IP "Moose::Cookbook::Extending::Mooseish_MooseSugar" 4
.IX Item "Moose::Cookbook::Extending::Mooseish_MooseSugar"
This recipe shows how to provide a replacement for \f(CW\*(C`Moose.pm\*(C'\fR. You
may want to do this as part of the \s-1API\s0 for a \f(CW\*(C`MooseX\*(C'\fR module,
especially if you want to default to a new metaclass class or base
object class.
.SH "SNACKS"
.IX Header "SNACKS"
.IP "Moose::Cookbook::Snack::Keywords" 4
.IX Item "Moose::Cookbook::Snack::Keywords"
.PD 0
.IP "Moose::Cookbook::Snack::Types" 4
.IX Item "Moose::Cookbook::Snack::Types"
.PD
.SH "Legacy Recipes"
.IX Header "Legacy Recipes"
These cover topics that are no longer considered best practice. We've kept
them in case in you encounter these usages in the wild.
.IP "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass"
.PD 0
.IP "Moose::Cookbook::Legacy::Table_ClassMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Table_ClassMetaclass"
.IP "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement" 4
.IX Item "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://www.gsph.com/index.php?Lang=En&ID=291>" 4
.IX Item "<http://www.gsph.com/index.php?Lang=En&ID=291>"
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook5.18.3pm                      0100644 0001750 0001750 00000032402 12566242160 024547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook 3"
.TH Moose::Cookbook 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook \- How to cook a Moose
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose cookbook is a series of recipes showing various Moose
features. Most recipes present some code demonstrating some feature,
and then explain the details of the code.
.PP
You should probably read the Moose::Manual first. The manual
explains Moose concepts without being too code-heavy.
.SH "RECIPES"
.IX Header "RECIPES"
.SS "Basic Moose"
.IX Subsection "Basic Moose"
These recipes will give you a good overview of Moose's capabilities, starting
with simple attribute declaration, and moving on to more powerful features like
laziness, types, type coercion, method modifiers, and more.
.IP "Moose::Cookbook::Basics::Point_AttributesAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::Point_AttributesAndSubclassing"
A simple Moose-based class. Demonstrates basic Moose attributes and subclassing.
.IP "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing" 4
.IX Item "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing"
A slightly more complex Moose class. Demonstrates using a method modifier in a
subclass.
.IP "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures"
Demonstrates several attribute features, including types, weak
references, predicates (\*(L"does this object have a foo?\*(R"), defaults,
laziness, and triggers.
.IP "Moose::Cookbook::Basics::Company_Subtypes" 4
.IX Item "Moose::Cookbook::Basics::Company_Subtypes"
Introduces the creation and use of custom types, a \f(CW\*(C`BUILD\*(C'\fR method, and the
use of \f(CW\*(C`override\*(C'\fR in a subclass. This recipe also shows how to model a set of
classes that could be used to model companies, people, employees, etc.
.IP "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion"
This recipe covers more subtype creation, including the use of type coercions.
.IP "Moose::Cookbook::Basics::Immutable" 4
.IX Item "Moose::Cookbook::Basics::Immutable"
Making a class immutable greatly increases the speed of accessors and
object construction.
.IP "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build" 4
.IX Item "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild - Builder methods and lazy_build"
The builder feature provides an inheritable and role-composable way to
provide a default attribute value.
.IP "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion" 4
.IX Item "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion"
Demonstrates using operator overloading, coercion, and subtypes to
model how eye color is determined during reproduction.
.IP "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD" 4
.IX Item "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR to hook
into object construction.
.IP "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent" 4
.IX Item "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent"
In this recipe, we make a Moose-based subclass of DateTime, a
module which does not use Moose itself.
.IP "Moose::Cookbook::Basics::Document_AugmentAndInner" 4
.IX Item "Moose::Cookbook::Basics::Document_AugmentAndInner"
Demonstrates the use of \f(CW\*(C`augment\*(C'\fR method modifiers, a way of turning
the usual method overriding style \*(L"inside-out\*(R".
.SS "Moose Roles"
.IX Subsection "Moose Roles"
These recipes will show you how to use Moose roles.
.IP "Moose::Cookbook::Roles::Comparable_CodeReuse" 4
.IX Item "Moose::Cookbook::Roles::Comparable_CodeReuse"
Demonstrates roles, which are also sometimes known as traits or
mix-ins. Roles provide a method of code re-use which is orthogonal to
subclassing.
.IP "Moose::Cookbook::Roles::Restartable_AdvancedComposition" 4
.IX Item "Moose::Cookbook::Roles::Restartable_AdvancedComposition"
Sometimes you just want to include part of a role in your
class. Sometimes you want the whole role but one of its methods
conflicts with one in your class. With method exclusion and aliasing,
you can work around these problems.
.IP "Moose::Cookbook::Roles::ApplicationToInstance" 4
.IX Item "Moose::Cookbook::Roles::ApplicationToInstance"
In this recipe, we apply a role to an existing object instance.
.SS "Meta Moose"
.IX Subsection "Meta Moose"
These recipes show you how to write your own meta classes, which lets
you extend the object system provided by Moose.
.IP "Moose::Cookbook::Meta::WhyMeta" 4
.IX Item "Moose::Cookbook::Meta::WhyMeta"
If you're wondering what all this \*(L"meta\*(R" stuff is, and why you should
care about it, read this \*(L"recipe\*(R".
.IP "Moose::Cookbook::Meta::Labeled_AttributeTrait" 4
.IX Item "Moose::Cookbook::Meta::Labeled_AttributeTrait"
Extending Moose's attribute metaclass is a great way to add
functionality. However, attributes can only have one metaclass.
Applying roles to the attribute metaclass lets you provide
composable attribute functionality.
.IP "Moose::Cookbook::Meta::Table_MetaclassTrait" 4
.IX Item "Moose::Cookbook::Meta::Table_MetaclassTrait"
This recipe takes the class metaclass we saw in the previous recipe
and reimplements it as a metaclass trait.
.IP "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass" 4
.IX Item "Moose::Cookbook::Meta::PrivateOrPublic_MethodMetaclass"
This recipe shows a custom method metaclass that implements making a
method private.
.IP "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass" 4
.IX Item "Moose::Cookbook::Meta::GlobRef_InstanceMetaclass"
This recipe shows an example of how you create your own meta-instance
class. The meta-instance determines the internal structure of object
instances and provide access to attribute slots.
.Sp
In this particular instance, we use a blessed glob reference as the instance
instead of a blessed hash reference.
.IP "Hooking into immutabilization (\s-1TODO\s0)" 4
.IX Item "Hooking into immutabilization (TODO)"
Moose has a feature known as \*(L"immutabilization\*(R". By calling \f(CW\*(C`_\|_PACKAGE_\|_\->meta()\->make_immutable()\*(C'\fR after defining your class
(attributes, roles, etc), you tell Moose to optimize things like
object creation, attribute access, and so on.
.Sp
If you are creating your own metaclasses, you may need to hook into
the immutabilization system. This cuts across a number of spots,
including the metaclass class, meta method classes, and possibly the
meta-instance class as well.
.Sp
This recipe shows you how to write extensions which immutabilize
properly.
.SS "Extending Moose"
.IX Subsection "Extending Moose"
These recipes cover some more ways to extend Moose, and will be useful
if you plan to write your own \f(CW\*(C`MooseX\*(C'\fR module.
.IP "Moose::Cookbook::Extending::ExtensionOverview" 4
.IX Item "Moose::Cookbook::Extending::ExtensionOverview"
There are quite a few ways to extend Moose. This recipe provides an
overview of each method, and provides recommendations for when each is
appropriate.
.IP "Moose::Cookbook::Extending::Debugging_BaseClassRole" 4
.IX Item "Moose::Cookbook::Extending::Debugging_BaseClassRole"
Many base object class extensions can be implemented as roles. This
example shows how to provide a base object class debugging role that
is applied to any class that uses a notional \f(CW\*(C`MooseX::Debugging\*(C'\fR
module.
.IP "Moose::Cookbook::Extending::Mooseish_MooseSugar" 4
.IX Item "Moose::Cookbook::Extending::Mooseish_MooseSugar"
This recipe shows how to provide a replacement for \f(CW\*(C`Moose.pm\*(C'\fR. You
may want to do this as part of the \s-1API\s0 for a \f(CW\*(C`MooseX\*(C'\fR module,
especially if you want to default to a new metaclass class or base
object class.
.SH "SNACKS"
.IX Header "SNACKS"
.IP "Moose::Cookbook::Snack::Keywords" 4
.IX Item "Moose::Cookbook::Snack::Keywords"
.PD 0
.IP "Moose::Cookbook::Snack::Types" 4
.IX Item "Moose::Cookbook::Snack::Types"
.PD
.SH "Legacy Recipes"
.IX Header "Legacy Recipes"
These cover topics that are no longer considered best practice. We've kept
them in case in you encounter these usages in the wild.
.IP "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass"
.PD 0
.IP "Moose::Cookbook::Legacy::Table_ClassMetaclass" 4
.IX Item "Moose::Cookbook::Legacy::Table_ClassMetaclass"
.IP "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement" 4
.IX Item "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://www.gsph.com/index.php?Lang=En&ID=291>" 4
.IX Item "<http://www.gsph.com/index.php?Lang=En&ID=291>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "\(bu" 4
.PD
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                              Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing.3pm                              0100644 0001750 0001750 00000033130 12566242162 035746  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3"
.TH Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing \- Demonstrates the use of method modifiers in a subclass
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BankAccount;
\&  use Moose;
\&
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
\&
\&  sub deposit {
\&      my ( $self, $amount ) = @_;
\&      $self\->balance( $self\->balance + $amount );
\&  }
\&
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $current_balance = $self\->balance();
\&      ( $current_balance >= $amount )
\&          || confess "Account overdrawn";
\&      $self\->balance( $current_balance \- $amount );
\&  }
\&
\&  package CheckingAccount;
\&  use Moose;
\&
\&  extends \*(AqBankAccount\*(Aq;
\&
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The first recipe demonstrated how to build very basic Moose classes,
focusing on creating and manipulating attributes. The objects in that
recipe were very data-oriented, and did not have much in the way of
behavior (i.e. methods). In this recipe, we expand upon the concepts
from the first recipe to include some real behavior. In particular, we
show how you can use a method modifier to implement new behavior for a
method.
.PP
The classes in the \s-1SYNOPSIS\s0 show two kinds of bank account. A simple
bank account has one attribute, the balance, and two behaviors,
depositing and withdrawing money.
.PP
We then extend the basic bank account in the CheckingAccount
class. This class adds another attribute, an overdraft account. It
also adds overdraft protection to the withdraw method. If you try to
withdraw more than you have, the checking account attempts to
reconcile the difference by withdrawing money from the overdraft
account. (1)
.PP
The first class, \fBBankAccount\fR, introduces a new attribute feature, a
default value:
.PP
.Vb 1
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
.Ve
.PP
This says that a \fBBankAccount\fR has a \f(CW\*(C`balance\*(C'\fR attribute, which has
an \f(CW\*(C`Int\*(C'\fR type constraint, a read/write accessor, and a default value
of \f(CW0\fR. This means that every instance of \fBBankAccount\fR that is
created will have its \f(CW\*(C`balance\*(C'\fR slot initialized to \f(CW0\fR, unless some
other value is provided to the constructor.
.PP
The \f(CW\*(C`deposit\*(C'\fR and \f(CW\*(C`withdraw\*(C'\fR methods should be fairly
self-explanatory, as they are just plain old Perl 5 \s-1OO. \\fIs0\fR\|(2)
.PP
As you know from the first recipe, the keyword \f(CW\*(C`extends\*(C'\fR sets a
class's superclass. Here we see that \fBCheckingAccount\fR \f(CW\*(C`extends\*(C'\fR
\&\fBBankAccount\fR. The next line introduces yet another new attribute
feature, class-based type constraints:
.PP
.Vb 1
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Up until now, we have only seen the \f(CW\*(C`Int\*(C'\fR type constraint, which (as
we saw in the first recipe) is a builtin type constraint. The
\&\f(CW\*(C`BankAccount\*(C'\fR type constraint is new, and was actually defined the
moment we created the \fBBankAccount\fR class itself. In fact, Moose
creates a corresponding type constraint for every class in your
program (3).
.PP
This means that in the first recipe, constraints for both \f(CW\*(C`Point\*(C'\fR and
\&\f(CW\*(C`Point3D\*(C'\fR were created. In this recipe, both \f(CW\*(C`BankAccount\*(C'\fR and
\&\f(CW\*(C`CheckingAccount\*(C'\fR type constraints are created automatically. Moose
does this as a convenience so that your classes and type constraint
can be kept in sync with one another. In short, Moose makes sure that
it will just \s-1DWIM \\fIs0\fR\|(4).
.PP
In \fBCheckingAccount\fR, we see another method modifier, the \f(CW\*(C`before\*(C'\fR
modifier.
.PP
.Vb 8
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.PP
Just as with the \f(CW\*(C`after\*(C'\fR modifier from the first recipe, Moose will
handle calling the superclass method (in this case \f(CW\*(C`BankAccount\->withdraw\*(C'\fR).
.PP
The \f(CW\*(C`before\*(C'\fR modifier will (obviously) run \fIbefore\fR the code from
the superclass is run. Here, \f(CW\*(C`before\*(C'\fR modifier implements overdraft
protection by first checking if there are available funds in the
checking account. If not (and if there is an overdraft account
available), it transfers the amount needed into the checking
account (5).
.PP
As with the method modifier in the first recipe, we could use
\&\f(CW\*(C`SUPER::\*(C'\fR to get the same effect:
.PP
.Vb 9
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&      $self\->SUPER::withdraw($amount);
\&  }
.Ve
.PP
The benefit of taking the method modifier approach is we do not need
to remember to call \f(CW\*(C`SUPER::withdraw\*(C'\fR and pass it the \f(CW$amount\fR
argument when writing \f(CW\*(C`CheckingAccount\->withdraw\*(C'\fR.
.PP
This is actually more than just a convenience for forgetful
programmers. Using method modifiers helps isolate subclasses from
changes in the superclasses. For instance, if \fBBankAccount\->withdraw\fR were to add an additional argument of some
kind, the version of \fBCheckingAccount\->withdraw\fR which uses
\&\f(CW\*(C`SUPER::withdraw\*(C'\fR would not pass that extra argument correctly,
whereas the method modifier version would automatically pass along all
arguments correctly.
.PP
Just as with the first recipe, object instantiation uses the \f(CW\*(C`new\*(C'\fR
method, which accepts named parameters.
.PP
.Vb 1
\&  my $savings_account = BankAccount\->new( balance => 250 );
\&
\&  my $checking_account = CheckingAccount\->new(
\&      balance           => 100,
\&      overdraft_account => $savings_account,
\&  );
.Ve
.PP
And as with the first recipe, a more in-depth example can be found in
the \fIt/recipes/moose_cookbook_basics_recipe2.t\fR test file.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe expanded on the basic concepts from the first recipe with
a more \*(L"real world\*(R" use case.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
If you're paying close attention, you might realize that there's a
circular loop waiting to happen here. A smarter example would have to
make sure that we don't accidentally create a loop between the
checking account and its overdraft account.
.IP "(2)" 4
.IX Item "(2)"
Note that for simple methods like these, which just manipulate some
single piece of data, it is often not necessary to write them at all.
For instance, \f(CW\*(C`deposit\*(C'\fR could be implemented via the \f(CW\*(C`inc\*(C'\fR native
delegation for counters \- see
Moose::Meta::Attribute::Native::Trait::Counter for more specifics,
and Moose::Meta::Attribute::Native for a broader overview.
.IP "(3)" 4
.IX Item "(3)"
In reality, this creation is sensitive to the order in which modules
are loaded. In more complicated cases, you may find that you need to
explicitly declare a class type before the corresponding class is
loaded.
.IP "(4)" 4
.IX Item "(4)"
Moose does not attempt to encode a class's is-a relationships within
the type constraint hierarchy. Instead, Moose just considers the class
type constraint to be a subtype of \f(CW\*(C`Object\*(C'\fR, and specializes the
constraint check to allow for subclasses. This means that an instance
of \fBCheckingAccount\fR will pass a \f(CW\*(C`BankAccount\*(C'\fR type constraint
successfully. For more details, please refer to the
Moose::Util::TypeConstraints documentation.
.IP "(5)" 4
.IX Item "(5)"
If the overdraft account does not have the amount needed, it will
throw an error. Of course, the overdraft account could also have
overdraft protection. See note 1.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
The BankAccount example in this recipe is directly taken from the
examples in this chapter of \*(L"Practical Common Lisp\*(R":
.PP
<http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                        Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing5.16.3pm                          0100644 0001750 0001750 00000032156 12566242167 036274  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3"
.TH Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing \- Demonstrates the use of method modifiers in a subclass
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BankAccount;
\&  use Moose;
\&
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
\&
\&  sub deposit {
\&      my ( $self, $amount ) = @_;
\&      $self\->balance( $self\->balance + $amount );
\&  }
\&
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $current_balance = $self\->balance();
\&      ( $current_balance >= $amount )
\&          || confess "Account overdrawn";
\&      $self\->balance( $current_balance \- $amount );
\&  }
\&
\&  package CheckingAccount;
\&  use Moose;
\&
\&  extends \*(AqBankAccount\*(Aq;
\&
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The first recipe demonstrated how to build very basic Moose classes,
focusing on creating and manipulating attributes. The objects in that
recipe were very data-oriented, and did not have much in the way of
behavior (i.e. methods). In this recipe, we expand upon the concepts
from the first recipe to include some real behavior. In particular, we
show how you can use a method modifier to implement new behavior for a
method.
.PP
The classes in the \s-1SYNOPSIS\s0 show two kinds of bank account. A simple
bank account has one attribute, the balance, and two behaviors,
depositing and withdrawing money.
.PP
We then extend the basic bank account in the CheckingAccount
class. This class adds another attribute, an overdraft account. It
also adds overdraft protection to the withdraw method. If you try to
withdraw more than you have, the checking account attempts to
reconcile the difference by withdrawing money from the overdraft
account. (1)
.PP
The first class, \fBBankAccount\fR, introduces a new attribute feature, a
default value:
.PP
.Vb 1
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
.Ve
.PP
This says that a \fBBankAccount\fR has a \f(CW\*(C`balance\*(C'\fR attribute, which has
an \f(CW\*(C`Int\*(C'\fR type constraint, a read/write accessor, and a default value
of \f(CW0\fR. This means that every instance of \fBBankAccount\fR that is
created will have its \f(CW\*(C`balance\*(C'\fR slot initialized to \f(CW0\fR, unless some
other value is provided to the constructor.
.PP
The \f(CW\*(C`deposit\*(C'\fR and \f(CW\*(C`withdraw\*(C'\fR methods should be fairly
self-explanatory, as they are just plain old Perl 5 \s-1OO\s0. (2)
.PP
As you know from the first recipe, the keyword \f(CW\*(C`extends\*(C'\fR sets a
class's superclass. Here we see that \fBCheckingAccount\fR \f(CW\*(C`extends\*(C'\fR
\&\fBBankAccount\fR. The next line introduces yet another new attribute
feature, class-based type constraints:
.PP
.Vb 1
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Up until now, we have only seen the \f(CW\*(C`Int\*(C'\fR type constraint, which (as
we saw in the first recipe) is a builtin type constraint. The
\&\f(CW\*(C`BankAccount\*(C'\fR type constraint is new, and was actually defined the
moment we created the \fBBankAccount\fR class itself. In fact, Moose
creates a corresponding type constraint for every class in your
program (3).
.PP
This means that in the first recipe, constraints for both \f(CW\*(C`Point\*(C'\fR and
\&\f(CW\*(C`Point3D\*(C'\fR were created. In this recipe, both \f(CW\*(C`BankAccount\*(C'\fR and
\&\f(CW\*(C`CheckingAccount\*(C'\fR type constraints are created automatically. Moose
does this as a convenience so that your classes and type constraint
can be kept in sync with one another. In short, Moose makes sure that
it will just \s-1DWIM\s0 (4).
.PP
In \fBCheckingAccount\fR, we see another method modifier, the \f(CW\*(C`before\*(C'\fR
modifier.
.PP
.Vb 8
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.PP
Just as with the \f(CW\*(C`after\*(C'\fR modifier from the first recipe, Moose will
handle calling the superclass method (in this case \f(CW\*(C`BankAccount\->withdraw\*(C'\fR).
.PP
The \f(CW\*(C`before\*(C'\fR modifier will (obviously) run \fIbefore\fR the code from
the superclass is run. Here, \f(CW\*(C`before\*(C'\fR modifier implements overdraft
protection by first checking if there are available funds in the
checking account. If not (and if there is an overdraft account
available), it transfers the amount needed into the checking
account (5).
.PP
As with the method modifier in the first recipe, we could use
\&\f(CW\*(C`SUPER::\*(C'\fR to get the same effect:
.PP
.Vb 9
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&      $self\->SUPER::withdraw($amount);
\&  }
.Ve
.PP
The benefit of taking the method modifier approach is we do not need
to remember to call \f(CW\*(C`SUPER::withdraw\*(C'\fR and pass it the \f(CW$amount\fR
argument when writing \f(CW\*(C`CheckingAccount\->withdraw\*(C'\fR.
.PP
This is actually more than just a convenience for forgetful
programmers. Using method modifiers helps isolate subclasses from
changes in the superclasses. For instance, if \fBBankAccount\->withdraw\fR were to add an additional argument of some
kind, the version of \fBCheckingAccount\->withdraw\fR which uses
\&\f(CW\*(C`SUPER::withdraw\*(C'\fR would not pass that extra argument correctly,
whereas the method modifier version would automatically pass along all
arguments correctly.
.PP
Just as with the first recipe, object instantiation uses the \f(CW\*(C`new\*(C'\fR
method, which accepts named parameters.
.PP
.Vb 1
\&  my $savings_account = BankAccount\->new( balance => 250 );
\&
\&  my $checking_account = CheckingAccount\->new(
\&      balance           => 100,
\&      overdraft_account => $savings_account,
\&  );
.Ve
.PP
And as with the first recipe, a more in-depth example can be found in
the \fIt/recipes/moose_cookbook_basics_recipe2.t\fR test file.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe expanded on the basic concepts from the first recipe with
a more \*(L"real world\*(R" use case.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
If you're paying close attention, you might realize that there's a
circular loop waiting to happen here. A smarter example would have to
make sure that we don't accidentally create a loop between the
checking account and its overdraft account.
.IP "(2)" 4
.IX Item "(2)"
Note that for simple methods like these, which just manipulate some
single piece of data, it is often not necessary to write them at all.
For instance, \f(CW\*(C`deposit\*(C'\fR could be implemented via the \f(CW\*(C`inc\*(C'\fR native
delegation for counters \- see
Moose::Meta::Attribute::Native::Trait::Counter for more specifics,
and Moose::Meta::Attribute::Native for a broader overview.
.IP "(3)" 4
.IX Item "(3)"
In reality, this creation is sensitive to the order in which modules
are loaded. In more complicated cases, you may find that you need to
explicitly declare a class type before the corresponding class is
loaded.
.IP "(4)" 4
.IX Item "(4)"
Moose does not attempt to encode a class's is-a relationships within
the type constraint hierarchy. Instead, Moose just considers the class
type constraint to be a subtype of \f(CW\*(C`Object\*(C'\fR, and specializes the
constraint check to allow for subclasses. This means that an instance
of \fBCheckingAccount\fR will pass a \f(CW\*(C`BankAccount\*(C'\fR type constraint
successfully. For more details, please refer to the
Moose::Util::TypeConstraints documentation.
.IP "(5)" 4
.IX Item "(5)"
If the overdraft account does not have the amount needed, it will
throw an error. Of course, the overdraft account could also have
overdraft protection. See note 1.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
The BankAccount example in this recipe is directly taken from the
examples in this chapter of \*(L"Practical Common Lisp\*(R":
.PP
http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html <http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                  Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing5.18.3pm                          0100644 0001750 0001750 00000033130 12566242162 036262  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3"
.TH Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BankAccount_MethodModifiersAndSubclassing \- Demonstrates the use of method modifiers in a subclass
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BankAccount;
\&  use Moose;
\&
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
\&
\&  sub deposit {
\&      my ( $self, $amount ) = @_;
\&      $self\->balance( $self\->balance + $amount );
\&  }
\&
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $current_balance = $self\->balance();
\&      ( $current_balance >= $amount )
\&          || confess "Account overdrawn";
\&      $self\->balance( $current_balance \- $amount );
\&  }
\&
\&  package CheckingAccount;
\&  use Moose;
\&
\&  extends \*(AqBankAccount\*(Aq;
\&
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The first recipe demonstrated how to build very basic Moose classes,
focusing on creating and manipulating attributes. The objects in that
recipe were very data-oriented, and did not have much in the way of
behavior (i.e. methods). In this recipe, we expand upon the concepts
from the first recipe to include some real behavior. In particular, we
show how you can use a method modifier to implement new behavior for a
method.
.PP
The classes in the \s-1SYNOPSIS\s0 show two kinds of bank account. A simple
bank account has one attribute, the balance, and two behaviors,
depositing and withdrawing money.
.PP
We then extend the basic bank account in the CheckingAccount
class. This class adds another attribute, an overdraft account. It
also adds overdraft protection to the withdraw method. If you try to
withdraw more than you have, the checking account attempts to
reconcile the difference by withdrawing money from the overdraft
account. (1)
.PP
The first class, \fBBankAccount\fR, introduces a new attribute feature, a
default value:
.PP
.Vb 1
\&  has \*(Aqbalance\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, default => 0 );
.Ve
.PP
This says that a \fBBankAccount\fR has a \f(CW\*(C`balance\*(C'\fR attribute, which has
an \f(CW\*(C`Int\*(C'\fR type constraint, a read/write accessor, and a default value
of \f(CW0\fR. This means that every instance of \fBBankAccount\fR that is
created will have its \f(CW\*(C`balance\*(C'\fR slot initialized to \f(CW0\fR, unless some
other value is provided to the constructor.
.PP
The \f(CW\*(C`deposit\*(C'\fR and \f(CW\*(C`withdraw\*(C'\fR methods should be fairly
self-explanatory, as they are just plain old Perl 5 \s-1OO. \\fIs0\fR\|(2)
.PP
As you know from the first recipe, the keyword \f(CW\*(C`extends\*(C'\fR sets a
class's superclass. Here we see that \fBCheckingAccount\fR \f(CW\*(C`extends\*(C'\fR
\&\fBBankAccount\fR. The next line introduces yet another new attribute
feature, class-based type constraints:
.PP
.Vb 1
\&  has \*(Aqoverdraft_account\*(Aq => ( isa => \*(AqBankAccount\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Up until now, we have only seen the \f(CW\*(C`Int\*(C'\fR type constraint, which (as
we saw in the first recipe) is a builtin type constraint. The
\&\f(CW\*(C`BankAccount\*(C'\fR type constraint is new, and was actually defined the
moment we created the \fBBankAccount\fR class itself. In fact, Moose
creates a corresponding type constraint for every class in your
program (3).
.PP
This means that in the first recipe, constraints for both \f(CW\*(C`Point\*(C'\fR and
\&\f(CW\*(C`Point3D\*(C'\fR were created. In this recipe, both \f(CW\*(C`BankAccount\*(C'\fR and
\&\f(CW\*(C`CheckingAccount\*(C'\fR type constraints are created automatically. Moose
does this as a convenience so that your classes and type constraint
can be kept in sync with one another. In short, Moose makes sure that
it will just \s-1DWIM \\fIs0\fR\|(4).
.PP
In \fBCheckingAccount\fR, we see another method modifier, the \f(CW\*(C`before\*(C'\fR
modifier.
.PP
.Vb 8
\&  before \*(Aqwithdraw\*(Aq => sub {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&  };
.Ve
.PP
Just as with the \f(CW\*(C`after\*(C'\fR modifier from the first recipe, Moose will
handle calling the superclass method (in this case \f(CW\*(C`BankAccount\->withdraw\*(C'\fR).
.PP
The \f(CW\*(C`before\*(C'\fR modifier will (obviously) run \fIbefore\fR the code from
the superclass is run. Here, \f(CW\*(C`before\*(C'\fR modifier implements overdraft
protection by first checking if there are available funds in the
checking account. If not (and if there is an overdraft account
available), it transfers the amount needed into the checking
account (5).
.PP
As with the method modifier in the first recipe, we could use
\&\f(CW\*(C`SUPER::\*(C'\fR to get the same effect:
.PP
.Vb 9
\&  sub withdraw {
\&      my ( $self, $amount ) = @_;
\&      my $overdraft_amount = $amount \- $self\->balance();
\&      if ( $self\->overdraft_account && $overdraft_amount > 0 ) {
\&          $self\->overdraft_account\->withdraw($overdraft_amount);
\&          $self\->deposit($overdraft_amount);
\&      }
\&      $self\->SUPER::withdraw($amount);
\&  }
.Ve
.PP
The benefit of taking the method modifier approach is we do not need
to remember to call \f(CW\*(C`SUPER::withdraw\*(C'\fR and pass it the \f(CW$amount\fR
argument when writing \f(CW\*(C`CheckingAccount\->withdraw\*(C'\fR.
.PP
This is actually more than just a convenience for forgetful
programmers. Using method modifiers helps isolate subclasses from
changes in the superclasses. For instance, if \fBBankAccount\->withdraw\fR were to add an additional argument of some
kind, the version of \fBCheckingAccount\->withdraw\fR which uses
\&\f(CW\*(C`SUPER::withdraw\*(C'\fR would not pass that extra argument correctly,
whereas the method modifier version would automatically pass along all
arguments correctly.
.PP
Just as with the first recipe, object instantiation uses the \f(CW\*(C`new\*(C'\fR
method, which accepts named parameters.
.PP
.Vb 1
\&  my $savings_account = BankAccount\->new( balance => 250 );
\&
\&  my $checking_account = CheckingAccount\->new(
\&      balance           => 100,
\&      overdraft_account => $savings_account,
\&  );
.Ve
.PP
And as with the first recipe, a more in-depth example can be found in
the \fIt/recipes/moose_cookbook_basics_recipe2.t\fR test file.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe expanded on the basic concepts from the first recipe with
a more \*(L"real world\*(R" use case.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
If you're paying close attention, you might realize that there's a
circular loop waiting to happen here. A smarter example would have to
make sure that we don't accidentally create a loop between the
checking account and its overdraft account.
.IP "(2)" 4
.IX Item "(2)"
Note that for simple methods like these, which just manipulate some
single piece of data, it is often not necessary to write them at all.
For instance, \f(CW\*(C`deposit\*(C'\fR could be implemented via the \f(CW\*(C`inc\*(C'\fR native
delegation for counters \- see
Moose::Meta::Attribute::Native::Trait::Counter for more specifics,
and Moose::Meta::Attribute::Native for a broader overview.
.IP "(3)" 4
.IX Item "(3)"
In reality, this creation is sensitive to the order in which modules
are loaded. In more complicated cases, you may find that you need to
explicitly declare a class type before the corresponding class is
loaded.
.IP "(4)" 4
.IX Item "(4)"
Moose does not attempt to encode a class's is-a relationships within
the type constraint hierarchy. Instead, Moose just considers the class
type constraint to be a subtype of \f(CW\*(C`Object\*(C'\fR, and specializes the
constraint check to allow for subclasses. This means that an instance
of \fBCheckingAccount\fR will pass a \f(CW\*(C`BankAccount\*(C'\fR type constraint
successfully. For more details, please refer to the
Moose::Util::TypeConstraints documentation.
.IP "(5)" 4
.IX Item "(5)"
If the overdraft account does not have the amount needed, it will
throw an error. Of course, the overdraft account could also have
overdraft protection. See note 1.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
The BankAccount example in this recipe is directly taken from the
examples in this chapter of \*(L"Practical Common Lisp\*(R":
.PP
<http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                        Moose::Cookbook::Basics::BinaryTree_AttributeFeatures.3pm                                           0100644 0001750 0001750 00000033203 12566242161 033361  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3"
.TH Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures \- Demonstrates various attribute features including lazy, predicates, weak refs, and more
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how various advanced attribute features can be used
to create complex and powerful behaviors. In particular, we introduce
a number of new attribute options, including \f(CW\*(C`predicate\*(C'\fR, \f(CW\*(C`lazy\*(C'\fR,
and \f(CW\*(C`trigger\*(C'\fR.
.PP
The example class is a classic binary tree. Each node in the tree is
itself an instance of \f(CW\*(C`BinaryTree\*(C'\fR. It has a \f(CW\*(C`node\*(C'\fR, which holds
some arbitrary value. It has \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR attributes, which
refer to its child trees, and a \f(CW\*(C`parent\*(C'\fR.
.PP
Let's take a look at the \f(CW\*(C`node\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
.Ve
.PP
Moose generates a read-write accessor for this attribute. The type
constraint is \f(CW\*(C`Any\*(C'\fR, which literally means it can contain anything.
.PP
We could have left out the \f(CW\*(C`isa\*(C'\fR option, but in this case, we are
including it for the benefit of other programmers, not the computer.
.PP
Next, let's move on to the \f(CW\*(C`parent\*(C'\fR attribute:
.PP
.Vb 6
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
.Ve
.PP
Again, we have a read-write accessor. This time, the \f(CW\*(C`isa\*(C'\fR option
says that this attribute must always be an instance of
\&\f(CW\*(C`BinaryTree\*(C'\fR. In the second recipe, we saw that every time we create
a Moose-based class, we also get a corresponding class type
constraint.
.PP
The \f(CW\*(C`predicate\*(C'\fR option is new. It creates a method which can be used
to check whether or not a given attribute has been initialized. In
this case, the method is named \f(CW\*(C`has_parent\*(C'\fR.
.PP
This brings us to our last attribute option, \f(CW\*(C`weak_ref\*(C'\fR. Since
\&\f(CW\*(C`parent\*(C'\fR is a circular reference (the tree in \f(CW\*(C`parent\*(C'\fR should
already have a reference to this one, in its \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR
attribute), we want to make sure that we weaken the reference to avoid
memory leaks. If \f(CW\*(C`weak_ref\*(C'\fR is true, it alters the accessor function
so that the reference is weakened when it is set.
.PP
Finally, we have the \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes. They are
essentially identical except for their names, so we'll just look at
\&\f(CW\*(C`left\*(C'\fR:
.PP
.Vb 8
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
.Ve
.PP
There are three new options here, \f(CW\*(C`lazy\*(C'\fR, \f(CW\*(C`default\*(C'\fR, and
\&\f(CW\*(C`trigger\*(C'\fR. The \f(CW\*(C`lazy\*(C'\fR and \f(CW\*(C`default\*(C'\fR options are linked.  In fact,
you cannot have a \f(CW\*(C`lazy\*(C'\fR attribute unless it has a \f(CW\*(C`default\*(C'\fR
(or a \f(CW\*(C`builder\*(C'\fR, but we'll cover that later). If you try to make an
attribute lazy without a default, class creation will fail with an
exception. (2)
.PP
In the second recipe the \fBBankAccount\fR's \f(CW\*(C`balance\*(C'\fR attribute had a
default value of \f(CW0\fR. Given a non-reference, Perl copies the
\&\fIvalue\fR. However, given a reference, it does not do a deep clone,
instead simply copying the reference. If you just specified a simple
reference for a default, Perl would create it once and it would be
shared by all objects with that attribute.
.PP
As a workaround, we use an anonymous subroutine to generate a new
reference every time the default is called.
.PP
.Vb 1
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => sub { [] } );
.Ve
.PP
In fact, using a non-subroutine reference as a default is illegal in Moose.
.PP
.Vb 2
\&  # will fail
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => [] );
.Ve
.PP
This will blow up, so don't do it.
.PP
You'll notice that we use \f(CW$_[0]\fR in our default sub. When the
default subroutine is executed, it is called as a method on the
object.
.PP
In our case, we're making a new \f(CW\*(C`BinaryTree\*(C'\fR object in our default,
with the current tree as the parent.
.PP
Normally, when an object is instantiated, any defaults are evaluated
immediately. With our \f(CW\*(C`BinaryTree\*(C'\fR class, this would be a big
problem! We'd create the first object, which would immediately try to
populate its \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes, which would create a new
\&\f(CW\*(C`BinaryTree\*(C'\fR, which would populate \fIits\fR \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR
slots. Kaboom!
.PP
By making our \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes \f(CW\*(C`lazy\*(C'\fR, we avoid this
problem. If the attribute has a value when it is read, the default is
never executed at all.
.PP
We still have one last bit of behavior to add. The autogenerated
\&\f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR accessors are not quite correct. When one of
these is set, we want to make sure that we update the parent of the
\&\f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute's tree.
.PP
We could write our own accessors, but then why use Moose at all?
Instead, we use a \f(CW\*(C`trigger\*(C'\fR. A \f(CW\*(C`trigger\*(C'\fR accepts a subroutine
reference, which will be called as a method whenever the attribute is
set. This can happen both during object construction or later by
passing a new object to the attribute's accessor method. However, it
is not called when a value is provided by a \f(CW\*(C`default\*(C'\fR or \f(CW\*(C`builder\*(C'\fR.
.PP
.Vb 2
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.PP
This trigger does two things. First, it ensures that the new child
node does not already have a parent. This is done for the sake of
simplifying the example. If we wanted to be more clever, we would
remove the child from its old parent tree and add it to the new one.
.PP
If the child has no parent, we will add it to the current tree, and we
ensure that is has the correct value for its \f(CW\*(C`parent\*(C'\fR attribute.
.PP
As with all the other recipes, \fBBinaryTree\fR can be used just like any
other Perl 5 class. A more detailed example of its usage can be found
in \fIt/recipes/moose_cookbook_basics_recipe3.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe introduced several of Moose's advanced features. We hope
that this inspires you to think of other ways these features can be
used to simplify your code.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Weak references are tricky things, and should be used sparingly and
appropriately (such as in the case of circular refs). If you are not
careful, attribute values could disappear \*(L"mysteriously\*(R" because
Perl's reference counting garbage collector has gone and removed the
item you are weak-referencing.
.Sp
In short, don't use them unless you know what you are doing :)
.IP "(2)" 4
.IX Item "(2)"
You \fIcan\fR use the \f(CW\*(C`default\*(C'\fR option without the \f(CW\*(C`lazy\*(C'\fR option if you
like, as we showed in the second recipe.
.Sp
Also, you can use \f(CW\*(C`builder\*(C'\fR instead of \f(CW\*(C`default\*(C'\fR. See
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                             Moose::Cookbook::Basics::BinaryTree_AttributeFeatures5.16.3pm                                       0100644 0001750 0001750 00000032151 12566242166 033701  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3"
.TH Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures \- Demonstrates various attribute features including lazy, predicates, weak refs, and more
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how various advanced attribute features can be used
to create complex and powerful behaviors. In particular, we introduce
a number of new attribute options, including \f(CW\*(C`predicate\*(C'\fR, \f(CW\*(C`lazy\*(C'\fR,
and \f(CW\*(C`trigger\*(C'\fR.
.PP
The example class is a classic binary tree. Each node in the tree is
itself an instance of \f(CW\*(C`BinaryTree\*(C'\fR. It has a \f(CW\*(C`node\*(C'\fR, which holds
some arbitrary value. It has \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR attributes, which
refer to its child trees, and a \f(CW\*(C`parent\*(C'\fR.
.PP
Let's take a look at the \f(CW\*(C`node\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
.Ve
.PP
Moose generates a read-write accessor for this attribute. The type
constraint is \f(CW\*(C`Any\*(C'\fR, which literally means it can contain anything.
.PP
We could have left out the \f(CW\*(C`isa\*(C'\fR option, but in this case, we are
including it for the benefit of other programmers, not the computer.
.PP
Next, let's move on to the \f(CW\*(C`parent\*(C'\fR attribute:
.PP
.Vb 6
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
.Ve
.PP
Again, we have a read-write accessor. This time, the \f(CW\*(C`isa\*(C'\fR option
says that this attribute must always be an instance of
\&\f(CW\*(C`BinaryTree\*(C'\fR. In the second recipe, we saw that every time we create
a Moose-based class, we also get a corresponding class type
constraint.
.PP
The \f(CW\*(C`predicate\*(C'\fR option is new. It creates a method which can be used
to check whether or not a given attribute has been initialized. In
this case, the method is named \f(CW\*(C`has_parent\*(C'\fR.
.PP
This brings us to our last attribute option, \f(CW\*(C`weak_ref\*(C'\fR. Since
\&\f(CW\*(C`parent\*(C'\fR is a circular reference (the tree in \f(CW\*(C`parent\*(C'\fR should
already have a reference to this one, in its \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR
attribute), we want to make sure that we weaken the reference to avoid
memory leaks. If \f(CW\*(C`weak_ref\*(C'\fR is true, it alters the accessor function
so that the reference is weakened when it is set.
.PP
Finally, we have the the \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes. They are
essentially identical except for their names, so we'll just look at
\&\f(CW\*(C`left\*(C'\fR:
.PP
.Vb 8
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
.Ve
.PP
There are three new options here, \f(CW\*(C`lazy\*(C'\fR, \f(CW\*(C`default\*(C'\fR, and
\&\f(CW\*(C`trigger\*(C'\fR. The \f(CW\*(C`lazy\*(C'\fR and \f(CW\*(C`default\*(C'\fR options options are linked.  In
fact, you cannot have a \f(CW\*(C`lazy\*(C'\fR attribute unless it has a \f(CW\*(C`default\*(C'\fR
(or a \f(CW\*(C`builder\*(C'\fR, but we'll cover that later). If you try to make an
attribute lazy without a default, class creation will fail with an
exception. (2)
.PP
In the second recipe the \fBBankAccount\fR's \f(CW\*(C`balance\*(C'\fR attribute had a
default value of \f(CW0\fR. Given a non-reference, Perl copies the
\&\fIvalue\fR. However, given a reference, it does not do a deep clone,
instead simply copying the reference. If you just specified a simple
reference for a default, Perl would create it once and it would be
shared by all objects with that attribute.
.PP
As a workaround, we use an anonymous subroutine to generate a new
reference every time the default is called.
.PP
.Vb 1
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => sub { [] } );
.Ve
.PP
In fact, using a non-subroutine reference as a default is illegal in Moose.
.PP
.Vb 2
\&  # will fail
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => [] );
.Ve
.PP
This will blow up, so don't do it.
.PP
You'll notice that we use \f(CW$_[0]\fR in our default sub. When the
default subroutine is executed, it is called as a method on the
object.
.PP
In our case, we're making a new \f(CW\*(C`BinaryTree\*(C'\fR object in our default,
with the current tree as the parent.
.PP
Normally, when an object is instantiated, any defaults are evaluated
immediately. With our \f(CW\*(C`BinaryTree\*(C'\fR class, this would be a big
problem! We'd create the first object, which would immediately try to
populate its \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes, which would create a new
\&\f(CW\*(C`BinaryTree\*(C'\fR, which would populate \fIits\fR \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR
slots. Kaboom!
.PP
By making our \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes \f(CW\*(C`lazy\*(C'\fR, we avoid this
problem. If the attribute has a value when it is read, the default is
never executed at all.
.PP
We still have one last bit of behavior to add. The autogenerated
\&\f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR accessors are not quite correct. When one of
these is set, we want to make sure that we update the parent of the
\&\f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute's tree.
.PP
We could write our own accessors, but then why use Moose at all?
Instead, we use a \f(CW\*(C`trigger\*(C'\fR. A \f(CW\*(C`trigger\*(C'\fR accepts a subroutine
reference, which will be called as a method whenever the attribute is
set. This can happen both during object construction or later by
passing a new object to the attribute's accessor method. However, it
is not called when a value is provided by a \f(CW\*(C`default\*(C'\fR or \f(CW\*(C`builder\*(C'\fR.
.PP
.Vb 2
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.PP
This trigger does two things. First, it ensures that the new child
node does not already have a parent. This is done for the sake of
simplifying the example. If we wanted to be more clever, we would
remove the child from its old parent tree and add it to the new one.
.PP
If the child has no parent, we will add it to the current tree, and we
ensure that is has the correct value for its \f(CW\*(C`parent\*(C'\fR attribute.
.PP
As with all the other recipes, \fBBinaryTree\fR can be used just like any
other Perl 5 class. A more detailed example of its usage can be found
in \fIt/recipes/moose_cookbook_basics_recipe3.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe introduced several of Moose's advanced features. We hope
that this inspires you to think of other ways these features can be
used to simplify your code.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Weak references are tricky things, and should be used sparingly and
appropriately (such as in the case of circular refs). If you are not
careful, attribute values could disappear \*(L"mysteriously\*(R" because
Perl's reference counting garbage collector has gone and removed the
item you are weak-referencing.
.Sp
In short, don't use them unless you know what you are doing :)
.IP "(2)" 4
.IX Item "(2)"
You \fIcan\fR use the \f(CW\*(C`default\*(C'\fR option without the \f(CW\*(C`lazy\*(C'\fR option if you
like, as we showed in the second recipe.
.Sp
Also, you can use \f(CW\*(C`builder\*(C'\fR instead of \f(CW\*(C`default\*(C'\fR. See
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                       Moose::Cookbook::Basics::BinaryTree_AttributeFeatures5.18.3pm                                       0100644 0001750 0001750 00000033203 12566242161 033675  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3"
.TH Moose::Cookbook::Basics::BinaryTree_AttributeFeatures 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures \- Demonstrates various attribute features including lazy, predicates, weak refs, and more
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
\&
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how various advanced attribute features can be used
to create complex and powerful behaviors. In particular, we introduce
a number of new attribute options, including \f(CW\*(C`predicate\*(C'\fR, \f(CW\*(C`lazy\*(C'\fR,
and \f(CW\*(C`trigger\*(C'\fR.
.PP
The example class is a classic binary tree. Each node in the tree is
itself an instance of \f(CW\*(C`BinaryTree\*(C'\fR. It has a \f(CW\*(C`node\*(C'\fR, which holds
some arbitrary value. It has \f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR attributes, which
refer to its child trees, and a \f(CW\*(C`parent\*(C'\fR.
.PP
Let's take a look at the \f(CW\*(C`node\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqnode\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq );
.Ve
.PP
Moose generates a read-write accessor for this attribute. The type
constraint is \f(CW\*(C`Any\*(C'\fR, which literally means it can contain anything.
.PP
We could have left out the \f(CW\*(C`isa\*(C'\fR option, but in this case, we are
including it for the benefit of other programmers, not the computer.
.PP
Next, let's move on to the \f(CW\*(C`parent\*(C'\fR attribute:
.PP
.Vb 6
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
.Ve
.PP
Again, we have a read-write accessor. This time, the \f(CW\*(C`isa\*(C'\fR option
says that this attribute must always be an instance of
\&\f(CW\*(C`BinaryTree\*(C'\fR. In the second recipe, we saw that every time we create
a Moose-based class, we also get a corresponding class type
constraint.
.PP
The \f(CW\*(C`predicate\*(C'\fR option is new. It creates a method which can be used
to check whether or not a given attribute has been initialized. In
this case, the method is named \f(CW\*(C`has_parent\*(C'\fR.
.PP
This brings us to our last attribute option, \f(CW\*(C`weak_ref\*(C'\fR. Since
\&\f(CW\*(C`parent\*(C'\fR is a circular reference (the tree in \f(CW\*(C`parent\*(C'\fR should
already have a reference to this one, in its \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR
attribute), we want to make sure that we weaken the reference to avoid
memory leaks. If \f(CW\*(C`weak_ref\*(C'\fR is true, it alters the accessor function
so that the reference is weakened when it is set.
.PP
Finally, we have the \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes. They are
essentially identical except for their names, so we'll just look at
\&\f(CW\*(C`left\*(C'\fR:
.PP
.Vb 8
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      default   => sub { BinaryTree\->new( parent => $_[0] ) },
\&      trigger   => \e&_set_parent_for_child
\&  );
.Ve
.PP
There are three new options here, \f(CW\*(C`lazy\*(C'\fR, \f(CW\*(C`default\*(C'\fR, and
\&\f(CW\*(C`trigger\*(C'\fR. The \f(CW\*(C`lazy\*(C'\fR and \f(CW\*(C`default\*(C'\fR options are linked.  In fact,
you cannot have a \f(CW\*(C`lazy\*(C'\fR attribute unless it has a \f(CW\*(C`default\*(C'\fR
(or a \f(CW\*(C`builder\*(C'\fR, but we'll cover that later). If you try to make an
attribute lazy without a default, class creation will fail with an
exception. (2)
.PP
In the second recipe the \fBBankAccount\fR's \f(CW\*(C`balance\*(C'\fR attribute had a
default value of \f(CW0\fR. Given a non-reference, Perl copies the
\&\fIvalue\fR. However, given a reference, it does not do a deep clone,
instead simply copying the reference. If you just specified a simple
reference for a default, Perl would create it once and it would be
shared by all objects with that attribute.
.PP
As a workaround, we use an anonymous subroutine to generate a new
reference every time the default is called.
.PP
.Vb 1
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => sub { [] } );
.Ve
.PP
In fact, using a non-subroutine reference as a default is illegal in Moose.
.PP
.Vb 2
\&  # will fail
\&  has \*(Aqfoo\*(Aq => ( is => \*(Aqrw\*(Aq, default => [] );
.Ve
.PP
This will blow up, so don't do it.
.PP
You'll notice that we use \f(CW$_[0]\fR in our default sub. When the
default subroutine is executed, it is called as a method on the
object.
.PP
In our case, we're making a new \f(CW\*(C`BinaryTree\*(C'\fR object in our default,
with the current tree as the parent.
.PP
Normally, when an object is instantiated, any defaults are evaluated
immediately. With our \f(CW\*(C`BinaryTree\*(C'\fR class, this would be a big
problem! We'd create the first object, which would immediately try to
populate its \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes, which would create a new
\&\f(CW\*(C`BinaryTree\*(C'\fR, which would populate \fIits\fR \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR
slots. Kaboom!
.PP
By making our \f(CW\*(C`left\*(C'\fR and \f(CW\*(C`right\*(C'\fR attributes \f(CW\*(C`lazy\*(C'\fR, we avoid this
problem. If the attribute has a value when it is read, the default is
never executed at all.
.PP
We still have one last bit of behavior to add. The autogenerated
\&\f(CW\*(C`right\*(C'\fR and \f(CW\*(C`left\*(C'\fR accessors are not quite correct. When one of
these is set, we want to make sure that we update the parent of the
\&\f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute's tree.
.PP
We could write our own accessors, but then why use Moose at all?
Instead, we use a \f(CW\*(C`trigger\*(C'\fR. A \f(CW\*(C`trigger\*(C'\fR accepts a subroutine
reference, which will be called as a method whenever the attribute is
set. This can happen both during object construction or later by
passing a new object to the attribute's accessor method. However, it
is not called when a value is provided by a \f(CW\*(C`default\*(C'\fR or \f(CW\*(C`builder\*(C'\fR.
.PP
.Vb 2
\&  sub _set_parent_for_child {
\&      my ( $self, $child ) = @_;
\&
\&      confess "You cannot insert a tree which already has a parent"
\&          if $child\->has_parent;
\&
\&      $child\->parent($self);
\&  }
.Ve
.PP
This trigger does two things. First, it ensures that the new child
node does not already have a parent. This is done for the sake of
simplifying the example. If we wanted to be more clever, we would
remove the child from its old parent tree and add it to the new one.
.PP
If the child has no parent, we will add it to the current tree, and we
ensure that is has the correct value for its \f(CW\*(C`parent\*(C'\fR attribute.
.PP
As with all the other recipes, \fBBinaryTree\fR can be used just like any
other Perl 5 class. A more detailed example of its usage can be found
in \fIt/recipes/moose_cookbook_basics_recipe3.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe introduced several of Moose's advanced features. We hope
that this inspires you to think of other ways these features can be
used to simplify your code.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Weak references are tricky things, and should be used sparingly and
appropriately (such as in the case of circular refs). If you are not
careful, attribute values could disappear \*(L"mysteriously\*(R" because
Perl's reference counting garbage collector has gone and removed the
item you are weak-referencing.
.Sp
In short, don't use them unless you know what you are doing :)
.IP "(2)" 4
.IX Item "(2)"
You \fIcan\fR use the \f(CW\*(C`default\*(C'\fR option without the \f(CW\*(C`lazy\*(C'\fR option if you
like, as we showed in the second recipe.
.Sp
Also, you can use \f(CW\*(C`builder\*(C'\fR instead of \f(CW\*(C`default\*(C'\fR. See
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for details.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                             Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild.3pm                                         0100644 0001750 0001750 00000021051 12566242162 033547  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3"
.TH Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  before \*(Aqright\*(Aq, \*(Aqleft\*(Aq => sub {
\&      my ($self, $tree) = @_;
\&      $tree\->parent($self) if defined $tree;
\&  };
\&
\&  sub _build_child_tree {
\&      my $self = shift;
\&
\&      return BinaryTree\->new( parent => $self );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you've already read
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures, then this example
should look very familiar. In fact, all we've done here is replace the
attribute's \f(CW\*(C`default\*(C'\fR parameter with a \f(CW\*(C`builder\*(C'\fR.
.PP
In this particular case, the \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR options act in
exactly the same way. When the \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute is read,
Moose calls the builder method to initialize the attribute.
.PP
Note that Moose calls the builder method \fIon the object which has the
attribute\fR. Here's an example:
.PP
.Vb 1
\&  my $tree = BinaryTree\->new();
\&
\&  my $left = $tree\->left();
.Ve
.PP
When \f(CW\*(C`$tree\->left()\*(C'\fR is called, Moose calls \f(CW\*(C`$tree\->_build_child_tree()\*(C'\fR in order to populate the \f(CW\*(C`left\*(C'\fR
attribute. If we had passed \f(CW\*(C`left\*(C'\fR to the original constructor, the
builder would not be called.
.PP
There are some differences between \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR. Notably,
a builder is subclassable, and can be composed from a role. See
Moose::Manual::Attributes for more details.
.SS "The lazy_build shortcut"
.IX Subsection "The lazy_build shortcut"
The \f(CW\*(C`lazy_build\*(C'\fR attribute option can be used as sugar to specify
a whole set of attribute options at once:
.PP
.Vb 5
\&  has \*(Aqanimal\*(Aq => (
\&      is         => \*(Aqro\*(Aq,
\&      isa        => \*(AqAnimal\*(Aq,
\&      lazy_build => 1,
\&  );
.Ve
.PP
This is a shorthand for:
.PP
.Vb 9
\&  has \*(Aqanimal\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqAnimal\*(Aq,
\&      required  => 1,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_animal\*(Aq,
\&      predicate => \*(Aqhas_animal\*(Aq,
\&      clearer   => \*(Aqclear_animal\*(Aq,
\&  );
.Ve
.PP
If your attribute starts with an underscore, Moose is smart and will
do the right thing with the \f(CW\*(C`predicate\*(C'\fR and \f(CW\*(C`clearer\*(C'\fR, making them
both start with an underscore. The \f(CW\*(C`builder\*(C'\fR method \fIalways\fR starts
with an underscore.
.PP
You can read more about \f(CW\*(C`lazy_build\*(C'\fR in Moose::Meta::Attribute
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`builder\*(C'\fR option is a more OO-friendly version of the \f(CW\*(C`default\*(C'\fR
functionality. It also separates the default-generating code into a
well-defined method. Sprinkling your attribute definitions with
anonymous subroutines can be quite ugly and hard to follow.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild5.16.3pm                                     0100644 0001750 0001750 00000020003 12566242166 034061  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3"
.TH Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  before \*(Aqright\*(Aq, \*(Aqleft\*(Aq => sub {
\&      my ($self, $tree) = @_;
\&      $tree\->parent($self) if defined $tree;
\&  };
\&
\&  sub _build_child_tree {
\&      my $self = shift;
\&
\&      return BinaryTree\->new( parent => $self );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you've already read
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures, then this example
should look very familiar. In fact, all we've done here is replace the
attribute's \f(CW\*(C`default\*(C'\fR parameter with a \f(CW\*(C`builder\*(C'\fR.
.PP
In this particular case, the \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR options act in
exactly the same way. When the \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute is read,
Moose calls the builder method to initialize the attribute.
.PP
Note that Moose calls the builder method \fIon the object which has the
attribute\fR. Here's an example:
.PP
.Vb 1
\&  my $tree = BinaryTree\->new();
\&
\&  my $left = $tree\->left();
.Ve
.PP
When \f(CW\*(C`$tree\->left()\*(C'\fR is called, Moose calls \f(CW\*(C`$tree\->_build_child_tree()\*(C'\fR in order to populate the \f(CW\*(C`left\*(C'\fR
attribute. If we had passed \f(CW\*(C`left\*(C'\fR to the original constructor, the
builder would not be called.
.PP
There are some differences between \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR. Notably,
a builder is subclassable, and can be composed from a role. See
Moose::Manual::Attributes for more details.
.SS "The lazy_build shortcut"
.IX Subsection "The lazy_build shortcut"
The \f(CW\*(C`lazy_build\*(C'\fR attribute option can be used as sugar to specify
a whole set of attribute options at once:
.PP
.Vb 5
\&  has \*(Aqanimal\*(Aq => (
\&      is         => \*(Aqro\*(Aq,
\&      isa        => \*(AqAnimal\*(Aq,
\&      lazy_build => 1,
\&  );
.Ve
.PP
This is a shorthand for:
.PP
.Vb 9
\&  has \*(Aqanimal\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqAnimal\*(Aq,
\&      required  => 1,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_animal\*(Aq,
\&      predicate => \*(Aqhas_animal\*(Aq,
\&      clearer   => \*(Aqclear_animal\*(Aq,
\&  );
.Ve
.PP
If your attribute starts with an underscore, Moose is smart and will
do the right thing with the \f(CW\*(C`predicate\*(C'\fR and \f(CW\*(C`clearer\*(C'\fR, making them
both start with an underscore. The \f(CW\*(C`builder\*(C'\fR method \fIalways\fR starts
with an underscore.
.PP
You can read more about \f(CW\*(C`lazy_build\*(C'\fR in Moose::Meta::Attribute
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`builder\*(C'\fR option is a more OO-friendly version of the \f(CW\*(C`default\*(C'\fR
functionality. It also separates the default-generating code into a
well-defined method. Sprinkling your attribute definitions with
anonymous subroutines can be quite ugly and hard to follow.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild5.18.3pm                                     0100644 0001750 0001750 00000021051 12566242162 034063  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3"
.TH Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild \- Builder methods and lazy_build
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package BinaryTree;
\&  use Moose;
\&
\&  has \*(Aqnode\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqAny\*(Aq);
\&
\&  has \*(Aqparent\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_parent\*(Aq,
\&      weak_ref  => 1,
\&  );
\&
\&  has \*(Aqleft\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_left\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  has \*(Aqright\*(Aq => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqBinaryTree\*(Aq,
\&      predicate => \*(Aqhas_right\*(Aq,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_child_tree\*(Aq,
\&  );
\&
\&  before \*(Aqright\*(Aq, \*(Aqleft\*(Aq => sub {
\&      my ($self, $tree) = @_;
\&      $tree\->parent($self) if defined $tree;
\&  };
\&
\&  sub _build_child_tree {
\&      my $self = shift;
\&
\&      return BinaryTree\->new( parent => $self );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you've already read
Moose::Cookbook::Basics::BinaryTree_AttributeFeatures, then this example
should look very familiar. In fact, all we've done here is replace the
attribute's \f(CW\*(C`default\*(C'\fR parameter with a \f(CW\*(C`builder\*(C'\fR.
.PP
In this particular case, the \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR options act in
exactly the same way. When the \f(CW\*(C`left\*(C'\fR or \f(CW\*(C`right\*(C'\fR attribute is read,
Moose calls the builder method to initialize the attribute.
.PP
Note that Moose calls the builder method \fIon the object which has the
attribute\fR. Here's an example:
.PP
.Vb 1
\&  my $tree = BinaryTree\->new();
\&
\&  my $left = $tree\->left();
.Ve
.PP
When \f(CW\*(C`$tree\->left()\*(C'\fR is called, Moose calls \f(CW\*(C`$tree\->_build_child_tree()\*(C'\fR in order to populate the \f(CW\*(C`left\*(C'\fR
attribute. If we had passed \f(CW\*(C`left\*(C'\fR to the original constructor, the
builder would not be called.
.PP
There are some differences between \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR. Notably,
a builder is subclassable, and can be composed from a role. See
Moose::Manual::Attributes for more details.
.SS "The lazy_build shortcut"
.IX Subsection "The lazy_build shortcut"
The \f(CW\*(C`lazy_build\*(C'\fR attribute option can be used as sugar to specify
a whole set of attribute options at once:
.PP
.Vb 5
\&  has \*(Aqanimal\*(Aq => (
\&      is         => \*(Aqro\*(Aq,
\&      isa        => \*(AqAnimal\*(Aq,
\&      lazy_build => 1,
\&  );
.Ve
.PP
This is a shorthand for:
.PP
.Vb 9
\&  has \*(Aqanimal\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqAnimal\*(Aq,
\&      required  => 1,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_animal\*(Aq,
\&      predicate => \*(Aqhas_animal\*(Aq,
\&      clearer   => \*(Aqclear_animal\*(Aq,
\&  );
.Ve
.PP
If your attribute starts with an underscore, Moose is smart and will
do the right thing with the \f(CW\*(C`predicate\*(C'\fR and \f(CW\*(C`clearer\*(C'\fR, making them
both start with an underscore. The \f(CW\*(C`builder\*(C'\fR method \fIalways\fR starts
with an underscore.
.PP
You can read more about \f(CW\*(C`lazy_build\*(C'\fR in Moose::Meta::Attribute
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`builder\*(C'\fR option is a more OO-friendly version of the \f(CW\*(C`default\*(C'\fR
functionality. It also separates the default-generating code into a
well-defined method. Sprinkling your attribute definitions with
anonymous subroutines can be quite ugly and hard to follow.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook::Basics::Company_Subtypes.3pm0100644 0001750 0001750 00000040247 12566242161 031164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Company_Subtypes 3"
.TH Moose::Cookbook::Basics::Company_Subtypes 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Company_Subtypes \- Demonstrates the use of subtypes and how to model classes related to companies, people, employees, etc.
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Address;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use Locale::US;
\&  use Regexp::Common \*(Aqzip\*(Aq;
\&
\&  my $STATES = Locale::US\->new;
\&  subtype \*(AqUSState\*(Aq
\&      => as Str
\&      => where {
\&             (    exists $STATES\->{code2state}{ uc($_) }
\&               || exists $STATES\->{state2code}{ uc($_) } );
\&         };
\&
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
\&
\&  has \*(Aqstreet\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqcity\*(Aq     => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
\&  has \*(Aqzip_code\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSZipCode\*(Aq );
\&
\&  package Company;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq,
\&      default => sub { [] },
\&  );
\&
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
\&
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
\&
\&  package Person;
\&  use Moose;
\&
\&  has \*(Aqfirst_name\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqlast_name\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqmiddle_initial\*(Aq => (
\&      is        => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_middle_initial\*(Aq
\&  );
\&  has \*(Aqaddress\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&
\&  sub full_name {
\&      my $self = shift;
\&      return $self\->first_name
\&          . (
\&          $self\->has_middle_initial
\&          ? \*(Aq \*(Aq . $self\->middle_initial . \*(Aq. \*(Aq
\&          : \*(Aq \*(Aq
\&          ) . $self\->last_name;
\&  }
\&
\&  package Employee;
\&  use Moose;
\&
\&  extends \*(AqPerson\*(Aq;
\&
\&  has \*(Aqtitle\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,     required => 1 );
\&  has \*(Aqemployer\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqCompany\*(Aq, weak_ref => 1 );
\&
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces the \f(CW\*(C`subtype\*(C'\fR sugar function from
Moose::Util::TypeConstraints. The \f(CW\*(C`subtype\*(C'\fR function lets you
declaratively create type constraints without building an entire
class.
.PP
In the recipe we also make use of Locale::US and Regexp::Common
to build constraints, showing how constraints can make use of existing
\&\s-1CPAN\s0 tools for data validation.
.PP
Finally, we introduce the \f(CW\*(C`required\*(C'\fR attribute option.
.PP
In the \f(CW\*(C`Address\*(C'\fR class we define two subtypes. The first uses the
Locale::US module to check the validity of a state. It accepts
either a state abbreviation of full name.
.PP
A state will be passed in as a string, so we make our \f(CW\*(C`USState\*(C'\fR type
a subtype of Moose's builtin \f(CW\*(C`Str\*(C'\fR type. This is done using the \f(CW\*(C`as\*(C'\fR
sugar. The actual constraint is defined using \f(CW\*(C`where\*(C'\fR. This function
accepts a single subroutine reference. That subroutine will be called
with the value to be checked in \f(CW$_\fR (1). It is expected to return a
true or false value indicating whether the value is valid for the
type.
.PP
We can now use the \f(CW\*(C`USState\*(C'\fR type just like Moose's builtin types:
.PP
.Vb 1
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
.Ve
.PP
When the \f(CW\*(C`state\*(C'\fR attribute is set, the value is checked against the
\&\f(CW\*(C`USState\*(C'\fR constraint. If the value is not valid, an exception will be
thrown.
.PP
The next \f(CW\*(C`subtype\*(C'\fR, \f(CW\*(C`USZipCode\*(C'\fR, uses
Regexp::Common. Regexp::Common includes a regex for validating
\&\s-1US\s0 zip codes. We use this constraint for the \f(CW\*(C`zip_code\*(C'\fR attribute.
.PP
.Vb 5
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
.Ve
.PP
Using a subtype instead of requiring a class for each type greatly
simplifies the code. We don't really need a class for these types, as
they're just strings, but we do want to ensure that they're valid.
.PP
The type constraints we created are reusable. Type constraints are
stored by name in a global registry, which means that we can refer to
them in other classes. Because the registry is global, we do recommend
that you use some sort of namespacing in real applications,
like \f(CW\*(C`MyApp::Type::USState\*(C'\fR (just as you would do with class names).
.PP
These two subtypes allow us to define a simple \f(CW\*(C`Address\*(C'\fR class.
.PP
Then we define our \f(CW\*(C`Company\*(C'\fR class, which has an address. As we saw
in earlier recipes, Moose automatically creates a type constraint for
each our classes, so we can use that for the \f(CW\*(C`Company\*(C'\fR class's
\&\f(CW\*(C`address\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
.Ve
.PP
A company also needs a name:
.PP
.Vb 1
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
.Ve
.PP
This introduces a new attribute option, \f(CW\*(C`required\*(C'\fR. If an attribute
is required, then it must be passed to the class's constructor, or an
exception will be thrown. It's important to understand that a
\&\f(CW\*(C`required\*(C'\fR attribute can still be false or \f(CW\*(C`undef\*(C'\fR, if its type
constraint allows that.
.PP
The next attribute, \f(CW\*(C`employees\*(C'\fR, uses a \fIparameterized\fR type
constraint:
.PP
.Vb 5
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq
\&      default => sub { [] },
\&  );
.Ve
.PP
This constraint says that \f(CW\*(C`employees\*(C'\fR must be an array reference
where each element of the array is an \f(CW\*(C`Employee\*(C'\fR object. It's worth
noting that an \fIempty\fR array reference also satisfies this
constraint, such as the value given as the default here.
.PP
Parameterizable type constraints (or \*(L"container types\*(R"), such as
\&\f(CW\*(C`ArrayRef[\`a]\*(C'\fR, can be made more specific with a type parameter. In
fact, we can arbitrarily nest these types, producing something like
\&\f(CW\*(C`HashRef[ArrayRef[Int]]\*(C'\fR. However, you can also just use the type by
itself, so \f(CW\*(C`ArrayRef\*(C'\fR is legal. (2)
.PP
If you jump down to the definition of the \f(CW\*(C`Employee\*(C'\fR class, you will
see that it has an \f(CW\*(C`employer\*(C'\fR attribute.
.PP
When we set the \f(CW\*(C`employees\*(C'\fR for a \f(CW\*(C`Company\*(C'\fR we want to make sure
that each of these employee objects refers back to the right
\&\f(CW\*(C`Company\*(C'\fR in its \f(CW\*(C`employer\*(C'\fR attribute.
.PP
To do that, we need to hook into object construction. Moose lets us do
this by writing a \f(CW\*(C`BUILD\*(C'\fR method in our class. When your class
defines a \f(CW\*(C`BUILD\*(C'\fR method, it will be called by the constructor
immediately after object construction, but before the object is returned
to the caller. Note that all \f(CW\*(C`BUILD\*(C'\fR methods in your class hierarchy
will be called automatically; there is no need to (and you should not)
call the superclass \f(CW\*(C`BUILD\*(C'\fR method.
.PP
The \f(CW\*(C`Company\*(C'\fR class uses the \f(CW\*(C`BUILD\*(C'\fR method to ensure that each
employee of a company has the proper \f(CW\*(C`Company\*(C'\fR object in its
\&\f(CW\*(C`employer\*(C'\fR attribute:
.PP
.Vb 6
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
.Ve
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is executed after type constraints are checked, so it is
safe to assume that if \f(CW\*(C`$self\->employees\*(C'\fR has a value, it will be an
array reference, and that the elements of that array reference will be
\&\f(CW\*(C`Employee\*(C'\fR objects.
.PP
We also want to make sure that whenever the \f(CW\*(C`employees\*(C'\fR attribute for
a \f(CW\*(C`Company\*(C'\fR is changed, we also update the \f(CW\*(C`employer\*(C'\fR for each
employee.
.PP
To do this we can use an \f(CW\*(C`after\*(C'\fR modifier:
.PP
.Vb 7
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
.Ve
.PP
Again, as with the \f(CW\*(C`BUILD\*(C'\fR method, we know that the type constraint check has
already happened, so we know that if \f(CW$employees\fR is defined it will contain
an array reference of \f(CW\*(C`Employee\*(C'\fR objects.
.PP
Note that \f(CW\*(C`employees\*(C'\fR is a read/write accessor, so we must return early if
it's called as a reader.
.PP
The \fBPerson\fR class does not really demonstrate anything new. It has several
\&\f(CW\*(C`required\*(C'\fR attributes. It also has a \f(CW\*(C`predicate\*(C'\fR method, which we
first used in Moose::Cookbook::Basics::BinaryTree_AttributeFeatures.
.PP
The only new feature in the \f(CW\*(C`Employee\*(C'\fR class is the \f(CW\*(C`override\*(C'\fR
method modifier:
.PP
.Vb 4
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.PP
This is just a sugary alternative to Perl's built in \f(CW\*(C`SUPER::\*(C'\fR
feature. However, there is one difference. You cannot pass any
arguments to \f(CW\*(C`super\*(C'\fR. Instead, Moose simply passes the same
parameters that were passed to the method.
.PP
A more detailed example of usage can be found in
\&\fIt/recipes/moose_cookbook_basics_recipe4.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe was intentionally longer and more complex. It illustrates
how Moose classes can be used together with type constraints, as well
as the density of information that you can get out of a small amount
of typing when using Moose.
.PP
This recipe also introduced the \f(CW\*(C`subtype\*(C'\fR function, the \f(CW\*(C`required\*(C'\fR
attribute, and the \f(CW\*(C`override\*(C'\fR method modifier.
.PP
We will revisit type constraints in future recipes, and cover type
coercion as well.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
The value being checked is also passed as the first argument to
the \f(CW\*(C`where\*(C'\fR block, so it can be accessed as \f(CW$_[0]\fR.
.IP "(2)" 4
.IX Item "(2)"
Note that \f(CW\*(C`ArrayRef[]\*(C'\fR will not work. Moose will not parse this as a
container type, and instead you will have a new type named
\&\*(L"ArrayRef[]\*(R", which doesn't make any sense.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                         Moose::Cookbook::Basics::Company_Subtypes5.16.3pm                                                   0100644 0001750 0001750 00000037201 12566242166 031420  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Company_Subtypes 3"
.TH Moose::Cookbook::Basics::Company_Subtypes 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Company_Subtypes \- Demonstrates the use of subtypes and how to model classes related to companies, people, employees, etc.
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Address;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use Locale::US;
\&  use Regexp::Common \*(Aqzip\*(Aq;
\&
\&  my $STATES = Locale::US\->new;
\&  subtype \*(AqUSState\*(Aq
\&      => as Str
\&      => where {
\&             (    exists $STATES\->{code2state}{ uc($_) }
\&               || exists $STATES\->{state2code}{ uc($_) } );
\&         };
\&
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
\&
\&  has \*(Aqstreet\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqcity\*(Aq     => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
\&  has \*(Aqzip_code\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSZipCode\*(Aq );
\&
\&  package Company;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq,
\&      default => sub { [] },
\&  );
\&
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
\&
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
\&
\&  package Person;
\&  use Moose;
\&
\&  has \*(Aqfirst_name\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqlast_name\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqmiddle_initial\*(Aq => (
\&      is        => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_middle_initial\*(Aq
\&  );
\&  has \*(Aqaddress\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&
\&  sub full_name {
\&      my $self = shift;
\&      return $self\->first_name
\&          . (
\&          $self\->has_middle_initial
\&          ? \*(Aq \*(Aq . $self\->middle_initial . \*(Aq. \*(Aq
\&          : \*(Aq \*(Aq
\&          ) . $self\->last_name;
\&  }
\&
\&  package Employee;
\&  use Moose;
\&
\&  extends \*(AqPerson\*(Aq;
\&
\&  has \*(Aqtitle\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,     required => 1 );
\&  has \*(Aqemployer\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqCompany\*(Aq, weak_ref => 1 );
\&
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces the \f(CW\*(C`subtype\*(C'\fR sugar function from
Moose::Util::TypeConstraints. The \f(CW\*(C`subtype\*(C'\fR function lets you
declaratively create type constraints without building an entire
class.
.PP
In the recipe we also make use of Locale::US and Regexp::Common
to build constraints, showing how constraints can make use of existing
\&\s-1CPAN\s0 tools for data validation.
.PP
Finally, we introduce the \f(CW\*(C`required\*(C'\fR attribute option.
.PP
In the \f(CW\*(C`Address\*(C'\fR class we define two subtypes. The first uses the
Locale::US module to check the validity of a state. It accepts
either a state abbreviation of full name.
.PP
A state will be passed in as a string, so we make our \f(CW\*(C`USState\*(C'\fR type
a subtype of Moose's builtin \f(CW\*(C`Str\*(C'\fR type. This is done using the \f(CW\*(C`as\*(C'\fR
sugar. The actual constraint is defined using \f(CW\*(C`where\*(C'\fR. This function
accepts a single subroutine reference. That subroutine will be called
with the value to be checked in \f(CW$_\fR (1). It is expected to return a
true or false value indicating whether the value is valid for the
type.
.PP
We can now use the \f(CW\*(C`USState\*(C'\fR type just like Moose's builtin types:
.PP
.Vb 1
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
.Ve
.PP
When the \f(CW\*(C`state\*(C'\fR attribute is set, the value is checked against the
\&\f(CW\*(C`USState\*(C'\fR constraint. If the value is not valid, an exception will be
thrown.
.PP
The next \f(CW\*(C`subtype\*(C'\fR, \f(CW\*(C`USZipCode\*(C'\fR, uses
Regexp::Common. Regexp::Common includes a regex for validating
\&\s-1US\s0 zip codes. We use this constraint for the \f(CW\*(C`zip_code\*(C'\fR attribute.
.PP
.Vb 5
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
.Ve
.PP
Using a subtype instead of requiring a class for each type greatly
simplifies the code. We don't really need a class for these types, as
they're just strings, but we do want to ensure that they're valid.
.PP
The type constraints we created are reusable. Type constraints are
stored by name in a global registry, which means that we can refer to
them in other classes. Because the registry is global, we do recommend
that you use some sort of namespacing in real applications,
like \f(CW\*(C`MyApp::Type::USState\*(C'\fR (just as you would do with class names).
.PP
These two subtypes allow us to define a simple \f(CW\*(C`Address\*(C'\fR class.
.PP
Then we define our \f(CW\*(C`Company\*(C'\fR class, which has an address. As we saw
in earlier recipes, Moose automatically creates a type constraint for
each our classes, so we can use that for the \f(CW\*(C`Company\*(C'\fR class's
\&\f(CW\*(C`address\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
.Ve
.PP
A company also needs a name:
.PP
.Vb 1
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
.Ve
.PP
This introduces a new attribute option, \f(CW\*(C`required\*(C'\fR. If an attribute
is required, then it must be passed to the class's constructor, or an
exception will be thrown. It's important to understand that a
\&\f(CW\*(C`required\*(C'\fR attribute can still be false or \f(CW\*(C`undef\*(C'\fR, if its type
constraint allows that.
.PP
The next attribute, \f(CW\*(C`employees\*(C'\fR, uses a \fIparameterized\fR type
constraint:
.PP
.Vb 5
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq
\&      default => sub { [] },
\&  );
.Ve
.PP
This constraint says that \f(CW\*(C`employees\*(C'\fR must be an array reference
where each element of the array is an \f(CW\*(C`Employee\*(C'\fR object. It's worth
noting that an \fIempty\fR array reference also satisfies this
constraint, such as the value given as the default here.
.PP
Parameterizable type constraints (or \*(L"container types\*(R"), such as
\&\f(CW\*(C`ArrayRef[\`a]\*(C'\fR, can be made more specific with a type parameter. In
fact, we can arbitrarily nest these types, producing something like
\&\f(CW\*(C`HashRef[ArrayRef[Int]]\*(C'\fR. However, you can also just use the type by
itself, so \f(CW\*(C`ArrayRef\*(C'\fR is legal. (2)
.PP
If you jump down to the definition of the \f(CW\*(C`Employee\*(C'\fR class, you will
see that it has an \f(CW\*(C`employer\*(C'\fR attribute.
.PP
When we set the \f(CW\*(C`employees\*(C'\fR for a \f(CW\*(C`Company\*(C'\fR we want to make sure
that each of these employee objects refers back to the right
\&\f(CW\*(C`Company\*(C'\fR in its \f(CW\*(C`employer\*(C'\fR attribute.
.PP
To do that, we need to hook into object construction. Moose lets us do
this by writing a \f(CW\*(C`BUILD\*(C'\fR method in our class. When your class
defines a \f(CW\*(C`BUILD\*(C'\fR method, it will be called by the constructor
immediately after object construction, but before the object is returned
to the caller. Note that all \f(CW\*(C`BUILD\*(C'\fR methods in your class hierarchy
will be called automatically; there is no need to (and you should not)
call the superclass \f(CW\*(C`BUILD\*(C'\fR method.
.PP
The \f(CW\*(C`Company\*(C'\fR class uses the \f(CW\*(C`BUILD\*(C'\fR method to ensure that each
employee of a company has the proper \f(CW\*(C`Company\*(C'\fR object in its
\&\f(CW\*(C`employer\*(C'\fR attribute:
.PP
.Vb 6
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
.Ve
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is executed after type constraints are checked, so it is
safe to assume that if \f(CW\*(C`$self\->employees\*(C'\fR has a value, it will be an
array reference, and that the elements of that array reference will be
\&\f(CW\*(C`Employee\*(C'\fR objects.
.PP
We also want to make sure that whenever the \f(CW\*(C`employees\*(C'\fR attribute for
a \f(CW\*(C`Company\*(C'\fR is changed, we also update the \f(CW\*(C`employer\*(C'\fR for each
employee.
.PP
To do this we can use an \f(CW\*(C`after\*(C'\fR modifier:
.PP
.Vb 7
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
.Ve
.PP
Again, as with the \f(CW\*(C`BUILD\*(C'\fR method, we know that the type constraint check has
already happened, so we know that if \f(CW$employees\fR is defined it will contain
an array reference of \f(CW\*(C`Employee\*(C'\fR objects.
.PP
Note that \f(CW\*(C`employees\*(C'\fR is a read/write accessor, so we must return early if
it's called as a reader.
.PP
The \fBPerson\fR class does not really demonstrate anything new. It has several
\&\f(CW\*(C`required\*(C'\fR attributes. It also has a \f(CW\*(C`predicate\*(C'\fR method, which we
first used in Moose::Cookbook::Basics::BinaryTree_AttributeFeatures.
.PP
The only new feature in the \f(CW\*(C`Employee\*(C'\fR class is the \f(CW\*(C`override\*(C'\fR
method modifier:
.PP
.Vb 4
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.PP
This is just a sugary alternative to Perl's built in \f(CW\*(C`SUPER::\*(C'\fR
feature. However, there is one difference. You cannot pass any
arguments to \f(CW\*(C`super\*(C'\fR. Instead, Moose simply passes the same
parameters that were passed to the method.
.PP
A more detailed example of usage can be found in
\&\fIt/recipes/moose_cookbook_basics_recipe4.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe was intentionally longer and more complex. It illustrates
how Moose classes can be used together with type constraints, as well
as the density of information that you can get out of a small amount
of typing when using Moose.
.PP
This recipe also introduced the \f(CW\*(C`subtype\*(C'\fR function, the \f(CW\*(C`required\*(C'\fR
attribute, and the \f(CW\*(C`override\*(C'\fR method modifier.
.PP
We will revisit type constraints in future recipes, and cover type
coercion as well.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
The value being checked is also passed as the first argument to
the \f(CW\*(C`where\*(C'\fR block, so it can be accessed as \f(CW$_[0]\fR.
.IP "(2)" 4
.IX Item "(2)"
Note that \f(CW\*(C`ArrayRef[]\*(C'\fR will not work. Moose will not parse this as a
container type, and instead you will have a new type named
\&\*(L"ArrayRef[]\*(R", which doesn't make any sense.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                               Moose::Cookbook::Basics::Company_Subtypes5.18.3pm                                                   0100644 0001750 0001750 00000040247 12566242161 031421  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Company_Subtypes 3"
.TH Moose::Cookbook::Basics::Company_Subtypes 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Company_Subtypes \- Demonstrates the use of subtypes and how to model classes related to companies, people, employees, etc.
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Address;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use Locale::US;
\&  use Regexp::Common \*(Aqzip\*(Aq;
\&
\&  my $STATES = Locale::US\->new;
\&  subtype \*(AqUSState\*(Aq
\&      => as Str
\&      => where {
\&             (    exists $STATES\->{code2state}{ uc($_) }
\&               || exists $STATES\->{state2code}{ uc($_) } );
\&         };
\&
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
\&
\&  has \*(Aqstreet\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqcity\*(Aq     => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
\&  has \*(Aqzip_code\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSZipCode\*(Aq );
\&
\&  package Company;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq,
\&      default => sub { [] },
\&  );
\&
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
\&
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
\&
\&  package Person;
\&  use Moose;
\&
\&  has \*(Aqfirst_name\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqlast_name\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
\&  has \*(Aqmiddle_initial\*(Aq => (
\&      is        => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_middle_initial\*(Aq
\&  );
\&  has \*(Aqaddress\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
\&
\&  sub full_name {
\&      my $self = shift;
\&      return $self\->first_name
\&          . (
\&          $self\->has_middle_initial
\&          ? \*(Aq \*(Aq . $self\->middle_initial . \*(Aq. \*(Aq
\&          : \*(Aq \*(Aq
\&          ) . $self\->last_name;
\&  }
\&
\&  package Employee;
\&  use Moose;
\&
\&  extends \*(AqPerson\*(Aq;
\&
\&  has \*(Aqtitle\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq,     required => 1 );
\&  has \*(Aqemployer\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqCompany\*(Aq, weak_ref => 1 );
\&
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces the \f(CW\*(C`subtype\*(C'\fR sugar function from
Moose::Util::TypeConstraints. The \f(CW\*(C`subtype\*(C'\fR function lets you
declaratively create type constraints without building an entire
class.
.PP
In the recipe we also make use of Locale::US and Regexp::Common
to build constraints, showing how constraints can make use of existing
\&\s-1CPAN\s0 tools for data validation.
.PP
Finally, we introduce the \f(CW\*(C`required\*(C'\fR attribute option.
.PP
In the \f(CW\*(C`Address\*(C'\fR class we define two subtypes. The first uses the
Locale::US module to check the validity of a state. It accepts
either a state abbreviation of full name.
.PP
A state will be passed in as a string, so we make our \f(CW\*(C`USState\*(C'\fR type
a subtype of Moose's builtin \f(CW\*(C`Str\*(C'\fR type. This is done using the \f(CW\*(C`as\*(C'\fR
sugar. The actual constraint is defined using \f(CW\*(C`where\*(C'\fR. This function
accepts a single subroutine reference. That subroutine will be called
with the value to be checked in \f(CW$_\fR (1). It is expected to return a
true or false value indicating whether the value is valid for the
type.
.PP
We can now use the \f(CW\*(C`USState\*(C'\fR type just like Moose's builtin types:
.PP
.Vb 1
\&  has \*(Aqstate\*(Aq    => ( is => \*(Aqrw\*(Aq, isa => \*(AqUSState\*(Aq );
.Ve
.PP
When the \f(CW\*(C`state\*(C'\fR attribute is set, the value is checked against the
\&\f(CW\*(C`USState\*(C'\fR constraint. If the value is not valid, an exception will be
thrown.
.PP
The next \f(CW\*(C`subtype\*(C'\fR, \f(CW\*(C`USZipCode\*(C'\fR, uses
Regexp::Common. Regexp::Common includes a regex for validating
\&\s-1US\s0 zip codes. We use this constraint for the \f(CW\*(C`zip_code\*(C'\fR attribute.
.PP
.Vb 5
\&  subtype \*(AqUSZipCode\*(Aq
\&      => as Value
\&      => where {
\&             /^$RE{zip}{US}{\-extended => \*(Aqallow\*(Aq}$/;
\&         };
.Ve
.PP
Using a subtype instead of requiring a class for each type greatly
simplifies the code. We don't really need a class for these types, as
they're just strings, but we do want to ensure that they're valid.
.PP
The type constraints we created are reusable. Type constraints are
stored by name in a global registry, which means that we can refer to
them in other classes. Because the registry is global, we do recommend
that you use some sort of namespacing in real applications,
like \f(CW\*(C`MyApp::Type::USState\*(C'\fR (just as you would do with class names).
.PP
These two subtypes allow us to define a simple \f(CW\*(C`Address\*(C'\fR class.
.PP
Then we define our \f(CW\*(C`Company\*(C'\fR class, which has an address. As we saw
in earlier recipes, Moose automatically creates a type constraint for
each our classes, so we can use that for the \f(CW\*(C`Company\*(C'\fR class's
\&\f(CW\*(C`address\*(C'\fR attribute:
.PP
.Vb 1
\&  has \*(Aqaddress\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqAddress\*(Aq );
.Ve
.PP
A company also needs a name:
.PP
.Vb 1
\&  has \*(Aqname\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, required => 1 );
.Ve
.PP
This introduces a new attribute option, \f(CW\*(C`required\*(C'\fR. If an attribute
is required, then it must be passed to the class's constructor, or an
exception will be thrown. It's important to understand that a
\&\f(CW\*(C`required\*(C'\fR attribute can still be false or \f(CW\*(C`undef\*(C'\fR, if its type
constraint allows that.
.PP
The next attribute, \f(CW\*(C`employees\*(C'\fR, uses a \fIparameterized\fR type
constraint:
.PP
.Vb 5
\&  has \*(Aqemployees\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqArrayRef[Employee]\*(Aq
\&      default => sub { [] },
\&  );
.Ve
.PP
This constraint says that \f(CW\*(C`employees\*(C'\fR must be an array reference
where each element of the array is an \f(CW\*(C`Employee\*(C'\fR object. It's worth
noting that an \fIempty\fR array reference also satisfies this
constraint, such as the value given as the default here.
.PP
Parameterizable type constraints (or \*(L"container types\*(R"), such as
\&\f(CW\*(C`ArrayRef[\`a]\*(C'\fR, can be made more specific with a type parameter. In
fact, we can arbitrarily nest these types, producing something like
\&\f(CW\*(C`HashRef[ArrayRef[Int]]\*(C'\fR. However, you can also just use the type by
itself, so \f(CW\*(C`ArrayRef\*(C'\fR is legal. (2)
.PP
If you jump down to the definition of the \f(CW\*(C`Employee\*(C'\fR class, you will
see that it has an \f(CW\*(C`employer\*(C'\fR attribute.
.PP
When we set the \f(CW\*(C`employees\*(C'\fR for a \f(CW\*(C`Company\*(C'\fR we want to make sure
that each of these employee objects refers back to the right
\&\f(CW\*(C`Company\*(C'\fR in its \f(CW\*(C`employer\*(C'\fR attribute.
.PP
To do that, we need to hook into object construction. Moose lets us do
this by writing a \f(CW\*(C`BUILD\*(C'\fR method in our class. When your class
defines a \f(CW\*(C`BUILD\*(C'\fR method, it will be called by the constructor
immediately after object construction, but before the object is returned
to the caller. Note that all \f(CW\*(C`BUILD\*(C'\fR methods in your class hierarchy
will be called automatically; there is no need to (and you should not)
call the superclass \f(CW\*(C`BUILD\*(C'\fR method.
.PP
The \f(CW\*(C`Company\*(C'\fR class uses the \f(CW\*(C`BUILD\*(C'\fR method to ensure that each
employee of a company has the proper \f(CW\*(C`Company\*(C'\fR object in its
\&\f(CW\*(C`employer\*(C'\fR attribute:
.PP
.Vb 6
\&  sub BUILD {
\&      my ( $self, $params ) = @_;
\&      foreach my $employee ( @{ $self\->employees } ) {
\&          $employee\->employer($self);
\&      }
\&  }
.Ve
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is executed after type constraints are checked, so it is
safe to assume that if \f(CW\*(C`$self\->employees\*(C'\fR has a value, it will be an
array reference, and that the elements of that array reference will be
\&\f(CW\*(C`Employee\*(C'\fR objects.
.PP
We also want to make sure that whenever the \f(CW\*(C`employees\*(C'\fR attribute for
a \f(CW\*(C`Company\*(C'\fR is changed, we also update the \f(CW\*(C`employer\*(C'\fR for each
employee.
.PP
To do this we can use an \f(CW\*(C`after\*(C'\fR modifier:
.PP
.Vb 7
\&  after \*(Aqemployees\*(Aq => sub {
\&      my ( $self, $employees ) = @_;
\&      return unless $employees;
\&      foreach my $employee ( @$employees ) {
\&          $employee\->employer($self);
\&      }
\&  };
.Ve
.PP
Again, as with the \f(CW\*(C`BUILD\*(C'\fR method, we know that the type constraint check has
already happened, so we know that if \f(CW$employees\fR is defined it will contain
an array reference of \f(CW\*(C`Employee\*(C'\fR objects.
.PP
Note that \f(CW\*(C`employees\*(C'\fR is a read/write accessor, so we must return early if
it's called as a reader.
.PP
The \fBPerson\fR class does not really demonstrate anything new. It has several
\&\f(CW\*(C`required\*(C'\fR attributes. It also has a \f(CW\*(C`predicate\*(C'\fR method, which we
first used in Moose::Cookbook::Basics::BinaryTree_AttributeFeatures.
.PP
The only new feature in the \f(CW\*(C`Employee\*(C'\fR class is the \f(CW\*(C`override\*(C'\fR
method modifier:
.PP
.Vb 4
\&  override \*(Aqfull_name\*(Aq => sub {
\&      my $self = shift;
\&      super() . \*(Aq, \*(Aq . $self\->title;
\&  };
.Ve
.PP
This is just a sugary alternative to Perl's built in \f(CW\*(C`SUPER::\*(C'\fR
feature. However, there is one difference. You cannot pass any
arguments to \f(CW\*(C`super\*(C'\fR. Instead, Moose simply passes the same
parameters that were passed to the method.
.PP
A more detailed example of usage can be found in
\&\fIt/recipes/moose_cookbook_basics_recipe4.t\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe was intentionally longer and more complex. It illustrates
how Moose classes can be used together with type constraints, as well
as the density of information that you can get out of a small amount
of typing when using Moose.
.PP
This recipe also introduced the \f(CW\*(C`subtype\*(C'\fR function, the \f(CW\*(C`required\*(C'\fR
attribute, and the \f(CW\*(C`override\*(C'\fR method modifier.
.PP
We will revisit type constraints in future recipes, and cover type
coercion as well.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
The value being checked is also passed as the first argument to
the \f(CW\*(C`where\*(C'\fR block, so it can be accessed as \f(CW$_[0]\fR.
.IP "(2)" 4
.IX Item "(2)"
Note that \f(CW\*(C`ArrayRef[]\*(C'\fR will not work. Moose will not parse this as a
container type, and instead you will have a new type named
\&\*(L"ArrayRef[]\*(R", which doesn't make any sense.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                         Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent.3pm                                       0100644 0001750 0001750 00000014112 12566242162 034123  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3"
.TH Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent \- Extending a non\-Moose parent class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::DateTime;
\&
\&  use Moose;
\&  use MooseX::NonMoose;
\&  use DateTime::Calendar::Mayan;
\&  extends qw( DateTime );
\&
\&  has \*(Aqmayan_date\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqDateTime::Calendar::Mayan\*(Aq,
\&      init_arg  => undef,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_mayan_date\*(Aq,
\&      clearer   => \*(Aq_clear_mayan_date\*(Aq,
\&      predicate => \*(Aqhas_mayan_date\*(Aq,
\&  );
\&
\&  after \*(Aqset\*(Aq => sub {
\&      $_[0]\->_clear_mayan_date;
\&  };
\&
\&  sub _build_mayan_date {
\&      DateTime::Calendar::Mayan\->from_object( object => $_[0] );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates how to use Moose to subclass a parent which
is not Moose based. This recipe only works if the parent class uses a
blessed hash reference for object instances. If your parent is doing
something funkier, you should check out MooseX::NonMoose::InsideOut and MooseX::InsideOut.
.PP
The meat of this recipe is contained in MooseX::NonMoose, which does all
the grunt work for you.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent5.16.3pm                                   0100644 0001750 0001750 00000013044 12566242166 034444  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3"
.TH Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent \- Extending a non\-Moose parent class
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::DateTime;
\&
\&  use Moose;
\&  use MooseX::NonMoose;
\&  use DateTime::Calendar::Mayan;
\&  extends qw( DateTime );
\&
\&  has \*(Aqmayan_date\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqDateTime::Calendar::Mayan\*(Aq,
\&      init_arg  => undef,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_mayan_date\*(Aq,
\&      clearer   => \*(Aq_clear_mayan_date\*(Aq,
\&      predicate => \*(Aqhas_mayan_date\*(Aq,
\&  );
\&
\&  after \*(Aqset\*(Aq => sub {
\&      $_[0]\->_clear_mayan_date;
\&  };
\&
\&  sub _build_mayan_date {
\&      DateTime::Calendar::Mayan\->from_object( object => $_[0] );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates how to use Moose to subclass a parent which
is not Moose based. This recipe only works if the parent class uses a
blessed hash reference for object instances. If your parent is doing
something funkier, you should check out MooseX::NonMoose::InsideOut and MooseX::InsideOut.
.PP
The meat of this recipe is contained in MooseX::NonMoose, which does all
the grunt work for you.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent5.18.3pm                                   0100644 0001750 0001750 00000014112 12566242162 034437  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3"
.TH Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent \- Extending a non\-Moose parent class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::DateTime;
\&
\&  use Moose;
\&  use MooseX::NonMoose;
\&  use DateTime::Calendar::Mayan;
\&  extends qw( DateTime );
\&
\&  has \*(Aqmayan_date\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqDateTime::Calendar::Mayan\*(Aq,
\&      init_arg  => undef,
\&      lazy      => 1,
\&      builder   => \*(Aq_build_mayan_date\*(Aq,
\&      clearer   => \*(Aq_clear_mayan_date\*(Aq,
\&      predicate => \*(Aqhas_mayan_date\*(Aq,
\&  );
\&
\&  after \*(Aqset\*(Aq => sub {
\&      $_[0]\->_clear_mayan_date;
\&  };
\&
\&  sub _build_mayan_date {
\&      DateTime::Calendar::Mayan\->from_object( object => $_[0] );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates how to use Moose to subclass a parent which
is not Moose based. This recipe only works if the parent class uses a
blessed hash reference for object instances. If your parent is doing
something funkier, you should check out MooseX::NonMoose::InsideOut and MooseX::InsideOut.
.PP
The meat of this recipe is contained in MooseX::NonMoose, which does all
the grunt work for you.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::Document_AugmentAndInner.3pm                                               0100644 0001750 0001750 00000021172 12566242161 032452  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Document_AugmentAndInner 3"
.TH Moose::Cookbook::Basics::Document_AugmentAndInner 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Document_AugmentAndInner \- The augment modifier, which turns normal method overriding "inside\-out"
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Document::Page;
\&  use Moose;
\&
\&  has \*(Aqbody\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, default => sub {\*(Aq\*(Aq} );
\&
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
\&
\&  sub append_body {
\&      my ( $self, $appendage ) = @_;
\&      $self\->body( $self\->body . $appendage );
\&  }
\&
\&  sub open_page  { (shift)\->append_body(\*(Aq<page>\*(Aq) }
\&  sub close_page { (shift)\->append_body(\*(Aq</page>\*(Aq) }
\&
\&  package Document::PageWithHeadersAndFooters;
\&  use Moose;
\&
\&  extends \*(AqDocument::Page\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
\&
\&  sub create_header { (shift)\->append_body(\*(Aq<header/>\*(Aq) }
\&  sub create_footer { (shift)\->append_body(\*(Aq<footer/>\*(Aq) }
\&
\&  package TPSReport;
\&  use Moose;
\&
\&  extends \*(AqDocument::PageWithHeadersAndFooters\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
\&
\&  sub create_tps_report {
\&      (shift)\->append_body(\*(Aq<report type="tps"/>\*(Aq);
\&  }
\&
\&  # <page><header/><report type="tps"/><footer/></page>
\&  my $report_xml = TPSReport\->new\->create;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how the \f(CW\*(C`augment\*(C'\fR method modifier works. This
modifier reverses the normal subclass to parent method resolution
order. With an \f(CW\*(C`augment\*(C'\fR modifier the \fIleast\fR specific method is
called first. Each successive call to \f(CW\*(C`inner\*(C'\fR descends the
inheritance tree, ending at the most specific subclass.
.PP
The \f(CW\*(C`augment\*(C'\fR modifier lets you design a parent class that can be
extended in a specific way. The parent provides generic wrapper
functionality, and the subclasses fill in the details.
.PP
In the example above, we've created a set of document classes, with
the most specific being the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
We start with the least specific class, \f(CW\*(C`Document::Page\*(C'\fR. Its create
method contains a call to \f(CW\*(C`inner()\*(C'\fR:
.PP
.Vb 6
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
.Ve
.PP
The \f(CW\*(C`inner\*(C'\fR function is exported by \f(CW\*(C`Moose\*(C'\fR, and is like \f(CW\*(C`super\*(C'\fR
for augmented methods. When \f(CW\*(C`inner\*(C'\fR is called, Moose finds the next
method in the chain, which is the \f(CW\*(C`augment\*(C'\fR modifier in
\&\f(CW\*(C`Document::PageWithHeadersAndFooters\*(C'\fR. You'll note that we can call
\&\f(CW\*(C`inner\*(C'\fR in our modifier:
.PP
.Vb 6
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
.Ve
.PP
This finds the next most specific modifier, in the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
Finally, in the \f(CW\*(C`TPSReport\*(C'\fR class, the chain comes to an end:
.PP
.Vb 5
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
.Ve
.PP
We do call the \f(CW\*(C`inner\*(C'\fR function one more time, but since there is no
more specific subclass, this is a no-op. Making this call means we can
easily subclass \f(CW\*(C`TPSReport\*(C'\fR in the future.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`augment\*(C'\fR modifier is a powerful tool for creating a set of
nested wrappers. It's not something you will need often, but when you
do, it is very handy.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::Document_AugmentAndInner5.16.3pm                                           0100644 0001750 0001750 00000020124 12566242166 032765  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Document_AugmentAndInner 3"
.TH Moose::Cookbook::Basics::Document_AugmentAndInner 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Document_AugmentAndInner \- The augment modifier, which turns normal method overriding "inside\-out"
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Document::Page;
\&  use Moose;
\&
\&  has \*(Aqbody\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, default => sub {\*(Aq\*(Aq} );
\&
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
\&
\&  sub append_body {
\&      my ( $self, $appendage ) = @_;
\&      $self\->body( $self\->body . $appendage );
\&  }
\&
\&  sub open_page  { (shift)\->append_body(\*(Aq<page>\*(Aq) }
\&  sub close_page { (shift)\->append_body(\*(Aq</page>\*(Aq) }
\&
\&  package Document::PageWithHeadersAndFooters;
\&  use Moose;
\&
\&  extends \*(AqDocument::Page\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
\&
\&  sub create_header { (shift)\->append_body(\*(Aq<header/>\*(Aq) }
\&  sub create_footer { (shift)\->append_body(\*(Aq<footer/>\*(Aq) }
\&
\&  package TPSReport;
\&  use Moose;
\&
\&  extends \*(AqDocument::PageWithHeadersAndFooters\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
\&
\&  sub create_tps_report {
\&      (shift)\->append_body(\*(Aq<report type="tps"/>\*(Aq);
\&  }
\&
\&  # <page><header/><report type="tps"/><footer/></page>
\&  my $report_xml = TPSReport\->new\->create;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how the \f(CW\*(C`augment\*(C'\fR method modifier works. This
modifier reverses the normal subclass to parent method resolution
order. With an \f(CW\*(C`augment\*(C'\fR modifier the \fIleast\fR specific method is
called first. Each successive call to \f(CW\*(C`inner\*(C'\fR descends the
inheritance tree, ending at the most specific subclass.
.PP
The \f(CW\*(C`augment\*(C'\fR modifier lets you design a parent class that can be
extended in a specific way. The parent provides generic wrapper
functionality, and the subclasses fill in the details.
.PP
In the example above, we've created a set of document classes, with
the most specific being the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
We start with the least specific class, \f(CW\*(C`Document::Page\*(C'\fR. Its create
method contains a call to \f(CW\*(C`inner()\*(C'\fR:
.PP
.Vb 6
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
.Ve
.PP
The \f(CW\*(C`inner\*(C'\fR function is exported by \f(CW\*(C`Moose\*(C'\fR, and is like \f(CW\*(C`super\*(C'\fR
for augmented methods. When \f(CW\*(C`inner\*(C'\fR is called, Moose finds the next
method in the chain, which is the \f(CW\*(C`augment\*(C'\fR modifier in
\&\f(CW\*(C`Document::PageWithHeadersAndFooters\*(C'\fR. You'll note that we can call
\&\f(CW\*(C`inner\*(C'\fR in our modifier:
.PP
.Vb 6
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
.Ve
.PP
This finds the next most specific modifier, in the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
Finally, in the \f(CW\*(C`TPSReport\*(C'\fR class, the chain comes to an end:
.PP
.Vb 5
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
.Ve
.PP
We do call the \f(CW\*(C`inner\*(C'\fR function one more time, but since there is no
more specific subclass, this is a no-op. Making this call means we can
easily subclass \f(CW\*(C`TPSReport\*(C'\fR in the future.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`augment\*(C'\fR modifier is a powerful tool for creating a set of
nested wrappers. It's not something you will need often, but when you
do, it is very handy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                            Moose::Cookbook::Basics::Document_AugmentAndInner5.18.3pm                                           0100644 0001750 0001750 00000021172 12566242161 032766  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Document_AugmentAndInner 3"
.TH Moose::Cookbook::Basics::Document_AugmentAndInner 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Document_AugmentAndInner \- The augment modifier, which turns normal method overriding "inside\-out"
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Document::Page;
\&  use Moose;
\&
\&  has \*(Aqbody\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq, default => sub {\*(Aq\*(Aq} );
\&
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
\&
\&  sub append_body {
\&      my ( $self, $appendage ) = @_;
\&      $self\->body( $self\->body . $appendage );
\&  }
\&
\&  sub open_page  { (shift)\->append_body(\*(Aq<page>\*(Aq) }
\&  sub close_page { (shift)\->append_body(\*(Aq</page>\*(Aq) }
\&
\&  package Document::PageWithHeadersAndFooters;
\&  use Moose;
\&
\&  extends \*(AqDocument::Page\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
\&
\&  sub create_header { (shift)\->append_body(\*(Aq<header/>\*(Aq) }
\&  sub create_footer { (shift)\->append_body(\*(Aq<footer/>\*(Aq) }
\&
\&  package TPSReport;
\&  use Moose;
\&
\&  extends \*(AqDocument::PageWithHeadersAndFooters\*(Aq;
\&
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
\&
\&  sub create_tps_report {
\&      (shift)\->append_body(\*(Aq<report type="tps"/>\*(Aq);
\&  }
\&
\&  # <page><header/><report type="tps"/><footer/></page>
\&  my $report_xml = TPSReport\->new\->create;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe shows how the \f(CW\*(C`augment\*(C'\fR method modifier works. This
modifier reverses the normal subclass to parent method resolution
order. With an \f(CW\*(C`augment\*(C'\fR modifier the \fIleast\fR specific method is
called first. Each successive call to \f(CW\*(C`inner\*(C'\fR descends the
inheritance tree, ending at the most specific subclass.
.PP
The \f(CW\*(C`augment\*(C'\fR modifier lets you design a parent class that can be
extended in a specific way. The parent provides generic wrapper
functionality, and the subclasses fill in the details.
.PP
In the example above, we've created a set of document classes, with
the most specific being the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
We start with the least specific class, \f(CW\*(C`Document::Page\*(C'\fR. Its create
method contains a call to \f(CW\*(C`inner()\*(C'\fR:
.PP
.Vb 6
\&  sub create {
\&      my $self = shift;
\&      $self\->open_page;
\&      inner();
\&      $self\->close_page;
\&  }
.Ve
.PP
The \f(CW\*(C`inner\*(C'\fR function is exported by \f(CW\*(C`Moose\*(C'\fR, and is like \f(CW\*(C`super\*(C'\fR
for augmented methods. When \f(CW\*(C`inner\*(C'\fR is called, Moose finds the next
method in the chain, which is the \f(CW\*(C`augment\*(C'\fR modifier in
\&\f(CW\*(C`Document::PageWithHeadersAndFooters\*(C'\fR. You'll note that we can call
\&\f(CW\*(C`inner\*(C'\fR in our modifier:
.PP
.Vb 6
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_header;
\&      inner();
\&      $self\->create_footer;
\&  };
.Ve
.PP
This finds the next most specific modifier, in the \f(CW\*(C`TPSReport\*(C'\fR class.
.PP
Finally, in the \f(CW\*(C`TPSReport\*(C'\fR class, the chain comes to an end:
.PP
.Vb 5
\&  augment \*(Aqcreate\*(Aq => sub {
\&      my $self = shift;
\&      $self\->create_tps_report;
\&      inner();
\&  };
.Ve
.PP
We do call the \f(CW\*(C`inner\*(C'\fR function one more time, but since there is no
more specific subclass, this is a no-op. Making this call means we can
easily subclass \f(CW\*(C`TPSReport\*(C'\fR in the future.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The \f(CW\*(C`augment\*(C'\fR modifier is a powerful tool for creating a set of
nested wrappers. It's not something you will need often, but when you
do, it is very handy.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion.3pm                                  0100644 0001750 0001750 00000033032 12566242161 035202  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion \- Operator overloading, subtypes, and coercion
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Human;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  subtype \*(AqSex\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { $_ =~ m{^[mf]$}s };
\&
\&  has \*(Aqsex\*(Aq    => ( is => \*(Aqro\*(Aq, isa => \*(AqSex\*(Aq, required => 1 );
\&
\&  has \*(Aqmother\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&  has \*(Aqfather\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      die(\*(AqOnly male and female humans may create children\*(Aq)
\&          if ( $one\->sex() eq $two\->sex() );
\&
\&      my ( $mother, $father )
\&          = ( $one\->sex eq \*(Aqf\*(Aq ? ( $one, $two ) : ( $two, $one ) );
\&
\&      my $sex = \*(Aqf\*(Aq;
\&      $sex = \*(Aqm\*(Aq if ( rand() >= 0.5 );
\&
\&      return Human\->new(
\&          sex    => $sex,
\&          mother => $mother,
\&          father => $father,
\&      );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose cookbook recipe shows how operator overloading, coercion,
and subtypes can be used to mimic the human reproductive system
(well, the selection of genes at least).
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Our \f(CW\*(C`Human\*(C'\fR class uses operator overloading to allow us to \*(L"add\*(R" two
humans together and produce a child. Our implementation does require
that the two objects be of opposite sex. Remember, we're talking
about biological reproduction, not marriage.
.PP
While this example works as-is, we can take it a lot further by adding
genes into the mix. We'll add the two genes that control eye color,
and use overloading to combine the genes from the parent to model the
biology.
.SS "What is Operator Overloading?"
.IX Subsection "What is Operator Overloading?"
Overloading is \fInot\fR a Moose-specific feature. It's a general \s-1OO\s0
concept that is implemented in Perl with the \f(CW\*(C`overload\*(C'\fR
pragma. Overloading lets objects do something sane when used with
Perl's built in operators, like addition (\f(CW\*(C`+\*(C'\fR) or when used as a
string.
.PP
In this example we overload addition so we can write code like
\&\f(CW\*(C`$child = $mother + $father\*(C'\fR.
.SH "GENES"
.IX Header "GENES"
There are many genes which affect eye color, but there are two which
are most important, \fIgey\fR and \fIbey2\fR. We will start by making a
class for each gene.
.SS "Human::Gene::bey2"
.IX Subsection "Human::Gene::bey2"
.Vb 1
\&  package Human::Gene::bey2;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqbey2_color\*(Aq => where { $_ =~ m{^(?:brown|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqbey2_color\*(Aq );
.Ve
.PP
This class is trivial. We have a type constraint for the allowed
colors, and a \f(CW\*(C`color\*(C'\fR attribute.
.SS "Human::Gene::gey"
.IX Subsection "Human::Gene::gey"
.Vb 1
\&  package Human::Gene::gey;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqgey_color\*(Aq => where { $_ =~ m{^(?:green|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqgey_color\*(Aq );
.Ve
.PP
This is nearly identical to the \f(CW\*(C`Humane::Gene::bey2\*(C'\fR class, except
that the \fIgey\fR gene allows for different colors.
.SH "EYE COLOR"
.IX Header "EYE COLOR"
We could just give four attributes (two of each gene) to the
\&\f(CW\*(C`Human\*(C'\fR class, but this is a bit messy. Instead, we'll abstract the
genes into a container class, \f(CW\*(C`Human::EyeColor\*(C'\fR. Then a \f(CW\*(C`Human\*(C'\fR can
have a single \f(CW\*(C`eye_color\*(C'\fR attribute.
.PP
.Vb 1
\&  package Human::EyeColor;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  coerce \*(AqHuman::Gene::bey2\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::bey2\->new( color => $_ ) };
\&
\&  coerce \*(AqHuman::Gene::gey\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::gey\->new( color => $_ ) };
\&
\&  has [qw( bey2_1 bey2_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::bey2\*(Aq, coerce => 1 );
\&
\&  has [qw( gey_1 gey_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::gey\*(Aq, coerce => 1 );
.Ve
.PP
The eye color class has two of each type of gene. We've also created a
coercion for each class that coerces a string into a new object. Note
that a coercion will fail if it attempts to coerce a string like
\&\*(L"indigo\*(R", because that is not a valid color for either type of gene.
.PP
As an aside, you can see that we can define several identical
attributes at once by supplying an array reference of names as the first
argument to \f(CW\*(C`has\*(C'\fR.
.PP
We also need a method to calculate the actual eye color that results
from a set of genes. The \fIbey2\fR brown gene is dominant over both blue
and green. The \fIgey\fR green gene is dominant over blue.
.PP
.Vb 2
\&  sub color {
\&      my ($self) = @_;
\&
\&      return \*(Aqbrown\*(Aq
\&          if ( $self\->bey2_1\->color() eq \*(Aqbrown\*(Aq
\&          or $self\->bey2_2\->color() eq \*(Aqbrown\*(Aq );
\&
\&      return \*(Aqgreen\*(Aq
\&          if ( $self\->gey_1\->color() eq \*(Aqgreen\*(Aq
\&          or $self\->gey_2\->color() eq \*(Aqgreen\*(Aq );
\&
\&      return \*(Aqblue\*(Aq;
\&  }
.Ve
.PP
We'd like to be able to treat a \f(CW\*(C`Human::EyeColor\*(C'\fR object as a string,
so we define a string overloading for the class:
.PP
.Vb 1
\&  use overload \*(Aq""\*(Aq => \e&color, fallback => 1;
.Ve
.PP
Finally, we need to define overloading for addition. That way we can
add together two \f(CW\*(C`Human::EyeColor\*(C'\fR objects and get a new one with a
new (genetically correct) eye color.
.PP
.Vb 1
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      my $one_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&      my $two_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&
\&      my $one_gey = \*(Aqgey_\*(Aq . _rand2();
\&      my $two_gey = \*(Aqgey_\*(Aq . _rand2();
\&
\&      return Human::EyeColor\->new(
\&          bey2_1 => $one\->$one_bey2\->color(),
\&          bey2_2 => $two\->$two_bey2\->color(),
\&          gey_1  => $one\->$one_gey\->color(),
\&          gey_2  => $two\->$two_gey\->color(),
\&      );
\&  }
\&
\&  sub _rand2 {
\&      return 1 + int( rand(2) );
\&  }
.Ve
.PP
When two eye color objects are added together, the \f(CW\*(C`_overload_add()\*(C'\fR
method will be passed two \f(CW\*(C`Human::EyeColor\*(C'\fR objects. These are the
left and right side operands for the \f(CW\*(C`+\*(C'\fR operator. This method
returns a new \f(CW\*(C`Human::EyeColor\*(C'\fR object.
.ie n .SH "ADDING EYE COLOR TO ""Human""s"
.el .SH "ADDING EYE COLOR TO \f(CWHuman\fPs"
.IX Header "ADDING EYE COLOR TO Humans"
Our original \f(CW\*(C`Human\*(C'\fR class requires just a few changes to incorporate
our new \f(CW\*(C`Human::EyeColor\*(C'\fR class.
.PP
.Vb 1
\&  use List::MoreUtils qw( zip );
\&
\&  coerce \*(AqHuman::EyeColor\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&      => via { my @genes = qw( bey2_1 bey2_2 gey_1 gey_2 );
\&               return Human::EyeColor\->new( zip( @genes, @{$_} ) ); };
\&
\&  has \*(Aqeye_color\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqHuman::EyeColor\*(Aq,
\&      coerce   => 1,
\&      required => 1,
\&  );
.Ve
.PP
We also need to modify \f(CW\*(C`_overload_add()\*(C'\fR in the \f(CW\*(C`Human\*(C'\fR class to
account for eye color:
.PP
.Vb 6
\&  return Human\->new(
\&      sex       => $sex,
\&      eye_color => ( $one\->eye_color() + $two\->eye_color() ),
\&      mother    => $mother,
\&      father    => $father,
\&  );
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The three techniques we used, overloading, subtypes, and coercion,
combine to provide a powerful interface.
.PP
If you'd like to learn more about overloading, please read the
documentation for the overload pragma.
.PP
To see all the code we created together, take a look at
\&\fIt/recipes/basics_recipe9.t\fR.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Had this been a real project we'd probably want:
.IP "Better Randomization with Crypt::Random" 4
.IX Item "Better Randomization with Crypt::Random"
.PD 0
.IP "Characteristic Base Class" 4
.IX Item "Characteristic Base Class"
.IP "Mutating Genes" 4
.IX Item "Mutating Genes"
.IP "More Characteristics" 4
.IX Item "More Characteristics"
.IP "Artificial Life" 4
.IX Item "Artificial Life"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This work is licensed under a Creative Commons Attribution 3.0 Unported License.
.PP
License details are at: <http://creativecommons.org/licenses/by/3.0/>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion5.16.3pm                              0100644 0001750 0001750 00000031764 12566242166 035533  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion \- Operator overloading, subtypes, and coercion
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Human;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  subtype \*(AqSex\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { $_ =~ m{^[mf]$}s };
\&
\&  has \*(Aqsex\*(Aq    => ( is => \*(Aqro\*(Aq, isa => \*(AqSex\*(Aq, required => 1 );
\&
\&  has \*(Aqmother\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&  has \*(Aqfather\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      die(\*(AqOnly male and female humans may create children\*(Aq)
\&          if ( $one\->sex() eq $two\->sex() );
\&
\&      my ( $mother, $father )
\&          = ( $one\->sex eq \*(Aqf\*(Aq ? ( $one, $two ) : ( $two, $one ) );
\&
\&      my $sex = \*(Aqf\*(Aq;
\&      $sex = \*(Aqm\*(Aq if ( rand() >= 0.5 );
\&
\&      return Human\->new(
\&          sex    => $sex,
\&          mother => $mother,
\&          father => $father,
\&      );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose cookbook recipe shows how operator overloading, coercion,
and subtypes can be used to mimic the human reproductive system
(well, the selection of genes at least).
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Our \f(CW\*(C`Human\*(C'\fR class uses operator overloading to allow us to \*(L"add\*(R" two
humans together and produce a child. Our implementation does require
that the two objects be of opposite sex. Remember, we're talking
about biological reproduction, not marriage.
.PP
While this example works as-is, we can take it a lot further by adding
genes into the mix. We'll add the two genes that control eye color,
and use overloading to combine the genes from the parent to model the
biology.
.SS "What is Operator Overloading?"
.IX Subsection "What is Operator Overloading?"
Overloading is \fInot\fR a Moose-specific feature. It's a general \s-1OO\s0
concept that is implemented in Perl with the \f(CW\*(C`overload\*(C'\fR
pragma. Overloading lets objects do something sane when used with
Perl's built in operators, like addition (\f(CW\*(C`+\*(C'\fR) or when used as a
string.
.PP
In this example we overload addition so we can write code like
\&\f(CW\*(C`$child = $mother + $father\*(C'\fR.
.SH "GENES"
.IX Header "GENES"
There are many genes which affect eye color, but there are two which
are most important, \fIgey\fR and \fIbey2\fR. We will start by making a
class for each gene.
.SS "Human::Gene::bey2"
.IX Subsection "Human::Gene::bey2"
.Vb 1
\&  package Human::Gene::bey2;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqbey2_color\*(Aq => where { $_ =~ m{^(?:brown|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqbey2_color\*(Aq );
.Ve
.PP
This class is trivial. We have a type constraint for the allowed
colors, and a \f(CW\*(C`color\*(C'\fR attribute.
.SS "Human::Gene::gey"
.IX Subsection "Human::Gene::gey"
.Vb 1
\&  package Human::Gene::gey;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqgey_color\*(Aq => where { $_ =~ m{^(?:green|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqgey_color\*(Aq );
.Ve
.PP
This is nearly identical to the \f(CW\*(C`Humane::Gene::bey2\*(C'\fR class, except
that the \fIgey\fR gene allows for different colors.
.SH "EYE COLOR"
.IX Header "EYE COLOR"
We could just give four attributes (two of each gene) to the
\&\f(CW\*(C`Human\*(C'\fR class, but this is a bit messy. Instead, we'll abstract the
genes into a container class, \f(CW\*(C`Human::EyeColor\*(C'\fR. Then a \f(CW\*(C`Human\*(C'\fR can
have a single \f(CW\*(C`eye_color\*(C'\fR attribute.
.PP
.Vb 1
\&  package Human::EyeColor;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  coerce \*(AqHuman::Gene::bey2\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::bey2\->new( color => $_ ) };
\&
\&  coerce \*(AqHuman::Gene::gey\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::gey\->new( color => $_ ) };
\&
\&  has [qw( bey2_1 bey2_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::bey2\*(Aq, coerce => 1 );
\&
\&  has [qw( gey_1 gey_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::gey\*(Aq, coerce => 1 );
.Ve
.PP
The eye color class has two of each type of gene. We've also created a
coercion for each class that coerces a string into a new object. Note
that a coercion will fail if it attempts to coerce a string like
\&\*(L"indigo\*(R", because that is not a valid color for either type of gene.
.PP
As an aside, you can see that we can define several identical
attributes at once by supplying an array reference of names as the first
argument to \f(CW\*(C`has\*(C'\fR.
.PP
We also need a method to calculate the actual eye color that results
from a set of genes. The \fIbey2\fR brown gene is dominant over both blue
and green. The \fIgey\fR green gene is dominant over blue.
.PP
.Vb 2
\&  sub color {
\&      my ($self) = @_;
\&
\&      return \*(Aqbrown\*(Aq
\&          if ( $self\->bey2_1\->color() eq \*(Aqbrown\*(Aq
\&          or $self\->bey2_2\->color() eq \*(Aqbrown\*(Aq );
\&
\&      return \*(Aqgreen\*(Aq
\&          if ( $self\->gey_1\->color() eq \*(Aqgreen\*(Aq
\&          or $self\->gey_2\->color() eq \*(Aqgreen\*(Aq );
\&
\&      return \*(Aqblue\*(Aq;
\&  }
.Ve
.PP
We'd like to be able to treat a \f(CW\*(C`Human::EyeColor\*(C'\fR object as a string,
so we define a string overloading for the class:
.PP
.Vb 1
\&  use overload \*(Aq""\*(Aq => \e&color, fallback => 1;
.Ve
.PP
Finally, we need to define overloading for addition. That way we can
add together two \f(CW\*(C`Human::EyeColor\*(C'\fR objects and get a new one with a
new (genetically correct) eye color.
.PP
.Vb 1
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      my $one_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&      my $two_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&
\&      my $one_gey = \*(Aqgey_\*(Aq . _rand2();
\&      my $two_gey = \*(Aqgey_\*(Aq . _rand2();
\&
\&      return Human::EyeColor\->new(
\&          bey2_1 => $one\->$one_bey2\->color(),
\&          bey2_2 => $two\->$two_bey2\->color(),
\&          gey_1  => $one\->$one_gey\->color(),
\&          gey_2  => $two\->$two_gey\->color(),
\&      );
\&  }
\&
\&  sub _rand2 {
\&      return 1 + int( rand(2) );
\&  }
.Ve
.PP
When two eye color objects are added together, the \f(CW\*(C`_overload_add()\*(C'\fR
method will be passed two \f(CW\*(C`Human::EyeColor\*(C'\fR objects. These are the
left and right side operands for the \f(CW\*(C`+\*(C'\fR operator. This method
returns a new \f(CW\*(C`Human::EyeColor\*(C'\fR object.
.ie n .SH "ADDING EYE COLOR TO ""Human""s"
.el .SH "ADDING EYE COLOR TO \f(CWHuman\fPs"
.IX Header "ADDING EYE COLOR TO Humans"
Our original \f(CW\*(C`Human\*(C'\fR class requires just a few changes to incorporate
our new \f(CW\*(C`Human::EyeColor\*(C'\fR class.
.PP
.Vb 1
\&  use List::MoreUtils qw( zip );
\&
\&  coerce \*(AqHuman::EyeColor\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&      => via { my @genes = qw( bey2_1 bey2_2 gey_1 gey_2 );
\&               return Human::EyeColor\->new( zip( @genes, @{$_} ) ); };
\&
\&  has \*(Aqeye_color\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqHuman::EyeColor\*(Aq,
\&      coerce   => 1,
\&      required => 1,
\&  );
.Ve
.PP
We also need to modify \f(CW\*(C`_overload_add()\*(C'\fR in the \f(CW\*(C`Human\*(C'\fR class to
account for eye color:
.PP
.Vb 6
\&  return Human\->new(
\&      sex       => $sex,
\&      eye_color => ( $one\->eye_color() + $two\->eye_color() ),
\&      mother    => $mother,
\&      father    => $father,
\&  );
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The three techniques we used, overloading, subtypes, and coercion,
combine to provide a powerful interface.
.PP
If you'd like to learn more about overloading, please read the
documentation for the overload pragma.
.PP
To see all the code we created together, take a look at
\&\fIt/recipes/basics_recipe9.t\fR.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Had this been a real project we'd probably want:
.IP "Better Randomization with Crypt::Random" 4
.IX Item "Better Randomization with Crypt::Random"
.PD 0
.IP "Characteristic Base Class" 4
.IX Item "Characteristic Base Class"
.IP "Mutating Genes" 4
.IX Item "Mutating Genes"
.IP "More Characteristics" 4
.IX Item "More Characteristics"
.IP "Artificial Life" 4
.IX Item "Artificial Life"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This work is licensed under a Creative Commons Attribution 3.0 Unported License.
.PP
License details are at: <http://creativecommons.org/licenses/by/3.0/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
            Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion5.18.3pm                              0100644 0001750 0001750 00000033032 12566242161 035516  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion \- Operator overloading, subtypes, and coercion
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Human;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  subtype \*(AqSex\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { $_ =~ m{^[mf]$}s };
\&
\&  has \*(Aqsex\*(Aq    => ( is => \*(Aqro\*(Aq, isa => \*(AqSex\*(Aq, required => 1 );
\&
\&  has \*(Aqmother\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&  has \*(Aqfather\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(AqHuman\*(Aq );
\&
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      die(\*(AqOnly male and female humans may create children\*(Aq)
\&          if ( $one\->sex() eq $two\->sex() );
\&
\&      my ( $mother, $father )
\&          = ( $one\->sex eq \*(Aqf\*(Aq ? ( $one, $two ) : ( $two, $one ) );
\&
\&      my $sex = \*(Aqf\*(Aq;
\&      $sex = \*(Aqm\*(Aq if ( rand() >= 0.5 );
\&
\&      return Human\->new(
\&          sex    => $sex,
\&          mother => $mother,
\&          father => $father,
\&      );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose cookbook recipe shows how operator overloading, coercion,
and subtypes can be used to mimic the human reproductive system
(well, the selection of genes at least).
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Our \f(CW\*(C`Human\*(C'\fR class uses operator overloading to allow us to \*(L"add\*(R" two
humans together and produce a child. Our implementation does require
that the two objects be of opposite sex. Remember, we're talking
about biological reproduction, not marriage.
.PP
While this example works as-is, we can take it a lot further by adding
genes into the mix. We'll add the two genes that control eye color,
and use overloading to combine the genes from the parent to model the
biology.
.SS "What is Operator Overloading?"
.IX Subsection "What is Operator Overloading?"
Overloading is \fInot\fR a Moose-specific feature. It's a general \s-1OO\s0
concept that is implemented in Perl with the \f(CW\*(C`overload\*(C'\fR
pragma. Overloading lets objects do something sane when used with
Perl's built in operators, like addition (\f(CW\*(C`+\*(C'\fR) or when used as a
string.
.PP
In this example we overload addition so we can write code like
\&\f(CW\*(C`$child = $mother + $father\*(C'\fR.
.SH "GENES"
.IX Header "GENES"
There are many genes which affect eye color, but there are two which
are most important, \fIgey\fR and \fIbey2\fR. We will start by making a
class for each gene.
.SS "Human::Gene::bey2"
.IX Subsection "Human::Gene::bey2"
.Vb 1
\&  package Human::Gene::bey2;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqbey2_color\*(Aq => where { $_ =~ m{^(?:brown|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqbey2_color\*(Aq );
.Ve
.PP
This class is trivial. We have a type constraint for the allowed
colors, and a \f(CW\*(C`color\*(C'\fR attribute.
.SS "Human::Gene::gey"
.IX Subsection "Human::Gene::gey"
.Vb 1
\&  package Human::Gene::gey;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  type \*(Aqgey_color\*(Aq => where { $_ =~ m{^(?:green|blue)$} };
\&
\&  has \*(Aqcolor\*(Aq => ( is => \*(Aqro\*(Aq, isa => \*(Aqgey_color\*(Aq );
.Ve
.PP
This is nearly identical to the \f(CW\*(C`Humane::Gene::bey2\*(C'\fR class, except
that the \fIgey\fR gene allows for different colors.
.SH "EYE COLOR"
.IX Header "EYE COLOR"
We could just give four attributes (two of each gene) to the
\&\f(CW\*(C`Human\*(C'\fR class, but this is a bit messy. Instead, we'll abstract the
genes into a container class, \f(CW\*(C`Human::EyeColor\*(C'\fR. Then a \f(CW\*(C`Human\*(C'\fR can
have a single \f(CW\*(C`eye_color\*(C'\fR attribute.
.PP
.Vb 1
\&  package Human::EyeColor;
\&
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  coerce \*(AqHuman::Gene::bey2\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::bey2\->new( color => $_ ) };
\&
\&  coerce \*(AqHuman::Gene::gey\*(Aq
\&      => from \*(AqStr\*(Aq
\&          => via { Human::Gene::gey\->new( color => $_ ) };
\&
\&  has [qw( bey2_1 bey2_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::bey2\*(Aq, coerce => 1 );
\&
\&  has [qw( gey_1 gey_2 )] =>
\&      ( is => \*(Aqro\*(Aq, isa => \*(AqHuman::Gene::gey\*(Aq, coerce => 1 );
.Ve
.PP
The eye color class has two of each type of gene. We've also created a
coercion for each class that coerces a string into a new object. Note
that a coercion will fail if it attempts to coerce a string like
\&\*(L"indigo\*(R", because that is not a valid color for either type of gene.
.PP
As an aside, you can see that we can define several identical
attributes at once by supplying an array reference of names as the first
argument to \f(CW\*(C`has\*(C'\fR.
.PP
We also need a method to calculate the actual eye color that results
from a set of genes. The \fIbey2\fR brown gene is dominant over both blue
and green. The \fIgey\fR green gene is dominant over blue.
.PP
.Vb 2
\&  sub color {
\&      my ($self) = @_;
\&
\&      return \*(Aqbrown\*(Aq
\&          if ( $self\->bey2_1\->color() eq \*(Aqbrown\*(Aq
\&          or $self\->bey2_2\->color() eq \*(Aqbrown\*(Aq );
\&
\&      return \*(Aqgreen\*(Aq
\&          if ( $self\->gey_1\->color() eq \*(Aqgreen\*(Aq
\&          or $self\->gey_2\->color() eq \*(Aqgreen\*(Aq );
\&
\&      return \*(Aqblue\*(Aq;
\&  }
.Ve
.PP
We'd like to be able to treat a \f(CW\*(C`Human::EyeColor\*(C'\fR object as a string,
so we define a string overloading for the class:
.PP
.Vb 1
\&  use overload \*(Aq""\*(Aq => \e&color, fallback => 1;
.Ve
.PP
Finally, we need to define overloading for addition. That way we can
add together two \f(CW\*(C`Human::EyeColor\*(C'\fR objects and get a new one with a
new (genetically correct) eye color.
.PP
.Vb 1
\&  use overload \*(Aq+\*(Aq => \e&_overload_add, fallback => 1;
\&
\&  sub _overload_add {
\&      my ( $one, $two ) = @_;
\&
\&      my $one_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&      my $two_bey2 = \*(Aqbey2_\*(Aq . _rand2();
\&
\&      my $one_gey = \*(Aqgey_\*(Aq . _rand2();
\&      my $two_gey = \*(Aqgey_\*(Aq . _rand2();
\&
\&      return Human::EyeColor\->new(
\&          bey2_1 => $one\->$one_bey2\->color(),
\&          bey2_2 => $two\->$two_bey2\->color(),
\&          gey_1  => $one\->$one_gey\->color(),
\&          gey_2  => $two\->$two_gey\->color(),
\&      );
\&  }
\&
\&  sub _rand2 {
\&      return 1 + int( rand(2) );
\&  }
.Ve
.PP
When two eye color objects are added together, the \f(CW\*(C`_overload_add()\*(C'\fR
method will be passed two \f(CW\*(C`Human::EyeColor\*(C'\fR objects. These are the
left and right side operands for the \f(CW\*(C`+\*(C'\fR operator. This method
returns a new \f(CW\*(C`Human::EyeColor\*(C'\fR object.
.ie n .SH "ADDING EYE COLOR TO ""Human""s"
.el .SH "ADDING EYE COLOR TO \f(CWHuman\fPs"
.IX Header "ADDING EYE COLOR TO Humans"
Our original \f(CW\*(C`Human\*(C'\fR class requires just a few changes to incorporate
our new \f(CW\*(C`Human::EyeColor\*(C'\fR class.
.PP
.Vb 1
\&  use List::MoreUtils qw( zip );
\&
\&  coerce \*(AqHuman::EyeColor\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&      => via { my @genes = qw( bey2_1 bey2_2 gey_1 gey_2 );
\&               return Human::EyeColor\->new( zip( @genes, @{$_} ) ); };
\&
\&  has \*(Aqeye_color\*(Aq => (
\&      is       => \*(Aqro\*(Aq,
\&      isa      => \*(AqHuman::EyeColor\*(Aq,
\&      coerce   => 1,
\&      required => 1,
\&  );
.Ve
.PP
We also need to modify \f(CW\*(C`_overload_add()\*(C'\fR in the \f(CW\*(C`Human\*(C'\fR class to
account for eye color:
.PP
.Vb 6
\&  return Human\->new(
\&      sex       => $sex,
\&      eye_color => ( $one\->eye_color() + $two\->eye_color() ),
\&      mother    => $mother,
\&      father    => $father,
\&  );
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
The three techniques we used, overloading, subtypes, and coercion,
combine to provide a powerful interface.
.PP
If you'd like to learn more about overloading, please read the
documentation for the overload pragma.
.PP
To see all the code we created together, take a look at
\&\fIt/recipes/basics_recipe9.t\fR.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Had this been a real project we'd probably want:
.IP "Better Randomization with Crypt::Random" 4
.IX Item "Better Randomization with Crypt::Random"
.PD 0
.IP "Characteristic Base Class" 4
.IX Item "Characteristic Base Class"
.IP "Mutating Genes" 4
.IX Item "Mutating Genes"
.IP "More Characteristics" 4
.IX Item "More Characteristics"
.IP "Artificial Life" 4
.IX Item "Artificial Life"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This work is licensed under a Creative Commons Attribution 3.0 Unported License.
.PP
License details are at: <http://creativecommons.org/licenses/by/3.0/>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion.3pm                                               0100644 0001750 0001750 00000030657 12566242161 032367  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion \- Demonstrates subtypes and coercion use HTTP\-related classes (Request, Protocol, etc.)
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Request;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use HTTP::Headers  ();
\&  use Params::Coerce ();
\&  use URI            ();
\&
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
\&
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
\&
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
\&
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
\&
\&  subtype \*(AqProtocol\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { /^HTTP\e/[0\-9]\e.[0\-9]$/ };
\&
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aqmethod\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqprotocol\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqProtocol\*(Aq );
\&  has \*(Aqheaders\*(Aq  => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces type coercions, which are defined with the
\&\f(CW\*(C`coerce\*(C'\fR sugar function. Coercions are attached to existing type
constraints, and define a (one-way) transformation from one type to
another.
.PP
This is very powerful, but it can also have unexpected consequences, so
you have to explicitly ask for an attribute to be coerced. To do this,
you must set the \f(CW\*(C`coerce\*(C'\fR attribute option to a true value.
.PP
First, we create the subtype to which we will coerce the other types:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
.Ve
.PP
We are creating a subtype rather than using \f(CW\*(C`HTTP::Headers\*(C'\fR as a type
directly. The reason we do this is that coercions are global, and a
coercion defined for \f(CW\*(C`HTTP::Headers\*(C'\fR in our \f(CW\*(C`Request\*(C'\fR class would
then be defined for \fIall\fR Moose-using classes in the current Perl
interpreter. It's a best practice to
avoid this sort of namespace pollution.
.PP
The \f(CW\*(C`class_type\*(C'\fR sugar function is simply a shortcut for this:
.PP
.Vb 3
\&  subtype \*(AqHTTP::Headers\*(Aq
\&      => as \*(AqObject\*(Aq
\&      => where { $_\->isa(\*(AqHTTP::Headers\*(Aq) };
.Ve
.PP
Internally, Moose creates a type constraint for each Moose-using
class, but for non-Moose classes, the type must be declared
explicitly.
.PP
We could go ahead and use this new type directly:
.PP
.Vb 5
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
This creates a simple attribute which defaults to an empty instance of
HTTP::Headers.
.PP
The constructor for HTTP::Headers accepts a list of key-value pairs
representing the \s-1HTTP\s0 header fields. In Perl, such a list could be
stored in an \s-1ARRAY\s0 or \s-1HASH\s0 reference. We want our \f(CW\*(C`headers\*(C'\fR attribute
to accept those data structures instead of an \fBHTTP::Headers\fR
instance, and just do the right thing. This is exactly what coercion
is for:
.PP
.Vb 5
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
.Ve
.PP
The first argument to \f(CW\*(C`coerce\*(C'\fR is the type \fIto\fR which we are
coercing. Then we give it a set of \f(CW\*(C`from\*(C'\fR/\f(CW\*(C`via\*(C'\fR clauses. The \f(CW\*(C`from\*(C'\fR
function takes some other type name and \f(CW\*(C`via\*(C'\fR takes a subroutine
reference which actually does the coercion.
.PP
However, defining the coercion doesn't do anything until we tell Moose
we want a particular attribute to be coerced:
.PP
.Vb 6
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
Now, if we use an \f(CW\*(C`ArrayRef\*(C'\fR or \f(CW\*(C`HashRef\*(C'\fR to populate \f(CW\*(C`headers\*(C'\fR, it
will be coerced into a new HTTP::Headers instance. With the
coercion in place, the following lines of code are all equivalent:
.PP
.Vb 3
\&  $foo\->headers( HTTP::Headers\->new( bar => 1, baz => 2 ) );
\&  $foo\->headers( [ \*(Aqbar\*(Aq, 1, \*(Aqbaz\*(Aq, 2 ] );
\&  $foo\->headers( { bar => 1, baz => 2 } );
.Ve
.PP
As you can see, careful use of coercions can produce a very open
interface for your class, while still retaining the \*(L"safety\*(R" of your
type constraint checks. (1)
.PP
Our next coercion shows how we can leverage existing \s-1CPAN\s0 modules to
help implement coercions. In this case we use Params::Coerce.
.PP
Once again, we need to declare a class type for our non-Moose \s-1URI\s0
class:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
.Ve
.PP
Then we define the coercion:
.PP
.Vb 7
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
.Ve
.PP
The first coercion takes any object and makes it a \f(CW\*(C`URI\*(C'\fR object. The
coercion system isn't that smart, and does not check if the object is
already a \s-1URI\s0, so we check for that ourselves. If it's not a \s-1URI\s0
already, we let Params::Coerce do its magic, and we just use its
return value.
.PP
If Params::Coerce didn't return a \s-1URI\s0 object (for whatever
reason), Moose would throw a type constraint error.
.PP
The other coercion takes a string and converts it to a \s-1URI\s0. In this
case, we are using the coercion to apply a default behavior, where a
string is assumed to be an \f(CW\*(C`http\*(C'\fR \s-1URI.\s0
.PP
Finally, we need to make sure our attributes enable coercion.
.PP
.Vb 2
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
.Ve
.PP
Re-using the coercion lets us enforce a consistent \s-1API\s0 across multiple
attributes.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe showed the use of coercions to create a more flexible and
DWIM-y \s-1API.\s0 Like any powerful feature, we recommend some
caution. Sometimes it's better to reject a value than just guess at
how to \s-1DWIM.\s0
.PP
We also showed the use of the \f(CW\*(C`class_type\*(C'\fR sugar function as a
shortcut for defining a new subtype of \f(CW\*(C`Object\*(C'\fR.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
This particular example could be safer. Really we only want to coerce
an array with an \fIeven\fR number of elements. We could create a new
\&\f(CW\*(C`EvenElementArrayRef\*(C'\fR type, and then coerce from that type, as
opposed to a plain \f(CW\*(C`ArrayRef\*(C'\fR
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                 Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion5.16.3pm                                           0100644 0001750 0001750 00000027611 12566242167 032703  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion \- Demonstrates subtypes and coercion use HTTP\-related classes (Request, Protocol, etc.)
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Request;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use HTTP::Headers  ();
\&  use Params::Coerce ();
\&  use URI            ();
\&
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
\&
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
\&
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
\&
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
\&
\&  subtype \*(AqProtocol\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { /^HTTP\e/[0\-9]\e.[0\-9]$/ };
\&
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aqmethod\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqprotocol\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqProtocol\*(Aq );
\&  has \*(Aqheaders\*(Aq  => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces type coercions, which are defined with the
\&\f(CW\*(C`coerce\*(C'\fR sugar function. Coercions are attached to existing type
constraints, and define a (one-way) transformation from one type to
another.
.PP
This is very powerful, but it can also have unexpected consequences, so
you have to explicitly ask for an attribute to be coerced. To do this,
you must set the \f(CW\*(C`coerce\*(C'\fR attribute option to a true value.
.PP
First, we create the subtype to which we will coerce the other types:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
.Ve
.PP
We are creating a subtype rather than using \f(CW\*(C`HTTP::Headers\*(C'\fR as a type
directly. The reason we do this is that coercions are global, and a
coercion defined for \f(CW\*(C`HTTP::Headers\*(C'\fR in our \f(CW\*(C`Request\*(C'\fR class would
then be defined for \fIall\fR Moose-using classes in the current Perl
interpreter. It's a best practice to
avoid this sort of namespace pollution.
.PP
The \f(CW\*(C`class_type\*(C'\fR sugar function is simply a shortcut for this:
.PP
.Vb 3
\&  subtype \*(AqHTTP::Headers\*(Aq
\&      => as \*(AqObject\*(Aq
\&      => where { $_\->isa(\*(AqHTTP::Headers\*(Aq) };
.Ve
.PP
Internally, Moose creates a type constraint for each Moose-using
class, but for non-Moose classes, the type must be declared
explicitly.
.PP
We could go ahead and use this new type directly:
.PP
.Vb 5
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
This creates a simple attribute which defaults to an empty instance of
HTTP::Headers.
.PP
The constructor for HTTP::Headers accepts a list of key-value pairs
representing the \s-1HTTP\s0 header fields. In Perl, such a list could be
stored in an \s-1ARRAY\s0 or \s-1HASH\s0 reference. We want our \f(CW\*(C`headers\*(C'\fR attribute
to accept those data structures instead of an \fBHTTP::Headers\fR
instance, and just do the right thing. This is exactly what coercion
is for:
.PP
.Vb 5
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
.Ve
.PP
The first argument to \f(CW\*(C`coerce\*(C'\fR is the type \fIto\fR which we are
coercing. Then we give it a set of \f(CW\*(C`from\*(C'\fR/\f(CW\*(C`via\*(C'\fR clauses. The \f(CW\*(C`from\*(C'\fR
function takes some other type name and \f(CW\*(C`via\*(C'\fR takes a subroutine
reference which actually does the coercion.
.PP
However, defining the coercion doesn't do anything until we tell Moose
we want a particular attribute to be coerced:
.PP
.Vb 6
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
Now, if we use an \f(CW\*(C`ArrayRef\*(C'\fR or \f(CW\*(C`HashRef\*(C'\fR to populate \f(CW\*(C`headers\*(C'\fR, it
will be coerced into a new HTTP::Headers instance. With the
coercion in place, the following lines of code are all equivalent:
.PP
.Vb 3
\&  $foo\->headers( HTTP::Headers\->new( bar => 1, baz => 2 ) );
\&  $foo\->headers( [ \*(Aqbar\*(Aq, 1, \*(Aqbaz\*(Aq, 2 ] );
\&  $foo\->headers( { bar => 1, baz => 2 } );
.Ve
.PP
As you can see, careful use of coercions can produce a very open
interface for your class, while still retaining the \*(L"safety\*(R" of your
type constraint checks. (1)
.PP
Our next coercion shows how we can leverage existing \s-1CPAN\s0 modules to
help implement coercions. In this case we use Params::Coerce.
.PP
Once again, we need to declare a class type for our non-Moose \s-1URI\s0
class:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
.Ve
.PP
Then we define the coercion:
.PP
.Vb 7
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
.Ve
.PP
The first coercion takes any object and makes it a \f(CW\*(C`URI\*(C'\fR object. The
coercion system isn't that smart, and does not check if the object is
already a \s-1URI\s0, so we check for that ourselves. If it's not a \s-1URI\s0
already, we let Params::Coerce do its magic, and we just use its
return value.
.PP
If Params::Coerce didn't return a \s-1URI\s0 object (for whatever
reason), Moose would throw a type constraint error.
.PP
The other coercion takes a string and converts it to a \s-1URI\s0. In this
case, we are using the coercion to apply a default behavior, where a
string is assumed to be an \f(CW\*(C`http\*(C'\fR \s-1URI\s0.
.PP
Finally, we need to make sure our attributes enable coercion.
.PP
.Vb 2
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
.Ve
.PP
Re-using the coercion lets us enforce a consistent \s-1API\s0 across multiple
attributes.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe showed the use of coercions to create a more flexible and
DWIM-y \s-1API\s0. Like any powerful feature, we recommend some
caution. Sometimes it's better to reject a value than just guess at
how to \s-1DWIM\s0.
.PP
We also showed the use of the \f(CW\*(C`class_type\*(C'\fR sugar function as a
shortcut for defining a new subtype of \f(CW\*(C`Object\*(C'\fR.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
This particular example could be safer. Really we only want to coerce
an array with an \fIeven\fR number of elements. We could create a new
\&\f(CW\*(C`EvenElementArrayRef\*(C'\fR type, and then coerce from that type, as
opposed to a plain \f(CW\*(C`ArrayRef\*(C'\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                       Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion5.18.3pm                                           0100644 0001750 0001750 00000030657 12566242161 032703  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3"
.TH Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion \- Demonstrates subtypes and coercion use HTTP\-related classes (Request, Protocol, etc.)
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package Request;
\&  use Moose;
\&  use Moose::Util::TypeConstraints;
\&
\&  use HTTP::Headers  ();
\&  use Params::Coerce ();
\&  use URI            ();
\&
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
\&
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
\&
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
\&
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
\&
\&  subtype \*(AqProtocol\*(Aq
\&      => as \*(AqStr\*(Aq
\&      => where { /^HTTP\e/[0\-9]\e.[0\-9]$/ };
\&
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aqmethod\*(Aq   => ( is => \*(Aqrw\*(Aq, isa => \*(AqStr\*(Aq );
\&  has \*(Aqprotocol\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqProtocol\*(Aq );
\&  has \*(Aqheaders\*(Aq  => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe introduces type coercions, which are defined with the
\&\f(CW\*(C`coerce\*(C'\fR sugar function. Coercions are attached to existing type
constraints, and define a (one-way) transformation from one type to
another.
.PP
This is very powerful, but it can also have unexpected consequences, so
you have to explicitly ask for an attribute to be coerced. To do this,
you must set the \f(CW\*(C`coerce\*(C'\fR attribute option to a true value.
.PP
First, we create the subtype to which we will coerce the other types:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::HTTP::Headers\*(Aq => as class_type(\*(AqHTTP::Headers\*(Aq);
.Ve
.PP
We are creating a subtype rather than using \f(CW\*(C`HTTP::Headers\*(C'\fR as a type
directly. The reason we do this is that coercions are global, and a
coercion defined for \f(CW\*(C`HTTP::Headers\*(C'\fR in our \f(CW\*(C`Request\*(C'\fR class would
then be defined for \fIall\fR Moose-using classes in the current Perl
interpreter. It's a best practice to
avoid this sort of namespace pollution.
.PP
The \f(CW\*(C`class_type\*(C'\fR sugar function is simply a shortcut for this:
.PP
.Vb 3
\&  subtype \*(AqHTTP::Headers\*(Aq
\&      => as \*(AqObject\*(Aq
\&      => where { $_\->isa(\*(AqHTTP::Headers\*(Aq) };
.Ve
.PP
Internally, Moose creates a type constraint for each Moose-using
class, but for non-Moose classes, the type must be declared
explicitly.
.PP
We could go ahead and use this new type directly:
.PP
.Vb 5
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
This creates a simple attribute which defaults to an empty instance of
HTTP::Headers.
.PP
The constructor for HTTP::Headers accepts a list of key-value pairs
representing the \s-1HTTP\s0 header fields. In Perl, such a list could be
stored in an \s-1ARRAY\s0 or \s-1HASH\s0 reference. We want our \f(CW\*(C`headers\*(C'\fR attribute
to accept those data structures instead of an \fBHTTP::Headers\fR
instance, and just do the right thing. This is exactly what coercion
is for:
.PP
.Vb 5
\&  coerce \*(AqMy::Types::HTTP::Headers\*(Aq
\&      => from \*(AqArrayRef\*(Aq
\&          => via { HTTP::Headers\->new( @{$_} ) }
\&      => from \*(AqHashRef\*(Aq
\&          => via { HTTP::Headers\->new( %{$_} ) };
.Ve
.PP
The first argument to \f(CW\*(C`coerce\*(C'\fR is the type \fIto\fR which we are
coercing. Then we give it a set of \f(CW\*(C`from\*(C'\fR/\f(CW\*(C`via\*(C'\fR clauses. The \f(CW\*(C`from\*(C'\fR
function takes some other type name and \f(CW\*(C`via\*(C'\fR takes a subroutine
reference which actually does the coercion.
.PP
However, defining the coercion doesn't do anything until we tell Moose
we want a particular attribute to be coerced:
.PP
.Vb 6
\&  has \*(Aqheaders\*(Aq => (
\&      is      => \*(Aqrw\*(Aq,
\&      isa     => \*(AqMy::Types::HTTP::Headers\*(Aq,
\&      coerce  => 1,
\&      default => sub { HTTP::Headers\->new }
\&  );
.Ve
.PP
Now, if we use an \f(CW\*(C`ArrayRef\*(C'\fR or \f(CW\*(C`HashRef\*(C'\fR to populate \f(CW\*(C`headers\*(C'\fR, it
will be coerced into a new HTTP::Headers instance. With the
coercion in place, the following lines of code are all equivalent:
.PP
.Vb 3
\&  $foo\->headers( HTTP::Headers\->new( bar => 1, baz => 2 ) );
\&  $foo\->headers( [ \*(Aqbar\*(Aq, 1, \*(Aqbaz\*(Aq, 2 ] );
\&  $foo\->headers( { bar => 1, baz => 2 } );
.Ve
.PP
As you can see, careful use of coercions can produce a very open
interface for your class, while still retaining the \*(L"safety\*(R" of your
type constraint checks. (1)
.PP
Our next coercion shows how we can leverage existing \s-1CPAN\s0 modules to
help implement coercions. In this case we use Params::Coerce.
.PP
Once again, we need to declare a class type for our non-Moose \s-1URI\s0
class:
.PP
.Vb 1
\&  subtype \*(AqMy::Types::URI\*(Aq => as class_type(\*(AqURI\*(Aq);
.Ve
.PP
Then we define the coercion:
.PP
.Vb 7
\&  coerce \*(AqMy::Types::URI\*(Aq
\&      => from \*(AqObject\*(Aq
\&          => via { $_\->isa(\*(AqURI\*(Aq)
\&                   ? $_
\&                   : Params::Coerce::coerce( \*(AqURI\*(Aq, $_ ); }
\&      => from \*(AqStr\*(Aq
\&          => via { URI\->new( $_, \*(Aqhttp\*(Aq ) };
.Ve
.PP
The first coercion takes any object and makes it a \f(CW\*(C`URI\*(C'\fR object. The
coercion system isn't that smart, and does not check if the object is
already a \s-1URI\s0, so we check for that ourselves. If it's not a \s-1URI\s0
already, we let Params::Coerce do its magic, and we just use its
return value.
.PP
If Params::Coerce didn't return a \s-1URI\s0 object (for whatever
reason), Moose would throw a type constraint error.
.PP
The other coercion takes a string and converts it to a \s-1URI\s0. In this
case, we are using the coercion to apply a default behavior, where a
string is assumed to be an \f(CW\*(C`http\*(C'\fR \s-1URI.\s0
.PP
Finally, we need to make sure our attributes enable coercion.
.PP
.Vb 2
\&  has \*(Aqbase\*(Aq => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
\&  has \*(Aquri\*(Aq  => ( is => \*(Aqrw\*(Aq, isa => \*(AqMy::Types::URI\*(Aq, coerce => 1 );
.Ve
.PP
Re-using the coercion lets us enforce a consistent \s-1API\s0 across multiple
attributes.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe showed the use of coercions to create a more flexible and
DWIM-y \s-1API.\s0 Like any powerful feature, we recommend some
caution. Sometimes it's better to reject a value than just guess at
how to \s-1DWIM.\s0
.PP
We also showed the use of the \f(CW\*(C`class_type\*(C'\fR sugar function as a
shortcut for defining a new subtype of \f(CW\*(C`Object\*(C'\fR.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
This particular example could be safer. Really we only want to coerce
an array with an \fIeven\fR number of elements. We could create a new
\&\f(CW\*(C`EvenElementArrayRef\*(C'\fR type, and then coerce from that type, as
opposed to a plain \f(CW\*(C`ArrayRef\*(C'\fR
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook::Basics::Immutable.3pm       0100644 0001750 0001750 00000013656 12566242161 027603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Immutable 3"
.TH Moose::Cookbook::Basics::Immutable 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Immutable \- Making Moose fast by making your class immutable
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose metaclass \s-1API\s0 provides a \f(CW\*(C`make_immutable()\*(C'\fR method. Calling
this method does two things to your class. First, it makes it
faster. In particular, object construction and destruction are
effectively \*(L"inlined\*(R" in your class, and no longer invoke the meta
\&\s-1API.\s0
.PP
Second, you can no longer make changes via the metaclass \s-1API,\s0 such as
adding attributes. In practice, this won't be a problem, as you rarely
need to do this after first loading the class.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We strongly recommend you make your classes immutable. It makes your
code much faster, with a small compile-time cost. This will be
especially noticeable when creating many objects.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook::Basics::Immutable5.16.3pm   0100644 0001750 0001750 00000012610 12566242167 030110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Immutable 3"
.TH Moose::Cookbook::Basics::Immutable 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Immutable \- Making Moose fast by making your class immutable
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose metaclass \s-1API\s0 provides a \f(CW\*(C`make_immutable()\*(C'\fR method. Calling
this method does two things to your class. First, it makes it
faster. In particular, object construction and destruction are
effectively \*(L"inlined\*(R" in your class, and no longer invoke the meta
\&\s-1API\s0.
.PP
Second, you can no longer make changes via the metaclass \s-1API\s0, such as
adding attributes. In practice, this won't be a problem, as you rarely
need to do this after first loading the class.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We strongly recommend you make your classes immutable. It makes your
code much faster, with a small compile-time cost. This will be
especially noticeable when creating many objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Moose::Cookbook::Basics::Immutable5.18.3pm   0100644 0001750 0001750 00000013656 12566242161 030117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Immutable 3"
.TH Moose::Cookbook::Basics::Immutable 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Immutable \- Making Moose fast by making your class immutable
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
\&
\&  _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Moose metaclass \s-1API\s0 provides a \f(CW\*(C`make_immutable()\*(C'\fR method. Calling
this method does two things to your class. First, it makes it
faster. In particular, object construction and destruction are
effectively \*(L"inlined\*(R" in your class, and no longer invoke the meta
\&\s-1API.\s0
.PP
Second, you can no longer make changes via the metaclass \s-1API,\s0 such as
adding attributes. In practice, this won't be a problem, as you rarely
need to do this after first loading the class.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We strongly recommend you make your classes immutable. It makes your
code much faster, with a small compile-time cost. This will be
especially noticeable when creating many objects.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                  Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD.3pm                                               0100644 0001750 0001750 00000022040 12566242161 031635  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3"
.TH Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD \- Using BUILDARGS and BUILD to hook into object construction
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Person;
\&
\&  has \*(Aqssn\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_ssn\*(Aq,
\&  );
\&
\&  has \*(Aqcountry_of_residence\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(Aqusa\*(Aq
\&  );
\&
\&  has \*(Aqfirst_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  has \*(Aqlast_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  around BUILDARGS => sub {
\&      my $orig = shift;
\&      my $class = shift;
\&
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
\&      else {
\&          return $class\->$orig(@_);
\&      }
\&  };
\&
\&  sub BUILD {
\&      my $self = shift;
\&
\&      if ( $self\->country_of_residence eq \*(Aqusa\*(Aq ) {
\&          die \*(AqCannot create a Person who lives in the USA without an ssn.\*(Aq
\&              unless $self\->has_ssn;
\&      }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR. By
defining these methods, we can hook into the object construction
process without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method is called \fIbefore\fR an object has been
created. It is called as a class method, and receives all of the
parameters passed to the \f(CW\*(C`new\*(C'\fR method. It is expected to do something
with these arguments and return a hash reference. The keys of the hash
must be attribute \f(CW\*(C`init_arg\*(C'\fRs.
.PP
The primary purpose of \f(CW\*(C`BUILDARGS\*(C'\fR is to allow a class to accept
something other than named arguments. In the case of our \f(CW\*(C`Person\*(C'\fR
class, we are allowing it to be called with a single argument, a
social security number:
.PP
.Vb 1
\&  my $person = Person\->new(\*(Aq123\-45\-6789\*(Aq);
.Ve
.PP
The key part of our \f(CW\*(C`BUILDARGS\*(C'\fR is this conditional:
.PP
.Vb 3
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
.Ve
.PP
By default, Moose constructors accept a list of key-value pairs, or a
hash reference. We need to make sure that \f(CW$_[0]\fR is not a reference
before assuming it is a social security number.
.PP
We call the original \f(CW\*(C`BUILDARGS\*(C'\fR method to handle all the other
cases. You should always do this in your own \f(CW\*(C`BUILDARGS\*(C'\fR methods,
since Moose::Object provides its own \f(CW\*(C`BUILDARGS\*(C'\fR method that
handles hash references and a list of key-value pairs.
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is called \fIafter\fR the object is constructed, but
before it is returned to the caller. The \f(CW\*(C`BUILD\*(C'\fR method provides an
opportunity to check the object state as a whole. This is a good place
to put logic that cannot be expressed as a type constraint on a single
attribute.
.PP
In the \f(CW\*(C`Person\*(C'\fR class, we need to check the relationship between two
attributes, \f(CW\*(C`ssn\*(C'\fR and \f(CW\*(C`country_of_residence\*(C'\fR. We throw an exception
if the object is not logically consistent.
.SH "MORE CONSIDERATIONS"
.IX Header "MORE CONSIDERATIONS"
This recipe is made significantly simpler because all of the
attributes are read-only. If the \f(CW\*(C`country_of_residence\*(C'\fR attribute
were settable, we would need to check that a Person had an \f(CW\*(C`ssn\*(C'\fR if
the new country was \f(CW\*(C`usa\*(C'\fR. This could be done with a \f(CW\*(C`before\*(C'\fR
modifier.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We have repeatedly discouraged overriding \f(CW\*(C`new\*(C'\fR in Moose
classes. This recipe shows how you can use \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR
to hook into object construction without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method lets us expand on Moose's built-in parameter
handling for constructors. The \f(CW\*(C`BUILD\*(C'\fR method lets us implement
logical constraints across the whole object after it is created.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD5.16.3pm                                           0100644 0001750 0001750 00000020772 12566242166 032166  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3"
.TH Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD \- Using BUILDARGS and BUILD to hook into object construction
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Person;
\&
\&  has \*(Aqssn\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_ssn\*(Aq,
\&  );
\&
\&  has \*(Aqcountry_of_residence\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(Aqusa\*(Aq
\&  );
\&
\&  has \*(Aqfirst_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  has \*(Aqlast_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  around BUILDARGS => sub {
\&      my $orig = shift;
\&      my $class = shift;
\&
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
\&      else {
\&          return $class\->$orig(@_);
\&      }
\&  };
\&
\&  sub BUILD {
\&      my $self = shift;
\&
\&      if ( $self\->country_of_residence eq \*(Aqusa\*(Aq ) {
\&          die \*(AqCannot create a Person who lives in the USA without an ssn.\*(Aq
\&              unless $self\->has_ssn;
\&      }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR. By
defining these methods, we can hook into the object construction
process without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method is called \fIbefore\fR an object has been
created. It is called as a class method, and receives all of the
parameters passed to the \f(CW\*(C`new\*(C'\fR method. It is expected to do something
with these arguments and return a hash reference. The keys of the hash
must be attribute \f(CW\*(C`init_arg\*(C'\fRs.
.PP
The primary purpose of \f(CW\*(C`BUILDARGS\*(C'\fR is to allow a class to accept
something other than named arguments. In the case of our \f(CW\*(C`Person\*(C'\fR
class, we are allowing it to be called with a single argument, a
social security number:
.PP
.Vb 1
\&  my $person = Person\->new(\*(Aq123\-45\-6789\*(Aq);
.Ve
.PP
The key part of our \f(CW\*(C`BUILDARGS\*(C'\fR is this conditional:
.PP
.Vb 3
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
.Ve
.PP
By default, Moose constructors accept a list of key-value pairs, or a
hash reference. We need to make sure that \f(CW$_[0]\fR is not a reference
before assuming it is a social security number.
.PP
We call the original \f(CW\*(C`BUILDARGS\*(C'\fR method to handle all the other
cases. You should always do this in your own \f(CW\*(C`BUILDARGS\*(C'\fR methods,
since Moose::Object provides its own \f(CW\*(C`BUILDARGS\*(C'\fR method that
handles hash references and a list of key-value pairs.
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is called \fIafter\fR the object is constructed, but
before it is returned to the caller. The \f(CW\*(C`BUILD\*(C'\fR method provides an
opportunity to check the object state as a whole. This is a good place
to put logic that cannot be expressed as a type constraint on a single
attribute.
.PP
In the \f(CW\*(C`Person\*(C'\fR class, we need to check the relationship between two
attributes, \f(CW\*(C`ssn\*(C'\fR and \f(CW\*(C`country_of_residence\*(C'\fR. We throw an exception
if the object is not logically consistent.
.SH "MORE CONSIDERATIONS"
.IX Header "MORE CONSIDERATIONS"
This recipe is made significantly simpler because all of the
attributes are read-only. If the \f(CW\*(C`country_of_residence\*(C'\fR attribute
were settable, we would need to check that a Person had an \f(CW\*(C`ssn\*(C'\fR if
the new country was \f(CW\*(C`usa\*(C'\fR. This could be done with a \f(CW\*(C`before\*(C'\fR
modifier.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We have repeatedly discouraged overriding \f(CW\*(C`new\*(C'\fR in Moose
classes. This recipe shows how you can use \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR
to hook into object construction without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method lets us expand on Moose's built-in parameter
handling for constructors. The \f(CW\*(C`BUILD\*(C'\fR method lets us implement
logical constraints across the whole object after it is created.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
      Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD5.18.3pm                                           0100644 0001750 0001750 00000022040 12566242161 032151  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3"
.TH Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Person_BUILDARGSAndBUILD \- Using BUILDARGS and BUILD to hook into object construction
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Person;
\&
\&  has \*(Aqssn\*(Aq => (
\&      is        => \*(Aqro\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_ssn\*(Aq,
\&  );
\&
\&  has \*(Aqcountry_of_residence\*(Aq => (
\&      is      => \*(Aqro\*(Aq,
\&      isa     => \*(AqStr\*(Aq,
\&      default => \*(Aqusa\*(Aq
\&  );
\&
\&  has \*(Aqfirst_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  has \*(Aqlast_name\*(Aq => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  around BUILDARGS => sub {
\&      my $orig = shift;
\&      my $class = shift;
\&
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
\&      else {
\&          return $class\->$orig(@_);
\&      }
\&  };
\&
\&  sub BUILD {
\&      my $self = shift;
\&
\&      if ( $self\->country_of_residence eq \*(Aqusa\*(Aq ) {
\&          die \*(AqCannot create a Person who lives in the USA without an ssn.\*(Aq
\&              unless $self\->has_ssn;
\&      }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe demonstrates the use of \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR. By
defining these methods, we can hook into the object construction
process without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method is called \fIbefore\fR an object has been
created. It is called as a class method, and receives all of the
parameters passed to the \f(CW\*(C`new\*(C'\fR method. It is expected to do something
with these arguments and return a hash reference. The keys of the hash
must be attribute \f(CW\*(C`init_arg\*(C'\fRs.
.PP
The primary purpose of \f(CW\*(C`BUILDARGS\*(C'\fR is to allow a class to accept
something other than named arguments. In the case of our \f(CW\*(C`Person\*(C'\fR
class, we are allowing it to be called with a single argument, a
social security number:
.PP
.Vb 1
\&  my $person = Person\->new(\*(Aq123\-45\-6789\*(Aq);
.Ve
.PP
The key part of our \f(CW\*(C`BUILDARGS\*(C'\fR is this conditional:
.PP
.Vb 3
\&      if ( @_ == 1 && ! ref $_[0] ) {
\&          return $class\->$orig(ssn => $_[0]);
\&      }
.Ve
.PP
By default, Moose constructors accept a list of key-value pairs, or a
hash reference. We need to make sure that \f(CW$_[0]\fR is not a reference
before assuming it is a social security number.
.PP
We call the original \f(CW\*(C`BUILDARGS\*(C'\fR method to handle all the other
cases. You should always do this in your own \f(CW\*(C`BUILDARGS\*(C'\fR methods,
since Moose::Object provides its own \f(CW\*(C`BUILDARGS\*(C'\fR method that
handles hash references and a list of key-value pairs.
.PP
The \f(CW\*(C`BUILD\*(C'\fR method is called \fIafter\fR the object is constructed, but
before it is returned to the caller. The \f(CW\*(C`BUILD\*(C'\fR method provides an
opportunity to check the object state as a whole. This is a good place
to put logic that cannot be expressed as a type constraint on a single
attribute.
.PP
In the \f(CW\*(C`Person\*(C'\fR class, we need to check the relationship between two
attributes, \f(CW\*(C`ssn\*(C'\fR and \f(CW\*(C`country_of_residence\*(C'\fR. We throw an exception
if the object is not logically consistent.
.SH "MORE CONSIDERATIONS"
.IX Header "MORE CONSIDERATIONS"
This recipe is made significantly simpler because all of the
attributes are read-only. If the \f(CW\*(C`country_of_residence\*(C'\fR attribute
were settable, we would need to check that a Person had an \f(CW\*(C`ssn\*(C'\fR if
the new country was \f(CW\*(C`usa\*(C'\fR. This could be done with a \f(CW\*(C`before\*(C'\fR
modifier.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
We have repeatedly discouraged overriding \f(CW\*(C`new\*(C'\fR in Moose
classes. This recipe shows how you can use \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`BUILD\*(C'\fR
to hook into object construction without overriding \f(CW\*(C`new\*(C'\fR.
.PP
The \f(CW\*(C`BUILDARGS\*(C'\fR method lets us expand on Moose's built-in parameter
handling for constructors. The \f(CW\*(C`BUILD\*(C'\fR method lets us implement
logical constraints across the whole object after it is created.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Moose::Cookbook::Basics::Point_AttributesAndSubclassing.3pm                                         0100644 0001750 0001750 00000031213 12566242162 033713  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3"
.TH Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Point_AttributesAndSubclassing \- Point and Point3D classes, showing basic attributes and subclassing.
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&  has \*(Aqy\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
\&
\&  package main;
\&
\&  # hash or hashrefs are ok for the constructor
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the classic Point example. It is taken directly from the Perl
6 Apocalypse 12 document, and is similar to the example found in the
classic K&R C book as well.
.PP
As with all Perl 5 classes, a Moose class is defined in a package.
Moose handles turning on \f(CW\*(C`strict\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR for us, so all we
need to do is say \f(CW\*(C`use Moose\*(C'\fR, and no kittens will die.
.PP
When Moose is loaded, it exports a set of sugar functions into our
package. This means that we import some functions which serve as Moose
\&\*(L"keywords\*(R". These aren't real language keywords, they're just Perl
functions exported into our package.
.PP
Moose automatically makes our package a subclass of Moose::Object.
The Moose::Object class provides us with a constructor that
respects our attributes, as well other features. See Moose::Object
for details.
.PP
Now, onto the keywords. The first one we see here is \f(CW\*(C`has\*(C'\fR, which
defines an instance attribute in our class:
.PP
.Vb 1
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This will create an attribute named \f(CW\*(C`x\*(C'\fR. The \f(CW\*(C`isa\*(C'\fR parameter says
that we expect the value stored in this attribute to pass the type
constraint for \f(CW\*(C`Int\*(C'\fR (1). The accessor generated for this attribute
will be read-write.
.PP
The \f(CW\*(C`required => 1\*(C'\fR parameter means that this attribute must be
provided when a new object is created. A point object without
coordinates doesn't make much sense, so we don't allow it.
.PP
We have defined our attributes; next we define our methods. In Moose,
as with regular Perl 5 \s-1OO,\s0 a method is just a subroutine defined
within the package:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
.Ve
.PP
That concludes the \fBPoint\fR class.
.PP
Next we have a subclass of \fBPoint\fR, \fBPoint3D\fR. To declare our
superclass, we use the Moose keyword \f(CW\*(C`extends\*(C'\fR:
.PP
.Vb 1
\&  extends \*(AqPoint\*(Aq;
.Ve
.PP
The \f(CW\*(C`extends\*(C'\fR keyword works much like \f(CW\*(C`use base\*(C'\fR/\f(CW\*(C`use parent\*(C'\fR. First,
it will attempt to load your class if needed. However, unlike \f(CW\*(C`base\*(C'\fR, the
\&\f(CW\*(C`extends\*(C'\fR keyword will \fIoverwrite\fR any previous values in your
package's \f(CW@ISA\fR, where \f(CW\*(C`use base\*(C'\fR will \f(CW\*(C`push\*(C'\fR values onto the
package's \f(CW@ISA\fR.
.PP
It is my opinion that the behavior of \f(CW\*(C`extends\*(C'\fR is more intuitive.
(2).
.PP
Next we create a new attribute for \fBPoint3D\fR called \f(CW\*(C`z\*(C'\fR.
.PP
.Vb 1
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This attribute is just like \fBPoint\fR's \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR attributes.
.PP
The \f(CW\*(C`after\*(C'\fR keyword demonstrates a Moose feature called \*(L"method
modifiers\*(R" (or \*(L"advice\*(R" for the \s-1AOP\s0 inclined):
.PP
.Vb 4
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.PP
When \f(CW\*(C`clear\*(C'\fR is called on a \fBPoint3D\fR object, our modifier method
gets called as well. Unsurprisingly, the modifier is called \fIafter\fR
the real method.
.PP
In this case, the real \f(CW\*(C`clear\*(C'\fR method is inherited from \fBPoint\fR. Our
modifier method receives the same arguments as those passed to the
modified method (just \f(CW$self\fR here).
.PP
Of course, using the \f(CW\*(C`after\*(C'\fR modifier is not the only way to
accomplish this. This \fBis\fR Perl, right? You can get the same results
with this code:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->SUPER::clear();
\&      $self\->z(0);
\&  }
.Ve
.PP
You could also use another Moose method modifier, \f(CW\*(C`override\*(C'\fR:
.PP
.Vb 5
\&  override \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      super();
\&      $self\->z(0);
\&  };
.Ve
.PP
The \f(CW\*(C`override\*(C'\fR modifier allows you to use the \f(CW\*(C`super\*(C'\fR keyword to
dispatch to the superclass's method in a very Ruby-ish style.
.PP
The choice of whether to use a method modifier, and which one to use,
is often a question of style as much as functionality.
.PP
Since \fBPoint\fR inherits from Moose::Object, it will also inherit
the default Moose::Object constructor:
.PP
.Vb 2
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor accepts a named argument pair for each
attribute defined by the class, which you can provide as a hash or
hash reference. In this particular example, the attributes are
required, and calling \f(CW\*(C`new\*(C'\fR without them will throw an error.
.PP
.Vb 1
\&  my $point = Point\->new( x => 5 ); # no y, kaboom!
.Ve
.PP
From here on, we can use \f(CW$point\fR and \f(CW$point3d\fR just as you would
any other Perl 5 object. For a more detailed example of what can be
done, you can refer to the
\&\fIt/recipes/moose_cookbook_basics_point_attributesandsubclassing.t\fR test file.
.SS "Moose Objects are Just Hashrefs"
.IX Subsection "Moose Objects are Just Hashrefs"
While this all may appear rather magical, it's important to realize
that Moose objects are just hash references under the hood (3). For
example, you could pass \f(CW$self\fR to \f(CW\*(C`Data::Dumper\*(C'\fR and you'd get
exactly what you'd expect.
.PP
You could even poke around inside the object's data structure, but
that is strongly discouraged.
.PP
The fact that Moose objects are hashrefs means it is easy to use Moose
to extend non-Moose classes, as long as they too are hash
references. If you want to extend a non-hashref class, check out
\&\f(CW\*(C`MooseX::InsideOut\*(C'\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe demonstrates some basic Moose concepts, attributes,
subclassing, and a simple method modifier.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Moose provides a number of builtin type constraints, of which \f(CW\*(C`Int\*(C'\fR
is one. For more information on the type constraint system, see
Moose::Util::TypeConstraints.
.IP "(2)" 4
.IX Item "(2)"
The \f(CW\*(C`extends\*(C'\fR keyword supports multiple inheritance. Simply pass all
of your superclasses to \f(CW\*(C`extends\*(C'\fR as a list:
.Sp
.Vb 1
\&  extends \*(AqFoo\*(Aq, \*(AqBar\*(Aq, \*(AqBaz\*(Aq;
.Ve
.IP "(3)" 4
.IX Item "(3)"
Moose supports using instance structures other than blessed hash
references (such as glob references \- see MooseX::GlobRef).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Method Modifiers" 4
.IX Item "Method Modifiers"
The concept of method modifiers is directly ripped off from \s-1CLOS. A\s0
great explanation of them can be found by following this link.
.Sp
<http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                     Moose::Cookbook::Basics::Point_AttributesAndSubclassing5.16.3pm                                     0100644 0001750 0001750 00000030224 12566242166 034232  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3"
.TH Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Point_AttributesAndSubclassing \- Point and Point3D classes, showing basic attributes and subclassing.
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&  has \*(Aqy\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
\&
\&  package main;
\&
\&  # hash or hashrefs are ok for the constructor
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the classic Point example. It is taken directly from the Perl
6 Apocalypse 12 document, and is similar to the example found in the
classic K&R C book as well.
.PP
As with all Perl 5 classes, a Moose class is defined in a package.
Moose handles turning on \f(CW\*(C`strict\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR for us, so all we
need to do is say \f(CW\*(C`use Moose\*(C'\fR, and no kittens will die.
.PP
When Moose is loaded, it exports a set of sugar functions into our
package. This means that we import some functions which serve as Moose
\&\*(L"keywords\*(R". These aren't real language keywords, they're just Perl
functions exported into our package.
.PP
Moose automatically makes our package a subclass of Moose::Object.
The Moose::Object class provides us with a constructor that
respects our attributes, as well other features. See Moose::Object
for details.
.PP
Now, onto the keywords. The first one we see here is \f(CW\*(C`has\*(C'\fR, which
defines an instance attribute in our class:
.PP
.Vb 1
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This will create an attribute named \f(CW\*(C`x\*(C'\fR. The \f(CW\*(C`isa\*(C'\fR parameter says
that we expect the value stored in this attribute to pass the type
constraint for \f(CW\*(C`Int\*(C'\fR (1). The accessor generated for this attribute
will be read-write.
.PP
The \f(CW\*(C`required => 1\*(C'\fR parameter means that this attribute must be
provided when a new object is created. A point object without
coordinates doesn't make much sense, so we don't allow it.
.PP
We have defined our attributes; next we define our methods. In Moose,
as with regular Perl 5 \s-1OO\s0, a method is just a subroutine defined
within the package:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
.Ve
.PP
That concludes the \fBPoint\fR class.
.PP
Next we have a subclass of \fBPoint\fR, \fBPoint3D\fR. To declare our
superclass, we use the Moose keyword \f(CW\*(C`extends\*(C'\fR:
.PP
.Vb 1
\&  extends \*(AqPoint\*(Aq;
.Ve
.PP
The \f(CW\*(C`extends\*(C'\fR keyword works much like \f(CW\*(C`use base\*(C'\fR. First, it will
attempt to load your class if needed. However, unlike \f(CW\*(C`base\*(C'\fR, the
\&\f(CW\*(C`extends\*(C'\fR keyword will \fIoverwrite\fR any previous values in your
package's \f(CW@ISA\fR, where \f(CW\*(C`use base\*(C'\fR will \f(CW\*(C`push\*(C'\fR values onto the
package's \f(CW@ISA\fR.
.PP
It is my opinion that the behavior of \f(CW\*(C`extends\*(C'\fR is more intuitive.
(2).
.PP
Next we create a new attribute for \fBPoint3D\fR called \f(CW\*(C`z\*(C'\fR.
.PP
.Vb 1
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This attribute is just like \fBPoint\fR's \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR attributes.
.PP
The \f(CW\*(C`after\*(C'\fR keyword demonstrates a Moose feature called \*(L"method
modifiers\*(R" (or \*(L"advice\*(R" for the \s-1AOP\s0 inclined):
.PP
.Vb 4
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.PP
When \f(CW\*(C`clear\*(C'\fR is called on a \fBPoint3D\fR object, our modifier method
gets called as well. Unsurprisingly, the modifier is called \fIafter\fR
the real method.
.PP
In this case, the real \f(CW\*(C`clear\*(C'\fR method is inherited from \fBPoint\fR. Our
modifier method receives the same arguments as those passed to the
modified method (just \f(CW$self\fR here).
.PP
Of course, using the \f(CW\*(C`after\*(C'\fR modifier is not the only way to
accomplish this. This \fBis\fR Perl, right? You can get the same results
with this code:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->SUPER::clear();
\&      $self\->z(0);
\&  }
.Ve
.PP
You could also use another Moose method modifier, \f(CW\*(C`override\*(C'\fR:
.PP
.Vb 5
\&  override \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      super();
\&      $self\->z(0);
\&  };
.Ve
.PP
The \f(CW\*(C`override\*(C'\fR modifier allows you to use the \f(CW\*(C`super\*(C'\fR keyword to
dispatch to the superclass's method in a very Ruby-ish style.
.PP
The choice of whether to use a method modifier, and which one to use,
is often a question of style as much as functionality.
.PP
Since \fBPoint\fR inherits from Moose::Object, it will also inherit
the default Moose::Object constructor:
.PP
.Vb 2
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor accepts a named argument pair for each
attribute defined by the class, which you can provide as a hash or
hash reference. In this particular example, the attributes are
required, and calling \f(CW\*(C`new\*(C'\fR without them will throw an error.
.PP
.Vb 1
\&  my $point = Point\->new( x => 5 ); # no y, kaboom!
.Ve
.PP
From here on, we can use \f(CW$point\fR and \f(CW$point3d\fR just as you would
any other Perl 5 object. For a more detailed example of what can be
done, you can refer to the
\&\fIt/recipes/moose_cookbook_basics_point_attributesandsubclassing.t\fR test file.
.SS "Moose Objects are Just Hashrefs"
.IX Subsection "Moose Objects are Just Hashrefs"
While this all may appear rather magical, it's important to realize
that Moose objects are just hash references under the hood (3). For
example, you could pass \f(CW$self\fR to \f(CW\*(C`Data::Dumper\*(C'\fR and you'd get
exactly what you'd expect.
.PP
You could even poke around inside the object's data structure, but
that is strongly discouraged.
.PP
The fact that Moose objects are hashrefs means it is easy to use Moose
to extend non-Moose classes, as long as they too are hash
references. If you want to extend a non-hashref class, check out
\&\f(CW\*(C`MooseX::InsideOut\*(C'\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe demonstrates some basic Moose concepts, attributes,
subclassing, and a simple method modifier.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Moose provides a number of builtin type constraints, of which \f(CW\*(C`Int\*(C'\fR
is one. For more information on the type constraint system, see
Moose::Util::TypeConstraints.
.IP "(2)" 4
.IX Item "(2)"
The \f(CW\*(C`extends\*(C'\fR keyword supports multiple inheritance. Simply pass all
of your superclasses to \f(CW\*(C`extends\*(C'\fR as a list:
.Sp
.Vb 1
\&  extends \*(AqFoo\*(Aq, \*(AqBar\*(Aq, \*(AqBaz\*(Aq;
.Ve
.IP "(3)" 4
.IX Item "(3)"
Moose supports using instance structures other than blessed hash
references (such as glob references \- see MooseX::GlobRef).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Method Modifiers" 4
.IX Item "Method Modifiers"
The concept of method modifiers is directly ripped off from \s-1CLOS\s0. A
great explanation of them can be found by following this link.
.Sp
http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html <http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                            Moose::Cookbook::Basics::Point_AttributesAndSubclassing5.18.3pm                                     0100644 0001750 0001750 00000031213 12566242162 034227  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3"
.TH Moose::Cookbook::Basics::Point_AttributesAndSubclassing 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Basics::Point_AttributesAndSubclassing \- Point and Point3D classes, showing basic attributes and subclassing.
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Point;
\&  use Moose;
\&
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&  has \*(Aqy\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
\&
\&  package Point3D;
\&  use Moose;
\&
\&  extends \*(AqPoint\*(Aq;
\&
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
\&
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
\&
\&  package main;
\&
\&  # hash or hashrefs are ok for the constructor
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the classic Point example. It is taken directly from the Perl
6 Apocalypse 12 document, and is similar to the example found in the
classic K&R C book as well.
.PP
As with all Perl 5 classes, a Moose class is defined in a package.
Moose handles turning on \f(CW\*(C`strict\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR for us, so all we
need to do is say \f(CW\*(C`use Moose\*(C'\fR, and no kittens will die.
.PP
When Moose is loaded, it exports a set of sugar functions into our
package. This means that we import some functions which serve as Moose
\&\*(L"keywords\*(R". These aren't real language keywords, they're just Perl
functions exported into our package.
.PP
Moose automatically makes our package a subclass of Moose::Object.
The Moose::Object class provides us with a constructor that
respects our attributes, as well other features. See Moose::Object
for details.
.PP
Now, onto the keywords. The first one we see here is \f(CW\*(C`has\*(C'\fR, which
defines an instance attribute in our class:
.PP
.Vb 1
\&  has \*(Aqx\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This will create an attribute named \f(CW\*(C`x\*(C'\fR. The \f(CW\*(C`isa\*(C'\fR parameter says
that we expect the value stored in this attribute to pass the type
constraint for \f(CW\*(C`Int\*(C'\fR (1). The accessor generated for this attribute
will be read-write.
.PP
The \f(CW\*(C`required => 1\*(C'\fR parameter means that this attribute must be
provided when a new object is created. A point object without
coordinates doesn't make much sense, so we don't allow it.
.PP
We have defined our attributes; next we define our methods. In Moose,
as with regular Perl 5 \s-1OO,\s0 a method is just a subroutine defined
within the package:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->x(0);
\&      $self\->y(0);
\&  }
.Ve
.PP
That concludes the \fBPoint\fR class.
.PP
Next we have a subclass of \fBPoint\fR, \fBPoint3D\fR. To declare our
superclass, we use the Moose keyword \f(CW\*(C`extends\*(C'\fR:
.PP
.Vb 1
\&  extends \*(AqPoint\*(Aq;
.Ve
.PP
The \f(CW\*(C`extends\*(C'\fR keyword works much like \f(CW\*(C`use base\*(C'\fR/\f(CW\*(C`use parent\*(C'\fR. First,
it will attempt to load your class if needed. However, unlike \f(CW\*(C`base\*(C'\fR, the
\&\f(CW\*(C`extends\*(C'\fR keyword will \fIoverwrite\fR any previous values in your
package's \f(CW@ISA\fR, where \f(CW\*(C`use base\*(C'\fR will \f(CW\*(C`push\*(C'\fR values onto the
package's \f(CW@ISA\fR.
.PP
It is my opinion that the behavior of \f(CW\*(C`extends\*(C'\fR is more intuitive.
(2).
.PP
Next we create a new attribute for \fBPoint3D\fR called \f(CW\*(C`z\*(C'\fR.
.PP
.Vb 1
\&  has \*(Aqz\*(Aq => (isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq, required => 1);
.Ve
.PP
This attribute is just like \fBPoint\fR's \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR attributes.
.PP
The \f(CW\*(C`after\*(C'\fR keyword demonstrates a Moose feature called \*(L"method
modifiers\*(R" (or \*(L"advice\*(R" for the \s-1AOP\s0 inclined):
.PP
.Vb 4
\&  after \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      $self\->z(0);
\&  };
.Ve
.PP
When \f(CW\*(C`clear\*(C'\fR is called on a \fBPoint3D\fR object, our modifier method
gets called as well. Unsurprisingly, the modifier is called \fIafter\fR
the real method.
.PP
In this case, the real \f(CW\*(C`clear\*(C'\fR method is inherited from \fBPoint\fR. Our
modifier method receives the same arguments as those passed to the
modified method (just \f(CW$self\fR here).
.PP
Of course, using the \f(CW\*(C`after\*(C'\fR modifier is not the only way to
accomplish this. This \fBis\fR Perl, right? You can get the same results
with this code:
.PP
.Vb 5
\&  sub clear {
\&      my $self = shift;
\&      $self\->SUPER::clear();
\&      $self\->z(0);
\&  }
.Ve
.PP
You could also use another Moose method modifier, \f(CW\*(C`override\*(C'\fR:
.PP
.Vb 5
\&  override \*(Aqclear\*(Aq => sub {
\&      my $self = shift;
\&      super();
\&      $self\->z(0);
\&  };
.Ve
.PP
The \f(CW\*(C`override\*(C'\fR modifier allows you to use the \f(CW\*(C`super\*(C'\fR keyword to
dispatch to the superclass's method in a very Ruby-ish style.
.PP
The choice of whether to use a method modifier, and which one to use,
is often a question of style as much as functionality.
.PP
Since \fBPoint\fR inherits from Moose::Object, it will also inherit
the default Moose::Object constructor:
.PP
.Vb 2
\&  my $point1 = Point\->new(x => 5, y => 7);
\&  my $point2 = Point\->new({x => 5, y => 7});
\&
\&  my $point3d = Point3D\->new(x => 5, y => 42, z => \-5);
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor accepts a named argument pair for each
attribute defined by the class, which you can provide as a hash or
hash reference. In this particular example, the attributes are
required, and calling \f(CW\*(C`new\*(C'\fR without them will throw an error.
.PP
.Vb 1
\&  my $point = Point\->new( x => 5 ); # no y, kaboom!
.Ve
.PP
From here on, we can use \f(CW$point\fR and \f(CW$point3d\fR just as you would
any other Perl 5 object. For a more detailed example of what can be
done, you can refer to the
\&\fIt/recipes/moose_cookbook_basics_point_attributesandsubclassing.t\fR test file.
.SS "Moose Objects are Just Hashrefs"
.IX Subsection "Moose Objects are Just Hashrefs"
While this all may appear rather magical, it's important to realize
that Moose objects are just hash references under the hood (3). For
example, you could pass \f(CW$self\fR to \f(CW\*(C`Data::Dumper\*(C'\fR and you'd get
exactly what you'd expect.
.PP
You could even poke around inside the object's data structure, but
that is strongly discouraged.
.PP
The fact that Moose objects are hashrefs means it is easy to use Moose
to extend non-Moose classes, as long as they too are hash
references. If you want to extend a non-hashref class, check out
\&\f(CW\*(C`MooseX::InsideOut\*(C'\fR.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This recipe demonstrates some basic Moose concepts, attributes,
subclassing, and a simple method modifier.
.SH "FOOTNOTES"
.IX Header "FOOTNOTES"
.IP "(1)" 4
.IX Item "(1)"
Moose provides a number of builtin type constraints, of which \f(CW\*(C`Int\*(C'\fR
is one. For more information on the type constraint system, see
Moose::Util::TypeConstraints.
.IP "(2)" 4
.IX Item "(2)"
The \f(CW\*(C`extends\*(C'\fR keyword supports multiple inheritance. Simply pass all
of your superclasses to \f(CW\*(C`extends\*(C'\fR as a list:
.Sp
.Vb 1
\&  extends \*(AqFoo\*(Aq, \*(AqBar\*(Aq, \*(AqBaz\*(Aq;
.Ve
.IP "(3)" 4
.IX Item "(3)"
Moose supports using instance structures other than blessed hash
references (such as glob references \- see MooseX::GlobRef).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Method Modifiers" 4
.IX Item "Method Modifiers"
The concept of method modifiers is directly ripped off from \s-1CLOS. A\s0
great explanation of them can be found by following this link.
.Sp
<http://www.gigamonkeys.com/book/object\-reorientation\-generic\-functions.html>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                     Moose::Cookbook::Extending::Debugging_BaseClassRole.3pm                                             0100644 0001750 0001750 00000016643 12566242160 032761  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Debugging_BaseClassRole 3"
.TH Moose::Cookbook::Extending::Debugging_BaseClassRole 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Debugging_BaseClassRole \- Providing a role for the base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MooseX::Debugging;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
\&
\&  package MooseX::Debugging::Role::Object;
\&
\&  use Moose::Role;
\&
\&  sub BUILD {}
\&  after BUILD => sub {
\&      my $self = shift;
\&
\&      warn "Made a new " . ( ref $self ) . " object\en";
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In this example, we provide a role for the base object class that adds
some simple debugging output. Every time an object is created, it
spits out a warning saying what type of object it was.
.PP
Obviously, a real debugging role would do something more interesting,
but this recipe is all about how we apply that role.
.PP
In this case, with the combination of Moose::Exporter and
Moose::Util::MetaRole, we ensure that when a module does \f(CW\*(C`use\ MooseX::Debugging\*(C'\fR, it automatically gets the debugging role applied
to its base object class.
.PP
There are a few pieces of code worth looking at more closely.
.PP
.Vb 3
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
.Ve
.PP
This creates an \f(CW\*(C`import\*(C'\fR method in the \f(CW\*(C`MooseX::Debugging\*(C'\fR package. Since we
are not actually exporting anything, we do not pass \f(CW\*(C`setup_import_methods\*(C'\fR
any parameters related to exports, but we need to have an \f(CW\*(C`import\*(C'\fR method to
ensure that our \f(CW\*(C`init_meta\*(C'\fR method is called. The \f(CW\*(C`init_meta\*(C'\fR is created by
\&\f(CW\*(C`setup_import_methods\*(C'\fR for us, since we passed the \f(CW\*(C`base_class_roles\*(C'\fR
parameter. The generated \f(CW\*(C`init_meta\*(C'\fR will in turn call
Moose::Util::MetaRole::apply_base_class_roles.
.PP
.Vb 4
\&  sub BUILD {}
\&  after BUILD => sub {
\&      ...
\&  };
.Ve
.PP
Due to the way role composition currently works, if the class that a role is
composed into contains a \f(CW\*(C`BUILD\*(C'\fR method, then that will override the \f(CW\*(C`BUILD\*(C'\fR
method in any roles it composes, which is typically not what you want. Using a
method modifier on \f(CW\*(C`BUILD\*(C'\fR avoids this issue, since method modifiers compose
together rather than being overridden. Method modifiers require that a method
exists in order to wrap, however, so we also provide a stub method to wrap if
no \f(CW\*(C`BUILD\*(C'\fR method exists in the class.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                             Moose::Cookbook::Extending::Debugging_BaseClassRole5.16.3pm                                         0100644 0001750 0001750 00000015575 12566242167 033305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Debugging_BaseClassRole 3"
.TH Moose::Cookbook::Extending::Debugging_BaseClassRole 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Debugging_BaseClassRole \- Providing a role for the base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MooseX::Debugging;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
\&
\&  package MooseX::Debugging::Role::Object;
\&
\&  use Moose::Role;
\&
\&  sub BUILD {}
\&  after BUILD => sub {
\&      my $self = shift;
\&
\&      warn "Made a new " . ( ref $self ) . " object\en";
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In this example, we provide a role for the base object class that adds
some simple debugging output. Every time an object is created, it
spits out a warning saying what type of object it was.
.PP
Obviously, a real debugging role would do something more interesting,
but this recipe is all about how we apply that role.
.PP
In this case, with the combination of Moose::Exporter and
Moose::Util::MetaRole, we ensure that when a module does \f(CW\*(C`use\ MooseX::Debugging\*(C'\fR, it automatically gets the debugging role applied
to its base object class.
.PP
There are a few pieces of code worth looking at more closely.
.PP
.Vb 3
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
.Ve
.PP
This creates an \f(CW\*(C`import\*(C'\fR method in the \f(CW\*(C`MooseX::Debugging\*(C'\fR package. Since we
are not actually exporting anything, we do not pass \f(CW\*(C`setup_import_methods\*(C'\fR
any parameters related to exports, but we need to have an \f(CW\*(C`import\*(C'\fR method to
ensure that our \f(CW\*(C`init_meta\*(C'\fR method is called. The \f(CW\*(C`init_meta\*(C'\fR is created by
\&\f(CW\*(C`setup_import_methods\*(C'\fR for us, since we passed the \f(CW\*(C`base_class_roles\*(C'\fR
parameter. The generated \f(CW\*(C`init_meta\*(C'\fR will in turn call
Moose::Util::MetaRole::apply_base_class_roles.
.PP
.Vb 4
\&  sub BUILD {}
\&  after BUILD => sub {
\&      ...
\&  };
.Ve
.PP
Due to the way role composition currently works, if the class that a role is
composed into contains a \f(CW\*(C`BUILD\*(C'\fR method, then that will override the \f(CW\*(C`BUILD\*(C'\fR
method in any roles it composes, which is typically not what you want. Using a
method modifier on \f(CW\*(C`BUILD\*(C'\fR avoids this issue, since method modifiers compose
together rather than being overridden. Method modifiers require that a method
exists in order to wrap, however, so we also provide a stub method to wrap if
no \f(CW\*(C`BUILD\*(C'\fR method exists in the class.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                   Moose::Cookbook::Extending::Debugging_BaseClassRole5.18.3pm                                         0100644 0001750 0001750 00000016643 12566242160 033275  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Debugging_BaseClassRole 3"
.TH Moose::Cookbook::Extending::Debugging_BaseClassRole 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Debugging_BaseClassRole \- Providing a role for the base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MooseX::Debugging;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
\&
\&  package MooseX::Debugging::Role::Object;
\&
\&  use Moose::Role;
\&
\&  sub BUILD {}
\&  after BUILD => sub {
\&      my $self = shift;
\&
\&      warn "Made a new " . ( ref $self ) . " object\en";
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In this example, we provide a role for the base object class that adds
some simple debugging output. Every time an object is created, it
spits out a warning saying what type of object it was.
.PP
Obviously, a real debugging role would do something more interesting,
but this recipe is all about how we apply that role.
.PP
In this case, with the combination of Moose::Exporter and
Moose::Util::MetaRole, we ensure that when a module does \f(CW\*(C`use\ MooseX::Debugging\*(C'\fR, it automatically gets the debugging role applied
to its base object class.
.PP
There are a few pieces of code worth looking at more closely.
.PP
.Vb 3
\&  Moose::Exporter\->setup_import_methods(
\&      base_class_roles => [\*(AqMooseX::Debugging::Role::Object\*(Aq],
\&  );
.Ve
.PP
This creates an \f(CW\*(C`import\*(C'\fR method in the \f(CW\*(C`MooseX::Debugging\*(C'\fR package. Since we
are not actually exporting anything, we do not pass \f(CW\*(C`setup_import_methods\*(C'\fR
any parameters related to exports, but we need to have an \f(CW\*(C`import\*(C'\fR method to
ensure that our \f(CW\*(C`init_meta\*(C'\fR method is called. The \f(CW\*(C`init_meta\*(C'\fR is created by
\&\f(CW\*(C`setup_import_methods\*(C'\fR for us, since we passed the \f(CW\*(C`base_class_roles\*(C'\fR
parameter. The generated \f(CW\*(C`init_meta\*(C'\fR will in turn call
Moose::Util::MetaRole::apply_base_class_roles.
.PP
.Vb 4
\&  sub BUILD {}
\&  after BUILD => sub {
\&      ...
\&  };
.Ve
.PP
Due to the way role composition currently works, if the class that a role is
composed into contains a \f(CW\*(C`BUILD\*(C'\fR method, then that will override the \f(CW\*(C`BUILD\*(C'\fR
method in any roles it composes, which is typically not what you want. Using a
method modifier on \f(CW\*(C`BUILD\*(C'\fR avoids this issue, since method modifiers compose
together rather than being overridden. Method modifiers require that a method
exists in order to wrap, however, so we also provide a stub method to wrap if
no \f(CW\*(C`BUILD\*(C'\fR method exists in the class.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                             Moose::Cookbook::Extending::ExtensionOverview.3pm                                                   0100644 0001750 0001750 00000046134 12566242162 032027  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::ExtensionOverview 3"
.TH Moose::Cookbook::Extending::ExtensionOverview 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::ExtensionOverview \- Moose extension overview
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose provides several ways in which extensions can hook into Moose
and change its behavior. Moose also has a lot of behavior that can be
changed. This recipe will provide an overview of each extension method
and give you some recommendations on what tools to use.
.PP
If you haven't yet read the recipes on metaclasses, go read those
first. You can't write Moose extensions without understanding the
metaclasses, and those recipes also demonstrate some basic extension
mechanisms, such as metaclass subclasses and traits.
.SS "Playing Nice With Others"
.IX Subsection "Playing Nice With Others"
One of the goals of this overview is to help you build extensions that
cooperate well with other extensions. This is especially important if
you plan to release your extension to \s-1CPAN.\s0
.PP
Moose comes with several modules that exist to help your write
cooperative extensions. These are Moose::Exporter and
Moose::Util::MetaRole. By using these two modules, you will ensure
that your extension works with both the Moose core features and any
other \s-1CPAN\s0 extension using those modules.
.SH "PARTS OF Moose YOU CAN EXTEND"
.IX Header "PARTS OF Moose YOU CAN EXTEND"
The types of things you might want to do in Moose extensions fall into
a few broad categories.
.SS "Metaclass Extensions"
.IX Subsection "Metaclass Extensions"
One way of extending Moose is by extending one or more Moose
metaclasses. For example, in Moose::Cookbook::Meta::Table_MetaclassTrait we saw
a metaclass role that added a \f(CW\*(C`table\*(C'\fR attribute to the
metaclass. If you were writing an \s-1ORM,\s0 this would be a logical
extension.
.PP
Many of the Moose extensions on \s-1CPAN\s0 work by providing an attribute
metaclass role. For example, the MooseX::Aliases module
provides an attribute metaclass trait that lets you specify aliases
to install for methods and attribute accessors.
.PP
A metaclass extension can be packaged as a role/trait or a subclass. If you
can, we recommend using traits instead of subclasses, since it's much easier
to combine disparate traits than it is to combine a bunch of subclasses.
.PP
When your extensions are implemented as roles, you can apply them with
the Moose::Util::MetaRole module.
.SS "Providing Sugar Functions"
.IX Subsection "Providing Sugar Functions"
As part of a metaclass extension, you may also want to provide some
sugar functions, just like Moose.pm does. Moose provides a
helper module called Moose::Exporter that makes this much
simpler. We will be use Moose::Exporter in several of the extension
recipes.
.SS "Object Class Extensions"
.IX Subsection "Object Class Extensions"
Another common Moose extension technique is to change the default object
class's behavior. As with metaclass extensions, this can be done with a
role/trait or with a subclass. For example, MooseX::StrictConstructor
extension applies a trait that makes the constructor reject arguments which
don't match its attributes.
.PP
Object class extensions often include metaclass extensions as well. In
particular, if you want your object extension to work when a class is
made immutable, you may need to modify the behavior of some or all of the
Moose::Meta::Instance, Moose::Meta::Method::Constructor, and
Moose::Meta::Method::Destructor objects.
.PP
The Moose::Util::MetaRole module lets you apply roles to the base
object class, as well as the meta classes just mentioned.
.SS "Providing a Role"
.IX Subsection "Providing a Role"
Some extensions come in the form of a role for you to consume. The
MooseX::Object::Pluggable extension is a great example of this. In
fact, despite the \f(CW\*(C`MooseX\*(C'\fR name, it does not actually change anything
about Moose's behavior. Instead, it is just a role that an object
which wants to be pluggable can consume.
.PP
If you are implementing this sort of extension, you don't need to do
anything special. You simply create a role and document that it should
be used via the normal \f(CW\*(C`with\*(C'\fR sugar:
.PP
.Vb 1
\&   package MyApp::User;
\&
\&   use Moose;
\&
\&   with \*(AqMy::Role\*(Aq;
.Ve
.PP
Don't use \*(L"MooseX\*(R" in the name for such packages.
.SS "New Types"
.IX Subsection "New Types"
Another common Moose extension is a new type for the Moose type
system. In this case, you simply create a type in your module. When
people load your module, the type is created, and they can refer to it
by name after that. The MooseX::Types::URI and
MooseX::Types::DateTime distributions are two good examples of how
this works. These both build on top of the MooseX::Types extension.
.SH "ROLES VS TRAITS VS SUBCLASSES"
.IX Header "ROLES VS TRAITS VS SUBCLASSES"
It is important to understand that \fBroles and traits are the same thing\fR. A
trait is simply a role applied to a instance. The only thing that may
distinguish the two is that a trait can be packaged in a way that lets Moose
resolve a short name to a class name. In other words, with a trait, the caller
can refer to it by a short name like \*(L"Big\*(R", and Moose will resolve it to a
class like \f(CW\*(C`MooseX::Embiggen::Meta::Attribute::Role::Big\*(C'\fR.
.PP
See Moose::Cookbook::Meta::Labeled_AttributeTrait and
Moose::Cookbook::Meta::Table_MetaclassTrait for examples of traits in
action. In particular, both of these recipes demonstrate the trait resolution
mechanism.
.PP
Implementing an extension as a (set of) metaclass or base object
role(s) will make your extension more cooperative. It is hard for an
end-user to effectively combine together multiple metaclass
subclasses, but it is very easy to combine roles.
.SH "USING YOUR EXTENSION"
.IX Header "USING YOUR EXTENSION"
There are a number of ways in which an extension can be applied. In
some cases you can provide multiple ways of consuming your extension.
.SS "Extensions as Metaclass Traits"
.IX Subsection "Extensions as Metaclass Traits"
If your extension is available as a trait, you can ask end users to
simply specify it in a list of traits. Currently, this only works for
(class) metaclass and attribute metaclass traits:
.PP
.Vb 1
\&  use Moose \-traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ];
\&
\&  has \*(Aqanimal\*(Aq => (
\&      traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ],
\&      ...
\&  );
.Ve
.PP
If your extension applies to any other metaclass, or the object base
class, you cannot use the trait mechanism.
.PP
The benefit of the trait mechanism is that is very easy to see where a
trait is applied in the code, and consumers have fine-grained control
over what the trait applies to. This is especially true for attribute
traits, where you can apply the trait to just one attribute in a
class.
.SS "Extensions as Metaclass (and Base Object) Roles"
.IX Subsection "Extensions as Metaclass (and Base Object) Roles"
Implementing your extensions as metaclass roles makes your extensions
easy to apply, and cooperative with other role-based extensions for
metaclasses.
.PP
Just as with a subclass, you will probably want to package your
extensions for consumption with a single module that uses
Moose::Exporter. However, in this case, you will use
Moose::Util::MetaRole to apply all of your roles. The advantage of
using this module is that \fIit preserves any subclassing or roles
already applied to the user's metaclasses\fR. This means that your
extension is cooperative \fIby default\fR, and consumers of your
extension can easily use it with other role-based extensions. Most
uses of Moose::Util::MetaRole can be handled by Moose::Exporter
directly; see the Moose::Exporter docs.
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  use MooseX::Embiggen::Role::Meta::Class;
\&  use MooseX::Embiggen::Role::Meta::Attribute;
\&  use MooseX::Embiggen::Role::Meta::Method::Constructor;
\&  use MooseX::Embiggen::Role::Object;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      class_metaroles => {
\&          class     => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&          attribute => [\*(AqMooseX::Embiggen::Role::Meta::Attribute\*(Aq],
\&          constructor =>
\&              [\*(AqMooseX::Embiggen::Role::Meta::Method::Constructor\*(Aq],
\&      },
\&      base_class_roles => [\*(AqMooseX::Embiggen::Role::Object\*(Aq],
\&  );
.Ve
.PP
As you can see from this example, you can use Moose::Util::MetaRole
to apply roles to any metaclass, as well as the base object class. If
some other extension has already applied its own roles, they will be
preserved when your extension applies its roles, and vice versa.
.SS "Providing Sugar"
.IX Subsection "Providing Sugar"
With Moose::Exporter, you can also export your own sugar functions:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
.Ve
.PP
And then the consumer of your extension can use your \f(CW\*(C`embiggen\*(C'\fR sub:
.PP
.Vb 1
\&  package Consumer;
\&
\&  use Moose;
\&  use MooseX::Embiggen;
\&
\&  extends \*(AqThing\*(Aq;
\&
\&  embiggen ...;
.Ve
.PP
This can be combined with metaclass and base class roles quite easily.
.SS "More advanced extensions"
.IX Subsection "More advanced extensions"
Providing your extension simply as a set of traits that gets applied to the
appropriate metaobjects is easy, but sometimes not sufficient. For instance,
sometimes you need to supply not just a base object role, but an actual base
object class (due to needing to interact with existing systems that only
provide a base class). To write extensions like this, you will need to provide
a custom \f(CW\*(C`init_meta\*(C'\fR method in your exporter. For instance:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  my ($import, $unimport, $init_meta) = Moose::Exporter\->build_import_methods(
\&      install         => [\*(Aqimport\*(Aq, \*(Aqunimport\*(Aq],
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
\&
\&  sub init_meta {
\&      my $package = shift;
\&      my %options = @_;
\&      if (my $meta = Class::MOP::class_of($options{for_class})) {
\&          if ($meta\->isa(\*(AqClass::MOP::Class\*(Aq)) {
\&              my @supers = $meta\->superclasses;
\&              $meta\->superclasses(\*(AqMooseX::Embiggen::Base::Class\*(Aq)
\&                  if @supers == 1 && $supers[0] eq \*(AqMoose::Object\*(Aq;
\&          }
\&      }
\&      $package\->$init_meta(%options);
\&  }
.Ve
.PP
In the previous examples, \f(CW\*(C`init_meta\*(C'\fR was generated for you, but here you must
override it in order to add additional functionality. Some differences to note:
.ie n .IP """build_import_methods"" instead of ""setup_import_methods""" 4
.el .IP "\f(CWbuild_import_methods\fR instead of \f(CWsetup_import_methods\fR" 4
.IX Item "build_import_methods instead of setup_import_methods"
\&\f(CW\*(C`build_import_methods\*(C'\fR simply returns the \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`unimport\*(C'\fR, and
\&\f(CW\*(C`init_meta\*(C'\fR methods, rather than installing them under the appropriate names.
This way, you can write your own methods which wrap the functionality provided
by Moose::Exporter.  The \f(CW\*(C`build_import_methods\*(C'\fR sub also takes an
additional \f(CW\*(C`install\*(C'\fR parameter, which tells it to just go ahead and install
these methods (since we don't need to modify them).
.ie n .IP """sub init_meta""" 4
.el .IP "\f(CWsub init_meta\fR" 4
.IX Item "sub init_meta"
Next, we must write our \f(CW\*(C`init_meta\*(C'\fR wrapper. The important things to remember
are that it is called as a method, and that \f(CW%options\fR needs to be passed
through to the existing implementation. We call the base implementation by
using the \f(CW$init_meta\fR subroutine reference that was returned by
\&\f(CW\*(C`build_import_methods\*(C'\fR earlier.
.IP "Additional implementation" 4
.IX Item "Additional implementation"
This extension sets a different default base object class. To do so, it first
checks to see if it's being applied to a class, and then checks to see if
Moose::Object is that class's only superclass, and if so, replaces that with
the superclass that this extension requires.
.Sp
Note that two extensions that do this same thing will not work together
properly (the second extension to be loaded won't see Moose::Object as the
base object, since it has already been overridden). This is why using a base
object role is recommended for the general case.
.Sp
This \f(CW\*(C`init_meta\*(C'\fR also works defensively, by only applying its functionality if
a metaclass already exists. This makes sure it doesn't break with legacy
extensions which override the metaclass directly (and so must be the first
extension to initialize the metaclass). This is likely not necessary, since
almost no extensions work this way anymore, but just provides an additional
level of protection. The common case of \f(CW\*(C`use Moose; use MooseX::Embiggen;\*(C'\fR
is not affected regardless.
.PP
This is just one example of what can be done with a custom \f(CW\*(C`init_meta\*(C'\fR method.
It can also be used for preventing an extension from being applied to a role,
doing other kinds of validation on the class being applied to, or pretty much
anything that would otherwise be done in an \f(CW\*(C`import\*(C'\fR method.
.SH "LEGACY EXTENSION MECHANISMS"
.IX Header "LEGACY EXTENSION MECHANISMS"
Before the existence of Moose::Exporter and
Moose::Util::MetaRole, there were a number of other ways to extend
Moose. In general, these methods were less cooperative, and only
worked well with a single extension.
.PP
These methods include metaclass.pm, Moose::Policy
(which uses metaclass.pm under the hood), and various
hacks to do what Moose::Exporter does. Please do not use these for
your own extensions.
.PP
Note that if you write a cooperative extension, it should cooperate
with older extensions, though older extensions generally do not
cooperate with each other.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
If you can write your extension as one or more metaclass and base
object roles, please consider doing so. Make sure to read the docs for
Moose::Exporter and Moose::Util::MetaRole as well.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                    Moose::Cookbook::Extending::ExtensionOverview5.16.3pm                                               0100644 0001750 0001750 00000045066 12566242166 032350  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::ExtensionOverview 3"
.TH Moose::Cookbook::Extending::ExtensionOverview 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::ExtensionOverview \- Moose extension overview
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose provides several ways in which extensions can hook into Moose
and change its behavior. Moose also has a lot of behavior that can be
changed. This recipe will provide an overview of each extension method
and give you some recommendations on what tools to use.
.PP
If you haven't yet read the recipes on metaclasses, go read those
first. You can't write Moose extensions without understanding the
metaclasses, and those recipes also demonstrate some basic extension
mechanisms, such as metaclass subclasses and traits.
.SS "Playing Nice With Others"
.IX Subsection "Playing Nice With Others"
One of the goals of this overview is to help you build extensions that
cooperate well with other extensions. This is especially important if
you plan to release your extension to \s-1CPAN\s0.
.PP
Moose comes with several modules that exist to help your write
cooperative extensions. These are Moose::Exporter and
Moose::Util::MetaRole. By using these two modules, you will ensure
that your extension works with both the Moose core features and any
other \s-1CPAN\s0 extension using those modules.
.SH "PARTS OF Moose YOU CAN EXTEND"
.IX Header "PARTS OF Moose YOU CAN EXTEND"
The types of things you might want to do in Moose extensions fall into
a few broad categories.
.SS "Metaclass Extensions"
.IX Subsection "Metaclass Extensions"
One way of extending Moose is by extending one or more Moose
metaclasses. For example, in Moose::Cookbook::Meta::Table_MetaclassTrait we saw
a metaclass role that added a \f(CW\*(C`table\*(C'\fR attribute to the
metaclass. If you were writing an \s-1ORM\s0, this would be a logical
extension.
.PP
Many of the Moose extensions on \s-1CPAN\s0 work by providing an attribute
metaclass role. For example, the MooseX::Aliases module
provides an attribute metaclass trait that lets you specify aliases
to install for methods and attribute accessors.
.PP
A metaclass extension can be packaged as a role/trait or a subclass. If you
can, we recommend using traits instead of subclasses, since it's much easier
to combine disparate traits than it is to combine a bunch of subclasses.
.PP
When your extensions are implemented as roles, you can apply them with
the Moose::Util::MetaRole module.
.SS "Providing Sugar Functions"
.IX Subsection "Providing Sugar Functions"
As part of a metaclass extension, you may also want to provide some
sugar functions, just like Moose.pm does. Moose provides a
helper module called Moose::Exporter that makes this much
simpler. We will be use Moose::Exporter in several of the extension
recipes.
.SS "Object Class Extensions"
.IX Subsection "Object Class Extensions"
Another common Moose extension technique is to change the default object
class's behavior. As with metaclass extensions, this can be done with a
role/trait or with a subclass. For example, MooseX::StrictConstructor
extension applies a trait that makes the constructor reject arguments which
don't match its attributes.
.PP
Object class extensions often include metaclass extensions as well. In
particular, if you want your object extension to work when a class is
made immutable, you may need to modify the behavior of some or all of the
Moose::Meta::Instance, Moose::Meta::Method::Constructor, and
Moose::Meta::Method::Destructor objects.
.PP
The Moose::Util::MetaRole module lets you apply roles to the base
object class, as well as the meta classes just mentioned.
.SS "Providing a Role"
.IX Subsection "Providing a Role"
Some extensions come in the form of a role for you to consume. The
MooseX::Object::Pluggable extension is a great example of this. In
fact, despite the \f(CW\*(C`MooseX\*(C'\fR name, it does not actually change anything
about Moose's behavior. Instead, it is just a role that an object
which wants to be pluggable can consume.
.PP
If you are implementing this sort of extension, you don't need to do
anything special. You simply create a role and document that it should
be used via the normal \f(CW\*(C`with\*(C'\fR sugar:
.PP
.Vb 1
\&   package MyApp::User;
\&
\&   use Moose;
\&
\&   with \*(AqMy::Role\*(Aq;
.Ve
.PP
Don't use \*(L"MooseX\*(R" in the name for such packages.
.SS "New Types"
.IX Subsection "New Types"
Another common Moose extension is a new type for the Moose type
system. In this case, you simply create a type in your module. When
people load your module, the type is created, and they can refer to it
by name after that. The MooseX::Types::URI and
MooseX::Types::DateTime distributions are two good examples of how
this works. These both build on top of the MooseX::Types extension.
.SH "ROLES VS TRAITS VS SUBCLASSES"
.IX Header "ROLES VS TRAITS VS SUBCLASSES"
It is important to understand that \fBroles and traits are the same thing\fR. A
trait is simply a role applied to a instance. The only thing that may
distinguish the two is that a trait can be packaged in a way that lets Moose
resolve a short name to a class name. In other words, with a trait, the caller
can refer to it by a short name like \*(L"Big\*(R", and Moose will resolve it to a
class like \f(CW\*(C`MooseX::Embiggen::Meta::Attribute::Role::Big\*(C'\fR.
.PP
See Moose::Cookbook::Meta::Labeled_AttributeTrait and
Moose::Cookbook::Meta::Table_MetaclassTrait for examples of traits in
action. In particular, both of these recipes demonstrate the trait resolution
mechanism.
.PP
Implementing an extension as a (set of) metaclass or base object
role(s) will make your extension more cooperative. It is hard for an
end-user to effectively combine together multiple metaclass
subclasses, but it is very easy to combine roles.
.SH "USING YOUR EXTENSION"
.IX Header "USING YOUR EXTENSION"
There are a number of ways in which an extension can be applied. In
some cases you can provide multiple ways of consuming your extension.
.SS "Extensions as Metaclass Traits"
.IX Subsection "Extensions as Metaclass Traits"
If your extension is available as a trait, you can ask end users to
simply specify it in a list of traits. Currently, this only works for
(class) metaclass and attribute metaclass traits:
.PP
.Vb 1
\&  use Moose \-traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ];
\&
\&  has \*(Aqanimal\*(Aq => (
\&      traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ],
\&      ...
\&  );
.Ve
.PP
If your extension applies to any other metaclass, or the object base
class, you cannot use the trait mechanism.
.PP
The benefit of the trait mechanism is that is very easy to see where a
trait is applied in the code, and consumers have fine-grained control
over what the trait applies to. This is especially true for attribute
traits, where you can apply the trait to just one attribute in a
class.
.SS "Extensions as Metaclass (and Base Object) Roles"
.IX Subsection "Extensions as Metaclass (and Base Object) Roles"
Implementing your extensions as metaclass roles makes your extensions
easy to apply, and cooperative with other role-based extensions for
metaclasses.
.PP
Just as with a subclass, you will probably want to package your
extensions for consumption with a single module that uses
Moose::Exporter. However, in this case, you will use
Moose::Util::MetaRole to apply all of your roles. The advantage of
using this module is that \fIit preserves any subclassing or roles
already applied to the user's metaclasses\fR. This means that your
extension is cooperative \fIby default\fR, and consumers of your
extension can easily use it with other role-based extensions. Most
uses of Moose::Util::MetaRole can be handled by Moose::Exporter
directly; see the Moose::Exporter docs.
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  use MooseX::Embiggen::Role::Meta::Class;
\&  use MooseX::Embiggen::Role::Meta::Attribute;
\&  use MooseX::Embiggen::Role::Meta::Method::Constructor;
\&  use MooseX::Embiggen::Role::Object;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      class_metaroles => {
\&          class     => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&          attribute => [\*(AqMooseX::Embiggen::Role::Meta::Attribute\*(Aq],
\&          constructor =>
\&              [\*(AqMooseX::Embiggen::Role::Meta::Method::Constructor\*(Aq],
\&      },
\&      base_class_roles => [\*(AqMooseX::Embiggen::Role::Object\*(Aq],
\&  );
.Ve
.PP
As you can see from this example, you can use Moose::Util::MetaRole
to apply roles to any metaclass, as well as the base object class. If
some other extension has already applied its own roles, they will be
preserved when your extension applies its roles, and vice versa.
.SS "Providing Sugar"
.IX Subsection "Providing Sugar"
With Moose::Exporter, you can also export your own sugar functions:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
.Ve
.PP
And then the consumer of your extension can use your \f(CW\*(C`embiggen\*(C'\fR sub:
.PP
.Vb 1
\&  package Consumer;
\&
\&  use Moose;
\&  use MooseX::Embiggen;
\&
\&  extends \*(AqThing\*(Aq;
\&
\&  embiggen ...;
.Ve
.PP
This can be combined with metaclass and base class roles quite easily.
.SS "More advanced extensions"
.IX Subsection "More advanced extensions"
Providing your extension simply as a set of traits that gets applied to the
appropriate metaobjects is easy, but sometimes not sufficient. For instance,
sometimes you need to supply not just a base object role, but an actual base
object class (due to needing to interact with existing systems that only
provide a base class). To write extensions like this, you will need to provide
a custom \f(CW\*(C`init_meta\*(C'\fR method in your exporter. For instance:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  my ($import, $unimport, $init_meta) = Moose::Exporter\->build_import_methods(
\&      install         => [\*(Aqimport\*(Aq, \*(Aqunimport\*(Aq],
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
\&
\&  sub init_meta {
\&      my $package = shift;
\&      my %options = @_;
\&      if (my $meta = Class::MOP::class_of($options{for_class})) {
\&          if ($meta\->isa(\*(AqClass::MOP::Class\*(Aq)) {
\&              my @supers = $meta\->superclasses;
\&              $meta\->superclasses(\*(AqMooseX::Embiggen::Base::Class\*(Aq)
\&                  if @supers == 1 && $supers[0] eq \*(AqMoose::Object\*(Aq;
\&          }
\&      }
\&      $package\->$init_meta(%options);
\&  }
.Ve
.PP
In the previous examples, \f(CW\*(C`init_meta\*(C'\fR was generated for you, but here you must
override it in order to add additional functionality. Some differences to note:
.ie n .IP """build_import_methods"" instead of ""setup_import_methods""" 4
.el .IP "\f(CWbuild_import_methods\fR instead of \f(CWsetup_import_methods\fR" 4
.IX Item "build_import_methods instead of setup_import_methods"
\&\f(CW\*(C`build_import_methods\*(C'\fR simply returns the \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`unimport\*(C'\fR, and
\&\f(CW\*(C`init_meta\*(C'\fR methods, rather than installing them under the appropriate names.
This way, you can write your own methods which wrap the functionality provided
by Moose::Exporter.  The \f(CW\*(C`build_import_methods\*(C'\fR sub also takes an
additional \f(CW\*(C`install\*(C'\fR parameter, which tells it to just go ahead and install
these methods (since we don't need to modify them).
.ie n .IP """sub init_meta""" 4
.el .IP "\f(CWsub init_meta\fR" 4
.IX Item "sub init_meta"
Next, we must write our \f(CW\*(C`init_meta\*(C'\fR wrapper. The important things to remember
are that it is called as a method, and that \f(CW%options\fR needs to be passed
through to the existing implementation. We call the base implementation by
using the \f(CW$init_meta\fR subroutine reference that was returned by
\&\f(CW\*(C`build_import_methods\*(C'\fR earlier.
.IP "Additional implementation" 4
.IX Item "Additional implementation"
This extension sets a different default base object class. To do so, it first
checks to see if it's being applied to a class, and then checks to see if
Moose::Object is that class's only superclass, and if so, replaces that with
the superclass that this extension requires.
.Sp
Note that two extensions that do this same thing will not work together
properly (the second extension to be loaded won't see Moose::Object as the
base object, since it has already been overridden). This is why using a base
object role is recommended for the general case.
.Sp
This \f(CW\*(C`init_meta\*(C'\fR also works defensively, by only applying its functionality if
a metaclass already exists. This makes sure it doesn't break with legacy
extensions which override the metaclass directly (and so must be the first
extension to initialize the metaclass). This is likely not necessary, since
almost no extensions work this way anymore, but just provides an additional
level of protection. The common case of \f(CW\*(C`use Moose; use MooseX::Embiggen;\*(C'\fR
is not affected regardless.
.PP
This is just one example of what can be done with a custom \f(CW\*(C`init_meta\*(C'\fR method.
It can also be used for preventing an extension from being applied to a role,
doing other kinds of validation on the class being applied to, or pretty much
anything that would otherwise be done in an \f(CW\*(C`import\*(C'\fR method.
.SH "LEGACY EXTENSION MECHANISMS"
.IX Header "LEGACY EXTENSION MECHANISMS"
Before the existence of Moose::Exporter and
Moose::Util::MetaRole, there were a number of other ways to extend
Moose. In general, these methods were less cooperative, and only
worked well with a single extension.
.PP
These methods include metaclass.pm, Moose::Policy
(which uses metaclass.pm under the hood), and various
hacks to do what Moose::Exporter does. Please do not use these for
your own extensions.
.PP
Note that if you write a cooperative extension, it should cooperate
with older extensions, though older extensions generally do not
cooperate with each other.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
If you can write your extension as one or more metaclass and base
object roles, please consider doing so. Make sure to read the docs for
Moose::Exporter and Moose::Util::MetaRole as well.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Moose::Cookbook::Extending::ExtensionOverview5.18.3pm                                               0100644 0001750 0001750 00000046134 12566242162 032343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::ExtensionOverview 3"
.TH Moose::Cookbook::Extending::ExtensionOverview 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::ExtensionOverview \- Moose extension overview
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose provides several ways in which extensions can hook into Moose
and change its behavior. Moose also has a lot of behavior that can be
changed. This recipe will provide an overview of each extension method
and give you some recommendations on what tools to use.
.PP
If you haven't yet read the recipes on metaclasses, go read those
first. You can't write Moose extensions without understanding the
metaclasses, and those recipes also demonstrate some basic extension
mechanisms, such as metaclass subclasses and traits.
.SS "Playing Nice With Others"
.IX Subsection "Playing Nice With Others"
One of the goals of this overview is to help you build extensions that
cooperate well with other extensions. This is especially important if
you plan to release your extension to \s-1CPAN.\s0
.PP
Moose comes with several modules that exist to help your write
cooperative extensions. These are Moose::Exporter and
Moose::Util::MetaRole. By using these two modules, you will ensure
that your extension works with both the Moose core features and any
other \s-1CPAN\s0 extension using those modules.
.SH "PARTS OF Moose YOU CAN EXTEND"
.IX Header "PARTS OF Moose YOU CAN EXTEND"
The types of things you might want to do in Moose extensions fall into
a few broad categories.
.SS "Metaclass Extensions"
.IX Subsection "Metaclass Extensions"
One way of extending Moose is by extending one or more Moose
metaclasses. For example, in Moose::Cookbook::Meta::Table_MetaclassTrait we saw
a metaclass role that added a \f(CW\*(C`table\*(C'\fR attribute to the
metaclass. If you were writing an \s-1ORM,\s0 this would be a logical
extension.
.PP
Many of the Moose extensions on \s-1CPAN\s0 work by providing an attribute
metaclass role. For example, the MooseX::Aliases module
provides an attribute metaclass trait that lets you specify aliases
to install for methods and attribute accessors.
.PP
A metaclass extension can be packaged as a role/trait or a subclass. If you
can, we recommend using traits instead of subclasses, since it's much easier
to combine disparate traits than it is to combine a bunch of subclasses.
.PP
When your extensions are implemented as roles, you can apply them with
the Moose::Util::MetaRole module.
.SS "Providing Sugar Functions"
.IX Subsection "Providing Sugar Functions"
As part of a metaclass extension, you may also want to provide some
sugar functions, just like Moose.pm does. Moose provides a
helper module called Moose::Exporter that makes this much
simpler. We will be use Moose::Exporter in several of the extension
recipes.
.SS "Object Class Extensions"
.IX Subsection "Object Class Extensions"
Another common Moose extension technique is to change the default object
class's behavior. As with metaclass extensions, this can be done with a
role/trait or with a subclass. For example, MooseX::StrictConstructor
extension applies a trait that makes the constructor reject arguments which
don't match its attributes.
.PP
Object class extensions often include metaclass extensions as well. In
particular, if you want your object extension to work when a class is
made immutable, you may need to modify the behavior of some or all of the
Moose::Meta::Instance, Moose::Meta::Method::Constructor, and
Moose::Meta::Method::Destructor objects.
.PP
The Moose::Util::MetaRole module lets you apply roles to the base
object class, as well as the meta classes just mentioned.
.SS "Providing a Role"
.IX Subsection "Providing a Role"
Some extensions come in the form of a role for you to consume. The
MooseX::Object::Pluggable extension is a great example of this. In
fact, despite the \f(CW\*(C`MooseX\*(C'\fR name, it does not actually change anything
about Moose's behavior. Instead, it is just a role that an object
which wants to be pluggable can consume.
.PP
If you are implementing this sort of extension, you don't need to do
anything special. You simply create a role and document that it should
be used via the normal \f(CW\*(C`with\*(C'\fR sugar:
.PP
.Vb 1
\&   package MyApp::User;
\&
\&   use Moose;
\&
\&   with \*(AqMy::Role\*(Aq;
.Ve
.PP
Don't use \*(L"MooseX\*(R" in the name for such packages.
.SS "New Types"
.IX Subsection "New Types"
Another common Moose extension is a new type for the Moose type
system. In this case, you simply create a type in your module. When
people load your module, the type is created, and they can refer to it
by name after that. The MooseX::Types::URI and
MooseX::Types::DateTime distributions are two good examples of how
this works. These both build on top of the MooseX::Types extension.
.SH "ROLES VS TRAITS VS SUBCLASSES"
.IX Header "ROLES VS TRAITS VS SUBCLASSES"
It is important to understand that \fBroles and traits are the same thing\fR. A
trait is simply a role applied to a instance. The only thing that may
distinguish the two is that a trait can be packaged in a way that lets Moose
resolve a short name to a class name. In other words, with a trait, the caller
can refer to it by a short name like \*(L"Big\*(R", and Moose will resolve it to a
class like \f(CW\*(C`MooseX::Embiggen::Meta::Attribute::Role::Big\*(C'\fR.
.PP
See Moose::Cookbook::Meta::Labeled_AttributeTrait and
Moose::Cookbook::Meta::Table_MetaclassTrait for examples of traits in
action. In particular, both of these recipes demonstrate the trait resolution
mechanism.
.PP
Implementing an extension as a (set of) metaclass or base object
role(s) will make your extension more cooperative. It is hard for an
end-user to effectively combine together multiple metaclass
subclasses, but it is very easy to combine roles.
.SH "USING YOUR EXTENSION"
.IX Header "USING YOUR EXTENSION"
There are a number of ways in which an extension can be applied. In
some cases you can provide multiple ways of consuming your extension.
.SS "Extensions as Metaclass Traits"
.IX Subsection "Extensions as Metaclass Traits"
If your extension is available as a trait, you can ask end users to
simply specify it in a list of traits. Currently, this only works for
(class) metaclass and attribute metaclass traits:
.PP
.Vb 1
\&  use Moose \-traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ];
\&
\&  has \*(Aqanimal\*(Aq => (
\&      traits => [ \*(AqBig\*(Aq, \*(AqBlue\*(Aq ],
\&      ...
\&  );
.Ve
.PP
If your extension applies to any other metaclass, or the object base
class, you cannot use the trait mechanism.
.PP
The benefit of the trait mechanism is that is very easy to see where a
trait is applied in the code, and consumers have fine-grained control
over what the trait applies to. This is especially true for attribute
traits, where you can apply the trait to just one attribute in a
class.
.SS "Extensions as Metaclass (and Base Object) Roles"
.IX Subsection "Extensions as Metaclass (and Base Object) Roles"
Implementing your extensions as metaclass roles makes your extensions
easy to apply, and cooperative with other role-based extensions for
metaclasses.
.PP
Just as with a subclass, you will probably want to package your
extensions for consumption with a single module that uses
Moose::Exporter. However, in this case, you will use
Moose::Util::MetaRole to apply all of your roles. The advantage of
using this module is that \fIit preserves any subclassing or roles
already applied to the user's metaclasses\fR. This means that your
extension is cooperative \fIby default\fR, and consumers of your
extension can easily use it with other role-based extensions. Most
uses of Moose::Util::MetaRole can be handled by Moose::Exporter
directly; see the Moose::Exporter docs.
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  use MooseX::Embiggen::Role::Meta::Class;
\&  use MooseX::Embiggen::Role::Meta::Attribute;
\&  use MooseX::Embiggen::Role::Meta::Method::Constructor;
\&  use MooseX::Embiggen::Role::Object;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      class_metaroles => {
\&          class     => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&          attribute => [\*(AqMooseX::Embiggen::Role::Meta::Attribute\*(Aq],
\&          constructor =>
\&              [\*(AqMooseX::Embiggen::Role::Meta::Method::Constructor\*(Aq],
\&      },
\&      base_class_roles => [\*(AqMooseX::Embiggen::Role::Object\*(Aq],
\&  );
.Ve
.PP
As you can see from this example, you can use Moose::Util::MetaRole
to apply roles to any metaclass, as well as the base object class. If
some other extension has already applied its own roles, they will be
preserved when your extension applies its roles, and vice versa.
.SS "Providing Sugar"
.IX Subsection "Providing Sugar"
With Moose::Exporter, you can also export your own sugar functions:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
.Ve
.PP
And then the consumer of your extension can use your \f(CW\*(C`embiggen\*(C'\fR sub:
.PP
.Vb 1
\&  package Consumer;
\&
\&  use Moose;
\&  use MooseX::Embiggen;
\&
\&  extends \*(AqThing\*(Aq;
\&
\&  embiggen ...;
.Ve
.PP
This can be combined with metaclass and base class roles quite easily.
.SS "More advanced extensions"
.IX Subsection "More advanced extensions"
Providing your extension simply as a set of traits that gets applied to the
appropriate metaobjects is easy, but sometimes not sufficient. For instance,
sometimes you need to supply not just a base object role, but an actual base
object class (due to needing to interact with existing systems that only
provide a base class). To write extensions like this, you will need to provide
a custom \f(CW\*(C`init_meta\*(C'\fR method in your exporter. For instance:
.PP
.Vb 1
\&  package MooseX::Embiggen;
\&
\&  use Moose::Exporter;
\&
\&  my ($import, $unimport, $init_meta) = Moose::Exporter\->build_import_methods(
\&      install         => [\*(Aqimport\*(Aq, \*(Aqunimport\*(Aq],
\&      with_meta       => [\*(Aqembiggen\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMooseX::Embiggen::Role::Meta::Class\*(Aq],
\&      },
\&  );
\&
\&  sub embiggen {
\&      my $meta = shift;
\&      $meta\->embiggen(@_);
\&  }
\&
\&  sub init_meta {
\&      my $package = shift;
\&      my %options = @_;
\&      if (my $meta = Class::MOP::class_of($options{for_class})) {
\&          if ($meta\->isa(\*(AqClass::MOP::Class\*(Aq)) {
\&              my @supers = $meta\->superclasses;
\&              $meta\->superclasses(\*(AqMooseX::Embiggen::Base::Class\*(Aq)
\&                  if @supers == 1 && $supers[0] eq \*(AqMoose::Object\*(Aq;
\&          }
\&      }
\&      $package\->$init_meta(%options);
\&  }
.Ve
.PP
In the previous examples, \f(CW\*(C`init_meta\*(C'\fR was generated for you, but here you must
override it in order to add additional functionality. Some differences to note:
.ie n .IP """build_import_methods"" instead of ""setup_import_methods""" 4
.el .IP "\f(CWbuild_import_methods\fR instead of \f(CWsetup_import_methods\fR" 4
.IX Item "build_import_methods instead of setup_import_methods"
\&\f(CW\*(C`build_import_methods\*(C'\fR simply returns the \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`unimport\*(C'\fR, and
\&\f(CW\*(C`init_meta\*(C'\fR methods, rather than installing them under the appropriate names.
This way, you can write your own methods which wrap the functionality provided
by Moose::Exporter.  The \f(CW\*(C`build_import_methods\*(C'\fR sub also takes an
additional \f(CW\*(C`install\*(C'\fR parameter, which tells it to just go ahead and install
these methods (since we don't need to modify them).
.ie n .IP """sub init_meta""" 4
.el .IP "\f(CWsub init_meta\fR" 4
.IX Item "sub init_meta"
Next, we must write our \f(CW\*(C`init_meta\*(C'\fR wrapper. The important things to remember
are that it is called as a method, and that \f(CW%options\fR needs to be passed
through to the existing implementation. We call the base implementation by
using the \f(CW$init_meta\fR subroutine reference that was returned by
\&\f(CW\*(C`build_import_methods\*(C'\fR earlier.
.IP "Additional implementation" 4
.IX Item "Additional implementation"
This extension sets a different default base object class. To do so, it first
checks to see if it's being applied to a class, and then checks to see if
Moose::Object is that class's only superclass, and if so, replaces that with
the superclass that this extension requires.
.Sp
Note that two extensions that do this same thing will not work together
properly (the second extension to be loaded won't see Moose::Object as the
base object, since it has already been overridden). This is why using a base
object role is recommended for the general case.
.Sp
This \f(CW\*(C`init_meta\*(C'\fR also works defensively, by only applying its functionality if
a metaclass already exists. This makes sure it doesn't break with legacy
extensions which override the metaclass directly (and so must be the first
extension to initialize the metaclass). This is likely not necessary, since
almost no extensions work this way anymore, but just provides an additional
level of protection. The common case of \f(CW\*(C`use Moose; use MooseX::Embiggen;\*(C'\fR
is not affected regardless.
.PP
This is just one example of what can be done with a custom \f(CW\*(C`init_meta\*(C'\fR method.
It can also be used for preventing an extension from being applied to a role,
doing other kinds of validation on the class being applied to, or pretty much
anything that would otherwise be done in an \f(CW\*(C`import\*(C'\fR method.
.SH "LEGACY EXTENSION MECHANISMS"
.IX Header "LEGACY EXTENSION MECHANISMS"
Before the existence of Moose::Exporter and
Moose::Util::MetaRole, there were a number of other ways to extend
Moose. In general, these methods were less cooperative, and only
worked well with a single extension.
.PP
These methods include metaclass.pm, Moose::Policy
(which uses metaclass.pm under the hood), and various
hacks to do what Moose::Exporter does. Please do not use these for
your own extensions.
.PP
Note that if you write a cooperative extension, it should cooperate
with older extensions, though older extensions generally do not
cooperate with each other.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
If you can write your extension as one or more metaclass and base
object roles, please consider doing so. Make sure to read the docs for
Moose::Exporter and Moose::Util::MetaRole as well.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                    Moose::Cookbook::Extending::Mooseish_MooseSugar.3pm                                                 0100644 0001750 0001750 00000015462 12566242161 032255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Mooseish_MooseSugar 3"
.TH Moose::Cookbook::Extending::Mooseish_MooseSugar 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Mooseish_MooseSugar \- Acting like Moose.pm and providing sugar Moose\-style
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Mooseish;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqhas_table\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMyApp::Meta::Class::Trait::HasTable\*(Aq],
\&      },
\&  );
\&
\&  sub has_table {
\&      my $meta = shift;
\&      $meta\->table(shift);
\&  }
\&
\&  package MyApp::Meta::Class::Trait::HasTable;
\&  use Moose::Role;
\&
\&  has table => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe expands on the use of Moose::Exporter we saw in
Moose::Cookbook::Extending::ExtensionOverview and the class metaclass trait
we saw in Moose::Cookbook::Meta::Table_MetaclassTrait. In this example we
provide our own metaclass trait, and we also export a \f(CW\*(C`has_table\*(C'\fR sugar
function.
.PP
The \f(CW\*(C`with_meta\*(C'\fR parameter specifies a list of functions that should
be wrapped before exporting. The wrapper simply ensures that the
importing package's appropriate metaclass object is the first argument
to the function, so we can do \f(CW\*(C`my\ $meta\ =\ shift;\*(C'\fR.
.PP
See the Moose::Exporter docs for more details on its \s-1API.\s0
.SH "USING MyApp::Mooseish"
.IX Header "USING MyApp::Mooseish"
The purpose of all this code is to provide a Moose-like
interface. Here's what it would look like in actual use:
.PP
.Vb 1
\&  package MyApp::User;
\&
\&  use namespace::autoclean;
\&
\&  use Moose;
\&  use MyApp::Mooseish;
\&
\&  has_table \*(AqUser\*(Aq;
\&
\&  has \*(Aqusername\*(Aq => ( is => \*(Aqro\*(Aq );
\&  has \*(Aqpassword\*(Aq => ( is => \*(Aqro\*(Aq );
\&
\&  sub login { ... }
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
Providing sugar functions can make your extension look much more
Moose-ish. See Fey::ORM for a more extensive example.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                              Moose::Cookbook::Extending::Mooseish_MooseSugar5.16.3pm                                             0100644 0001750 0001750 00000014414 12566242167 032571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Mooseish_MooseSugar 3"
.TH Moose::Cookbook::Extending::Mooseish_MooseSugar 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Mooseish_MooseSugar \- Acting like Moose.pm and providing sugar Moose\-style
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Mooseish;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqhas_table\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMyApp::Meta::Class::Trait::HasTable\*(Aq],
\&      },
\&  );
\&
\&  sub has_table {
\&      my $meta = shift;
\&      $meta\->table(shift);
\&  }
\&
\&  package MyApp::Meta::Class::Trait::HasTable;
\&  use Moose::Role;
\&
\&  has table => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe expands on the use of Moose::Exporter we saw in
Moose::Cookbook::Extending::ExtensionOverview and the class metaclass trait
we saw in Moose::Cookbook::Meta::Table_MetaclassTrait. In this example we
provide our own metaclass trait, and we also export a \f(CW\*(C`has_table\*(C'\fR sugar
function.
.PP
The \f(CW\*(C`with_meta\*(C'\fR parameter specifies a list of functions that should
be wrapped before exporting. The wrapper simply ensures that the
importing package's appropriate metaclass object is the first argument
to the function, so we can do \f(CW\*(C`my\ $meta\ =\ shift;\*(C'\fR.
.PP
See the Moose::Exporter docs for more details on its \s-1API\s0.
.SH "USING MyApp::Mooseish"
.IX Header "USING MyApp::Mooseish"
The purpose of all this code is to provide a Moose-like
interface. Here's what it would look like in actual use:
.PP
.Vb 1
\&  package MyApp::User;
\&
\&  use namespace::autoclean;
\&
\&  use Moose;
\&  use MyApp::Mooseish;
\&
\&  has_table \*(AqUser\*(Aq;
\&
\&  has \*(Aqusername\*(Aq => ( is => \*(Aqro\*(Aq );
\&  has \*(Aqpassword\*(Aq => ( is => \*(Aqro\*(Aq );
\&
\&  sub login { ... }
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
Providing sugar functions can make your extension look much more
Moose-ish. See Fey::ORM for a more extensive example.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                    Moose::Cookbook::Extending::Mooseish_MooseSugar5.18.3pm                                             0100644 0001750 0001750 00000015462 12566242161 032571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Extending::Mooseish_MooseSugar 3"
.TH Moose::Cookbook::Extending::Mooseish_MooseSugar 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Extending::Mooseish_MooseSugar \- Acting like Moose.pm and providing sugar Moose\-style
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyApp::Mooseish;
\&
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods(
\&      with_meta       => [\*(Aqhas_table\*(Aq],
\&      class_metaroles => {
\&          class => [\*(AqMyApp::Meta::Class::Trait::HasTable\*(Aq],
\&      },
\&  );
\&
\&  sub has_table {
\&      my $meta = shift;
\&      $meta\->table(shift);
\&  }
\&
\&  package MyApp::Meta::Class::Trait::HasTable;
\&  use Moose::Role;
\&
\&  has table => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This recipe expands on the use of Moose::Exporter we saw in
Moose::Cookbook::Extending::ExtensionOverview and the class metaclass trait
we saw in Moose::Cookbook::Meta::Table_MetaclassTrait. In this example we
provide our own metaclass trait, and we also export a \f(CW\*(C`has_table\*(C'\fR sugar
function.
.PP
The \f(CW\*(C`with_meta\*(C'\fR parameter specifies a list of functions that should
be wrapped before exporting. The wrapper simply ensures that the
importing package's appropriate metaclass object is the first argument
to the function, so we can do \f(CW\*(C`my\ $meta\ =\ shift;\*(C'\fR.
.PP
See the Moose::Exporter docs for more details on its \s-1API.\s0
.SH "USING MyApp::Mooseish"
.IX Header "USING MyApp::Mooseish"
The purpose of all this code is to provide a Moose-like
interface. Here's what it would look like in actual use:
.PP
.Vb 1
\&  package MyApp::User;
\&
\&  use namespace::autoclean;
\&
\&  use Moose;
\&  use MyApp::Mooseish;
\&
\&  has_table \*(AqUser\*(Aq;
\&
\&  has \*(Aqusername\*(Aq => ( is => \*(Aqro\*(Aq );
\&  has \*(Aqpassword\*(Aq => ( is => \*(Aqro\*(Aq );
\&
\&  sub login { ... }
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
Providing sugar functions can make your extension look much more
Moose-ish. See Fey::ORM for a more extensive example.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                              Moose::Cookbook::Legacy::Debugging_BaseClassReplacement.3pm                                         0100644 0001750 0001750 00000020051 12566242160 033562  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3"
.TH Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Legacy::Debugging_BaseClassReplacement \- Providing an alternate base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyApp::Base;
\&  use Moose;
\&
\&  extends \*(AqMoose::Object\*(Aq;
\&
\&  before \*(Aqnew\*(Aq => sub { warn "Making a new " . $_[0] };
\&
\&  no Moose;
\&
\&  package MyApp::UseMyBase;
\&  use Moose ();
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq );
\&
\&  sub init_meta {
\&      shift;
\&      return Moose\->init_meta( @_, base_class => \*(AqMyApp::Base\*(Aq );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1WARNING:\s0 Replacing the base class entirely, as opposed to applying roles to
the base class, is strongly discouraged. This recipe is provided solely for
reference when encountering older code that does this.\fR
.PP
A common extension is to provide an alternate base class. One way to
do that is to make a \f(CW\*(C`MyApp::Base\*(C'\fR and add \f(CW\*(C`extends\ \*(AqMyApp::Base\*(Aq\*(C'\fR to every class in your application. That's pretty
tedious. Instead, you can create a Moose-alike module that sets the
base object class to \f(CW\*(C`MyApp::Base\*(C'\fR for you.
.PP
Then, instead of writing \f(CW\*(C`use\ Moose\*(C'\fR you can write \f(CW\*(C`use\ MyApp::UseMyBase\*(C'\fR.
.PP
In this particular example, our base class issues some debugging
output every time a new object is created, but you can think of some
more interesting things to do with your own base class.
.PP
This uses the magic of Moose::Exporter. When we call \f(CW\*(C`Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq )\*(C'\fR it builds
\&\f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR methods for you. The \f(CW\*(C`also => \*(AqMoose\*(Aq\*(C'\fR
bit says that we want to export everything that Moose does.
.PP
The \f(CW\*(C`import\*(C'\fR method that gets created will call our \f(CW\*(C`init_meta\*(C'\fR
method, passing it \f(CW\*(C`for_caller => $caller\*(C'\fR as its
arguments. The \f(CW$caller\fR is set to the class that actually imported
us in the first place.
.PP
See the Moose::Exporter docs for more details on its \s-1API.\s0
.SH "USING MyApp::UseMyBase"
.IX Header "USING MyApp::UseMyBase"
To actually use our new base class, we simply use \f(CW\*(C`MyApp::UseMyBase\*(C'\fR
\&\fIinstead\fR of \f(CW\*(C`Moose\*(C'\fR. We get all the Moose sugar plus our new base
class.
.PP
.Vb 1
\&  package Foo;
\&
\&  use MyApp::UseMyBase;
\&
\&  has \*(Aqsize\*(Aq => ( is => \*(Aqrw\*(Aq );
\&
\&  no MyApp::UseMyBase;
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This is an awful lot of magic for a simple base class. You will often
want to combine a metaclass trait with a base class extension, and
that's when this technique is useful.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\*(R"\s0 in Moose and \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Moose::Cookbook::Legacy::Debugging_BaseClassReplacement5.16.3pm                                     0100644 0001750 0001750 00000017220 12566242167 034107  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3"
.TH Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Legacy::Debugging_BaseClassReplacement \- Providing an alternate base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyApp::Base;
\&  use Moose;
\&
\&  extends \*(AqMoose::Object\*(Aq;
\&
\&  before \*(Aqnew\*(Aq => sub { warn "Making a new " . $_[0] };
\&
\&  no Moose;
\&
\&  package MyApp::UseMyBase;
\&  use Moose ();
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq );
\&
\&  sub init_meta {
\&      shift;
\&      return Moose\->init_meta( @_, base_class => \*(AqMyApp::Base\*(Aq );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1WARNING:\s0 Replacing the base class entirely, as opposed to applying roles to
the base class, is strongly discouraged. This recipe is provided solely for
reference when encountering older code that does this.\fR
.PP
A common extension is to provide an alternate base class. One way to
do that is to make a \f(CW\*(C`MyApp::Base\*(C'\fR and add \f(CW\*(C`extends\ \*(AqMyApp::Base\*(Aq\*(C'\fR to every class in your application. That's pretty
tedious. Instead, you can create a Moose-alike module that sets the
base object class to \f(CW\*(C`MyApp::Base\*(C'\fR for you.
.PP
Then, instead of writing \f(CW\*(C`use\ Moose\*(C'\fR you can write \f(CW\*(C`use\ MyApp::UseMyBase\*(C'\fR.
.PP
In this particular example, our base class issues some debugging
output every time a new object is created, but you can think of some
more interesting things to do with your own base class.
.PP
This uses the magic of Moose::Exporter. When we call \f(CW\*(C`Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq )\*(C'\fR it builds
\&\f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR methods for you. The \f(CW\*(C`also => \*(AqMoose\*(Aq\*(C'\fR
bit says that we want to export everything that Moose does.
.PP
The \f(CW\*(C`import\*(C'\fR method that gets created will call our \f(CW\*(C`init_meta\*(C'\fR
method, passing it \f(CW\*(C`for_caller => $caller\*(C'\fR as its
arguments. The \f(CW$caller\fR is set to the class that actually imported
us in the first place.
.PP
See the Moose::Exporter docs for more details on its \s-1API\s0.
.SH "NAME"
Moose::Cookbook::Extending::Recipe3 \- Providing an alternate base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.0402
.SH "USING MyApp::UseMyBase"
.IX Header "USING MyApp::UseMyBase"
To actually use our new base class, we simply use \f(CW\*(C`MyApp::UseMyBase\*(C'\fR
\&\fIinstead\fR of \f(CW\*(C`Moose\*(C'\fR. We get all the Moose sugar plus our new base
class.
.PP
.Vb 1
\&  package Foo;
\&
\&  use MyApp::UseMyBase;
\&
\&  has \*(Aqsize\*(Aq => ( is => \*(Aqrw\*(Aq );
\&
\&  no MyApp::UseMyBase;
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This is an awful lot of magic for a simple base class. You will often
want to combine a metaclass trait with a base class extension, and
that's when this technique is useful.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                Moose::Cookbook::Legacy::Debugging_BaseClassReplacement5.18.3pm                                     0100644 0001750 0001750 00000020051 12566242160 034076  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3"
.TH Moose::Cookbook::Legacy::Debugging_BaseClassReplacement 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Legacy::Debugging_BaseClassReplacement \- Providing an alternate base object class
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyApp::Base;
\&  use Moose;
\&
\&  extends \*(AqMoose::Object\*(Aq;
\&
\&  before \*(Aqnew\*(Aq => sub { warn "Making a new " . $_[0] };
\&
\&  no Moose;
\&
\&  package MyApp::UseMyBase;
\&  use Moose ();
\&  use Moose::Exporter;
\&
\&  Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq );
\&
\&  sub init_meta {
\&      shift;
\&      return Moose\->init_meta( @_, base_class => \*(AqMyApp::Base\*(Aq );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1WARNING:\s0 Replacing the base class entirely, as opposed to applying roles to
the base class, is strongly discouraged. This recipe is provided solely for
reference when encountering older code that does this.\fR
.PP
A common extension is to provide an alternate base class. One way to
do that is to make a \f(CW\*(C`MyApp::Base\*(C'\fR and add \f(CW\*(C`extends\ \*(AqMyApp::Base\*(Aq\*(C'\fR to every class in your application. That's pretty
tedious. Instead, you can create a Moose-alike module that sets the
base object class to \f(CW\*(C`MyApp::Base\*(C'\fR for you.
.PP
Then, instead of writing \f(CW\*(C`use\ Moose\*(C'\fR you can write \f(CW\*(C`use\ MyApp::UseMyBase\*(C'\fR.
.PP
In this particular example, our base class issues some debugging
output every time a new object is created, but you can think of some
more interesting things to do with your own base class.
.PP
This uses the magic of Moose::Exporter. When we call \f(CW\*(C`Moose::Exporter\->setup_import_methods( also => \*(AqMoose\*(Aq )\*(C'\fR it builds
\&\f(CW\*(C`import\*(C'\fR and \f(CW\*(C`unimport\*(C'\fR methods for you. The \f(CW\*(C`also => \*(AqMoose\*(Aq\*(C'\fR
bit says that we want to export everything that Moose does.
.PP
The \f(CW\*(C`import\*(C'\fR method that gets created will call our \f(CW\*(C`init_meta\*(C'\fR
method, passing it \f(CW\*(C`for_caller => $caller\*(C'\fR as its
arguments. The \f(CW$caller\fR is set to the class that actually imported
us in the first place.
.PP
See the Moose::Exporter docs for more details on its \s-1API.\s0
.SH "USING MyApp::UseMyBase"
.IX Header "USING MyApp::UseMyBase"
To actually use our new base class, we simply use \f(CW\*(C`MyApp::UseMyBase\*(C'\fR
\&\fIinstead\fR of \f(CW\*(C`Moose\*(C'\fR. We get all the Moose sugar plus our new base
class.
.PP
.Vb 1
\&  package Foo;
\&
\&  use MyApp::UseMyBase;
\&
\&  has \*(Aqsize\*(Aq => ( is => \*(Aqrw\*(Aq );
\&
\&  no MyApp::UseMyBase;
.Ve
.SH "CONCLUSION"
.IX Header "CONCLUSION"
This is an awful lot of magic for a simple base class. You will often
want to combine a metaclass trait with a base class extension, and
that's when this technique is useful.
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\*(R"\s0 in Moose and \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Moose::Cookbook::Legacy::Labeled_AttributeMetaclass.3pm                                             0100644 0001750 0001750 00000034022 12566242161 033003  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3"
.TH Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Meta::Labeled_AttributeMetaclass \- A meta\-attribute, attributes with labels
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
\&
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
\&
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation {\*(AqMyApp::Meta::Attribute::Labeled\*(Aq}
\&
\&  package MyApp::Website;
\&  use Moose;
\&
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
\&
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
\&
\&  package main;
\&
\&  my $app = MyApp::Website\->new( url => "http://google.com", name => "Google" );
.Ve
.SH "SUMMARY"
.IX Header "SUMMARY"
\&\fB\s-1WARNING:\s0 Subclassing metaclasses (as opposed to providing metaclass traits)
is strongly discouraged. This recipe is provided solely for reference when
encountering older code that does this.\fR
.PP
In this recipe, we begin to delve into the wonder of meta-programming.
Some readers may scoff and claim that this is the arena of only the
most twisted Moose developers. Absolutely not! Any sufficiently
twisted developer can benefit greatly from going more meta.
.PP
Our goal is to allow each attribute to have a human-readable \*(L"label\*(R"
attached to it. Such labels would be used when showing data to an end
user. In this recipe we label the \f(CW\*(C`url\*(C'\fR attribute with \*(L"The site's
\&\s-1URL\*(R"\s0 and create a simple method showing how to use that label.
.PP
The proper, modern way to extend attributes (using a role instead of a
subclass) is described in Moose::Cookbook::Meta::Recipe3, but that recipe
assumes you've read and at least tried to understand this one.
.SH "META-ATTRIBUTE OBJECTS"
.IX Header "META-ATTRIBUTE OBJECTS"
All the attributes of a Moose-based object are actually objects
themselves.  These objects have methods and attributes. Let's look at
a concrete example.
.PP
.Vb 2
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Internally, the metaclass for \f(CW\*(C`Point\*(C'\fR has two
Moose::Meta::Attribute. There are several methods for getting
meta-attributes out of a metaclass, one of which is
\&\f(CW\*(C`get_attribute_list\*(C'\fR. This method is called on the metaclass object.
.PP
The \f(CW\*(C`get_attribute_list\*(C'\fR method returns a list of attribute names. You can
then use \f(CW\*(C`get_attribute\*(C'\fR to get the Moose::Meta::Attribute object itself.
.PP
Once you have this meta-attribute object, you can call methods on it like this:
.PP
.Vb 2
\&  print $point\->meta\->get_attribute(\*(Aqx\*(Aq)\->type_constraint;
\&     => Int
.Ve
.PP
To add a label to our attributes there are two steps. First, we need a
new attribute metaclass that can store a label for an
attribute. Second, we need to create attributes that use that
attribute metaclass.
.SH "RECIPE REVIEW"
.IX Header "RECIPE REVIEW"
We start by creating a new attribute metaclass.
.PP
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
.Ve
.PP
We can subclass a Moose metaclass in the same way that we subclass
anything else.
.PP
.Vb 5
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
.Ve
.PP
Again, this is standard Moose code.
.PP
Then we need to register our metaclass with Moose:
.PP
.Vb 2
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation { \*(AqMyApp::Meta::Attribute::Labeled\*(Aq }
.Ve
.PP
This is a bit of magic that lets us use a short name, \*(L"Labeled\*(R", when
referring to our new metaclass.
.PP
That was the whole attribute metaclass.
.PP
Now we start using it.
.PP
.Vb 3
\&  package MyApp::Website;
\&  use Moose;
\&  use MyApp::Meta::Attribute::Labeled;
.Ve
.PP
We have to load the metaclass to use it, just like any Perl class.
.PP
Finally, we use it for an attribute:
.PP
.Vb 6
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
.Ve
.PP
This looks like a normal attribute declaration, except for two things,
the \f(CW\*(C`metaclass\*(C'\fR and \f(CW\*(C`label\*(C'\fR parameters. The \f(CW\*(C`metaclass\*(C'\fR parameter
tells Moose we want to use a custom metaclass for this (one)
attribute. The \f(CW\*(C`label\*(C'\fR parameter will be stored in the meta-attribute
object.
.PP
The reason that we can pass the name \f(CW\*(C`Labeled\*(C'\fR, instead of
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR, is because of the
\&\f(CW\*(C`register_implementation\*(C'\fR code we touched on previously.
.PP
When you pass a metaclass to \f(CW\*(C`has\*(C'\fR, it will take the name you provide
and prefix it with \f(CW\*(C`Moose::Meta::Attribute::Custom::\*(C'\fR. Then it calls
\&\f(CW\*(C`register_implementation\*(C'\fR in the package. In this case, that means
Moose ends up calling
\&\f(CW\*(C`Moose::Meta::Attribute::Custom::Labeled::register_implementation\*(C'\fR.
.PP
If this function exists, it should return the \fIreal\fR metaclass
package name. This is exactly what our code does, returning
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR. This is a little convoluted, and
if you don't like it, you can always use the fully-qualified name.
.PP
We can access this meta-attribute and its label like this:
.PP
.Vb 1
\&  $website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
\&
\&  MyApp::Website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
.Ve
.PP
We also have a regular attribute, \f(CW\*(C`name\*(C'\fR:
.PP
.Vb 4
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.PP
This is a regular Moose attribute, because we have not specified a new
metaclass.
.PP
Finally, we have a \f(CW\*(C`dump\*(C'\fR method, which creates a human-readable
representation of a \f(CW\*(C`MyApp::Website\*(C'\fR object. It will use an
attribute's label if it has one.
.PP
.Vb 2
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
.Ve
.PP
This is a bit of defensive code. We cannot depend on every
meta-attribute having a label. Even if we define one for every
attribute in our class, a subclass may neglect to do so. Or a
superclass could add an attribute without a label.
.PP
We also check that the attribute has a label using the predicate we
defined. We could instead make the label \f(CW\*(C`required\*(C'\fR. If we have a
label, we use it, otherwise we use the attribute name:
.PP
.Vb 3
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
.Ve
.PP
The \f(CW\*(C`get_read_method\*(C'\fR is part of the Moose::Meta::Attribute
\&\s-1API.\s0 It returns the name of a method that can read the attribute's
value, \fIwhen called on the real object\fR (don't call this on the
meta-attribute).
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You might wonder why you'd bother with all this. You could just
hardcode \*(L"The Site's \s-1URL\*(R"\s0 in the \f(CW\*(C`dump\*(C'\fR method. But we want to avoid
repetition. If you need the label once, you may need it elsewhere,
maybe in the \f(CW\*(C`as_form\*(C'\fR method you write next.
.PP
Associating a label with an attribute just makes sense! The label is a
piece of information \fIabout\fR the attribute.
.PP
It's also important to realize that this was a trivial example. You
can make much more powerful metaclasses that \fIdo\fR things, as opposed
to just storing some more information. For example, you could
implement a metaclass that expires attributes after a certain amount
of time:
.PP
.Vb 7
\&   has site_cache => (
\&       metaclass     => \*(AqTimedExpiry\*(Aq,
\&       expires_after => { hours => 1 },
\&       refresh_with  => sub { get( $_[0]\->url ) },
\&       isa           => \*(AqStr\*(Aq,
\&       is            => \*(Aqro\*(Aq,
\&   );
.Ve
.PP
The sky's the limit!
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Moose::Cookbook::Legacy::Labeled_AttributeMetaclass5.16.3pm                                         0100644 0001750 0001750 00000032754 12566242167 033335  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3"
.TH Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3 "2012-09-19" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Meta::Labeled_AttributeMetaclass \- A meta\-attribute, attributes with labels
.SH "VERSION"
.IX Header "VERSION"
version 2.0604
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
\&
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
\&
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation {\*(AqMyApp::Meta::Attribute::Labeled\*(Aq}
\&
\&  package MyApp::Website;
\&  use Moose;
\&
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
\&
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
\&
\&  package main;
\&
\&  my $app = MyApp::Website\->new( url => "http://google.com", name => "Google" );
.Ve
.SH "SUMMARY"
.IX Header "SUMMARY"
\&\fB\s-1WARNING:\s0 Subclassing metaclasses (as opposed to providing metaclass traits)
is strongly discouraged. This recipe is provided solely for reference when
encountering older code that does this.\fR
.PP
In this recipe, we begin to delve into the wonder of meta-programming.
Some readers may scoff and claim that this is the arena of only the
most twisted Moose developers. Absolutely not! Any sufficiently
twisted developer can benefit greatly from going more meta.
.PP
Our goal is to allow each attribute to have a human-readable \*(L"label\*(R"
attached to it. Such labels would be used when showing data to an end
user. In this recipe we label the \f(CW\*(C`url\*(C'\fR attribute with \*(L"The site's
\&\s-1URL\s0\*(R" and create a simple method showing how to use that label.
.PP
The proper, modern way to extend attributes (using a role instead of a
subclass) is described in Moose::Cookbook::Meta::Recipe3, but that recipe
assumes you've read and at least tried to understand this one.
.SH "META-ATTRIBUTE OBJECTS"
.IX Header "META-ATTRIBUTE OBJECTS"
All the attributes of a Moose-based object are actually objects
themselves.  These objects have methods and attributes. Let's look at
a concrete example.
.PP
.Vb 2
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Internally, the metaclass for \f(CW\*(C`Point\*(C'\fR has two
Moose::Meta::Attribute. There are several methods for getting
meta-attributes out of a metaclass, one of which is
\&\f(CW\*(C`get_attribute_list\*(C'\fR. This method is called on the metaclass object.
.PP
The \f(CW\*(C`get_attribute_list\*(C'\fR method returns a list of attribute names. You can
then use \f(CW\*(C`get_attribute\*(C'\fR to get the Moose::Meta::Attribute object itself.
.PP
Once you have this meta-attribute object, you can call methods on it like this:
.PP
.Vb 2
\&  print $point\->meta\->get_attribute(\*(Aqx\*(Aq)\->type_constraint;
\&     => Int
.Ve
.PP
To add a label to our attributes there are two steps. First, we need a
new attribute metaclass that can store a label for an
attribute. Second, we need to create attributes that use that
attribute metaclass.
.SH "RECIPE REVIEW"
.IX Header "RECIPE REVIEW"
We start by creating a new attribute metaclass.
.PP
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
.Ve
.PP
We can subclass a Moose metaclass in the same way that we subclass
anything else.
.PP
.Vb 5
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
.Ve
.PP
Again, this is standard Moose code.
.PP
Then we need to register our metaclass with Moose:
.PP
.Vb 2
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation { \*(AqMyApp::Meta::Attribute::Labeled\*(Aq }
.Ve
.PP
This is a bit of magic that lets us use a short name, \*(L"Labeled\*(R", when
referring to our new metaclass.
.PP
That was the whole attribute metaclass.
.PP
Now we start using it.
.PP
.Vb 3
\&  package MyApp::Website;
\&  use Moose;
\&  use MyApp::Meta::Attribute::Labeled;
.Ve
.PP
We have to load the metaclass to use it, just like any Perl class.
.PP
Finally, we use it for an attribute:
.PP
.Vb 6
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
.Ve
.PP
This looks like a normal attribute declaration, except for two things,
the \f(CW\*(C`metaclass\*(C'\fR and \f(CW\*(C`label\*(C'\fR parameters. The \f(CW\*(C`metaclass\*(C'\fR parameter
tells Moose we want to use a custom metaclass for this (one)
attribute. The \f(CW\*(C`label\*(C'\fR parameter will be stored in the meta-attribute
object.
.PP
The reason that we can pass the name \f(CW\*(C`Labeled\*(C'\fR, instead of
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR, is because of the
\&\f(CW\*(C`register_implementation\*(C'\fR code we touched on previously.
.PP
When you pass a metaclass to \f(CW\*(C`has\*(C'\fR, it will take the name you provide
and prefix it with \f(CW\*(C`Moose::Meta::Attribute::Custom::\*(C'\fR. Then it calls
\&\f(CW\*(C`register_implementation\*(C'\fR in the package. In this case, that means
Moose ends up calling
\&\f(CW\*(C`Moose::Meta::Attribute::Custom::Labeled::register_implementation\*(C'\fR.
.PP
If this function exists, it should return the \fIreal\fR metaclass
package name. This is exactly what our code does, returning
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR. This is a little convoluted, and
if you don't like it, you can always use the fully-qualified name.
.PP
We can access this meta-attribute and its label like this:
.PP
.Vb 1
\&  $website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
\&
\&  MyApp::Website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
.Ve
.PP
We also have a regular attribute, \f(CW\*(C`name\*(C'\fR:
.PP
.Vb 4
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.PP
This is a regular Moose attribute, because we have not specified a new
metaclass.
.PP
Finally, we have a \f(CW\*(C`dump\*(C'\fR method, which creates a human-readable
representation of a \f(CW\*(C`MyApp::Website\*(C'\fR object. It will use an
attribute's label if it has one.
.PP
.Vb 2
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
.Ve
.PP
This is a bit of defensive code. We cannot depend on every
meta-attribute having a label. Even if we define one for every
attribute in our class, a subclass may neglect to do so. Or a
superclass could add an attribute without a label.
.PP
We also check that the attribute has a label using the predicate we
defined. We could instead make the label \f(CW\*(C`required\*(C'\fR. If we have a
label, we use it, otherwise we use the attribute name:
.PP
.Vb 3
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
.Ve
.PP
The \f(CW\*(C`get_read_method\*(C'\fR is part of the Moose::Meta::Attribute
\&\s-1API\s0. It returns the name of a method that can read the attribute's
value, \fIwhen called on the real object\fR (don't call this on the
meta-attribute).
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You might wonder why you'd bother with all this. You could just
hardcode \*(L"The Site's \s-1URL\s0\*(R" in the \f(CW\*(C`dump\*(C'\fR method. But we want to avoid
repetition. If you need the label once, you may need it elsewhere,
maybe in the \f(CW\*(C`as_form\*(C'\fR method you write next.
.PP
Associating a label with an attribute just makes sense! The label is a
piece of information \fIabout\fR the attribute.
.PP
It's also important to realize that this was a trivial example. You
can make much more powerful metaclasses that \fIdo\fR things, as opposed
to just storing some more information. For example, you could
implement a metaclass that expires attributes after a certain amount
of time:
.PP
.Vb 7
\&   has site_cache => (
\&       metaclass     => \*(AqTimedExpiry\*(Aq,
\&       expires_after => { hours => 1 },
\&       refresh_with  => sub { get( $_[0]\->url ) },
\&       isa           => \*(AqStr\*(Aq,
\&       is            => \*(Aqro\*(Aq,
\&   );
.Ve
.PP
The sky's the limit!
.SH "AUTHOR"
.IX Header "AUTHOR"
Moose is maintained by the Moose Cabal, along with the help of many contributors. See \*(L"\s-1CABAL\s0\*(R" in Moose and \*(L"\s-1CONTRIBUTORS\s0\*(R" in Moose for details.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                    Moose::Cookbook::Legacy::Labeled_AttributeMetaclass5.18.3pm                                         0100644 0001750 0001750 00000034022 12566242161 033317  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3"
.TH Moose::Cookbook::Legacy::Labeled_AttributeMetaclass 3 "2014-01-19" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Moose::Cookbook::Meta::Labeled_AttributeMetaclass \- A meta\-attribute, attributes with labels
.SH "VERSION"
.IX Header "VERSION"
version 2.1202
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
\&
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
\&
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation {\*(AqMyApp::Meta::Attribute::Labeled\*(Aq}
\&
\&  package MyApp::Website;
\&  use Moose;
\&
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
\&
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
\&
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
\&
\&  package main;
\&
\&  my $app = MyApp::Website\->new( url => "http://google.com", name => "Google" );
.Ve
.SH "SUMMARY"
.IX Header "SUMMARY"
\&\fB\s-1WARNING:\s0 Subclassing metaclasses (as opposed to providing metaclass traits)
is strongly discouraged. This recipe is provided solely for reference when
encountering older code that does this.\fR
.PP
In this recipe, we begin to delve into the wonder of meta-programming.
Some readers may scoff and claim that this is the arena of only the
most twisted Moose developers. Absolutely not! Any sufficiently
twisted developer can benefit greatly from going more meta.
.PP
Our goal is to allow each attribute to have a human-readable \*(L"label\*(R"
attached to it. Such labels would be used when showing data to an end
user. In this recipe we label the \f(CW\*(C`url\*(C'\fR attribute with \*(L"The site's
\&\s-1URL\*(R"\s0 and create a simple method showing how to use that label.
.PP
The proper, modern way to extend attributes (using a role instead of a
subclass) is described in Moose::Cookbook::Meta::Recipe3, but that recipe
assumes you've read and at least tried to understand this one.
.SH "META-ATTRIBUTE OBJECTS"
.IX Header "META-ATTRIBUTE OBJECTS"
All the attributes of a Moose-based object are actually objects
themselves.  These objects have methods and attributes. Let's look at
a concrete example.
.PP
.Vb 2
\&  has \*(Aqx\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqro\*(Aq );
\&  has \*(Aqy\*(Aq => ( isa => \*(AqInt\*(Aq, is => \*(Aqrw\*(Aq );
.Ve
.PP
Internally, the metaclass for \f(CW\*(C`Point\*(C'\fR has two
Moose::Meta::Attribute. There are several methods for getting
meta-attributes out of a metaclass, one of which is
\&\f(CW\*(C`get_attribute_list\*(C'\fR. This method is called on the metaclass object.
.PP
The \f(CW\*(C`get_attribute_list\*(C'\fR method returns a list of attribute names. You can
then use \f(CW\*(C`get_attribute\*(C'\fR to get the Moose::Meta::Attribute object itself.
.PP
Once you have this meta-attribute object, you can call methods on it like this:
.PP
.Vb 2
\&  print $point\->meta\->get_attribute(\*(Aqx\*(Aq)\->type_constraint;
\&     => Int
.Ve
.PP
To add a label to our attributes there are two steps. First, we need a
new attribute metaclass that can store a label for an
attribute. Second, we need to create attributes that use that
attribute metaclass.
.SH "RECIPE REVIEW"
.IX Header "RECIPE REVIEW"
We start by creating a new attribute metaclass.
.PP
.Vb 3
\&  package MyApp::Meta::Attribute::Labeled;
\&  use Moose;
\&  extends \*(AqMoose::Meta::Attribute\*(Aq;
.Ve
.PP
We can subclass a Moose metaclass in the same way that we subclass
anything else.
.PP
.Vb 5
\&  has label => (
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      predicate => \*(Aqhas_label\*(Aq,
\&  );
.Ve
.PP
Again, this is standard Moose code.
.PP
Then we need to register our metaclass with Moose:
.PP
.Vb 2
\&  package Moose::Meta::Attribute::Custom::Labeled;
\&  sub register_implementation { \*(AqMyApp::Meta::Attribute::Labeled\*(Aq }
.Ve
.PP
This is a bit of magic that lets us use a short name, \*(L"Labeled\*(R", when
referring to our new metaclass.
.PP
That was the whole attribute metaclass.
.PP
Now we start using it.
.PP
.Vb 3
\&  package MyApp::Website;
\&  use Moose;
\&  use MyApp::Meta::Attribute::Labeled;
.Ve
.PP
We have to load the metaclass to use it, just like any Perl class.
.PP
Finally, we use it for an attribute:
.PP
.Vb 6
\&  has url => (
\&      metaclass => \*(AqLabeled\*(Aq,
\&      is        => \*(Aqrw\*(Aq,
\&      isa       => \*(AqStr\*(Aq,
\&      label     => "The site\*(Aqs URL",
\&  );
.Ve
.PP
This looks like a normal attribute declaration, except for two things,
the \f(CW\*(C`metaclass\*(C'\fR and \f(CW\*(C`label\*(C'\fR parameters. The \f(CW\*(C`metaclass\*(C'\fR parameter
tells Moose we want to use a custom metaclass for this (one)
attribute. The \f(CW\*(C`label\*(C'\fR parameter will be stored in the meta-attribute
object.
.PP
The reason that we can pass the name \f(CW\*(C`Labeled\*(C'\fR, instead of
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR, is because of the
\&\f(CW\*(C`register_implementation\*(C'\fR code we touched on previously.
.PP
When you pass a metaclass to \f(CW\*(C`has\*(C'\fR, it will take the name you provide
and prefix it with \f(CW\*(C`Moose::Meta::Attribute::Custom::\*(C'\fR. Then it calls
\&\f(CW\*(C`register_implementation\*(C'\fR in the package. In this case, that means
Moose ends up calling
\&\f(CW\*(C`Moose::Meta::Attribute::Custom::Labeled::register_implementation\*(C'\fR.
.PP
If this function exists, it should return the \fIreal\fR metaclass
package name. This is exactly what our code does, returning
\&\f(CW\*(C`MyApp::Meta::Attribute::Labeled\*(C'\fR. This is a little convoluted, and
if you don't like it, you can always use the fully-qualified name.
.PP
We can access this meta-attribute and its label like this:
.PP
.Vb 1
\&  $website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
\&
\&  MyApp::Website\->meta\->get_attribute(\*(Aqurl\*(Aq)\->label()
.Ve
.PP
We also have a regular attribute, \f(CW\*(C`name\*(C'\fR:
.PP
.Vb 4
\&  has name => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.PP
This is a regular Moose attribute, because we have not specified a new
metaclass.
.PP
Finally, we have a \f(CW\*(C`dump\*(C'\fR method, which creates a human-readable
representation of a \f(CW\*(C`MyApp::Website\*(C'\fR object. It will use an
attribute's label if it has one.
.PP
.Vb 2
\&  sub dump {
\&      my $self = shift;
\&
\&      my $meta = $self\->meta;
\&
\&      my $dump = \*(Aq\*(Aq;
\&
\&      for my $attribute ( map { $meta\->get_attribute($_) }
\&          sort $meta\->get_attribute_list ) {
\&
\&          if (   $attribute\->isa(\*(AqMyApp::Meta::Attribute::Labeled\*(Aq)
\&              && $attribute\->has_label ) {
\&              $dump .= $attribute\->label;
\&          }
.Ve
.PP
This is a bit of defensive code. We cannot depend on every
meta-attribute having a label. Even if we define one for every
attribute in our class, a subclass may neglect to do so. Or a
superclass could add an attribute without a label.
.PP
We also check that the attribute has a label using the predicate we
defined. We could instead make the label \f(CW\*(C`required\*(C'\fR. If we have a
label, we use it, otherwise we use the attribute name:
.PP
.Vb 3
\&          else {
\&              $dump .= $attribute\->name;
\&          }
\&
\&          my $reader = $attribute\->get_read_method;
\&          $dump .= ": " . $self\->$reader . "\en";
\&      }
\&
\&      return $dump;
\&  }
.Ve
.PP
The \f(CW\*(C`get_read_method\*(C'\fR is part of the Moose::Meta::Attribute
\&\s-1API.\s0 It returns the name of a method that can read the attribute's
value, \fIwhen called on the real object\fR (don't call this on the
meta-attribute).
.SH "CONCLUSION"
.IX Header "CONCLUSION"
You might wonder why you'd bother with all this. You could just
hardcode \*(L"The Site's \s-1URL\*(R"\s0 in the \f(CW\*(C`dump\*(C'\fR method. But we want to avoid
repetition. If you need the label once, you may need it elsewhere,
maybe in the \f(CW\*(C`as_form\*(C'\fR method you write next.
.PP
Associating a label with an attribute just makes sense! The label is a
piece of information \fIabout\fR the attribute.
.PP
It's also important to realize that this was a trivial example. You
can make much more powerful metaclasses that \fIdo\fR things, as opposed
to just storing some more information. For example, you could
implement a metaclass that expires attributes after a certain amount
of time:
.PP
.Vb 7
\&   has site_cache => (
\&       metaclass     => \*(AqTimedExpiry\*(Aq,
\&       expires_after => { hours => 1 },
\&       refresh_with  => sub { get( $_[0]\->url ) },
\&       isa           => \*(AqStr\*(Aq,
\&       is            => \*(Aqro\*(Aq,
\&   );
.Ve
.PP
The sky's the limit!
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan.little@iinteractive.com>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Shawn M Moore <code@sartak.org>
.IP "\(bu" 4
\&\s-1XXXX XXX\s0'\s-1XX \s0(Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Hans Dieter Pearcey <hdp@weftsoar.net>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Matt S Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Moose::Cookbook::Legacy::Table_ClassMetaclass.3pm                                                   0100644 0001750 0001750 00000016325 12566242160 031611  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(