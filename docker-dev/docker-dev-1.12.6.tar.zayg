ne.\n\nA call always returns some value, possibly "None", unless it raises an\nexception.  How this value is computed depends on the type of the\ncallable object.\n\nIf it is---\n\na user-defined function:\n   The code block for the function is executed, passing it the\n   argument list.  The first thing the code block will do is bind the\n   formal parameters to the arguments; this is described in section\n   *Function definitions*.  When the code block executes a "return"\n   statement, this specifies the return value of the function call.\n\na built-in function or method:\n   The result is up to the interpreter; see *Built-in Functions* for\n   the descriptions of built-in functions and methods.\n\na class object:\n   A new instance of that class is returned.\n\na class instance method:\n   The corresponding user-defined function is called, with an argument\n   list that is one longer than the argument list of the call: the\n   instance becomes the first argument.\n\na class instance:\n   The class must define a "__call__()" method; the effect is then the\n   same as if that method was called.\n',
 'class': u'\nClass definitions\n*****************\n\nA class definition defines a class object (see section *The standard\ntype hierarchy*):\n\n   classdef    ::= "class" classname [inheritance] ":" suite\n   inheritance ::= "(" [expression_list] ")"\n   classname   ::= identifier\n\nA class definition is an executable statement.  It first evaluates the\ninheritance list, if present.  Each item in the inheritance list\nshould evaluate to a class object or class type which allows\nsubclassing.  The class\'s suite is then executed in a new execution\nframe (see section *Naming and binding*), using a newly created local\nnamespace and the original global namespace. (Usually, the suite\ncontains only function definitions.)  When the class\'s suite finishes\nexecution, its execution frame is discarded but its local namespace is\nsaved. [4] A class object is then created using the inheritance list\nfor the base classes and the saved local namespace for the attribute\ndictionary.  The class name is bound to this class object in the\noriginal local namespace.\n\n**Programmer\'s note:** Variables defined in the class definition are\nclass variables; they are shared by all instances.  To create instance\nvariables, they can be set in a method with "self.name = value".  Both\nclass and instance variables are accessible through the notation\n""self.name"", and an instance variable hides a class variable with\nthe same name when accessed in this way. Class variables can be used\nas defaults for instance variables, but using mutable values there can\nlead to unexpected results.  For *new-style class*es, descriptors can\nbe used to create instance variables with different implementation\ndetails.\n\nClass definitions, like function definitions, may be wrapped by one or\nmore *decorator* expressions.  The evaluation rules for the decorator\nexpressions are the same as for functions.  The result must be a class\nobject, which is then bound to the class name.\n\n-[ Footnotes ]-\n\n[1] The exception is propagated to the invocation stack unless\n    there is a "finally" clause which happens to raise another\n    exception. That new exception causes the old one to be lost.\n\n[2] Currently, control "flows off the end" except in the case of\n    an exception or the execution of a "return", "continue", or\n    "break" statement.\n\n[3] A string literal appearing as the first statement in the\n    function body is transformed into the function\'s "__doc__"\n    attribute and therefore the function\'s *docstring*.\n\n[4] A string literal appearing as the first statement in the class\n    body is transformed into the namespace\'s "__doc__" item and\n    therefore the class\'s *docstring*.\n',
 'comparisons': u'\nComparisons\n***********\n\nUnlike C, all comparison operations in Python have the same priority,\nwhich is lower than that of any arithmetic, shifting or bitwise\noperation.  Also unlike C, expressions like "a < b < c" have the\ninterpretation that is conventional in mathematics:\n\n   comparison    ::= or_expr ( comp_operator or_expr )*\n   comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="\n                     | "is" ["not"] | ["not"] "in"\n\nComparisons yield boolean values: "True" or "False".\n\nComparisons can be chained arbitrarily, e.g., "x < y <= z" is\nequivalent to "x < y and y <= z", except that "y" is evaluated only\nonce (but in both cases "z" is not evaluated at all when "x < y" is\nfound to be false).\n\nFormally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*,\n*op2*, ..., *opN* are comparison operators, then "a op1 b op2 c ... y\nopN z" is equivalent to "a op1 b and b op2 c and ... y opN z", except\nthat each expression is evaluated at most once.\n\nNote that "a op1 b op2 c" doesn\'t imply any kind of comparison between\n*a* and *c*, so that, e.g., "x < y > z" is perfectly legal (though\nperhaps not pretty).\n\nThe forms "<>" and "!=" are equivalent; for consistency with C, "!="\nis preferred; where "!=" is mentioned below "<>" is also accepted.\nThe "<>" spelling is considered obsolescent.\n\nThe operators "<", ">", "==", ">=", "<=", and "!=" compare the values\nof two objects.  The objects need not have the same type. If both are\nnumbers, they are converted to a common type.  Otherwise, objects of\ndifferent types *always* compare unequal, and are ordered consistently\nbut arbitrarily. You can control comparison behavior of objects of\nnon-built-in types by defining a "__cmp__" method or rich comparison\nmethods like "__gt__", described in section *Special method names*.\n\n(This unusual definition of comparison was used to simplify the\ndefinition of operations like sorting and the "in" and "not in"\noperators. In the future, the comparison rules for objects of\ndifferent types are likely to change.)\n\nComparison of objects of the same type depends on the type:\n\n* Numbers are compared arithmetically.\n\n* Strings are compared lexicographically using the numeric\n  equivalents (the result of the built-in function "ord()") of their\n  characters. Unicode and 8-bit strings are fully interoperable in\n  this behavior. [4]\n\n* Tuples and lists are compared lexicographically using comparison\n  of corresponding elements.  This means that to compare equal, each\n  element must compare equal and the two sequences must be of the same\n  type and have the same length.\n\n  If not equal, the sequences are ordered the same as their first\n  differing elements.  For example, "cmp([1,2,x], [1,2,y])" returns\n  the same as "cmp(x,y)".  If the corresponding element does not\n  exist, the shorter sequence is ordered first (for example, "[1,2] <\n  [1,2,3]").\n\n* Mappings (dictionaries) compare equal if and only if their sorted\n  (key, value) lists compare equal. [5] Outcomes other than equality\n  are resolved consistently, but are not otherwise defined. [6]\n\n* Most other objects of built-in types compare unequal unless they\n  are the same object; the choice whether one object is considered\n  smaller or larger than another one is made arbitrarily but\n  consistently within one execution of a program.\n\nThe operators "in" and "not in" test for collection membership.  "x in\ns" evaluates to true if *x* is a member of the collection *s*, and\nfalse otherwise.  "x not in s" returns the negation of "x in s". The\ncollection membership test has traditionally been bound to sequences;\nan object is a member of a collection if the collection is a sequence\nand contains an element equal to that object.  However, it make sense\nfor many other object types to support membership tests without being\na sequence.  In particular, dictionaries (for keys) and sets support\nmembership testing.\n\nFor the list and tuple types, "x in y" is true if and only if there\nexists an index *i* such that "x == y[i]" is true.\n\nFor the Unicode and string types, "x in y" is true if and only if *x*\nis a substring of *y*.  An equivalent test is "y.find(x) != -1".\nNote, *x* and *y* need not be the same type; consequently, "u\'ab\' in\n\'abc\'" will return "True". Empty strings are always considered to be a\nsubstring of any other string, so """ in "abc"" will return "True".\n\nChanged in version 2.3: Previously, *x* was required to be a string of\nlength "1".\n\nFor user-defined classes which define the "__contains__()" method, "x\nin y" is true if and only if "y.__contains__(x)" is true.\n\nFor user-defined classes which do not define "__contains__()" but do\ndefine "__iter__()", "x in y" is true if some value "z" with "x == z"\nis produced while iterating over "y".  If an exception is raised\nduring the iteration, it is as if "in" raised that exception.\n\nLastly, the old-style iteration protocol is tried: if a class defines\n"__getitem__()", "x in y" is true if and only if there is a non-\nnegative integer index *i* such that "x == y[i]", and all lower\ninteger indices do not raise "IndexError" exception. (If any other\nexception is raised, it is as if "in" raised that exception).\n\nThe operator "not in" is defined to have the inverse true value of\n"in".\n\nThe operators "is" and "is not" test for object identity: "x is y" is\ntrue if and only if *x* and *y* are the same object.  "x is not y"\nyields the inverse truth value. [7]\n',
 'compound': u'\nCompound statements\n*******************\n\nCompound statements contain (groups of) other statements; they affect\nor control the execution of those other statements in some way.  In\ngeneral, compound statements span multiple lines, although in simple\nincarnations a whole compound statement may be contained in one line.\n\nThe "if", "while" and "for" statements implement traditional control\nflow constructs.  "try" specifies exception handlers and/or cleanup\ncode for a group of statements.  Function and class definitions are\nalso syntactically compound statements.\n\nCompound statements consist of one or more \'clauses.\'  A clause\nconsists of a header and a \'suite.\'  The clause headers of a\nparticular compound statement are all at the same indentation level.\nEach clause header begins with a uniquely identifying keyword and ends\nwith a colon.  A suite is a group of statements controlled by a\nclause.  A suite can be one or more semicolon-separated simple\nstatements on the same line as the header, following the header\'s\ncolon, or it can be one or more indented statements on subsequent\nlines.  Only the latter form of suite can contain nested compound\nstatements; the following is illegal, mostly because it wouldn\'t be\nclear to which "if" clause a following "else" clause would belong:\n\n   if test1: if test2: print x\n\nAlso note that the semicolon binds tighter than the colon in this\ncontext, so that in the following example, either all or none of the\n"print" statements are executed:\n\n   if x < y < z: print x; print y; print z\n\nSummarizing:\n\n   compound_stmt ::= if_stmt\n                     | while_stmt\n                     | for_stmt\n                     | try_stmt\n                     | with_stmt\n                     | funcdef\n                     | classdef\n                     | decorated\n   suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT\n   statement     ::= stmt_list NEWLINE | compound_stmt\n   stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]\n\nNote that statements always end in a "NEWLINE" possibly followed by a\n"DEDENT". Also note that optional continuation clauses always begin\nwith a keyword that cannot start a statement, thus there are no\nambiguities (the \'dangling "else"\' problem is solved in Python by\nrequiring nested "if" statements to be indented).\n\nThe formatting of the grammar rules in the following sections places\neach clause on a separate line for clarity.\n\n\nThe "if" statement\n==================\n\nThe "if" statement is used for conditional execution:\n\n   if_stmt ::= "if" expression ":" suite\n               ( "elif" expression ":" suite )*\n               ["else" ":" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section *Boolean operations*\nfor the definition of true and false); then that suite is executed\n(and no other part of the "if" statement is executed or evaluated).\nIf all expressions are false, the suite of the "else" clause, if\npresent, is executed.\n\n\nThe "while" statement\n=====================\n\nThe "while" statement is used for repeated execution as long as an\nexpression is true:\n\n   while_stmt ::= "while" expression ":" suite\n                  ["else" ":" suite]\n\nThis repeatedly tests the expression and, if it is true, executes the\nfirst suite; if the expression is false (which may be the first time\nit is tested) the suite of the "else" clause, if present, is executed\nand the loop terminates.\n\nA "break" statement executed in the first suite terminates the loop\nwithout executing the "else" clause\'s suite.  A "continue" statement\nexecuted in the first suite skips the rest of the suite and goes back\nto testing the expression.\n\n\nThe "for" statement\n===================\n\nThe "for" statement is used to iterate over the elements of a sequence\n(such as a string, tuple or list) or other iterable object:\n\n   for_stmt ::= "for" target_list "in" expression_list ":" suite\n                ["else" ":" suite]\n\nThe expression list is evaluated once; it should yield an iterable\nobject.  An iterator is created for the result of the\n"expression_list".  The suite is then executed once for each item\nprovided by the iterator, in the order of ascending indices.  Each\nitem in turn is assigned to the target list using the standard rules\nfor assignments, and then the suite is executed.  When the items are\nexhausted (which is immediately when the sequence is empty), the suite\nin the "else" clause, if present, is executed, and the loop\nterminates.\n\nA "break" statement executed in the first suite terminates the loop\nwithout executing the "else" clause\'s suite.  A "continue" statement\nexecuted in the first suite skips the rest of the suite and continues\nwith the next item, or with the "else" clause if there was no next\nitem.\n\nThe suite may assign to the variable(s) in the target list; this does\nnot affect the next item assigned to it.\n\nThe target list is not deleted when the loop is finished, but if the\nsequence is empty, it will not have been assigned to at all by the\nloop.  Hint: the built-in function "range()" returns a sequence of\nintegers suitable to emulate the effect of Pascal\'s "for i := a to b\ndo"; e.g., "range(3)" returns the list "[0, 1, 2]".\n\nNote: There is a subtlety when the sequence is being modified by the\n  loop (this can only occur for mutable sequences, i.e. lists). An\n  internal counter is used to keep track of which item is used next,\n  and this is incremented on each iteration.  When this counter has\n  reached the length of the sequence the loop terminates.  This means\n  that if the suite deletes the current (or a previous) item from the\n  sequence, the next item will be skipped (since it gets the index of\n  the current item which has already been treated).  Likewise, if the\n  suite inserts an item in the sequence before the current item, the\n  current item will be treated again the next time through the loop.\n  This can lead to nasty bugs that can be avoided by making a\n  temporary copy using a slice of the whole sequence, e.g.,\n\n     for x in a[:]:\n         if x < 0: a.remove(x)\n\n\nThe "try" statement\n===================\n\nThe "try" statement specifies exception handlers and/or cleanup code\nfor a group of statements:\n\n   try_stmt  ::= try1_stmt | try2_stmt\n   try1_stmt ::= "try" ":" suite\n                 ("except" [expression [("as" | ",") identifier]] ":" suite)+\n                 ["else" ":" suite]\n                 ["finally" ":" suite]\n   try2_stmt ::= "try" ":" suite\n                 "finally" ":" suite\n\nChanged in version 2.5: In previous versions of Python,\n"try"..."except"..."finally" did not work. "try"..."except" had to be\nnested in "try"..."finally".\n\nThe "except" clause(s) specify one or more exception handlers. When no\nexception occurs in the "try" clause, no exception handler is\nexecuted. When an exception occurs in the "try" suite, a search for an\nexception handler is started.  This search inspects the except clauses\nin turn until one is found that matches the exception.  An expression-\nless except clause, if present, must be last; it matches any\nexception.  For an except clause with an expression, that expression\nis evaluated, and the clause matches the exception if the resulting\nobject is "compatible" with the exception.  An object is compatible\nwith an exception if it is the class or a base class of the exception\nobject, or a tuple containing an item compatible with the exception.\n\nIf no except clause matches the exception, the search for an exception\nhandler continues in the surrounding code and on the invocation stack.\n[1]\n\nIf the evaluation of an expression in the header of an except clause\nraises an exception, the original search for a handler is canceled and\na search starts for the new exception in the surrounding code and on\nthe call stack (it is treated as if the entire "try" statement raised\nthe exception).\n\nWhen a matching except clause is found, the exception is assigned to\nthe target specified in that except clause, if present, and the except\nclause\'s suite is executed.  All except clauses must have an\nexecutable block.  When the end of this block is reached, execution\ncontinues normally after the entire try statement.  (This means that\nif two nested handlers exist for the same exception, and the exception\noccurs in the try clause of the inner handler, the outer handler will\nnot handle the exception.)\n\nBefore an except clause\'s suite is executed, details about the\nexception are assigned to three variables in the "sys" module:\n"sys.exc_type" receives the object identifying the exception;\n"sys.exc_value" receives the exception\'s parameter;\n"sys.exc_traceback" receives a traceback object (see section *The\nstandard type hierarchy*) identifying the point in the program where\nthe exception occurred. These details are also available through the\n"sys.exc_info()" function, which returns a tuple "(exc_type,\nexc_value, exc_traceback)".  Use of the corresponding variables is\ndeprecated in favor of this function, since their use is unsafe in a\nthreaded program.  As of Python 1.5, the variables are restored to\ntheir previous values (before the call) when returning from a function\nthat handled an exception.\n\nThe optional "else" clause is executed if and when control flows off\nthe end of the "try" clause. [2] Exceptions in the "else" clause are\nnot handled by the preceding "except" clauses.\n\nIf "finally" is present, it specifies a \'cleanup\' handler.  The "try"\nclause is executed, including any "except" and "else" clauses.  If an\nexception occurs in any of the clauses and is not handled, the\nexception is temporarily saved. The "finally" clause is executed.  If\nthere is a saved exception, it is re-raised at the end of the\n"finally" clause. If the "finally" clause raises another exception or\nexecutes a "return" or "break" statement, the saved exception is\ndiscarded:\n\n   >>> def f():\n   ...     try:\n   ...         1/0\n   ...     finally:\n   ...         return 42\n   ...\n   >>> f()\n   42\n\nThe exception information is not available to the program during\nexecution of the "finally" clause.\n\nWhen a "return", "break" or "continue" statement is executed in the\n"try" suite of a "try"..."finally" statement, the "finally" clause is\nalso executed \'on the way out.\' A "continue" statement is illegal in\nthe "finally" clause. (The reason is a problem with the current\nimplementation --- this restriction may be lifted in the future).\n\nThe return value of a function is determined by the last "return"\nstatement executed.  Since the "finally" clause always executes, a\n"return" statement executed in the "finally" clause will always be the\nlast one executed:\n\n   >>> def foo():\n   ...     try:\n   ...         return \'try\'\n   ...     finally:\n   ...         return \'finally\'\n   ...\n   >>> foo()\n   \'finally\'\n\nAdditional information on exceptions can be found in section\n*Exceptions*, and information on using the "raise" statement to\ngenerate exceptions may be found in section *The raise statement*.\n\n\nThe "with" statement\n====================\n\nNew in version 2.5.\n\nThe "with" statement is used to wrap the execution of a block with\nmethods defined by a context manager (see section *With Statement\nContext Managers*). This allows common "try"..."except"..."finally"\nusage patterns to be encapsulated for convenient reuse.\n\n   with_stmt ::= "with" with_item ("," with_item)* ":" suite\n   with_item ::= expression ["as" target]\n\nThe execution of the "with" statement with one "item" proceeds as\nfollows:\n\n1. The context expression (the expression given in the "with_item")\n   is evaluated to obtain a context manager.\n\n2. The context manager\'s "__exit__()" is loaded for later use.\n\n3. The context manager\'s "__enter__()" method is invoked.\n\n4. If a target was included in the "with" statement, the return\n   value from "__enter__()" is assigned to it.\n\n   Note: The "with" statement guarantees that if the "__enter__()"\n     method returns without an error, then "__exit__()" will always be\n     called. Thus, if an error occurs during the assignment to the\n     target list, it will be treated the same as an error occurring\n     within the suite would be. See step 6 below.\n\n5. The suite is executed.\n\n6. The context manager\'s "__exit__()" method is invoked. If an\n   exception caused the suite to be exited, its type, value, and\n   traceback are passed as arguments to "__exit__()". Otherwise, three\n   "None" arguments are supplied.\n\n   If the suite was exited due to an exception, and the return value\n   from the "__exit__()" method was false, the exception is reraised.\n   If the return value was true, the exception is suppressed, and\n   execution continues with the statement following the "with"\n   statement.\n\n   If the suite was exited for any reason other than an exception, the\n   return value from "__exit__()" is ignored, and execution proceeds\n   at the normal location for the kind of exit that was taken.\n\nWith more than one item, the context managers are processed as if\nmultiple "with" statements were nested:\n\n   with A() as a, B() as b:\n       suite\n\nis equivalent to\n\n   with A() as a:\n       with B() as b:\n           suite\n\nNote: In Python 2.5, the "with" statement is only allowed when the\n  "with_statement" feature has been enabled.  It is always enabled in\n  Python 2.6.\n\nChanged in version 2.7: Support for multiple context expressions.\n\nSee also: **PEP 0343** - The "with" statement\n\n     The specification, background, and examples for the Python "with"\n     statement.\n\n\nFunction definitions\n====================\n\nA function definition defines a user-defined function object (see\nsection *The standard type hierarchy*):\n\n   decorated      ::= decorators (classdef | funcdef)\n   decorators     ::= decorator+\n   decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE\n   funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite\n   dotted_name    ::= identifier ("." identifier)*\n   parameter_list ::= (defparameter ",")*\n                      (  "*" identifier ["," "**" identifier]\n                      | "**" identifier\n                      | defparameter [","] )\n   defparameter   ::= parameter ["=" expression]\n   sublist        ::= parameter ("," parameter)* [","]\n   parameter      ::= identifier | "(" sublist ")"\n   funcname       ::= identifier\n\nA function definition is an executable statement.  Its execution binds\nthe function name in the current local namespace to a function object\n(a wrapper around the executable code for the function).  This\nfunction object contains a reference to the current global namespace\nas the global namespace to be used when the function is called.\n\nThe function definition does not execute the function body; this gets\nexecuted only when the function is called. [3]\n\nA function definition may be wrapped by one or more *decorator*\nexpressions. Decorator expressions are evaluated when the function is\ndefined, in the scope that contains the function definition.  The\nresult must be a callable, which is invoked with the function object\nas the only argument. The returned value is bound to the function name\ninstead of the function object.  Multiple decorators are applied in\nnested fashion. For example, the following code:\n\n   @f1(arg)\n   @f2\n   def func(): pass\n\nis equivalent to:\n\n   def func(): pass\n   func = f1(arg)(f2(func))\n\nWhen one or more top-level *parameters* have the form *parameter* "="\n*expression*, the function is said to have "default parameter values."\nFor a parameter with a default value, the corresponding *argument* may\nbe omitted from a call, in which case the parameter\'s default value is\nsubstituted.  If a parameter has a default value, all following\nparameters must also have a default value --- this is a syntactic\nrestriction that is not expressed by the grammar.\n\n**Default parameter values are evaluated when the function definition\nis executed.**  This means that the expression is evaluated once, when\nthe function is defined, and that the same "pre-computed" value is\nused for each call.  This is especially important to understand when a\ndefault parameter is a mutable object, such as a list or a dictionary:\nif the function modifies the object (e.g. by appending an item to a\nlist), the default value is in effect modified. This is generally not\nwhat was intended.  A way around this  is to use "None" as the\ndefault, and explicitly test for it in the body of the function, e.g.:\n\n   def whats_on_the_telly(penguin=None):\n       if penguin is None:\n           penguin = []\n       penguin.append("property of the zoo")\n       return penguin\n\nFunction call semantics are described in more detail in section\n*Calls*. A function call always assigns values to all parameters\nmentioned in the parameter list, either from position arguments, from\nkeyword arguments, or from default values.  If the form\n""*identifier"" is present, it is initialized to a tuple receiving any\nexcess positional parameters, defaulting to the empty tuple.  If the\nform ""**identifier"" is present, it is initialized to a new\ndictionary receiving any excess keyword arguments, defaulting to a new\nempty dictionary.\n\nIt is also possible to create anonymous functions (functions not bound\nto a name), for immediate use in expressions.  This uses lambda\nexpressions, described in section *Lambdas*.  Note that the lambda\nexpression is merely a shorthand for a simplified function definition;\na function defined in a ""def"" statement can be passed around or\nassigned to another name just like a function defined by a lambda\nexpression.  The ""def"" form is actually more powerful since it\nallows the execution of multiple statements.\n\n**Programmer\'s note:** Functions are first-class objects.  A ""def""\nform executed inside a function definition defines a local function\nthat can be returned or passed around.  Free variables used in the\nnested function can access the local variables of the function\ncontaining the def.  See section *Naming and binding* for details.\n\n\nClass definitions\n=================\n\nA class definition defines a class object (see section *The standard\ntype hierarchy*):\n\n   classdef    ::= "class" classname [inheritance] ":" suite\n   inheritance ::= "(" [expression_list] ")"\n   classname   ::= identifier\n\nA class definition is an executable statement.  It first evaluates the\ninheritance list, if present.  Each item in the inheritance list\nshould evaluate to a class object or class type which allows\nsubclassing.  The class\'s suite is then executed in a new execution\nframe (see section *Naming and binding*), using a newly created local\nnamespace and the original global namespace. (Usually, the suite\ncontains only function definitions.)  When the class\'s suite finishes\nexecution, its execution frame is discarded but its local namespace is\nsaved. [4] A class object is then created using the inheritance list\nfor the base classes and the saved local namespace for the attribute\ndictionary.  The class name is bound to this class object in the\noriginal local namespace.\n\n**Programmer\'s note:** Variables defined in the class definition are\nclass variables; they are shared by all instances.  To create instance\nvariables, they can be set in a method with "self.name = value".  Both\nclass and instance variables are accessible through the notation\n""self.name"", and an instance variable hides a class variable with\nthe same name when accessed in this way. Class variables can be used\nas defaults for instance variables, but using mutable values there can\nlead to unexpected results.  For *new-style class*es, descriptors can\nbe used to create instance variables with different implementation\ndetails.\n\nClass definitions, like function definitions, may be wrapped by one or\nmore *decorator* expressions.  The evaluation rules for the decorator\nexpressions are the same as for functions.  The result must be a class\nobject, which is then bound to the class name.\n\n-[ Footnotes ]-\n\n[1] The exception is propagated to the invocation stack unless\n    there is a "finally" clause which happens to raise another\n    exception. That new exception causes the old one to be lost.\n\n[2] Currently, control "flows off the end" except in the case of\n    an exception or the execution of a "return", "continue", or\n    "break" statement.\n\n[3] A string literal appearing as the first statement in the\n    function body is transformed into the function\'s "__doc__"\n    attribute and therefore the function\'s *docstring*.\n\n[4] A string literal appearing as the first statement in the class\n    body is transformed into the namespace\'s "__doc__" item and\n    therefore the class\'s *docstring*.\n',
 'context-managers': u'\nWith Statement Context Managers\n*******************************\n\nNew in version 2.5.\n\nA *context manager* is an object that defines the runtime context to\nbe established when executing a "with" statement. The context manager\nhandles the entry into, and the exit from, the desired runtime context\nfor the execution of the block of code.  Context managers are normally\ninvoked using the "with" statement (described in section *The with\nstatement*), but can also be used by directly invoking their methods.\n\nTypical uses of context managers include saving and restoring various\nkinds of global state, locking and unlocking resources, closing opened\nfiles, etc.\n\nFor more information on context managers, see *Context Manager Types*.\n\nobject.__enter__(self)\n\n   Enter the runtime context related to this object. The "with"\n   statement will bind this method\'s return value to the target(s)\n   specified in the "as" clause of the statement, if any.\n\nobject.__exit__(self, exc_type, exc_value, traceback)\n\n   Exit the runtime context related to this object. The parameters\n   describe the exception that caused the context to be exited. If the\n   context was exited without an exception, all three arguments will\n   be "None".\n\n   If an exception is supplied, and the method wishes to suppress the\n   exception (i.e., prevent it from being propagated), it should\n   return a true value. Otherwise, the exception will be processed\n   normally upon exit from this method.\n\n   Note that "__exit__()" methods should not reraise the passed-in\n   exception; this is the caller\'s responsibility.\n\nSee also: **PEP 0343** - The "with" statement\n\n     The specification, background, and examples for the Python "with"\n     statement.\n',
 'continue': u'\nThe "continue" statement\n************************\n\n   continue_stmt ::= "continue"\n\n"continue" may only occur syntactically nested in a "for" or "while"\nloop, but not nested in a function or class definition or "finally"\nclause within that loop.  It continues with the next cycle of the\nnearest enclosing loop.\n\nWhen "continue" passes control out of a "try" statement with a\n"finally" clause, that "finally" clause is executed before really\nstarting the next loop cycle.\n',
 'conversions': u'\nArithmetic conversions\n**********************\n\nWhen a description of an arithmetic operator below uses the phrase\n"the numeric arguments are converted to a common type," the arguments\nare coerced using the coercion rules listed at  *Coercion rules*.  If\nboth arguments are standard numeric types, the following coercions are\napplied:\n\n* If either argument is a complex number, the other is converted to\n  complex;\n\n* otherwise, if either argument is a floating point number, the\n  other is converted to floating point;\n\n* otherwise, if either argument is a long integer, the other is\n  converted to long integer;\n\n* otherwise, both must be plain integers and no conversion is\n  necessary.\n\nSome additional rules apply for certain operators (e.g., a string left\nargument to the \'%\' operator). Extensions can define their own\ncoercions.\n',
 'customization': u'\nBasic customization\n*******************\n\nobject.__new__(cls[, ...])\n\n   Called to create a new instance of class *cls*.  "__new__()" is a\n   static method (special-cased so you need not declare it as such)\n   that takes the class of which an instance was requested as its\n   first argument.  The remaining arguments are those passed to the\n   object constructor expression (the call to the class).  The return\n   value of "__new__()" should be the new object instance (usually an\n   instance of *cls*).\n\n   Typical implementations create a new instance of the class by\n   invoking the superclass\'s "__new__()" method using\n   "super(currentclass, cls).__new__(cls[, ...])" with appropriate\n   arguments and then modifying the newly-created instance as\n   necessary before returning it.\n\n   If "__new__()" returns an instance of *cls*, then the new\n   instance\'s "__init__()" method will be invoked like\n   "__init__(self[, ...])", where *self* is the new instance and the\n   remaining arguments are the same as were passed to "__new__()".\n\n   If "__new__()" does not return an instance of *cls*, then the new\n   instance\'s "__init__()" method will not be invoked.\n\n   "__new__()" is intended mainly to allow subclasses of immutable\n   types (like int, str, or tuple) to customize instance creation.  It\n   is also commonly overridden in custom metaclasses in order to\n   customize class creation.\n\nobject.__init__(self[, ...])\n\n   Called when the instance is created.  The arguments are those\n   passed to the class constructor expression.  If a base class has an\n   "__init__()" method, the derived class\'s "__init__()" method, if\n   any, must explicitly call it to ensure proper initialization of the\n   base class part of the instance; for example:\n   "BaseClass.__init__(self, [args...])".  As a special constraint on\n   constructors, no value may be returned; doing so will cause a\n   "TypeError" to be raised at runtime.\n\nobject.__del__(self)\n\n   Called when the instance is about to be destroyed.  This is also\n   called a destructor.  If a base class has a "__del__()" method, the\n   derived class\'s "__del__()" method, if any, must explicitly call it\n   to ensure proper deletion of the base class part of the instance.\n   Note that it is possible (though not recommended!) for the\n   "__del__()" method to postpone destruction of the instance by\n   creating a new reference to it.  It may then be called at a later\n   time when this new reference is deleted.  It is not guaranteed that\n   "__del__()" methods are called for objects that still exist when\n   the interpreter exits.\n\n   Note: "del x" doesn\'t directly call "x.__del__()" --- the former\n     decrements the reference count for "x" by one, and the latter is\n     only called when "x"\'s reference count reaches zero.  Some common\n     situations that may prevent the reference count of an object from\n     going to zero include: circular references between objects (e.g.,\n     a doubly-linked list or a tree data structure with parent and\n     child pointers); a reference to the object on the stack frame of\n     a function that caught an exception (the traceback stored in\n     "sys.exc_traceback" keeps the stack frame alive); or a reference\n     to the object on the stack frame that raised an unhandled\n     exception in interactive mode (the traceback stored in\n     "sys.last_traceback" keeps the stack frame alive).  The first\n     situation can only be remedied by explicitly breaking the cycles;\n     the latter two situations can be resolved by storing "None" in\n     "sys.exc_traceback" or "sys.last_traceback".  Circular references\n     which are garbage are detected when the option cycle detector is\n     enabled (it\'s on by default), but can only be cleaned up if there\n     are no Python-level "__del__()" methods involved. Refer to the\n     documentation for the "gc" module for more information about how\n     "__del__()" methods are handled by the cycle detector,\n     particularly the description of the "garbage" value.\n\n   Warning: Due to the precarious circumstances under which\n     "__del__()" methods are invoked, exceptions that occur during\n     their execution are ignored, and a warning is printed to\n     "sys.stderr" instead. Also, when "__del__()" is invoked in\n     response to a module being deleted (e.g., when execution of the\n     program is done), other globals referenced by the "__del__()"\n     method may already have been deleted or in the process of being\n     torn down (e.g. the import machinery shutting down).  For this\n     reason, "__del__()" methods should do the absolute minimum needed\n     to maintain external invariants.  Starting with version 1.5,\n     Python guarantees that globals whose name begins with a single\n     underscore are deleted from their module before other globals are\n     deleted; if no other references to such globals exist, this may\n     help in assuring that imported modules are still available at the\n     time when the "__del__()" method is called.\n\n   See also the *-R* command-line option.\n\nobject.__repr__(self)\n\n   Called by the "repr()" built-in function and by string conversions\n   (reverse quotes) to compute the "official" string representation of\n   an object.  If at all possible, this should look like a valid\n   Python expression that could be used to recreate an object with the\n   same value (given an appropriate environment).  If this is not\n   possible, a string of the form "<...some useful description...>"\n   should be returned.  The return value must be a string object. If a\n   class defines "__repr__()" but not "__str__()", then "__repr__()"\n   is also used when an "informal" string representation of instances\n   of that class is required.\n\n   This is typically used for debugging, so it is important that the\n   representation is information-rich and unambiguous.\n\nobject.__str__(self)\n\n   Called by the "str()" built-in function and by the "print"\n   statement to compute the "informal" string representation of an\n   object.  This differs from "__repr__()" in that it does not have to\n   be a valid Python expression: a more convenient or concise\n   representation may be used instead. The return value must be a\n   string object.\n\nobject.__lt__(self, other)\nobject.__le__(self, other)\nobject.__eq__(self, other)\nobject.__ne__(self, other)\nobject.__gt__(self, other)\nobject.__ge__(self, other)\n\n   New in version 2.1.\n\n   These are the so-called "rich comparison" methods, and are called\n   for comparison operators in preference to "__cmp__()" below. The\n   correspondence between operator symbols and method names is as\n   follows: "x<y" calls "x.__lt__(y)", "x<=y" calls "x.__le__(y)",\n   "x==y" calls "x.__eq__(y)", "x!=y" and "x<>y" call "x.__ne__(y)",\n   "x>y" calls "x.__gt__(y)", and "x>=y" calls "x.__ge__(y)".\n\n   A rich comparison method may return the singleton "NotImplemented"\n   if it does not implement the operation for a given pair of\n   arguments. By convention, "False" and "True" are returned for a\n   successful comparison. However, these methods can return any value,\n   so if the comparison operator is used in a Boolean context (e.g.,\n   in the condition of an "if" statement), Python will call "bool()"\n   on the value to determine if the result is true or false.\n\n   There are no implied relationships among the comparison operators.\n   The truth of "x==y" does not imply that "x!=y" is false.\n   Accordingly, when defining "__eq__()", one should also define\n   "__ne__()" so that the operators will behave as expected.  See the\n   paragraph on "__hash__()" for some important notes on creating\n   *hashable* objects which support custom comparison operations and\n   are usable as dictionary keys.\n\n   There are no swapped-argument versions of these methods (to be used\n   when the left argument does not support the operation but the right\n   argument does); rather, "__lt__()" and "__gt__()" are each other\'s\n   reflection, "__le__()" and "__ge__()" are each other\'s reflection,\n   and "__eq__()" and "__ne__()" are their own reflection.\n\n   Arguments to rich comparison methods are never coerced.\n\n   To automatically generate ordering operations from a single root\n   operation, see "functools.total_ordering()".\n\nobject.__cmp__(self, other)\n\n   Called by comparison operations if rich comparison (see above) is\n   not defined.  Should return a negative integer if "self < other",\n   zero if "self == other", a positive integer if "self > other".  If\n   no "__cmp__()", "__eq__()" or "__ne__()" operation is defined,\n   class instances are compared by object identity ("address").  See\n   also the description of "__hash__()" for some important notes on\n   creating *hashable* objects which support custom comparison\n   operations and are usable as dictionary keys. (Note: the\n   restriction that exceptions are not propagated by "__cmp__()" has\n   been removed since Python 1.5.)\n\nobject.__rcmp__(self, other)\n\n   Changed in version 2.1: No longer supported.\n\nobject.__hash__(self)\n\n   Called by built-in function "hash()" and for operations on members\n   of hashed collections including "set", "frozenset", and "dict".\n   "__hash__()" should return an integer.  The only required property\n   is that objects which compare equal have the same hash value; it is\n   advised to somehow mix together (e.g. using exclusive or) the hash\n   values for the components of the object that also play a part in\n   comparison of objects.\n\n   If a class does not define a "__cmp__()" or "__eq__()" method it\n   should not define a "__hash__()" operation either; if it defines\n   "__cmp__()" or "__eq__()" but not "__hash__()", its instances will\n   not be usable in hashed collections.  If a class defines mutable\n   objects and implements a "__cmp__()" or "__eq__()" method, it\n   should not implement "__hash__()", since hashable collection\n   implementations require that a object\'s hash value is immutable (if\n   the object\'s hash value changes, it will be in the wrong hash\n   bucket).\n\n   User-defined classes have "__cmp__()" and "__hash__()" methods by\n   default; with them, all objects compare unequal (except with\n   themselves) and "x.__hash__()" returns a result derived from\n   "id(x)".\n\n   Classes which inherit a "__hash__()" method from a parent class but\n   change the meaning of "__cmp__()" or "__eq__()" such that the hash\n   value returned is no longer appropriate (e.g. by switching to a\n   value-based concept of equality instead of the default identity\n   based equality) can explicitly flag themselves as being unhashable\n   by setting "__hash__ = None" in the class definition. Doing so\n   means that not only will instances of the class raise an\n   appropriate "TypeError" when a program attempts to retrieve their\n   hash value, but they will also be correctly identified as\n   unhashable when checking "isinstance(obj, collections.Hashable)"\n   (unlike classes which define their own "__hash__()" to explicitly\n   raise "TypeError").\n\n   Changed in version 2.5: "__hash__()" may now also return a long\n   integer object; the 32-bit integer is then derived from the hash of\n   that object.\n\n   Changed in version 2.6: "__hash__" may now be set to "None" to\n   explicitly flag instances of a class as unhashable.\n\nobject.__nonzero__(self)\n\n   Called to implement truth value testing and the built-in operation\n   "bool()"; should return "False" or "True", or their integer\n   equivalents "0" or "1".  When this method is not defined,\n   "__len__()" is called, if it is defined, and the object is\n   considered true if its result is nonzero. If a class defines\n   neither "__len__()" nor "__nonzero__()", all its instances are\n   considered true.\n\nobject.__unicode__(self)\n\n   Called to implement "unicode()" built-in; should return a Unicode\n   object. When this method is not defined, string conversion is\n   attempted, and the result of string conversion is converted to\n   Unicode using the system default encoding.\n',
 'debugger': u'\n"pdb" --- The Python Debugger\n*****************************\n\n**Source code:** Lib/pdb.py\n\n======================================================================\n\nThe module "pdb" defines an interactive source code debugger for\nPython programs.  It supports setting (conditional) breakpoints and\nsingle stepping at the source line level, inspection of stack frames,\nsource code listing, and evaluation of arbitrary Python code in the\ncontext of any stack frame.  It also supports post-mortem debugging\nand can be called under program control.\n\nThe debugger is extensible --- it is actually defined as the class\n"Pdb". This is currently undocumented but easily understood by reading\nthe source.  The extension interface uses the modules "bdb" and "cmd".\n\nThe debugger\'s prompt is "(Pdb)". Typical usage to run a program under\ncontrol of the debugger is:\n\n   >>> import pdb\n   >>> import mymodule\n   >>> pdb.run(\'mymodule.test()\')\n   > <string>(0)?()\n   (Pdb) continue\n   > <string>(1)?()\n   (Pdb) continue\n   NameError: \'spam\'\n   > <string>(1)?()\n   (Pdb)\n\n"pdb.py" can also be invoked as a script to debug other scripts.  For\nexample:\n\n   python -m pdb myscript.py\n\nWhen invoked as a script, pdb will automatically enter post-mortem\ndebugging if the program being debugged exits abnormally. After post-\nmortem debugging (or after normal exit of the program), pdb will\nrestart the program. Automatic restarting preserves pdb\'s state (such\nas breakpoints) and in most cases is more useful than quitting the\ndebugger upon program\'s exit.\n\nNew in version 2.4: Restarting post-mortem behavior added.\n\nThe typical usage to break into the debugger from a running program is\nto insert\n\n   import pdb; pdb.set_trace()\n\nat the location you want to break into the debugger.  You can then\nstep through the code following this statement, and continue running\nwithout the debugger using the "c" command.\n\nThe typical usage to inspect a crashed program is:\n\n   >>> import pdb\n   >>> import mymodule\n   >>> mymodule.test()\n   Traceback (most recent call last):\n     File "<stdin>", line 1, in ?\n     File "./mymodule.py", line 4, in test\n       test2()\n     File "./mymodule.py", line 3, in test2\n       print spam\n   NameError: spam\n   >>> pdb.pm()\n   > ./mymodule.py(3)test2()\n   -> print spam\n   (Pdb)\n\nThe module defines the following functions; each enters the debugger\nin a slightly different way:\n\npdb.run(statement[, globals[, locals]])\n\n   Execute the *statement* (given as a string) under debugger control.\n   The debugger prompt appears before any code is executed; you can\n   set breakpoints and type "continue", or you can step through the\n   statement using "step" or "next" (all these commands are explained\n   below).  The optional *globals* and *locals* arguments specify the\n   environment in which the code is executed; by default the\n   dictionary of the module "__main__" is used.  (See the explanation\n   of the "exec" statement or the "eval()" built-in function.)\n\npdb.runeval(expression[, globals[, locals]])\n\n   Evaluate the *expression* (given as a string) under debugger\n   control.  When "runeval()" returns, it returns the value of the\n   expression.  Otherwise this function is similar to "run()".\n\npdb.runcall(function[, argument, ...])\n\n   Call the *function* (a function or method object, not a string)\n   with the given arguments.  When "runcall()" returns, it returns\n   whatever the function call returned.  The debugger prompt appears\n   as soon as the function is entered.\n\npdb.set_trace()\n\n   Enter the debugger at the calling stack frame.  This is useful to\n   hard-code a breakpoint at a given point in a program, even if the\n   code is not otherwise being debugged (e.g. when an assertion\n   fails).\n\npdb.post_mortem([traceback])\n\n   Enter post-mortem debugging of the given *traceback* object.  If no\n   *traceback* is given, it uses the one of the exception that is\n   currently being handled (an exception must be being handled if the\n   default is to be used).\n\npdb.pm()\n\n   Enter post-mortem debugging of the traceback found in\n   "sys.last_traceback".\n\nThe "run*" functions and "set_trace()" are aliases for instantiating\nthe "Pdb" class and calling the method of the same name.  If you want\nto access further features, you have to do this yourself:\n\nclass class pdb.Pdb(completekey=\'tab\', stdin=None, stdout=None, skip=None)\n\n   "Pdb" is the debugger class.\n\n   The *completekey*, *stdin* and *stdout* arguments are passed to the\n   underlying "cmd.Cmd" class; see the description there.\n\n   The *skip* argument, if given, must be an iterable of glob-style\n   module name patterns.  The debugger will not step into frames that\n   originate in a module that matches one of these patterns. [1]\n\n   Example call to enable tracing with *skip*:\n\n      import pdb; pdb.Pdb(skip=[\'django.*\']).set_trace()\n\n   New in version 2.7: The *skip* argument.\n\n   run(statement[, globals[, locals]])\n   runeval(expression[, globals[, locals]])\n   runcall(function[, argument, ...])\n   set_trace()\n\n      See the documentation for the functions explained above.\n',
 'del': u'\nThe "del" statement\n*******************\n\n   del_stmt ::= "del" target_list\n\nDeletion is recursively defined very similar to the way assignment is\ndefined. Rather than spelling it out in full details, here are some\nhints.\n\nDeletion of a target list recursively deletes each target, from left\nto right.\n\nDeletion of a name removes the binding of that name  from the local or\nglobal namespace, depending on whether the name occurs in a "global"\nstatement in the same code block.  If the name is unbound, a\n"NameError" exception will be raised.\n\nIt is illegal to delete a name from the local namespace if it occurs\nas a free variable in a nested block.\n\nDeletion of attribute references, subscriptions and slicings is passed\nto the primary object involved; deletion of a slicing is in general\nequivalent to assignment of an empty slice of the right type (but even\nthis is determined by the sliced object).\n',
 'dict': u'\nDictionary displays\n*******************\n\nA dictionary display is a possibly empty series of key/datum pairs\nenclosed in curly braces:\n\n   dict_display       ::= "{" [key_datum_list | dict_comprehension] "}"\n   key_datum_list     ::= key_datum ("," key_datum)* [","]\n   key_datum          ::= expression ":" expression\n   dict_comprehension ::= expression ":" expression comp_for\n\nA dictionary display yields a new dictionary object.\n\nIf a comma-separated sequence of key/datum pairs is given, they are\nevaluated from left to right to define the entries of the dictionary:\neach key object is used as a key into the dictionary to store the\ncorresponding datum.  This means that you can specify the same key\nmultiple times in the key/datum list, and the final dictionary\'s value\nfor that key will be the last one given.\n\nA dict comprehension, in contrast to list and set comprehensions,\nneeds two expressions separated with a colon followed by the usual\n"for" and "if" clauses. When the comprehension is run, the resulting\nkey and value elements are inserted in the new dictionary in the order\nthey are produced.\n\nRestrictions on the types of the key values are listed earlier in\nsection *The standard type hierarchy*.  (To summarize, the key type\nshould be *hashable*, which excludes all mutable objects.)  Clashes\nbetween duplicate keys are not detected; the last datum (textually\nrightmost in the display) stored for a given key value prevails.\n',
 'dynamic-features': u'\nInteraction with dynamic features\n*********************************\n\nThere are several cases where Python statements are illegal when used\nin conjunction with nested scopes that contain free variables.\n\nIf a variable is referenced in an enclosing scope, it is illegal to\ndelete the name.  An error will be reported at compile time.\n\nIf the wild card form of import --- "import *" --- is used in a\nfunction and the function contains or is a nested block with free\nvariables, the compiler will raise a "SyntaxError".\n\nIf "exec" is used in a function and the function contains or is a\nnested block with free variables, the compiler will raise a\n"SyntaxError" unless the exec explicitly specifies the local namespace\nfor the "exec".  (In other words, "exec obj" would be illegal, but\n"exec obj in ns" would be legal.)\n\nThe "eval()", "execfile()", and "input()" functions and the "exec"\nstatement do not have access to the full environment for resolving\nnames.  Names may be resolved in the local and global namespaces of\nthe caller.  Free variables are not resolved in the nearest enclosing\nnamespace, but in the global namespace. [1] The "exec" statement and\nthe "eval()" and "execfile()" functions have optional arguments to\noverride the global and local namespace.  If only one namespace is\nspecified, it is used for both.\n',
 'else': u'\nThe "if" statement\n******************\n\nThe "if" statement is used for conditional execution:\n\n   if_stmt ::= "if" expression ":" suite\n               ( "elif" expression ":" suite )*\n               ["else" ":" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section *Boolean operations*\nfor the definition of true and false); then that suite is executed\n(and no other part of the "if" statement is executed or evaluated).\nIf all expressions are false, the suite of the "else" clause, if\npresent, is executed.\n',
 'exceptions': u'\nExceptions\n**********\n\nExceptions are a means of breaking out of the normal flow of control\nof a code block in order to handle errors or other exceptional\nconditions.  An exception is *raised* at the point where the error is\ndetected; it may be *handled* by the surrounding code block or by any\ncode block that directly or indirectly invoked the code block where\nthe error occurred.\n\nThe Python interpreter raises an exception when it detects a run-time\nerror (such as division by zero).  A Python program can also\nexplicitly raise an exception with the "raise" statement. Exception\nhandlers are specified with the "try" ... "except" statement.  The\n"finally" clause of such a statement can be used to specify cleanup\ncode which does not handle the exception, but is executed whether an\nexception occurred or not in the preceding code.\n\nPython uses the "termination" model of error handling: an exception\nhandler can find out what happened and continue execution at an outer\nlevel, but it cannot repair the cause of the error and retry the\nfailing operation (except by re-entering the offending piece of code\nfrom the top).\n\nWhen an exception is not handled at all, the interpreter terminates\nexecution of the program, or returns to its interactive main loop.  In\neither case, it prints a stack backtrace, except when the exception is\n"SystemExit".\n\nExceptions are identified by class instances.  The "except" clause is\nselected depending on the class of the instance: it must reference the\nclass of the instance or a base class thereof.  The instance can be\nreceived by the handler and can carry additional information about the\nexceptional condition.\n\nExceptions can also be identified by strings, in which case the\n"except" clause is selected by object identity.  An arbitrary value\ncan be raised along with the identifying string which can be passed to\nthe handler.\n\nNote: Messages to exceptions are not part of the Python API.  Their\n  contents may change from one version of Python to the next without\n  warning and should not be relied on by code which will run under\n  multiple versions of the interpreter.\n\nSee also the description of the "try" statement in section *The try\nstatement* and "raise" statement in section *The raise statement*.\n\n-[ Footnotes ]-\n\n[1] This limitation occurs because the code that is executed by\n    these operations is not available at the time the module is\n    compiled.\n',
 'exec': u'\nThe "exec" statement\n********************\n\n   exec_stmt ::= "exec" or_expr ["in" expression ["," expression]]\n\nThis statement supports dynamic execution of Python code.  The first\nexpression should evaluate to either a Unicode string, a *Latin-1*\nencoded string, an open file object, a code object, or a tuple.  If it\nis a string, the string is parsed as a suite of Python statements\nwhich is then executed (unless a syntax error occurs). [1] If it is an\nopen file, the file is parsed until EOF and executed. If it is a code\nobject, it is simply executed.  For the interpretation of a tuple, see\nbelow.  In all cases, the code that\'s executed is expected to be valid\nas file input (see section *File input*).  Be aware that the "return"\nand "yield" statements may not be used outside of function definitions\neven within the context of code passed to the "exec" statement.\n\nIn all cases, if the optional parts are omitted, the code is executed\nin the current scope.  If only the first expression after "in" is\nspecified, it should be a dictionary, which will be used for both the\nglobal and the local variables.  If two expressions are given, they\nare used for the global and local variables, respectively. If\nprovided, *locals* can be any mapping object. Remember that at module\nlevel, globals and locals are the same dictionary. If two separate\nobjects are given as *globals* and *locals*, the code will be executed\nas if it were embedded in a class definition.\n\nThe first expression may also be a tuple of length 2 or 3.  In this\ncase, the optional parts must be omitted.  The form "exec(expr,\nglobals)" is equivalent to "exec expr in globals", while the form\n"exec(expr, globals, locals)" is equivalent to "exec expr in globals,\nlocals".  The tuple form of "exec" provides compatibility with Python\n3, where "exec" is a function rather than a statement.\n\nChanged in version 2.4: Formerly, *locals* was required to be a\ndictionary.\n\nAs a side effect, an implementation may insert additional keys into\nthe dictionaries given besides those corresponding to variable names\nset by the executed code.  For example, the current implementation may\nadd a reference to the dictionary of the built-in module "__builtin__"\nunder the key "__builtins__" (!).\n\n**Programmer\'s hints:** dynamic evaluation of expressions is supported\nby the built-in function "eval()".  The built-in functions "globals()"\nand "locals()" return the current global and local dictionary,\nrespectively, which may be useful to pass around for use by "exec".\n\n-[ Footnotes ]-\n\n[1] Note that the parser only accepts the Unix-style end of line\n    convention. If you are reading the code from a file, make sure to\n    use *universal newlines* mode to convert Windows or Mac-style\n    newlines.\n',
 'execmodel': u'\nExecution model\n***************\n\n\nNaming and binding\n==================\n\n*Names* refer to objects.  Names are introduced by name binding\noperations. Each occurrence of a name in the program text refers to\nthe *binding* of that name established in the innermost function block\ncontaining the use.\n\nA *block* is a piece of Python program text that is executed as a\nunit. The following are blocks: a module, a function body, and a class\ndefinition. Each command typed interactively is a block.  A script\nfile (a file given as standard input to the interpreter or specified\non the interpreter command line the first argument) is a code block.\nA script command (a command specified on the interpreter command line\nwith the \'**-c**\' option) is a code block.  The file read by the\nbuilt-in function "execfile()" is a code block.  The string argument\npassed to the built-in function "eval()" and to the "exec" statement\nis a code block. The expression read and evaluated by the built-in\nfunction "input()" is a code block.\n\nA code block is executed in an *execution frame*.  A frame contains\nsome administrative information (used for debugging) and determines\nwhere and how execution continues after the code block\'s execution has\ncompleted.\n\nA *scope* defines the visibility of a name within a block.  If a local\nvariable is defined in a block, its scope includes that block.  If the\ndefinition occurs in a function block, the scope extends to any blocks\ncontained within the defining one, unless a contained block introduces\na different binding for the name.  The scope of names defined in a\nclass block is limited to the class block; it does not extend to the\ncode blocks of methods -- this includes generator expressions since\nthey are implemented using a function scope.  This means that the\nfollowing will fail:\n\n   class A:\n       a = 42\n       b = list(a + i for i in range(10))\n\nWhen a name is used in a code block, it is resolved using the nearest\nenclosing scope.  The set of all such scopes visible to a code block\nis called the block\'s *environment*.\n\nIf a name is bound in a block, it is a local variable of that block.\nIf a name is bound at the module level, it is a global variable.  (The\nvariables of the module code block are local and global.)  If a\nvariable is used in a code block but not defined there, it is a *free\nvariable*.\n\nWhen a name is not found at all, a "NameError" exception is raised.\nIf the name refers to a local variable that has not been bound, a\n"UnboundLocalError" exception is raised.  "UnboundLocalError" is a\nsubclass of "NameError".\n\nThe following constructs bind names: formal parameters to functions,\n"import" statements, class and function definitions (these bind the\nclass or function name in the defining block), and targets that are\nidentifiers if occurring in an assignment, "for" loop header, in the\nsecond position of an "except" clause header or after "as" in a "with"\nstatement.  The "import" statement of the form "from ... import *"\nbinds all names defined in the imported module, except those beginning\nwith an underscore.  This form may only be used at the module level.\n\nA target occurring in a "del" statement is also considered bound for\nthis purpose (though the actual semantics are to unbind the name).  It\nis illegal to unbind a name that is referenced by an enclosing scope;\nthe compiler will report a "SyntaxError".\n\nEach assignment or import statement occurs within a block defined by a\nclass or function definition or at the module level (the top-level\ncode block).\n\nIf a name binding operation occurs anywhere within a code block, all\nuses of the name within the block are treated as references to the\ncurrent block.  This can lead to errors when a name is used within a\nblock before it is bound. This rule is subtle.  Python lacks\ndeclarations and allows name binding operations to occur anywhere\nwithin a code block.  The local variables of a code block can be\ndetermined by scanning the entire text of the block for name binding\noperations.\n\nIf the global statement occurs within a block, all uses of the name\nspecified in the statement refer to the binding of that name in the\ntop-level namespace. Names are resolved in the top-level namespace by\nsearching the global namespace, i.e. the namespace of the module\ncontaining the code block, and the builtins namespace, the namespace\nof the module "__builtin__".  The global namespace is searched first.\nIf the name is not found there, the builtins namespace is searched.\nThe global statement must precede all uses of the name.\n\nThe builtins namespace associated with the execution of a code block\nis actually found by looking up the name "__builtins__" in its global\nnamespace; this should be a dictionary or a module (in the latter case\nthe module\'s dictionary is used).  By default, when in the "__main__"\nmodule, "__builtins__" is the built-in module "__builtin__" (note: no\n\'s\'); when in any other module, "__builtins__" is an alias for the\ndictionary of the "__builtin__" module itself.  "__builtins__" can be\nset to a user-created dictionary to create a weak form of restricted\nexecution.\n\n**CPython implementation detail:** Users should not touch\n"__builtins__"; it is strictly an implementation detail.  Users\nwanting to override values in the builtins namespace should "import"\nthe "__builtin__" (no \'s\') module and modify its attributes\nappropriately.\n\nThe namespace for a module is automatically created the first time a\nmodule is imported.  The main module for a script is always called\n"__main__".\n\nThe "global" statement has the same scope as a name binding operation\nin the same block.  If the nearest enclosing scope for a free variable\ncontains a global statement, the free variable is treated as a global.\n\nA class definition is an executable statement that may use and define\nnames. These references follow the normal rules for name resolution.\nThe namespace of the class definition becomes the attribute dictionary\nof the class.  Names defined at the class scope are not visible in\nmethods.\n\n\nInteraction with dynamic features\n---------------------------------\n\nThere are several cases where Python statements are illegal when used\nin conjunction with nested scopes that contain free variables.\n\nIf a variable is referenced in an enclosing scope, it is illegal to\ndelete the name.  An error will be reported at compile time.\n\nIf the wild card form of import --- "import *" --- is used in a\nfunction and the function contains or is a nested block with free\nvariables, the compiler will raise a "SyntaxError".\n\nIf "exec" is used in a function and the function contains or is a\nnested block with free variables, the compiler will raise a\n"SyntaxError" unless the exec explicitly specifies the local namespace\nfor the "exec".  (In other words, "exec obj" would be illegal, but\n"exec obj in ns" would be legal.)\n\nThe "eval()", "execfile()", and "input()" functions and the "exec"\nstatement do not have access to the full environment for resolving\nnames.  Names may be resolved in the local and global namespaces of\nthe caller.  Free variables are not resolved in the nearest enclosing\nnamespace, but in the global namespace. [1] The "exec" statement and\nthe "eval()" and "execfile()" functions have optional arguments to\noverride the global and local namespace.  If only one namespace is\nspecified, it is used for both.\n\n\nExceptions\n==========\n\nExceptions are a means of breaking out of the normal flow of control\nof a code block in order to handle errors or other exceptional\nconditions.  An exception is *raised* at the point where the error is\ndetected; it may be *handled* by the surrounding code block or by any\ncode block that directly or indirectly invoked the code block where\nthe error occurred.\n\nThe Python interpreter raises an exception when it detects a run-time\nerror (such as division by zero).  A Python program can also\nexplicitly raise an exception with the "raise" statement. Exception\nhandlers are specified with the "try" ... "except" statement.  The\n"finally" clause of such a statement can be used to specify cleanup\ncode which does not handle the exception, but is executed whether an\nexception occurred or not in the preceding code.\n\nPython uses the "termination" model of error handling: an exception\nhandler can find out what happened and continue execution at an outer\nlevel, but it cannot repair the cause of the error and retry the\nfailing operation (except by re-entering the offending piece of code\nfrom the top).\n\nWhen an exception is not handled at all, the interpreter terminates\nexecution of the program, or returns to its interactive main loop.  In\neither case, it prints a stack backtrace, except when the exception is\n"SystemExit".\n\nExceptions are identified by class instances.  The "except" clause is\nselected depending on the class of the instance: it must reference the\nclass of the instance or a base class thereof.  The instance can be\nreceived by the handler and can carry additional information about the\nexceptional condition.\n\nExceptions can also be identified by strings, in which case the\n"except" clause is selected by object identity.  An arbitrary value\ncan be raised along with the identifying string which can be passed to\nthe handler.\n\nNote: Messages to exceptions are not part of the Python API.  Their\n  contents may change from one version of Python to the next without\n  warning and should not be relied on by code which will run under\n  multiple versions of the interpreter.\n\nSee also the description of the "try" statement in section *The try\nstatement* and "raise" statement in section *The raise statement*.\n\n-[ Footnotes ]-\n\n[1] This limitation occurs because the code that is executed by\n    these operations is not available at the time the module is\n    compiled.\n',
 'exprlists': u'\nExpression lists\n****************\n\n   expression_list ::= expression ( "," expression )* [","]\n\nAn expression list containing at least one comma yields a tuple.  The\nlength of the tuple is the number of expressions in the list.  The\nexpressions are evaluated from left to right.\n\nThe trailing comma is required only to create a single tuple (a.k.a. a\n*singleton*); it is optional in all other cases.  A single expression\nwithout a trailing comma doesn\'t create a tuple, but rather yields the\nvalue of that expression. (To create an empty tuple, use an empty pair\nof parentheses: "()".)\n',
 'floating': u'\nFloating point literals\n***********************\n\nFloating point literals are described by the following lexical\ndefinitions:\n\n   floatnumber   ::= pointfloat | exponentfloat\n   pointfloat    ::= [intpart] fraction | intpart "."\n   exponentfloat ::= (intpart | pointfloat) exponent\n   intpart       ::= digit+\n   fraction      ::= "." digit+\n   exponent      ::= ("e" | "E") ["+" | "-"] digit+\n\nNote that the integer and exponent parts of floating point numbers can\nlook like octal integers, but are interpreted using radix 10.  For\nexample, "077e010" is legal, and denotes the same number as "77e10".\nThe allowed range of floating point literals is implementation-\ndependent. Some examples of floating point literals:\n\n   3.14    10.    .001    1e100    3.14e-10    0e0\n\nNote that numeric literals do not include a sign; a phrase like "-1"\nis actually an expression composed of the unary operator "-" and the\nliteral "1".\n',
 'for': u'\nThe "for" statement\n*******************\n\nThe "for" statement is used to iterate over the elements of a sequence\n(such as a string, tuple or list) or other iterable object:\n\n   for_stmt ::= "for" target_list "in" expression_list ":" suite\n                ["else" ":" suite]\n\nThe expression list is evaluated once; it should yield an iterable\nobject.  An iterator is created for the result of the\n"expression_list".  The suite is then executed once for each item\nprovided by the iterator, in the order of ascending indices.  Each\nitem in turn is assigned to the target list using the standard rules\nfor assignments, and then the suite is executed.  When the items are\nexhausted (which is immediately when the sequence is empty), the suite\nin the "else" clause, if present, is executed, and the loop\nterminates.\n\nA "break" statement executed in the first suite terminates the loop\nwithout executing the "else" clause\'s suite.  A "continue" statement\nexecuted in the first suite skips the rest of the suite and continues\nwith the next item, or with the "else" clause if there was no next\nitem.\n\nThe suite may assign to the variable(s) in the target list; this does\nnot affect the next item assigned to it.\n\nThe target list is not deleted when the loop is finished, but if the\nsequence is empty, it will not have been assigned to at all by the\nloop.  Hint: the built-in function "range()" returns a sequence of\nintegers suitable to emulate the effect of Pascal\'s "for i := a to b\ndo"; e.g., "range(3)" returns the list "[0, 1, 2]".\n\nNote: There is a subtlety when the sequence is being modified by the\n  loop (this can only occur for mutable sequences, i.e. lists). An\n  internal counter is used to keep track of which item is used next,\n  and this is incremented on each iteration.  When this counter has\n  reached the length of the sequence the loop terminates.  This means\n  that if the suite deletes the current (or a previous) item from the\n  sequence, the next item will be skipped (since it gets the index of\n  the current item which has already been treated).  Likewise, if the\n  suite inserts an item in the sequence before the current item, the\n  current item will be treated again the next time through the loop.\n  This can lead to nasty bugs that can be avoided by making a\n  temporary copy using a slice of the whole sequence, e.g.,\n\n     for x in a[:]:\n         if x < 0: a.remove(x)\n',
 'formatstrings': u'\nFormat String Syntax\n********************\n\nThe "str.format()" method and the "Formatter" class share the same\nsyntax for format strings (although in the case of "Formatter",\nsubclasses can define their own format string syntax).\n\nFormat strings contain "replacement fields" surrounded by curly braces\n"{}". Anything that is not contained in braces is considered literal\ntext, which is copied unchanged to the output.  If you need to include\na brace character in the literal text, it can be escaped by doubling:\n"{{" and "}}".\n\nThe grammar for a replacement field is as follows:\n\n      replacement_field ::= "{" [field_name] ["!" conversion] [":" format_spec] "}"\n      field_name        ::= arg_name ("." attribute_name | "[" element_index "]")*\n      arg_name          ::= [identifier | integer]\n      attribute_name    ::= identifier\n      element_index     ::= integer | index_string\n      index_string      ::= <any source character except "]"> +\n      conversion        ::= "r" | "s"\n      format_spec       ::= <described in the next section>\n\nIn less formal terms, the replacement field can start with a\n*field_name* that specifies the object whose value is to be formatted\nand inserted into the output instead of the replacement field. The\n*field_name* is optionally followed by a  *conversion* field, which is\npreceded by an exclamation point "\'!\'", and a *format_spec*, which is\npreceded by a colon "\':\'".  These specify a non-default format for the\nreplacement value.\n\nSee also the *Format Specification Mini-Language* section.\n\nThe *field_name* itself begins with an *arg_name* that is either a\nnumber or a keyword.  If it\'s a number, it refers to a positional\nargument, and if it\'s a keyword, it refers to a named keyword\nargument.  If the numerical arg_names in a format string are 0, 1, 2,\n... in sequence, they can all be omitted (not just some) and the\nnumbers 0, 1, 2, ... will be automatically inserted in that order.\nBecause *arg_name* is not quote-delimited, it is not possible to\nspecify arbitrary dictionary keys (e.g., the strings "\'10\'" or\n"\':-]\'") within a format string. The *arg_name* can be followed by any\nnumber of index or attribute expressions. An expression of the form\n"\'.name\'" selects the named attribute using "getattr()", while an\nexpression of the form "\'[index]\'" does an index lookup using\n"__getitem__()".\n\nChanged in version 2.7: The positional argument specifiers can be\nomitted, so "\'{} {}\'" is equivalent to "\'{0} {1}\'".\n\nSome simple format string examples:\n\n   "First, thou shalt count to {0}" # References first positional argument\n   "Bring me a {}"                  # Implicitly references the first positional argument\n   "From {} to {}"                  # Same as "From {0} to {1}"\n   "My quest is {name}"             # References keyword argument \'name\'\n   "Weight in tons {0.weight}"      # \'weight\' attribute of first positional arg\n   "Units destroyed: {players[0]}"  # First element of keyword argument \'players\'.\n\nThe *conversion* field causes a type coercion before formatting.\nNormally, the job of formatting a value is done by the "__format__()"\nmethod of the value itself.  However, in some cases it is desirable to\nforce a type to be formatted as a string, overriding its own\ndefinition of formatting.  By converting the value to a string before\ncalling "__format__()", the normal formatting logic is bypassed.\n\nTwo conversion flags are currently supported: "\'!s\'" which calls\n"str()" on the value, and "\'!r\'" which calls "repr()".\n\nSome examples:\n\n   "Harold\'s a clever {0!s}"        # Calls str() on the argument first\n   "Bring out the holy {name!r}"    # Calls repr() on the argument first\n\nThe *format_spec* field contains a specification of how the value\nshould be presented, including such details as field width, alignment,\npadding, decimal precision and so on.  Each value type can define its\nown "formatting mini-language" or interpretation of the *format_spec*.\n\nMost built-in types support a common formatting mini-language, which\nis described in the next section.\n\nA *format_spec* field can also include nested replacement fields\nwithin it. These nested replacement fields can contain only a field\nname; conversion flags and format specifications are not allowed.  The\nreplacement fields within the format_spec are substituted before the\n*format_spec* string is interpreted. This allows the formatting of a\nvalue to be dynamically specified.\n\nSee the *Format examples* section for some examples.\n\n\nFormat Specification Mini-Language\n==================================\n\n"Format specifications" are used within replacement fields contained\nwithin a format string to define how individual values are presented\n(see *Format String Syntax*).  They can also be passed directly to the\nbuilt-in "format()" function.  Each formattable type may define how\nthe format specification is to be interpreted.\n\nMost built-in types implement the following options for format\nspecifications, although some of the formatting options are only\nsupported by the numeric types.\n\nA general convention is that an empty format string ("""") produces\nthe same result as if you had called "str()" on the value. A non-empty\nformat string typically modifies the result.\n\nThe general form of a *standard format specifier* is:\n\n   format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]\n   fill        ::= <any character>\n   align       ::= "<" | ">" | "=" | "^"\n   sign        ::= "+" | "-" | " "\n   width       ::= integer\n   precision   ::= integer\n   type        ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"\n\nIf a valid *align* value is specified, it can be preceded by a *fill*\ncharacter that can be any character and defaults to a space if\nomitted. Note that it is not possible to use "{" and "}" as *fill*\nchar while using the "str.format()" method; this limitation however\ndoesn\'t affect the "format()" function.\n\nThe meaning of the various alignment options is as follows:\n\n   +-----------+------------------------------------------------------------+\n   | Option    | Meaning                                                    |\n   +===========+============================================================+\n   | "\'<\'"     | Forces the field to be left-aligned within the available   |\n   |           | space (this is the default for most objects).              |\n   +-----------+------------------------------------------------------------+\n   | "\'>\'"     | Forces the field to be right-aligned within the available  |\n   |           | space (this is the default for numbers).                   |\n   +-----------+------------------------------------------------------------+\n   | "\'=\'"     | Forces the padding to be placed after the sign (if any)    |\n   |           | but before the digits.  This is used for printing fields   |\n   |           | in the form \'+000000120\'. This alignment option is only    |\n   |           | valid for numeric types.                                   |\n   +-----------+------------------------------------------------------------+\n   | "\'^\'"     | Forces the field to be centered within the available       |\n   |           | space.                                                     |\n   +-----------+------------------------------------------------------------+\n\nNote that unless a minimum field width is defined, the field width\nwill always be the same size as the data to fill it, so that the\nalignment option has no meaning in this case.\n\nThe *sign* option is only valid for number types, and can be one of\nthe following:\n\n   +-----------+------------------------------------------------------------+\n   | Option    | Meaning                                                    |\n   +===========+============================================================+\n   | "\'+\'"     | indicates that a sign should be used for both positive as  |\n   |           | well as negative numbers.                                  |\n   +-----------+------------------------------------------------------------+\n   | "\'-\'"     | indicates that a sign should be used only for negative     |\n   |           | numbers (this is the default behavior).                    |\n   +-----------+------------------------------------------------------------+\n   | space     | indicates that a leading space should be used on positive  |\n   |           | numbers, and a minus sign on negative numbers.             |\n   +-----------+------------------------------------------------------------+\n\nThe "\'#\'" option is only valid for integers, and only for binary,\noctal, or hexadecimal output.  If present, it specifies that the\noutput will be prefixed by "\'0b\'", "\'0o\'", or "\'0x\'", respectively.\n\nThe "\',\'" option signals the use of a comma for a thousands separator.\nFor a locale aware separator, use the "\'n\'" integer presentation type\ninstead.\n\nChanged in version 2.7: Added the "\',\'" option (see also **PEP 378**).\n\n*width* is a decimal integer defining the minimum field width.  If not\nspecified, then the field width will be determined by the content.\n\nPreceding the *width* field by a zero ("\'0\'") character enables sign-\naware zero-padding for numeric types.  This is equivalent to a *fill*\ncharacter of "\'0\'" with an *alignment* type of "\'=\'".\n\nThe *precision* is a decimal number indicating how many digits should\nbe displayed after the decimal point for a floating point value\nformatted with "\'f\'" and "\'F\'", or before and after the decimal point\nfor a floating point value formatted with "\'g\'" or "\'G\'".  For non-\nnumber types the field indicates the maximum field size - in other\nwords, how many characters will be used from the field content. The\n*precision* is not allowed for integer values.\n\nFinally, the *type* determines how the data should be presented.\n\nThe available string presentation types are:\n\n   +-----------+------------------------------------------------------------+\n   | Type      | Meaning                                                    |\n   +===========+============================================================+\n   | "\'s\'"     | String format. This is the default type for strings and    |\n   |           | may be omitted.                                            |\n   +-----------+------------------------------------------------------------+\n   | None      | The same as "\'s\'".                                         |\n   +-----------+------------------------------------------------------------+\n\nThe available integer presentation types are:\n\n   +-----------+------------------------------------------------------------+\n   | Type      | Meaning                                                    |\n   +===========+============================================================+\n   | "\'b\'"     | Binary format. Outputs the number in base 2.               |\n   +-----------+------------------------------------------------------------+\n   | "\'c\'"     | Character. Converts the integer to the corresponding       |\n   |           | unicode character before printing.                         |\n   +-----------+------------------------------------------------------------+\n   | "\'d\'"     | Decimal Integer. Outputs the number in base 10.            |\n   +-----------+------------------------------------------------------------+\n   | "\'o\'"     | Octal format. Outputs the number in base 8.                |\n   +-----------+------------------------------------------------------------+\n   | "\'x\'"     | Hex format. Outputs the number in base 16, using lower-    |\n   |           | case letters for the digits above 9.                       |\n   +-----------+------------------------------------------------------------+\n   | "\'X\'"     | Hex format. Outputs the number in base 16, using upper-    |\n   |           | case letters for the digits above 9.                       |\n   +-----------+------------------------------------------------------------+\n   | "\'n\'"     | Number. This is the same as "\'d\'", except that it uses the |\n   |           | current locale setting to insert the appropriate number    |\n   |           | separator characters.                                      |\n   +-----------+------------------------------------------------------------+\n   | None      | The same as "\'d\'".                                         |\n   +-----------+------------------------------------------------------------+\n\nIn addition to the above presentation types, integers can be formatted\nwith the floating point presentation types listed below (except "\'n\'"\nand None). When doing so, "float()" is used to convert the integer to\na floating point number before formatting.\n\nThe available presentation types for floating point and decimal values\nare:\n\n   +-----------+------------------------------------------------------------+\n   | Type      | Meaning                                                    |\n   +===========+============================================================+\n   | "\'e\'"     | Exponent notation. Prints the number in scientific         |\n   |           | notation using the letter \'e\' to indicate the exponent.    |\n   |           | The default precision is "6".                              |\n   +-----------+------------------------------------------------------------+\n   | "\'E\'"     | Exponent notation. Same as "\'e\'" except it uses an upper   |\n   |           | case \'E\' as the separator character.                       |\n   +-----------+------------------------------------------------------------+\n   | "\'f\'"     | Fixed point. Displays the number as a fixed-point number.  |\n   |           | The default precision is "6".                              |\n   +-----------+------------------------------------------------------------+\n   | "\'F\'"     | Fixed point. Same as "\'f\'".                                |\n   +-----------+------------------------------------------------------------+\n   | "\'g\'"     | General format.  For a given precision "p >= 1", this      |\n   |           | rounds the number to "p" significant digits and then       |\n   |           | formats the result in either fixed-point format or in      |\n   |           | scientific notation, depending on its magnitude.  The      |\n   |           | precise rules are as follows: suppose that the result      |\n   |           | formatted with presentation type "\'e\'" and precision "p-1" |\n   |           | would have exponent "exp".  Then if "-4 <= exp < p", the   |\n   |           | number is formatted with presentation type "\'f\'" and       |\n   |           | precision "p-1-exp".  Otherwise, the number is formatted   |\n   |           | with presentation type "\'e\'" and precision "p-1". In both  |\n   |           | cases insignificant trailing zeros are removed from the    |\n   |           | significand, and the decimal point is also removed if      |\n   |           | there are no remaining digits following it.  Positive and  |\n   |           | negative infinity, positive and negative zero, and nans,   |\n   |           | are formatted as "inf", "-inf", "0", "-0" and "nan"        |\n   |           | respectively, regardless of the precision.  A precision of |\n   |           | "0" is treated as equivalent to a precision of "1". The    |\n   |           | default precision is "6".                                  |\n   +-----------+------------------------------------------------------------+\n   | "\'G\'"     | General format. Same as "\'g\'" except switches to "\'E\'" if  |\n   |           | the number gets too large. The representations of infinity |\n   |           | and NaN are uppercased, too.                               |\n   +-----------+------------------------------------------------------------+\n   | "\'n\'"     | Number. This is the same as "\'g\'", except that it uses the |\n   |           | current locale setting to insert the appropriate number    |\n   |           | separator characters.                                      |\n   +-----------+------------------------------------------------------------+\n   | "\'%\'"     | Percentage. Multiplies the number by 100 and displays in   |\n   |           | fixed ("\'f\'") format, followed by a percent sign.          |\n   +-----------+------------------------------------------------------------+\n   | None      | The same as "\'g\'".                                         |\n   +-----------+------------------------------------------------------------+\n\n\nFormat examples\n===============\n\nThis section contains examples of the new format syntax and comparison\nwith the old "%"-formatting.\n\nIn most of the cases the syntax is similar to the old "%"-formatting,\nwith the addition of the "{}" and with ":" used instead of "%". For\nexample, "\'%03.2f\'" can be translated to "\'{:03.2f}\'".\n\nThe new format syntax also supports new and different options, shown\nin the follow examples.\n\nAccessing arguments by position:\n\n   >>> \'{0}, {1}, {2}\'.format(\'a\', \'b\', \'c\')\n   \'a, b, c\'\n   >>> \'{}, {}, {}\'.format(\'a\', \'b\', \'c\')  # 2.7+ only\n   \'a, b, c\'\n   >>> \'{2}, {1}, {0}\'.format(\'a\', \'b\', \'c\')\n   \'c, b, a\'\n   >>> \'{2}, {1}, {0}\'.format(*\'abc\')      # unpacking argument sequence\n   \'c, b, a\'\n   >>> \'{0}{1}{0}\'.format(\'abra\', \'cad\')   # arguments\' indices can be repeated\n   \'abracadabra\'\n\nAccessing arguments by name:\n\n   >>> \'Coordinates: {latitude}, {longitude}\'.format(latitude=\'37.24N\', longitude=\'-115.81W\')\n   \'Coordinates: 37.24N, -115.81W\'\n   >>> coord = {\'latitude\': \'37.24N\', \'longitude\': \'-115.81W\'}\n   >>> \'Coordinates: {latitude}, {longitude}\'.format(**coord)\n   \'Coordinates: 37.24N, -115.81W\'\n\nAccessing arguments\' attributes:\n\n   >>> c = 3-5j\n   >>> (\'The complex number {0} is formed from the real part {0.real} \'\n   ...  \'and the imaginary part {0.imag}.\').format(c)\n   \'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.\'\n   >>> class Point(object):\n   ...     def __init__(self, x, y):\n   ...         self.x, self.y = x, y\n   ...     def __str__(self):\n   ...         return \'Point({self.x}, {self.y})\'.format(self=self)\n   ...\n   >>> str(Point(4, 2))\n   \'Point(4, 2)\'\n\nAccessing arguments\' items:\n\n   >>> coord = (3, 5)\n   >>> \'X: {0[0]};  Y: {0[1]}\'.format(coord)\n   \'X: 3;  Y: 5\'\n\nReplacing "%s" and "%r":\n\n   >>> "repr() shows quotes: {!r}; str() doesn\'t: {!s}".format(\'test1\', \'test2\')\n   "repr() shows quotes: \'test1\'; str() doesn\'t: test2"\n\nAligning the text and specifying a width:\n\n   >>> \'{:<30}\'.format(\'left aligned\')\n   \'left aligned                  \'\n   >>> \'{:>30}\'.format(\'right aligned\')\n   \'                 right aligned\'\n   >>> \'{:^30}\'.format(\'centered\')\n   \'           centered           \'\n   >>> \'{:*^30}\'.format(\'centered\')  # use \'*\' as a fill char\n   \'***********centered***********\'\n\nReplacing "%+f", "%-f", and "% f" and specifying a sign:\n\n   >>> \'{:+f}; {:+f}\'.format(3.14, -3.14)  # show it always\n   \'+3.140000; -3.140000\'\n   >>> \'{: f}; {: f}\'.format(3.14, -3.14)  # show a space for positive numbers\n   \' 3.140000; -3.140000\'\n   >>> \'{:-f}; {:-f}\'.format(3.14, -3.14)  # show only the minus -- same as \'{:f}; {:f}\'\n   \'3.140000; -3.140000\'\n\nReplacing "%x" and "%o" and converting the value to different bases:\n\n   >>> # format also supports binary numbers\n   >>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)\n   \'int: 42;  hex: 2a;  oct: 52;  bin: 101010\'\n   >>> # with 0x, 0o, or 0b as prefix:\n   >>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)\n   \'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010\'\n\nUsing the comma as a thousands separator:\n\n   >>> \'{:,}\'.format(1234567890)\n   \'1,234,567,890\'\n\nExpressing a percentage:\n\n   >>> points = 19.5\n   >>> total = 22\n   >>> \'Correct answers: {:.2%}\'.format(points/total)\n   \'Correct answers: 88.64%\'\n\nUsing type-specific formatting:\n\n   >>> import datetime\n   >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)\n   >>> \'{:%Y-%m-%d %H:%M:%S}\'.format(d)\n   \'2010-07-04 12:15:58\'\n\nNesting arguments and more complex examples:\n\n   >>> for align, text in zip(\'<^>\', [\'left\', \'center\', \'right\']):\n   ...     \'{0:{fill}{align}16}\'.format(text, fill=align, align=align)\n   ...\n   \'left<<<<<<<<<<<<\'\n   \'^^^^^center^^^^^\'\n   \'>>>>>>>>>>>right\'\n   >>>\n   >>> octets = [192, 168, 0, 1]\n   >>> \'{:02X}{:02X}{:02X}{:02X}\'.format(*octets)\n   \'C0A80001\'\n   >>> int(_, 16)\n   3232235521\n   >>>\n   >>> width = 5\n   >>> for num in range(5,12):\n   ...     for base in \'dXob\':\n   ...         print \'{0:{width}{base}}\'.format(num, base=base, width=width),\n   ...     print\n   ...\n       5     5     5   101\n       6     6     6   110\n       7     7     7   111\n       8     8    10  1000\n       9     9    11  1001\n      10     A    12  1010\n      11     B    13  1011\n',
 'function': u'\nFunction definitions\n********************\n\nA function definition defines a user-defined function object (see\nsection *The standard type hierarchy*):\n\n   decorated      ::= decorators (classdef | funcdef)\n   decorators     ::= decorator+\n   decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE\n   funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite\n   dotted_name    ::= identifier ("." identifier)*\n   parameter_list ::= (defparameter ",")*\n                      (  "*" identifier ["," "**" identifier]\n                      | "**" identifier\n                      | defparameter [","] )\n   defparameter   ::= parameter ["=" expression]\n   sublist        ::= parameter ("," parameter)* [","]\n   parameter      ::= identifier | "(" sublist ")"\n   funcname       ::= identifier\n\nA function definition is an executable statement.  Its execution binds\nthe function name in the current local namespace to a function object\n(a wrapper around the executable code for the function).  This\nfunction object contains a reference to the current global namespace\nas the global namespace to be used when the function is called.\n\nThe function definition does not execute the function body; this gets\nexecuted only when the function is called. [3]\n\nA function definition may be wrapped by one or more *decorator*\nexpressions. Decorator expressions are evaluated when the function is\ndefined, in the scope that contains the function definition.  The\nresult must be a callable, which is invoked with the function object\nas the only argument. The returned value is bound to the function name\ninstead of the function object.  Multiple decorators are applied in\nnested fashion. For example, the following code:\n\n   @f1(arg)\n   @f2\n   def func(): pass\n\nis equivalent to:\n\n   def func(): pass\n   func = f1(arg)(f2(func))\n\nWhen one or more top-level *parameters* have the form *parameter* "="\n*expression*, the function is said to have "default parameter values."\nFor a parameter with a default value, the corresponding *argument* may\nbe omitted from a call, in which case the parameter\'s default value is\nsubstituted.  If a parameter has a default value, all following\nparameters must also have a default value --- this is a syntactic\nrestriction that is not expressed by the grammar.\n\n**Default parameter values are evaluated when the function definition\nis executed.**  This means that the expression is evaluated once, when\nthe function is defined, and that the same "pre-computed" value is\nused for each call.  This is especially important to understand when a\ndefault parameter is a mutable object, such as a list or a dictionary:\nif the function modifies the object (e.g. by appending an item to a\nlist), the default value is in effect modified. This is generally not\nwhat was intended.  A way around this  is to use "None" as the\ndefault, and explicitly test for it in the body of the function, e.g.:\n\n   def whats_on_the_telly(penguin=None):\n       if penguin is None:\n           penguin = []\n       penguin.append("property of the zoo")\n       return penguin\n\nFunction call semantics are described in more detail in section\n*Calls*. A function call always assigns values to all parameters\nmentioned in the parameter list, either from position arguments, from\nkeyword arguments, or from default values.  If the form\n""*identifier"" is present, it is initialized to a tuple receiving any\nexcess positional parameters, defaulting to the empty tuple.  If the\nform ""**identifier"" is present, it is initialized to a new\ndictionary receiving any excess keyword arguments, defaulting to a new\nempty dictionary.\n\nIt is also possible to create anonymous functions (functions not bound\nto a name), for immediate use in expressions.  This uses lambda\nexpressions, described in section *Lambdas*.  Note that the lambda\nexpression is merely a shorthand for a simplified function definition;\na function defined in a ""def"" statement can be passed around or\nassigned to another name just like a function defined by a lambda\nexpression.  The ""def"" form is actually more powerful since it\nallows the execution of multiple statements.\n\n**Programmer\'s note:** Functions are first-class objects.  A ""def""\nform executed inside a function definition defines a local function\nthat can be returned or passed around.  Free variables used in the\nnested function can access the local variables of the function\ncontaining the def.  See section *Naming and binding* for details.\n',
 'global': u'\nThe "global" statement\n**********************\n\n   global_stmt ::= "global" identifier ("," identifier)*\n\nThe "global" statement is a declaration which holds for the entire\ncurrent code block.  It means that the listed identifiers are to be\ninterpreted as globals.  It would be impossible to assign to a global\nvariable without "global", although free variables may refer to\nglobals without being declared global.\n\nNames listed in a "global" statement must not be used in the same code\nblock textually preceding that "global" statement.\n\nNames listed in a "global" statement must not be defined as formal\nparameters or in a "for" loop control target, "class" definition,\nfunction definition, or "import" statement.\n\n**CPython implementation detail:** The current implementation does not\nenforce the latter two restrictions, but programs should not abuse\nthis freedom, as future implementations may enforce them or silently\nchange the meaning of the program.\n\n**Programmer\'s note:** the "global" is a directive to the parser.  It\napplies only to code parsed at the same time as the "global"\nstatement. In particular, a "global" statement contained in an "exec"\nstatement does not affect the code block *containing* the "exec"\nstatement, and code contained in an "exec" statement is unaffected by\n"global" statements in the code containing the "exec" statement.  The\nsame applies to the "eval()", "execfile()" and "compile()" functions.\n',
 'id-classes': u'\nReserved classes of identifiers\n*******************************\n\nCertain classes of identifiers (besides keywords) have special\nmeanings.  These classes are identified by the patterns of leading and\ntrailing underscore characters:\n\n"_*"\n   Not imported by "from module import *".  The special identifier "_"\n   is used in the interactive interpreter to store the result of the\n   last evaluation; it is stored in the "__builtin__" module.  When\n   not in interactive mode, "_" has no special meaning and is not\n   defined. See section *The import statement*.\n\n   Note: The name "_" is often used in conjunction with\n     internationalization; refer to the documentation for the\n     "gettext" module for more information on this convention.\n\n"__*__"\n   System-defined names. These names are defined by the interpreter\n   and its implementation (including the standard library).  Current\n   system names are discussed in the *Special method names* section\n   and elsewhere.  More will likely be defined in future versions of\n   Python.  *Any* use of "__*__" names, in any context, that does not\n   follow explicitly documented use, is subject to breakage without\n   warning.\n\n"__*"\n   Class-private names.  Names in this category, when used within the\n   context of a class definition, are re-written to use a mangled form\n   to help avoid name clashes between "private" attributes of base and\n   derived classes. See section *Identifiers (Names)*.\n',
 'identifiers': u'\nIdentifiers and keywords\n************************\n\nIdentifiers (also referred to as *names*) are described by the\nfollowing lexical definitions:\n\n   identifier ::= (letter|"_") (letter | digit | "_")*\n   letter     ::= lowercase | uppercase\n   lowercase  ::= "a"..."z"\n   uppercase  ::= "A"..."Z"\n   digit      ::= "0"..."9"\n\nIdentifiers are unlimited in length.  Case is significant.\n\n\nKeywords\n========\n\nThe following identifiers are used as reserved words, or *keywords* of\nthe language, and cannot be used as ordinary identifiers.  They must\nbe spelled exactly as written here:\n\n   and       del       from      not       while\n   as        elif      global    or        with\n   assert    else      if        pass      yield\n   break     except    import    print\n   class     exec      in        raise\n   continue  finally   is        return\n   def       for       lambda    try\n\nChanged in version 2.4: "None" became a constant and is now recognized\nby the compiler as a name for the built-in object "None".  Although it\nis not a keyword, you cannot assign a different object to it.\n\nChanged in version 2.5: Using "as" and "with" as identifiers triggers\na warning.  To use them as keywords, enable the "with_statement"\nfuture feature .\n\nChanged in version 2.6: "as" and "with" are full keywords.\n\n\nReserved classes of identifiers\n===============================\n\nCertain classes of identifiers (besides keywords) have special\nmeanings.  These classes are identified by the patterns of leading and\ntrailing underscore characters:\n\n"_*"\n   Not imported by "from module import *".  The special identifier "_"\n   is used in the interactive interpreter to store the result of the\n   last evaluation; it is stored in the "__builtin__" module.  When\n   not in interactive mode, "_" has no special meaning and is not\n   defined. See section *The import statement*.\n\n   Note: The name "_" is often used in conjunction with\n     internationalization; refer to the documentation for the\n     "gettext" module for more information on this convention.\n\n"__*__"\n   System-defined names. These names are defined by the interpreter\n   and its implementation (including the standard library).  Current\n   system names are discussed in the *Special method names* section\n   and elsewhere.  More will likely be defined in future versions of\n   Python.  *Any* use of "__*__" names, in any context, that does not\n   follow explicitly documented use, is subject to breakage without\n   warning.\n\n"__*"\n   Class-private names.  Names in this category, when used within the\n   context of a class definition, are re-written to use a mangled form\n   to help avoid name clashes between "private" attributes of base and\n   derived classes. See section *Identifiers (Names)*.\n',
 'if': u'\nThe "if" statement\n******************\n\nThe "if" statement is used for conditional execution:\n\n   if_stmt ::= "if" expression ":" suite\n               ( "elif" expression ":" suite )*\n               ["else" ":" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section *Boolean operations*\nfor the definition of true and false); then that suite is executed\n(and no other part of the "if" statement is executed or evaluated).\nIf all expressions are false, the suite of the "else" clause, if\npresent, is executed.\n',
 'imaginary': u'\nImaginary literals\n******************\n\nImaginary literals are described by the following lexical definitions:\n\n   imagnumber ::= (floatnumber | intpart) ("j" | "J")\n\nAn imaginary literal yields a complex number with a real part of 0.0.\nComplex numbers are represented as a pair of floating point numbers\nand have the same restrictions on their range.  To create a complex\nnumber with a nonzero real part, add a floating point number to it,\ne.g., "(3+4j)".  Some examples of imaginary literals:\n\n   3.14j   10.j    10j     .001j   1e100j  3.14e-10j\n',
 'import': u'\nThe "import" statement\n**********************\n\n   import_stmt     ::= "import" module ["as" name] ( "," module ["as" name] )*\n                   | "from" relative_module "import" identifier ["as" name]\n                   ( "," identifier ["as" name] )*\n                   | "from" relative_module "import" "(" identifier ["as" name]\n                   ( "," identifier ["as" name] )* [","] ")"\n                   | "from" module "import" "*"\n   module          ::= (identifier ".")* identifier\n   relative_module ::= "."* module | "."+\n   name            ::= identifier\n\nImport statements are executed in two steps: (1) find a module, and\ninitialize it if necessary; (2) define a name or names in the local\nnamespace (of the scope where the "import" statement occurs). The\nstatement comes in two forms differing on whether it uses the "from"\nkeyword. The first form (without "from") repeats these steps for each\nidentifier in the list. The form with "from" performs step (1) once,\nand then performs step (2) repeatedly.\n\nTo understand how step (1) occurs, one must first understand how\nPython handles hierarchical naming of modules. To help organize\nmodules and provide a hierarchy in naming, Python has a concept of\npackages. A package can contain other packages and modules while\nmodules cannot contain other modules or packages. From a file system\nperspective, packages are directories and modules are files.\n\nOnce the name of the module is known (unless otherwise specified, the\nterm "module" will refer to both packages and modules), searching for\nthe module or package can begin. The first place checked is\n"sys.modules", the cache of all modules that have been imported\npreviously. If the module is found there then it is used in step (2)\nof import.\n\nIf the module is not found in the cache, then "sys.meta_path" is\nsearched (the specification for "sys.meta_path" can be found in **PEP\n302**). The object is a list of *finder* objects which are queried in\norder as to whether they know how to load the module by calling their\n"find_module()" method with the name of the module. If the module\nhappens to be contained within a package (as denoted by the existence\nof a dot in the name), then a second argument to "find_module()" is\ngiven as the value of the "__path__" attribute from the parent package\n(everything up to the last dot in the name of the module being\nimported). If a finder can find the module it returns a *loader*\n(discussed later) or returns "None".\n\nIf none of the finders on "sys.meta_path" are able to find the module\nthen some implicitly defined finders are queried. Implementations of\nPython vary in what implicit meta path finders are defined. The one\nthey all do define, though, is one that handles "sys.path_hooks",\n"sys.path_importer_cache", and "sys.path".\n\nThe implicit finder searches for the requested module in the "paths"\nspecified in one of two places ("paths" do not have to be file system\npaths). If the module being imported is supposed to be contained\nwithin a package then the second argument passed to "find_module()",\n"__path__" on the parent package, is used as the source of paths. If\nthe module is not contained in a package then "sys.path" is used as\nthe source of paths.\n\nOnce the source of paths is chosen it is iterated over to find a\nfinder that can handle that path. The dict at\n"sys.path_importer_cache" caches finders for paths and is checked for\na finder. If the path does not have a finder cached then\n"sys.path_hooks" is searched by calling each object in the list with a\nsingle argument of the path, returning a finder or raises\n"ImportError". If a finder is returned then it is cached in\n"sys.path_importer_cache" and then used for that path entry. If no\nfinder can be found but the path exists then a value of "None" is\nstored in "sys.path_importer_cache" to signify that an implicit, file-\nbased finder that handles modules stored as individual files should be\nused for that path. If the path does not exist then a finder which\nalways returns "None" is placed in the cache for the path.\n\nIf no finder can find the module then "ImportError" is raised.\nOtherwise some finder returned a loader whose "load_module()" method\nis called with the name of the module to load (see **PEP 302** for the\noriginal definition of loaders). A loader has several responsibilities\nto perform on a module it loads. First, if the module already exists\nin "sys.modules" (a possibility if the loader is called outside of the\nimport machinery) then it is to use that module for initialization and\nnot a new module. But if the module does not exist in "sys.modules"\nthen it is to be added to that dict before initialization begins. If\nan error occurs during loading of the module and it was added to\n"sys.modules" it is to be removed from the dict. If an error occurs\nbut the module was already in "sys.modules" it is left in the dict.\n\nThe loader must set several attributes on the module. "__name__" is to\nbe set to the name of the module. "__file__" is to be the "path" to\nthe file unless the module is built-in (and thus listed in\n"sys.builtin_module_names") in which case the attribute is not set. If\nwhat is being imported is a package then "__path__" is to be set to a\nlist of paths to be searched when looking for modules and packages\ncontained within the package being imported. "__package__" is optional\nbut should be set to the name of package that contains the module or\npackage (the empty string is used for module not contained in a\npackage). "__loader__" is also optional but should be set to the\nloader object that is loading the module.\n\nIf an error occurs during loading then the loader raises "ImportError"\nif some other exception is not already being propagated. Otherwise the\nloader returns the module that was loaded and initialized.\n\nWhen step (1) finishes without raising an exception, step (2) can\nbegin.\n\nThe first form of "import" statement binds the module name in the\nlocal namespace to the module object, and then goes on to import the\nnext identifier, if any.  If the module name is followed by "as", the\nname following "as" is used as the local name for the module.\n\nThe "from" form does not bind the module name: it goes through the\nlist of identifiers, looks each one of them up in the module found in\nstep (1), and binds the name in the local namespace to the object thus\nfound.  As with the first form of "import", an alternate local name\ncan be supplied by specifying ""as" localname".  If a name is not\nfound, "ImportError" is raised.  If the list of identifiers is\nreplaced by a star ("\'*\'"), all public names defined in the module are\nbound in the local namespace of the "import" statement..\n\nThe *public names* defined by a module are determined by checking the\nmodule\'s namespace for a variable named "__all__"; if defined, it must\nbe a sequence of strings which are names defined or imported by that\nmodule.  The names given in "__all__" are all considered public and\nare required to exist.  If "__all__" is not defined, the set of public\nnames includes all names found in the module\'s namespace which do not\nbegin with an underscore character ("\'_\'"). "__all__" should contain\nthe entire public API. It is intended to avoid accidentally exporting\nitems that are not part of the API (such as library modules which were\nimported and used within the module).\n\nThe "from" form with "*" may only occur in a module scope.  If the\nwild card form of import --- "import *" --- is used in a function and\nthe function contains or is a nested block with free variables, the\ncompiler will raise a "SyntaxError".\n\nWhen specifying what module to import you do not have to specify the\nabsolute name of the module. When a module or package is contained\nwithin another package it is possible to make a relative import within\nthe same top package without having to mention the package name. By\nusing leading dots in the specified module or package after "from" you\ncan specify how high to traverse up the current package hierarchy\nwithout specifying exact names. One leading dot means the current\npackage where the module making the import exists. Two dots means up\none package level. Three dots is up two levels, etc. So if you execute\n"from . import mod" from a module in the "pkg" package then you will\nend up importing "pkg.mod". If you execute "from ..subpkg2 import mod"\nfrom within "pkg.subpkg1" you will import "pkg.subpkg2.mod". The\nspecification for relative imports is contained within **PEP 328**.\n\n"importlib.import_module()" is provided to support applications that\ndetermine which modules need to be loaded dynamically.\n\n\nFuture statements\n=================\n\nA *future statement* is a directive to the compiler that a particular\nmodule should be compiled using syntax or semantics that will be\navailable in a specified future release of Python.  The future\nstatement is intended to ease migration to future versions of Python\nthat introduce incompatible changes to the language.  It allows use of\nthe new features on a per-module basis before the release in which the\nfeature becomes standard.\n\n   future_statement ::= "from" "__future__" "import" feature ["as" name]\n                        ("," feature ["as" name])*\n                        | "from" "__future__" "import" "(" feature ["as" name]\n                        ("," feature ["as" name])* [","] ")"\n   feature          ::= identifier\n   name             ::= identifier\n\nA future statement must appear near the top of the module.  The only\nlines that can appear before a future statement are:\n\n* the module docstring (if any),\n\n* comments,\n\n* blank lines, and\n\n* other future statements.\n\nThe features recognized by Python 2.6 are "unicode_literals",\n"print_function", "absolute_import", "division", "generators",\n"nested_scopes" and "with_statement".  "generators", "with_statement",\n"nested_scopes" are redundant in Python version 2.6 and above because\nthey are always enabled.\n\nA future statement is recognized and treated specially at compile\ntime: Changes to the semantics of core constructs are often\nimplemented by generating different code.  It may even be the case\nthat a new feature introduces new incompatible syntax (such as a new\nreserved word), in which case the compiler may need to parse the\nmodule differently.  Such decisions cannot be pushed off until\nruntime.\n\nFor any given release, the compiler knows which feature names have\nbeen defined, and raises a compile-time error if a future statement\ncontains a feature not known to it.\n\nThe direct runtime semantics are the same as for any import statement:\nthere is a standard module "__future__", described later, and it will\nbe imported in the usual way at the time the future statement is\nexecuted.\n\nThe interesting runtime semantics depend on the specific feature\nenabled by the future statement.\n\nNote that there is nothing special about the statement:\n\n   import __future__ [as name]\n\nThat is not a future statement; it\'s an ordinary import statement with\nno special semantics or syntax restrictions.\n\nCode compiled by an "exec" statement or calls to the built-in\nfunctions "compile()" and "execfile()" that occur in a module "M"\ncontaining a future statement will, by default, use the new  syntax or\nsemantics associated with the future statement.  This can, starting\nwith Python 2.2 be controlled by optional arguments to "compile()" ---\nsee the documentation of that function for details.\n\nA future statement typed at an interactive interpreter prompt will\ntake effect for the rest of the interpreter session.  If an\ninterpreter is started with the *-i* option, is passed a script name\nto execute, and the script includes a future statement, it will be in\neffect in the interactive session started after the script is\nexecuted.\n\nSee also: **PEP 236** - Back to the __future__\n\n     The original proposal for the __future__ mechanism.\n',
 'in': u'\nComparisons\n***********\n\nUnlike C, all comparison operations in Python have the same priority,\nwhich is lower than that of any arithmetic, shifting or bitwise\noperation.  Also unlike C, expressions like "a < b < c" have the\ninterpretation that is conventional in mathematics:\n\n   comparison    ::= or_expr ( comp_operator or_expr )*\n   comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="\n                     | "is" ["not"] | ["not"] "in"\n\nComparisons yield boolean values: "True" or "False".\n\nComparisons can be chained arbitrarily, e.g., "x < y <= z" is\nequivalent to "x < y and y <= z", except that "y" is evaluated only\nonce (but in both cases "z" is not evaluated at all when "x < y" is\nfound to be false).\n\nFormally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*,\n*op2*, ..., *opN* are comparison operators, then "a op1 b op2 c ... y\nopN z" is equivalent to "a op1 b and b op2 c and ... y opN z", except\nthat each expression is evaluated at most once.\n\nNote that "a op1 b op2 c" doesn\'t imply any kind of comparison between\n*a* and *c*, so that, e.g., "x < y > z" is perfectly legal (though\nperhaps not pretty).\n\nThe forms "<>" and "!=" are equivalent; for consistency with C, "!="\nis preferred; where "!=" is mentioned below "<>" is also accepted.\nThe "<>" spelling is considered obsolescent.\n\nThe operators "<", ">", "==", ">=", "<=", and "!=" compare the values\nof two objects.  The objects need not have the same type. If both are\nnumbers, they are converted to a common type.  Otherwise, objects of\ndifferent types *always* compare unequal, and are ordered consistently\nbut arbitrarily. You can control comparison behavior of objects of\nnon-built-in types by defining a "__cmp__" method or rich comparison\nmethods like "__gt__", described in section *Special method names*.\n\n(This unusual definition of comparison was used to simplify the\ndefinition of operations like sorting and the "in" and "not in"\noperators. In the future, the comparison rules for objects of\ndifferent types are likely to change.)\n\nComparison of objects of the same type depends on the type:\n\n* Numbers are compared arithmetically.\n\n* Strings are compared lexicographically using the numeric\n  equivalents (the result of the built-in function "ord()") of their\n  characters. Unicode and 8-bit strings are fully interoperable in\n  this behavior. [4]\n\n* Tuples and lists are compared lexicographically using comparison\n  of corresponding elements.  This means that to compare equal, each\n  element must compare equal and the two sequences must be of the same\n  type and have the same length.\n\n  If not equal, the sequences are ordered the same as their first\n  differing elements.  For example, "cmp([1,2,x], [1,2,y])" returns\n  the same as "cmp(x,y)".  If the corresponding element does not\n  exist, the shorter sequence is ordered first (for example, "[1,2] <\n  [1,2,3]").\n\n* Mappings (dictionaries) compare equal if and only if their sorted\n  (key, value) lists compare equal. [5] Outcomes other than equality\n  are resolved consistently, but are not otherwise defined. [6]\n\n* Most other objects of built-in types compare unequal unless they\n  are the same object; the choice whether one object is considered\n  smaller or larger than another one is made arbitrarily but\n  consistently within one execution of a program.\n\nThe operators "in" and "not in" test for collection membership.  "x in\ns" evaluates to true if *x* is a member of the collection *s*, and\nfalse otherwise.  "x not in s" returns the negation of "x in s". The\ncollection membership test has traditionally been bound to sequences;\nan object is a member of a collection if the collection is a sequence\nand contains an element equal to that object.  However, it make sense\nfor many other object types to support membership tests without being\na sequence.  In particular, dictionaries (for keys) and sets support\nmembership testing.\n\nFor the list and tuple types, "x in y" is true if and only if there\nexists an index *i* such that "x == y[i]" is true.\n\nFor the Unicode and string types, "x in y" is true if and only if *x*\nis a substring of *y*.  An equivalent test is "y.find(x) != -1".\nNote, *x* and *y* need not be the same type; consequently, "u\'ab\' in\n\'abc\'" will return "True". Empty strings are always considered to be a\nsubstring of any other string, so """ in "abc"" will return "True".\n\nChanged in version 2.3: Previously, *x* was required to be a string of\nlength "1".\n\nFor user-defined classes which define the "__contains__()" method, "x\nin y" is true if and only if "y.__contains__(x)" is true.\n\nFor user-defined classes which do not define "__contains__()" but do\ndefine "__iter__()", "x in y" is true if some value "z" with "x == z"\nis produced while iterating over "y".  If an exception is raised\nduring the iteration, it is as if "in" raised that exception.\n\nLastly, the old-style iteration protocol is tried: if a class defines\n"__getitem__()", "x in y" is true if and only if there is a non-\nnegative integer index *i* such that "x == y[i]", and all lower\ninteger indices do not raise "IndexError" exception. (If any other\nexception is raised, it is as if "in" raised that exception).\n\nThe operator "not in" is defined to have the inverse true value of\n"in".\n\nThe operators "is" and "is not" test for object identity: "x is y" is\ntrue if and only if *x* and *y* are the same object.  "x is not y"\nyields the inverse truth value. [7]\n',
 'integers': u'\nInteger and long integer literals\n*********************************\n\nInteger and long integer literals are described by the following\nlexical definitions:\n\n   longinteger    ::= integer ("l" | "L")\n   integer        ::= decimalinteger | octinteger | hexinteger | bininteger\n   decimalinteger ::= nonzerodigit digit* | "0"\n   octinteger     ::= "0" ("o" | "O") octdigit+ | "0" octdigit+\n   hexinteger     ::= "0" ("x" | "X") hexdigit+\n   bininteger     ::= "0" ("b" | "B") bindigit+\n   nonzerodigit   ::= "1"..."9"\n   octdigit       ::= "0"..."7"\n   bindigit       ::= "0" | "1"\n   hexdigit       ::= digit | "a"..."f" | "A"..."F"\n\nAlthough both lower case "\'l\'" and upper case "\'L\'" are allowed as\nsuffix for long integers, it is strongly recommended to always use\n"\'L\'", since the letter "\'l\'" looks too much like the digit "\'1\'".\n\nPlain integer literals that are above the largest representable plain\ninteger (e.g., 2147483647 when using 32-bit arithmetic) are accepted\nas if they were long integers instead. [1]  There is no limit for long\ninteger literals apart from what can be stored in available memory.\n\nSome examples of plain integer literals (first row) and long integer\nliterals (second and third rows):\n\n   7     2147483647                        0177\n   3L    79228162514264337593543950336L    0377L   0x100000000L\n         79228162514264337593543950336             0xdeadbeef\n',
 'lambda': u'\nLambdas\n*******\n\n   lambda_expr     ::= "lambda" [parameter_list]: expression\n   old_lambda_expr ::= "lambda" [parameter_list]: old_expression\n\nLambda expressions (sometimes called lambda forms) have the same\nsyntactic position as expressions.  They are a shorthand to create\nanonymous functions; the expression "lambda arguments: expression"\nyields a function object.  The unnamed object behaves like a function\nobject defined with\n\n   def name(arguments):\n       return expression\n\nSee section *Function definitions* for the syntax of parameter lists.\nNote that functions created with lambda expressions cannot contain\nstatements.\n',
 'lists': u'\nList displays\n*************\n\nA list display is a possibly empty series of expressions enclosed in\nsquare brackets:\n\n   list_display        ::= "[" [expression_list | list_comprehension] "]"\n   list_comprehension  ::= expression list_for\n   list_for            ::= "for" target_list "in" old_expression_list [list_iter]\n   old_expression_list ::= old_expression [("," old_expression)+ [","]]\n   old_expression      ::= or_test | old_lambda_expr\n   list_iter           ::= list_for | list_if\n   list_if             ::= "if" old_expression [list_iter]\n\nA list display yields a new list object.  Its contents are specified\nby providing either a list of expressions or a list comprehension.\nWhen a comma-separated list of expressions is supplied, its elements\nare evaluated from left to right and placed into the list object in\nthat order.  When a list comprehension is supplied, it consists of a\nsingle expression followed by at least one "for" clause and zero or\nmore "for" or "if" clauses.  In this case, the elements of the new\nlist are those that would be produced by considering each of the "for"\nor "if" clauses a block, nesting from left to right, and evaluating\nthe expression to produce a list element each time the innermost block\nis reached [1].\n',
 'naming': u'\nNaming and binding\n******************\n\n*Names* refer to objects.  Names are introduced by name binding\noperations. Each occurrence of a name in the program text refers to\nthe *binding* of that name established in the innermost function block\ncontaining the use.\n\nA *block* is a piece of Python program text that is executed as a\nunit. The following are blocks: a module, a function body, and a class\ndefinition. Each command typed interactively is a block.  A script\nfile (a file given as standard input to the interpreter or specified\non the interpreter command line the first argument) is a code block.\nA script command (a command specified on the interpreter command line\nwith the \'**-c**\' option) is a code block.  The file read by the\nbuilt-in function "execfile()" is a code block.  The string argument\npassed to the built-in function "eval()" and to the "exec" statement\nis a code block. The expression read and evaluated by the built-in\nfunction "input()" is a code block.\n\nA code block is executed in an *execution frame*.  A frame contains\nsome administrative information (used for debugging) and determines\nwhere and how execution continues after the code block\'s execution has\ncompleted.\n\nA *scope* defines the visibility of a name within a block.  If a local\nvariable is defined in a block, its scope includes that block.  If the\ndefinition occurs in a function block, the scope extends to any blocks\ncontained within the defining one, unless a contained block introduces\na different binding for the name.  The scope of names defined in a\nclass block is limited to the class block; it does not extend to the\ncode blocks of methods -- this includes generator expressions since\nthey are implemented using a function scope.  This means that the\nfollowing will fail:\n\n   class A:\n       a = 42\n       b = list(a + i for i in range(10))\n\nWhen a name is used in a code block, it is resolved using the nearest\nenclosing scope.  The set of all such scopes visible to a code block\nis called the block\'s *environment*.\n\nIf a name is bound in a block, it is a local variable of that block.\nIf a name is bound at the module level, it is a global variable.  (The\nvariables of the module code block are local and global.)  If a\nvariable is used in a code block but not defined there, it is a *free\nvariable*.\n\nWhen a name is not found at all, a "NameError" exception is raised.\nIf the name refers to a local variable that has not been bound, a\n"UnboundLocalError" exception is raised.  "UnboundLocalError" is a\nsubclass of "NameError".\n\nThe following constructs bind names: formal parameters to functions,\n"import" statements, class and function definitions (these bind the\nclass or function name in the defining block), and targets that are\nidentifiers if occurring in an assignment, "for" loop header, in the\nsecond position of an "except" clause header or after "as" in a "with"\nstatement.  The "import" statement of the form "from ... import *"\nbinds all names defined in the imported module, except those beginning\nwith an underscore.  This form may only be used at the module level.\n\nA target occurring in a "del" statement is also considered bound for\nthis purpose (though the actual semantics are to unbind the name).  It\nis illegal to unbind a name that is referenced by an enclosing scope;\nthe compiler will report a "SyntaxError".\n\nEach assignment or import statement occurs within a block defined by a\nclass or function definition or at the module level (the top-level\ncode block).\n\nIf a name binding operation occurs anywhere within a code block, all\nuses of the name within the block are treated as references to the\ncurrent block.  This can lead to errors when a name is used within a\nblock before it is bound. This rule is subtle.  Python lacks\ndeclarations and allows name binding operations to occur anywhere\nwithin a code block.  The local variables of a code block can be\ndetermined by scanning the entire text of the block for name binding\noperations.\n\nIf the global statement occurs within a block, all uses of the name\nspecified in the statement refer to the binding of that name in the\ntop-level namespace. Names are resolved in the top-level namespace by\nsearching the global namespace, i.e. the namespace of the module\ncontaining the code block, and the builtins namespace, the namespace\nof the module "__builtin__".  The global namespace is searched first.\nIf the name is not found there, the builtins namespace is searched.\nThe global statement must precede all uses of the name.\n\nThe builtins namespace associated with the execution of a code block\nis actually found by looking up the name "__builtins__" in its global\nnamespace; this should be a dictionary or a module (in the latter case\nthe module\'s dictionary is used).  By default, when in the "__main__"\nmodule, "__builtins__" is the built-in module "__builtin__" (note: no\n\'s\'); when in any other module, "__builtins__" is an alias for the\ndictionary of the "__builtin__" module itself.  "__builtins__" can be\nset to a user-created dictionary to create a weak form of restricted\nexecution.\n\n**CPython implementation detail:** Users should not touch\n"__builtins__"; it is strictly an implementation detail.  Users\nwanting to override values in the builtins namespace should "import"\nthe "__builtin__" (no \'s\') module and modify its attributes\nappropriately.\n\nThe namespace for a module is automatically created the first time a\nmodule is imported.  The main module for a script is always called\n"__main__".\n\nThe "global" statement has the same scope as a name binding operation\nin the same block.  If the nearest enclosing scope for a free variable\ncontains a global statement, the free variable is treated as a global.\n\nA class definition is an executable statement that may use and define\nnames. These references follow the normal rules for name resolution.\nThe namespace of the class definition becomes the attribute dictionary\nof the class.  Names defined at the class scope are not visible in\nmethods.\n\n\nInteraction with dynamic features\n=================================\n\nThere are several cases where Python statements are illegal when used\nin conjunction with nested scopes that contain free variables.\n\nIf a variable is referenced in an enclosing scope, it is illegal to\ndelete the name.  An error will be reported at compile time.\n\nIf the wild card form of import --- "import *" --- is used in a\nfunction and the function contains or is a nested block with free\nvariables, the compiler will raise a "SyntaxError".\n\nIf "exec" is used in a function and the function contains or is a\nnested block with free variables, the compiler will raise a\n"SyntaxError" unless the exec explicitly specifies the local namespace\nfor the "exec".  (In other words, "exec obj" would be illegal, but\n"exec obj in ns" would be legal.)\n\nThe "eval()", "execfile()", and "input()" functions and the "exec"\nstatement do not have access to the full environment for resolving\nnames.  Names may be resolved in the local and global namespaces of\nthe caller.  Free variables are not resolved in the nearest enclosing\nnamespace, but in the global namespace. [1] The "exec" statement and\nthe "eval()" and "execfile()" functions have optional arguments to\noverride the global and local namespace.  If only one namespace is\nspecified, it is used for both.\n',
 'numbers': u'\nNumeric literals\n****************\n\nThere are four types of numeric literals: plain integers, long\nintegers, floating point numbers, and imaginary numbers.  There are no\ncomplex literals (complex numbers can be formed by adding a real\nnumber and an imaginary number).\n\nNote that numeric literals do not include a sign; a phrase like "-1"\nis actually an expression composed of the unary operator \'"-"\' and the\nliteral "1".\n',
 'numeric-types': u'\nEmulating numeric types\n***********************\n\nThe following methods can be defined to emulate numeric objects.\nMethods corresponding to operations that are not supported by the\nparticular kind of number implemented (e.g., bitwise operations for\nnon-integral numbers) should be left undefined.\n\nobject.__add__(self, other)\nobject.__sub__(self, other)\nobject.__mul__(self, other)\nobject.__floordiv__(self, other)\nobject.__mod__(self, other)\nobject.__divmod__(self, other)\nobject.__pow__(self, other[, modulo])\nobject.__lshift__(self, other)\nobject.__rshift__(self, other)\nobject.__and__(self, other)\nobject.__xor__(self, other)\nobject.__or__(self, other)\n\n   These methods are called to implement the binary arithmetic\n   operations ("+", "-", "*", "//", "%", "divmod()", "pow()", "**",\n   "<<", ">>", "&", "^", "|").  For instance, to evaluate the\n   expression "x + y", where *x* is an instance of a class that has an\n   "__add__()" method, "x.__add__(y)" is called.  The "__divmod__()"\n   method should be the equivalent to using "__floordiv__()" and\n   "__mod__()"; it should not be related to "__truediv__()" (described\n   below).  Note that "__pow__()" should be defined to accept an\n   optional third argument if the ternary version of the built-in\n   "pow()" function is to be supported.\n\n   If one of those methods does not support the operation with the\n   supplied arguments, it should return "NotImplemented".\n\nobject.__div__(self, other)\nobject.__truediv__(self, other)\n\n   The division operator ("/") is implemented by these methods.  The\n   "__truediv__()" method is used when "__future__.division" is in\n   effect, otherwise "__div__()" is used.  If only one of these two\n   methods is defined, the object will not support division in the\n   alternate context; "TypeError" will be raised instead.\n\nobject.__radd__(self, other)\nobject.__rsub__(self, other)\nobject.__rmul__(self, other)\nobject.__rdiv__(self, other)\nobject.__rtruediv__(self, other)\nobject.__rfloordiv__(self, other)\nobject.__rmod__(self, other)\nobject.__rdivmod__(self, other)\nobject.__rpow__(self, other)\nobject.__rlshift__(self, other)\nobject.__rrshift__(self, other)\nobject.__rand__(self, other)\nobject.__rxor__(self, other)\nobject.__ror__(self, other)\n\n   These methods are called to implement the binary arithmetic\n   operations ("+", "-", "*", "/", "%", "divmod()", "pow()", "**",\n   "<<", ">>", "&", "^", "|") with reflected (swapped) operands.\n   These functions are only called if the left operand does not\n   support the corresponding operation and the operands are of\n   different types. [2] For instance, to evaluate the expression "x -\n   y", where *y* is an instance of a class that has an "__rsub__()"\n   method, "y.__rsub__(x)" is called if "x.__sub__(y)" returns\n   *NotImplemented*.\n\n   Note that ternary "pow()" will not try calling "__rpow__()" (the\n   coercion rules would become too complicated).\n\n   Note: If the right operand\'s type is a subclass of the left\n     operand\'s type and that subclass provides the reflected method\n     for the operation, this method will be called before the left\n     operand\'s non-reflected method.  This behavior allows subclasses\n     to override their ancestors\' operations.\n\nobject.__iadd__(self, other)\nobject.__isub__(self, other)\nobject.__imul__(self, other)\nobject.__idiv__(self, other)\nobject.__itruediv__(self, other)\nobject.__ifloordiv__(self, other)\nobject.__imod__(self, other)\nobject.__ipow__(self, other[, modulo])\nobject.__ilshift__(self, other)\nobject.__irshift__(self, other)\nobject.__iand__(self, other)\nobject.__ixor__(self, other)\nobject.__ior__(self, other)\n\n   These methods are called to implement the augmented arithmetic\n   assignments ("+=", "-=", "*=", "/=", "//=", "%=", "**=", "<<=",\n   ">>=", "&=", "^=", "|=").  These methods should attempt to do the\n   operation in-place (modifying *self*) and return the result (which\n   could be, but does not have to be, *self*).  If a specific method\n   is not defined, the augmented assignment falls back to the normal\n   methods.  For instance, to execute the statement "x += y", where\n   *x* is an instance of a class that has an "__iadd__()" method,\n   "x.__iadd__(y)" is called.  If *x* is an instance of a class that\n   does not define a "__iadd__()" method, "x.__add__(y)" and\n   "y.__radd__(x)" are considered, as with the evaluation of "x + y".\n\nobject.__neg__(self)\nobject.__pos__(self)\nobject.__abs__(self)\nobject.__invert__(self)\n\n   Called to implement the unary arithmetic operations ("-", "+",\n   "abs()" and "~").\n\nobject.__complex__(self)\nobject.__int__(self)\nobject.__long__(self)\nobject.__float__(self)\n\n   Called to implement the built-in functions "complex()", "int()",\n   "long()", and "float()".  Should return a value of the appropriate\n   type.\n\nobject.__oct__(self)\nobject.__hex__(self)\n\n   Called to implement the built-in functions "oct()" and "hex()".\n   Should return a string value.\n\nobject.__index__(self)\n\n   Called to implement "operator.index()".  Also called whenever\n   Python needs an integer object (such as in slicing).  Must return\n   an integer (int or long).\n\n   New in version 2.5.\n\nobject.__coerce__(self, other)\n\n   Called to implement "mixed-mode" numeric arithmetic.  Should either\n   return a 2-tuple containing *self* and *other* converted to a\n   common numeric type, or "None" if conversion is impossible.  When\n   the common type would be the type of "other", it is sufficient to\n   return "None", since the interpreter will also ask the other object\n   to attempt a coercion (but sometimes, if the implementation of the\n   other type cannot be changed, it is useful to do the conversion to\n   the other type here).  A return value of "NotImplemented" is\n   equivalent to returning "None".\n',
 'objects': u'\nObjects, values and types\n*************************\n\n*Objects* are Python\'s abstraction for data.  All data in a Python\nprogram is represented by objects or by relations between objects. (In\na sense, and in conformance to Von Neumann\'s model of a "stored\nprogram computer," code is also represented by objects.)\n\nEvery object has an identity, a type and a value.  An object\'s\n*identity* never changes once it has been created; you may think of it\nas the object\'s address in memory.  The \'"is"\' operator compares the\nidentity of two objects; the "id()" function returns an integer\nrepresenting its identity (currently implemented as its address). An\nobject\'s *type* is also unchangeable. [1] An object\'s type determines\nthe operations that the object supports (e.g., "does it have a\nlength?") and also defines the possible values for objects of that\ntype.  The "type()" function returns an object\'s type (which is an\nobject itself).  The *value* of some objects can change.  Objects\nwhose value can change are said to be *mutable*; objects whose value\nis unchangeable once they are created are called *immutable*. (The\nvalue of an immutable container object that contains a reference to a\nmutable object can change when the latter\'s value is changed; however\nthe container is still considered immutable, because the collection of\nobjects it contains cannot be changed.  So, immutability is not\nstrictly the same as having an unchangeable value, it is more subtle.)\nAn object\'s mutability is determined by its type; for instance,\nnumbers, strings and tuples are immutable, while dictionaries and\nlists are mutable.\n\nObjects are never explicitly destroyed; however, when they become\nunreachable they may be garbage-collected.  An implementation is\nallowed to postpone garbage collection or omit it altogether --- it is\na matter of implementation quality how garbage collection is\nimplemented, as long as no objects are collected that are still\nreachable.\n\n**CPython implementation detail:** CPython currently uses a reference-\ncounting scheme with (optional) delayed detection of cyclically linked\ngarbage, which collects most objects as soon as they become\nunreachable, but is not guaranteed to collect garbage containing\ncircular references.  See the documentation of the "gc" module for\ninformation on controlling the collection of cyclic garbage. Other\nimplementations act differently and CPython may change. Do not depend\non immediate finalization of objects when they become unreachable (ex:\nalways close files).\n\nNote that the use of the implementation\'s tracing or debugging\nfacilities may keep objects alive that would normally be collectable.\nAlso note that catching an exception with a \'"try"..."except"\'\nstatement may keep objects alive.\n\nSome objects contain references to "external" resources such as open\nfiles or windows.  It is understood that these resources are freed\nwhen the object is garbage-collected, but since garbage collection is\nnot guaranteed to happen, such objects also provide an explicit way to\nrelease the external resource, usually a "close()" method. Programs\nare strongly recommended to explicitly close such objects.  The\n\'"try"..."finally"\' statement provides a convenient way to do this.\n\nSome objects contain references to other objects; these are called\n*containers*. Examples of containers are tuples, lists and\ndictionaries.  The references are part of a container\'s value.  In\nmost cases, when we talk about the value of a container, we imply the\nvalues, not the identities of the contained objects; however, when we\ntalk about the mutability of a container, only the identities of the\nimmediately contained objects are implied.  So, if an immutable\ncontainer (like a tuple) contains a reference to a mutable object, its\nvalue changes if that mutable object is changed.\n\nTypes affect almost all aspects of object behavior.  Even the\nimportance of object identity is affected in some sense: for immutable\ntypes, operations that compute new values may actually return a\nreference to any existing object with the same type and value, while\nfor mutable objects this is not allowed.  E.g., after "a = 1; b = 1",\n"a" and "b" may or may not refer to the same object with the value\none, depending on the implementation, but after "c = []; d = []", "c"\nand "d" are guaranteed to refer to two different, unique, newly\ncreated empty lists. (Note that "c = d = []" assigns the same object\nto both "c" and "d".)\n',
 'operator-summary': u'\nOperator precedence\n*******************\n\nThe following table summarizes the operator precedences in Python,\nfrom lowest precedence (least binding) to highest precedence (most\nbinding). Operators in the same box have the same precedence.  Unless\nthe syntax is explicitly given, operators are binary.  Operators in\nthe same box group left to right (except for comparisons, including\ntests, which all have the same precedence and chain from left to right\n--- see section *Comparisons* --- and exponentiation, which groups\nfrom right to left).\n\n+-------------------------------------------------+---------------------------------------+\n| Operator                                        | Description                           |\n+=================================================+=======================================+\n| "lambda"                                        | Lambda expression                     |\n+-------------------------------------------------+---------------------------------------+\n| "if" -- "else"                                  | Conditional expression                |\n+-------------------------------------------------+---------------------------------------+\n| "or"                                            | Boolean OR                            |\n+-------------------------------------------------+---------------------------------------+\n| "and"                                           | Boolean AND                           |\n+-------------------------------------------------+---------------------------------------+\n| "not" "x"                                       | Boolean NOT                           |\n+-------------------------------------------------+---------------------------------------+\n| "in", "not in", "is", "is not", "<", "<=", ">", | Comparisons, including membership     |\n| ">=", "<>", "!=", "=="                          | tests and identity tests              |\n+-------------------------------------------------+---------------------------------------+\n| "|"                                             | Bitwise OR                            |\n+-------------------------------------------------+---------------------------------------+\n| "^"                                             | Bitwise XOR                           |\n+-------------------------------------------------+---------------------------------------+\n| "&"                                             | Bitwise AND                           |\n+-------------------------------------------------+---------------------------------------+\n| "<<", ">>"                                      | Shifts                                |\n+-------------------------------------------------+---------------------------------------+\n| "+", "-"                                        | Addition and subtraction              |\n+-------------------------------------------------+---------------------------------------+\n| "*", "/", "//", "%"                             | Multiplication, division, remainder   |\n|                                                 | [8]                                   |\n+-------------------------------------------------+---------------------------------------+\n| "+x", "-x", "~x"                                | Positive, negative, bitwise NOT       |\n+-------------------------------------------------+---------------------------------------+\n| "**"                                            | Exponentiation [9]                    |\n+-------------------------------------------------+---------------------------------------+\n| "x[index]", "x[index:index]",                   | Subscription, slicing, call,          |\n| "x(arguments...)", "x.attribute"                | attribute reference                   |\n+-------------------------------------------------+---------------------------------------+\n| "(expressions...)", "[expressions...]", "{key:  | Binding or tuple display, list        |\n| value...}", "`expressions...`"                  | display, dictionary display, string   |\n|                                                 | conversion                            |\n+-------------------------------------------------+---------------------------------------+\n\n-[ Footnotes ]-\n\n[1] In Python 2.3 and later releases, a list comprehension "leaks"\n    the control variables of each "for" it contains into the\n    containing scope.  However, this behavior is deprecated, and\n    relying on it will not work in Python 3.\n\n[2] While "abs(x%y) < abs(y)" is true mathematically, for floats\n    it may not be true numerically due to roundoff.  For example, and\n    assuming a platform on which a Python float is an IEEE 754 double-\n    precision number, in order that "-1e-100 % 1e100" have the same\n    sign as "1e100", the computed result is "-1e-100 + 1e100", which\n    is numerically exactly equal to "1e100".  The function\n    "math.fmod()" returns a result whose sign matches the sign of the\n    first argument instead, and so returns "-1e-100" in this case.\n    Which approach is more appropriate depends on the application.\n\n[3] If x is very close to an exact integer multiple of y, it\'s\n    possible for "floor(x/y)" to be one larger than "(x-x%y)/y" due to\n    rounding.  In such cases, Python returns the latter result, in\n    order to preserve that "divmod(x,y)[0] * y + x % y" be very close\n    to "x".\n\n[4] While comparisons between unicode strings make sense at the\n    byte level, they may be counter-intuitive to users. For example,\n    the strings "u"\\u00C7"" and "u"\\u0043\\u0327"" compare differently,\n    even though they both represent the same unicode character (LATIN\n    CAPITAL LETTER C WITH CEDILLA). To compare strings in a human\n    recognizable way, compare using "unicodedata.normalize()".\n\n[5] The implementation computes this efficiently, without\n    constructing lists or sorting.\n\n[6] Earlier versions of Python used lexicographic comparison of\n    the sorted (key, value) lists, but this was very expensive for the\n    common case of comparing for equality.  An even earlier version of\n    Python compared dictionaries by identity only, but this caused\n    surprises because people expected to be able to test a dictionary\n    for emptiness by comparing it to "{}".\n\n[7] Due to automatic garbage-collection, free lists, and the\n    dynamic nature of descriptors, you may notice seemingly unusual\n    behaviour in certain uses of the "is" operator, like those\n    involving comparisons between instance methods, or constants.\n    Check their documentation for more info.\n\n[8] The "%" operator is also used for string formatting; the same\n    precedence applies.\n\n[9] The power operator "**" binds less tightly than an arithmetic\n    or bitwise unary operator on its right, that is, "2**-1" is "0.5".\n',
 'pass': u'\nThe "pass" statement\n********************\n\n   pass_stmt ::= "pass"\n\n"pass" is a null operation --- when it is executed, nothing happens.\nIt is useful as a placeholder when a statement is required\nsyntactically, but no code needs to be executed, for example:\n\n   def f(arg): pass    # a function that does nothing (yet)\n\n   class C: pass       # a class with no methods (yet)\n',
 'power': u'\nThe power operator\n******************\n\nThe power operator binds more tightly than unary operators on its\nleft; it binds less tightly than unary operators on its right.  The\nsyntax is:\n\n   power ::= primary ["**" u_expr]\n\nThus, in an unparenthesized sequence of power and unary operators, the\noperators are evaluated from right to left (this does not constrain\nthe evaluation order for the operands): "-1**2" results in "-1".\n\nThe power operator has the same semantics as the built-in "pow()"\nfunction, when called with two arguments: it yields its left argument\nraised to the power of its right argument.  The numeric arguments are\nfirst converted to a common type.  The result type is that of the\narguments after coercion.\n\nWith mixed operand types, the coercion rules for binary arithmetic\noperators apply. For int and long int operands, the result has the\nsame type as the operands (after coercion) unless the second argument\nis negative; in that case, all arguments are converted to float and a\nfloat result is delivered. For example, "10**2" returns "100", but\n"10**-2" returns "0.01". (This last feature was added in Python 2.2.\nIn Python 2.1 and before, if both arguments were of integer types and\nthe second argument was negative, an exception was raised).\n\nRaising "0.0" to a negative power results in a "ZeroDivisionError".\nRaising a negative number to a fractional power results in a\n"ValueError".\n',
 'print': u'\nThe "print" statement\n*********************\n\n   print_stmt ::= "print" ([expression ("," expression)* [","]]\n                  | ">>" expression [("," expression)+ [","]])\n\n"print" evaluates each expression in turn and writes the resulting\nobject to standard output (see below).  If an object is not a string,\nit is first converted to a string using the rules for string\nconversions.  The (resulting or original) string is then written.  A\nspace is written before each object is (converted and) written, unless\nthe output system believes it is positioned at the beginning of a\nline.  This is the case (1) when no characters have yet been written\nto standard output, (2) when the last character written to standard\noutput is a whitespace character except "\' \'", or (3) when the last\nwrite operation on standard output was not a "print" statement. (In\nsome cases it may be functional to write an empty string to standard\noutput for this reason.)\n\nNote: Objects which act like file objects but which are not the\n  built-in file objects often do not properly emulate this aspect of\n  the file object\'s behavior, so it is best not to rely on this.\n\nA "\'\\n\'" character is written at the end, unless the "print" statement\nends with a comma.  This is the only action if the statement contains\njust the keyword "print".\n\nStandard output is defined as the file object named "stdout" in the\nbuilt-in module "sys".  If no such object exists, or if it does not\nhave a "write()" method, a "RuntimeError" exception is raised.\n\n"print" also has an extended form, defined by the second portion of\nthe syntax described above. This form is sometimes referred to as\n""print" chevron." In this form, the first expression after the ">>"\nmust evaluate to a "file-like" object, specifically an object that has\na "write()" method as described above.  With this extended form, the\nsubsequent expressions are printed to this file object.  If the first\nexpression evaluates to "None", then "sys.stdout" is used as the file\nfor output.\n',
 'raise': u'\nThe "raise" statement\n*********************\n\n   raise_stmt ::= "raise" [expression ["," expression ["," expression]]]\n\nIf no expressions are present, "raise" re-raises the last exception\nthat was active in the current scope.  If no exception is active in\nthe current scope, a "TypeError" exception is raised indicating that\nthis is an error (if running under IDLE, a "Queue.Empty" exception is\nraised instead).\n\nOtherwise, "raise" evaluates the expressions to get three objects,\nusing "None" as the value of omitted expressions.  The first two\nobjects are used to determine the *type* and *value* of the exception.\n\nIf the first object is an instance, the type of the exception is the\nclass of the instance, the instance itself is the value, and the\nsecond object must be "None".\n\nIf the first object is a class, it becomes the type of the exception.\nThe second object is used to determine the exception value: If it is\nan instance of the class, the instance becomes the exception value. If\nthe second object is a tuple, it is used as the argument list for the\nclass constructor; if it is "None", an empty argument list is used,\nand any other object is treated as a single argument to the\nconstructor.  The instance so created by calling the constructor is\nused as the exception value.\n\nIf a third object is present and not "None", it must be a traceback\nobject (see section *The standard type hierarchy*), and it is\nsubstituted instead of the current location as the place where the\nexception occurred.  If the third object is present and not a\ntraceback object or "None", a "TypeError" exception is raised.  The\nthree-expression form of "raise" is useful to re-raise an exception\ntransparently in an except clause, but "raise" with no expressions\nshould be preferred if the exception to be re-raised was the most\nrecently active exception in the current scope.\n\nAdditional information on exceptions can be found in section\n*Exceptions*, and information about handling exceptions is in section\n*The try statement*.\n',
 'return': u'\nThe "return" statement\n**********************\n\n   return_stmt ::= "return" [expression_list]\n\n"return" may only occur syntactically nested in a function definition,\nnot within a nested class definition.\n\nIf an expression list is present, it is evaluated, else "None" is\nsubstituted.\n\n"return" leaves the current function call with the expression list (or\n"None") as return value.\n\nWhen "return" passes control out of a "try" statement with a "finally"\nclause, that "finally" clause is executed before really leaving the\nfunction.\n\nIn a generator function, the "return" statement is not allowed to\ninclude an "expression_list".  In that context, a bare "return"\nindicates that the generator is done and will cause "StopIteration" to\nbe raised.\n',
 'sequence-types': u'\nEmulating container types\n*************************\n\nThe following methods can be defined to implement container objects.\nContainers usually are sequences (such as lists or tuples) or mappings\n(like dictionaries), but can represent other containers as well.  The\nfirst set of methods is used either to emulate a sequence or to\nemulate a mapping; the difference is that for a sequence, the\nallowable keys should be the integers *k* for which "0 <= k < N" where\n*N* is the length of the sequence, or slice objects, which define a\nrange of items. (For backwards compatibility, the method\n"__getslice__()" (see below) can also be defined to handle simple, but\nnot extended slices.) It is also recommended that mappings provide the\nmethods "keys()", "values()", "items()", "has_key()", "get()",\n"clear()", "setdefault()", "iterkeys()", "itervalues()",\n"iteritems()", "pop()", "popitem()", "copy()", and "update()" behaving\nsimilar to those for Python\'s standard dictionary objects.  The\n"UserDict" module provides a "DictMixin" class to help create those\nmethods from a base set of "__getitem__()", "__setitem__()",\n"__delitem__()", and "keys()". Mutable sequences should provide\nmethods "append()", "count()", "index()", "extend()", "insert()",\n"pop()", "remove()", "reverse()" and "sort()", like Python standard\nlist objects.  Finally, sequence types should implement addition\n(meaning concatenation) and multiplication (meaning repetition) by\ndefining the methods "__add__()", "__radd__()", "__iadd__()",\n"__mul__()", "__rmul__()" and "__imul__()" described below; they\nshould not define "__coerce__()" or other numerical operators.  It is\nrecommended that both mappings and sequences implement the\n"__contains__()" method to allow efficient use of the "in" operator;\nfor mappings, "in" should be equivalent of "has_key()"; for sequences,\nit should search through the values.  It is further recommended that\nboth mappings and sequences implement the "__iter__()" method to allow\nefficient iteration through the container; for mappings, "__iter__()"\nshould be the same as "iterkeys()"; for sequences, it should iterate\nthrough the values.\n\nobject.__len__(self)\n\n   Called to implement the built-in function "len()".  Should return\n   the length of the object, an integer ">=" 0.  Also, an object that\n   doesn\'t define a "__nonzero__()" method and whose "__len__()"\n   method returns zero is considered to be false in a Boolean context.\n\nobject.__getitem__(self, key)\n\n   Called to implement evaluation of "self[key]". For sequence types,\n   the accepted keys should be integers and slice objects.  Note that\n   the special interpretation of negative indexes (if the class wishes\n   to emulate a sequence type) is up to the "__getitem__()" method. If\n   *key* is of an inappropriate type, "TypeError" may be raised; if of\n   a value outside the set of indexes for the sequence (after any\n   special interpretation of negative values), "IndexError" should be\n   raised. For mapping types, if *key* is missing (not in the\n   container), "KeyError" should be raised.\n\n   Note: "for" loops expect that an "IndexError" will be raised for\n     illegal indexes to allow proper detection of the end of the\n     sequence.\n\nobject.__setitem__(self, key, value)\n\n   Called to implement assignment to "self[key]".  Same note as for\n   "__getitem__()".  This should only be implemented for mappings if\n   the objects support changes to the values for keys, or if new keys\n   can be added, or for sequences if elements can be replaced.  The\n   same exceptions should be raised for improper *key* values as for\n   the "__getitem__()" method.\n\nobject.__delitem__(self, key)\n\n   Called to implement deletion of "self[key]".  Same note as for\n   "__getitem__()".  This should only be implemented for mappings if\n   the objects support removal of keys, or for sequences if elements\n   can be removed from the sequence.  The same exceptions should be\n   raised for improper *key* values as for the "__getitem__()" method.\n\nobject.__iter__(self)\n\n   This method is called when an iterator is required for a container.\n   This method should return a new iterator object that can iterate\n   over all the objects in the container.  For mappings, it should\n   iterate over the keys of the container, and should also be made\n   available as the method "iterkeys()".\n\n   Iterator objects also need to implement this method; they are\n   required to return themselves.  For more information on iterator\n   objects, see *Iterator Types*.\n\nobject.__reversed__(self)\n\n   Called (if present) by the "reversed()" built-in to implement\n   reverse iteration.  It should return a new iterator object that\n   iterates over all the objects in the container in reverse order.\n\n   If the "__reversed__()" method is not provided, the "reversed()"\n   built-in will fall back to using the sequence protocol ("__len__()"\n   and "__getitem__()").  Objects that support the sequence protocol\n   should only provide "__reversed__()" if they can provide an\n   implementation that is more efficient than the one provided by\n   "reversed()".\n\n   New in version 2.6.\n\nThe membership test operators ("in" and "not in") are normally\nimplemented as an iteration through a sequence.  However, container\nobjects can supply the following special method with a more efficient\nimplementation, which also does not require the object be a sequence.\n\nobject.__contains__(self, item)\n\n   Called to implement membership test operators.  Should return true\n   if *item* is in *self*, false otherwise.  For mapping objects, this\n   should consider the keys of the mapping rather than the values or\n   the key-item pairs.\n\n   For objects that don\'t define "__contains__()", the membership test\n   first tries iteration via "__iter__()", then the old sequence\n   iteration protocol via "__getitem__()", see *this section in the\n   language reference*.\n',
 'shifting': u'\nShifting operations\n*******************\n\nThe shifting operations have lower priority than the arithmetic\noperations:\n\n   shift_expr ::= a_expr | shift_expr ( "<<" | ">>" ) a_expr\n\nThese operators accept plain or long integers as arguments.  The\narguments are converted to a common type.  They shift the first\nargument to the left or right by the number of bits given by the\nsecond argument.\n\nA right shift by *n* bits is defined as division by "pow(2, n)".  A\nleft shift by *n* bits is defined as multiplication with "pow(2, n)".\nNegative shift counts raise a "ValueError" exception.\n\nNote: In the current implementation, the right-hand operand is\n  required to be at most "sys.maxsize".  If the right-hand operand is\n  larger than "sys.maxsize" an "OverflowError" exception is raised.\n',
 'slicings': u'\nSlicings\n********\n\nA slicing selects a range of items in a sequence object (e.g., a\nstring, tuple or list).  Slicings may be used as expressions or as\ntargets in assignment or "del" statements.  The syntax for a slicing:\n\n   slicing          ::= simple_slicing | extended_slicing\n   simple_slicing   ::= primary "[" short_slice "]"\n   extended_slicing ::= primary "[" slice_list "]"\n   slice_list       ::= slice_item ("," slice_item)* [","]\n   slice_item       ::= expression | proper_slice | ellipsis\n   proper_slice     ::= short_slice | long_slice\n   short_slice      ::= [lower_bound] ":" [upper_bound]\n   long_slice       ::= short_slice ":" [stride]\n   lower_bound      ::= expression\n   upper_bound      ::= expression\n   stride           ::= expression\n   ellipsis         ::= "..."\n\nThere is ambiguity in the formal syntax here: anything that looks like\nan expression list also looks like a slice list, so any subscription\ncan be interpreted as a slicing.  Rather than further complicating the\nsyntax, this is disambiguated by defining that in this case the\ninterpretation as a subscription takes priority over the\ninterpretation as a slicing (this is the case if the slice list\ncontains no proper slice nor ellipses).  Similarly, when the slice\nlist has exactly one short slice and no trailing comma, the\ninterpretation as a simple slicing takes priority over that as an\nextended slicing.\n\nThe semantics for a simple slicing are as follows.  The primary must\nevaluate to a sequence object.  The lower and upper bound expressions,\nif present, must evaluate to plain integers; defaults are zero and the\n"sys.maxint", respectively.  If either bound is negative, the\nsequence\'s length is added to it.  The slicing now selects all items\nwith index *k* such that "i <= k < j" where *i* and *j* are the\nspecified lower and upper bounds.  This may be an empty sequence.  It\nis not an error if *i* or *j* lie outside the range of valid indexes\n(such items don\'t exist so they aren\'t selected).\n\nThe semantics for an extended slicing are as follows.  The primary\nmust evaluate to a mapping object, and it is indexed with a key that\nis constructed from the slice list, as follows.  If the slice list\ncontains at least one comma, the key is a tuple containing the\nconversion of the slice items; otherwise, the conversion of the lone\nslice item is the key.  The conversion of a slice item that is an\nexpression is that expression.  The conversion of an ellipsis slice\nitem is the built-in "Ellipsis" object.  The conversion of a proper\nslice is a slice object (see section *The standard type hierarchy*)\nwhose "start", "stop" and "step" attributes are the values of the\nexpressions given as lower bound, upper bound and stride,\nrespectively, substituting "None" for missing expressions.\n',
 'specialattrs': u'\nSpecial Attributes\n******************\n\nThe implementation adds a few special read-only attributes to several\nobject types, where they are relevant.  Some of these are not reported\nby the "dir()" built-in function.\n\nobject.__dict__\n\n   A dictionary or other mapping object used to store an object\'s\n   (writable) attributes.\n\nobject.__methods__\n\n   Deprecated since version 2.2: Use the built-in function "dir()" to\n   get a list of an object\'s attributes. This attribute is no longer\n   available.\n\nobject.__members__\n\n   Deprecated since version 2.2: Use the built-in function "dir()" to\n   get a list of an object\'s attributes. This attribute is no longer\n   available.\n\ninstance.__class__\n\n   The class to which a class instance belongs.\n\nclass.__bases__\n\n   The tuple of base classes of a class object.\n\nclass.__name__\n\n   The name of the class or type.\n\nThe following attributes are only supported by *new-style class*es.\n\nclass.__mro__\n\n   This attribute is a tuple of classes that are considered when\n   looking for base classes during method resolution.\n\nclass.mro()\n\n   This method can be overridden by a metaclass to customize the\n   method resolution order for its instances.  It is called at class\n   instantiation, and its result is stored in "__mro__".\n\nclass.__subclasses__()\n\n   Each new-style class keeps a list of weak references to its\n   immediate subclasses.  This method returns a list of all those\n   references still alive. Example:\n\n      >>> int.__subclasses__()\n      [<type \'bool\'>]\n\n-[ Footnotes ]-\n\n[1] Additional information on these special methods may be found\n    in the Python Reference Manual (*Basic customization*).\n\n[2] As a consequence, the list "[1, 2]" is considered equal to\n    "[1.0, 2.0]", and similarly for tuples.\n\n[3] They must have since the parser can\'t tell the type of the\n    operands.\n\n[4] Cased characters are those with general category property\n    being one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase),\n    or "Lt" (Letter, titlecase).\n\n[5] To format only a tuple you should therefore provide a\n    singleton tuple whose only element is the tuple to be formatted.\n\n[6] The advantage of leaving the newline on is that returning an\n    empty string is then an unambiguous EOF indication.  It is also\n    possible (in cases where it might matter, for example, if you want\n    to make an exact copy of a file while scanning its lines) to tell\n    whether the last line of a file ended in a newline or not (yes\n    this happens!).\n',
 'specialnames': u'\nSpecial method names\n********************\n\nA class can implement certain operations that are invoked by special\nsyntax (such as arithmetic operations or subscripting and slicing) by\ndefining methods with special names. This is Python\'s approach to\n*operator overloading*, allowing classes to define their own behavior\nwith respect to language operators.  For instance, if a class defines\na method named "__getitem__()", and "x" is an instance of this class,\nthen "x[i]" is roughly equivalent to "x.__getitem__(i)" for old-style\nclasses and "type(x).__getitem__(x, i)" for new-style classes.  Except\nwhere mentioned, attempts to execute an operation raise an exception\nwhen no appropriate method is defined (typically "AttributeError" or\n"TypeError").\n\nWhen implementing a class that emulates any built-in type, it is\nimportant that the emulation only be implemented to the degree that it\nmakes sense for the object being modelled.  For example, some\nsequences may work well with retrieval of individual elements, but\nextracting a slice may not make sense.  (One example of this is the\n"NodeList" interface in the W3C\'s Document Object Model.)\n\n\nBasic customization\n===================\n\nobject.__new__(cls[, ...])\n\n   Called to create a new instance of class *cls*.  "__new__()" is a\n   static method (special-cased so you need not declare it as such)\n   that takes the class of which an instance was requested as its\n   first argument.  The remaining arguments are those passed to the\n   object constructor expression (the call to the class).  The return\n   value of "__new__()" should be the new object instance (usually an\n   instance of *cls*).\n\n   Typical implementations create a new instance of the class by\n   invoking the superclass\'s "__new__()" method using\n   "super(currentclass, cls).__new__(cls[, ...])" with appropriate\n   arguments and then modifying the newly-created instance as\n   necessary before returning it.\n\n   If "__new__()" returns an instance of *cls*, then the new\n   instance\'s "__init__()" method will be invoked like\n   "__init__(self[, ...])", where *self* is the new instance and the\n   remaining arguments are the same as were passed to "__new__()".\n\n   If "__new__()" does not return an instance of *cls*, then the new\n   instance\'s "__init__()" method will not be invoked.\n\n   "__new__()" is intended mainly to allow subclasses of immutable\n   types (like int, str, or tuple) to customize instance creation.  It\n   is also commonly overridden in custom metaclasses in order to\n   customize class creation.\n\nobject.__init__(self[, ...])\n\n   Called when the instance is created.  The arguments are those\n   passed to the class constructor expression.  If a base class has an\n   "__init__()" method, the derived class\'s "__init__()" method, if\n   any, must explicitly call it to ensure proper initialization of the\n   base class part of the instance; for example:\n   "BaseClass.__init__(self, [args...])".  As a special constraint on\n   constructors, no value may be returned; doing so will cause a\n   "TypeError" to be raised at runtime.\n\nobject.__del__(self)\n\n   Called when the instance is about to be destroyed.  This is also\n   called a destructor.  If a base class has a "__del__()" method, the\n   derived class\'s "__del__()" method, if any, must explicitly call it\n   to ensure proper deletion of the base class part of the instance.\n   Note that it is possible (though not recommended!) for the\n   "__del__()" method to postpone destruction of the instance by\n   creating a new reference to it.  It may then be called at a later\n   time when this new reference is deleted.  It is not guaranteed that\n   "__del__()" methods are called for objects that still exist when\n   the interpreter exits.\n\n   Note: "del x" doesn\'t directly call "x.__del__()" --- the former\n     decrements the reference count for "x" by one, and the latter is\n     only called when "x"\'s reference count reaches zero.  Some common\n     situations that may prevent the reference count of an object from\n     going to zero include: circular references between objects (e.g.,\n     a doubly-linked list or a tree data structure with parent and\n     child pointers); a reference to the object on the stack frame of\n     a function that caught an exception (the traceback stored in\n     "sys.exc_traceback" keeps the stack frame alive); or a reference\n     to the object on the stack frame that raised an unhandled\n     exception in interactive mode (the traceback stored in\n     "sys.last_traceback" keeps the stack frame alive).  The first\n     situation can only be remedied by explicitly breaking the cycles;\n     the latter two situations can be resolved by storing "None" in\n     "sys.exc_traceback" or "sys.last_traceback".  Circular references\n     which are garbage are detected when the option cycle detector is\n     enabled (it\'s on by default), but can only be cleaned up if there\n     are no Python-level "__del__()" methods involved. Refer to the\n     documentation for the "gc" module for more information about how\n     "__del__()" methods are handled by the cycle detector,\n     particularly the description of the "garbage" value.\n\n   Warning: Due to the precarious circumstances under which\n     "__del__()" methods are invoked, exceptions that occur during\n     their execution are ignored, and a warning is printed to\n     "sys.stderr" instead. Also, when "__del__()" is invoked in\n     response to a module being deleted (e.g., when execution of the\n     program is done), other globals referenced by the "__del__()"\n     method may already have been deleted or in the process of being\n     torn down (e.g. the import machinery shutting down).  For this\n     reason, "__del__()" methods should do the absolute minimum needed\n     to maintain external invariants.  Starting with version 1.5,\n     Python guarantees that globals whose name begins with a single\n     underscore are deleted from their module before other globals are\n     deleted; if no other references to such globals exist, this may\n     help in assuring that imported modules are still available at the\n     time when the "__del__()" method is called.\n\n   See also the *-R* command-line option.\n\nobject.__repr__(self)\n\n   Called by the "repr()" built-in function and by string conversions\n   (reverse quotes) to compute the "official" string representation of\n   an object.  If at all possible, this should look like a valid\n   Python expression that could be used to recreate an object with the\n   same value (given an appropriate environment).  If this is not\n   possible, a string of the form "<...some useful description...>"\n   should be returned.  The return value must be a string object. If a\n   class defines "__repr__()" but not "__str__()", then "__repr__()"\n   is also used when an "informal" string representation of instances\n   of that class is required.\n\n   This is typically used for debugging, so it is important that the\n   representation is information-rich and unambiguous.\n\nobject.__str__(self)\n\n   Called by the "str()" built-in function and by the "print"\n   statement to compute the "informal" string representation of an\n   object.  This differs from "__repr__()" in that it does not have to\n   be a valid Python expression: a more convenient or concise\n   representation may be used instead. The return value must be a\n   string object.\n\nobject.__lt__(self, other)\nobject.__le__(self, other)\nobject.__eq__(self, other)\nobject.__ne__(self, other)\nobject.__gt__(self, other)\nobject.__ge__(self, other)\n\n   New in version 2.1.\n\n   These are the so-called "rich comparison" methods, and are called\n   for comparison operators in preference to "__cmp__()" below. The\n   correspondence between operator symbols and method names is as\n   follows: "x<y" calls "x.__lt__(y)", "x<=y" calls "x.__le__(y)",\n   "x==y" calls "x.__eq__(y)", "x!=y" and "x<>y" call "x.__ne__(y)",\n   "x>y" calls "x.__gt__(y)", and "x>=y" calls "x.__ge__(y)".\n\n   A rich comparison method may return the singleton "NotImplemented"\n   if it does not implement the operation for a given pair of\n   arguments. By convention, "False" and "True" are returned for a\n   successful comparison. However, these methods can return any value,\n   so if the comparison operator is used in a Boolean context (e.g.,\n   in the condition of an "if" statement), Python will call "bool()"\n   on the value to determine if the result is true or false.\n\n   There are no implied relationships among the comparison operators.\n   The truth of "x==y" does not imply that "x!=y" is false.\n   Accordingly, when defining "__eq__()", one should also define\n   "__ne__()" so that the operators will behave as expected.  See the\n   paragraph on "__hash__()" for some important notes on creating\n   *hashable* objects which support custom comparison operations and\n   are usable as dictionary keys.\n\n   There are no swapped-argument versions of these methods (to be used\n   when the left argument does not support the operation but the right\n   argument does); rather, "__lt__()" and "__gt__()" are each other\'s\n   reflection, "__le__()" and "__ge__()" are each other\'s reflection,\n   and "__eq__()" and "__ne__()" are their own reflection.\n\n   Arguments to rich comparison methods are never coerced.\n\n   To automatically generate ordering operations from a single root\n   operation, see "functools.total_ordering()".\n\nobject.__cmp__(self, other)\n\n   Called by comparison operations if rich comparison (see above) is\n   not defined.  Should return a negative integer if "self < other",\n   zero if "self == other", a positive integer if "self > other".  If\n   no "__cmp__()", "__eq__()" or "__ne__()" operation is defined,\n   class instances are compared by object identity ("address").  See\n   also the description of "__hash__()" for some important notes on\n   creating *hashable* objects which support custom comparison\n   operations and are usable as dictionary keys. (Note: the\n   restriction that exceptions are not propagated by "__cmp__()" has\n   been removed since Python 1.5.)\n\nobject.__rcmp__(self, other)\n\n   Changed in version 2.1: No longer supported.\n\nobject.__hash__(self)\n\n   Called by built-in function "hash()" and for operations on members\n   of hashed collections including "set", "frozenset", and "dict".\n   "__hash__()" should return an integer.  The only required property\n   is that objects which compare equal have the same hash value; it is\n   advised to somehow mix together (e.g. using exclusive or) the hash\n   values for the components of the object that also play a part in\n   comparison of objects.\n\n   If a class does not define a "__cmp__()" or "__eq__()" method it\n   should not define a "__hash__()" operation either; if it defines\n   "__cmp__()" or "__eq__()" but not "__hash__()", its instances will\n   not be usable in hashed collections.  If a class defines mutable\n   objects and implements a "__cmp__()" or "__eq__()" method, it\n   should not implement "__hash__()", since hashable collection\n   implementations require that a object\'s hash value is immutable (if\n   the object\'s hash value changes, it will be in the wrong hash\n   bucket).\n\n   User-defined classes have "__cmp__()" and "__hash__()" methods by\n   default; with them, all objects compare unequal (except with\n   themselves) and "x.__hash__()" returns a result derived from\n   "id(x)".\n\n   Classes which inherit a "__hash__()" method from a parent class but\n   change the meaning of "__cmp__()" or "__eq__()" such that the hash\n   value returned is no longer appropriate (e.g. by switching to a\n   value-based concept of equality instead of the default identity\n   based equality) can explicitly flag themselves as being unhashable\n   by setting "__hash__ = None" in the class definition. Doing so\n   means that not only will instances of the class raise an\n   appropriate "TypeError" when a program attempts to retrieve their\n   hash value, but they will also be correctly identified as\n   unhashable when checking "isinstance(obj, collections.Hashable)"\n   (unlike classes which define their own "__hash__()" to explicitly\n   raise "TypeError").\n\n   Changed in version 2.5: "__hash__()" may now also return a long\n   integer object; the 32-bit integer is then derived from the hash of\n   that object.\n\n   Changed in version 2.6: "__hash__" may now be set to "None" to\n   explicitly flag instances of a class as unhashable.\n\nobject.__nonzero__(self)\n\n   Called to implement truth value testing and the built-in operation\n   "bool()"; should return "False" or "True", or their integer\n   equivalents "0" or "1".  When this method is not defined,\n   "__len__()" is called, if it is defined, and the object is\n   considered true if its result is nonzero. If a class defines\n   neither "__len__()" nor "__nonzero__()", all its instances are\n   considered true.\n\nobject.__unicode__(self)\n\n   Called to implement "unicode()" built-in; should return a Unicode\n   object. When this method is not defined, string conversion is\n   attempted, and the result of string conversion is converted to\n   Unicode using the system default encoding.\n\n\nCustomizing attribute access\n============================\n\nThe following methods can be defined to customize the meaning of\nattribute access (use of, assignment to, or deletion of "x.name") for\nclass instances.\n\nobject.__getattr__(self, name)\n\n   Called when an attribute lookup has not found the attribute in the\n   usual places (i.e. it is not an instance attribute nor is it found\n   in the class tree for "self").  "name" is the attribute name. This\n   method should return the (computed) attribute value or raise an\n   "AttributeError" exception.\n\n   Note that if the attribute is found through the normal mechanism,\n   "__getattr__()" is not called.  (This is an intentional asymmetry\n   between "__getattr__()" and "__setattr__()".) This is done both for\n   efficiency reasons and because otherwise "__getattr__()" would have\n   no way to access other attributes of the instance.  Note that at\n   least for instance variables, you can fake total control by not\n   inserting any values in the instance attribute dictionary (but\n   instead inserting them in another object).  See the\n   "__getattribute__()" method below for a way to actually get total\n   control in new-style classes.\n\nobject.__setattr__(self, name, value)\n\n   Called when an attribute assignment is attempted.  This is called\n   instead of the normal mechanism (i.e. store the value in the\n   instance dictionary).  *name* is the attribute name, *value* is the\n   value to be assigned to it.\n\n   If "__setattr__()" wants to assign to an instance attribute, it\n   should not simply execute "self.name = value" --- this would cause\n   a recursive call to itself.  Instead, it should insert the value in\n   the dictionary of instance attributes, e.g., "self.__dict__[name] =\n   value".  For new-style classes, rather than accessing the instance\n   dictionary, it should call the base class method with the same\n   name, for example, "object.__setattr__(self, name, value)".\n\nobject.__delattr__(self, name)\n\n   Like "__setattr__()" but for attribute deletion instead of\n   assignment.  This should only be implemented if "del obj.name" is\n   meaningful for the object.\n\n\nMore attribute access for new-style classes\n-------------------------------------------\n\nThe following methods only apply to new-style classes.\n\nobject.__getattribute__(self, name)\n\n   Called unconditionally to implement attribute accesses for\n   instances of the class. If the class also defines "__getattr__()",\n   the latter will not be called unless "__getattribute__()" either\n   calls it explicitly or raises an "AttributeError". This method\n   should return the (computed) attribute value or raise an\n   "AttributeError" exception. In order to avoid infinite recursion in\n   this method, its implementation should always call the base class\n   method with the same name to access any attributes it needs, for\n   example, "object.__getattribute__(self, name)".\n\n   Note: This method may still be bypassed when looking up special\n     methods as the result of implicit invocation via language syntax\n     or built-in functions. See *Special method lookup for new-style\n     classes*.\n\n\nImplementing Descriptors\n------------------------\n\nThe following methods only apply when an instance of the class\ncontaining the method (a so-called *descriptor* class) appears in an\n*owner* class (the descriptor must be in either the owner\'s class\ndictionary or in the class dictionary for one of its parents).  In the\nexamples below, "the attribute" refers to the attribute whose name is\nthe key of the property in the owner class\' "__dict__".\n\nobject.__get__(self, instance, owner)\n\n   Called to get the attribute of the owner class (class attribute\n   access) or of an instance of that class (instance attribute\n   access). *owner* is always the owner class, while *instance* is the\n   instance that the attribute was accessed through, or "None" when\n   the attribute is accessed through the *owner*.  This method should\n   return the (computed) attribute value or raise an "AttributeError"\n   exception.\n\nobject.__set__(self, instance, value)\n\n   Called to set the attribute on an instance *instance* of the owner\n   class to a new value, *value*.\n\nobject.__delete__(self, instance)\n\n   Called to delete the attribute on an instance *instance* of the\n   owner class.\n\n\nInvoking Descriptors\n--------------------\n\nIn general, a descriptor is an object attribute with "binding\nbehavior", one whose attribute access has been overridden by methods\nin the descriptor protocol:  "__get__()", "__set__()", and\n"__delete__()". If any of those methods are defined for an object, it\nis said to be a descriptor.\n\nThe default behavior for attribute access is to get, set, or delete\nthe attribute from an object\'s dictionary. For instance, "a.x" has a\nlookup chain starting with "a.__dict__[\'x\']", then\n"type(a).__dict__[\'x\']", and continuing through the base classes of\n"type(a)" excluding metaclasses.\n\nHowever, if the looked-up value is an object defining one of the\ndescriptor methods, then Python may override the default behavior and\ninvoke the descriptor method instead.  Where this occurs in the\nprecedence chain depends on which descriptor methods were defined and\nhow they were called.  Note that descriptors are only invoked for new\nstyle objects or classes (ones that subclass "object()" or "type()").\n\nThe starting point for descriptor invocation is a binding, "a.x". How\nthe arguments are assembled depends on "a":\n\nDirect Call\n   The simplest and least common call is when user code directly\n   invokes a descriptor method:    "x.__get__(a)".\n\nInstance Binding\n   If binding to a new-style object instance, "a.x" is transformed\n   into the call: "type(a).__dict__[\'x\'].__get__(a, type(a))".\n\nClass Binding\n   If binding to a new-style class, "A.x" is transformed into the\n   call: "A.__dict__[\'x\'].__get__(None, A)".\n\nSuper Binding\n   If "a" is an instance of "super", then the binding "super(B,\n   obj).m()" searches "obj.__class__.__mro__" for the base class "A"\n   immediately preceding "B" and then invokes the descriptor with the\n   call: "A.__dict__[\'m\'].__get__(obj, obj.__class__)".\n\nFor instance bindings, the precedence of descriptor invocation depends\non the which descriptor methods are defined.  A descriptor can define\nany combination of "__get__()", "__set__()" and "__delete__()".  If it\ndoes not define "__get__()", then accessing the attribute will return\nthe descriptor object itself unless there is a value in the object\'s\ninstance dictionary.  If the descriptor defines "__set__()" and/or\n"__delete__()", it is a data descriptor; if it defines neither, it is\na non-data descriptor.  Normally, data descriptors define both\n"__get__()" and "__set__()", while non-data descriptors have just the\n"__get__()" method.  Data descriptors with "__set__()" and "__get__()"\ndefined always override a redefinition in an instance dictionary.  In\ncontrast, non-data descriptors can be overridden by instances.\n\nPython methods (including "staticmethod()" and "classmethod()") are\nimplemented as non-data descriptors.  Accordingly, instances can\nredefine and override methods.  This allows individual instances to\nacquire behaviors that differ from other instances of the same class.\n\nThe "property()" function is implemented as a data descriptor.\nAccordingly, instances cannot override the behavior of a property.\n\n\n__slots__\n---------\n\nBy default, instances of both old and new-style classes have a\ndictionary for attribute storage.  This wastes space for objects\nhaving very few instance variables.  The space consumption can become\nacute when creating large numbers of instances.\n\nThe default can be overridden by defining *__slots__* in a new-style\nclass definition.  The *__slots__* declaration takes a sequence of\ninstance variables and reserves just enough space in each instance to\nhold a value for each variable.  Space is saved because *__dict__* is\nnot created for each instance.\n\n__slots__\n\n   This class variable can be assigned a string, iterable, or sequence\n   of strings with variable names used by instances.  If defined in a\n   new-style class, *__slots__* reserves space for the declared\n   variables and prevents the automatic creation of *__dict__* and\n   *__weakref__* for each instance.\n\n   New in version 2.2.\n\nNotes on using *__slots__*\n\n* When inheriting from a class without *__slots__*, the *__dict__*\n  attribute of that class will always be accessible, so a *__slots__*\n  definition in the subclass is meaningless.\n\n* Without a *__dict__* variable, instances cannot be assigned new\n  variables not listed in the *__slots__* definition.  Attempts to\n  assign to an unlisted variable name raises "AttributeError". If\n  dynamic assignment of new variables is desired, then add\n  "\'__dict__\'" to the sequence of strings in the *__slots__*\n  declaration.\n\n  Changed in version 2.3: Previously, adding "\'__dict__\'" to the\n  *__slots__* declaration would not enable the assignment of new\n  attributes not specifically listed in the sequence of instance\n  variable names.\n\n* Without a *__weakref__* variable for each instance, classes\n  defining *__slots__* do not support weak references to its\n  instances. If weak reference support is needed, then add\n  "\'__weakref__\'" to the sequence of strings in the *__slots__*\n  declaration.\n\n  Changed in version 2.3: Previously, adding "\'__weakref__\'" to the\n  *__slots__* declaration would not enable support for weak\n  references.\n\n* *__slots__* are implemented at the class level by creating\n  descriptors (*Implementing Descriptors*) for each variable name.  As\n  a result, class attributes cannot be used to set default values for\n  instance variables defined by *__slots__*; otherwise, the class\n  attribute would overwrite the descriptor assignment.\n\n* The action of a *__slots__* declaration is limited to the class\n  where it is defined.  As a result, subclasses will have a *__dict__*\n  unless they also define *__slots__* (which must only contain names\n  of any *additional* slots).\n\n* If a class defines a slot also defined in a base class, the\n  instance variable defined by the base class slot is inaccessible\n  (except by retrieving its descriptor directly from the base class).\n  This renders the meaning of the program undefined.  In the future, a\n  check may be added to prevent this.\n\n* Nonempty *__slots__* does not work for classes derived from\n  "variable-length" built-in types such as "long", "str" and "tuple".\n\n* Any non-string iterable may be assigned to *__slots__*. Mappings\n  may also be used; however, in the future, special meaning may be\n  assigned to the values corresponding to each key.\n\n* *__class__* assignment works only if both classes have the same\n  *__slots__*.\n\n  Changed in version 2.6: Previously, *__class__* assignment raised an\n  error if either new or old class had *__slots__*.\n\n\nCustomizing class creation\n==========================\n\nBy default, new-style classes are constructed using "type()". A class\ndefinition is read into a separate namespace and the value of class\nname is bound to the result of "type(name, bases, dict)".\n\nWhen the class definition is read, if *__metaclass__* is defined then\nthe callable assigned to it will be called instead of "type()". This\nallows classes or functions to be written which monitor or alter the\nclass creation process:\n\n* Modifying the class dictionary prior to the class being created.\n\n* Returning an instance of another class -- essentially performing\n  the role of a factory function.\n\nThese steps will have to be performed in the metaclass\'s "__new__()"\nmethod -- "type.__new__()" can then be called from this method to\ncreate a class with different properties.  This example adds a new\nelement to the class dictionary before creating the class:\n\n   class metacls(type):\n       def __new__(mcs, name, bases, dict):\n           dict[\'foo\'] = \'metacls was here\'\n           return type.__new__(mcs, name, bases, dict)\n\nYou can of course also override other class methods (or add new\nmethods); for example defining a custom "__call__()" method in the\nmetaclass allows custom behavior when the class is called, e.g. not\nalways creating a new instance.\n\n__metaclass__\n\n   This variable can be any callable accepting arguments for "name",\n   "bases", and "dict".  Upon class creation, the callable is used\n   instead of the built-in "type()".\n\n   New in version 2.2.\n\nThe appropriate metaclass is determined by the following precedence\nrules:\n\n* If "dict[\'__metaclass__\']" exists, it is used.\n\n* Otherwise, if there is at least one base class, its metaclass is\n  used (this looks for a *__class__* attribute first and if not found,\n  uses its type).\n\n* Otherwise, if a global variable named __metaclass__ exists, it is\n  used.\n\n* Otherwise, the old-style, classic metaclass (types.ClassType) is\n  used.\n\nThe potential uses for metaclasses are boundless. Some ideas that have\nbeen explored including logging, interface checking, automatic\ndelegation, automatic property creation, proxies, frameworks, and\nautomatic resource locking/synchronization.\n\n\nCustomizing instance and subclass checks\n========================================\n\nNew in version 2.6.\n\nThe following methods are used to override the default behavior of the\n"isinstance()" and "issubclass()" built-in functions.\n\nIn particular, the metaclass "abc.ABCMeta" implements these methods in\norder to allow the addition of Abstract Base Classes (ABCs) as\n"virtual base classes" to any class or type (including built-in\ntypes), including other ABCs.\n\nclass.__instancecheck__(self, instance)\n\n   Return true if *instance* should be considered a (direct or\n   indirect) instance of *class*. If defined, called to implement\n   "isinstance(instance, class)".\n\nclass.__subclasscheck__(self, subclass)\n\n   Return true if *subclass* should be considered a (direct or\n   indirect) subclass of *class*.  If defined, called to implement\n   "issubclass(subclass, class)".\n\nNote that these methods are looked up on the type (metaclass) of a\nclass.  They cannot be defined as class methods in the actual class.\nThis is consistent with the lookup of special methods that are called\non instances, only in this case the instance is itself a class.\n\nSee also: **PEP 3119** - Introducing Abstract Base Classes\n\n     Includes the specification for customizing "isinstance()" and\n     "issubclass()" behavior through "__instancecheck__()" and\n     "__subclasscheck__()", with motivation for this functionality in\n     the context of adding Abstract Base Classes (see the "abc"\n     module) to the language.\n\n\nEmulating callable objects\n==========================\n\nobject.__call__(self[, args...])\n\n   Called when the instance is "called" as a function; if this method\n   is defined, "x(arg1, arg2, ...)" is a shorthand for\n   "x.__call__(arg1, arg2, ...)".\n\n\nEmulating container types\n=========================\n\nThe following methods can be defined to implement container objects.\nContainers usually are sequences (such as lists or tuples) or mappings\n(like dictionaries), but can represent other containers as well.  The\nfirst set of methods is used either to emulate a sequence or to\nemulate a mapping; the difference is that for a sequence, the\nallowable keys should be the integers *k* for which "0 <= k < N" where\n*N* is the length of the sequence, or slice objects, which define a\nrange of items. (For backwards compatibility, the method\n"__getslice__()" (see below) can also be defined to handle simple, but\nnot extended slices.) It is also recommended that mappings provide the\nmethods "keys()", "values()", "items()", "has_key()", "get()",\n"clear()", "setdefault()", "iterkeys()", "itervalues()",\n"iteritems()", "pop()", "popitem()", "copy()", and "update()" behaving\nsimilar to those for Python\'s standard dictionary objects.  The\n"UserDict" module provides a "DictMixin" class to help create those\nmethods from a base set of "__getitem__()", "__setitem__()",\n"__delitem__()", and "keys()". Mutable sequences should provide\nmethods "append()", "count()", "index()", "extend()", "insert()",\n"pop()", "remove()", "reverse()" and "sort()", like Python standard\nlist objects.  Finally, sequence types should implement addition\n(meaning concatenation) and multiplication (meaning repetition) by\ndefining the methods "__add__()", "__radd__()", "__iadd__()",\n"__mul__()", "__rmul__()" and "__imul__()" described below; they\nshould not define "__coerce__()" or other numerical operators.  It is\nrecommended that both mappings and sequences implement the\n"__contains__()" method to allow efficient use of the "in" operator;\nfor mappings, "in" should be equivalent of "has_key()"; for sequences,\nit should search through the values.  It is further recommended that\nboth mappings and sequences implement the "__iter__()" method to allow\nefficient iteration through the container; for mappings, "__iter__()"\nshould be the same as "iterkeys()"; for sequences, it should iterate\nthrough the values.\n\nobject.__len__(self)\n\n   Called to implement the built-in function "len()".  Should return\n   the length of the object, an integer ">=" 0.  Also, an object that\n   doesn\'t define a "__nonzero__()" method and whose "__len__()"\n   method returns zero is considered to be false in a Boolean context.\n\nobject.__getitem__(self, key)\n\n   Called to implement evaluation of "self[key]". For sequence types,\n   the accepted keys should be integers and slice objects.  Note that\n   the special interpretation of negative indexes (if the class wishes\n   to emulate a sequence type) is up to the "__getitem__()" method. If\n   *key* is of an inappropriate type, "TypeError" may be raised; if of\n   a value outside the set of indexes for the sequence (after any\n   special interpretation of negative values), "IndexError" should be\n   raised. For mapping types, if *key* is missing (not in the\n   container), "KeyError" should be raised.\n\n   Note: "for" loops expect that an "IndexError" will be raised for\n     illegal indexes to allow proper detection of the end of the\n     sequence.\n\nobject.__setitem__(self, key, value)\n\n   Called to implement assignment to "self[key]".  Same note as for\n   "__getitem__()".  This should only be implemented for mappings if\n   the objects support changes to the values for keys, or if new keys\n   can be added, or for sequences if elements can be replaced.  The\n   same exceptions should be raised for improper *key* values as for\n   the "__getitem__()" method.\n\nobject.__delitem__(self, key)\n\n   Called to implement deletion of "self[key]".  Same note as for\n   "__getitem__()".  This should only be implemented for mappings if\n   the objects support removal of keys, or for sequences if elements\n   can be removed from the sequence.  The same exceptions should be\n   raised for improper *key* values as for the "__getitem__()" method.\n\nobject.__iter__(self)\n\n   This method is called when an iterator is required for a container.\n   This method should return a new iterator object that can iterate\n   over all the objects in the container.  For mappings, it should\n   iterate over the keys of the container, and should also be made\n   available as the method "iterkeys()".\n\n   Iterator objects also need to implement this method; they are\n   required to return themselves.  For more information on iterator\n   objects, see *Iterator Types*.\n\nobject.__reversed__(self)\n\n   Called (if present) by the "reversed()" built-in to implement\n   reverse iteration.  It should return a new iterator object that\n   iterates over all the objects in the container in reverse order.\n\n   If the "__reversed__()" method is not provided, the "reversed()"\n   built-in will fall back to using the sequence protocol ("__len__()"\n   and "__getitem__()").  Objects that support the sequence protocol\n   should only provide "__reversed__()" if they can provide an\n   implementation that is more efficient than the one provided by\n   "reversed()".\n\n   New in version 2.6.\n\nThe membership test operators ("in" and "not in") are normally\nimplemented as an iteration through a sequence.  However, container\nobjects can supply the following special method with a more efficient\nimplementation, which also does not require the object be a sequence.\n\nobject.__contains__(self, item)\n\n   Called to implement membership test operators.  Should return true\n   if *item* is in *self*, false otherwise.  For mapping objects, this\n   should consider the keys of the mapping rather than the values or\n   the key-item pairs.\n\n   For objects that don\'t define "__contains__()", the membership test\n   first tries iteration via "__iter__()", then the old sequence\n   iteration protocol via "__getitem__()", see *this section in the\n   language reference*.\n\n\nAdditional methods for emulation of sequence types\n==================================================\n\nThe following optional methods can be defined to further emulate\nsequence objects.  Immutable sequences methods should at most only\ndefine "__getslice__()"; mutable sequences might define all three\nmethods.\n\nobject.__getslice__(self, i, j)\n\n   Deprecated since version 2.0: Support slice objects as parameters\n   to the "__getitem__()" method. (However, built-in types in CPython\n   currently still implement "__getslice__()".  Therefore, you have to\n   override it in derived classes when implementing slicing.)\n\n   Called to implement evaluation of "self[i:j]". The returned object\n   should be of the same type as *self*.  Note that missing *i* or *j*\n   in the slice expression are replaced by zero or "sys.maxint",\n   respectively.  If negative indexes are used in the slice, the\n   length of the sequence is added to that index. If the instance does\n   not implement the "__len__()" method, an "AttributeError" is\n   raised. No guarantee is made that indexes adjusted this way are not\n   still negative.  Indexes which are greater than the length of the\n   sequence are not modified. If no "__getslice__()" is found, a slice\n   object is created instead, and passed to "__getitem__()" instead.\n\nobject.__setslice__(self, i, j, sequence)\n\n   Called to implement assignment to "self[i:j]". Same notes for *i*\n   and *j* as for "__getslice__()".\n\n   This method is deprecated. If no "__setslice__()" is found, or for\n   extended slicing of the form "self[i:j:k]", a slice object is\n   created, and passed to "__setitem__()", instead of "__setslice__()"\n   being called.\n\nobject.__delslice__(self, i, j)\n\n   Called to implement deletion of "self[i:j]". Same notes for *i* and\n   *j* as for "__getslice__()". This method is deprecated. If no\n   "__delslice__()" is found, or for extended slicing of the form\n   "self[i:j:k]", a slice object is created, and passed to\n   "__delitem__()", instead of "__delslice__()" being called.\n\nNotice that these methods are only invoked when a single slice with a\nsingle colon is used, and the slice method is available.  For slice\noperations involving extended slice notation, or in absence of the\nslice methods, "__getitem__()", "__setitem__()" or "__delitem__()" is\ncalled with a slice object as argument.\n\nThe following example demonstrate how to make your program or module\ncompatible with earlier versions of Python (assuming that methods\n"__getitem__()", "__setitem__()" and "__delitem__()" support slice\nobjects as arguments):\n\n   class MyClass:\n       ...\n       def __getitem__(self, index):\n           ...\n       def __setitem__(self, index, value):\n           ...\n       def __delitem__(self, index):\n           ...\n\n       if sys.version_info < (2, 0):\n           # They won\'t be defined if version is at least 2.0 final\n\n           def __getslice__(self, i, j):\n               return self[max(0, i):max(0, j):]\n           def __setslice__(self, i, j, seq):\n               self[max(0, i):max(0, j):] = seq\n           def __delslice__(self, i, j):\n               del self[max(0, i):max(0, j):]\n       ...\n\nNote the calls to "max()"; these are necessary because of the handling\nof negative indices before the "__*slice__()" methods are called.\nWhen negative indexes are used, the "__*item__()" methods receive them\nas provided, but the "__*slice__()" methods get a "cooked" form of the\nindex values.  For each negative index value, the length of the\nsequence is added to the index before calling the method (which may\nstill result in a negative index); this is the customary handling of\nnegative indexes by the built-in sequence types, and the "__*item__()"\nmethods are expected to do this as well.  However, since they should\nalready be doing that, negative indexes cannot be passed in; they must\nbe constrained to the bounds of the sequence before being passed to\nthe "__*item__()" methods. Calling "max(0, i)" conveniently returns\nthe proper value.\n\n\nEmulating numeric types\n=======================\n\nThe following methods can be defined to emulate numeric objects.\nMethods corresponding to operations that are not supported by the\nparticular kind of number implemented (e.g., bitwise operations for\nnon-integral numbers) should be left undefined.\n\nobject.__add__(self, other)\nobject.__sub__(self, other)\nobject.__mul__(self, other)\nobject.__floordiv__(self, other)\nobject.__mod__(self, other)\nobject.__divmod__(self, other)\nobject.__pow__(self, other[, modulo])\nobject.__lshift__(self, other)\nobject.__rshift__(self, other)\nobject.__and__(self, other)\nobject.__xor__(self, other)\nobject.__or__(self, other)\n\n   These methods are called to implement the binary arithmetic\n   operations ("+", "-", "*", "//", "%", "divmod()", "pow()", "**",\n   "<<", ">>", "&", "^", "|").  For instance, to evaluate the\n   expression "x + y", where *x* is an instance of a class that has an\n   "__add__()" method, "x.__add__(y)" is called.  The "__divmod__()"\n   method should be the equivalent to using "__floordiv__()" and\n   "__mod__()"; it should not be related to "__truediv__()" (described\n   below).  Note that "__pow__()" should be defined to accept an\n   optional third argument if the ternary version of the built-in\n   "pow()" function is to be supported.\n\n   If one of those methods does not support the operation with the\n   supplied arguments, it should return "NotImplemented".\n\nobject.__div__(self, other)\nobject.__truediv__(self, other)\n\n   The division operator ("/") is implemented by these methods.  The\n   "__truediv__()" method is used when "__future__.division" is in\n   effect, otherwise "__div__()" is used.  If only one of these two\n   methods is defined, the object will not support division in the\n   alternate context; "TypeError" will be raised instead.\n\nobject.__radd__(self, other)\nobject.__rsub__(self, other)\nobject.__rmul__(self, other)\nobject.__rdiv__(self, other)\nobject.__rtruediv__(self, other)\nobject.__rfloordiv__(self, other)\nobject.__rmod__(self, other)\nobject.__rdivmod__(self, other)\nobject.__rpow__(self, other)\nobject.__rlshift__(self, other)\nobject.__rrshift__(self, other)\nobject.__rand__(self, other)\nobject.__rxor__(self, other)\nobject.__ror__(self, other)\n\n   These methods are called to implement the binary arithmetic\n   operations ("+", "-", "*", "/", "%", "divmod()", "pow()", "**",\n   "<<", ">>", "&", "^", "|") with reflected (swapped) operands.\n   These functions are only called if the left operand does not\n   support the corresponding operation and the operands are of\n   different types. [2] For instance, to evaluate the expression "x -\n   y", where *y* is an instance of a class that has an "__rsub__()"\n   method, "y.__rsub__(x)" is called if "x.__sub__(y)" returns\n   *NotImplemented*.\n\n   Note that ternary "pow()" will not try calling "__rpow__()" (the\n   coercion rules would become too complicated).\n\n   Note: If the right operand\'s type is a subclass of the left\n     operand\'s type and that subclass provides the reflected method\n     for the operation, this method will be called before the left\n     operand\'s non-reflected method.  This behavior allows subclasses\n     to override their ancestors\' operations.\n\nobject.__iadd__(self, other)\nobject.__isub__(self, other)\nobject.__imul__(self, other)\nobject.__idiv__(self, other)\nobject.__itruediv__(self, other)\nobject.__ifloordiv__(self, other)\nobject.__imod__(self, other)\nobject.__ipow__(self, other[, modulo])\nobject.__ilshift__(self, other)\nobject.__irshift__(self, other)\nobject.__iand__(self, other)\nobject.__ixor__(self, other)\nobject.__ior__(self, other)\n\n   These methods are called to implement the augmented arithmetic\n   assignments ("+=", "-=", "*=", "/=", "//=", "%=", "**=", "<<=",\n   ">>=", "&=", "^=", "|=").  These methods should attempt to do the\n   operation in-place (modifying *self*) and return the result (which\n   could be, but does not have to be, *self*).  If a specific method\n   is not defined, the augmented assignment falls back to the normal\n   methods.  For instance, to execute the statement "x += y", where\n   *x* is an instance of a class that has an "__iadd__()" method,\n   "x.__iadd__(y)" is called.  If *x* is an instance of a class that\n   does not define a "__iadd__()" method, "x.__add__(y)" and\n   "y.__radd__(x)" are considered, as with the evaluation of "x + y".\n\nobject.__neg__(self)\nobject.__pos__(self)\nobject.__abs__(self)\nobject.__invert__(self)\n\n   Called to implement the unary arithmetic operations ("-", "+",\n   "abs()" and "~").\n\nobject.__complex__(self)\nobject.__int__(self)\nobject.__long__(self)\nobject.__float__(self)\n\n   Called to implement the built-in functions "complex()", "int()",\n   "long()", and "float()".  Should return a value of the appropriate\n   type.\n\nobject.__oct__(self)\nobject.__hex__(self)\n\n   Called to implement the built-in functions "oct()" and "hex()".\n   Should return a string value.\n\nobject.__index__(self)\n\n   Called to implement "operator.index()".  Also called whenever\n   Python needs an integer object (such as in slicing).  Must return\n   an integer (int or long).\n\n   New in version 2.5.\n\nobject.__coerce__(self, other)\n\n   Called to implement "mixed-mode" numeric arithmetic.  Should either\n   return a 2-tuple containing *self* and *other* converted to a\n   common numeric type, or "None" if conversion is impossible.  When\n   the common type would be the type of "other", it is sufficient to\n   return "None", since the interpreter will also ask the other object\n   to attempt a coercion (but sometimes, if the implementation of the\n   other type cannot be changed, it is useful to do the conversion to\n   the other type here).  A return value of "NotImplemented" is\n   equivalent to returning "None".\n\n\nCoercion rules\n==============\n\nThis section used to document the rules for coercion.  As the language\nhas evolved, the coercion rules have become hard to document\nprecisely; documenting what one version of one particular\nimplementation does is undesirable.  Instead, here are some informal\nguidelines regarding coercion.  In Python 3, coercion will not be\nsupported.\n\n* If the left operand of a % operator is a string or Unicode object,\n  no coercion takes place and the string formatting operation is\n  invoked instead.\n\n* It is no longer recommended to define a coercion operation. Mixed-\n  mode operations on types that don\'t define coercion pass the\n  original arguments to the operation.\n\n* New-style classes (those derived from "object") never invoke the\n  "__coerce__()" method in response to a binary operator; the only\n  time "__coerce__()" is invoked is when the built-in function\n  "coerce()" is called.\n\n* For most intents and purposes, an operator that returns\n  "NotImplemented" is treated the same as one that is not implemented\n  at all.\n\n* Below, "__op__()" and "__rop__()" are used to signify the generic\n  method names corresponding to an operator; "__iop__()" is used for\n  the corresponding in-place operator.  For example, for the operator\n  \'"+"\', "__add__()" and "__radd__()" are used for the left and right\n  variant of the binary operator, and "__iadd__()" for the in-place\n  variant.\n\n* For objects *x* and *y*, first "x.__op__(y)" is tried.  If this is\n  not implemented or returns "NotImplemented", "y.__rop__(x)" is\n  tried.  If this is also not implemented or returns "NotImplemented",\n  a "TypeError" exception is raised.  But see the following exception:\n\n* Exception to the previous item: if the left operand is an instance\n  of a built-in type or a new-style class, and the right operand is an\n  instance of a proper subclass of that type or class and overrides\n  the base\'s "__rop__()" method, the right operand\'s "__rop__()"\n  method is tried *before* the left operand\'s "__op__()" method.\n\n  This is done so that a subclass can completely override binary\n  operators. Otherwise, the left operand\'s "__op__()" method would\n  always accept the right operand: when an instance of a given class\n  is expected, an instance of a subclass of that class is always\n  acceptable.\n\n* When either operand type defines a coercion, this coercion is\n  called before that type\'s "__op__()" or "__rop__()" method is\n  called, but no sooner.  If the coercion returns an object of a\n  different type for the operand whose coercion is invoked, part of\n  the process is redone using the new object.\n\n* When an in-place operator (like \'"+="\') is used, if the left\n  operand implements "__iop__()", it is invoked without any coercion.\n  When the operation falls back to "__op__()" and/or "__rop__()", the\n  normal coercion rules apply.\n\n* In "x + y", if *x* is a sequence that implements sequence\n  concatenation, sequence concatenation is invoked.\n\n* In "x * y", if one operand is a sequence that implements sequence\n  repetition, and the other is an integer ("int" or "long"), sequence\n  repetition is invoked.\n\n* Rich comparisons (implemented by methods "__eq__()" and so on)\n  never use coercion.  Three-way comparison (implemented by\n  "__cmp__()") does use coercion under the same conditions as other\n  binary operations use it.\n\n* In the current implementation, the built-in numeric types "int",\n  "long", "float", and "complex" do not use coercion. All these types\n  implement a "__coerce__()" method, for use by the built-in\n  "coerce()" function.\n\n  Changed in version 2.7: The complex type no longer makes implicit\n  calls to the "__coerce__()" method for mixed-type binary arithmetic\n  operations.\n\n\nWith Statement Context Managers\n===============================\n\nNew in version 2.5.\n\nA *context manager* is an object that defines the runtime context to\nbe established when executing a "with" statement. The context manager\nhandles the entry into, and the exit from, the desired runtime context\nfor the execution of the block of code.  Context managers are normally\ninvoked using the "with" statement (described in section *The with\nstatement*), but can also be used by directly invoking their methods.\n\nTypical uses of context managers include saving and restoring various\nkinds of global state, locking and unlocking resources, closing opened\nfiles, etc.\n\nFor more information on context managers, see *Context Manager Types*.\n\nobject.__enter__(self)\n\n   Enter the runtime context related to this object. The "with"\n   statement will bind this method\'s return value to the target(s)\n   specified in the "as" clause of the statement, if any.\n\nobject.__exit__(self, exc_type, exc_value, traceback)\n\n   Exit the runtime context related to this object. The parameters\n   describe the exception that caused the context to be exited. If the\n   context was exited without an exception, all three arguments will\n   be "None".\n\n   If an exception is supplied, and the method wishes to suppress the\n   exception (i.e., prevent it from being propagated), it should\n   return a true value. Otherwise, the exception will be processed\n   normally upon exit from this method.\n\n   Note that "__exit__()" methods should not reraise the passed-in\n   exception; this is the caller\'s responsibility.\n\nSee also: **PEP 0343** - The "with" statement\n\n     The specification, background, and examples for the Python "with"\n     statement.\n\n\nSpecial method lookup for old-style classes\n===========================================\n\nFor old-style classes, special methods are always looked up in exactly\nthe same way as any other method or attribute. This is the case\nregardless of whether the method is being looked up explicitly as in\n"x.__getitem__(i)" or implicitly as in "x[i]".\n\nThis behaviour means that special methods may exhibit different\nbehaviour for different instances of a single old-style class if the\nappropriate special attributes are set differently:\n\n   >>> class C:\n   ...     pass\n   ...\n   >>> c1 = C()\n   >>> c2 = C()\n   >>> c1.__len__ = lambda: 5\n   >>> c2.__len__ = lambda: 9\n   >>> len(c1)\n   5\n   >>> len(c2)\n   9\n\n\nSpecial method lookup for new-style classes\n===========================================\n\nFor new-style classes, implicit invocations of special methods are\nonly guaranteed to work correctly if defined on an object\'s type, not\nin the object\'s instance dictionary.  That behaviour is the reason why\nthe following code raises an exception (unlike the equivalent example\nwith old-style classes):\n\n   >>> class C(object):\n   ...     pass\n   ...\n   >>> c = C()\n   >>> c.__len__ = lambda: 5\n   >>> len(c)\n   Traceback (most recent call last):\n     File "<stdin>", line 1, in <module>\n   TypeError: object of type \'C\' has no len()\n\nThe rationale behind this behaviour lies with a number of special\nmethods such as "__hash__()" and "__repr__()" that are implemented by\nall objects, including type objects. If the implicit lookup of these\nmethods used the conventional lookup process, they would fail when\ninvoked on the type object itself:\n\n   >>> 1 .__hash__() == hash(1)\n   True\n   >>> int.__hash__() == hash(int)\n   Traceback (most recent call last):\n     File "<stdin>", line 1, in <module>\n   TypeError: descriptor \'__hash__\' of \'int\' object needs an argument\n\nIncorrectly attempting to invoke an unbound method of a class in this\nway is sometimes referred to as \'metaclass confusion\', and is avoided\nby bypassing the instance when looking up special methods:\n\n   >>> type(1).__hash__(1) == hash(1)\n   True\n   >>> type(int).__hash__(int) == hash(int)\n   True\n\nIn addition to bypassing any instance attributes in the interest of\ncorrectness, implicit special method lookup generally also bypasses\nthe "__getattribute__()" method even of the object\'s metaclass:\n\n   >>> class Meta(type):\n   ...    def __getattribute__(*args):\n   ...       print "Metaclass getattribute invoked"\n   ...       return type.__getattribute__(*args)\n   ...\n   >>> class C(object):\n   ...     __metaclass__ = Meta\n   ...     def __len__(self):\n   ...         return 10\n   ...     def __getattribute__(*args):\n   ...         print "Class getattribute invoked"\n   ...         return object.__getattribute__(*args)\n   ...\n   >>> c = C()\n   >>> c.__len__()                 # Explicit lookup via instance\n   Class getattribute invoked\n   10\n   >>> type(c).__len__(c)          # Explicit lookup via type\n   Metaclass getattribute invoked\n   10\n   >>> len(c)                      # Implicit lookup\n   10\n\nBypassing the "__getattribute__()" machinery in this fashion provides\nsignificant scope for speed optimisations within the interpreter, at\nthe cost of some flexibility in the handling of special methods (the\nspecial method *must* be set on the class object itself in order to be\nconsistently invoked by the interpreter).\n\n-[ Footnotes ]-\n\n[1] It *is* possible in some cases to change an object\'s type,\n    under certain controlled conditions. It generally isn\'t a good\n    idea though, since it can lead to some very strange behaviour if\n    it is handled incorrectly.\n\n[2] For operands of the same type, it is assumed that if the non-\n    reflected method (such as "__add__()") fails the operation is not\n    supported, which is why the reflected method is not called.\n',
 'string-methods': u'\nString Methods\n**************\n\nBelow are listed the string methods which both 8-bit strings and\nUnicode objects support.  Some of them are also available on\n"bytearray" objects.\n\nIn addition, Python\'s strings support the sequence type methods\ndescribed in the *Sequence Types --- str, unicode, list, tuple,\nbytearray, buffer, xrange* section. To output formatted strings use\ntemplate strings or the "%" operator described in the *String\nFormatting Operations* section. Also, see the "re" module for string\nfunctions based on regular expressions.\n\nstr.capitalize()\n\n   Return a copy of the string with its first character capitalized\n   and the rest lowercased.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.center(width[, fillchar])\n\n   Return centered in a string of length *width*. Padding is done\n   using the specified *fillchar* (default is a space).\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.count(sub[, start[, end]])\n\n   Return the number of non-overlapping occurrences of substring *sub*\n   in the range [*start*, *end*].  Optional arguments *start* and\n   *end* are interpreted as in slice notation.\n\nstr.decode([encoding[, errors]])\n\n   Decodes the string using the codec registered for *encoding*.\n   *encoding* defaults to the default string encoding.  *errors* may\n   be given to set a different error handling scheme.  The default is\n   "\'strict\'", meaning that encoding errors raise "UnicodeError".\n   Other possible values are "\'ignore\'", "\'replace\'" and any other\n   name registered via "codecs.register_error()", see section *Codec\n   Base Classes*.\n\n   New in version 2.2.\n\n   Changed in version 2.3: Support for other error handling schemes\n   added.\n\n   Changed in version 2.7: Support for keyword arguments added.\n\nstr.encode([encoding[, errors]])\n\n   Return an encoded version of the string.  Default encoding is the\n   current default string encoding.  *errors* may be given to set a\n   different error handling scheme.  The default for *errors* is\n   "\'strict\'", meaning that encoding errors raise a "UnicodeError".\n   Other possible values are "\'ignore\'", "\'replace\'",\n   "\'xmlcharrefreplace\'", "\'backslashreplace\'" and any other name\n   registered via "codecs.register_error()", see section *Codec Base\n   Classes*. For a list of possible encodings, see section *Standard\n   Encodings*.\n\n   New in version 2.0.\n\n   Changed in version 2.3: Support for "\'xmlcharrefreplace\'" and\n   "\'backslashreplace\'" and other error handling schemes added.\n\n   Changed in version 2.7: Support for keyword arguments added.\n\nstr.endswith(suffix[, start[, end]])\n\n   Return "True" if the string ends with the specified *suffix*,\n   otherwise return "False".  *suffix* can also be a tuple of suffixes\n   to look for.  With optional *start*, test beginning at that\n   position.  With optional *end*, stop comparing at that position.\n\n   Changed in version 2.5: Accept tuples as *suffix*.\n\nstr.expandtabs([tabsize])\n\n   Return a copy of the string where all tab characters are replaced\n   by one or more spaces, depending on the current column and the\n   given tab size.  Tab positions occur every *tabsize* characters\n   (default is 8, giving tab positions at columns 0, 8, 16 and so on).\n   To expand the string, the current column is set to zero and the\n   string is examined character by character.  If the character is a\n   tab ("\\t"), one or more space characters are inserted in the result\n   until the current column is equal to the next tab position. (The\n   tab character itself is not copied.)  If the character is a newline\n   ("\\n") or return ("\\r"), it is copied and the current column is\n   reset to zero.  Any other character is copied unchanged and the\n   current column is incremented by one regardless of how the\n   character is represented when printed.\n\n   >>> \'01\\t012\\t0123\\t01234\'.expandtabs()\n   \'01      012     0123    01234\'\n   >>> \'01\\t012\\t0123\\t01234\'.expandtabs(4)\n   \'01  012 0123    01234\'\n\nstr.find(sub[, start[, end]])\n\n   Return the lowest index in the string where substring *sub* is\n   found, such that *sub* is contained in the slice "s[start:end]".\n   Optional arguments *start* and *end* are interpreted as in slice\n   notation.  Return "-1" if *sub* is not found.\n\n   Note: The "find()" method should be used only if you need to know\n     the position of *sub*.  To check if *sub* is a substring or not,\n     use the "in" operator:\n\n        >>> \'Py\' in \'Python\'\n        True\n\nstr.format(*args, **kwargs)\n\n   Perform a string formatting operation.  The string on which this\n   method is called can contain literal text or replacement fields\n   delimited by braces "{}".  Each replacement field contains either\n   the numeric index of a positional argument, or the name of a\n   keyword argument.  Returns a copy of the string where each\n   replacement field is replaced with the string value of the\n   corresponding argument.\n\n   >>> "The sum of 1 + 2 is {0}".format(1+2)\n   \'The sum of 1 + 2 is 3\'\n\n   See *Format String Syntax* for a description of the various\n   formatting options that can be specified in format strings.\n\n   This method of string formatting is the new standard in Python 3,\n   and should be preferred to the "%" formatting described in *String\n   Formatting Operations* in new code.\n\n   New in version 2.6.\n\nstr.index(sub[, start[, end]])\n\n   Like "find()", but raise "ValueError" when the substring is not\n   found.\n\nstr.isalnum()\n\n   Return true if all characters in the string are alphanumeric and\n   there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isalpha()\n\n   Return true if all characters in the string are alphabetic and\n   there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isdigit()\n\n   Return true if all characters in the string are digits and there is\n   at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.islower()\n\n   Return true if all cased characters [4] in the string are lowercase\n   and there is at least one cased character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isspace()\n\n   Return true if there are only whitespace characters in the string\n   and there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.istitle()\n\n   Return true if the string is a titlecased string and there is at\n   least one character, for example uppercase characters may only\n   follow uncased characters and lowercase characters only cased ones.\n   Return false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isupper()\n\n   Return true if all cased characters [4] in the string are uppercase\n   and there is at least one cased character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.join(iterable)\n\n   Return a string which is the concatenation of the strings in the\n   *iterable* *iterable*.  The separator between elements is the\n   string providing this method.\n\nstr.ljust(width[, fillchar])\n\n   Return the string left justified in a string of length *width*.\n   Padding is done using the specified *fillchar* (default is a\n   space).  The original string is returned if *width* is less than or\n   equal to "len(s)".\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.lower()\n\n   Return a copy of the string with all the cased characters [4]\n   converted to lowercase.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.lstrip([chars])\n\n   Return a copy of the string with leading characters removed.  The\n   *chars* argument is a string specifying the set of characters to be\n   removed.  If omitted or "None", the *chars* argument defaults to\n   removing whitespace.  The *chars* argument is not a prefix; rather,\n   all combinations of its values are stripped:\n\n   >>> \'   spacious   \'.lstrip()\n   \'spacious   \'\n   >>> \'www.example.com\'.lstrip(\'cmowz.\')\n   \'example.com\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.partition(sep)\n\n   Split the string at the first occurrence of *sep*, and return a\n   3-tuple containing the part before the separator, the separator\n   itself, and the part after the separator.  If the separator is not\n   found, return a 3-tuple containing the string itself, followed by\n   two empty strings.\n\n   New in version 2.5.\n\nstr.replace(old, new[, count])\n\n   Return a copy of the string with all occurrences of substring *old*\n   replaced by *new*.  If the optional argument *count* is given, only\n   the first *count* occurrences are replaced.\n\nstr.rfind(sub[, start[, end]])\n\n   Return the highest index in the string where substring *sub* is\n   found, such that *sub* is contained within "s[start:end]".\n   Optional arguments *start* and *end* are interpreted as in slice\n   notation.  Return "-1" on failure.\n\nstr.rindex(sub[, start[, end]])\n\n   Like "rfind()" but raises "ValueError" when the substring *sub* is\n   not found.\n\nstr.rjust(width[, fillchar])\n\n   Return the string right justified in a string of length *width*.\n   Padding is done using the specified *fillchar* (default is a\n   space). The original string is returned if *width* is less than or\n   equal to "len(s)".\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.rpartition(sep)\n\n   Split the string at the last occurrence of *sep*, and return a\n   3-tuple containing the part before the separator, the separator\n   itself, and the part after the separator.  If the separator is not\n   found, return a 3-tuple containing two empty strings, followed by\n   the string itself.\n\n   New in version 2.5.\n\nstr.rsplit([sep[, maxsplit]])\n\n   Return a list of the words in the string, using *sep* as the\n   delimiter string. If *maxsplit* is given, at most *maxsplit* splits\n   are done, the *rightmost* ones.  If *sep* is not specified or\n   "None", any whitespace string is a separator.  Except for splitting\n   from the right, "rsplit()" behaves like "split()" which is\n   described in detail below.\n\n   New in version 2.4.\n\nstr.rstrip([chars])\n\n   Return a copy of the string with trailing characters removed.  The\n   *chars* argument is a string specifying the set of characters to be\n   removed.  If omitted or "None", the *chars* argument defaults to\n   removing whitespace.  The *chars* argument is not a suffix; rather,\n   all combinations of its values are stripped:\n\n   >>> \'   spacious   \'.rstrip()\n   \'   spacious\'\n   >>> \'mississippi\'.rstrip(\'ipz\')\n   \'mississ\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.split([sep[, maxsplit]])\n\n   Return a list of the words in the string, using *sep* as the\n   delimiter string.  If *maxsplit* is given, at most *maxsplit*\n   splits are done (thus, the list will have at most "maxsplit+1"\n   elements).  If *maxsplit* is not specified or "-1", then there is\n   no limit on the number of splits (all possible splits are made).\n\n   If *sep* is given, consecutive delimiters are not grouped together\n   and are deemed to delimit empty strings (for example,\n   "\'1,,2\'.split(\',\')" returns "[\'1\', \'\', \'2\']").  The *sep* argument\n   may consist of multiple characters (for example,\n   "\'1<>2<>3\'.split(\'<>\')" returns "[\'1\', \'2\', \'3\']"). Splitting an\n   empty string with a specified separator returns "[\'\']".\n\n   If *sep* is not specified or is "None", a different splitting\n   algorithm is applied: runs of consecutive whitespace are regarded\n   as a single separator, and the result will contain no empty strings\n   at the start or end if the string has leading or trailing\n   whitespace.  Consequently, splitting an empty string or a string\n   consisting of just whitespace with a "None" separator returns "[]".\n\n   For example, "\' 1  2   3  \'.split()" returns "[\'1\', \'2\', \'3\']", and\n   "\'  1  2   3  \'.split(None, 1)" returns "[\'1\', \'2   3  \']".\n\nstr.splitlines([keepends])\n\n   Return a list of the lines in the string, breaking at line\n   boundaries. This method uses the *universal newlines* approach to\n   splitting lines. Line breaks are not included in the resulting list\n   unless *keepends* is given and true.\n\n   For example, "\'ab c\\n\\nde fg\\rkl\\r\\n\'.splitlines()" returns "[\'ab\n   c\', \'\', \'de fg\', \'kl\']", while the same call with\n   "splitlines(True)" returns "[\'ab c\\n\', \'\\n\', \'de fg\\r\', \'kl\\r\\n\']".\n\n   Unlike "split()" when a delimiter string *sep* is given, this\n   method returns an empty list for the empty string, and a terminal\n   line break does not result in an extra line.\n\nstr.startswith(prefix[, start[, end]])\n\n   Return "True" if string starts with the *prefix*, otherwise return\n   "False". *prefix* can also be a tuple of prefixes to look for.\n   With optional *start*, test string beginning at that position.\n   With optional *end*, stop comparing string at that position.\n\n   Changed in version 2.5: Accept tuples as *prefix*.\n\nstr.strip([chars])\n\n   Return a copy of the string with the leading and trailing\n   characters removed. The *chars* argument is a string specifying the\n   set of characters to be removed. If omitted or "None", the *chars*\n   argument defaults to removing whitespace. The *chars* argument is\n   not a prefix or suffix; rather, all combinations of its values are\n   stripped:\n\n   >>> \'   spacious   \'.strip()\n   \'spacious\'\n   >>> \'www.example.com\'.strip(\'cmowz.\')\n   \'example\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.swapcase()\n\n   Return a copy of the string with uppercase characters converted to\n   lowercase and vice versa.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.title()\n\n   Return a titlecased version of the string where words start with an\n   uppercase character and the remaining characters are lowercase.\n\n   The algorithm uses a simple language-independent definition of a\n   word as groups of consecutive letters.  The definition works in\n   many contexts but it means that apostrophes in contractions and\n   possessives form word boundaries, which may not be the desired\n   result:\n\n      >>> "they\'re bill\'s friends from the UK".title()\n      "They\'Re Bill\'S Friends From The Uk"\n\n   A workaround for apostrophes can be constructed using regular\n   expressions:\n\n      >>> import re\n      >>> def titlecase(s):\n      ...     return re.sub(r"[A-Za-z]+(\'[A-Za-z]+)?",\n      ...                   lambda mo: mo.group(0)[0].upper() +\n      ...                              mo.group(0)[1:].lower(),\n      ...                   s)\n      ...\n      >>> titlecase("they\'re bill\'s friends.")\n      "They\'re Bill\'s Friends."\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.translate(table[, deletechars])\n\n   Return a copy of the string where all characters occurring in the\n   optional argument *deletechars* are removed, and the remaining\n   characters have been mapped through the given translation table,\n   which must be a string of length 256.\n\n   You can use the "maketrans()" helper function in the "string"\n   module to create a translation table. For string objects, set the\n   *table* argument to "None" for translations that only delete\n   characters:\n\n   >>> \'read this short text\'.translate(None, \'aeiou\')\n   \'rd ths shrt txt\'\n\n   New in version 2.6: Support for a "None" *table* argument.\n\n   For Unicode objects, the "translate()" method does not accept the\n   optional *deletechars* argument.  Instead, it returns a copy of the\n   *s* where all characters have been mapped through the given\n   translation table which must be a mapping of Unicode ordinals to\n   Unicode ordinals, Unicode strings or "None". Unmapped characters\n   are left untouched. Characters mapped to "None" are deleted.  Note,\n   a more flexible approach is to create a custom character mapping\n   codec using the "codecs" module (see "encodings.cp1251" for an\n   example).\n\nstr.upper()\n\n   Return a copy of the string with all the cased characters [4]\n   converted to uppercase.  Note that "str.upper().isupper()" might be\n   "False" if "s" contains uncased characters or if the Unicode\n   category of the resulting character(s) is not "Lu" (Letter,\n   uppercase), but e.g. "Lt" (Letter, titlecase).\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.zfill(width)\n\n   Return the numeric string left filled with zeros in a string of\n   length *width*.  A sign prefix is handled correctly.  The original\n   string is returned if *width* is less than or equal to "len(s)".\n\n   New in version 2.2.2.\n\nThe following methods are present only on unicode objects:\n\nunicode.isnumeric()\n\n   Return "True" if there are only numeric characters in S, "False"\n   otherwise. Numeric characters include digit characters, and all\n   characters that have the Unicode numeric value property, e.g.\n   U+2155, VULGAR FRACTION ONE FIFTH.\n\nunicode.isdecimal()\n\n   Return "True" if there are only decimal characters in S, "False"\n   otherwise. Decimal characters include digit characters, and all\n   characters that can be used to form decimal-radix numbers, e.g.\n   U+0660, ARABIC-INDIC DIGIT ZERO.\n',
 'strings': u'\nString literals\n***************\n\nString literals are described by the following lexical definitions:\n\n   stringliteral   ::= [stringprefix](shortstring | longstring)\n   stringprefix    ::= "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"\n                    | "b" | "B" | "br" | "Br" | "bR" | "BR"\n   shortstring     ::= "\'" shortstringitem* "\'" | \'"\' shortstringitem* \'"\'\n   longstring      ::= "\'\'\'" longstringitem* "\'\'\'"\n                  | \'"""\' longstringitem* \'"""\'\n   shortstringitem ::= shortstringchar | escapeseq\n   longstringitem  ::= longstringchar | escapeseq\n   shortstringchar ::= <any source character except "\\" or newline or the quote>\n   longstringchar  ::= <any source character except "\\">\n   escapeseq       ::= "\\" <any ASCII character>\n\nOne syntactic restriction not indicated by these productions is that\nwhitespace is not allowed between the "stringprefix" and the rest of\nthe string literal. The source character set is defined by the\nencoding declaration; it is ASCII if no encoding declaration is given\nin the source file; see section *Encoding declarations*.\n\nIn plain English: String literals can be enclosed in matching single\nquotes ("\'") or double quotes (""").  They can also be enclosed in\nmatching groups of three single or double quotes (these are generally\nreferred to as *triple-quoted strings*).  The backslash ("\\")\ncharacter is used to escape characters that otherwise have a special\nmeaning, such as newline, backslash itself, or the quote character.\nString literals may optionally be prefixed with a letter "\'r\'" or\n"\'R\'"; such strings are called *raw strings* and use different rules\nfor interpreting backslash escape sequences.  A prefix of "\'u\'" or\n"\'U\'" makes the string a Unicode string.  Unicode strings use the\nUnicode character set as defined by the Unicode Consortium and ISO\n10646.  Some additional escape sequences, described below, are\navailable in Unicode strings. A prefix of "\'b\'" or "\'B\'" is ignored in\nPython 2; it indicates that the literal should become a bytes literal\nin Python 3 (e.g. when code is automatically converted with 2to3).  A\n"\'u\'" or "\'b\'" prefix may be followed by an "\'r\'" prefix.\n\nIn triple-quoted strings, unescaped newlines and quotes are allowed\n(and are retained), except that three unescaped quotes in a row\nterminate the string.  (A "quote" is the character used to open the\nstring, i.e. either "\'" or """.)\n\nUnless an "\'r\'" or "\'R\'" prefix is present, escape sequences in\nstrings are interpreted according to rules similar to those used by\nStandard C.  The recognized escape sequences are:\n\n+-------------------+-----------------------------------+---------+\n| Escape Sequence   | Meaning                           | Notes   |\n+===================+===================================+=========+\n| "\\newline"        | Ignored                           |         |\n+-------------------+-----------------------------------+---------+\n| "\\\\"              | Backslash ("\\")                   |         |\n+-------------------+-----------------------------------+---------+\n| "\\\'"              | Single quote ("\'")                |         |\n+-------------------+-----------------------------------+---------+\n| "\\""              | Double quote (""")                |         |\n+-------------------+-----------------------------------+---------+\n| "\\a"              | ASCII Bell (BEL)                  |         |\n+-------------------+-----------------------------------+---------+\n| "\\b"              | ASCII Backspace (BS)              |         |\n+-------------------+-----------------------------------+---------+\n| "\\f"              | ASCII Formfeed (FF)               |         |\n+-------------------+-----------------------------------+---------+\n| "\\n"              | ASCII Linefeed (LF)               |         |\n+-------------------+-----------------------------------+---------+\n| "\\N{name}"        | Character named *name* in the     |         |\n|                   | Unicode database (Unicode only)   |         |\n+-------------------+-----------------------------------+---------+\n| "\\r"              | ASCII Carriage Return (CR)        |         |\n+-------------------+-----------------------------------+---------+\n| "\\t"              | ASCII Horizontal Tab (TAB)        |         |\n+-------------------+-----------------------------------+---------+\n| "\\uxxxx"          | Character with 16-bit hex value   | (1)     |\n|                   | *xxxx* (Unicode only)             |         |\n+-------------------+-----------------------------------+---------+\n| "\\Uxxxxxxxx"      | Character with 32-bit hex value   | (2)     |\n|                   | *xxxxxxxx* (Unicode only)         |         |\n+-------------------+-----------------------------------+---------+\n| "\\v"              | ASCII Vertical Tab (VT)           |         |\n+-------------------+-----------------------------------+---------+\n| "\\ooo"            | Character with octal value *ooo*  | (3,5)   |\n+-------------------+-----------------------------------+---------+\n| "\\xhh"            | Character with hex value *hh*     | (4,5)   |\n+-------------------+-----------------------------------+---------+\n\nNotes:\n\n1. Individual code units which form parts of a surrogate pair can\n   be encoded using this escape sequence.\n\n2. Any Unicode character can be encoded this way, but characters\n   outside the Basic Multilingual Plane (BMP) will be encoded using a\n   surrogate pair if Python is compiled to use 16-bit code units (the\n   default).\n\n3. As in Standard C, up to three octal digits are accepted.\n\n4. Unlike in Standard C, exactly two hex digits are required.\n\n5. In a string literal, hexadecimal and octal escapes denote the\n   byte with the given value; it is not necessary that the byte\n   encodes a character in the source character set. In a Unicode\n   literal, these escapes denote a Unicode character with the given\n   value.\n\nUnlike Standard C, all unrecognized escape sequences are left in the\nstring unchanged, i.e., *the backslash is left in the string*.  (This\nbehavior is useful when debugging: if an escape sequence is mistyped,\nthe resulting output is more easily recognized as broken.)  It is also\nimportant to note that the escape sequences marked as "(Unicode only)"\nin the table above fall into the category of unrecognized escapes for\nnon-Unicode string literals.\n\nWhen an "\'r\'" or "\'R\'" prefix is present, a character following a\nbackslash is included in the string without change, and *all\nbackslashes are left in the string*.  For example, the string literal\n"r"\\n"" consists of two characters: a backslash and a lowercase "\'n\'".\nString quotes can be escaped with a backslash, but the backslash\nremains in the string; for example, "r"\\""" is a valid string literal\nconsisting of two characters: a backslash and a double quote; "r"\\""\nis not a valid string literal (even a raw string cannot end in an odd\nnumber of backslashes).  Specifically, *a raw string cannot end in a\nsingle backslash* (since the backslash would escape the following\nquote character).  Note also that a single backslash followed by a\nnewline is interpreted as those two characters as part of the string,\n*not* as a line continuation.\n\nWhen an "\'r\'" or "\'R\'" prefix is used in conjunction with a "\'u\'" or\n"\'U\'" prefix, then the "\\uXXXX" and "\\UXXXXXXXX" escape sequences are\nprocessed while  *all other backslashes are left in the string*. For\nexample, the string literal "ur"\\u0062\\n"" consists of three Unicode\ncharacters: \'LATIN SMALL LETTER B\', \'REVERSE SOLIDUS\', and \'LATIN\nSMALL LETTER N\'. Backslashes can be escaped with a preceding\nbackslash; however, both remain in the string.  As a result, "\\uXXXX"\nescape sequences are only recognized when there are an odd number of\nbackslashes.\n',
 'subscriptions': u'\nSubscriptions\n*************\n\nA subscription selects an item of a sequence (string, tuple or list)\nor mapping (dictionary) object:\n\n   subscription ::= primary "[" expression_list "]"\n\nThe primary must evaluate to an object of a sequence or mapping type.\n\nIf the primary is a mapping, the expression list must evaluate to an\nobject whose value is one of the keys of the mapping, and the\nsubscription selects the value in the mapping that corresponds to that\nkey.  (The expression list is a tuple except if it has exactly one\nitem.)\n\nIf the primary is a sequence, the expression (list) must evaluate to a\nplain integer.  If this value is negative, the length of the sequence\nis added to it (so that, e.g., "x[-1]" selects the last item of "x".)\nThe resulting value must be a nonnegative integer less than the number\nof items in the sequence, and the subscription selects the item whose\nindex is that value (counting from zero).\n\nA string\'s items are characters.  A character is not a separate data\ntype but a string of exactly one character.\n',
 'truth': u'\nTruth Value Testing\n*******************\n\nAny object can be tested for truth value, for use in an "if" or\n"while" condition or as operand of the Boolean operations below. The\nfollowing values are considered false:\n\n* "None"\n\n* "False"\n\n* zero of any numeric type, for example, "0", "0L", "0.0", "0j".\n\n* any empty sequence, for example, "\'\'", "()", "[]".\n\n* any empty mapping, for example, "{}".\n\n* instances of user-defined classes, if the class defines a\n  "__nonzero__()" or "__len__()" method, when that method returns the\n  integer zero or "bool" value "False". [1]\n\nAll other values are considered true --- so objects of many types are\nalways true.\n\nOperations and built-in functions that have a Boolean result always\nreturn "0" or "False" for false and "1" or "True" for true, unless\notherwise stated. (Important exception: the Boolean operations "or"\nand "and" always return one of their operands.)\n',
 'try': u'\nThe "try" statement\n*******************\n\nThe "try" statement specifies exception handlers and/or cleanup code\nfor a group of statements:\n\n   try_stmt  ::= try1_stmt | try2_stmt\n   try1_stmt ::= "try" ":" suite\n                 ("except" [expression [("as" | ",") identifier]] ":" suite)+\n                 ["else" ":" suite]\n                 ["finally" ":" suite]\n   try2_stmt ::= "try" ":" suite\n                 "finally" ":" suite\n\nChanged in version 2.5: In previous versions of Python,\n"try"..."except"..."finally" did not work. "try"..."except" had to be\nnested in "try"..."finally".\n\nThe "except" clause(s) specify one or more exception handlers. When no\nexception occurs in the "try" clause, no exception handler is\nexecuted. When an exception occurs in the "try" suite, a search for an\nexception handler is started.  This search inspects the except clauses\nin turn until one is found that matches the exception.  An expression-\nless except clause, if present, must be last; it matches any\nexception.  For an except clause with an expression, that expression\nis evaluated, and the clause matches the exception if the resulting\nobject is "compatible" with the exception.  An object is compatible\nwith an exception if it is the class or a base class of the exception\nobject, or a tuple containing an item compatible with the exception.\n\nIf no except clause matches the exception, the search for an exception\nhandler continues in the surrounding code and on the invocation stack.\n[1]\n\nIf the evaluation of an expression in the header of an except clause\nraises an exception, the original search for a handler is canceled and\na search starts for the new exception in the surrounding code and on\nthe call stack (it is treated as if the entire "try" statement raised\nthe exception).\n\nWhen a matching except clause is found, the exception is assigned to\nthe target specified in that except clause, if present, and the except\nclause\'s suite is executed.  All except clauses must have an\nexecutable block.  When the end of this block is reached, execution\ncontinues normally after the entire try statement.  (This means that\nif two nested handlers exist for the same exception, and the exception\noccurs in the try clause of the inner handler, the outer handler will\nnot handle the exception.)\n\nBefore an except clause\'s suite is executed, details about the\nexception are assigned to three variables in the "sys" module:\n"sys.exc_type" receives the object identifying the exception;\n"sys.exc_value" receives the exception\'s parameter;\n"sys.exc_traceback" receives a traceback object (see section *The\nstandard type hierarchy*) identifying the point in the program where\nthe exception occurred. These details are also available through the\n"sys.exc_info()" function, which returns a tuple "(exc_type,\nexc_value, exc_traceback)".  Use of the corresponding variables is\ndeprecated in favor of this function, since their use is unsafe in a\nthreaded program.  As of Python 1.5, the variables are restored to\ntheir previous values (before the call) when returning from a function\nthat handled an exception.\n\nThe optional "else" clause is executed if and when control flows off\nthe end of the "try" clause. [2] Exceptions in the "else" clause are\nnot handled by the preceding "except" clauses.\n\nIf "finally" is present, it specifies a \'cleanup\' handler.  The "try"\nclause is executed, including any "except" and "else" clauses.  If an\nexception occurs in any of the clauses and is not handled, the\nexception is temporarily saved. The "finally" clause is executed.  If\nthere is a saved exception, it is re-raised at the end of the\n"finally" clause. If the "finally" clause raises another exception or\nexecutes a "return" or "break" statement, the saved exception is\ndiscarded:\n\n   >>> def f():\n   ...     try:\n   ...         1/0\n   ...     finally:\n   ...         return 42\n   ...\n   >>> f()\n   42\n\nThe exception information is not available to the program during\nexecution of the "finally" clause.\n\nWhen a "return", "break" or "continue" statement is executed in the\n"try" suite of a "try"..."finally" statement, the "finally" clause is\nalso executed \'on the way out.\' A "continue" statement is illegal in\nthe "finally" clause. (The reason is a problem with the current\nimplementation --- this restriction may be lifted in the future).\n\nThe return value of a function is determined by the last "return"\nstatement executed.  Since the "finally" clause always executes, a\n"return" statement executed in the "finally" clause will always be the\nlast one executed:\n\n   >>> def foo():\n   ...     try:\n   ...         return \'try\'\n   ...     finally:\n   ...         return \'finally\'\n   ...\n   >>> foo()\n   \'finally\'\n\nAdditional information on exceptions can be found in section\n*Exceptions*, and information on using the "raise" statement to\ngenerate exceptions may be found in section *The raise statement*.\n',
 'types': u'\nThe standard type hierarchy\n***************************\n\nBelow is a list of the types that are built into Python.  Extension\nmodules (written in C, Java, or other languages, depending on the\nimplementation) can define additional types.  Future versions of\nPython may add types to the type hierarchy (e.g., rational numbers,\nefficiently stored arrays of integers, etc.).\n\nSome of the type descriptions below contain a paragraph listing\n\'special attributes.\'  These are attributes that provide access to the\nimplementation and are not intended for general use.  Their definition\nmay change in the future.\n\nNone\n   This type has a single value.  There is a single object with this\n   value. This object is accessed through the built-in name "None". It\n   is used to signify the absence of a value in many situations, e.g.,\n   it is returned from functions that don\'t explicitly return\n   anything. Its truth value is false.\n\nNotImplemented\n   This type has a single value.  There is a single object with this\n   value. This object is accessed through the built-in name\n   "NotImplemented". Numeric methods and rich comparison methods may\n   return this value if they do not implement the operation for the\n   operands provided.  (The interpreter will then try the reflected\n   operation, or some other fallback, depending on the operator.)  Its\n   truth value is true.\n\nEllipsis\n   This type has a single value.  There is a single object with this\n   value. This object is accessed through the built-in name\n   "Ellipsis". It is used to indicate the presence of the "..." syntax\n   in a slice.  Its truth value is true.\n\n"numbers.Number"\n   These are created by numeric literals and returned as results by\n   arithmetic operators and arithmetic built-in functions.  Numeric\n   objects are immutable; once created their value never changes.\n   Python numbers are of course strongly related to mathematical\n   numbers, but subject to the limitations of numerical representation\n   in computers.\n\n   Python distinguishes between integers, floating point numbers, and\n   complex numbers:\n\n   "numbers.Integral"\n      These represent elements from the mathematical set of integers\n      (positive and negative).\n\n      There are three types of integers:\n\n      Plain integers\n         These represent numbers in the range -2147483648 through\n         2147483647. (The range may be larger on machines with a\n         larger natural word size, but not smaller.)  When the result\n         of an operation would fall outside this range, the result is\n         normally returned as a long integer (in some cases, the\n         exception "OverflowError" is raised instead).  For the\n         purpose of shift and mask operations, integers are assumed to\n         have a binary, 2\'s complement notation using 32 or more bits,\n         and hiding no bits from the user (i.e., all 4294967296\n         different bit patterns correspond to different values).\n\n      Long integers\n         These represent numbers in an unlimited range, subject to\n         available (virtual) memory only.  For the purpose of shift\n         and mask operations, a binary representation is assumed, and\n         negative numbers are represented in a variant of 2\'s\n         complement which gives the illusion of an infinite string of\n         sign bits extending to the left.\n\n      Booleans\n         These represent the truth values False and True.  The two\n         objects representing the values "False" and "True" are the\n         only Boolean objects. The Boolean type is a subtype of plain\n         integers, and Boolean values behave like the values 0 and 1,\n         respectively, in almost all contexts, the exception being\n         that when converted to a string, the strings ""False"" or\n         ""True"" are returned, respectively.\n\n      The rules for integer representation are intended to give the\n      most meaningful interpretation of shift and mask operations\n      involving negative integers and the least surprises when\n      switching between the plain and long integer domains.  Any\n      operation, if it yields a result in the plain integer domain,\n      will yield the same result in the long integer domain or when\n      using mixed operands.  The switch between domains is transparent\n      to the programmer.\n\n   "numbers.Real" ("float")\n      These represent machine-level double precision floating point\n      numbers. You are at the mercy of the underlying machine\n      architecture (and C or Java implementation) for the accepted\n      range and handling of overflow. Python does not support single-\n      precision floating point numbers; the savings in processor and\n      memory usage that are usually the reason for using these are\n      dwarfed by the overhead of using objects in Python, so there is\n      no reason to complicate the language with two kinds of floating\n      point numbers.\n\n   "numbers.Complex"\n      These represent complex numbers as a pair of machine-level\n      double precision floating point numbers.  The same caveats apply\n      as for floating point numbers. The real and imaginary parts of a\n      complex number "z" can be retrieved through the read-only\n      attributes "z.real" and "z.imag".\n\nSequences\n   These represent finite ordered sets indexed by non-negative\n   numbers. The built-in function "len()" returns the number of items\n   of a sequence. When the length of a sequence is *n*, the index set\n   contains the numbers 0, 1, ..., *n*-1.  Item *i* of sequence *a* is\n   selected by "a[i]".\n\n   Sequences also support slicing: "a[i:j]" selects all items with\n   index *k* such that *i* "<=" *k* "<" *j*.  When used as an\n   expression, a slice is a sequence of the same type.  This implies\n   that the index set is renumbered so that it starts at 0.\n\n   Some sequences also support "extended slicing" with a third "step"\n   parameter: "a[i:j:k]" selects all items of *a* with index *x* where\n   "x = i + n*k", *n* ">=" "0" and *i* "<=" *x* "<" *j*.\n\n   Sequences are distinguished according to their mutability:\n\n   Immutable sequences\n      An object of an immutable sequence type cannot change once it is\n      created.  (If the object contains references to other objects,\n      these other objects may be mutable and may be changed; however,\n      the collection of objects directly referenced by an immutable\n      object cannot change.)\n\n      The following types are immutable sequences:\n\n      Strings\n         The items of a string are characters.  There is no separate\n         character type; a character is represented by a string of one\n         item. Characters represent (at least) 8-bit bytes.  The\n         built-in functions "chr()" and "ord()" convert between\n         characters and nonnegative integers representing the byte\n         values.  Bytes with the values 0-127 usually represent the\n         corresponding ASCII values, but the interpretation of values\n         is up to the program.  The string data type is also used to\n         represent arrays of bytes, e.g., to hold data read from a\n         file.\n\n         (On systems whose native character set is not ASCII, strings\n         may use EBCDIC in their internal representation, provided the\n         functions "chr()" and "ord()" implement a mapping between\n         ASCII and EBCDIC, and string comparison preserves the ASCII\n         order. Or perhaps someone can propose a better rule?)\n\n      Unicode\n         The items of a Unicode object are Unicode code units.  A\n         Unicode code unit is represented by a Unicode object of one\n         item and can hold either a 16-bit or 32-bit value\n         representing a Unicode ordinal (the maximum value for the\n         ordinal is given in "sys.maxunicode", and depends on how\n         Python is configured at compile time).  Surrogate pairs may\n         be present in the Unicode object, and will be reported as two\n         separate items.  The built-in functions "unichr()" and\n         "ord()" convert between code units and nonnegative integers\n         representing the Unicode ordinals as defined in the Unicode\n         Standard 3.0. Conversion from and to other encodings are\n         possible through the Unicode method "encode()" and the built-\n         in function "unicode()".\n\n      Tuples\n         The items of a tuple are arbitrary Python objects. Tuples of\n         two or more items are formed by comma-separated lists of\n         expressions.  A tuple of one item (a \'singleton\') can be\n         formed by affixing a comma to an expression (an expression by\n         itself does not create a tuple, since parentheses must be\n         usable for grouping of expressions).  An empty tuple can be\n         formed by an empty pair of parentheses.\n\n   Mutable sequences\n      Mutable sequences can be changed after they are created.  The\n      subscription and slicing notations can be used as the target of\n      assignment and "del" (delete) statements.\n\n      There are currently two intrinsic mutable sequence types:\n\n      Lists\n         The items of a list are arbitrary Python objects.  Lists are\n         formed by placing a comma-separated list of expressions in\n         square brackets. (Note that there are no special cases needed\n         to form lists of length 0 or 1.)\n\n      Byte Arrays\n         A bytearray object is a mutable array. They are created by\n         the built-in "bytearray()" constructor.  Aside from being\n         mutable (and hence unhashable), byte arrays otherwise provide\n         the same interface and functionality as immutable bytes\n         objects.\n\n      The extension module "array" provides an additional example of a\n      mutable sequence type.\n\nSet types\n   These represent unordered, finite sets of unique, immutable\n   objects. As such, they cannot be indexed by any subscript. However,\n   they can be iterated over, and the built-in function "len()"\n   returns the number of items in a set. Common uses for sets are fast\n   membership testing, removing duplicates from a sequence, and\n   computing mathematical operations such as intersection, union,\n   difference, and symmetric difference.\n\n   For set elements, the same immutability rules apply as for\n   dictionary keys. Note that numeric types obey the normal rules for\n   numeric comparison: if two numbers compare equal (e.g., "1" and\n   "1.0"), only one of them can be contained in a set.\n\n   There are currently two intrinsic set types:\n\n   Sets\n      These represent a mutable set. They are created by the built-in\n      "set()" constructor and can be modified afterwards by several\n      methods, such as "add()".\n\n   Frozen sets\n      These represent an immutable set.  They are created by the\n      built-in "frozenset()" constructor.  As a frozenset is immutable\n      and *hashable*, it can be used again as an element of another\n      set, or as a dictionary key.\n\nMappings\n   These represent finite sets of objects indexed by arbitrary index\n   sets. The subscript notation "a[k]" selects the item indexed by "k"\n   from the mapping "a"; this can be used in expressions and as the\n   target of assignments or "del" statements. The built-in function\n   "len()" returns the number of items in a mapping.\n\n   There is currently a single intrinsic mapping type:\n\n   Dictionaries\n      These represent finite sets of objects indexed by nearly\n      arbitrary values.  The only types of values not acceptable as\n      keys are values containing lists or dictionaries or other\n      mutable types that are compared by value rather than by object\n      identity, the reason being that the efficient implementation of\n      dictionaries requires a key\'s hash value to remain constant.\n      Numeric types used for keys obey the normal rules for numeric\n      comparison: if two numbers compare equal (e.g., "1" and "1.0")\n      then they can be used interchangeably to index the same\n      dictionary entry.\n\n      Dictionaries are mutable; they can be created by the "{...}"\n      notation (see section *Dictionary displays*).\n\n      The extension modules "dbm", "gdbm", and "bsddb" provide\n      additional examples of mapping types.\n\nCallable types\n   These are the types to which the function call operation (see\n   section *Calls*) can be applied:\n\n   User-defined functions\n      A user-defined function object is created by a function\n      definition (see section *Function definitions*).  It should be\n      called with an argument list containing the same number of items\n      as the function\'s formal parameter list.\n\n      Special attributes:\n\n      +-------------------------+---------------------------------+-------------+\n      | Attribute               | Meaning                         |             |\n      +=========================+=================================+=============+\n      | "__doc__" "func_doc"    | The function\'s documentation    | Writable    |\n      |                         | string, or "None" if            |             |\n      |                         | unavailable.                    |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__name__" "func_name"  | The function\'s name.            | Writable    |\n      +-------------------------+---------------------------------+-------------+\n      | "__module__"            | The name of the module the      | Writable    |\n      |                         | function was defined in, or     |             |\n      |                         | "None" if unavailable.          |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__defaults__"          | A tuple containing default      | Writable    |\n      | "func_defaults"         | argument values for those       |             |\n      |                         | arguments that have defaults,   |             |\n      |                         | or "None" if no arguments have  |             |\n      |                         | a default value.                |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__code__" "func_code"  | The code object representing    | Writable    |\n      |                         | the compiled function body.     |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__globals__"           | A reference to the dictionary   | Read-only   |\n      | "func_globals"          | that holds the function\'s       |             |\n      |                         | global variables --- the global |             |\n      |                         | namespace of the module in      |             |\n      |                         | which the function was defined. |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__dict__" "func_dict"  | The namespace supporting        | Writable    |\n      |                         | arbitrary function attributes.  |             |\n      +-------------------------+---------------------------------+-------------+\n      | "__closure__"           | "None" or a tuple of cells that | Read-only   |\n      | "func_closure"          | contain bindings for the        |             |\n      |                         | function\'s free variables.      |             |\n      +-------------------------+---------------------------------+-------------+\n\n      Most of the attributes labelled "Writable" check the type of the\n      assigned value.\n\n      Changed in version 2.4: "func_name" is now writable.\n\n      Changed in version 2.6: The double-underscore attributes\n      "__closure__", "__code__", "__defaults__", and "__globals__"\n      were introduced as aliases for the corresponding "func_*"\n      attributes for forwards compatibility with Python 3.\n\n      Function objects also support getting and setting arbitrary\n      attributes, which can be used, for example, to attach metadata\n      to functions.  Regular attribute dot-notation is used to get and\n      set such attributes. *Note that the current implementation only\n      supports function attributes on user-defined functions. Function\n      attributes on built-in functions may be supported in the\n      future.*\n\n      Additional information about a function\'s definition can be\n      retrieved from its code object; see the description of internal\n      types below.\n\n   User-defined methods\n      A user-defined method object combines a class, a class instance\n      (or "None") and any callable object (normally a user-defined\n      function).\n\n      Special read-only attributes: "im_self" is the class instance\n      object, "im_func" is the function object; "im_class" is the\n      class of "im_self" for bound methods or the class that asked for\n      the method for unbound methods; "__doc__" is the method\'s\n      documentation (same as "im_func.__doc__"); "__name__" is the\n      method name (same as "im_func.__name__"); "__module__" is the\n      name of the module the method was defined in, or "None" if\n      unavailable.\n\n      Changed in version 2.2: "im_self" used to refer to the class\n      that defined the method.\n\n      Changed in version 2.6: For Python 3 forward-compatibility,\n      "im_func" is also available as "__func__", and "im_self" as\n      "__self__".\n\n      Methods also support accessing (but not setting) the arbitrary\n      function attributes on the underlying function object.\n\n      User-defined method objects may be created when getting an\n      attribute of a class (perhaps via an instance of that class), if\n      that attribute is a user-defined function object, an unbound\n      user-defined method object, or a class method object. When the\n      attribute is a user-defined method object, a new method object\n      is only created if the class from which it is being retrieved is\n      the same as, or a derived class of, the class stored in the\n      original method object; otherwise, the original method object is\n      used as it is.\n\n      When a user-defined method object is created by retrieving a\n      user-defined function object from a class, its "im_self"\n      attribute is "None" and the method object is said to be unbound.\n      When one is created by retrieving a user-defined function object\n      from a class via one of its instances, its "im_self" attribute\n      is the instance, and the method object is said to be bound. In\n      either case, the new method\'s "im_class" attribute is the class\n      from which the retrieval takes place, and its "im_func"\n      attribute is the original function object.\n\n      When a user-defined method object is created by retrieving\n      another method object from a class or instance, the behaviour is\n      the same as for a function object, except that the "im_func"\n      attribute of the new instance is not the original method object\n      but its "im_func" attribute.\n\n      When a user-defined method object is created by retrieving a\n      class method object from a class or instance, its "im_self"\n      attribute is the class itself, and its "im_func" attribute is\n      the function object underlying the class method.\n\n      When an unbound user-defined method object is called, the\n      underlying function ("im_func") is called, with the restriction\n      that the first argument must be an instance of the proper class\n      ("im_class") or of a derived class thereof.\n\n      When a bound user-defined method object is called, the\n      underlying function ("im_func") is called, inserting the class\n      instance ("im_self") in front of the argument list.  For\n      instance, when "C" is a class which contains a definition for a\n      function "f()", and "x" is an instance of "C", calling "x.f(1)"\n      is equivalent to calling "C.f(x, 1)".\n\n      When a user-defined method object is derived from a class method\n      object, the "class instance" stored in "im_self" will actually\n      be the class itself, so that calling either "x.f(1)" or "C.f(1)"\n      is equivalent to calling "f(C,1)" where "f" is the underlying\n      function.\n\n      Note that the transformation from function object to (unbound or\n      bound) method object happens each time the attribute is\n      retrieved from the class or instance. In some cases, a fruitful\n      optimization is to assign the attribute to a local variable and\n      call that local variable. Also notice that this transformation\n      only happens for user-defined functions; other callable objects\n      (and all non-callable objects) are retrieved without\n      transformation.  It is also important to note that user-defined\n      functions which are attributes of a class instance are not\n      converted to bound methods; this *only* happens when the\n      function is an attribute of the class.\n\n   Generator functions\n      A function or method which uses the "yield" statement (see\n      section *The yield statement*) is called a *generator function*.\n      Such a function, when called, always returns an iterator object\n      which can be used to execute the body of the function:  calling\n      the iterator\'s "next()" method will cause the function to\n      execute until it provides a value using the "yield" statement.\n      When the function executes a "return" statement or falls off the\n      end, a "StopIteration" exception is raised and the iterator will\n      have reached the end of the set of values to be returned.\n\n   Built-in functions\n      A built-in function object is a wrapper around a C function.\n      Examples of built-in functions are "len()" and "math.sin()"\n      ("math" is a standard built-in module). The number and type of\n      the arguments are determined by the C function. Special read-\n      only attributes: "__doc__" is the function\'s documentation\n      string, or "None" if unavailable; "__name__" is the function\'s\n      name; "__self__" is set to "None" (but see the next item);\n      "__module__" is the name of the module the function was defined\n      in or "None" if unavailable.\n\n   Built-in methods\n      This is really a different disguise of a built-in function, this\n      time containing an object passed to the C function as an\n      implicit extra argument.  An example of a built-in method is\n      "alist.append()", assuming *alist* is a list object. In this\n      case, the special read-only attribute "__self__" is set to the\n      object denoted by *alist*.\n\n   Class Types\n      Class types, or "new-style classes," are callable.  These\n      objects normally act as factories for new instances of\n      themselves, but variations are possible for class types that\n      override "__new__()".  The arguments of the call are passed to\n      "__new__()" and, in the typical case, to "__init__()" to\n      initialize the new instance.\n\n   Classic Classes\n      Class objects are described below.  When a class object is\n      called, a new class instance (also described below) is created\n      and returned.  This implies a call to the class\'s "__init__()"\n      method if it has one.  Any arguments are passed on to the\n      "__init__()" method.  If there is no "__init__()" method, the\n      class must be called without arguments.\n\n   Class instances\n      Class instances are described below.  Class instances are\n      callable only when the class has a "__call__()" method;\n      "x(arguments)" is a shorthand for "x.__call__(arguments)".\n\nModules\n   Modules are imported by the "import" statement (see section *The\n   import statement*). A module object has a namespace implemented by\n   a dictionary object (this is the dictionary referenced by the\n   func_globals attribute of functions defined in the module).\n   Attribute references are translated to lookups in this dictionary,\n   e.g., "m.x" is equivalent to "m.__dict__["x"]". A module object\n   does not contain the code object used to initialize the module\n   (since it isn\'t needed once the initialization is done).\n\n   Attribute assignment updates the module\'s namespace dictionary,\n   e.g., "m.x = 1" is equivalent to "m.__dict__["x"] = 1".\n\n   Special read-only attribute: "__dict__" is the module\'s namespace\n   as a dictionary object.\n\n   **CPython implementation detail:** Because of the way CPython\n   clears module dictionaries, the module dictionary will be cleared\n   when the module falls out of scope even if the dictionary still has\n   live references.  To avoid this, copy the dictionary or keep the\n   module around while using its dictionary directly.\n\n   Predefined (writable) attributes: "__name__" is the module\'s name;\n   "__doc__" is the module\'s documentation string, or "None" if\n   unavailable; "__file__" is the pathname of the file from which the\n   module was loaded, if it was loaded from a file. The "__file__"\n   attribute is not present for C modules that are statically linked\n   into the interpreter; for extension modules loaded dynamically from\n   a shared library, it is the pathname of the shared library file.\n\nClasses\n   Both class types (new-style classes) and class objects (old-\n   style/classic classes) are typically created by class definitions\n   (see section *Class definitions*).  A class has a namespace\n   implemented by a dictionary object. Class attribute references are\n   translated to lookups in this dictionary, e.g., "C.x" is translated\n   to "C.__dict__["x"]" (although for new-style classes in particular\n   there are a number of hooks which allow for other means of locating\n   attributes). When the attribute name is not found there, the\n   attribute search continues in the base classes.  For old-style\n   classes, the search is depth-first, left-to-right in the order of\n   occurrence in the base class list. New-style classes use the more\n   complex C3 method resolution order which behaves correctly even in\n   the presence of \'diamond\' inheritance structures where there are\n   multiple inheritance paths leading back to a common ancestor.\n   Additional details on the C3 MRO used by new-style classes can be\n   found in the documentation accompanying the 2.3 release at\n   https://www.python.org/download/releases/2.3/mro/.\n\n   When a class attribute reference (for class "C", say) would yield a\n   user-defined function object or an unbound user-defined method\n   object whose associated class is either "C" or one of its base\n   classes, it is transformed into an unbound user-defined method\n   object whose "im_class" attribute is "C". When it would yield a\n   class method object, it is transformed into a bound user-defined\n   method object whose "im_self" attribute is "C".  When it would\n   yield a static method object, it is transformed into the object\n   wrapped by the static method object. See section *Implementing\n   Descriptors* for another way in which attributes retrieved from a\n   class may differ from those actually contained in its "__dict__"\n   (note that only new-style classes support descriptors).\n\n   Class attribute assignments update the class\'s dictionary, never\n   the dictionary of a base class.\n\n   A class object can be called (see above) to yield a class instance\n   (see below).\n\n   Special attributes: "__name__" is the class name; "__module__" is\n   the module name in which the class was defined; "__dict__" is the\n   dictionary containing the class\'s namespace; "__bases__" is a tuple\n   (possibly empty or a singleton) containing the base classes, in the\n   order of their occurrence in the base class list; "__doc__" is the\n   class\'s documentation string, or None if undefined.\n\nClass instances\n   A class instance is created by calling a class object (see above).\n   A class instance has a namespace implemented as a dictionary which\n   is the first place in which attribute references are searched.\n   When an attribute is not found there, and the instance\'s class has\n   an attribute by that name, the search continues with the class\n   attributes.  If a class attribute is found that is a user-defined\n   function object or an unbound user-defined method object whose\n   associated class is the class (call it "C") of the instance for\n   which the attribute reference was initiated or one of its bases, it\n   is transformed into a bound user-defined method object whose\n   "im_class" attribute is "C" and whose "im_self" attribute is the\n   instance. Static method and class method objects are also\n   transformed, as if they had been retrieved from class "C"; see\n   above under "Classes". See section *Implementing Descriptors* for\n   another way in which attributes of a class retrieved via its\n   instances may differ from the objects actually stored in the\n   class\'s "__dict__". If no class attribute is found, and the\n   object\'s class has a "__getattr__()" method, that is called to\n   satisfy the lookup.\n\n   Attribute assignments and deletions update the instance\'s\n   dictionary, never a class\'s dictionary.  If the class has a\n   "__setattr__()" or "__delattr__()" method, this is called instead\n   of updating the instance dictionary directly.\n\n   Class instances can pretend to be numbers, sequences, or mappings\n   if they have methods with certain special names.  See section\n   *Special method names*.\n\n   Special attributes: "__dict__" is the attribute dictionary;\n   "__class__" is the instance\'s class.\n\nFiles\n   A file object represents an open file.  File objects are created by\n   the "open()" built-in function, and also by "os.popen()",\n   "os.fdopen()", and the "makefile()" method of socket objects (and\n   perhaps by other functions or methods provided by extension\n   modules).  The objects "sys.stdin", "sys.stdout" and "sys.stderr"\n   are initialized to file objects corresponding to the interpreter\'s\n   standard input, output and error streams.  See *File Objects* for\n   complete documentation of file objects.\n\nInternal types\n   A few types used internally by the interpreter are exposed to the\n   user. Their definitions may change with future versions of the\n   interpreter, but they are mentioned here for completeness.\n\n   Code objects\n      Code objects represent *byte-compiled* executable Python code,\n      or *bytecode*. The difference between a code object and a\n      function object is that the function object contains an explicit\n      reference to the function\'s globals (the module in which it was\n      defined), while a code object contains no context; also the\n      default argument values are stored in the function object, not\n      in the code object (because they represent values calculated at\n      run-time).  Unlike function objects, code objects are immutable\n      and contain no references (directly or indirectly) to mutable\n      objects.\n\n      Special read-only attributes: "co_name" gives the function name;\n      "co_argcount" is the number of positional arguments (including\n      arguments with default values); "co_nlocals" is the number of\n      local variables used by the function (including arguments);\n      "co_varnames" is a tuple containing the names of the local\n      variables (starting with the argument names); "co_cellvars" is a\n      tuple containing the names of local variables that are\n      referenced by nested functions; "co_freevars" is a tuple\n      containing the names of free variables; "co_code" is a string\n      representing the sequence of bytecode instructions; "co_consts"\n      is a tuple containing the literals used by the bytecode;\n      "co_names" is a tuple containing the names used by the bytecode;\n      "co_filename" is the filename from which the code was compiled;\n      "co_firstlineno" is the first line number of the function;\n      "co_lnotab" is a string encoding the mapping from bytecode\n      offsets to line numbers (for details see the source code of the\n      interpreter); "co_stacksize" is the required stack size\n      (including local variables); "co_flags" is an integer encoding a\n      number of flags for the interpreter.\n\n      The following flag bits are defined for "co_flags": bit "0x04"\n      is set if the function uses the "*arguments" syntax to accept an\n      arbitrary number of positional arguments; bit "0x08" is set if\n      the function uses the "**keywords" syntax to accept arbitrary\n      keyword arguments; bit "0x20" is set if the function is a\n      generator.\n\n      Future feature declarations ("from __future__ import division")\n      also use bits in "co_flags" to indicate whether a code object\n      was compiled with a particular feature enabled: bit "0x2000" is\n      set if the function was compiled with future division enabled;\n      bits "0x10" and "0x1000" were used in earlier versions of\n      Python.\n\n      Other bits in "co_flags" are reserved for internal use.\n\n      If a code object represents a function, the first item in\n      "co_consts" is the documentation string of the function, or\n      "None" if undefined.\n\n   Frame objects\n      Frame objects represent execution frames.  They may occur in\n      traceback objects (see below).\n\n      Special read-only attributes: "f_back" is to the previous stack\n      frame (towards the caller), or "None" if this is the bottom\n      stack frame; "f_code" is the code object being executed in this\n      frame; "f_locals" is the dictionary used to look up local\n      variables; "f_globals" is used for global variables;\n      "f_builtins" is used for built-in (intrinsic) names;\n      "f_restricted" is a flag indicating whether the function is\n      executing in restricted execution mode; "f_lasti" gives the\n      precise instruction (this is an index into the bytecode string\n      of the code object).\n\n      Special writable attributes: "f_trace", if not "None", is a\n      function called at the start of each source code line (this is\n      used by the debugger); "f_exc_type", "f_exc_value",\n      "f_exc_traceback" represent the last exception raised in the\n      parent frame provided another exception was ever raised in the\n      current frame (in all other cases they are None); "f_lineno" is\n      the current line number of the frame --- writing to this from\n      within a trace function jumps to the given line (only for the\n      bottom-most frame).  A debugger can implement a Jump command\n      (aka Set Next Statement) by writing to f_lineno.\n\n   Traceback objects\n      Traceback objects represent a stack trace of an exception.  A\n      traceback object is created when an exception occurs.  When the\n      search for an exception handler unwinds the execution stack, at\n      each unwound level a traceback object is inserted in front of\n      the current traceback.  When an exception handler is entered,\n      the stack trace is made available to the program. (See section\n      *The try statement*.) It is accessible as "sys.exc_traceback",\n      and also as the third item of the tuple returned by\n      "sys.exc_info()".  The latter is the preferred interface, since\n      it works correctly when the program is using multiple threads.\n      When the program contains no suitable handler, the stack trace\n      is written (nicely formatted) to the standard error stream; if\n      the interpreter is interactive, it is also made available to the\n      user as "sys.last_traceback".\n\n      Special read-only attributes: "tb_next" is the next level in the\n      stack trace (towards the frame where the exception occurred), or\n      "None" if there is no next level; "tb_frame" points to the\n      execution frame of the current level; "tb_lineno" gives the line\n      number where the exception occurred; "tb_lasti" indicates the\n      precise instruction.  The line number and last instruction in\n      the traceback may differ from the line number of its frame\n      object if the exception occurred in a "try" statement with no\n      matching except clause or with a finally clause.\n\n   Slice objects\n      Slice objects are used to represent slices when *extended slice\n      syntax* is used. This is a slice using two colons, or multiple\n      slices or ellipses separated by commas, e.g., "a[i:j:step]",\n      "a[i:j, k:l]", or "a[..., i:j]".  They are also created by the\n      built-in "slice()" function.\n\n      Special read-only attributes: "start" is the lower bound; "stop"\n      is the upper bound; "step" is the step value; each is "None" if\n      omitted.  These attributes can have any type.\n\n      Slice objects support one method:\n\n      slice.indices(self, length)\n\n         This method takes a single integer argument *length* and\n         computes information about the extended slice that the slice\n         object would describe if applied to a sequence of *length*\n         items.  It returns a tuple of three integers; respectively\n         these are the *start* and *stop* indices and the *step* or\n         stride length of the slice. Missing or out-of-bounds indices\n         are handled in a manner consistent with regular slices.\n\n         New in version 2.3.\n\n   Static method objects\n      Static method objects provide a way of defeating the\n      transformation of function objects to method objects described\n      above. A static method object is a wrapper around any other\n      object, usually a user-defined method object. When a static\n      method object is retrieved from a class or a class instance, the\n      object actually returned is the wrapped object, which is not\n      subject to any further transformation. Static method objects are\n      not themselves callable, although the objects they wrap usually\n      are. Static method objects are created by the built-in\n      "staticmethod()" constructor.\n\n   Class method objects\n      A class method object, like a static method object, is a wrapper\n      around another object that alters the way in which that object\n      is retrieved from classes and class instances. The behaviour of\n      class method objects upon such retrieval is described above,\n      under "User-defined methods". Class method objects are created\n      by the built-in "classmethod()" constructor.\n',
 'typesfunctions': u'\nFunctions\n*********\n\nFunction objects are created by function definitions.  The only\noperation on a function object is to call it: "func(argument-list)".\n\nThere are really two flavors of function objects: built-in functions\nand user-defined functions.  Both support the same operation (to call\nthe function), but the implementation is different, hence the\ndifferent object types.\n\nSee *Function definitions* for more information.\n',
 'typesmapping': u'\nMapping Types --- "dict"\n************************\n\nA *mapping* object maps *hashable* values to arbitrary objects.\nMappings are mutable objects.  There is currently only one standard\nmapping type, the *dictionary*.  (For other containers see the built\nin "list", "set", and "tuple" classes, and the "collections" module.)\n\nA dictionary\'s keys are *almost* arbitrary values.  Values that are\nnot *hashable*, that is, values containing lists, dictionaries or\nother mutable types (that are compared by value rather than by object\nidentity) may not be used as keys.  Numeric types used for keys obey\nthe normal rules for numeric comparison: if two numbers compare equal\n(such as "1" and "1.0") then they can be used interchangeably to index\nthe same dictionary entry.  (Note however, that since computers store\nfloating-point numbers as approximations it is usually unwise to use\nthem as dictionary keys.)\n\nDictionaries can be created by placing a comma-separated list of "key:\nvalue" pairs within braces, for example: "{\'jack\': 4098, \'sjoerd\':\n4127}" or "{4098: \'jack\', 4127: \'sjoerd\'}", or by the "dict"\nconstructor.\n\nclass class dict(**kwarg)\nclass class dict(mapping, **kwarg)\nclass class dict(iterable, **kwarg)\n\n   Return a new dictionary initialized from an optional positional\n   argument and a possibly empty set of keyword arguments.\n\n   If no positional argument is given, an empty dictionary is created.\n   If a positional argument is given and it is a mapping object, a\n   dictionary is created with the same key-value pairs as the mapping\n   object.  Otherwise, the positional argument must be an *iterable*\n   object.  Each item in the iterable must itself be an iterable with\n   exactly two objects.  The first object of each item becomes a key\n   in the new dictionary, and the second object the corresponding\n   value.  If a key occurs more than once, the last value for that key\n   becomes the corresponding value in the new dictionary.\n\n   If keyword arguments are given, the keyword arguments and their\n   values are added to the dictionary created from the positional\n   argument.  If a key being added is already present, the value from\n   the keyword argument replaces the value from the positional\n   argument.\n\n   To illustrate, the following examples all return a dictionary equal\n   to "{"one": 1, "two": 2, "three": 3}":\n\n      >>> a = dict(one=1, two=2, three=3)\n      >>> b = {\'one\': 1, \'two\': 2, \'three\': 3}\n      >>> c = dict(zip([\'one\', \'two\', \'three\'], [1, 2, 3]))\n      >>> d = dict([(\'two\', 2), (\'one\', 1), (\'three\', 3)])\n      >>> e = dict({\'three\': 3, \'one\': 1, \'two\': 2})\n      >>> a == b == c == d == e\n      True\n\n   Providing keyword arguments as in the first example only works for\n   keys that are valid Python identifiers.  Otherwise, any valid keys\n   can be used.\n\n   New in version 2.2.\n\n   Changed in version 2.3: Support for building a dictionary from\n   keyword arguments added.\n\n   These are the operations that dictionaries support (and therefore,\n   custom mapping types should support too):\n\n   len(d)\n\n      Return the number of items in the dictionary *d*.\n\n   d[key]\n\n      Return the item of *d* with key *key*.  Raises a "KeyError" if\n      *key* is not in the map.\n\n      New in version 2.5: If a subclass of dict defines a method\n      "__missing__()", if the key *key* is not present, the "d[key]"\n      operation calls that method with the key *key* as argument.  The\n      "d[key]" operation then returns or raises whatever is returned\n      or raised by the "__missing__(key)" call if the key is not\n      present. No other operations or methods invoke "__missing__()".\n      If "__missing__()" is not defined, "KeyError" is raised.\n      "__missing__()" must be a method; it cannot be an instance\n      variable. For an example, see "collections.defaultdict".\n\n   d[key] = value\n\n      Set "d[key]" to *value*.\n\n   del d[key]\n\n      Remove "d[key]" from *d*.  Raises a "KeyError" if *key* is not\n      in the map.\n\n   key in d\n\n      Return "True" if *d* has a key *key*, else "False".\n\n      New in version 2.2.\n\n   key not in d\n\n      Equivalent to "not key in d".\n\n      New in version 2.2.\n\n   iter(d)\n\n      Return an iterator over the keys of the dictionary.  This is a\n      shortcut for "iterkeys()".\n\n   clear()\n\n      Remove all items from the dictionary.\n\n   copy()\n\n      Return a shallow copy of the dictionary.\n\n   fromkeys(seq[, value])\n\n      Create a new dictionary with keys from *seq* and values set to\n      *value*.\n\n      "fromkeys()" is a class method that returns a new dictionary.\n      *value* defaults to "None".\n\n      New in version 2.3.\n\n   get(key[, default])\n\n      Return the value for *key* if *key* is in the dictionary, else\n      *default*. If *default* is not given, it defaults to "None", so\n      that this method never raises a "KeyError".\n\n   has_key(key)\n\n      Test for the presence of *key* in the dictionary.  "has_key()"\n      is deprecated in favor of "key in d".\n\n   items()\n\n      Return a copy of the dictionary\'s list of "(key, value)" pairs.\n\n      **CPython implementation detail:** Keys and values are listed in\n      an arbitrary order which is non-random, varies across Python\n      implementations, and depends on the dictionary\'s history of\n      insertions and deletions.\n\n      If "items()", "keys()", "values()", "iteritems()", "iterkeys()",\n      and "itervalues()" are called with no intervening modifications\n      to the dictionary, the lists will directly correspond.  This\n      allows the creation of "(value, key)" pairs using "zip()":\n      "pairs = zip(d.values(), d.keys())".  The same relationship\n      holds for the "iterkeys()" and "itervalues()" methods: "pairs =\n      zip(d.itervalues(), d.iterkeys())" provides the same value for\n      "pairs". Another way to create the same list is "pairs = [(v, k)\n      for (k, v) in d.iteritems()]".\n\n   iteritems()\n\n      Return an iterator over the dictionary\'s "(key, value)" pairs.\n      See the note for "dict.items()".\n\n      Using "iteritems()" while adding or deleting entries in the\n      dictionary may raise a "RuntimeError" or fail to iterate over\n      all entries.\n\n      New in version 2.2.\n\n   iterkeys()\n\n      Return an iterator over the dictionary\'s keys.  See the note for\n      "dict.items()".\n\n      Using "iterkeys()" while adding or deleting entries in the\n      dictionary may raise a "RuntimeError" or fail to iterate over\n      all entries.\n\n      New in version 2.2.\n\n   itervalues()\n\n      Return an iterator over the dictionary\'s values.  See the note\n      for "dict.items()".\n\n      Using "itervalues()" while adding or deleting entries in the\n      dictionary may raise a "RuntimeError" or fail to iterate over\n      all entries.\n\n      New in version 2.2.\n\n   keys()\n\n      Return a copy of the dictionary\'s list of keys.  See the note\n      for "dict.items()".\n\n   pop(key[, default])\n\n      If *key* is in the dictionary, remove it and return its value,\n      else return *default*.  If *default* is not given and *key* is\n      not in the dictionary, a "KeyError" is raised.\n\n      New in version 2.3.\n\n   popitem()\n\n      Remove and return an arbitrary "(key, value)" pair from the\n      dictionary.\n\n      "popitem()" is useful to destructively iterate over a\n      dictionary, as often used in set algorithms.  If the dictionary\n      is empty, calling "popitem()" raises a "KeyError".\n\n   setdefault(key[, default])\n\n      If *key* is in the dictionary, return its value.  If not, insert\n      *key* with a value of *default* and return *default*.  *default*\n      defaults to "None".\n\n   update([other])\n\n      Update the dictionary with the key/value pairs from *other*,\n      overwriting existing keys.  Return "None".\n\n      "update()" accepts either another dictionary object or an\n      iterable of key/value pairs (as tuples or other iterables of\n      length two).  If keyword arguments are specified, the dictionary\n      is then updated with those key/value pairs: "d.update(red=1,\n      blue=2)".\n\n      Changed in version 2.4: Allowed the argument to be an iterable\n      of key/value pairs and allowed keyword arguments.\n\n   values()\n\n      Return a copy of the dictionary\'s list of values.  See the note\n      for "dict.items()".\n\n   viewitems()\n\n      Return a new view of the dictionary\'s items ("(key, value)"\n      pairs).  See below for documentation of view objects.\n\n      New in version 2.7.\n\n   viewkeys()\n\n      Return a new view of the dictionary\'s keys.  See below for\n      documentation of view objects.\n\n      New in version 2.7.\n\n   viewvalues()\n\n      Return a new view of the dictionary\'s values.  See below for\n      documentation of view objects.\n\n      New in version 2.7.\n\n\nDictionary view objects\n=======================\n\nThe objects returned by "dict.viewkeys()", "dict.viewvalues()" and\n"dict.viewitems()" are *view objects*.  They provide a dynamic view on\nthe dictionary\'s entries, which means that when the dictionary\nchanges, the view reflects these changes.\n\nDictionary views can be iterated over to yield their respective data,\nand support membership tests:\n\nlen(dictview)\n\n   Return the number of entries in the dictionary.\n\niter(dictview)\n\n   Return an iterator over the keys, values or items (represented as\n   tuples of "(key, value)") in the dictionary.\n\n   Keys and values are iterated over in an arbitrary order which is\n   non-random, varies across Python implementations, and depends on\n   the dictionary\'s history of insertions and deletions. If keys,\n   values and items views are iterated over with no intervening\n   modifications to the dictionary, the order of items will directly\n   correspond.  This allows the creation of "(value, key)" pairs using\n   "zip()": "pairs = zip(d.values(), d.keys())".  Another way to\n   create the same list is "pairs = [(v, k) for (k, v) in d.items()]".\n\n   Iterating views while adding or deleting entries in the dictionary\n   may raise a "RuntimeError" or fail to iterate over all entries.\n\nx in dictview\n\n   Return "True" if *x* is in the underlying dictionary\'s keys, values\n   or items (in the latter case, *x* should be a "(key, value)"\n   tuple).\n\nKeys views are set-like since their entries are unique and hashable.\nIf all values are hashable, so that (key, value) pairs are unique and\nhashable, then the items view is also set-like.  (Values views are not\ntreated as set-like since the entries are generally not unique.)  Then\nthese set operations are available ("other" refers either to another\nview or a set):\n\ndictview & other\n\n   Return the intersection of the dictview and the other object as a\n   new set.\n\ndictview | other\n\n   Return the union of the dictview and the other object as a new set.\n\ndictview - other\n\n   Return the difference between the dictview and the other object\n   (all elements in *dictview* that aren\'t in *other*) as a new set.\n\ndictview ^ other\n\n   Return the symmetric difference (all elements either in *dictview*\n   or *other*, but not in both) of the dictview and the other object\n   as a new set.\n\nAn example of dictionary view usage:\n\n   >>> dishes = {\'eggs\': 2, \'sausage\': 1, \'bacon\': 1, \'spam\': 500}\n   >>> keys = dishes.viewkeys()\n   >>> values = dishes.viewvalues()\n\n   >>> # iteration\n   >>> n = 0\n   >>> for val in values:\n   ...     n += val\n   >>> print(n)\n   504\n\n   >>> # keys and values are iterated over in the same order\n   >>> list(keys)\n   [\'eggs\', \'bacon\', \'sausage\', \'spam\']\n   >>> list(values)\n   [2, 1, 1, 500]\n\n   >>> # view objects are dynamic and reflect dict changes\n   >>> del dishes[\'eggs\']\n   >>> del dishes[\'sausage\']\n   >>> list(keys)\n   [\'spam\', \'bacon\']\n\n   >>> # set operations\n   >>> keys & {\'eggs\', \'bacon\', \'salad\'}\n   {\'bacon\'}\n',
 'typesmethods': u'\nMethods\n*******\n\nMethods are functions that are called using the attribute notation.\nThere are two flavors: built-in methods (such as "append()" on lists)\nand class instance methods.  Built-in methods are described with the\ntypes that support them.\n\nThe implementation adds two special read-only attributes to class\ninstance methods: "m.im_self" is the object on which the method\noperates, and "m.im_func" is the function implementing the method.\nCalling "m(arg-1, arg-2, ..., arg-n)" is completely equivalent to\ncalling "m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)".\n\nClass instance methods are either *bound* or *unbound*, referring to\nwhether the method was accessed through an instance or a class,\nrespectively.  When a method is unbound, its "im_self" attribute will\nbe "None" and if called, an explicit "self" object must be passed as\nthe first argument.  In this case, "self" must be an instance of the\nunbound method\'s class (or a subclass of that class), otherwise a\n"TypeError" is raised.\n\nLike function objects, methods objects support getting arbitrary\nattributes. However, since method attributes are actually stored on\nthe underlying function object ("meth.im_func"), setting method\nattributes on either bound or unbound methods is disallowed.\nAttempting to set an attribute on a method results in an\n"AttributeError" being raised.  In order to set a method attribute,\nyou need to explicitly set it on the underlying function object:\n\n   >>> class C:\n   ...     def method(self):\n   ...         pass\n   ...\n   >>> c = C()\n   >>> c.method.whoami = \'my name is method\'  # can\'t set on the method\n   Traceback (most recent call last):\n     File "<stdin>", line 1, in <module>\n   AttributeError: \'instancemethod\' object has no attribute \'whoami\'\n   >>> c.method.im_func.whoami = \'my name is method\'\n   >>> c.method.whoami\n   \'my name is method\'\n\nSee *The standard type hierarchy* for more information.\n',
 'typesmodules': u'\nModules\n*******\n\nThe only special operation on a module is attribute access: "m.name",\nwhere *m* is a module and *name* accesses a name defined in *m*\'s\nsymbol table. Module attributes can be assigned to.  (Note that the\n"import" statement is not, strictly speaking, an operation on a module\nobject; "import foo" does not require a module object named *foo* to\nexist, rather it requires an (external) *definition* for a module\nnamed *foo* somewhere.)\n\nA special attribute of every module is "__dict__". This is the\ndictionary containing the module\'s symbol table. Modifying this\ndictionary will actually change the module\'s symbol table, but direct\nassignment to the "__dict__" attribute is not possible (you can write\n"m.__dict__[\'a\'] = 1", which defines "m.a" to be "1", but you can\'t\nwrite "m.__dict__ = {}").  Modifying "__dict__" directly is not\nrecommended.\n\nModules built into the interpreter are written like this: "<module\n\'sys\' (built-in)>".  If loaded from a file, they are written as\n"<module \'os\' from \'/usr/local/lib/pythonX.Y/os.pyc\'>".\n',
 'typesseq': u'\nSequence Types --- "str", "unicode", "list", "tuple", "bytearray", "buffer", "xrange"\n*************************************************************************************\n\nThere are seven sequence types: strings, Unicode strings, lists,\ntuples, bytearrays, buffers, and xrange objects.\n\nFor other containers see the built in "dict" and "set" classes, and\nthe "collections" module.\n\nString literals are written in single or double quotes: "\'xyzzy\'",\n""frobozz"".  See *String literals* for more about string literals.\nUnicode strings are much like strings, but are specified in the syntax\nusing a preceding "\'u\'" character: "u\'abc\'", "u"def"". In addition to\nthe functionality described here, there are also string-specific\nmethods described in the *String Methods* section. Lists are\nconstructed with square brackets, separating items with commas: "[a,\nb, c]". Tuples are constructed by the comma operator (not within\nsquare brackets), with or without enclosing parentheses, but an empty\ntuple must have the enclosing parentheses, such as "a, b, c" or "()".\nA single item tuple must have a trailing comma, such as "(d,)".\n\nBytearray objects are created with the built-in function\n"bytearray()".\n\nBuffer objects are not directly supported by Python syntax, but can be\ncreated by calling the built-in function "buffer()".  They don\'t\nsupport concatenation or repetition.\n\nObjects of type xrange are similar to buffers in that there is no\nspecific syntax to create them, but they are created using the\n"xrange()" function.  They don\'t support slicing, concatenation or\nrepetition, and using "in", "not in", "min()" or "max()" on them is\ninefficient.\n\nMost sequence types support the following operations.  The "in" and\n"not in" operations have the same priorities as the comparison\noperations.  The "+" and "*" operations have the same priority as the\ncorresponding numeric operations. [3] Additional methods are provided\nfor *Mutable Sequence Types*.\n\nThis table lists the sequence operations sorted in ascending priority.\nIn the table, *s* and *t* are sequences of the same type; *n*, *i* and\n*j* are integers:\n\n+--------------------+----------------------------------+------------+\n| Operation          | Result                           | Notes      |\n+====================+==================================+============+\n| "x in s"           | "True" if an item of *s* is      | (1)        |\n|                    | equal to *x*, else "False"       |            |\n+--------------------+----------------------------------+------------+\n| "x not in s"       | "False" if an item of *s* is     | (1)        |\n|                    | equal to *x*, else "True"        |            |\n+--------------------+----------------------------------+------------+\n| "s + t"            | the concatenation of *s* and *t* | (6)        |\n+--------------------+----------------------------------+------------+\n| "s * n, n * s"     | *n* shallow copies of *s*        | (2)        |\n|                    | concatenated                     |            |\n+--------------------+----------------------------------+------------+\n| "s[i]"             | *i*th item of *s*, origin 0      | (3)        |\n+--------------------+----------------------------------+------------+\n| "s[i:j]"           | slice of *s* from *i* to *j*     | (3)(4)     |\n+--------------------+----------------------------------+------------+\n| "s[i:j:k]"         | slice of *s* from *i* to *j*     | (3)(5)     |\n|                    | with step *k*                    |            |\n+--------------------+----------------------------------+------------+\n| "len(s)"           | length of *s*                    |            |\n+--------------------+----------------------------------+------------+\n| "min(s)"           | smallest item of *s*             |            |\n+--------------------+----------------------------------+------------+\n| "max(s)"           | largest item of *s*              |            |\n+--------------------+----------------------------------+------------+\n| "s.index(x)"       | index of the first occurrence of |            |\n|                    | *x* in *s*                       |            |\n+--------------------+----------------------------------+------------+\n| "s.count(x)"       | total number of occurrences of   |            |\n|                    | *x* in *s*                       |            |\n+--------------------+----------------------------------+------------+\n\nSequence types also support comparisons. In particular, tuples and\nlists are compared lexicographically by comparing corresponding\nelements. This means that to compare equal, every element must compare\nequal and the two sequences must be of the same type and have the same\nlength. (For full details see *Comparisons* in the language\nreference.)\n\nNotes:\n\n1. When *s* is a string or Unicode string object the "in" and "not\n   in" operations act like a substring test.  In Python versions\n   before 2.3, *x* had to be a string of length 1. In Python 2.3 and\n   beyond, *x* may be a string of any length.\n\n2. Values of *n* less than "0" are treated as "0" (which yields an\n   empty sequence of the same type as *s*).  Note also that the copies\n   are shallow; nested structures are not copied.  This often haunts\n   new Python programmers; consider:\n\n   >>> lists = [[]] * 3\n   >>> lists\n   [[], [], []]\n   >>> lists[0].append(3)\n   >>> lists\n   [[3], [3], [3]]\n\n   What has happened is that "[[]]" is a one-element list containing\n   an empty list, so all three elements of "[[]] * 3" are (pointers\n   to) this single empty list.  Modifying any of the elements of\n   "lists" modifies this single list. You can create a list of\n   different lists this way:\n\n   >>> lists = [[] for i in range(3)]\n   >>> lists[0].append(3)\n   >>> lists[1].append(5)\n   >>> lists[2].append(7)\n   >>> lists\n   [[3], [5], [7]]\n\n3. If *i* or *j* is negative, the index is relative to the end of\n   the string: "len(s) + i" or "len(s) + j" is substituted.  But note\n   that "-0" is still "0".\n\n4. The slice of *s* from *i* to *j* is defined as the sequence of\n   items with index *k* such that "i <= k < j".  If *i* or *j* is\n   greater than "len(s)", use "len(s)".  If *i* is omitted or "None",\n   use "0".  If *j* is omitted or "None", use "len(s)".  If *i* is\n   greater than or equal to *j*, the slice is empty.\n\n5. The slice of *s* from *i* to *j* with step *k* is defined as the\n   sequence of items with index  "x = i + n*k" such that "0 <= n <\n   (j-i)/k".  In other words, the indices are "i", "i+k", "i+2*k",\n   "i+3*k" and so on, stopping when *j* is reached (but never\n   including *j*).  If *i* or *j* is greater than "len(s)", use\n   "len(s)".  If *i* or *j* are omitted or "None", they become "end"\n   values (which end depends on the sign of *k*).  Note, *k* cannot be\n   zero. If *k* is "None", it is treated like "1".\n\n6. **CPython implementation detail:** If *s* and *t* are both\n   strings, some Python implementations such as CPython can usually\n   perform an in-place optimization for assignments of the form "s = s\n   + t" or "s += t".  When applicable, this optimization makes\n   quadratic run-time much less likely.  This optimization is both\n   version and implementation dependent.  For performance sensitive\n   code, it is preferable to use the "str.join()" method which assures\n   consistent linear concatenation performance across versions and\n   implementations.\n\n   Changed in version 2.4: Formerly, string concatenation never\n   occurred in-place.\n\n\nString Methods\n==============\n\nBelow are listed the string methods which both 8-bit strings and\nUnicode objects support.  Some of them are also available on\n"bytearray" objects.\n\nIn addition, Python\'s strings support the sequence type methods\ndescribed in the *Sequence Types --- str, unicode, list, tuple,\nbytearray, buffer, xrange* section. To output formatted strings use\ntemplate strings or the "%" operator described in the *String\nFormatting Operations* section. Also, see the "re" module for string\nfunctions based on regular expressions.\n\nstr.capitalize()\n\n   Return a copy of the string with its first character capitalized\n   and the rest lowercased.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.center(width[, fillchar])\n\n   Return centered in a string of length *width*. Padding is done\n   using the specified *fillchar* (default is a space).\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.count(sub[, start[, end]])\n\n   Return the number of non-overlapping occurrences of substring *sub*\n   in the range [*start*, *end*].  Optional arguments *start* and\n   *end* are interpreted as in slice notation.\n\nstr.decode([encoding[, errors]])\n\n   Decodes the string using the codec registered for *encoding*.\n   *encoding* defaults to the default string encoding.  *errors* may\n   be given to set a different error handling scheme.  The default is\n   "\'strict\'", meaning that encoding errors raise "UnicodeError".\n   Other possible values are "\'ignore\'", "\'replace\'" and any other\n   name registered via "codecs.register_error()", see section *Codec\n   Base Classes*.\n\n   New in version 2.2.\n\n   Changed in version 2.3: Support for other error handling schemes\n   added.\n\n   Changed in version 2.7: Support for keyword arguments added.\n\nstr.encode([encoding[, errors]])\n\n   Return an encoded version of the string.  Default encoding is the\n   current default string encoding.  *errors* may be given to set a\n   different error handling scheme.  The default for *errors* is\n   "\'strict\'", meaning that encoding errors raise a "UnicodeError".\n   Other possible values are "\'ignore\'", "\'replace\'",\n   "\'xmlcharrefreplace\'", "\'backslashreplace\'" and any other name\n   registered via "codecs.register_error()", see section *Codec Base\n   Classes*. For a list of possible encodings, see section *Standard\n   Encodings*.\n\n   New in version 2.0.\n\n   Changed in version 2.3: Support for "\'xmlcharrefreplace\'" and\n   "\'backslashreplace\'" and other error handling schemes added.\n\n   Changed in version 2.7: Support for keyword arguments added.\n\nstr.endswith(suffix[, start[, end]])\n\n   Return "True" if the string ends with the specified *suffix*,\n   otherwise return "False".  *suffix* can also be a tuple of suffixes\n   to look for.  With optional *start*, test beginning at that\n   position.  With optional *end*, stop comparing at that position.\n\n   Changed in version 2.5: Accept tuples as *suffix*.\n\nstr.expandtabs([tabsize])\n\n   Return a copy of the string where all tab characters are replaced\n   by one or more spaces, depending on the current column and the\n   given tab size.  Tab positions occur every *tabsize* characters\n   (default is 8, giving tab positions at columns 0, 8, 16 and so on).\n   To expand the string, the current column is set to zero and the\n   string is examined character by character.  If the character is a\n   tab ("\\t"), one or more space characters are inserted in the result\n   until the current column is equal to the next tab position. (The\n   tab character itself is not copied.)  If the character is a newline\n   ("\\n") or return ("\\r"), it is copied and the current column is\n   reset to zero.  Any other character is copied unchanged and the\n   current column is incremented by one regardless of how the\n   character is represented when printed.\n\n   >>> \'01\\t012\\t0123\\t01234\'.expandtabs()\n   \'01      012     0123    01234\'\n   >>> \'01\\t012\\t0123\\t01234\'.expandtabs(4)\n   \'01  012 0123    01234\'\n\nstr.find(sub[, start[, end]])\n\n   Return the lowest index in the string where substring *sub* is\n   found, such that *sub* is contained in the slice "s[start:end]".\n   Optional arguments *start* and *end* are interpreted as in slice\n   notation.  Return "-1" if *sub* is not found.\n\n   Note: The "find()" method should be used only if you need to know\n     the position of *sub*.  To check if *sub* is a substring or not,\n     use the "in" operator:\n\n        >>> \'Py\' in \'Python\'\n        True\n\nstr.format(*args, **kwargs)\n\n   Perform a string formatting operation.  The string on which this\n   method is called can contain literal text or replacement fields\n   delimited by braces "{}".  Each replacement field contains either\n   the numeric index of a positional argument, or the name of a\n   keyword argument.  Returns a copy of the string where each\n   replacement field is replaced with the string value of the\n   corresponding argument.\n\n   >>> "The sum of 1 + 2 is {0}".format(1+2)\n   \'The sum of 1 + 2 is 3\'\n\n   See *Format String Syntax* for a description of the various\n   formatting options that can be specified in format strings.\n\n   This method of string formatting is the new standard in Python 3,\n   and should be preferred to the "%" formatting described in *String\n   Formatting Operations* in new code.\n\n   New in version 2.6.\n\nstr.index(sub[, start[, end]])\n\n   Like "find()", but raise "ValueError" when the substring is not\n   found.\n\nstr.isalnum()\n\n   Return true if all characters in the string are alphanumeric and\n   there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isalpha()\n\n   Return true if all characters in the string are alphabetic and\n   there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isdigit()\n\n   Return true if all characters in the string are digits and there is\n   at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.islower()\n\n   Return true if all cased characters [4] in the string are lowercase\n   and there is at least one cased character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isspace()\n\n   Return true if there are only whitespace characters in the string\n   and there is at least one character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.istitle()\n\n   Return true if the string is a titlecased string and there is at\n   least one character, for example uppercase characters may only\n   follow uncased characters and lowercase characters only cased ones.\n   Return false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.isupper()\n\n   Return true if all cased characters [4] in the string are uppercase\n   and there is at least one cased character, false otherwise.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.join(iterable)\n\n   Return a string which is the concatenation of the strings in the\n   *iterable* *iterable*.  The separator between elements is the\n   string providing this method.\n\nstr.ljust(width[, fillchar])\n\n   Return the string left justified in a string of length *width*.\n   Padding is done using the specified *fillchar* (default is a\n   space).  The original string is returned if *width* is less than or\n   equal to "len(s)".\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.lower()\n\n   Return a copy of the string with all the cased characters [4]\n   converted to lowercase.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.lstrip([chars])\n\n   Return a copy of the string with leading characters removed.  The\n   *chars* argument is a string specifying the set of characters to be\n   removed.  If omitted or "None", the *chars* argument defaults to\n   removing whitespace.  The *chars* argument is not a prefix; rather,\n   all combinations of its values are stripped:\n\n   >>> \'   spacious   \'.lstrip()\n   \'spacious   \'\n   >>> \'www.example.com\'.lstrip(\'cmowz.\')\n   \'example.com\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.partition(sep)\n\n   Split the string at the first occurrence of *sep*, and return a\n   3-tuple containing the part before the separator, the separator\n   itself, and the part after the separator.  If the separator is not\n   found, return a 3-tuple containing the string itself, followed by\n   two empty strings.\n\n   New in version 2.5.\n\nstr.replace(old, new[, count])\n\n   Return a copy of the string with all occurrences of substring *old*\n   replaced by *new*.  If the optional argument *count* is given, only\n   the first *count* occurrences are replaced.\n\nstr.rfind(sub[, start[, end]])\n\n   Return the highest index in the string where substring *sub* is\n   found, such that *sub* is contained within "s[start:end]".\n   Optional arguments *start* and *end* are interpreted as in slice\n   notation.  Return "-1" on failure.\n\nstr.rindex(sub[, start[, end]])\n\n   Like "rfind()" but raises "ValueError" when the substring *sub* is\n   not found.\n\nstr.rjust(width[, fillchar])\n\n   Return the string right justified in a string of length *width*.\n   Padding is done using the specified *fillchar* (default is a\n   space). The original string is returned if *width* is less than or\n   equal to "len(s)".\n\n   Changed in version 2.4: Support for the *fillchar* argument.\n\nstr.rpartition(sep)\n\n   Split the string at the last occurrence of *sep*, and return a\n   3-tuple containing the part before the separator, the separator\n   itself, and the part after the separator.  If the separator is not\n   found, return a 3-tuple containing two empty strings, followed by\n   the string itself.\n\n   New in version 2.5.\n\nstr.rsplit([sep[, maxsplit]])\n\n   Return a list of the words in the string, using *sep* as the\n   delimiter string. If *maxsplit* is given, at most *maxsplit* splits\n   are done, the *rightmost* ones.  If *sep* is not specified or\n   "None", any whitespace string is a separator.  Except for splitting\n   from the right, "rsplit()" behaves like "split()" which is\n   described in detail below.\n\n   New in version 2.4.\n\nstr.rstrip([chars])\n\n   Return a copy of the string with trailing characters removed.  The\n   *chars* argument is a string specifying the set of characters to be\n   removed.  If omitted or "None", the *chars* argument defaults to\n   removing whitespace.  The *chars* argument is not a suffix; rather,\n   all combinations of its values are stripped:\n\n   >>> \'   spacious   \'.rstrip()\n   \'   spacious\'\n   >>> \'mississippi\'.rstrip(\'ipz\')\n   \'mississ\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.split([sep[, maxsplit]])\n\n   Return a list of the words in the string, using *sep* as the\n   delimiter string.  If *maxsplit* is given, at most *maxsplit*\n   splits are done (thus, the list will have at most "maxsplit+1"\n   elements).  If *maxsplit* is not specified or "-1", then there is\n   no limit on the number of splits (all possible splits are made).\n\n   If *sep* is given, consecutive delimiters are not grouped together\n   and are deemed to delimit empty strings (for example,\n   "\'1,,2\'.split(\',\')" returns "[\'1\', \'\', \'2\']").  The *sep* argument\n   may consist of multiple characters (for example,\n   "\'1<>2<>3\'.split(\'<>\')" returns "[\'1\', \'2\', \'3\']"). Splitting an\n   empty string with a specified separator returns "[\'\']".\n\n   If *sep* is not specified or is "None", a different splitting\n   algorithm is applied: runs of consecutive whitespace are regarded\n   as a single separator, and the result will contain no empty strings\n   at the start or end if the string has leading or trailing\n   whitespace.  Consequently, splitting an empty string or a string\n   consisting of just whitespace with a "None" separator returns "[]".\n\n   For example, "\' 1  2   3  \'.split()" returns "[\'1\', \'2\', \'3\']", and\n   "\'  1  2   3  \'.split(None, 1)" returns "[\'1\', \'2   3  \']".\n\nstr.splitlines([keepends])\n\n   Return a list of the lines in the string, breaking at line\n   boundaries. This method uses the *universal newlines* approach to\n   splitting lines. Line breaks are not included in the resulting list\n   unless *keepends* is given and true.\n\n   For example, "\'ab c\\n\\nde fg\\rkl\\r\\n\'.splitlines()" returns "[\'ab\n   c\', \'\', \'de fg\', \'kl\']", while the same call with\n   "splitlines(True)" returns "[\'ab c\\n\', \'\\n\', \'de fg\\r\', \'kl\\r\\n\']".\n\n   Unlike "split()" when a delimiter string *sep* is given, this\n   method returns an empty list for the empty string, and a terminal\n   line break does not result in an extra line.\n\nstr.startswith(prefix[, start[, end]])\n\n   Return "True" if string starts with the *prefix*, otherwise return\n   "False". *prefix* can also be a tuple of prefixes to look for.\n   With optional *start*, test string beginning at that position.\n   With optional *end*, stop comparing string at that position.\n\n   Changed in version 2.5: Accept tuples as *prefix*.\n\nstr.strip([chars])\n\n   Return a copy of the string with the leading and trailing\n   characters removed. The *chars* argument is a string specifying the\n   set of characters to be removed. If omitted or "None", the *chars*\n   argument defaults to removing whitespace. The *chars* argument is\n   not a prefix or suffix; rather, all combinations of its values are\n   stripped:\n\n   >>> \'   spacious   \'.strip()\n   \'spacious\'\n   >>> \'www.example.com\'.strip(\'cmowz.\')\n   \'example\'\n\n   Changed in version 2.2.2: Support for the *chars* argument.\n\nstr.swapcase()\n\n   Return a copy of the string with uppercase characters converted to\n   lowercase and vice versa.\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.title()\n\n   Return a titlecased version of the string where words start with an\n   uppercase character and the remaining characters are lowercase.\n\n   The algorithm uses a simple language-independent definition of a\n   word as groups of consecutive letters.  The definition works in\n   many contexts but it means that apostrophes in contractions and\n   possessives form word boundaries, which may not be the desired\n   result:\n\n      >>> "they\'re bill\'s friends from the UK".title()\n      "They\'Re Bill\'S Friends From The Uk"\n\n   A workaround for apostrophes can be constructed using regular\n   expressions:\n\n      >>> import re\n      >>> def titlecase(s):\n      ...     return re.sub(r"[A-Za-z]+(\'[A-Za-z]+)?",\n      ...                   lambda mo: mo.group(0)[0].upper() +\n      ...                              mo.group(0)[1:].lower(),\n      ...                   s)\n      ...\n      >>> titlecase("they\'re bill\'s friends.")\n      "They\'re Bill\'s Friends."\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.translate(table[, deletechars])\n\n   Return a copy of the string where all characters occurring in the\n   optional argument *deletechars* are removed, and the remaining\n   characters have been mapped through the given translation table,\n   which must be a string of length 256.\n\n   You can use the "maketrans()" helper function in the "string"\n   module to create a translation table. For string objects, set the\n   *table* argument to "None" for translations that only delete\n   characters:\n\n   >>> \'read this short text\'.translate(None, \'aeiou\')\n   \'rd ths shrt txt\'\n\n   New in version 2.6: Support for a "None" *table* argument.\n\n   For Unicode objects, the "translate()" method does not accept the\n   optional *deletechars* argument.  Instead, it returns a copy of the\n   *s* where all characters have been mapped through the given\n   translation table which must be a mapping of Unicode ordinals to\n   Unicode ordinals, Unicode strings or "None". Unmapped characters\n   are left untouched. Characters mapped to "None" are deleted.  Note,\n   a more flexible approach is to create a custom character mapping\n   codec using the "codecs" module (see "encodings.cp1251" for an\n   example).\n\nstr.upper()\n\n   Return a copy of the string with all the cased characters [4]\n   converted to uppercase.  Note that "str.upper().isupper()" might be\n   "False" if "s" contains uncased characters or if the Unicode\n   category of the resulting character(s) is not "Lu" (Letter,\n   uppercase), but e.g. "Lt" (Letter, titlecase).\n\n   For 8-bit strings, this method is locale-dependent.\n\nstr.zfill(width)\n\n   Return the numeric string left filled with zeros in a string of\n   length *width*.  A sign prefix is handled correctly.  The original\n   string is returned if *width* is less than or equal to "len(s)".\n\n   New in version 2.2.2.\n\nThe following methods are present only on unicode objects:\n\nunicode.isnumeric()\n\n   Return "True" if there are only numeric characters in S, "False"\n   otherwise. Numeric characters include digit characters, and all\n   characters that have the Unicode numeric value property, e.g.\n   U+2155, VULGAR FRACTION ONE FIFTH.\n\nunicode.isdecimal()\n\n   Return "True" if there are only decimal characters in S, "False"\n   otherwise. Decimal characters include digit characters, and all\n   characters that can be used to form decimal-radix numbers, e.g.\n   U+0660, ARABIC-INDIC DIGIT ZERO.\n\n\nString Formatting Operations\n============================\n\nString and Unicode objects have one unique built-in operation: the "%"\noperator (modulo).  This is also known as the string *formatting* or\n*interpolation* operator.  Given "format % values" (where *format* is\na string or Unicode object), "%" conversion specifications in *format*\nare replaced with zero or more elements of *values*.  The effect is\nsimilar to the using "sprintf()" in the C language.  If *format* is a\nUnicode object, or if any of the objects being converted using the\n"%s" conversion are Unicode objects, the result will also be a Unicode\nobject.\n\nIf *format* requires a single argument, *values* may be a single non-\ntuple object. [5]  Otherwise, *values* must be a tuple with exactly\nthe number of items specified by the format string, or a single\nmapping object (for example, a dictionary).\n\nA conversion specifier contains two or more characters and has the\nfollowing components, which must occur in this order:\n\n1. The "\'%\'" character, which marks the start of the specifier.\n\n2. Mapping key (optional), consisting of a parenthesised sequence\n   of characters (for example, "(somename)").\n\n3. Conversion flags (optional), which affect the result of some\n   conversion types.\n\n4. Minimum field width (optional).  If specified as an "\'*\'"\n   (asterisk), the actual width is read from the next element of the\n   tuple in *values*, and the object to convert comes after the\n   minimum field width and optional precision.\n\n5. Precision (optional), given as a "\'.\'" (dot) followed by the\n   precision.  If specified as "\'*\'" (an asterisk), the actual width\n   is read from the next element of the tuple in *values*, and the\n   value to convert comes after the precision.\n\n6. Length modifier (optional).\n\n7. Conversion type.\n\nWhen the right argument is a dictionary (or other mapping type), then\nthe formats in the string *must* include a parenthesised mapping key\ninto that dictionary inserted immediately after the "\'%\'" character.\nThe mapping key selects the value to be formatted from the mapping.\nFor example:\n\n>>> print \'%(language)s has %(number)03d quote types.\' % \\\n...       {"language": "Python", "number": 2}\nPython has 002 quote types.\n\nIn this case no "*" specifiers may occur in a format (since they\nrequire a sequential parameter list).\n\nThe conversion flag characters are:\n\n+-----------+-----------------------------------------------------------------------+\n| Flag      | Meaning                                                               |\n+===========+=======================================================================+\n| "\'#\'"     | The value conversion will use the "alternate form" (where defined     |\n|           | below).                                                               |\n+-----------+-----------------------------------------------------------------------+\n| "\'0\'"     | The conversion will be zero padded for numeric values.                |\n+-----------+-----------------------------------------------------------------------+\n| "\'-\'"     | The converted value is left adjusted (overrides the "\'0\'" conversion  |\n|           | if both are given).                                                   |\n+-----------+-----------------------------------------------------------------------+\n| "\' \'"     | (a space) A blank should be left before a positive number (or empty   |\n|           | string) produced by a signed conversion.                              |\n+-----------+-----------------------------------------------------------------------+\n| "\'+\'"     | A sign character ("\'+\'" or "\'-\'") will precede the conversion         |\n|           | (overrides a "space" flag).                                           |\n+-----------+-----------------------------------------------------------------------+\n\nA length modifier ("h", "l", or "L") may be present, but is ignored as\nit is not necessary for Python -- so e.g. "%ld" is identical to "%d".\n\nThe conversion types are:\n\n+--------------+-------------------------------------------------------+---------+\n| Conversion   | Meaning                                               | Notes   |\n+==============+=======================================================+=========+\n| "\'d\'"        | Signed integer decimal.                               |         |\n+--------------+-------------------------------------------------------+---------+\n| "\'i\'"        | Signed integer decimal.                               |         |\n+--------------+-------------------------------------------------------+---------+\n| "\'o\'"        | Signed octal value.                                   | (1)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'u\'"        | Obsolete type -- it is identical to "\'d\'".            | (7)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'x\'"        | Signed hexadecimal (lowercase).                       | (2)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'X\'"        | Signed hexadecimal (uppercase).                       | (2)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'e\'"        | Floating point exponential format (lowercase).        | (3)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'E\'"        | Floating point exponential format (uppercase).        | (3)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'f\'"        | Floating point decimal format.                        | (3)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'F\'"        | Floating point decimal format.                        | (3)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'g\'"        | Floating point format. Uses lowercase exponential     | (4)     |\n|              | format if exponent is less than -4 or not less than   |         |\n|              | precision, decimal format otherwise.                  |         |\n+--------------+-------------------------------------------------------+---------+\n| "\'G\'"        | Floating point format. Uses uppercase exponential     | (4)     |\n|              | format if exponent is less than -4 or not less than   |         |\n|              | precision, decimal format otherwise.                  |         |\n+--------------+-------------------------------------------------------+---------+\n| "\'c\'"        | Single character (accepts integer or single character |         |\n|              | string).                                              |         |\n+--------------+-------------------------------------------------------+---------+\n| "\'r\'"        | String (converts any Python object using *repr()*).   | (5)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'s\'"        | String (converts any Python object using "str()").    | (6)     |\n+--------------+-------------------------------------------------------+---------+\n| "\'%\'"        | No argument is converted, results in a "\'%\'"          |         |\n|              | character in the result.                              |         |\n+--------------+-------------------------------------------------------+---------+\n\nNotes:\n\n1. The alternate form causes a leading zero ("\'0\'") to be inserted\n   between left-hand padding and the formatting of the number if the\n   leading character of the result is not already a zero.\n\n2. The alternate form causes a leading "\'0x\'" or "\'0X\'" (depending\n   on whether the "\'x\'" or "\'X\'" format was used) to be inserted\n   between left-hand padding and the formatting of the number if the\n   leading character of the result is not already a zero.\n\n3. The alternate form causes the result to always contain a decimal\n   point, even if no digits follow it.\n\n   The precision determines the number of digits after the decimal\n   point and defaults to 6.\n\n4. The alternate form causes the result to always contain a decimal\n   point, and trailing zeroes are not removed as they would otherwise\n   be.\n\n   The precision determines the number of significant digits before\n   and after the decimal point and defaults to 6.\n\n5. The "%r" conversion was added in Python 2.0.\n\n   The precision determines the maximal number of characters used.\n\n6. If the object or format provided is a "unicode" string, the\n   resulting string will also be "unicode".\n\n   The precision determines the maximal number of characters used.\n\n7. See **PEP 237**.\n\nSince Python strings have an explicit length, "%s" conversions do not\nassume that "\'\\0\'" is the end of the string.\n\nChanged in version 2.7: "%f" conversions for numbers whose absolute\nvalue is over 1e50 are no longer replaced by "%g" conversions.\n\nAdditional string operations are defined in standard modules "string"\nand "re".\n\n\nXRange Type\n===========\n\nThe "xrange" type is an immutable sequence which is commonly used for\nlooping.  The advantage of the "xrange" type is that an "xrange"\nobject will always take the same amount of memory, no matter the size\nof the range it represents.  There are no consistent performance\nadvantages.\n\nXRange objects have very little behavior: they only support indexing,\niteration, and the "len()" function.\n\n\nMutable Sequence Types\n======================\n\nList and "bytearray" objects support additional operations that allow\nin-place modification of the object. Other mutable sequence types\n(when added to the language) should also support these operations.\nStrings and tuples are immutable sequence types: such objects cannot\nbe modified once created. The following operations are defined on\nmutable sequence types (where *x* is an arbitrary object):\n\n+--------------------------------+----------------------------------+-----------------------+\n| Operation                      | Result                           | Notes                 |\n+================================+==================================+=======================+\n| "s[i] = x"                     | item *i* of *s* is replaced by   |                       |\n|                                | *x*                              |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s[i:j] = t"                   | slice of *s* from *i* to *j* is  |                       |\n|                                | replaced by the contents of the  |                       |\n|                                | iterable *t*                     |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "del s[i:j]"                   | same as "s[i:j] = []"            |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s[i:j:k] = t"                 | the elements of "s[i:j:k]" are   | (1)                   |\n|                                | replaced by those of *t*         |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "del s[i:j:k]"                 | removes the elements of          |                       |\n|                                | "s[i:j:k]" from the list         |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.append(x)"                  | same as "s[len(s):len(s)] = [x]" | (2)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.extend(x)"                  | same as "s[len(s):len(s)] = x"   | (3)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.count(x)"                   | return number of *i*\'s for which |                       |\n|                                | "s[i] == x"                      |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.index(x[, i[, j]])"         | return smallest *k* such that    | (4)                   |\n|                                | "s[k] == x" and "i <= k < j"     |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.insert(i, x)"               | same as "s[i:i] = [x]"           | (5)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.pop([i])"                   | same as "x = s[i]; del s[i];     | (6)                   |\n|                                | return x"                        |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.remove(x)"                  | same as "del s[s.index(x)]"      | (4)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.reverse()"                  | reverses the items of *s* in     | (7)                   |\n|                                | place                            |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.sort([cmp[, key[,           | sort the items of *s* in place   | (7)(8)(9)(10)         |\n| reverse]]])"                   |                                  |                       |\n+--------------------------------+----------------------------------+-----------------------+\n\nNotes:\n\n1. *t* must have the same length as the slice it is  replacing.\n\n2. The C implementation of Python has historically accepted\n   multiple parameters and implicitly joined them into a tuple; this\n   no longer works in Python 2.0.  Use of this misfeature has been\n   deprecated since Python 1.4.\n\n3. *x* can be any iterable object.\n\n4. Raises "ValueError" when *x* is not found in *s*. When a\n   negative index is passed as the second or third parameter to the\n   "index()" method, the list length is added, as for slice indices.\n   If it is still negative, it is truncated to zero, as for slice\n   indices.\n\n   Changed in version 2.3: Previously, "index()" didn\'t have arguments\n   for specifying start and stop positions.\n\n5. When a negative index is passed as the first parameter to the\n   "insert()" method, the list length is added, as for slice indices.\n   If it is still negative, it is truncated to zero, as for slice\n   indices.\n\n   Changed in version 2.3: Previously, all negative indices were\n   truncated to zero.\n\n6. The "pop()" method\'s optional argument *i* defaults to "-1", so\n   that by default the last item is removed and returned.\n\n7. The "sort()" and "reverse()" methods modify the list in place\n   for economy of space when sorting or reversing a large list.  To\n   remind you that they operate by side effect, they don\'t return the\n   sorted or reversed list.\n\n8. The "sort()" method takes optional arguments for controlling the\n   comparisons.\n\n   *cmp* specifies a custom comparison function of two arguments (list\n   items) which should return a negative, zero or positive number\n   depending on whether the first argument is considered smaller than,\n   equal to, or larger than the second argument: "cmp=lambda x,y:\n   cmp(x.lower(), y.lower())".  The default value is "None".\n\n   *key* specifies a function of one argument that is used to extract\n   a comparison key from each list element: "key=str.lower".  The\n   default value is "None".\n\n   *reverse* is a boolean value.  If set to "True", then the list\n   elements are sorted as if each comparison were reversed.\n\n   In general, the *key* and *reverse* conversion processes are much\n   faster than specifying an equivalent *cmp* function.  This is\n   because *cmp* is called multiple times for each list element while\n   *key* and *reverse* touch each element only once.  Use\n   "functools.cmp_to_key()" to convert an old-style *cmp* function to\n   a *key* function.\n\n   Changed in version 2.3: Support for "None" as an equivalent to\n   omitting *cmp* was added.\n\n   Changed in version 2.4: Support for *key* and *reverse* was added.\n\n9. Starting with Python 2.3, the "sort()" method is guaranteed to\n   be stable.  A sort is stable if it guarantees not to change the\n   relative order of elements that compare equal --- this is helpful\n   for sorting in multiple passes (for example, sort by department,\n   then by salary grade).\n\n10. **CPython implementation detail:** While a list is being\n    sorted, the effect of attempting to mutate, or even inspect, the\n    list is undefined.  The C implementation of Python 2.3 and newer\n    makes the list appear empty for the duration, and raises\n    "ValueError" if it can detect that the list has been mutated\n    during a sort.\n',
 'typesseq-mutable': u'\nMutable Sequence Types\n**********************\n\nList and "bytearray" objects support additional operations that allow\nin-place modification of the object. Other mutable sequence types\n(when added to the language) should also support these operations.\nStrings and tuples are immutable sequence types: such objects cannot\nbe modified once created. The following operations are defined on\nmutable sequence types (where *x* is an arbitrary object):\n\n+--------------------------------+----------------------------------+-----------------------+\n| Operation                      | Result                           | Notes                 |\n+================================+==================================+=======================+\n| "s[i] = x"                     | item *i* of *s* is replaced by   |                       |\n|                                | *x*                              |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s[i:j] = t"                   | slice of *s* from *i* to *j* is  |                       |\n|                                | replaced by the contents of the  |                       |\n|                                | iterable *t*                     |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "del s[i:j]"                   | same as "s[i:j] = []"            |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s[i:j:k] = t"                 | the elements of "s[i:j:k]" are   | (1)                   |\n|                                | replaced by those of *t*         |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "del s[i:j:k]"                 | removes the elements of          |                       |\n|                                | "s[i:j:k]" from the list         |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.append(x)"                  | same as "s[len(s):len(s)] = [x]" | (2)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.extend(x)"                  | same as "s[len(s):len(s)] = x"   | (3)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.count(x)"                   | return number of *i*\'s for which |                       |\n|                                | "s[i] == x"                      |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.index(x[, i[, j]])"         | return smallest *k* such that    | (4)                   |\n|                                | "s[k] == x" and "i <= k < j"     |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.insert(i, x)"               | same as "s[i:i] = [x]"           | (5)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.pop([i])"                   | same as "x = s[i]; del s[i];     | (6)                   |\n|                                | return x"                        |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.remove(x)"                  | same as "del s[s.index(x)]"      | (4)                   |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.reverse()"                  | reverses the items of *s* in     | (7)                   |\n|                                | place                            |                       |\n+--------------------------------+----------------------------------+-----------------------+\n| "s.sort([cmp[, key[,           | sort the items of *s* in place   | (7)(8)(9)(10)         |\n| reverse]]])"                   |                                  |                       |\n+--------------------------------+----------------------------------+-----------------------+\n\nNotes:\n\n1. *t* must have the same length as the slice it is  replacing.\n\n2. The C implementation of Python has historically accepted\n   multiple parameters and implicitly joined them into a tuple; this\n   no longer works in Python 2.0.  Use of this misfeature has been\n   deprecated since Python 1.4.\n\n3. *x* can be any iterable object.\n\n4. Raises "ValueError" when *x* is not found in *s*. When a\n   negative index is passed as the second or third parameter to the\n   "index()" method, the list length is added, as for slice indices.\n   If it is still negative, it is truncated to zero, as for slice\n   indices.\n\n   Changed in version 2.3: Previously, "index()" didn\'t have arguments\n   for specifying start and stop positions.\n\n5. When a negative index is passed as the first parameter to the\n   "insert()" method, the list length is added, as for slice indices.\n   If it is still negative, it is truncated to zero, as for slice\n   indices.\n\n   Changed in version 2.3: Previously, all negative indices were\n   truncated to zero.\n\n6. The "pop()" method\'s optional argument *i* defaults to "-1", so\n   that by default the last item is removed and returned.\n\n7. The "sort()" and "reverse()" methods modify the list in place\n   for economy of space when sorting or reversing a large list.  To\n   remind you that they operate by side effect, they don\'t return the\n   sorted or reversed list.\n\n8. The "sort()" method takes optional arguments for controlling the\n   comparisons.\n\n   *cmp* specifies a custom comparison function of two arguments (list\n   items) which should return a negative, zero or positive number\n   depending on whether the first argument is considered smaller than,\n   equal to, or larger than the second argument: "cmp=lambda x,y:\n   cmp(x.lower(), y.lower())".  The default value is "None".\n\n   *key* specifies a function of one argument that is used to extract\n   a comparison key from each list element: "key=str.lower".  The\n   default value is "None".\n\n   *reverse* is a boolean value.  If set to "True", then the list\n   elements are sorted as if each comparison were reversed.\n\n   In general, the *key* and *reverse* conversion processes are much\n   faster than specifying an equivalent *cmp* function.  This is\n   because *cmp* is called multiple times for each list element while\n   *key* and *reverse* touch each element only once.  Use\n   "functools.cmp_to_key()" to convert an old-style *cmp* function to\n   a *key* function.\n\n   Changed in version 2.3: Support for "None" as an equivalent to\n   omitting *cmp* was added.\n\n   Changed in version 2.4: Support for *key* and *reverse* was added.\n\n9. Starting with Python 2.3, the "sort()" method is guaranteed to\n   be stable.  A sort is stable if it guarantees not to change the\n   relative order of elements that compare equal --- this is helpful\n   for sorting in multiple passes (for example, sort by department,\n   then by salary grade).\n\n10. **CPython implementation detail:** While a list is being\n    sorted, the effect of attempting to mutate, or even inspect, the\n    list is undefined.  The C implementation of Python 2.3 and newer\n    makes the list appear empty for the duration, and raises\n    "ValueError" if it can detect that the list has been mutated\n    during a sort.\n',
 'unary': u'\nUnary arithmetic and bitwise operations\n***************************************\n\nAll unary arithmetic and bitwise operations have the same priority:\n\n   u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr\n\nThe unary "-" (minus) operator yields the negation of its numeric\nargument.\n\nThe unary "+" (plus) operator yields its numeric argument unchanged.\n\nThe unary "~" (invert) operator yields the bitwise inversion of its\nplain or long integer argument.  The bitwise inversion of "x" is\ndefined as "-(x+1)".  It only applies to integral numbers.\n\nIn all three cases, if the argument does not have the proper type, a\n"TypeError" exception is raised.\n',
 'while': u'\nThe "while" statement\n*********************\n\nThe "while" statement is used for repeated execution as long as an\nexpression is true:\n\n   while_stmt ::= "while" expression ":" suite\n                  ["else" ":" suite]\n\nThis repeatedly tests the expression and, if it is true, executes the\nfirst suite; if the expression is false (which may be the first time\nit is tested) the suite of the "else" clause, if present, is executed\nand the loop terminates.\n\nA "break" statement executed in the first suite terminates the loop\nwithout executing the "else" clause\'s suite.  A "continue" statement\nexecuted in the first suite skips the rest of the suite and goes back\nto testing the expression.\n',
 'with': u'\nThe "with" statement\n********************\n\nNew in version 2.5.\n\nThe "with" statement is used to wrap the execution of a block with\nmethods defined by a context manager (see section *With Statement\nContext Managers*). This allows common "try"..."except"..."finally"\nusage patterns to be encapsulated for convenient reuse.\n\n   with_stmt ::= "with" with_item ("," with_item)* ":" suite\n   with_item ::= expression ["as" target]\n\nThe execution of the "with" statement with one "item" proceeds as\nfollows:\n\n1. The context expression (the expression given in the "with_item")\n   is evaluated to obtain a context manager.\n\n2. The context manager\'s "__exit__()" is loaded for later use.\n\n3. The context manager\'s "__enter__()" method is invoked.\n\n4. If a target was included in the "with" statement, the return\n   value from "__enter__()" is assigned to it.\n\n   Note: The "with" statement guarantees that if the "__enter__()"\n     method returns without an error, then "__exit__()" will always be\n     called. Thus, if an error occurs during the assignment to the\n     target list, it will be treated the same as an error occurring\n     within the suite would be. See step 6 below.\n\n5. The suite is executed.\n\n6. The context manager\'s "__exit__()" method is invoked. If an\n   exception caused the suite to be exited, its type, value, and\n   traceback are passed as arguments to "__exit__()". Otherwise, three\n   "None" arguments are supplied.\n\n   If the suite was exited due to an exception, and the return value\n   from the "__exit__()" method was false, the exception is reraised.\n   If the return value was true, the exception is suppressed, and\n   execution continues with the statement following the "with"\n   statement.\n\n   If the suite was exited for any reason other than an exception, the\n   return value from "__exit__()" is ignored, and execution proceeds\n   at the normal location for the kind of exit that was taken.\n\nWith more than one item, the context managers are processed as if\nmultiple "with" statements were nested:\n\n   with A() as a, B() as b:\n       suite\n\nis equivalent to\n\n   with A() as a:\n       with B() as b:\n           suite\n\nNote: In Python 2.5, the "with" statement is only allowed when the\n  "with_statement" feature has been enabled.  It is always enabled in\n  Python 2.6.\n\nChanged in version 2.7: Support for multiple context expressions.\n\nSee also: **PEP 0343** - The "with" statement\n\n     The specification, background, and examples for the Python "with"\n     statement.\n',
 'yield': u'\nThe "yield" statement\n*********************\n\n   yield_stmt ::= yield_expression\n\nThe "yield" statement is only used when defining a generator function,\nand is only used in the body of the generator function. Using a\n"yield" statement in a function definition is sufficient to cause that\ndefinition to create a generator function instead of a normal\nfunction.\n\nWhen a generator function is called, it returns an iterator known as a\ngenerator iterator, or more commonly, a generator.  The body of the\ngenerator function is executed by calling the generator\'s "next()"\nmethod repeatedly until it raises an exception.\n\nWhen a "yield" statement is executed, the state of the generator is\nfrozen and the value of "expression_list" is returned to "next()"\'s\ncaller.  By "frozen" we mean that all local state is retained,\nincluding the current bindings of local variables, the instruction\npointer, and the internal evaluation stack: enough information is\nsaved so that the next time "next()" is invoked, the function can\nproceed exactly as if the "yield" statement were just another external\ncall.\n\nAs of Python version 2.5, the "yield" statement is now allowed in the\n"try" clause of a "try" ...  "finally" construct.  If the generator is\nnot resumed before it is finalized (by reaching a zero reference count\nor by being garbage collected), the generator-iterator\'s "close()"\nmethod will be called, allowing any pending "finally" clauses to\nexecute.\n\nFor full details of "yield" semantics, refer to the *Yield\nexpressions* section.\n\nNote: In Python 2.2, the "yield" statement was only allowed when the\n  "generators" feature has been enabled.  This "__future__" import\n  statement was used to enable the feature:\n\n     from __future__ import generators\n\nSee also: **PEP 0255** - Simple Generators\n\n     The proposal for adding generators and the "yield" statement to\n     Python.\n\n  **PEP 0342** - Coroutines via Enhanced Generators\n     The proposal that, among other generator enhancements, proposed\n     allowing "yield" to appear inside a "try" ... "finally" block.\n'}
                                   usr/lib/python2.7/pydoc_data/topics.pyc                                                             0100644 0000000 0000000 00001403555 13077704275 016552  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s,  iN d  d 6d d 6d d 6d d 6d d	 6d
 d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d  d! 6d" d# 6d$ d% 6d& d' 6d( d) 6d* d+ 6d, d- 6d. d/ 6d0 d1 6d2 d3 6d4 d5 6d6 d7 6d8 d9 6d: d; 6d< d= 6d> d? 6d@ dA 6dB dC 6dD dE 6dF dG 6dH dI 6dJ dK 6dL dM 6dN dO 6d8 dP 6dQ dR 6dS dT 6d$ dU 6dV dW 6dX dY 6dZ d[ 6d\ d] 6d^ d_ 6d` da 6db dc 6dd de 6df dg 6dh di 6dj dk 6dl dm 6dn do 6dp dq 6dr ds 6dt du 6dv dw 6dx dy 6dz d{ 6d| d} 6d~ d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6d d 6Z  d S(   ur  
The "assert" statement
**********************

Assert statements are a convenient way to insert debugging assertions
into a program:

   assert_stmt ::= "assert" expression ["," expression]

The simple form, "assert expression", is equivalent to

   if __debug__:
      if not expression: raise AssertionError

The extended form, "assert expression1, expression2", is equivalent to

   if __debug__:
      if not expression1: raise AssertionError(expression2)

These equivalences assume that "__debug__" and "AssertionError" refer
to the built-in variables with those names.  In the current
implementation, the built-in variable "__debug__" is "True" under
normal circumstances, "False" when optimization is requested (command
line option -O).  The current code generator emits no code for an
assert statement when optimization is requested at compile time.  Note
that it is unnecessary to include the source code for the expression
that failed in the error message; it will be displayed as part of the
stack trace.

Assignments to "__debug__" are illegal.  The value for the built-in
variable is determined when the interpreter starts.
t   assertu  
Assignment statements
*********************

Assignment statements are used to (re)bind names to values and to
modify attributes or items of mutable objects:

   assignment_stmt ::= (target_list "=")+ (expression_list | yield_expression)
   target_list     ::= target ("," target)* [","]
   target          ::= identifier
              | "(" target_list ")"
              | "[" target_list "]"
              | attributeref
              | subscription
              | slicing

(See section *Primaries* for the syntax definitions for the last three
symbols.)

An assignment statement evaluates the expression list (remember that
this can be a single expression or a comma-separated list, the latter
yielding a tuple) and assigns the single resulting object to each of
the target lists, from left to right.

Assignment is defined recursively depending on the form of the target
(list). When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must
ultimately perform the assignment and decide about its validity, and
may raise an exception if the assignment is unacceptable.  The rules
observed by various types and the exceptions raised are given with the
definition of the object types (see section *The standard type
hierarchy*).

Assignment of an object to a target list is recursively defined as
follows.

* If the target list is a single target: The object is assigned to
  that target.

* If the target list is a comma-separated list of targets: The
  object must be an iterable with the same number of items as there
  are targets in the target list, and the items are assigned, from
  left to right, to the corresponding targets.

Assignment of an object to a single target is recursively defined as
follows.

* If the target is an identifier (name):

  * If the name does not occur in a "global" statement in the
    current code block: the name is bound to the object in the current
    local namespace.

  * Otherwise: the name is bound to the object in the current global
    namespace.

  The name is rebound if it was already bound.  This may cause the
  reference count for the object previously bound to the name to reach
  zero, causing the object to be deallocated and its destructor (if it
  has one) to be called.

* If the target is a target list enclosed in parentheses or in
  square brackets: The object must be an iterable with the same number
  of items as there are targets in the target list, and its items are
  assigned, from left to right, to the corresponding targets.

* If the target is an attribute reference: The primary expression in
  the reference is evaluated.  It should yield an object with
  assignable attributes; if this is not the case, "TypeError" is
  raised.  That object is then asked to assign the assigned object to
  the given attribute; if it cannot perform the assignment, it raises
  an exception (usually but not necessarily "AttributeError").

  Note: If the object is a class instance and the attribute reference
  occurs on both sides of the assignment operator, the RHS expression,
  "a.x" can access either an instance attribute or (if no instance
  attribute exists) a class attribute.  The LHS target "a.x" is always
  set as an instance attribute, creating it if necessary.  Thus, the
  two occurrences of "a.x" do not necessarily refer to the same
  attribute: if the RHS expression refers to a class attribute, the
  LHS creates a new instance attribute as the target of the
  assignment:

     class Cls:
         x = 3             # class variable
     inst = Cls()
     inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3

  This description does not necessarily apply to descriptor
  attributes, such as properties created with "property()".

* If the target is a subscription: The primary expression in the
  reference is evaluated.  It should yield either a mutable sequence
  object (such as a list) or a mapping object (such as a dictionary).
  Next, the subscript expression is evaluated.

  If the primary is a mutable sequence object (such as a list), the
  subscript must yield a plain integer.  If it is negative, the
  sequence's length is added to it. The resulting value must be a
  nonnegative integer less than the sequence's length, and the
  sequence is asked to assign the assigned object to its item with
  that index.  If the index is out of range, "IndexError" is raised
  (assignment to a subscripted sequence cannot add new items to a
  list).

  If the primary is a mapping object (such as a dictionary), the
  subscript must have a type compatible with the mapping's key type,
  and the mapping is then asked to create a key/datum pair which maps
  the subscript to the assigned object.  This can either replace an
  existing key/value pair with the same key value, or insert a new
  key/value pair (if no key with the same value existed).

* If the target is a slicing: The primary expression in the
  reference is evaluated.  It should yield a mutable sequence object
  (such as a list).  The assigned object should be a sequence object
  of the same type.  Next, the lower and upper bound expressions are
  evaluated, insofar they are present; defaults are zero and the
  sequence's length.  The bounds should evaluate to (small) integers.
  If either bound is negative, the sequence's length is added to it.
  The resulting bounds are clipped to lie between zero and the
  sequence's length, inclusive.  Finally, the sequence object is asked
  to replace the slice with the items of the assigned sequence.  The
  length of the slice may be different from the length of the assigned
  sequence, thus changing the length of the target sequence, if the
  object allows it.

**CPython implementation detail:** In the current implementation, the
syntax for targets is taken to be the same as for expressions, and
invalid syntax is rejected during the code generation phase, causing
less detailed error messages.

WARNING: Although the definition of assignment implies that overlaps
between the left-hand side and the right-hand side are 'safe' (for
example "a, b = b, a" swaps two variables), overlaps *within* the
collection of assigned-to variables are not safe!  For instance, the
following program prints "[0, 2]":

   x = [0, 1]
   i = 0
   i, x[i] = 1, 2
   print x


Augmented assignment statements
===============================

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

   augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
   augtarget                 ::= identifier | attributeref | subscription | slicing
   augop                     ::= "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
             | ">>=" | "<<=" | "&=" | "^=" | "|="

(See section *Primaries* for the syntax definitions for the last three
symbols.)

An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression
list, performs the binary operation specific to the type of assignment
on the two operands, and assigns the result to the original target.
The target is only evaluated once.

An augmented assignment expression like "x += 1" can be rewritten as
"x = x + 1" to achieve a similar, but not exactly equal effect. In the
augmented version, "x" is only evaluated once. Also, when possible,
the actual operation is performed *in-place*, meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment
statements is handled the same way as normal assignments. Similarly,
with the exception of the possible *in-place* behavior, the binary
operation performed by augmented assignment is the same as the normal
binary operations.

For targets which are attribute references, the same *caveat about
class and instance attributes* applies as for regular assignments.
t
   assignmentu  
Identifiers (Names)
*******************

An identifier occurring as an atom is a name.  See section
*Identifiers and keywords* for lexical definition and section *Naming
and binding* for documentation of naming and binding.

When the name is bound to an object, evaluation of the atom yields
that object. When a name is not bound, an attempt to evaluate it
raises a "NameError" exception.

**Private name mangling:** When an identifier that textually occurs in
a class definition begins with two or more underscore characters and
does not end in two or more underscores, it is considered a *private
name* of that class. Private names are transformed to a longer form
before code is generated for them.  The transformation inserts the
class name, with leading underscores removed and a single underscore
inserted, in front of the name.  For example, the identifier "__spam"
occurring in a class named "Ham" will be transformed to "_Ham__spam".
This transformation is independent of the syntactical context in which
the identifier is used.  If the transformed name is extremely long
(longer than 255 characters), implementation defined truncation may
happen. If the class name consists only of underscores, no
transformation is done.
s   atom-identifiersu
  
Literals
********

Python supports string literals and various numeric literals:

   literal ::= stringliteral | integer | longinteger
               | floatnumber | imagnumber

Evaluation of a literal yields an object of the given type (string,
integer, long integer, floating point number, complex number) with the
given value.  The value may be approximated in the case of floating
point and imaginary (complex) literals.  See section *Literals* for
details.

All literals correspond to immutable data types, and hence the
object's identity is less important than its value.  Multiple
evaluations of literals with the same value (either the same
occurrence in the program text or a different occurrence) may obtain
the same object or a different object with the same value.
s   atom-literalsuY*  
Customizing attribute access
****************************

The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of "x.name") for
class instances.

object.__getattr__(self, name)

   Called when an attribute lookup has not found the attribute in the
   usual places (i.e. it is not an instance attribute nor is it found
   in the class tree for "self").  "name" is the attribute name. This
   method should return the (computed) attribute value or raise an
   "AttributeError" exception.

   Note that if the attribute is found through the normal mechanism,
   "__getattr__()" is not called.  (This is an intentional asymmetry
   between "__getattr__()" and "__setattr__()".) This is done both for
   efficiency reasons and because otherwise "__getattr__()" would have
   no way to access other attributes of the instance.  Note that at
   least for instance variables, you can fake total control by not
   inserting any values in the instance attribute dictionary (but
   instead inserting them in another object).  See the
   "__getattribute__()" method below for a way to actually get total
   control in new-style classes.

object.__setattr__(self, name, value)

   Called when an attribute assignment is attempted.  This is called
   instead of the normal mechanism (i.e. store the value in the
   instance dictionary).  *name* is the attribute name, *value* is the
   value to be assigned to it.

   If "__setattr__()" wants to assign to an instance attribute, it
   should not simply execute "self.name = value" --- this would cause
   a recursive call to itself.  Instead, it should insert the value in
   the dictionary of instance attributes, e.g., "self.__dict__[name] =
   value".  For new-style classes, rather than accessing the instance
   dictionary, it should call the base class method with the same
   name, for example, "object.__setattr__(self, name, value)".

object.__delattr__(self, name)

   Like "__setattr__()" but for attribute deletion instead of
   assignment.  This should only be implemented if "del obj.name" is
   meaningful for the object.


More attribute access for new-style classes
===========================================

The following methods only apply to new-style classes.

object.__getattribute__(self, name)

   Called unconditionally to implement attribute accesses for
   instances of the class. If the class also defines "__getattr__()",
   the latter will not be called unless "__getattribute__()" either
   calls it explicitly or raises an "AttributeError". This method
   should return the (computed) attribute value or raise an
   "AttributeError" exception. In order to avoid infinite recursion in
   this method, its implementation should always call the base class
   method with the same name to access any attributes it needs, for
   example, "object.__getattribute__(self, name)".

   Note: This method may still be bypassed when looking up special
     methods as the result of implicit invocation via language syntax
     or built-in functions. See *Special method lookup for new-style
     classes*.


Implementing Descriptors
========================

The following methods only apply when an instance of the class
containing the method (a so-called *descriptor* class) appears in an
*owner* class (the descriptor must be in either the owner's class
dictionary or in the class dictionary for one of its parents).  In the
examples below, "the attribute" refers to the attribute whose name is
the key of the property in the owner class' "__dict__".

object.__get__(self, instance, owner)

   Called to get the attribute of the owner class (class attribute
   access) or of an instance of that class (instance attribute
   access). *owner* is always the owner class, while *instance* is the
   instance that the attribute was accessed through, or "None" when
   the attribute is accessed through the *owner*.  This method should
   return the (computed) attribute value or raise an "AttributeError"
   exception.

object.__set__(self, instance, value)

   Called to set the attribute on an instance *instance* of the owner
   class to a new value, *value*.

object.__delete__(self, instance)

   Called to delete the attribute on an instance *instance* of the
   owner class.


Invoking Descriptors
====================

In general, a descriptor is an object attribute with "binding
behavior", one whose attribute access has been overridden by methods
in the descriptor protocol:  "__get__()", "__set__()", and
"__delete__()". If any of those methods are defined for an object, it
is said to be a descriptor.

The default behavior for attribute access is to get, set, or delete
the attribute from an object's dictionary. For instance, "a.x" has a
lookup chain starting with "a.__dict__['x']", then
"type(a).__dict__['x']", and continuing through the base classes of
"type(a)" excluding metaclasses.

However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.  Note that descriptors are only invoked for new
style objects or classes (ones that subclass "object()" or "type()").

The starting point for descriptor invocation is a binding, "a.x". How
the arguments are assembled depends on "a":

Direct Call
   The simplest and least common call is when user code directly
   invokes a descriptor method:    "x.__get__(a)".

Instance Binding
   If binding to a new-style object instance, "a.x" is transformed
   into the call: "type(a).__dict__['x'].__get__(a, type(a))".

Class Binding
   If binding to a new-style class, "A.x" is transformed into the
   call: "A.__dict__['x'].__get__(None, A)".

Super Binding
   If "a" is an instance of "super", then the binding "super(B,
   obj).m()" searches "obj.__class__.__mro__" for the base class "A"
   immediately preceding "B" and then invokes the descriptor with the
   call: "A.__dict__['m'].__get__(obj, obj.__class__)".

For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  A descriptor can define
any combination of "__get__()", "__set__()" and "__delete__()".  If it
does not define "__get__()", then accessing the attribute will return
the descriptor object itself unless there is a value in the object's
instance dictionary.  If the descriptor defines "__set__()" and/or
"__delete__()", it is a data descriptor; if it defines neither, it is
a non-data descriptor.  Normally, data descriptors define both
"__get__()" and "__set__()", while non-data descriptors have just the
"__get__()" method.  Data descriptors with "__set__()" and "__get__()"
defined always override a redefinition in an instance dictionary.  In
contrast, non-data descriptors can be overridden by instances.

Python methods (including "staticmethod()" and "classmethod()") are
implemented as non-data descriptors.  Accordingly, instances can
redefine and override methods.  This allows individual instances to
acquire behaviors that differ from other instances of the same class.

The "property()" function is implemented as a data descriptor.
Accordingly, instances cannot override the behavior of a property.


__slots__
=========

By default, instances of both old and new-style classes have a
dictionary for attribute storage.  This wastes space for objects
having very few instance variables.  The space consumption can become
acute when creating large numbers of instances.

The default can be overridden by defining *__slots__* in a new-style
class definition.  The *__slots__* declaration takes a sequence of
instance variables and reserves just enough space in each instance to
hold a value for each variable.  Space is saved because *__dict__* is
not created for each instance.

__slots__

   This class variable can be assigned a string, iterable, or sequence
   of strings with variable names used by instances.  If defined in a
   new-style class, *__slots__* reserves space for the declared
   variables and prevents the automatic creation of *__dict__* and
   *__weakref__* for each instance.

   New in version 2.2.

Notes on using *__slots__*

* When inheriting from a class without *__slots__*, the *__dict__*
  attribute of that class will always be accessible, so a *__slots__*
  definition in the subclass is meaningless.

* Without a *__dict__* variable, instances cannot be assigned new
  variables not listed in the *__slots__* definition.  Attempts to
  assign to an unlisted variable name raises "AttributeError". If
  dynamic assignment of new variables is desired, then add
  "'__dict__'" to the sequence of strings in the *__slots__*
  declaration.

  Changed in version 2.3: Previously, adding "'__dict__'" to the
  *__slots__* declaration would not enable the assignment of new
  attributes not specifically listed in the sequence of instance
  variable names.

* Without a *__weakref__* variable for each instance, classes
  defining *__slots__* do not support weak references to its
  instances. If weak reference support is needed, then add
  "'__weakref__'" to the sequence of strings in the *__slots__*
  declaration.

  Changed in version 2.3: Previously, adding "'__weakref__'" to the
  *__slots__* declaration would not enable support for weak
  references.

* *__slots__* are implemented at the class level by creating
  descriptors (*Implementing Descriptors*) for each variable name.  As
  a result, class attributes cannot be used to set default values for
  instance variables defined by *__slots__*; otherwise, the class
  attribute would overwrite the descriptor assignment.

* The action of a *__slots__* declaration is limited to the class
  where it is defined.  As a result, subclasses will have a *__dict__*
  unless they also define *__slots__* (which must only contain names
  of any *additional* slots).

* If a class defines a slot also defined in a base class, the
  instance variable defined by the base class slot is inaccessible
  (except by retrieving its descriptor directly from the base class).
  This renders the meaning of the program undefined.  In the future, a
  check may be added to prevent this.

* Nonempty *__slots__* does not work for classes derived from
  "variable-length" built-in types such as "long", "str" and "tuple".

* Any non-string iterable may be assigned to *__slots__*. Mappings
  may also be used; however, in the future, special meaning may be
  assigned to the values corresponding to each key.

* *__class__* assignment works only if both classes have the same
  *__slots__*.

  Changed in version 2.6: Previously, *__class__* assignment raised an
  error if either new or old class had *__slots__*.
s   attribute-accessu_  
Attribute references
********************

An attribute reference is a primary followed by a period and a name:

   attributeref ::= primary "." identifier

The primary must evaluate to an object of a type that supports
attribute references, e.g., a module, list, or an instance.  This
object is then asked to produce the attribute whose name is the
identifier.  If this attribute is not available, the exception
"AttributeError" is raised. Otherwise, the type and value of the
object produced is determined by the object.  Multiple evaluations of
the same attribute reference may yield different objects.
s   attribute-referencesu  
Augmented assignment statements
*******************************

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

   augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
   augtarget                 ::= identifier | attributeref | subscription | slicing
   augop                     ::= "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
             | ">>=" | "<<=" | "&=" | "^=" | "|="

(See section *Primaries* for the syntax definitions for the last three
symbols.)

An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression
list, performs the binary operation specific to the type of assignment
on the two operands, and assigns the result to the original target.
The target is only evaluated once.

An augmented assignment expression like "x += 1" can be rewritten as
"x = x + 1" to achieve a similar, but not exactly equal effect. In the
augmented version, "x" is only evaluated once. Also, when possible,
the actual operation is performed *in-place*, meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment
statements is handled the same way as normal assignments. Similarly,
with the exception of the possible *in-place* behavior, the binary
operation performed by augmented assignment is the same as the normal
binary operations.

For targets which are attribute references, the same *caveat about
class and instance attributes* applies as for regular assignments.
t	   augassignup  
Binary arithmetic operations
****************************

The binary arithmetic operations have the conventional priority
levels.  Note that some of these operations also apply to certain non-
numeric types.  Apart from the power operator, there are only two
levels, one for multiplicative operators and one for additive
operators:

   m_expr ::= u_expr | m_expr "*" u_expr | m_expr "//" u_expr | m_expr "/" u_expr
              | m_expr "%" u_expr
   a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr

The "*" (multiplication) operator yields the product of its arguments.
The arguments must either both be numbers, or one argument must be an
integer (plain or long) and the other must be a sequence. In the
former case, the numbers are converted to a common type and then
multiplied together.  In the latter case, sequence repetition is
performed; a negative repetition factor yields an empty sequence.

The "/" (division) and "//" (floor division) operators yield the
quotient of their arguments.  The numeric arguments are first
converted to a common type. Plain or long integer division yields an
integer of the same type; the result is that of mathematical division
with the 'floor' function applied to the result. Division by zero
raises the "ZeroDivisionError" exception.

The "%" (modulo) operator yields the remainder from the division of
the first argument by the second.  The numeric arguments are first
converted to a common type.  A zero right argument raises the
"ZeroDivisionError" exception.  The arguments may be floating point
numbers, e.g., "3.14%0.7" equals "0.34" (since "3.14" equals "4*0.7 +
0.34".)  The modulo operator always yields a result with the same sign
as its second operand (or zero); the absolute value of the result is
strictly smaller than the absolute value of the second operand [2].

The integer division and modulo operators are connected by the
following identity: "x == (x/y)*y + (x%y)".  Integer division and
modulo are also connected with the built-in function "divmod()":
"divmod(x, y) == (x/y, x%y)".  These identities don't hold for
floating point numbers; there similar identities hold approximately
where "x/y" is replaced by "floor(x/y)" or "floor(x/y) - 1" [3].

In addition to performing the modulo operation on numbers, the "%"
operator is also overloaded by string and unicode objects to perform
string formatting (also known as interpolation). The syntax for string
formatting is described in the Python Library Reference, section
*String Formatting Operations*.

Deprecated since version 2.3: The floor division operator, the modulo
operator, and the "divmod()" function are no longer defined for
complex numbers.  Instead, convert to a floating point number using
the "abs()" function if appropriate.

The "+" (addition) operator yields the sum of its arguments. The
arguments must either both be numbers or both sequences of the same
type.  In the former case, the numbers are converted to a common type
and then added together.  In the latter case, the sequences are
concatenated.

The "-" (subtraction) operator yields the difference of its arguments.
The numeric arguments are first converted to a common type.
t   binaryu  
Binary bitwise operations
*************************

Each of the three bitwise operations has a different priority level:

   and_expr ::= shift_expr | and_expr "&" shift_expr
   xor_expr ::= and_expr | xor_expr "^" and_expr
   or_expr  ::= xor_expr | or_expr "|" xor_expr

The "&" operator yields the bitwise AND of its arguments, which must
be plain or long integers.  The arguments are converted to a common
type.

The "^" operator yields the bitwise XOR (exclusive OR) of its
arguments, which must be plain or long integers.  The arguments are
converted to a common type.

The "|" operator yields the bitwise (inclusive) OR of its arguments,
which must be plain or long integers.  The arguments are converted to
a common type.
t   bitwiseu  
Code Objects
************

Code objects are used by the implementation to represent "pseudo-
compiled" executable Python code such as a function body. They differ
from function objects because they don't contain a reference to their
global execution environment.  Code objects are returned by the built-
in "compile()" function and can be extracted from function objects
through their "func_code" attribute. See also the "code" module.

A code object can be executed or evaluated by passing it (instead of a
source string) to the "exec" statement or the built-in "eval()"
function.

See *The standard type hierarchy* for more information.
s   bltin-code-objectsuG  
The Ellipsis Object
*******************

This object is used by extended slice notation (see *Slicings*).  It
supports no special operations.  There is exactly one ellipsis object,
named "Ellipsis" (a built-in name).

It is written as "Ellipsis".  When in a subscript, it can also be
written as "...", for example "seq[...]".
s   bltin-ellipsis-objectu   
The Null Object
***************

This object is returned by functions that don't explicitly return a
value.  It supports no special operations.  There is exactly one null
object, named "None" (a built-in name).

It is written as "None".
s   bltin-null-objectu3  
Type Objects
************

Type objects represent the various object types.  An object's type is
accessed by the built-in function "type()".  There are no special
operations on types.  The standard module "types" defines names for
all standard built-in types.

Types are written like this: "<type 'int'>".
s   bltin-type-objectsu  
Boolean operations
******************

   or_test  ::= and_test | or_test "or" and_test
   and_test ::= not_test | and_test "and" not_test
   not_test ::= comparison | "not" not_test

In the context of Boolean operations, and also when expressions are
used by control flow statements, the following values are interpreted
as false: "False", "None", numeric zero of all types, and empty
strings and containers (including strings, tuples, lists,
dictionaries, sets and frozensets).  All other values are interpreted
as true.  (See the "__nonzero__()" special method for a way to change
this.)

The operator "not" yields "True" if its argument is false, "False"
otherwise.

The expression "x and y" first evaluates *x*; if *x* is false, its
value is returned; otherwise, *y* is evaluated and the resulting value
is returned.

The expression "x or y" first evaluates *x*; if *x* is true, its value
is returned; otherwise, *y* is evaluated and the resulting value is
returned.

(Note that neither "and" nor "or" restrict the value and type they
return to "False" and "True", but rather return the last evaluated
argument. This is sometimes useful, e.g., if "s" is a string that
should be replaced by a default value if it is empty, the expression
"s or 'foo'" yields the desired value.  Because "not" has to invent a
value anyway, it does not bother to return a value of the same type as
its argument, so e.g., "not 'foo'" yields "False", not "''".)
t   booleansu%  
The "break" statement
*********************

   break_stmt ::= "break"

"break" may only occur syntactically nested in a "for" or "while"
loop, but not nested in a function or class definition within that
loop.

It terminates the nearest enclosing loop, skipping the optional "else"
clause if the loop has one.

If a "for" loop is terminated by "break", the loop control target
keeps its current value.

When "break" passes control out of a "try" statement with a "finally"
clause, that "finally" clause is executed before really leaving the
loop.
t   breaku   
Emulating callable objects
**************************

object.__call__(self[, args...])

   Called when the instance is "called" as a function; if this method
   is defined, "x(arg1, arg2, ...)" is a shorthand for
   "x.__call__(arg1, arg2, ...)".
s   callable-typesu  
Calls
*****

A call calls a callable object (e.g., a *function*) with a possibly
empty series of *arguments*:

   call                 ::= primary "(" [argument_list [","]
            | expression genexpr_for] ")"
   argument_list        ::= positional_arguments ["," keyword_arguments]
                       ["," "*" expression] ["," keyword_arguments]
                       ["," "**" expression]
                     | keyword_arguments ["," "*" expression]
                       ["," "**" expression]
                     | "*" expression ["," keyword_arguments] ["," "**" expression]
                     | "**" expression
   positional_arguments ::= expression ("," expression)*
   keyword_arguments    ::= keyword_item ("," keyword_item)*
   keyword_item         ::= identifier "=" expression

A trailing comma may be present after the positional and keyword
arguments but does not affect the semantics.

The primary must evaluate to a callable object (user-defined
functions, built-in functions, methods of built-in objects, class
objects, methods of class instances, and certain class instances
themselves are callable; extensions may define additional callable
object types).  All argument expressions are evaluated before the call
is attempted.  Please refer to section *Function definitions* for the
syntax of formal *parameter* lists.

If keyword arguments are present, they are first converted to
positional arguments, as follows.  First, a list of unfilled slots is
created for the formal parameters.  If there are N positional
arguments, they are placed in the first N slots.  Next, for each
keyword argument, the identifier is used to determine the
corresponding slot (if the identifier is the same as the first formal
parameter name, the first slot is used, and so on).  If the slot is
already filled, a "TypeError" exception is raised. Otherwise, the
value of the argument is placed in the slot, filling it (even if the
expression is "None", it fills the slot).  When all arguments have
been processed, the slots that are still unfilled are filled with the
corresponding default value from the function definition.  (Default
values are calculated, once, when the function is defined; thus, a
mutable object such as a list or dictionary used as default value will
be shared by all calls that don't specify an argument value for the
corresponding slot; this should usually be avoided.)  If there are any
unfilled slots for which no default value is specified, a "TypeError"
exception is raised.  Otherwise, the list of filled slots is used as
the argument list for the call.

**CPython implementation detail:** An implementation may provide
built-in functions whose positional parameters do not have names, even
if they are 'named' for the purpose of documentation, and which
therefore cannot be supplied by keyword.  In CPython, this is the case
for functions implemented in C that use "PyArg_ParseTuple()" to parse
their arguments.

If there are more positional arguments than there are formal parameter
slots, a "TypeError" exception is raised, unless a formal parameter
using the syntax "*identifier" is present; in this case, that formal
parameter receives a tuple containing the excess positional arguments
(or an empty tuple if there were no excess positional arguments).

If any keyword argument does not correspond to a formal parameter
name, a "TypeError" exception is raised, unless a formal parameter
using the syntax "**identifier" is present; in this case, that formal
parameter receives a dictionary containing the excess keyword
arguments (using the keywords as keys and the argument values as
corresponding values), or a (new) empty dictionary if there were no
excess keyword arguments.

If the syntax "*expression" appears in the function call, "expression"
must evaluate to an iterable.  Elements from this iterable are treated
as if they were additional positional arguments; if there are
positional arguments *x1*, ..., *xN*, and "expression" evaluates to a
sequence *y1*, ..., *yM*, this is equivalent to a call with M+N
positional arguments *x1*, ..., *xN*, *y1*, ..., *yM*.

A consequence of this is that although the "*expression" syntax may
appear *after* some keyword arguments, it is processed *before* the
keyword arguments (and the "**expression" argument, if any -- see
below).  So:

   >>> def f(a, b):
   ...  print a, b
   ...
   >>> f(b=1, *(2,))
   2 1
   >>> f(a=1, *(2,))
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   TypeError: f() got multiple values for keyword argument 'a'
   >>> f(1, *(2,))
   1 2

It is unusual for both keyword arguments and the "*expression" syntax
to be used in the same call, so in practice this confusion does not
arise.

If the syntax "**expression" appears in the function call,
"expression" must evaluate to a mapping, the contents of which are
treated as additional keyword arguments.  In the case of a keyword
appearing in both "expression" and as an explicit keyword argument, a
"TypeError" exception is raised.

Formal parameters using the syntax "*identifier" or "**identifier"
cannot be used as positional argument slots or as keyword argument
names.  Formal parameters using the syntax "(sublist)" cannot be used
as keyword argument names; the outermost sublist corresponds to a
single unnamed argument slot, and the argument value is assigned to
the sublist using the usual tuple assignment rules after all other
parameter processing is done.

A call always returns some value, possibly "None", unless it raises an
exception.  How this value is computed depends on the type of the
callable object.

If it is---

a user-defined function:
   The code block for the function is executed, passing it the
   argument list.  The first thing the code block will do is bind the
   formal parameters to the arguments; this is described in section
   *Function definitions*.  When the code block executes a "return"
   statement, this specifies the return value of the function call.

a built-in function or method:
   The result is up to the interpreter; see *Built-in Functions* for
   the descriptions of built-in functions and methods.

a class object:
   A new instance of that class is returned.

a class instance method:
   The corresponding user-defined function is called, with an argument
   list that is one longer than the argument list of the call: the
   instance becomes the first argument.

a class instance:
   The class must define a "__call__()" method; the effect is then the
   same as if that method was called.
t   callsuN
  
Class definitions
*****************

A class definition defines a class object (see section *The standard
type hierarchy*):

   classdef    ::= "class" classname [inheritance] ":" suite
   inheritance ::= "(" [expression_list] ")"
   classname   ::= identifier

A class definition is an executable statement.  It first evaluates the
inheritance list, if present.  Each item in the inheritance list
should evaluate to a class object or class type which allows
subclassing.  The class's suite is then executed in a new execution
frame (see section *Naming and binding*), using a newly created local
namespace and the original global namespace. (Usually, the suite
contains only function definitions.)  When the class's suite finishes
execution, its execution frame is discarded but its local namespace is
saved. [4] A class object is then created using the inheritance list
for the base classes and the saved local namespace for the attribute
dictionary.  The class name is bound to this class object in the
original local namespace.

**Programmer's note:** Variables defined in the class definition are
class variables; they are shared by all instances.  To create instance
variables, they can be set in a method with "self.name = value".  Both
class and instance variables are accessible through the notation
""self.name"", and an instance variable hides a class variable with
the same name when accessed in this way. Class variables can be used
as defaults for instance variables, but using mutable values there can
lead to unexpected results.  For *new-style class*es, descriptors can
be used to create instance variables with different implementation
details.

Class definitions, like function definitions, may be wrapped by one or
more *decorator* expressions.  The evaluation rules for the decorator
expressions are the same as for functions.  The result must be a class
object, which is then bound to the class name.

-[ Footnotes ]-

[1] The exception is propagated to the invocation stack unless
    there is a "finally" clause which happens to raise another
    exception. That new exception causes the old one to be lost.

[2] Currently, control "flows off the end" except in the case of
    an exception or the execution of a "return", "continue", or
    "break" statement.

[3] A string literal appearing as the first statement in the
    function body is transformed into the function's "__doc__"
    attribute and therefore the function's *docstring*.

[4] A string literal appearing as the first statement in the class
    body is transformed into the namespace's "__doc__" item and
    therefore the class's *docstring*.
t   classu3  
Comparisons
***********

Unlike C, all comparison operations in Python have the same priority,
which is lower than that of any arithmetic, shifting or bitwise
operation.  Also unlike C, expressions like "a < b < c" have the
interpretation that is conventional in mathematics:

   comparison    ::= or_expr ( comp_operator or_expr )*
   comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="
                     | "is" ["not"] | ["not"] "in"

Comparisons yield boolean values: "True" or "False".

Comparisons can be chained arbitrarily, e.g., "x < y <= z" is
equivalent to "x < y and y <= z", except that "y" is evaluated only
once (but in both cases "z" is not evaluated at all when "x < y" is
found to be false).

Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*,
*op2*, ..., *opN* are comparison operators, then "a op1 b op2 c ... y
opN z" is equivalent to "a op1 b and b op2 c and ... y opN z", except
that each expression is evaluated at most once.

Note that "a op1 b op2 c" doesn't imply any kind of comparison between
*a* and *c*, so that, e.g., "x < y > z" is perfectly legal (though
perhaps not pretty).

The forms "<>" and "!=" are equivalent; for consistency with C, "!="
is preferred; where "!=" is mentioned below "<>" is also accepted.
The "<>" spelling is considered obsolescent.

The operators "<", ">", "==", ">=", "<=", and "!=" compare the values
of two objects.  The objects need not have the same type. If both are
numbers, they are converted to a common type.  Otherwise, objects of
different types *always* compare unequal, and are ordered consistently
but arbitrarily. You can control comparison behavior of objects of
non-built-in types by defining a "__cmp__" method or rich comparison
methods like "__gt__", described in section *Special method names*.

(This unusual definition of comparison was used to simplify the
definition of operations like sorting and the "in" and "not in"
operators. In the future, the comparison rules for objects of
different types are likely to change.)

Comparison of objects of the same type depends on the type:

* Numbers are compared arithmetically.

* Strings are compared lexicographically using the numeric
  equivalents (the result of the built-in function "ord()") of their
  characters. Unicode and 8-bit strings are fully interoperable in
  this behavior. [4]

* Tuples and lists are compared lexicographically using comparison
  of corresponding elements.  This means that to compare equal, each
  element must compare equal and the two sequences must be of the same
  type and have the same length.

  If not equal, the sequences are ordered the same as their first
  differing elements.  For example, "cmp([1,2,x], [1,2,y])" returns
  the same as "cmp(x,y)".  If the corresponding element does not
  exist, the shorter sequence is ordered first (for example, "[1,2] <
  [1,2,3]").

* Mappings (dictionaries) compare equal if and only if their sorted
  (key, value) lists compare equal. [5] Outcomes other than equality
  are resolved consistently, but are not otherwise defined. [6]

* Most other objects of built-in types compare unequal unless they
  are the same object; the choice whether one object is considered
  smaller or larger than another one is made arbitrarily but
  consistently within one execution of a program.

The operators "in" and "not in" test for collection membership.  "x in
s" evaluates to true if *x* is a member of the collection *s*, and
false otherwise.  "x not in s" returns the negation of "x in s". The
collection membership test has traditionally been bound to sequences;
an object is a member of a collection if the collection is a sequence
and contains an element equal to that object.  However, it make sense
for many other object types to support membership tests without being
a sequence.  In particular, dictionaries (for keys) and sets support
membership testing.

For the list and tuple types, "x in y" is true if and only if there
exists an index *i* such that "x == y[i]" is true.

For the Unicode and string types, "x in y" is true if and only if *x*
is a substring of *y*.  An equivalent test is "y.find(x) != -1".
Note, *x* and *y* need not be the same type; consequently, "u'ab' in
'abc'" will return "True". Empty strings are always considered to be a
substring of any other string, so """ in "abc"" will return "True".

Changed in version 2.3: Previously, *x* was required to be a string of
length "1".

For user-defined classes which define the "__contains__()" method, "x
in y" is true if and only if "y.__contains__(x)" is true.

For user-defined classes which do not define "__contains__()" but do
define "__iter__()", "x in y" is true if some value "z" with "x == z"
is produced while iterating over "y".  If an exception is raised
during the iteration, it is as if "in" raised that exception.

Lastly, the old-style iteration protocol is tried: if a class defines
"__getitem__()", "x in y" is true if and only if there is a non-
negative integer index *i* such that "x == y[i]", and all lower
integer indices do not raise "IndexError" exception. (If any other
exception is raised, it is as if "in" raised that exception).

The operator "not in" is defined to have the inverse true value of
"in".

The operators "is" and "is not" test for object identity: "x is y" is
true if and only if *x* and *y* are the same object.  "x is not y"
yields the inverse truth value. [7]
t   comparisonsuP  
Compound statements
*******************

Compound statements contain (groups of) other statements; they affect
or control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

The "if", "while" and "for" statements implement traditional control
flow constructs.  "try" specifies exception handlers and/or cleanup
code for a group of statements.  Function and class definitions are
also syntactically compound statements.

Compound statements consist of one or more 'clauses.'  A clause
consists of a header and a 'suite.'  The clause headers of a
particular compound statement are all at the same indentation level.
Each clause header begins with a uniquely identifying keyword and ends
with a colon.  A suite is a group of statements controlled by a
clause.  A suite can be one or more semicolon-separated simple
statements on the same line as the header, following the header's
colon, or it can be one or more indented statements on subsequent
lines.  Only the latter form of suite can contain nested compound
statements; the following is illegal, mostly because it wouldn't be
clear to which "if" clause a following "else" clause would belong:

   if test1: if test2: print x

Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
"print" statements are executed:

   if x < y < z: print x; print y; print z

Summarizing:

   compound_stmt ::= if_stmt
                     | while_stmt
                     | for_stmt
                     | try_stmt
                     | with_stmt
                     | funcdef
                     | classdef
                     | decorated
   suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
   statement     ::= stmt_list NEWLINE | compound_stmt
   stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]

Note that statements always end in a "NEWLINE" possibly followed by a
"DEDENT". Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the 'dangling "else"' problem is solved in Python by
requiring nested "if" statements to be indented).

The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.


The "if" statement
==================

The "if" statement is used for conditional execution:

   if_stmt ::= "if" expression ":" suite
               ( "elif" expression ":" suite )*
               ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *Boolean operations*
for the definition of true and false); then that suite is executed
(and no other part of the "if" statement is executed or evaluated).
If all expressions are false, the suite of the "else" clause, if
present, is executed.


The "while" statement
=====================

The "while" statement is used for repeated execution as long as an
expression is true:

   while_stmt ::= "while" expression ":" suite
                  ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time
it is tested) the suite of the "else" clause, if present, is executed
and the loop terminates.

A "break" statement executed in the first suite terminates the loop
without executing the "else" clause's suite.  A "continue" statement
executed in the first suite skips the rest of the suite and goes back
to testing the expression.


The "for" statement
===================

The "for" statement is used to iterate over the elements of a sequence
(such as a string, tuple or list) or other iterable object:

   for_stmt ::= "for" target_list "in" expression_list ":" suite
                ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the
"expression_list".  The suite is then executed once for each item
provided by the iterator, in the order of ascending indices.  Each
item in turn is assigned to the target list using the standard rules
for assignments, and then the suite is executed.  When the items are
exhausted (which is immediately when the sequence is empty), the suite
in the "else" clause, if present, is executed, and the loop
terminates.

A "break" statement executed in the first suite terminates the loop
without executing the "else" clause's suite.  A "continue" statement
executed in the first suite skips the rest of the suite and continues
with the next item, or with the "else" clause if there was no next
item.

The suite may assign to the variable(s) in the target list; this does
not affect the next item assigned to it.

The target list is not deleted when the loop is finished, but if the
sequence is empty, it will not have been assigned to at all by the
loop.  Hint: the built-in function "range()" returns a sequence of
integers suitable to emulate the effect of Pascal's "for i := a to b
do"; e.g., "range(3)" returns the list "[0, 1, 2]".

Note: There is a subtlety when the sequence is being modified by the
  loop (this can only occur for mutable sequences, i.e. lists). An
  internal counter is used to keep track of which item is used next,
  and this is incremented on each iteration.  When this counter has
  reached the length of the sequence the loop terminates.  This means
  that if the suite deletes the current (or a previous) item from the
  sequence, the next item will be skipped (since it gets the index of
  the current item which has already been treated).  Likewise, if the
  suite inserts an item in the sequence before the current item, the
  current item will be treated again the next time through the loop.
  This can lead to nasty bugs that can be avoided by making a
  temporary copy using a slice of the whole sequence, e.g.,

     for x in a[:]:
         if x < 0: a.remove(x)


The "try" statement
===================

The "try" statement specifies exception handlers and/or cleanup code
for a group of statements:

   try_stmt  ::= try1_stmt | try2_stmt
   try1_stmt ::= "try" ":" suite
                 ("except" [expression [("as" | ",") identifier]] ":" suite)+
                 ["else" ":" suite]
                 ["finally" ":" suite]
   try2_stmt ::= "try" ":" suite
                 "finally" ":" suite

Changed in version 2.5: In previous versions of Python,
"try"..."except"..."finally" did not work. "try"..."except" had to be
nested in "try"..."finally".

The "except" clause(s) specify one or more exception handlers. When no
exception occurs in the "try" clause, no exception handler is
executed. When an exception occurs in the "try" suite, a search for an
exception handler is started.  This search inspects the except clauses
in turn until one is found that matches the exception.  An expression-
less except clause, if present, must be last; it matches any
exception.  For an except clause with an expression, that expression
is evaluated, and the clause matches the exception if the resulting
object is "compatible" with the exception.  An object is compatible
with an exception if it is the class or a base class of the exception
object, or a tuple containing an item compatible with the exception.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
[1]

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and
a search starts for the new exception in the surrounding code and on
the call stack (it is treated as if the entire "try" statement raised
the exception).

When a matching except clause is found, the exception is assigned to
the target specified in that except clause, if present, and the except
clause's suite is executed.  All except clauses must have an
executable block.  When the end of this block is reached, execution
continues normally after the entire try statement.  (This means that
if two nested handlers exist for the same exception, and the exception
occurs in the try clause of the inner handler, the outer handler will
not handle the exception.)

Before an except clause's suite is executed, details about the
exception are assigned to three variables in the "sys" module:
"sys.exc_type" receives the object identifying the exception;
"sys.exc_value" receives the exception's parameter;
"sys.exc_traceback" receives a traceback object (see section *The
standard type hierarchy*) identifying the point in the program where
the exception occurred. These details are also available through the
"sys.exc_info()" function, which returns a tuple "(exc_type,
exc_value, exc_traceback)".  Use of the corresponding variables is
deprecated in favor of this function, since their use is unsafe in a
threaded program.  As of Python 1.5, the variables are restored to
their previous values (before the call) when returning from a function
that handled an exception.

The optional "else" clause is executed if and when control flows off
the end of the "try" clause. [2] Exceptions in the "else" clause are
not handled by the preceding "except" clauses.

If "finally" is present, it specifies a 'cleanup' handler.  The "try"
clause is executed, including any "except" and "else" clauses.  If an
exception occurs in any of the clauses and is not handled, the
exception is temporarily saved. The "finally" clause is executed.  If
there is a saved exception, it is re-raised at the end of the
"finally" clause. If the "finally" clause raises another exception or
executes a "return" or "break" statement, the saved exception is
discarded:

   >>> def f():
   ...     try:
   ...         1/0
   ...     finally:
   ...         return 42
   ...
   >>> f()
   42

The exception information is not available to the program during
execution of the "finally" clause.

When a "return", "break" or "continue" statement is executed in the
"try" suite of a "try"..."finally" statement, the "finally" clause is
also executed 'on the way out.' A "continue" statement is illegal in
the "finally" clause. (The reason is a problem with the current
implementation --- this restriction may be lifted in the future).

The return value of a function is determined by the last "return"
statement executed.  Since the "finally" clause always executes, a
"return" statement executed in the "finally" clause will always be the
last one executed:

   >>> def foo():
   ...     try:
   ...         return 'try'
   ...     finally:
   ...         return 'finally'
   ...
   >>> foo()
   'finally'

Additional information on exceptions can be found in section
*Exceptions*, and information on using the "raise" statement to
generate exceptions may be found in section *The raise statement*.


The "with" statement
====================

New in version 2.5.

The "with" statement is used to wrap the execution of a block with
methods defined by a context manager (see section *With Statement
Context Managers*). This allows common "try"..."except"..."finally"
usage patterns to be encapsulated for convenient reuse.

   with_stmt ::= "with" with_item ("," with_item)* ":" suite
   with_item ::= expression ["as" target]

The execution of the "with" statement with one "item" proceeds as
follows:

1. The context expression (the expression given in the "with_item")
   is evaluated to obtain a context manager.

2. The context manager's "__exit__()" is loaded for later use.

3. The context manager's "__enter__()" method is invoked.

4. If a target was included in the "with" statement, the return
   value from "__enter__()" is assigned to it.

   Note: The "with" statement guarantees that if the "__enter__()"
     method returns without an error, then "__exit__()" will always be
     called. Thus, if an error occurs during the assignment to the
     target list, it will be treated the same as an error occurring
     within the suite would be. See step 6 below.

5. The suite is executed.

6. The context manager's "__exit__()" method is invoked. If an
   exception caused the suite to be exited, its type, value, and
   traceback are passed as arguments to "__exit__()". Otherwise, three
   "None" arguments are supplied.

   If the suite was exited due to an exception, and the return value
   from the "__exit__()" method was false, the exception is reraised.
   If the return value was true, the exception is suppressed, and
   execution continues with the statement following the "with"
   statement.

   If the suite was exited for any reason other than an exception, the
   return value from "__exit__()" is ignored, and execution proceeds
   at the normal location for the kind of exit that was taken.

With more than one item, the context managers are processed as if
multiple "with" statements were nested:

   with A() as a, B() as b:
       suite

is equivalent to

   with A() as a:
       with B() as b:
           suite

Note: In Python 2.5, the "with" statement is only allowed when the
  "with_statement" feature has been enabled.  It is always enabled in
  Python 2.6.

Changed in version 2.7: Support for multiple context expressions.

See also: **PEP 0343** - The "with" statement

     The specification, background, and examples for the Python "with"
     statement.


Function definitions
====================

A function definition defines a user-defined function object (see
section *The standard type hierarchy*):

   decorated      ::= decorators (classdef | funcdef)
   decorators     ::= decorator+
   decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
   funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite
   dotted_name    ::= identifier ("." identifier)*
   parameter_list ::= (defparameter ",")*
                      (  "*" identifier ["," "**" identifier]
                      | "**" identifier
                      | defparameter [","] )
   defparameter   ::= parameter ["=" expression]
   sublist        ::= parameter ("," parameter)* [","]
   parameter      ::= identifier | "(" sublist ")"
   funcname       ::= identifier

A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object
(a wrapper around the executable code for the function).  This
function object contains a reference to the current global namespace
as the global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called. [3]

A function definition may be wrapped by one or more *decorator*
expressions. Decorator expressions are evaluated when the function is
defined, in the scope that contains the function definition.  The
result must be a callable, which is invoked with the function object
as the only argument. The returned value is bound to the function name
instead of the function object.  Multiple decorators are applied in
nested fashion. For example, the following code:

   @f1(arg)
   @f2
   def func(): pass

is equivalent to:

   def func(): pass
   func = f1(arg)(f2(func))

When one or more top-level *parameters* have the form *parameter* "="
*expression*, the function is said to have "default parameter values."
For a parameter with a default value, the corresponding *argument* may
be omitted from a call, in which case the parameter's default value is
substituted.  If a parameter has a default value, all following
parameters must also have a default value --- this is a syntactic
restriction that is not expressed by the grammar.

**Default parameter values are evaluated when the function definition
is executed.**  This means that the expression is evaluated once, when
the function is defined, and that the same "pre-computed" value is
used for each call.  This is especially important to understand when a
default parameter is a mutable object, such as a list or a dictionary:
if the function modifies the object (e.g. by appending an item to a
list), the default value is in effect modified. This is generally not
what was intended.  A way around this  is to use "None" as the
default, and explicitly test for it in the body of the function, e.g.:

   def whats_on_the_telly(penguin=None):
       if penguin is None:
           penguin = []
       penguin.append("property of the zoo")
       return penguin

Function call semantics are described in more detail in section
*Calls*. A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form
""*identifier"" is present, it is initialized to a tuple receiving any
excess positional parameters, defaulting to the empty tuple.  If the
form ""**identifier"" is present, it is initialized to a new
dictionary receiving any excess keyword arguments, defaulting to a new
empty dictionary.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *Lambdas*.  Note that the lambda
expression is merely a shorthand for a simplified function definition;
a function defined in a ""def"" statement can be passed around or
assigned to another name just like a function defined by a lambda
expression.  The ""def"" form is actually more powerful since it
allows the execution of multiple statements.

**Programmer's note:** Functions are first-class objects.  A ""def""
form executed inside a function definition defines a local function
that can be returned or passed around.  Free variables used in the
nested function can access the local variables of the function
containing the def.  See section *Naming and binding* for details.


Class definitions
=================

A class definition defines a class object (see section *The standard
type hierarchy*):

   classdef    ::= "class" classname [inheritance] ":" suite
   inheritance ::= "(" [expression_list] ")"
   classname   ::= identifier

A class definition is an executable statement.  It first evaluates the
inheritance list, if present.  Each item in the inheritance list
should evaluate to a class object or class type which allows
subclassing.  The class's suite is then executed in a new execution
frame (see section *Naming and binding*), using a newly created local
namespace and the original global namespace. (Usually, the suite
contains only function definitions.)  When the class's suite finishes
execution, its execution frame is discarded but its local namespace is
saved. [4] A class object is then created using the inheritance list
for the base classes and the saved local namespace for the attribute
dictionary.  The class name is bound to this class object in the
original local namespace.

**Programmer's note:** Variables defined in the class definition are
class variables; they are shared by all instances.  To create instance
variables, they can be set in a method with "self.name = value".  Both
class and instance variables are accessible through the notation
""self.name"", and an instance variable hides a class variable with
the same name when accessed in this way. Class variables can be used
as defaults for instance variables, but using mutable values there can
lead to unexpected results.  For *new-style class*es, descriptors can
be used to create instance variables with different implementation
details.

Class definitions, like function definitions, may be wrapped by one or
more *decorator* expressions.  The evaluation rules for the decorator
expressions are the same as for functions.  The result must be a class
object, which is then bound to the class name.

-[ Footnotes ]-

[1] The exception is propagated to the invocation stack unless
    there is a "finally" clause which happens to raise another
    exception. That new exception causes the old one to be lost.

[2] Currently, control "flows off the end" except in the case of
    an exception or the execution of a "return", "continue", or
    "break" statement.

[3] A string literal appearing as the first statement in the
    function body is transformed into the function's "__doc__"
    attribute and therefore the function's *docstring*.

[4] A string literal appearing as the first statement in the class
    body is transformed into the namespace's "__doc__" item and
    therefore the class's *docstring*.
t   compoundu  
With Statement Context Managers
*******************************

New in version 2.5.

A *context manager* is an object that defines the runtime context to
be established when executing a "with" statement. The context manager
handles the entry into, and the exit from, the desired runtime context
for the execution of the block of code.  Context managers are normally
invoked using the "with" statement (described in section *The with
statement*), but can also be used by directly invoking their methods.

Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.

For more information on context managers, see *Context Manager Types*.

object.__enter__(self)

   Enter the runtime context related to this object. The "with"
   statement will bind this method's return value to the target(s)
   specified in the "as" clause of the statement, if any.

object.__exit__(self, exc_type, exc_value, traceback)

   Exit the runtime context related to this object. The parameters
   describe the exception that caused the context to be exited. If the
   context was exited without an exception, all three arguments will
   be "None".

   If an exception is supplied, and the method wishes to suppress the
   exception (i.e., prevent it from being propagated), it should
   return a true value. Otherwise, the exception will be processed
   normally upon exit from this method.

   Note that "__exit__()" methods should not reraise the passed-in
   exception; this is the caller's responsibility.

See also: **PEP 0343** - The "with" statement

     The specification, background, and examples for the Python "with"
     statement.
s   context-managersu  
The "continue" statement
************************

   continue_stmt ::= "continue"

"continue" may only occur syntactically nested in a "for" or "while"
loop, but not nested in a function or class definition or "finally"
clause within that loop.  It continues with the next cycle of the
nearest enclosing loop.

When "continue" passes control out of a "try" statement with a
"finally" clause, that "finally" clause is executed before really
starting the next loop cycle.
t   continueuD  
Arithmetic conversions
**********************

When a description of an arithmetic operator below uses the phrase
"the numeric arguments are converted to a common type," the arguments
are coerced using the coercion rules listed at  *Coercion rules*.  If
both arguments are standard numeric types, the following coercions are
applied:

* If either argument is a complex number, the other is converted to
  complex;

* otherwise, if either argument is a floating point number, the
  other is converted to floating point;

* otherwise, if either argument is a long integer, the other is
  converted to long integer;

* otherwise, both must be plain integers and no conversion is
  necessary.

Some additional rules apply for certain operators (e.g., a string left
argument to the '%' operator). Extensions can define their own
coercions.
t   conversionsu.  
Basic customization
*******************

object.__new__(cls[, ...])

   Called to create a new instance of class *cls*.  "__new__()" is a
   static method (special-cased so you need not declare it as such)
   that takes the class of which an instance was requested as its
   first argument.  The remaining arguments are those passed to the
   object constructor expression (the call to the class).  The return
   value of "__new__()" should be the new object instance (usually an
   instance of *cls*).

   Typical implementations create a new instance of the class by
   invoking the superclass's "__new__()" method using
   "super(currentclass, cls).__new__(cls[, ...])" with appropriate
   arguments and then modifying the newly-created instance as
   necessary before returning it.

   If "__new__()" returns an instance of *cls*, then the new
   instance's "__init__()" method will be invoked like
   "__init__(self[, ...])", where *self* is the new instance and the
   remaining arguments are the same as were passed to "__new__()".

   If "__new__()" does not return an instance of *cls*, then the new
   instance's "__init__()" method will not be invoked.

   "__new__()" is intended mainly to allow subclasses of immutable
   types (like int, str, or tuple) to customize instance creation.  It
   is also commonly overridden in custom metaclasses in order to
   customize class creation.

object.__init__(self[, ...])

   Called when the instance is created.  The arguments are those
   passed to the class constructor expression.  If a base class has an
   "__init__()" method, the derived class's "__init__()" method, if
   any, must explicitly call it to ensure proper initialization of the
   base class part of the instance; for example:
   "BaseClass.__init__(self, [args...])".  As a special constraint on
   constructors, no value may be returned; doing so will cause a
   "TypeError" to be raised at runtime.

object.__del__(self)

   Called when the instance is about to be destroyed.  This is also
   called a destructor.  If a base class has a "__del__()" method, the
   derived class's "__del__()" method, if any, must explicitly call it
   to ensure proper deletion of the base class part of the instance.
   Note that it is possible (though not recommended!) for the
   "__del__()" method to postpone destruction of the instance by
   creating a new reference to it.  It may then be called at a later
   time when this new reference is deleted.  It is not guaranteed that
   "__del__()" methods are called for objects that still exist when
   the interpreter exits.

   Note: "del x" doesn't directly call "x.__del__()" --- the former
     decrements the reference count for "x" by one, and the latter is
     only called when "x"'s reference count reaches zero.  Some common
     situations that may prevent the reference count of an object from
     going to zero include: circular references between objects (e.g.,
     a doubly-linked list or a tree data structure with parent and
     child pointers); a reference to the object on the stack frame of
     a function that caught an exception (the traceback stored in
     "sys.exc_traceback" keeps the stack frame alive); or a reference
     to the object on the stack frame that raised an unhandled
     exception in interactive mode (the traceback stored in
     "sys.last_traceback" keeps the stack frame alive).  The first
     situation can only be remedied by explicitly breaking the cycles;
     the latter two situations can be resolved by storing "None" in
     "sys.exc_traceback" or "sys.last_traceback".  Circular references
     which are garbage are detected when the option cycle detector is
     enabled (it's on by default), but can only be cleaned up if there
     are no Python-level "__del__()" methods involved. Refer to the
     documentation for the "gc" module for more information about how
     "__del__()" methods are handled by the cycle detector,
     particularly the description of the "garbage" value.

   Warning: Due to the precarious circumstances under which
     "__del__()" methods are invoked, exceptions that occur during
     their execution are ignored, and a warning is printed to
     "sys.stderr" instead. Also, when "__del__()" is invoked in
     response to a module being deleted (e.g., when execution of the
     program is done), other globals referenced by the "__del__()"
     method may already have been deleted or in the process of being
     torn down (e.g. the import machinery shutting down).  For this
     reason, "__del__()" methods should do the absolute minimum needed
     to maintain external invariants.  Starting with version 1.5,
     Python guarantees that globals whose name begins with a single
     underscore are deleted from their module before other globals are
     deleted; if no other references to such globals exist, this may
     help in assuring that imported modules are still available at the
     time when the "__del__()" method is called.

   See also the *-R* command-line option.

object.__repr__(self)

   Called by the "repr()" built-in function and by string conversions
   (reverse quotes) to compute the "official" string representation of
   an object.  If at all possible, this should look like a valid
   Python expression that could be used to recreate an object with the
   same value (given an appropriate environment).  If this is not
   possible, a string of the form "<...some useful description...>"
   should be returned.  The return value must be a string object. If a
   class defines "__repr__()" but not "__str__()", then "__repr__()"
   is also used when an "informal" string representation of instances
   of that class is required.

   This is typically used for debugging, so it is important that the
   representation is information-rich and unambiguous.

object.__str__(self)

   Called by the "str()" built-in function and by the "print"
   statement to compute the "informal" string representation of an
   object.  This differs from "__repr__()" in that it does not have to
   be a valid Python expression: a more convenient or concise
   representation may be used instead. The return value must be a
   string object.

object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)

   New in version 2.1.

   These are the so-called "rich comparison" methods, and are called
   for comparison operators in preference to "__cmp__()" below. The
   correspondence between operator symbols and method names is as
   follows: "x<y" calls "x.__lt__(y)", "x<=y" calls "x.__le__(y)",
   "x==y" calls "x.__eq__(y)", "x!=y" and "x<>y" call "x.__ne__(y)",
   "x>y" calls "x.__gt__(y)", and "x>=y" calls "x.__ge__(y)".

   A rich comparison method may return the singleton "NotImplemented"
   if it does not implement the operation for a given pair of
   arguments. By convention, "False" and "True" are returned for a
   successful comparison. However, these methods can return any value,
   so if the comparison operator is used in a Boolean context (e.g.,
   in the condition of an "if" statement), Python will call "bool()"
   on the value to determine if the result is true or false.

   There are no implied relationships among the comparison operators.
   The truth of "x==y" does not imply that "x!=y" is false.
   Accordingly, when defining "__eq__()", one should also define
   "__ne__()" so that the operators will behave as expected.  See the
   paragraph on "__hash__()" for some important notes on creating
   *hashable* objects which support custom comparison operations and
   are usable as dictionary keys.

   There are no swapped-argument versions of these methods (to be used
   when the left argument does not support the operation but the right
   argument does); rather, "__lt__()" and "__gt__()" are each other's
   reflection, "__le__()" and "__ge__()" are each other's reflection,
   and "__eq__()" and "__ne__()" are their own reflection.

   Arguments to rich comparison methods are never coerced.

   To automatically generate ordering operations from a single root
   operation, see "functools.total_ordering()".

object.__cmp__(self, other)

   Called by comparison operations if rich comparison (see above) is
   not defined.  Should return a negative integer if "self < other",
   zero if "self == other", a positive integer if "self > other".  If
   no "__cmp__()", "__eq__()" or "__ne__()" operation is defined,
   class instances are compared by object identity ("address").  See
   also the description of "__hash__()" for some important notes on
   creating *hashable* objects which support custom comparison
   operations and are usable as dictionary keys. (Note: the
   restriction that exceptions are not propagated by "__cmp__()" has
   been removed since Python 1.5.)

object.__rcmp__(self, other)

   Changed in version 2.1: No longer supported.

object.__hash__(self)

   Called by built-in function "hash()" and for operations on members
   of hashed collections including "set", "frozenset", and "dict".
   "__hash__()" should return an integer.  The only required property
   is that objects which compare equal have the same hash value; it is
   advised to somehow mix together (e.g. using exclusive or) the hash
   values for the components of the object that also play a part in
   comparison of objects.

   If a class does not define a "__cmp__()" or "__eq__()" method it
   should not define a "__hash__()" operation either; if it defines
   "__cmp__()" or "__eq__()" but not "__hash__()", its instances will
   not be usable in hashed collections.  If a class defines mutable
   objects and implements a "__cmp__()" or "__eq__()" method, it
   should not implement "__hash__()", since hashable collection
   implementations require that a object's hash value is immutable (if
   the object's hash value changes, it will be in the wrong hash
   bucket).

   User-defined classes have "__cmp__()" and "__hash__()" methods by
   default; with them, all objects compare unequal (except with
   themselves) and "x.__hash__()" returns a result derived from
   "id(x)".

   Classes which inherit a "__hash__()" method from a parent class but
   change the meaning of "__cmp__()" or "__eq__()" such that the hash
   value returned is no longer appropriate (e.g. by switching to a
   value-based concept of equality instead of the default identity
   based equality) can explicitly flag themselves as being unhashable
   by setting "__hash__ = None" in the class definition. Doing so
   means that not only will instances of the class raise an
   appropriate "TypeError" when a program attempts to retrieve their
   hash value, but they will also be correctly identified as
   unhashable when checking "isinstance(obj, collections.Hashable)"
   (unlike classes which define their own "__hash__()" to explicitly
   raise "TypeError").

   Changed in version 2.5: "__hash__()" may now also return a long
   integer object; the 32-bit integer is then derived from the hash of
   that object.

   Changed in version 2.6: "__hash__" may now be set to "None" to
   explicitly flag instances of a class as unhashable.

object.__nonzero__(self)

   Called to implement truth value testing and the built-in operation
   "bool()"; should return "False" or "True", or their integer
   equivalents "0" or "1".  When this method is not defined,
   "__len__()" is called, if it is defined, and the object is
   considered true if its result is nonzero. If a class defines
   neither "__len__()" nor "__nonzero__()", all its instances are
   considered true.

object.__unicode__(self)

   Called to implement "unicode()" built-in; should return a Unicode
   object. When this method is not defined, string conversion is
   attempted, and the result of string conversion is converted to
   Unicode using the system default encoding.
t   customizationu  
"pdb" --- The Python Debugger
*****************************

**Source code:** Lib/pdb.py

======================================================================

The module "pdb" defines an interactive source code debugger for
Python programs.  It supports setting (conditional) breakpoints and
single stepping at the source line level, inspection of stack frames,
source code listing, and evaluation of arbitrary Python code in the
context of any stack frame.  It also supports post-mortem debugging
and can be called under program control.

The debugger is extensible --- it is actually defined as the class
"Pdb". This is currently undocumented but easily understood by reading
the source.  The extension interface uses the modules "bdb" and "cmd".

The debugger's prompt is "(Pdb)". Typical usage to run a program under
control of the debugger is:

   >>> import pdb
   >>> import mymodule
   >>> pdb.run('mymodule.test()')
   > <string>(0)?()
   (Pdb) continue
   > <string>(1)?()
   (Pdb) continue
   NameError: 'spam'
   > <string>(1)?()
   (Pdb)

"pdb.py" can also be invoked as a script to debug other scripts.  For
example:

   python -m pdb myscript.py

When invoked as a script, pdb will automatically enter post-mortem
debugging if the program being debugged exits abnormally. After post-
mortem debugging (or after normal exit of the program), pdb will
restart the program. Automatic restarting preserves pdb's state (such
as breakpoints) and in most cases is more useful than quitting the
debugger upon program's exit.

New in version 2.4: Restarting post-mortem behavior added.

The typical usage to break into the debugger from a running program is
to insert

   import pdb; pdb.set_trace()

at the location you want to break into the debugger.  You can then
step through the code following this statement, and continue running
without the debugger using the "c" command.

The typical usage to inspect a crashed program is:

   >>> import pdb
   >>> import mymodule
   >>> mymodule.test()
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
     File "./mymodule.py", line 4, in test
       test2()
     File "./mymodule.py", line 3, in test2
       print spam
   NameError: spam
   >>> pdb.pm()
   > ./mymodule.py(3)test2()
   -> print spam
   (Pdb)

The module defines the following functions; each enters the debugger
in a slightly different way:

pdb.run(statement[, globals[, locals]])

   Execute the *statement* (given as a string) under debugger control.
   The debugger prompt appears before any code is executed; you can
   set breakpoints and type "continue", or you can step through the
   statement using "step" or "next" (all these commands are explained
   below).  The optional *globals* and *locals* arguments specify the
   environment in which the code is executed; by default the
   dictionary of the module "__main__" is used.  (See the explanation
   of the "exec" statement or the "eval()" built-in function.)

pdb.runeval(expression[, globals[, locals]])

   Evaluate the *expression* (given as a string) under debugger
   control.  When "runeval()" returns, it returns the value of the
   expression.  Otherwise this function is similar to "run()".

pdb.runcall(function[, argument, ...])

   Call the *function* (a function or method object, not a string)
   with the given arguments.  When "runcall()" returns, it returns
   whatever the function call returned.  The debugger prompt appears
   as soon as the function is entered.

pdb.set_trace()

   Enter the debugger at the calling stack frame.  This is useful to
   hard-code a breakpoint at a given point in a program, even if the
   code is not otherwise being debugged (e.g. when an assertion
   fails).

pdb.post_mortem([traceback])

   Enter post-mortem debugging of the given *traceback* object.  If no
   *traceback* is given, it uses the one of the exception that is
   currently being handled (an exception must be being handled if the
   default is to be used).

pdb.pm()

   Enter post-mortem debugging of the traceback found in
   "sys.last_traceback".

The "run*" functions and "set_trace()" are aliases for instantiating
the "Pdb" class and calling the method of the same name.  If you want
to access further features, you have to do this yourself:

class class pdb.Pdb(completekey='tab', stdin=None, stdout=None, skip=None)

   "Pdb" is the debugger class.

   The *completekey*, *stdin* and *stdout* arguments are passed to the
   underlying "cmd.Cmd" class; see the description there.

   The *skip* argument, if given, must be an iterable of glob-style
   module name patterns.  The debugger will not step into frames that
   originate in a module that matches one of these patterns. [1]

   Example call to enable tracing with *skip*:

      import pdb; pdb.Pdb(skip=['django.*']).set_trace()

   New in version 2.7: The *skip* argument.

   run(statement[, globals[, locals]])
   runeval(expression[, globals[, locals]])
   runcall(function[, argument, ...])
   set_trace()

      See the documentation for the functions explained above.
t   debuggeru  
The "del" statement
*******************

   del_stmt ::= "del" target_list

Deletion is recursively defined very similar to the way assignment is
defined. Rather than spelling it out in full details, here are some
hints.

Deletion of a target list recursively deletes each target, from left
to right.

Deletion of a name removes the binding of that name  from the local or
global namespace, depending on whether the name occurs in a "global"
statement in the same code block.  If the name is unbound, a
"NameError" exception will be raised.

It is illegal to delete a name from the local namespace if it occurs
as a free variable in a nested block.

Deletion of attribute references, subscriptions and slicings is passed
to the primary object involved; deletion of a slicing is in general
equivalent to assignment of an empty slice of the right type (but even
this is determined by the sliced object).
t   delu  
Dictionary displays
*******************

A dictionary display is a possibly empty series of key/datum pairs
enclosed in curly braces:

   dict_display       ::= "{" [key_datum_list | dict_comprehension] "}"
   key_datum_list     ::= key_datum ("," key_datum)* [","]
   key_datum          ::= expression ":" expression
   dict_comprehension ::= expression ":" expression comp_for

A dictionary display yields a new dictionary object.

If a comma-separated sequence of key/datum pairs is given, they are
evaluated from left to right to define the entries of the dictionary:
each key object is used as a key into the dictionary to store the
corresponding datum.  This means that you can specify the same key
multiple times in the key/datum list, and the final dictionary's value
for that key will be the last one given.

A dict comprehension, in contrast to list and set comprehensions,
needs two expressions separated with a colon followed by the usual
"for" and "if" clauses. When the comprehension is run, the resulting
key and value elements are inserted in the new dictionary in the order
they are produced.

Restrictions on the types of the key values are listed earlier in
section *The standard type hierarchy*.  (To summarize, the key type
should be *hashable*, which excludes all mutable objects.)  Clashes
between duplicate keys are not detected; the last datum (textually
rightmost in the display) stored for a given key value prevails.
t   dictu+  
Interaction with dynamic features
*********************************

There are several cases where Python statements are illegal when used
in conjunction with nested scopes that contain free variables.

If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

If the wild card form of import --- "import *" --- is used in a
function and the function contains or is a nested block with free
variables, the compiler will raise a "SyntaxError".

If "exec" is used in a function and the function contains or is a
nested block with free variables, the compiler will raise a
"SyntaxError" unless the exec explicitly specifies the local namespace
for the "exec".  (In other words, "exec obj" would be illegal, but
"exec obj in ns" would be legal.)

The "eval()", "execfile()", and "input()" functions and the "exec"
statement do not have access to the full environment for resolving
names.  Names may be resolved in the local and global namespaces of
the caller.  Free variables are not resolved in the nearest enclosing
namespace, but in the global namespace. [1] The "exec" statement and
the "eval()" and "execfile()" functions have optional arguments to
override the global and local namespace.  If only one namespace is
specified, it is used for both.
s   dynamic-featuresuG  
The "if" statement
******************

The "if" statement is used for conditional execution:

   if_stmt ::= "if" expression ":" suite
               ( "elif" expression ":" suite )*
               ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *Boolean operations*
for the definition of true and false); then that suite is executed
(and no other part of the "if" statement is executed or evaluated).
If all expressions are false, the suite of the "else" clause, if
present, is executed.
t   elseul	  
Exceptions
**********

Exceptions are a means of breaking out of the normal flow of control
of a code block in order to handle errors or other exceptional
conditions.  An exception is *raised* at the point where the error is
detected; it may be *handled* by the surrounding code block or by any
code block that directly or indirectly invoked the code block where
the error occurred.

The Python interpreter raises an exception when it detects a run-time
error (such as division by zero).  A Python program can also
explicitly raise an exception with the "raise" statement. Exception
handlers are specified with the "try" ... "except" statement.  The
"finally" clause of such a statement can be used to specify cleanup
code which does not handle the exception, but is executed whether an
exception occurred or not in the preceding code.

Python uses the "termination" model of error handling: an exception
handler can find out what happened and continue execution at an outer
level, but it cannot repair the cause of the error and retry the
failing operation (except by re-entering the offending piece of code
from the top).

When an exception is not handled at all, the interpreter terminates
execution of the program, or returns to its interactive main loop.  In
either case, it prints a stack backtrace, except when the exception is
"SystemExit".

Exceptions are identified by class instances.  The "except" clause is
selected depending on the class of the instance: it must reference the
class of the instance or a base class thereof.  The instance can be
received by the handler and can carry additional information about the
exceptional condition.

Exceptions can also be identified by strings, in which case the
"except" clause is selected by object identity.  An arbitrary value
can be raised along with the identifying string which can be passed to
the handler.

Note: Messages to exceptions are not part of the Python API.  Their
  contents may change from one version of Python to the next without
  warning and should not be relied on by code which will run under
  multiple versions of the interpreter.

See also the description of the "try" statement in section *The try
statement* and "raise" statement in section *The raise statement*.

-[ Footnotes ]-

[1] This limitation occurs because the code that is executed by
    these operations is not available at the time the module is
    compiled.
t
   exceptionsu
  
The "exec" statement
********************

   exec_stmt ::= "exec" or_expr ["in" expression ["," expression]]

This statement supports dynamic execution of Python code.  The first
expression should evaluate to either a Unicode string, a *Latin-1*
encoded string, an open file object, a code object, or a tuple.  If it
is a string, the string is parsed as a suite of Python statements
which is then executed (unless a syntax error occurs). [1] If it is an
open file, the file is parsed until EOF and executed. If it is a code
object, it is simply executed.  For the interpretation of a tuple, see
below.  In all cases, the code that's executed is expected to be valid
as file input (see section *File input*).  Be aware that the "return"
and "yield" statements may not be used outside of function definitions
even within the context of code passed to the "exec" statement.

In all cases, if the optional parts are omitted, the code is executed
in the current scope.  If only the first expression after "in" is
specified, it should be a dictionary, which will be used for both the
global and the local variables.  If two expressions are given, they
are used for the global and local variables, respectively. If
provided, *locals* can be any mapping object. Remember that at module
level, globals and locals are the same dictionary. If two separate
objects are given as *globals* and *locals*, the code will be executed
as if it were embedded in a class definition.

The first expression may also be a tuple of length 2 or 3.  In this
case, the optional parts must be omitted.  The form "exec(expr,
globals)" is equivalent to "exec expr in globals", while the form
"exec(expr, globals, locals)" is equivalent to "exec expr in globals,
locals".  The tuple form of "exec" provides compatibility with Python
3, where "exec" is a function rather than a statement.

Changed in version 2.4: Formerly, *locals* was required to be a
dictionary.

As a side effect, an implementation may insert additional keys into
the dictionaries given besides those corresponding to variable names
set by the executed code.  For example, the current implementation may
add a reference to the dictionary of the built-in module "__builtin__"
under the key "__builtins__" (!).

**Programmer's hints:** dynamic evaluation of expressions is supported
by the built-in function "eval()".  The built-in functions "globals()"
and "locals()" return the current global and local dictionary,
respectively, which may be useful to pass around for use by "exec".

-[ Footnotes ]-

[1] Note that the parser only accepts the Unix-style end of line
    convention. If you are reading the code from a file, make sure to
    use *universal newlines* mode to convert Windows or Mac-style
    newlines.
t   execu#&  
Execution model
***************


Naming and binding
==================

*Names* refer to objects.  Names are introduced by name binding
operations. Each occurrence of a name in the program text refers to
the *binding* of that name established in the innermost function block
containing the use.

A *block* is a piece of Python program text that is executed as a
unit. The following are blocks: a module, a function body, and a class
definition. Each command typed interactively is a block.  A script
file (a file given as standard input to the interpreter or specified
on the interpreter command line the first argument) is a code block.
A script command (a command specified on the interpreter command line
with the '**-c**' option) is a code block.  The file read by the
built-in function "execfile()" is a code block.  The string argument
passed to the built-in function "eval()" and to the "exec" statement
is a code block. The expression read and evaluated by the built-in
function "input()" is a code block.

A code block is executed in an *execution frame*.  A frame contains
some administrative information (used for debugging) and determines
where and how execution continues after the code block's execution has
completed.

A *scope* defines the visibility of a name within a block.  If a local
variable is defined in a block, its scope includes that block.  If the
definition occurs in a function block, the scope extends to any blocks
contained within the defining one, unless a contained block introduces
a different binding for the name.  The scope of names defined in a
class block is limited to the class block; it does not extend to the
code blocks of methods -- this includes generator expressions since
they are implemented using a function scope.  This means that the
following will fail:

   class A:
       a = 42
       b = list(a + i for i in range(10))

When a name is used in a code block, it is resolved using the nearest
enclosing scope.  The set of all such scopes visible to a code block
is called the block's *environment*.

If a name is bound in a block, it is a local variable of that block.
If a name is bound at the module level, it is a global variable.  (The
variables of the module code block are local and global.)  If a
variable is used in a code block but not defined there, it is a *free
variable*.

When a name is not found at all, a "NameError" exception is raised.
If the name refers to a local variable that has not been bound, a
"UnboundLocalError" exception is raised.  "UnboundLocalError" is a
subclass of "NameError".

The following constructs bind names: formal parameters to functions,
"import" statements, class and function definitions (these bind the
class or function name in the defining block), and targets that are
identifiers if occurring in an assignment, "for" loop header, in the
second position of an "except" clause header or after "as" in a "with"
statement.  The "import" statement of the form "from ... import *"
binds all names defined in the imported module, except those beginning
with an underscore.  This form may only be used at the module level.

A target occurring in a "del" statement is also considered bound for
this purpose (though the actual semantics are to unbind the name).  It
is illegal to unbind a name that is referenced by an enclosing scope;
the compiler will report a "SyntaxError".

Each assignment or import statement occurs within a block defined by a
class or function definition or at the module level (the top-level
code block).

If a name binding operation occurs anywhere within a code block, all
uses of the name within the block are treated as references to the
current block.  This can lead to errors when a name is used within a
block before it is bound. This rule is subtle.  Python lacks
declarations and allows name binding operations to occur anywhere
within a code block.  The local variables of a code block can be
determined by scanning the entire text of the block for name binding
operations.

If the global statement occurs within a block, all uses of the name
specified in the statement refer to the binding of that name in the
top-level namespace. Names are resolved in the top-level namespace by
searching the global namespace, i.e. the namespace of the module
containing the code block, and the builtins namespace, the namespace
of the module "__builtin__".  The global namespace is searched first.
If the name is not found there, the builtins namespace is searched.
The global statement must precede all uses of the name.

The builtins namespace associated with the execution of a code block
is actually found by looking up the name "__builtins__" in its global
namespace; this should be a dictionary or a module (in the latter case
the module's dictionary is used).  By default, when in the "__main__"
module, "__builtins__" is the built-in module "__builtin__" (note: no
's'); when in any other module, "__builtins__" is an alias for the
dictionary of the "__builtin__" module itself.  "__builtins__" can be
set to a user-created dictionary to create a weak form of restricted
execution.

**CPython implementation detail:** Users should not touch
"__builtins__"; it is strictly an implementation detail.  Users
wanting to override values in the builtins namespace should "import"
the "__builtin__" (no 's') module and modify its attributes
appropriately.

The namespace for a module is automatically created the first time a
module is imported.  The main module for a script is always called
"__main__".

The "global" statement has the same scope as a name binding operation
in the same block.  If the nearest enclosing scope for a free variable
contains a global statement, the free variable is treated as a global.

A class definition is an executable statement that may use and define
names. These references follow the normal rules for name resolution.
The namespace of the class definition becomes the attribute dictionary
of the class.  Names defined at the class scope are not visible in
methods.


Interaction with dynamic features
---------------------------------

There are several cases where Python statements are illegal when used
in conjunction with nested scopes that contain free variables.

If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

If the wild card form of import --- "import *" --- is used in a
function and the function contains or is a nested block with free
variables, the compiler will raise a "SyntaxError".

If "exec" is used in a function and the function contains or is a
nested block with free variables, the compiler will raise a
"SyntaxError" unless the exec explicitly specifies the local namespace
for the "exec".  (In other words, "exec obj" would be illegal, but
"exec obj in ns" would be legal.)

The "eval()", "execfile()", and "input()" functions and the "exec"
statement do not have access to the full environment for resolving
names.  Names may be resolved in the local and global namespaces of
the caller.  Free variables are not resolved in the nearest enclosing
namespace, but in the global namespace. [1] The "exec" statement and
the "eval()" and "execfile()" functions have optional arguments to
override the global and local namespace.  If only one namespace is
specified, it is used for both.


Exceptions
==========

Exceptions are a means of breaking out of the normal flow of control
of a code block in order to handle errors or other exceptional
conditions.  An exception is *raised* at the point where the error is
detected; it may be *handled* by the surrounding code block or by any
code block that directly or indirectly invoked the code block where
the error occurred.

The Python interpreter raises an exception when it detects a run-time
error (such as division by zero).  A Python program can also
explicitly raise an exception with the "raise" statement. Exception
handlers are specified with the "try" ... "except" statement.  The
"finally" clause of such a statement can be used to specify cleanup
code which does not handle the exception, but is executed whether an
exception occurred or not in the preceding code.

Python uses the "termination" model of error handling: an exception
handler can find out what happened and continue execution at an outer
level, but it cannot repair the cause of the error and retry the
failing operation (except by re-entering the offending piece of code
from the top).

When an exception is not handled at all, the interpreter terminates
execution of the program, or returns to its interactive main loop.  In
either case, it prints a stack backtrace, except when the exception is
"SystemExit".

Exceptions are identified by class instances.  The "except" clause is
selected depending on the class of the instance: it must reference the
class of the instance or a base class thereof.  The instance can be
received by the handler and can carry additional information about the
exceptional condition.

Exceptions can also be identified by strings, in which case the
"except" clause is selected by object identity.  An arbitrary value
can be raised along with the identifying string which can be passed to
the handler.

Note: Messages to exceptions are not part of the Python API.  Their
  contents may change from one version of Python to the next without
  warning and should not be relied on by code which will run under
  multiple versions of the interpreter.

See also the description of the "try" statement in section *The try
statement* and "raise" statement in section *The raise statement*.

-[ Footnotes ]-

[1] This limitation occurs because the code that is executed by
    these operations is not available at the time the module is
    compiled.
t	   execmodeluK  
Expression lists
****************

   expression_list ::= expression ( "," expression )* [","]

An expression list containing at least one comma yields a tuple.  The
length of the tuple is the number of expressions in the list.  The
expressions are evaluated from left to right.

The trailing comma is required only to create a single tuple (a.k.a. a
*singleton*); it is optional in all other cases.  A single expression
without a trailing comma doesn't create a tuple, but rather yields the
value of that expression. (To create an empty tuple, use an empty pair
of parentheses: "()".)
t	   exprlistsu  
Floating point literals
***********************

Floating point literals are described by the following lexical
definitions:

   floatnumber   ::= pointfloat | exponentfloat
   pointfloat    ::= [intpart] fraction | intpart "."
   exponentfloat ::= (intpart | pointfloat) exponent
   intpart       ::= digit+
   fraction      ::= "." digit+
   exponent      ::= ("e" | "E") ["+" | "-"] digit+

Note that the integer and exponent parts of floating point numbers can
look like octal integers, but are interpreted using radix 10.  For
example, "077e010" is legal, and denotes the same number as "77e10".
The allowed range of floating point literals is implementation-
dependent. Some examples of floating point literals:

   3.14    10.    .001    1e100    3.14e-10    0e0

Note that numeric literals do not include a sign; a phrase like "-1"
is actually an expression composed of the unary operator "-" and the
literal "1".
t   floatinguZ	  
The "for" statement
*******************

The "for" statement is used to iterate over the elements of a sequence
(such as a string, tuple or list) or other iterable object:

   for_stmt ::= "for" target_list "in" expression_list ":" suite
                ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the
"expression_list".  The suite is then executed once for each item
provided by the iterator, in the order of ascending indices.  Each
item in turn is assigned to the target list using the standard rules
for assignments, and then the suite is executed.  When the items are
exhausted (which is immediately when the sequence is empty), the suite
in the "else" clause, if present, is executed, and the loop
terminates.

A "break" statement executed in the first suite terminates the loop
without executing the "else" clause's suite.  A "continue" statement
executed in the first suite skips the rest of the suite and continues
with the next item, or with the "else" clause if there was no next
item.

The suite may assign to the variable(s) in the target list; this does
not affect the next item assigned to it.

The target list is not deleted when the loop is finished, but if the
sequence is empty, it will not have been assigned to at all by the
loop.  Hint: the built-in function "range()" returns a sequence of
integers suitable to emulate the effect of Pascal's "for i := a to b
do"; e.g., "range(3)" returns the list "[0, 1, 2]".

Note: There is a subtlety when the sequence is being modified by the
  loop (this can only occur for mutable sequences, i.e. lists). An
  internal counter is used to keep track of which item is used next,
  and this is incremented on each iteration.  When this counter has
  reached the length of the sequence the loop terminates.  This means
  that if the suite deletes the current (or a previous) item from the
  sequence, the next item will be skipped (since it gets the index of
  the current item which has already been treated).  Likewise, if the
  suite inserts an item in the sequence before the current item, the
  current item will be treated again the next time through the loop.
  This can lead to nasty bugs that can be avoided by making a
  temporary copy using a slice of the whole sequence, e.g.,

     for x in a[:]:
         if x < 0: a.remove(x)
t   foruP  
Format String Syntax
********************

The "str.format()" method and the "Formatter" class share the same
syntax for format strings (although in the case of "Formatter",
subclasses can define their own format string syntax).

Format strings contain "replacement fields" surrounded by curly braces
"{}". Anything that is not contained in braces is considered literal
text, which is copied unchanged to the output.  If you need to include
a brace character in the literal text, it can be escaped by doubling:
"{{" and "}}".

The grammar for a replacement field is as follows:

      replacement_field ::= "{" [field_name] ["!" conversion] [":" format_spec] "}"
      field_name        ::= arg_name ("." attribute_name | "[" element_index "]")*
      arg_name          ::= [identifier | integer]
      attribute_name    ::= identifier
      element_index     ::= integer | index_string
      index_string      ::= <any source character except "]"> +
      conversion        ::= "r" | "s"
      format_spec       ::= <described in the next section>

In less formal terms, the replacement field can start with a
*field_name* that specifies the object whose value is to be formatted
and inserted into the output instead of the replacement field. The
*field_name* is optionally followed by a  *conversion* field, which is
preceded by an exclamation point "'!'", and a *format_spec*, which is
preceded by a colon "':'".  These specify a non-default format for the
replacement value.

See also the *Format Specification Mini-Language* section.

The *field_name* itself begins with an *arg_name* that is either a
number or a keyword.  If it's a number, it refers to a positional
argument, and if it's a keyword, it refers to a named keyword
argument.  If the numerical arg_names in a format string are 0, 1, 2,
... in sequence, they can all be omitted (not just some) and the
numbers 0, 1, 2, ... will be automatically inserted in that order.
Because *arg_name* is not quote-delimited, it is not possible to
specify arbitrary dictionary keys (e.g., the strings "'10'" or
"':-]'") within a format string. The *arg_name* can be followed by any
number of index or attribute expressions. An expression of the form
"'.name'" selects the named attribute using "getattr()", while an
expression of the form "'[index]'" does an index lookup using
"__getitem__()".

Changed in version 2.7: The positional argument specifiers can be
omitted, so "'{} {}'" is equivalent to "'{0} {1}'".

Some simple format string examples:

   "First, thou shalt count to {0}" # References first positional argument
   "Bring me a {}"                  # Implicitly references the first positional argument
   "From {} to {}"                  # Same as "From {0} to {1}"
   "My quest is {name}"             # References keyword argument 'name'
   "Weight in tons {0.weight}"      # 'weight' attribute of first positional arg
   "Units destroyed: {players[0]}"  # First element of keyword argument 'players'.

The *conversion* field causes a type coercion before formatting.
Normally, the job of formatting a value is done by the "__format__()"
method of the value itself.  However, in some cases it is desirable to
force a type to be formatted as a string, overriding its own
definition of formatting.  By converting the value to a string before
calling "__format__()", the normal formatting logic is bypassed.

Two conversion flags are currently supported: "'!s'" which calls
"str()" on the value, and "'!r'" which calls "repr()".

Some examples:

   "Harold's a clever {0!s}"        # Calls str() on the argument first
   "Bring out the holy {name!r}"    # Calls repr() on the argument first

The *format_spec* field contains a specification of how the value
should be presented, including such details as field width, alignment,
padding, decimal precision and so on.  Each value type can define its
own "formatting mini-language" or interpretation of the *format_spec*.

Most built-in types support a common formatting mini-language, which
is described in the next section.

A *format_spec* field can also include nested replacement fields
within it. These nested replacement fields can contain only a field
name; conversion flags and format specifications are not allowed.  The
replacement fields within the format_spec are substituted before the
*format_spec* string is interpreted. This allows the formatting of a
value to be dynamically specified.

See the *Format examples* section for some examples.


Format Specification Mini-Language
==================================

"Format specifications" are used within replacement fields contained
within a format string to define how individual values are presented
(see *Format String Syntax*).  They can also be passed directly to the
built-in "format()" function.  Each formattable type may define how
the format specification is to be interpreted.

Most built-in types implement the following options for format
specifications, although some of the formatting options are only
supported by the numeric types.

A general convention is that an empty format string ("""") produces
the same result as if you had called "str()" on the value. A non-empty
format string typically modifies the result.

The general form of a *standard format specifier* is:

   format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]
   fill        ::= <any character>
   align       ::= "<" | ">" | "=" | "^"
   sign        ::= "+" | "-" | " "
   width       ::= integer
   precision   ::= integer
   type        ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"

If a valid *align* value is specified, it can be preceded by a *fill*
character that can be any character and defaults to a space if
omitted. Note that it is not possible to use "{" and "}" as *fill*
char while using the "str.format()" method; this limitation however
doesn't affect the "format()" function.

The meaning of the various alignment options is as follows:

   +-----------+------------------------------------------------------------+
   | Option    | Meaning                                                    |
   +===========+============================================================+
   | "'<'"     | Forces the field to be left-aligned within the available   |
   |           | space (this is the default for most objects).              |
   +-----------+------------------------------------------------------------+
   | "'>'"     | Forces the field to be right-aligned within the available  |
   |           | space (this is the default for numbers).                   |
   +-----------+------------------------------------------------------------+
   | "'='"     | Forces the padding to be placed after the sign (if any)    |
   |           | but before the digits.  This is used for printing fields   |
   |           | in the form '+000000120'. This alignment option is only    |
   |           | valid for numeric types.                                   |
   +-----------+------------------------------------------------------------+
   | "'^'"     | Forces the field to be centered within the available       |
   |           | space.                                                     |
   +-----------+------------------------------------------------------------+

Note that unless a minimum field width is defined, the field width
will always be the same size as the data to fill it, so that the
alignment option has no meaning in this case.

The *sign* option is only valid for number types, and can be one of
the following:

   +-----------+------------------------------------------------------------+
   | Option    | Meaning                                                    |
   +===========+============================================================+
   | "'+'"     | indicates that a sign should be used for both positive as  |
   |           | well as negative numbers.                                  |
   +-----------+------------------------------------------------------------+
   | "'-'"     | indicates that a sign should be used only for negative     |
   |           | numbers (this is the default behavior).                    |
   +-----------+------------------------------------------------------------+
   | space     | indicates that a leading space should be used on positive  |
   |           | numbers, and a minus sign on negative numbers.             |
   +-----------+------------------------------------------------------------+

The "'#'" option is only valid for integers, and only for binary,
octal, or hexadecimal output.  If present, it specifies that the
output will be prefixed by "'0b'", "'0o'", or "'0x'", respectively.

The "','" option signals the use of a comma for a thousands separator.
For a locale aware separator, use the "'n'" integer presentation type
instead.

Changed in version 2.7: Added the "','" option (see also **PEP 378**).

*width* is a decimal integer defining the minimum field width.  If not
specified, then the field width will be determined by the content.

Preceding the *width* field by a zero ("'0'") character enables sign-
aware zero-padding for numeric types.  This is equivalent to a *fill*
character of "'0'" with an *alignment* type of "'='".

The *precision* is a decimal number indicating how many digits should
be displayed after the decimal point for a floating point value
formatted with "'f'" and "'F'", or before and after the decimal point
for a floating point value formatted with "'g'" or "'G'".  For non-
number types the field indicates the maximum field size - in other
words, how many characters will be used from the field content. The
*precision* is not allowed for integer values.

Finally, the *type* determines how the data should be presented.

The available string presentation types are:

   +-----------+------------------------------------------------------------+
   | Type      | Meaning                                                    |
   +===========+============================================================+
   | "'s'"     | String format. This is the default type for strings and    |
   |           | may be omitted.                                            |
   +-----------+------------------------------------------------------------+
   | None      | The same as "'s'".                                         |
   +-----------+------------------------------------------------------------+

The available integer presentation types are:

   +-----------+------------------------------------------------------------+
   | Type      | Meaning                                                    |
   +===========+============================================================+
   | "'b'"     | Binary format. Outputs the number in base 2.               |
   +-----------+------------------------------------------------------------+
   | "'c'"     | Character. Converts the integer to the corresponding       |
   |           | unicode character before printing.                         |
   +-----------+------------------------------------------------------------+
   | "'d'"     | Decimal Integer. Outputs the number in base 10.            |
   +-----------+------------------------------------------------------------+
   | "'o'"     | Octal format. Outputs the number in base 8.                |
   +-----------+------------------------------------------------------------+
   | "'x'"     | Hex format. Outputs the number in base 16, using lower-    |
   |           | case letters for the digits above 9.                       |
   +-----------+------------------------------------------------------------+
   | "'X'"     | Hex format. Outputs the number in base 16, using upper-    |
   |           | case letters for the digits above 9.                       |
   +-----------+------------------------------------------------------------+
   | "'n'"     | Number. This is the same as "'d'", except that it uses the |
   |           | current locale setting to insert the appropriate number    |
   |           | separator characters.                                      |
   +-----------+------------------------------------------------------------+
   | None      | The same as "'d'".                                         |
   +-----------+------------------------------------------------------------+

In addition to the above presentation types, integers can be formatted
with the floating point presentation types listed below (except "'n'"
and None). When doing so, "float()" is used to convert the integer to
a floating point number before formatting.

The available presentation types for floating point and decimal values
are:

   +-----------+------------------------------------------------------------+
   | Type      | Meaning                                                    |
   +===========+============================================================+
   | "'e'"     | Exponent notation. Prints the number in scientific         |
   |           | notation using the letter 'e' to indicate the exponent.    |
   |           | The default precision is "6".                              |
   +-----------+------------------------------------------------------------+
   | "'E'"     | Exponent notation. Same as "'e'" except it uses an upper   |
   |           | case 'E' as the separator character.                       |
   +-----------+------------------------------------------------------------+
   | "'f'"     | Fixed point. Displays the number as a fixed-point number.  |
   |           | The default precision is "6".                              |
   +-----------+------------------------------------------------------------+
   | "'F'"     | Fixed point. Same as "'f'".                                |
   +-----------+------------------------------------------------------------+
   | "'g'"     | General format.  For a given precision "p >= 1", this      |
   |           | rounds the number to "p" significant digits and then       |
   |           | formats the result in either fixed-point format or in      |
   |           | scientific notation, depending on its magnitude.  The      |
   |           | precise rules are as follows: suppose that the result      |
   |           | formatted with presentation type "'e'" and precision "p-1" |
   |           | would have exponent "exp".  Then if "-4 <= exp < p", the   |
   |           | number is formatted with presentation type "'f'" and       |
   |           | precision "p-1-exp".  Otherwise, the number is formatted   |
   |           | with presentation type "'e'" and precision "p-1". In both  |
   |           | cases insignificant trailing zeros are removed from the    |
   |           | significand, and the decimal point is also removed if      |
   |           | there are no remaining digits following it.  Positive and  |
   |           | negative infinity, positive and negative zero, and nans,   |
   |           | are formatted as "inf", "-inf", "0", "-0" and "nan"        |
   |           | respectively, regardless of the precision.  A precision of |
   |           | "0" is treated as equivalent to a precision of "1". The    |
   |           | default precision is "6".                                  |
   +-----------+------------------------------------------------------------+
   | "'G'"     | General format. Same as "'g'" except switches to "'E'" if  |
   |           | the number gets too large. The representations of infinity |
   |           | and NaN are uppercased, too.                               |
   +-----------+------------------------------------------------------------+
   | "'n'"     | Number. This is the same as "'g'", except that it uses the |
   |           | current locale setting to insert the appropriate number    |
   |           | separator characters.                                      |
   +-----------+------------------------------------------------------------+
   | "'%'"     | Percentage. Multiplies the number by 100 and displays in   |
   |           | fixed ("'f'") format, followed by a percent sign.          |
   +-----------+------------------------------------------------------------+
   | None      | The same as "'g'".                                         |
   +-----------+------------------------------------------------------------+


Format examples
===============

This section contains examples of the new format syntax and comparison
with the old "%"-formatting.

In most of the cases the syntax is similar to the old "%"-formatting,
with the addition of the "{}" and with ":" used instead of "%". For
example, "'%03.2f'" can be translated to "'{:03.2f}'".

The new format syntax also supports new and different options, shown
in the follow examples.

Accessing arguments by position:

   >>> '{0}, {1}, {2}'.format('a', 'b', 'c')
   'a, b, c'
   >>> '{}, {}, {}'.format('a', 'b', 'c')  # 2.7+ only
   'a, b, c'
   >>> '{2}, {1}, {0}'.format('a', 'b', 'c')
   'c, b, a'
   >>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
   'c, b, a'
   >>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
   'abracadabra'

Accessing arguments by name:

   >>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
   'Coordinates: 37.24N, -115.81W'
   >>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
   >>> 'Coordinates: {latitude}, {longitude}'.format(**coord)
   'Coordinates: 37.24N, -115.81W'

Accessing arguments' attributes:

   >>> c = 3-5j
   >>> ('The complex number {0} is formed from the real part {0.real} '
   ...  'and the imaginary part {0.imag}.').format(c)
   'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'
   >>> class Point(object):
   ...     def __init__(self, x, y):
   ...         self.x, self.y = x, y
   ...     def __str__(self):
   ...         return 'Point({self.x}, {self.y})'.format(self=self)
   ...
   >>> str(Point(4, 2))
   'Point(4, 2)'

Accessing arguments' items:

   >>> coord = (3, 5)
   >>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
   'X: 3;  Y: 5'

Replacing "%s" and "%r":

   >>> "repr() shows quotes: {!r}; str() doesn't: {!s}".format('test1', 'test2')
   "repr() shows quotes: 'test1'; str() doesn't: test2"

Aligning the text and specifying a width:

   >>> '{:<30}'.format('left aligned')
   'left aligned                  '
   >>> '{:>30}'.format('right aligned')
   '                 right aligned'
   >>> '{:^30}'.format('centered')
   '           centered           '
   >>> '{:*^30}'.format('centered')  # use '*' as a fill char
   '***********centered***********'

Replacing "%+f", "%-f", and "% f" and specifying a sign:

   >>> '{:+f}; {:+f}'.format(3.14, -3.14)  # show it always
   '+3.140000; -3.140000'
   >>> '{: f}; {: f}'.format(3.14, -3.14)  # show a space for positive numbers
   ' 3.140000; -3.140000'
   >>> '{:-f}; {:-f}'.format(3.14, -3.14)  # show only the minus -- same as '{:f}; {:f}'
   '3.140000; -3.140000'

Replacing "%x" and "%o" and converting the value to different bases:

   >>> # format also supports binary numbers
   >>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
   'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
   >>> # with 0x, 0o, or 0b as prefix:
   >>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
   'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'

Using the comma as a thousands separator:

   >>> '{:,}'.format(1234567890)
   '1,234,567,890'

Expressing a percentage:

   >>> points = 19.5
   >>> total = 22
   >>> 'Correct answers: {:.2%}'.format(points/total)
   'Correct answers: 88.64%'

Using type-specific formatting:

   >>> import datetime
   >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)
   >>> '{:%Y-%m-%d %H:%M:%S}'.format(d)
   '2010-07-04 12:15:58'

Nesting arguments and more complex examples:

   >>> for align, text in zip('<^>', ['left', 'center', 'right']):
   ...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)
   ...
   'left<<<<<<<<<<<<'
   '^^^^^center^^^^^'
   '>>>>>>>>>>>right'
   >>>
   >>> octets = [192, 168, 0, 1]
   >>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)
   'C0A80001'
   >>> int(_, 16)
   3232235521
   >>>
   >>> width = 5
   >>> for num in range(5,12):
   ...     for base in 'dXob':
   ...         print '{0:{width}{base}}'.format(num, base=base, width=width),
   ...     print
   ...
       5     5     5   101
       6     6     6   110
       7     7     7   111
       8     8    10  1000
       9     9    11  1001
      10     A    12  1010
      11     B    13  1011
t   formatstringsu  
Function definitions
********************

A function definition defines a user-defined function object (see
section *The standard type hierarchy*):

   decorated      ::= decorators (classdef | funcdef)
   decorators     ::= decorator+
   decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
   funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite
   dotted_name    ::= identifier ("." identifier)*
   parameter_list ::= (defparameter ",")*
                      (  "*" identifier ["," "**" identifier]
                      | "**" identifier
                      | defparameter [","] )
   defparameter   ::= parameter ["=" expression]
   sublist        ::= parameter ("," parameter)* [","]
   parameter      ::= identifier | "(" sublist ")"
   funcname       ::= identifier

A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object
(a wrapper around the executable code for the function).  This
function object contains a reference to the current global namespace
as the global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called. [3]

A function definition may be wrapped by one or more *decorator*
expressions. Decorator expressions are evaluated when the function is
defined, in the scope that contains the function definition.  The
result must be a callable, which is invoked with the function object
as the only argument. The returned value is bound to the function name
instead of the function object.  Multiple decorators are applied in
nested fashion. For example, the following code:

   @f1(arg)
   @f2
   def func(): pass

is equivalent to:

   def func(): pass
   func = f1(arg)(f2(func))

When one or more top-level *parameters* have the form *parameter* "="
*expression*, the function is said to have "default parameter values."
For a parameter with a default value, the corresponding *argument* may
be omitted from a call, in which case the parameter's default value is
substituted.  If a parameter has a default value, all following
parameters must also have a default value --- this is a syntactic
restriction that is not expressed by the grammar.

**Default parameter values are evaluated when the function definition
is executed.**  This means that the expression is evaluated once, when
the function is defined, and that the same "pre-computed" value is
used for each call.  This is especially important to understand when a
default parameter is a mutable object, such as a list or a dictionary:
if the function modifies the object (e.g. by appending an item to a
list), the default value is in effect modified. This is generally not
what was intended.  A way around this  is to use "None" as the
default, and explicitly test for it in the body of the function, e.g.:

   def whats_on_the_telly(penguin=None):
       if penguin is None:
           penguin = []
       penguin.append("property of the zoo")
       return penguin

Function call semantics are described in more detail in section
*Calls*. A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form
""*identifier"" is present, it is initialized to a tuple receiving any
excess positional parameters, defaulting to the empty tuple.  If the
form ""**identifier"" is present, it is initialized to a new
dictionary receiving any excess keyword arguments, defaulting to a new
empty dictionary.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *Lambdas*.  Note that the lambda
expression is merely a shorthand for a simplified function definition;
a function defined in a ""def"" statement can be passed around or
assigned to another name just like a function defined by a lambda
expression.  The ""def"" form is actually more powerful since it
allows the execution of multiple statements.

**Programmer's note:** Functions are first-class objects.  A ""def""
form executed inside a function definition defines a local function
that can be returned or passed around.  Free variables used in the
nested function can access the local variables of the function
containing the def.  See section *Naming and binding* for details.
t   functionu  
The "global" statement
**********************

   global_stmt ::= "global" identifier ("," identifier)*

The "global" statement is a declaration which holds for the entire
current code block.  It means that the listed identifiers are to be
interpreted as globals.  It would be impossible to assign to a global
variable without "global", although free variables may refer to
globals without being declared global.

Names listed in a "global" statement must not be used in the same code
block textually preceding that "global" statement.

Names listed in a "global" statement must not be defined as formal
parameters or in a "for" loop control target, "class" definition,
function definition, or "import" statement.

**CPython implementation detail:** The current implementation does not
enforce the latter two restrictions, but programs should not abuse
this freedom, as future implementations may enforce them or silently
change the meaning of the program.

**Programmer's note:** the "global" is a directive to the parser.  It
applies only to code parsed at the same time as the "global"
statement. In particular, a "global" statement contained in an "exec"
statement does not affect the code block *containing* the "exec"
statement, and code contained in an "exec" statement is unaffected by
"global" statements in the code containing the "exec" statement.  The
same applies to the "eval()", "execfile()" and "compile()" functions.
t   globalu  
Reserved classes of identifiers
*******************************

Certain classes of identifiers (besides keywords) have special
meanings.  These classes are identified by the patterns of leading and
trailing underscore characters:

"_*"
   Not imported by "from module import *".  The special identifier "_"
   is used in the interactive interpreter to store the result of the
   last evaluation; it is stored in the "__builtin__" module.  When
   not in interactive mode, "_" has no special meaning and is not
   defined. See section *The import statement*.

   Note: The name "_" is often used in conjunction with
     internationalization; refer to the documentation for the
     "gettext" module for more information on this convention.

"__*__"
   System-defined names. These names are defined by the interpreter
   and its implementation (including the standard library).  Current
   system names are discussed in the *Special method names* section
   and elsewhere.  More will likely be defined in future versions of
   Python.  *Any* use of "__*__" names, in any context, that does not
   follow explicitly documented use, is subject to breakage without
   warning.

"__*"
   Class-private names.  Names in this category, when used within the
   context of a class definition, are re-written to use a mangled form
   to help avoid name clashes between "private" attributes of base and
   derived classes. See section *Identifiers (Names)*.
s
   id-classesu
  
Identifiers and keywords
************************

Identifiers (also referred to as *names*) are described by the
following lexical definitions:

   identifier ::= (letter|"_") (letter | digit | "_")*
   letter     ::= lowercase | uppercase
   lowercase  ::= "a"..."z"
   uppercase  ::= "A"..."Z"
   digit      ::= "0"..."9"

Identifiers are unlimited in length.  Case is significant.


Keywords
========

The following identifiers are used as reserved words, or *keywords* of
the language, and cannot be used as ordinary identifiers.  They must
be spelled exactly as written here:

   and       del       from      not       while
   as        elif      global    or        with
   assert    else      if        pass      yield
   break     except    import    print
   class     exec      in        raise
   continue  finally   is        return
   def       for       lambda    try

Changed in version 2.4: "None" became a constant and is now recognized
by the compiler as a name for the built-in object "None".  Although it
is not a keyword, you cannot assign a different object to it.

Changed in version 2.5: Using "as" and "with" as identifiers triggers
a warning.  To use them as keywords, enable the "with_statement"
future feature .

Changed in version 2.6: "as" and "with" are full keywords.


Reserved classes of identifiers
===============================

Certain classes of identifiers (besides keywords) have special
meanings.  These classes are identified by the patterns of leading and
trailing underscore characters:

"_*"
   Not imported by "from module import *".  The special identifier "_"
   is used in the interactive interpreter to store the result of the
   last evaluation; it is stored in the "__builtin__" module.  When
   not in interactive mode, "_" has no special meaning and is not
   defined. See section *The import statement*.

   Note: The name "_" is often used in conjunction with
     internationalization; refer to the documentation for the
     "gettext" module for more information on this convention.

"__*__"
   System-defined names. These names are defined by the interpreter
   and its implementation (including the standard library).  Current
   system names are discussed in the *Special method names* section
   and elsewhere.  More will likely be defined in future versions of
   Python.  *Any* use of "__*__" names, in any context, that does not
   follow explicitly documented use, is subject to breakage without
   warning.

"__*"
   Class-private names.  Names in this category, when used within the
   context of a class definition, are re-written to use a mangled form
   to help avoid name clashes between "private" attributes of base and
   derived classes. See section *Identifiers (Names)*.
t   identifierst   ifu%  
Imaginary literals
******************

Imaginary literals are described by the following lexical definitions:

   imagnumber ::= (floatnumber | intpart) ("j" | "J")

An imaginary literal yields a complex number with a real part of 0.0.
Complex numbers are represented as a pair of floating point numbers
and have the same restrictions on their range.  To create a complex
number with a nonzero real part, add a floating point number to it,
e.g., "(3+4j)".  Some examples of imaginary literals:

   3.14j   10.j    10j     .001j   1e100j  3.14e-10j
t	   imaginaryuI.  
The "import" statement
**********************

   import_stmt     ::= "import" module ["as" name] ( "," module ["as" name] )*
                   | "from" relative_module "import" identifier ["as" name]
                   ( "," identifier ["as" name] )*
                   | "from" relative_module "import" "(" identifier ["as" name]
                   ( "," identifier ["as" name] )* [","] ")"
                   | "from" module "import" "*"
   module          ::= (identifier ".")* identifier
   relative_module ::= "."* module | "."+
   name            ::= identifier

Import statements are executed in two steps: (1) find a module, and
initialize it if necessary; (2) define a name or names in the local
namespace (of the scope where the "import" statement occurs). The
statement comes in two forms differing on whether it uses the "from"
keyword. The first form (without "from") repeats these steps for each
identifier in the list. The form with "from" performs step (1) once,
and then performs step (2) repeatedly.

To understand how step (1) occurs, one must first understand how
Python handles hierarchical naming of modules. To help organize
modules and provide a hierarchy in naming, Python has a concept of
packages. A package can contain other packages and modules while
modules cannot contain other modules or packages. From a file system
perspective, packages are directories and modules are files.

Once the name of the module is known (unless otherwise specified, the
term "module" will refer to both packages and modules), searching for
the module or package can begin. The first place checked is
"sys.modules", the cache of all modules that have been imported
previously. If the module is found there then it is used in step (2)
of import.

If the module is not found in the cache, then "sys.meta_path" is
searched (the specification for "sys.meta_path" can be found in **PEP
302**). The object is a list of *finder* objects which are queried in
order as to whether they know how to load the module by calling their
"find_module()" method with the name of the module. If the module
happens to be contained within a package (as denoted by the existence
of a dot in the name), then a second argument to "find_module()" is
given as the value of the "__path__" attribute from the parent package
(everything up to the last dot in the name of the module being
imported). If a finder can find the module it returns a *loader*
(discussed later) or returns "None".

If none of the finders on "sys.meta_path" are able to find the module
then some implicitly defined finders are queried. Implementations of
Python vary in what implicit meta path finders are defined. The one
they all do define, though, is one that handles "sys.path_hooks",
"sys.path_importer_cache", and "sys.path".

The implicit finder searches for the requested module in the "paths"
specified in one of two places ("paths" do not have to be file system
paths). If the module being imported is supposed to be contained
within a package then the second argument passed to "find_module()",
"__path__" on the parent package, is used as the source of paths. If
the module is not contained in a package then "sys.path" is used as
the source of paths.

Once the source of paths is chosen it is iterated over to find a
finder that can handle that path. The dict at
"sys.path_importer_cache" caches finders for paths and is checked for
a finder. If the path does not have a finder cached then
"sys.path_hooks" is searched by calling each object in the list with a
single argument of the path, returning a finder or raises
"ImportError". If a finder is returned then it is cached in
"sys.path_importer_cache" and then used for that path entry. If no
finder can be found but the path exists then a value of "None" is
stored in "sys.path_importer_cache" to signify that an implicit, file-
based finder that handles modules stored as individual files should be
used for that path. If the path does not exist then a finder which
always returns "None" is placed in the cache for the path.

If no finder can find the module then "ImportError" is raised.
Otherwise some finder returned a loader whose "load_module()" method
is called with the name of the module to load (see **PEP 302** for the
original definition of loaders). A loader has several responsibilities
to perform on a module it loads. First, if the module already exists
in "sys.modules" (a possibility if the loader is called outside of the
import machinery) then it is to use that module for initialization and
not a new module. But if the module does not exist in "sys.modules"
then it is to be added to that dict before initialization begins. If
an error occurs during loading of the module and it was added to
"sys.modules" it is to be removed from the dict. If an error occurs
but the module was already in "sys.modules" it is left in the dict.

The loader must set several attributes on the module. "__name__" is to
be set to the name of the module. "__file__" is to be the "path" to
the file unless the module is built-in (and thus listed in
"sys.builtin_module_names") in which case the attribute is not set. If
what is being imported is a package then "__path__" is to be set to a
list of paths to be searched when looking for modules and packages
contained within the package being imported. "__package__" is optional
but should be set to the name of package that contains the module or
package (the empty string is used for module not contained in a
package). "__loader__" is also optional but should be set to the
loader object that is loading the module.

If an error occurs during loading then the loader raises "ImportError"
if some other exception is not already being propagated. Otherwise the
loader returns the module that was loaded and initialized.

When step (1) finishes without raising an exception, step (2) can
begin.

The first form of "import" statement binds the module name in the
local namespace to the module object, and then goes on to import the
next identifier, if any.  If the module name is followed by "as", the
name following "as" is used as the local name for the module.

The "from" form does not bind the module name: it goes through the
list of identifiers, looks each one of them up in the module found in
step (1), and binds the name in the local namespace to the object thus
found.  As with the first form of "import", an alternate local name
can be supplied by specifying ""as" localname".  If a name is not
found, "ImportError" is raised.  If the list of identifiers is
replaced by a star ("'*'"), all public names defined in the module are
bound in the local namespace of the "import" statement..

The *public names* defined by a module are determined by checking the
module's namespace for a variable named "__all__"; if defined, it must
be a sequence of strings which are names defined or imported by that
module.  The names given in "__all__" are all considered public and
are required to exist.  If "__all__" is not defined, the set of public
names includes all names found in the module's namespace which do not
begin with an underscore character ("'_'"). "__all__" should contain
the entire public API. It is intended to avoid accidentally exporting
items that are not part of the API (such as library modules which were
imported and used within the module).

The "from" form with "*" may only occur in a module scope.  If the
wild card form of import --- "import *" --- is used in a function and
the function contains or is a nested block with free variables, the
compiler will raise a "SyntaxError".

When specifying what module to import you do not have to specify the
absolute name of the module. When a module or package is contained
within another package it is possible to make a relative import within
the same top package without having to mention the package name. By
using leading dots in the specified module or package after "from" you
can specify how high to traverse up the current package hierarchy
without specifying exact names. One leading dot means the current
package where the module making the import exists. Two dots means up
one package level. Three dots is up two levels, etc. So if you execute
"from . import mod" from a module in the "pkg" package then you will
end up importing "pkg.mod". If you execute "from ..subpkg2 import mod"
from within "pkg.subpkg1" you will import "pkg.subpkg2.mod". The
specification for relative imports is contained within **PEP 328**.

"importlib.import_module()" is provided to support applications that
determine which modules need to be loaded dynamically.


Future statements
=================

A *future statement* is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python.  The future
statement is intended to ease migration to future versions of Python
that introduce incompatible changes to the language.  It allows use of
the new features on a per-module basis before the release in which the
feature becomes standard.

   future_statement ::= "from" "__future__" "import" feature ["as" name]
                        ("," feature ["as" name])*
                        | "from" "__future__" "import" "(" feature ["as" name]
                        ("," feature ["as" name])* [","] ")"
   feature          ::= identifier
   name             ::= identifier

A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

* the module docstring (if any),

* comments,

* blank lines, and

* other future statements.

The features recognized by Python 2.6 are "unicode_literals",
"print_function", "absolute_import", "division", "generators",
"nested_scopes" and "with_statement".  "generators", "with_statement",
"nested_scopes" are redundant in Python version 2.6 and above because
they are always enabled.

A future statement is recognized and treated specially at compile
time: Changes to the semantics of core constructs are often
implemented by generating different code.  It may even be the case
that a new feature introduces new incompatible syntax (such as a new
reserved word), in which case the compiler may need to parse the
module differently.  Such decisions cannot be pushed off until
runtime.

For any given release, the compiler knows which feature names have
been defined, and raises a compile-time error if a future statement
contains a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module "__future__", described later, and it will
be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature
enabled by the future statement.

Note that there is nothing special about the statement:

   import __future__ [as name]

That is not a future statement; it's an ordinary import statement with
no special semantics or syntax restrictions.

Code compiled by an "exec" statement or calls to the built-in
functions "compile()" and "execfile()" that occur in a module "M"
containing a future statement will, by default, use the new  syntax or
semantics associated with the future statement.  This can, starting
with Python 2.2 be controlled by optional arguments to "compile()" ---
see the documentation of that function for details.

A future statement typed at an interactive interpreter prompt will
take effect for the rest of the interpreter session.  If an
interpreter is started with the *-i* option, is passed a script name
to execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is
executed.

See also: **PEP 236** - Back to the __future__

     The original proposal for the __future__ mechanism.
t   importt   inuo  
Integer and long integer literals
*********************************

Integer and long integer literals are described by the following
lexical definitions:

   longinteger    ::= integer ("l" | "L")
   integer        ::= decimalinteger | octinteger | hexinteger | bininteger
   decimalinteger ::= nonzerodigit digit* | "0"
   octinteger     ::= "0" ("o" | "O") octdigit+ | "0" octdigit+
   hexinteger     ::= "0" ("x" | "X") hexdigit+
   bininteger     ::= "0" ("b" | "B") bindigit+
   nonzerodigit   ::= "1"..."9"
   octdigit       ::= "0"..."7"
   bindigit       ::= "0" | "1"
   hexdigit       ::= digit | "a"..."f" | "A"..."F"

Although both lower case "'l'" and upper case "'L'" are allowed as
suffix for long integers, it is strongly recommended to always use
"'L'", since the letter "'l'" looks too much like the digit "'1'".

Plain integer literals that are above the largest representable plain
integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted
as if they were long integers instead. [1]  There is no limit for long
integer literals apart from what can be stored in available memory.

Some examples of plain integer literals (first row) and long integer
literals (second and third rows):

   7     2147483647                        0177
   3L    79228162514264337593543950336L    0377L   0x100000000L
         79228162514264337593543950336             0xdeadbeef
t   integersuz  
Lambdas
*******

   lambda_expr     ::= "lambda" [parameter_list]: expression
   old_lambda_expr ::= "lambda" [parameter_list]: old_expression

Lambda expressions (sometimes called lambda forms) have the same
syntactic position as expressions.  They are a shorthand to create
anonymous functions; the expression "lambda arguments: expression"
yields a function object.  The unnamed object behaves like a function
object defined with

   def name(arguments):
       return expression

See section *Function definitions* for the syntax of parameter lists.
Note that functions created with lambda expressions cannot contain
statements.
t   lambdau  
List displays
*************

A list display is a possibly empty series of expressions enclosed in
square brackets:

   list_display        ::= "[" [expression_list | list_comprehension] "]"
   list_comprehension  ::= expression list_for
   list_for            ::= "for" target_list "in" old_expression_list [list_iter]
   old_expression_list ::= old_expression [("," old_expression)+ [","]]
   old_expression      ::= or_test | old_lambda_expr
   list_iter           ::= list_for | list_if
   list_if             ::= "if" old_expression [list_iter]

A list display yields a new list object.  Its contents are specified
by providing either a list of expressions or a list comprehension.
When a comma-separated list of expressions is supplied, its elements
are evaluated from left to right and placed into the list object in
that order.  When a list comprehension is supplied, it consists of a
single expression followed by at least one "for" clause and zero or
more "for" or "if" clauses.  In this case, the elements of the new
list are those that would be produced by considering each of the "for"
or "if" clauses a block, nesting from left to right, and evaluating
the expression to produce a list element each time the innermost block
is reached [1].
t   listsu  
Naming and binding
******************

*Names* refer to objects.  Names are introduced by name binding
operations. Each occurrence of a name in the program text refers to
the *binding* of that name established in the innermost function block
containing the use.

A *block* is a piece of Python program text that is executed as a
unit. The following are blocks: a module, a function body, and a class
definition. Each command typed interactively is a block.  A script
file (a file given as standard input to the interpreter or specified
on the interpreter command line the first argument) is a code block.
A script command (a command specified on the interpreter command line
with the '**-c**' option) is a code block.  The file read by the
built-in function "execfile()" is a code block.  The string argument
passed to the built-in function "eval()" and to the "exec" statement
is a code block. The expression read and evaluated by the built-in
function "input()" is a code block.

A code block is executed in an *execution frame*.  A frame contains
some administrative information (used for debugging) and determines
where and how execution continues after the code block's execution has
completed.

A *scope* defines the visibility of a name within a block.  If a local
variable is defined in a block, its scope includes that block.  If the
definition occurs in a function block, the scope extends to any blocks
contained within the defining one, unless a contained block introduces
a different binding for the name.  The scope of names defined in a
class block is limited to the class block; it does not extend to the
code blocks of methods -- this includes generator expressions since
they are implemented using a function scope.  This means that the
following will fail:

   class A:
       a = 42
       b = list(a + i for i in range(10))

When a name is used in a code block, it is resolved using the nearest
enclosing scope.  The set of all such scopes visible to a code block
is called the block's *environment*.

If a name is bound in a block, it is a local variable of that block.
If a name is bound at the module level, it is a global variable.  (The
variables of the module code block are local and global.)  If a
variable is used in a code block but not defined there, it is a *free
variable*.

When a name is not found at all, a "NameError" exception is raised.
If the name refers to a local variable that has not been bound, a
"UnboundLocalError" exception is raised.  "UnboundLocalError" is a
subclass of "NameError".

The following constructs bind names: formal parameters to functions,
"import" statements, class and function definitions (these bind the
class or function name in the defining block), and targets that are
identifiers if occurring in an assignment, "for" loop header, in the
second position of an "except" clause header or after "as" in a "with"
statement.  The "import" statement of the form "from ... import *"
binds all names defined in the imported module, except those beginning
with an underscore.  This form may only be used at the module level.

A target occurring in a "del" statement is also considered bound for
this purpose (though the actual semantics are to unbind the name).  It
is illegal to unbind a name that is referenced by an enclosing scope;
the compiler will report a "SyntaxError".

Each assignment or import statement occurs within a block defined by a
class or function definition or at the module level (the top-level
code block).

If a name binding operation occurs anywhere within a code block, all
uses of the name within the block are treated as references to the
current block.  This can lead to errors when a name is used within a
block before it is bound. This rule is subtle.  Python lacks
declarations and allows name binding operations to occur anywhere
within a code block.  The local variables of a code block can be
determined by scanning the entire text of the block for name binding
operations.

If the global statement occurs within a block, all uses of the name
specified in the statement refer to the binding of that name in the
top-level namespace. Names are resolved in the top-level namespace by
searching the global namespace, i.e. the namespace of the module
containing the code block, and the builtins namespace, the namespace
of the module "__builtin__".  The global namespace is searched first.
If the name is not found there, the builtins namespace is searched.
The global statement must precede all uses of the name.

The builtins namespace associated with the execution of a code block
is actually found by looking up the name "__builtins__" in its global
namespace; this should be a dictionary or a module (in the latter case
the module's dictionary is used).  By default, when in the "__main__"
module, "__builtins__" is the built-in module "__builtin__" (note: no
's'); when in any other module, "__builtins__" is an alias for the
dictionary of the "__builtin__" module itself.  "__builtins__" can be
set to a user-created dictionary to create a weak form of restricted
execution.

**CPython implementation detail:** Users should not touch
"__builtins__"; it is strictly an implementation detail.  Users
wanting to override values in the builtins namespace should "import"
the "__builtin__" (no 's') module and modify its attributes
appropriately.

The namespace for a module is automatically created the first time a
module is imported.  The main module for a script is always called
"__main__".

The "global" statement has the same scope as a name binding operation
in the same block.  If the nearest enclosing scope for a free variable
contains a global statement, the free variable is treated as a global.

A class definition is an executable statement that may use and define
names. These references follow the normal rules for name resolution.
The namespace of the class definition becomes the attribute dictionary
of the class.  Names defined at the class scope are not visible in
methods.


Interaction with dynamic features
=================================

There are several cases where Python statements are illegal when used
in conjunction with nested scopes that contain free variables.

If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

If the wild card form of import --- "import *" --- is used in a
function and the function contains or is a nested block with free
variables, the compiler will raise a "SyntaxError".

If "exec" is used in a function and the function contains or is a
nested block with free variables, the compiler will raise a
"SyntaxError" unless the exec explicitly specifies the local namespace
for the "exec".  (In other words, "exec obj" would be illegal, but
"exec obj in ns" would be legal.)

The "eval()", "execfile()", and "input()" functions and the "exec"
statement do not have access to the full environment for resolving
names.  Names may be resolved in the local and global namespaces of
the caller.  Free variables are not resolved in the nearest enclosing
namespace, but in the global namespace. [1] The "exec" statement and
the "eval()" and "execfile()" functions have optional arguments to
override the global and local namespace.  If only one namespace is
specified, it is used for both.
t   namingu  
Numeric literals
****************

There are four types of numeric literals: plain integers, long
integers, floating point numbers, and imaginary numbers.  There are no
complex literals (complex numbers can be formed by adding a real
number and an imaginary number).

Note that numeric literals do not include a sign; a phrase like "-1"
is actually an expression composed of the unary operator '"-"' and the
literal "1".
t   numbersuy  
Emulating numeric types
***********************

The following methods can be defined to emulate numeric objects.
Methods corresponding to operations that are not supported by the
particular kind of number implemented (e.g., bitwise operations for
non-integral numbers) should be left undefined.

object.__add__(self, other)
object.__sub__(self, other)
object.__mul__(self, other)
object.__floordiv__(self, other)
object.__mod__(self, other)
object.__divmod__(self, other)
object.__pow__(self, other[, modulo])
object.__lshift__(self, other)
object.__rshift__(self, other)
object.__and__(self, other)
object.__xor__(self, other)
object.__or__(self, other)

   These methods are called to implement the binary arithmetic
   operations ("+", "-", "*", "//", "%", "divmod()", "pow()", "**",
   "<<", ">>", "&", "^", "|").  For instance, to evaluate the
   expression "x + y", where *x* is an instance of a class that has an
   "__add__()" method, "x.__add__(y)" is called.  The "__divmod__()"
   method should be the equivalent to using "__floordiv__()" and
   "__mod__()"; it should not be related to "__truediv__()" (described
   below).  Note that "__pow__()" should be defined to accept an
   optional third argument if the ternary version of the built-in
   "pow()" function is to be supported.

   If one of those methods does not support the operation with the
   supplied arguments, it should return "NotImplemented".

object.__div__(self, other)
object.__truediv__(self, other)

   The division operator ("/") is implemented by these methods.  The
   "__truediv__()" method is used when "__future__.division" is in
   effect, otherwise "__div__()" is used.  If only one of these two
   methods is defined, the object will not support division in the
   alternate context; "TypeError" will be raised instead.

object.__radd__(self, other)
object.__rsub__(self, other)
object.__rmul__(self, other)
object.__rdiv__(self, other)
object.__rtruediv__(self, other)
object.__rfloordiv__(self, other)
object.__rmod__(self, other)
object.__rdivmod__(self, other)
object.__rpow__(self, other)
object.__rlshift__(self, other)
object.__rrshift__(self, other)
object.__rand__(self, other)
object.__rxor__(self, other)
object.__ror__(self, other)

   These methods are called to implement the binary arithmetic
   operations ("+", "-", "*", "/", "%", "divmod()", "pow()", "**",
   "<<", ">>", "&", "^", "|") with reflected (swapped) operands.
   These functions are only called if the left operand does not
   support the corresponding operation and the operands are of
   different types. [2] For instance, to evaluate the expression "x -
   y", where *y* is an instance of a class that has an "__rsub__()"
   method, "y.__rsub__(x)" is called if "x.__sub__(y)" returns
   *NotImplemented*.

   Note that ternary "pow()" will not try calling "__rpow__()" (the
   coercion rules would become too complicated).

   Note: If the right operand's type is a subclass of the left
     operand's type and that subclass provides the reflected method
     for the operation, this method will be called before the left
     operand's non-reflected method.  This behavior allows subclasses
     to override their ancestors' operations.

object.__iadd__(self, other)
object.__isub__(self, other)
object.__imul__(self, other)
object.__idiv__(self, other)
object.__itruediv__(self, other)
object.__ifloordiv__(self, other)
object.__imod__(self, other)
object.__ipow__(self, other[, modulo])
object.__ilshift__(self, other)
object.__irshift__(self, other)
object.__iand__(self, other)
object.__ixor__(self, other)
object.__ior__(self, other)

   These methods are called to implement the augmented arithmetic
   assignments ("+=", "-=", "*=", "/=", "//=", "%=", "**=", "<<=",
   ">>=", "&=", "^=", "|=").  These methods should attempt to do the
   operation in-place (modifying *self*) and return the result (which
   could be, but does not have to be, *self*).  If a specific method
   is not defined, the augmented assignment falls back to the normal
   methods.  For instance, to execute the statement "x += y", where
   *x* is an instance of a class that has an "__iadd__()" method,
   "x.__iadd__(y)" is called.  If *x* is an instance of a class that
   does not define a "__iadd__()" method, "x.__add__(y)" and
   "y.__radd__(x)" are considered, as with the evaluation of "x + y".

object.__neg__(self)
object.__pos__(self)
object.__abs__(self)
object.__invert__(self)

   Called to implement the unary arithmetic operations ("-", "+",
   "abs()" and "~").

object.__complex__(self)
object.__int__(self)
object.__long__(self)
object.__float__(self)

   Called to implement the built-in functions "complex()", "int()",
   "long()", and "float()".  Should return a value of the appropriate
   type.

object.__oct__(self)
object.__hex__(self)

   Called to implement the built-in functions "oct()" and "hex()".
   Should return a string value.

object.__index__(self)

   Called to implement "operator.index()".  Also called whenever
   Python needs an integer object (such as in slicing).  Must return
   an integer (int or long).

   New in version 2.5.

object.__coerce__(self, other)

   Called to implement "mixed-mode" numeric arithmetic.  Should either
   return a 2-tuple containing *self* and *other* converted to a
   common numeric type, or "None" if conversion is impossible.  When
   the common type would be the type of "other", it is sufficient to
   return "None", since the interpreter will also ask the other object
   to attempt a coercion (but sometimes, if the implementation of the
   other type cannot be changed, it is useful to do the conversion to
   the other type here).  A return value of "NotImplemented" is
   equivalent to returning "None".
s   numeric-typesuZ  
Objects, values and types
*************************

*Objects* are Python's abstraction for data.  All data in a Python
program is represented by objects or by relations between objects. (In
a sense, and in conformance to Von Neumann's model of a "stored
program computer," code is also represented by objects.)

Every object has an identity, a type and a value.  An object's
*identity* never changes once it has been created; you may think of it
as the object's address in memory.  The '"is"' operator compares the
identity of two objects; the "id()" function returns an integer
representing its identity (currently implemented as its address). An
object's *type* is also unchangeable. [1] An object's type determines
the operations that the object supports (e.g., "does it have a
length?") and also defines the possible values for objects of that
type.  The "type()" function returns an object's type (which is an
object itself).  The *value* of some objects can change.  Objects
whose value can change are said to be *mutable*; objects whose value
is unchangeable once they are created are called *immutable*. (The
value of an immutable container object that contains a reference to a
mutable object can change when the latter's value is changed; however
the container is still considered immutable, because the collection of
objects it contains cannot be changed.  So, immutability is not
strictly the same as having an unchangeable value, it is more subtle.)
An object's mutability is determined by its type; for instance,
numbers, strings and tuples are immutable, while dictionaries and
lists are mutable.

Objects are never explicitly destroyed; however, when they become
unreachable they may be garbage-collected.  An implementation is
allowed to postpone garbage collection or omit it altogether --- it is
a matter of implementation quality how garbage collection is
implemented, as long as no objects are collected that are still
reachable.

**CPython implementation detail:** CPython currently uses a reference-
counting scheme with (optional) delayed detection of cyclically linked
garbage, which collects most objects as soon as they become
unreachable, but is not guaranteed to collect garbage containing
circular references.  See the documentation of the "gc" module for
information on controlling the collection of cyclic garbage. Other
implementations act differently and CPython may change. Do not depend
on immediate finalization of objects when they become unreachable (ex:
always close files).

Note that the use of the implementation's tracing or debugging
facilities may keep objects alive that would normally be collectable.
Also note that catching an exception with a '"try"..."except"'
statement may keep objects alive.

Some objects contain references to "external" resources such as open
files or windows.  It is understood that these resources are freed
when the object is garbage-collected, but since garbage collection is
not guaranteed to happen, such objects also provide an explicit way to
release the external resource, usually a "close()" method. Programs
are strongly recommended to explicitly close such objects.  The
'"try"..."finally"' statement provides a convenient way to do this.

Some objects contain references to other objects; these are called
*containers*. Examples of containers are tuples, lists and
dictionaries.  The references are part of a container's value.  In
most cases, when we talk about the value of a container, we imply the
values, not the identities of the contained objects; however, when we
talk about the mutability of a container, only the identities of the
immediately contained objects are implied.  So, if an immutable
container (like a tuple) contains a reference to a mutable object, its
value changes if that mutable object is changed.

Types affect almost all aspects of object behavior.  Even the
importance of object identity is affected in some sense: for immutable
types, operations that compute new values may actually return a
reference to any existing object with the same type and value, while
for mutable objects this is not allowed.  E.g., after "a = 1; b = 1",
"a" and "b" may or may not refer to the same object with the value
one, depending on the implementation, but after "c = []; d = []", "c"
and "d" are guaranteed to refer to two different, unique, newly
created empty lists. (Note that "c = d = []" assigns the same object
to both "c" and "d".)
t   objectsu  
Operator precedence
*******************

The following table summarizes the operator precedences in Python,
from lowest precedence (least binding) to highest precedence (most
binding). Operators in the same box have the same precedence.  Unless
the syntax is explicitly given, operators are binary.  Operators in
the same box group left to right (except for comparisons, including
tests, which all have the same precedence and chain from left to right
--- see section *Comparisons* --- and exponentiation, which groups
from right to left).

+-------------------------------------------------+---------------------------------------+
| Operator                                        | Description                           |
+=================================================+=======================================+
| "lambda"                                        | Lambda expression                     |
+-------------------------------------------------+---------------------------------------+
| "if" -- "else"                                  | Conditional expression                |
+-------------------------------------------------+---------------------------------------+
| "or"                                            | Boolean OR                            |
+-------------------------------------------------+---------------------------------------+
| "and"                                           | Boolean AND                           |
+-------------------------------------------------+---------------------------------------+
| "not" "x"                                       | Boolean NOT                           |
+-------------------------------------------------+---------------------------------------+
| "in", "not in", "is", "is not", "<", "<=", ">", | Comparisons, including membership     |
| ">=", "<>", "!=", "=="                          | tests and identity tests              |
+-------------------------------------------------+---------------------------------------+
| "|"                                             | Bitwise OR                            |
+-------------------------------------------------+---------------------------------------+
| "^"                                             | Bitwise XOR                           |
+-------------------------------------------------+---------------------------------------+
| "&"                                             | Bitwise AND                           |
+-------------------------------------------------+---------------------------------------+
| "<<", ">>"                                      | Shifts                                |
+-------------------------------------------------+---------------------------------------+
| "+", "-"                                        | Addition and subtraction              |
+-------------------------------------------------+---------------------------------------+
| "*", "/", "//", "%"                             | Multiplication, division, remainder   |
|                                                 | [8]                                   |
+-------------------------------------------------+---------------------------------------+
| "+x", "-x", "~x"                                | Positive, negative, bitwise NOT       |
+-------------------------------------------------+---------------------------------------+
| "**"                                            | Exponentiation [9]                    |
+-------------------------------------------------+---------------------------------------+
| "x[index]", "x[index:index]",                   | Subscription, slicing, call,          |
| "x(arguments...)", "x.attribute"                | attribute reference                   |
+-------------------------------------------------+---------------------------------------+
| "(expressions...)", "[expressions...]", "{key:  | Binding or tuple display, list        |
| value...}", "`expressions...`"                  | display, dictionary display, string   |
|                                                 | conversion                            |
+-------------------------------------------------+---------------------------------------+

-[ Footnotes ]-

[1] In Python 2.3 and later releases, a list comprehension "leaks"
    the control variables of each "for" it contains into the
    containing scope.  However, this behavior is deprecated, and
    relying on it will not work in Python 3.

[2] While "abs(x%y) < abs(y)" is true mathematically, for floats
    it may not be true numerically due to roundoff.  For example, and
    assuming a platform on which a Python float is an IEEE 754 double-
    precision number, in order that "-1e-100 % 1e100" have the same
    sign as "1e100", the computed result is "-1e-100 + 1e100", which
    is numerically exactly equal to "1e100".  The function
    "math.fmod()" returns a result whose sign matches the sign of the
    first argument instead, and so returns "-1e-100" in this case.
    Which approach is more appropriate depends on the application.

[3] If x is very close to an exact integer multiple of y, it's
    possible for "floor(x/y)" to be one larger than "(x-x%y)/y" due to
    rounding.  In such cases, Python returns the latter result, in
    order to preserve that "divmod(x,y)[0] * y + x % y" be very close
    to "x".

[4] While comparisons between unicode strings make sense at the
    byte level, they may be counter-intuitive to users. For example,
    the strings "u"\u00C7"" and "u"\u0043\u0327"" compare differently,
    even though they both represent the same unicode character (LATIN
    CAPITAL LETTER C WITH CEDILLA). To compare strings in a human
    recognizable way, compare using "unicodedata.normalize()".

[5] The implementation computes this efficiently, without
    constructing lists or sorting.

[6] Earlier versions of Python used lexicographic comparison of
    the sorted (key, value) lists, but this was very expensive for the
    common case of comparing for equality.  An even earlier version of
    Python compared dictionaries by identity only, but this caused
    surprises because people expected to be able to test a dictionary
    for emptiness by comparing it to "{}".

[7] Due to automatic garbage-collection, free lists, and the
    dynamic nature of descriptors, you may notice seemingly unusual
    behaviour in certain uses of the "is" operator, like those
    involving comparisons between instance methods, or constants.
    Check their documentation for more info.

[8] The "%" operator is also used for string formatting; the same
    precedence applies.

[9] The power operator "**" binds less tightly than an arithmetic
    or bitwise unary operator on its right, that is, "2**-1" is "0.5".
s   operator-summaryux  
The "pass" statement
********************

   pass_stmt ::= "pass"

"pass" is a null operation --- when it is executed, nothing happens.
It is useful as a placeholder when a statement is required
syntactically, but no code needs to be executed, for example:

   def f(arg): pass    # a function that does nothing (yet)

   class C: pass       # a class with no methods (yet)
t   passu  
The power operator
******************

The power operator binds more tightly than unary operators on its
left; it binds less tightly than unary operators on its right.  The
syntax is:

   power ::= primary ["**" u_expr]

Thus, in an unparenthesized sequence of power and unary operators, the
operators are evaluated from right to left (this does not constrain
the evaluation order for the operands): "-1**2" results in "-1".

The power operator has the same semantics as the built-in "pow()"
function, when called with two arguments: it yields its left argument
raised to the power of its right argument.  The numeric arguments are
first converted to a common type.  The result type is that of the
arguments after coercion.

With mixed operand types, the coercion rules for binary arithmetic
operators apply. For int and long int operands, the result has the
same type as the operands (after coercion) unless the second argument
is negative; in that case, all arguments are converted to float and a
float result is delivered. For example, "10**2" returns "100", but
"10**-2" returns "0.01". (This last feature was added in Python 2.2.
In Python 2.1 and before, if both arguments were of integer types and
the second argument was negative, an exception was raised).

Raising "0.0" to a negative power results in a "ZeroDivisionError".
Raising a negative number to a fractional power results in a
"ValueError".
t   poweru  
The "print" statement
*********************

   print_stmt ::= "print" ([expression ("," expression)* [","]]
                  | ">>" expression [("," expression)+ [","]])

"print" evaluates each expression in turn and writes the resulting
object to standard output (see below).  If an object is not a string,
it is first converted to a string using the rules for string
conversions.  The (resulting or original) string is then written.  A
space is written before each object is (converted and) written, unless
the output system believes it is positioned at the beginning of a
line.  This is the case (1) when no characters have yet been written
to standard output, (2) when the last character written to standard
output is a whitespace character except "' '", or (3) when the last
write operation on standard output was not a "print" statement. (In
some cases it may be functional to write an empty string to standard
output for this reason.)

Note: Objects which act like file objects but which are not the
  built-in file objects often do not properly emulate this aspect of
  the file object's behavior, so it is best not to rely on this.

A "'\n'" character is written at the end, unless the "print" statement
ends with a comma.  This is the only action if the statement contains
just the keyword "print".

Standard output is defined as the file object named "stdout" in the
built-in module "sys".  If no such object exists, or if it does not
have a "write()" method, a "RuntimeError" exception is raised.

"print" also has an extended form, defined by the second portion of
the syntax described above. This form is sometimes referred to as
""print" chevron." In this form, the first expression after the ">>"
must evaluate to a "file-like" object, specifically an object that has
a "write()" method as described above.  With this extended form, the
subsequent expressions are printed to this file object.  If the first
expression evaluates to "None", then "sys.stdout" is used as the file
for output.
t   printu  
The "raise" statement
*********************

   raise_stmt ::= "raise" [expression ["," expression ["," expression]]]

If no expressions are present, "raise" re-raises the last exception
that was active in the current scope.  If no exception is active in
the current scope, a "TypeError" exception is raised indicating that
this is an error (if running under IDLE, a "Queue.Empty" exception is
raised instead).

Otherwise, "raise" evaluates the expressions to get three objects,
using "None" as the value of omitted expressions.  The first two
objects are used to determine the *type* and *value* of the exception.

If the first object is an instance, the type of the exception is the
class of the instance, the instance itself is the value, and the
second object must be "None".

If the first object is a class, it becomes the type of the exception.
The second object is used to determine the exception value: If it is
an instance of the class, the instance becomes the exception value. If
the second object is a tuple, it is used as the argument list for the
class constructor; if it is "None", an empty argument list is used,
and any other object is treated as a single argument to the
constructor.  The instance so created by calling the constructor is
used as the exception value.

If a third object is present and not "None", it must be a traceback
object (see section *The standard type hierarchy*), and it is
substituted instead of the current location as the place where the
exception occurred.  If the third object is present and not a
traceback object or "None", a "TypeError" exception is raised.  The
three-expression form of "raise" is useful to re-raise an exception
transparently in an except clause, but "raise" with no expressions
should be preferred if the exception to be re-raised was the most
recently active exception in the current scope.

Additional information on exceptions can be found in section
*Exceptions*, and information about handling exceptions is in section
*The try statement*.
t   raiseu  
The "return" statement
**********************

   return_stmt ::= "return" [expression_list]

"return" may only occur syntactically nested in a function definition,
not within a nested class definition.

If an expression list is present, it is evaluated, else "None" is
substituted.

"return" leaves the current function call with the expression list (or
"None") as return value.

When "return" passes control out of a "try" statement with a "finally"
clause, that "finally" clause is executed before really leaving the
function.

In a generator function, the "return" statement is not allowed to
include an "expression_list".  In that context, a bare "return"
indicates that the generator is done and will cause "StopIteration" to
be raised.
t   returnu  
Emulating container types
*************************

The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to
emulate a mapping; the difference is that for a sequence, the
allowable keys should be the integers *k* for which "0 <= k < N" where
*N* is the length of the sequence, or slice objects, which define a
range of items. (For backwards compatibility, the method
"__getslice__()" (see below) can also be defined to handle simple, but
not extended slices.) It is also recommended that mappings provide the
methods "keys()", "values()", "items()", "has_key()", "get()",
"clear()", "setdefault()", "iterkeys()", "itervalues()",
"iteritems()", "pop()", "popitem()", "copy()", and "update()" behaving
similar to those for Python's standard dictionary objects.  The
"UserDict" module provides a "DictMixin" class to help create those
methods from a base set of "__getitem__()", "__setitem__()",
"__delitem__()", and "keys()". Mutable sequences should provide
methods "append()", "count()", "index()", "extend()", "insert()",
"pop()", "remove()", "reverse()" and "sort()", like Python standard
list objects.  Finally, sequence types should implement addition
(meaning concatenation) and multiplication (meaning repetition) by
defining the methods "__add__()", "__radd__()", "__iadd__()",
"__mul__()", "__rmul__()" and "__imul__()" described below; they
should not define "__coerce__()" or other numerical operators.  It is
recommended that both mappings and sequences implement the
"__contains__()" method to allow efficient use of the "in" operator;
for mappings, "in" should be equivalent of "has_key()"; for sequences,
it should search through the values.  It is further recommended that
both mappings and sequences implement the "__iter__()" method to allow
efficient iteration through the container; for mappings, "__iter__()"
should be the same as "iterkeys()"; for sequences, it should iterate
through the values.

object.__len__(self)

   Called to implement the built-in function "len()".  Should return
   the length of the object, an integer ">=" 0.  Also, an object that
   doesn't define a "__nonzero__()" method and whose "__len__()"
   method returns zero is considered to be false in a Boolean context.

object.__getitem__(self, key)

   Called to implement evaluation of "self[key]". For sequence types,
   the accepted keys should be integers and slice objects.  Note that
   the special interpretation of negative indexes (if the class wishes
   to emulate a sequence type) is up to the "__getitem__()" method. If
   *key* is of an inappropriate type, "TypeError" may be raised; if of
   a value outside the set of indexes for the sequence (after any
   special interpretation of negative values), "IndexError" should be
   raised. For mapping types, if *key* is missing (not in the
   container), "KeyError" should be raised.

   Note: "for" loops expect that an "IndexError" will be raised for
     illegal indexes to allow proper detection of the end of the
     sequence.

object.__setitem__(self, key, value)

   Called to implement assignment to "self[key]".  Same note as for
   "__getitem__()".  This should only be implemented for mappings if
   the objects support changes to the values for keys, or if new keys
   can be added, or for sequences if elements can be replaced.  The
   same exceptions should be raised for improper *key* values as for
   the "__getitem__()" method.

object.__delitem__(self, key)

   Called to implement deletion of "self[key]".  Same note as for
   "__getitem__()".  This should only be implemented for mappings if
   the objects support removal of keys, or for sequences if elements
   can be removed from the sequence.  The same exceptions should be
   raised for improper *key* values as for the "__getitem__()" method.

object.__iter__(self)

   This method is called when an iterator is required for a container.
   This method should return a new iterator object that can iterate
   over all the objects in the container.  For mappings, it should
   iterate over the keys of the container, and should also be made
   available as the method "iterkeys()".

   Iterator objects also need to implement this method; they are
   required to return themselves.  For more information on iterator
   objects, see *Iterator Types*.

object.__reversed__(self)

   Called (if present) by the "reversed()" built-in to implement
   reverse iteration.  It should return a new iterator object that
   iterates over all the objects in the container in reverse order.

   If the "__reversed__()" method is not provided, the "reversed()"
   built-in will fall back to using the sequence protocol ("__len__()"
   and "__getitem__()").  Objects that support the sequence protocol
   should only provide "__reversed__()" if they can provide an
   implementation that is more efficient than the one provided by
   "reversed()".

   New in version 2.6.

The membership test operators ("in" and "not in") are normally
implemented as an iteration through a sequence.  However, container
objects can supply the following special method with a more efficient
implementation, which also does not require the object be a sequence.

object.__contains__(self, item)

   Called to implement membership test operators.  Should return true
   if *item* is in *self*, false otherwise.  For mapping objects, this
   should consider the keys of the mapping rather than the values or
   the key-item pairs.

   For objects that don't define "__contains__()", the membership test
   first tries iteration via "__iter__()", then the old sequence
   iteration protocol via "__getitem__()", see *this section in the
   language reference*.
s   sequence-typesu  
Shifting operations
*******************

The shifting operations have lower priority than the arithmetic
operations:

   shift_expr ::= a_expr | shift_expr ( "<<" | ">>" ) a_expr

These operators accept plain or long integers as arguments.  The
arguments are converted to a common type.  They shift the first
argument to the left or right by the number of bits given by the
second argument.

A right shift by *n* bits is defined as division by "pow(2, n)".  A
left shift by *n* bits is defined as multiplication with "pow(2, n)".
Negative shift counts raise a "ValueError" exception.

Note: In the current implementation, the right-hand operand is
  required to be at most "sys.maxsize".  If the right-hand operand is
  larger than "sys.maxsize" an "OverflowError" exception is raised.
t   shiftingu
  
Slicings
********

A slicing selects a range of items in a sequence object (e.g., a
string, tuple or list).  Slicings may be used as expressions or as
targets in assignment or "del" statements.  The syntax for a slicing:

   slicing          ::= simple_slicing | extended_slicing
   simple_slicing   ::= primary "[" short_slice "]"
   extended_slicing ::= primary "[" slice_list "]"
   slice_list       ::= slice_item ("," slice_item)* [","]
   slice_item       ::= expression | proper_slice | ellipsis
   proper_slice     ::= short_slice | long_slice
   short_slice      ::= [lower_bound] ":" [upper_bound]
   long_slice       ::= short_slice ":" [stride]
   lower_bound      ::= expression
   upper_bound      ::= expression
   stride           ::= expression
   ellipsis         ::= "..."

There is ambiguity in the formal syntax here: anything that looks like
an expression list also looks like a slice list, so any subscription
can be interpreted as a slicing.  Rather than further complicating the
syntax, this is disambiguated by defining that in this case the
interpretation as a subscription takes priority over the
interpretation as a slicing (this is the case if the slice list
contains no proper slice nor ellipses).  Similarly, when the slice
list has exactly one short slice and no trailing comma, the
interpretation as a simple slicing takes priority over that as an
extended slicing.

The semantics for a simple slicing are as follows.  The primary must
evaluate to a sequence object.  The lower and upper bound expressions,
if present, must evaluate to plain integers; defaults are zero and the
"sys.maxint", respectively.  If either bound is negative, the
sequence's length is added to it.  The slicing now selects all items
with index *k* such that "i <= k < j" where *i* and *j* are the
specified lower and upper bounds.  This may be an empty sequence.  It
is not an error if *i* or *j* lie outside the range of valid indexes
(such items don't exist so they aren't selected).

The semantics for an extended slicing are as follows.  The primary
must evaluate to a mapping object, and it is indexed with a key that
is constructed from the slice list, as follows.  If the slice list
contains at least one comma, the key is a tuple containing the
conversion of the slice items; otherwise, the conversion of the lone
slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of an ellipsis slice
item is the built-in "Ellipsis" object.  The conversion of a proper
slice is a slice object (see section *The standard type hierarchy*)
whose "start", "stop" and "step" attributes are the values of the
expressions given as lower bound, upper bound and stride,
respectively, substituting "None" for missing expressions.
t   slicingsu	  
Special Attributes
******************

The implementation adds a few special read-only attributes to several
object types, where they are relevant.  Some of these are not reported
by the "dir()" built-in function.

object.__dict__

   A dictionary or other mapping object used to store an object's
   (writable) attributes.

object.__methods__

   Deprecated since version 2.2: Use the built-in function "dir()" to
   get a list of an object's attributes. This attribute is no longer
   available.

object.__members__

   Deprecated since version 2.2: Use the built-in function "dir()" to
   get a list of an object's attributes. This attribute is no longer
   available.

instance.__class__

   The class to which a class instance belongs.

class.__bases__

   The tuple of base classes of a class object.

class.__name__

   The name of the class or type.

The following attributes are only supported by *new-style class*es.

class.__mro__

   This attribute is a tuple of classes that are considered when
   looking for base classes during method resolution.

class.mro()

   This method can be overridden by a metaclass to customize the
   method resolution order for its instances.  It is called at class
   instantiation, and its result is stored in "__mro__".

class.__subclasses__()

   Each new-style class keeps a list of weak references to its
   immediate subclasses.  This method returns a list of all those
   references still alive. Example:

      >>> int.__subclasses__()
      [<type 'bool'>]

-[ Footnotes ]-

[1] Additional information on these special methods may be found
    in the Python Reference Manual (*Basic customization*).

[2] As a consequence, the list "[1, 2]" is considered equal to
    "[1.0, 2.0]", and similarly for tuples.

[3] They must have since the parser can't tell the type of the
    operands.

[4] Cased characters are those with general category property
    being one of "Lu" (Letter, uppercase), "Ll" (Letter, lowercase),
    or "Lt" (Letter, titlecase).

[5] To format only a tuple you should therefore provide a
    singleton tuple whose only element is the tuple to be formatted.

[6] The advantage of leaving the newline on is that returning an
    empty string is then an unambiguous EOF indication.  It is also
    possible (in cases where it might matter, for example, if you want
    to make an exact copy of a file while scanning its lines) to tell
    whether the last line of a file ended in a newline or not (yes
    this happens!).
t   specialattrsuY  
Special method names
********************

A class can implement certain operations that are invoked by special
syntax (such as arithmetic operations or subscripting and slicing) by
defining methods with special names. This is Python's approach to
*operator overloading*, allowing classes to define their own behavior
with respect to language operators.  For instance, if a class defines
a method named "__getitem__()", and "x" is an instance of this class,
then "x[i]" is roughly equivalent to "x.__getitem__(i)" for old-style
classes and "type(x).__getitem__(x, i)" for new-style classes.  Except
where mentioned, attempts to execute an operation raise an exception
when no appropriate method is defined (typically "AttributeError" or
"TypeError").

When implementing a class that emulates any built-in type, it is
important that the emulation only be implemented to the degree that it
makes sense for the object being modelled.  For example, some
sequences may work well with retrieval of individual elements, but
extracting a slice may not make sense.  (One example of this is the
"NodeList" interface in the W3C's Document Object Model.)


Basic customization
===================

object.__new__(cls[, ...])

   Called to create a new instance of class *cls*.  "__new__()" is a
   static method (special-cased so you need not declare it as such)
   that takes the class of which an instance was requested as its
   first argument.  The remaining arguments are those passed to the
   object constructor expression (the call to the class).  The return
   value of "__new__()" should be the new object instance (usually an
   instance of *cls*).

   Typical implementations create a new instance of the class by
   invoking the superclass's "__new__()" method using
   "super(currentclass, cls).__new__(cls[, ...])" with appropriate
   arguments and then modifying the newly-created instance as
   necessary before returning it.

   If "__new__()" returns an instance of *cls*, then the new
   instance's "__init__()" method will be invoked like
   "__init__(self[, ...])", where *self* is the new instance and the
   remaining arguments are the same as were passed to "__new__()".

   If "__new__()" does not return an instance of *cls*, then the new
   instance's "__init__()" method will not be invoked.

   "__new__()" is intended mainly to allow subclasses of immutable
   types (like int, str, or tuple) to customize instance creation.  It
   is also commonly overridden in custom metaclasses in order to
   customize class creation.

object.__init__(self[, ...])

   Called when the instance is created.  The arguments are those
   passed to the class constructor expression.  If a base class has an
   "__init__()" method, the derived class's "__init__()" method, if
   any, must explicitly call it to ensure proper initialization of the
   base class part of the instance; for example:
   "BaseClass.__init__(self, [args...])".  As a special constraint on
   constructors, no value may be returned; doing so will cause a
   "TypeError" to be raised at runtime.

object.__del__(self)

   Called when the instance is about to be destroyed.  This is also
   called a destructor.  If a base class has a "__del__()" method, the
   derived class's "__del__()" method, if any, must explicitly call it
   to ensure proper deletion of the base class part of the instance.
   Note that it is possible (though not recommended!) for the
   "__del__()" method to postpone destruction of the instance by
   creating a new reference to it.  It may then be called at a later
   time when this new reference is deleted.  It is not guaranteed that
   "__del__()" methods are called for objects that still exist when
   the interpreter exits.

   Note: "del x" doesn't directly call "x.__del__()" --- the former
     decrements the reference count for "x" by one, and the latter is
     only called when "x"'s reference count reaches zero.  Some common
     situations that may prevent the reference count of an object from
     going to zero include: circular references between objects (e.g.,
     a doubly-linked list or a tree data structure with parent and
     child pointers); a reference to the object on the stack frame of
     a function that caught an exception (the traceback stored in
     "sys.exc_traceback" keeps the stack frame alive); or a reference
     to the object on the stack frame that raised an unhandled
     exception in interactive mode (the traceback stored in
     "sys.last_traceback" keeps the stack frame alive).  The first
     situation can only be remedied by explicitly breaking the cycles;
     the latter two situations can be resolved by storing "None" in
     "sys.exc_traceback" or "sys.last_traceback".  Circular references
     which are garbage are detected when the option cycle detector is
     enabled (it's on by default), but can only be cleaned up if there
     are no Python-level "__del__()" methods involved. Refer to the
     documentation for the "gc" module for more information about how
     "__del__()" methods are handled by the cycle detector,
     particularly the description of the "garbage" value.

   Warning: Due to the precarious circumstances under which
     "__del__()" methods are invoked, exceptions that occur during
     their execution are ignored, and a warning is printed to
     "sys.stderr" instead. Also, when "__del__()" is invoked in
     response to a module being deleted (e.g., when execution of the
     program is done), other globals referenced by the "__del__()"
     method may already have been deleted or in the process of being
     torn down (e.g. the import machinery shutting down).  For this
     reason, "__del__()" methods should do the absolute minimum needed
     to maintain external invariants.  Starting with version 1.5,
     Python guarantees that globals whose name begins with a single
     underscore are deleted from their module before other globals are
     deleted; if no other references to such globals exist, this may
     help in assuring that imported modules are still available at the
     time when the "__del__()" method is called.

   See also the *-R* command-line option.

object.__repr__(self)

   Called by the "repr()" built-in function and by string conversions
   (reverse quotes) to compute the "official" string representation of
   an object.  If at all possible, this should look like a valid
   Python expression that could be used to recreate an object with the
   same value (given an appropriate environment).  If this is not
   possible, a string of the form "<...some useful description...>"
   should be returned.  The return value must be a string object. If a
   class defines "__repr__()" but not "__str__()", then "__repr__()"
   is also used when an "informal" string representation of instances
   of that class is required.

   This is typically used for debugging, so it is important that the
   representation is information-rich and unambiguous.

object.__str__(self)

   Called by the "str()" built-in function and by the "print"
   statement to compute the "informal" string representation of an
   object.  This differs from "__repr__()" in that it does not have to
   be a valid Python expression: a more convenient or concise
   representation may be used instead. The return value must be a
   string object.

object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)

   New in version 2.1.

   These are the so-called "rich comparison" methods, and are called
   for comparison operators in preference to "__cmp__()" below. The
   correspondence between operator symbols and method names is as
   follows: "x<y" calls "x.__lt__(y)", "x<=y" calls "x.__le__(y)",
   "x==y" calls "x.__eq__(y)", "x!=y" and "x<>y" call "x.__ne__(y)",
   "x>y" calls "x.__gt__(y)", and "x>=y" calls "x.__ge__(y)".

   A rich comparison method may return the singleton "NotImplemented"
   if it does not implement the operation for a given pair of
   arguments. By convention, "False" and "True" are returned for a
   successful comparison. However, these methods can return any value,
   so if the comparison operator is used in a Boolean context (e.g.,
   in the condition of an "if" statement), Python will call "bool()"
   on the value to determine if the result is true or false.

   There are no implied relationships among the comparison operators.
   The truth of "x==y" does not imply that "x!=y" is false.
   Accordingly, when defining "__eq__()", one should also define
   "__ne__()" so that the operators will behave as expected.  See the
   paragraph on "__hash__()" for some important notes on creating
   *hashable* objects which support custom comparison operations and
   are usable as dictionary keys.

   There are no swapped-argument versions of these methods (to be used
   when the left argument does not support the operation but the right
   argument does); rather, "__lt__()" and "__gt__()" are each other's
   reflection, "__le__()" and "__ge__()" are each other's reflection,
   and "__eq__()" and "__ne__()" are their own reflection.

   Arguments to rich comparison methods are never coerced.

   To automatically generate ordering operations from a single root
   operation, see "functools.total_ordering()".

object.__cmp__(self, other)

   Called by comparison operations if rich comparison (see above) is
   not defined.  Should return a negative integer if "self < other",
   zero if "self == other", a positive integer if "self > other".  If
   no "__cmp__()", "__eq__()" or "__ne__()" operation is defined,
   class instances are compared by object identity ("address").  See
   also the description of "__hash__()" for some important notes on
   creating *hashable* objects which support custom comparison
   operations and are usable as dictionary keys. (Note: the
   restriction that exceptions are not propagated by "__cmp__()" has
   been removed since Python 1.5.)

object.__rcmp__(self, other)

   Changed in version 2.1: No longer supported.

object.__hash__(self)

   Called by built-in function "hash()" and for operations on members
   of hashed collections including "set", "frozenset", and "dict".
   "__hash__()" should return an integer.  The only required property
   is that objects which compare equal have the same hash value; it is
   advised to somehow mix together (e.g. using exclusive or) the hash
   values for the components of the object that also play a part in
   comparison of objects.

   If a class does not define a "__cmp__()" or "__eq__()" method it
   should not define a "__hash__()" operation either; if it defines
   "__cmp__()" or "__eq__()" but not "__hash__()", its instances will
   not be usable in hashed collections.  If a class defines mutable
   objects and implements a "__cmp__()" or "__eq__()" method, it
   should not implement "__hash__()", since hashable collection
   implementations require that a object's hash value is immutable (if
   the object's hash value changes, it will be in the wrong hash
   bucket).

   User-defined classes have "__cmp__()" and "__hash__()" methods by
   default; with them, all objects compare unequal (except with
   themselves) and "x.__hash__()" returns a result derived from
   "id(x)".

   Classes which inherit a "__hash__()" method from a parent class but
   change the meaning of "__cmp__()" or "__eq__()" such that the hash
   value returned is no longer appropriate (e.g. by switching to a
   value-based concept of equality instead of the default identity
   based equality) can explicitly flag themselves as being unhashable
   by setting "__hash__ = None" in the class definition. Doing so
   means that not only will instances of the class raise an
   appropriate "TypeError" when a program attempts to retrieve their
   hash value, but they will also be correctly identified as
   unhashable when checking "isinstance(obj, collections.Hashable)"
   (unlike classes which define their own "__hash__()" to explicitly
   raise "TypeError").

   Changed in version 2.5: "__hash__()" may now also return a long
   integer object; the 32-bit integer is then derived from the hash of
   that object.

   Changed in version 2.6: "__hash__" may now be set to "None" to
   explicitly flag instances of a class as unhashable.

object.__nonzero__(self)

   Called to implement truth value testing and the built-in operation
   "bool()"; should return "False" or "True", or their integer
   equivalents "0" or "1".  When this method is not defined,
   "__len__()" is called, if it is defined, and the object is
   considered true if its result is nonzero. If a class defines
   neither "__len__()" nor "__nonzero__()", all its instances are
   considered true.

object.__unicode__(self)

   Called to implement "unicode()" built-in; should return a Unicode
   object. When this method is not defined, string conversion is
   attempted, and the result of string conversion is converted to
   Unicode using the system default encoding.


Customizing attribute access
============================

The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of "x.name") for
class instances.

object.__getattr__(self, name)

   Called when an attribute lookup has not found the attribute in the
   usual places (i.e. it is not an instance attribute nor is it found
   in the class tree for "self").  "name" is the attribute name. This
   method should return the (computed) attribute value or raise an
   "AttributeError" exception.

   Note that if the attribute is found through the normal mechanism,
   "__getattr__()" is not called.  (This is an intentional asymmetry
   between "__getattr__()" and "__setattr__()".) This is done both for
   efficiency reasons and because otherwise "__getattr__()" would have
   no way to access other attributes of the instance.  Note that at
   least for instance variables, you can fake total control by not
   inserting any values in the instance attribute dictionary (but
   instead inserting them in another object).  See the
   "__getattribute__()" method below for a way to actually get total
   control in new-style classes.

object.__setattr__(self, name, value)

   Called when an attribute assignment is attempted.  This is called
   instead of the normal mechanism (i.e. store the value in the
   instance dictionary).  *name* is the attribute name, *value* is the
   value to be assigned to it.

   If "__setattr__()" wants to assign to an instance attribute, it
   should not simply execute "self.name = value" --- this would cause
   a recursive call to itself.  Instead, it should insert the value in
   the dictionary of instance attributes, e.g., "self.__dict__[name] =
   value".  For new-style classes, rather than accessing the instance
   dictionary, it should call the base class method with the same
   name, for example, "object.__setattr__(self, name, value)".

object.__delattr__(self, name)

   Like "__setattr__()" but for attribute deletion instead of
   assignment.  This should only be implemented if "del obj.name" is
   meaningful for the object.


More attribute access for new-style classes
-------------------------------------------

The following methods only apply to new-style classes.

object.__getattribute__(self, name)

   Called unconditionally to implement attribute accesses for
   instances of the class. If the class also defines "__getattr__()",
   the latter will not be called unless "__getattribute__()" either
   calls it explicitly or raises an "AttributeError". This method
   should return the (computed) attribute value or raise an
   "AttributeError" exception. In order to avoid infinite recursion in
   this method, its implementation should always call the base class
   method with the same name to access any attributes it needs, for
   example, "object.__getattribute__(self, name)".

   Note: This method may still be bypassed when looking up special
     methods as the result of implicit invocation via language syntax
     or built-in functions. See *Special method lookup for new-style
     classes*.


Implementing Descriptors
------------------------

The following methods only apply when an instance of the class
containing the method (a so-called *descriptor* class) appears in an
*owner* class (the descriptor must be in either the owner's class
dictionary or in the class dictionary for one of its parents).  In the
examples below, "the attribute" refers to the attribute whose name is
the key of the property in the owner class' "__dict__".

object.__get__(self, instance, owner)

   Called to get the attribute of the owner class (class attribute
   access) or of an instance of that class (instance attribute
   access). *owner* is always the owner class, while *instance* is the
   instance that the attribute was accessed through, or "None" when
   the attribute is accessed through the *owner*.  This method should
   return the (computed) attribute value or raise an "AttributeError"
   exception.

object.__set__(self, instance, value)

   Called to set the attribute on an instance *instance* of the owner
   class to a new value, *value*.

object.__delete__(self, instance)

   Called to delete the attribute on an instance *instance* of the
   owner class.


Invoking Descriptors
--------------------

In general, a descriptor is an object attribute with "binding
behavior", one whose attribute access has been overridden by methods
in the descriptor protocol:  "__get__()", "__set__()", and
"__delete__()". If any of those methods are defined for an object, it
is said to be a descriptor.

The default behavior for attribute access is to get, set, or delete
the attribute from an object's dictionary. For instance, "a.x" has a
lookup chain starting with "a.__dict__['x']", then
"type(a).__dict__['x']", and continuing through the base classes of
"type(a)" excluding metaclasses.

However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.  Note that descriptors are only invoked for new
style objects or classes (ones that subclass "object()" or "type()").

The starting point for descriptor invocation is a binding, "a.x". How
the arguments are assembled depends on "a":

Direct Call
   The simplest and least common call is when user code directly
   invokes a descriptor method:    "x.__get__(a)".

Instance Binding
   If binding to a new-style object instance, "a.x" is transformed
   into the call: "type(a).__dict__['x'].__get__(a, type(a))".

Class Binding
   If binding to a new-style class, "A.x" is transformed into the
   call: "A.__dict__['x'].__get__(None, A)".

Super Binding
   If "a" is an instance of "super", then the binding "super(B,
   obj).m()" searches "obj.__class__.__mro__" for the base class "A"
   immediately preceding "B" and then invokes the descriptor with the
   call: "A.__dict__['m'].__get__(obj, obj.__class__)".

For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  A descriptor can define
any combination of "__get__()", "__set__()" and "__delete__()".  If it
does not define "__get__()", then accessing the attribute will return
the descriptor object itself unless there is a value in the object's
instance dictionary.  If the descriptor defines "__set__()" and/or
"__delete__()", it is a data descriptor; if it defines neither, it is
a non-data descriptor.  Normally, data descriptors define both
"__get__()" and "__set__()", while non-data descriptors have just the
"__get__()" method.  Data descriptors with "__set__()" and "__get__()"
defined always override a redefinition in an instance dictionary.  In
contrast, non-data descriptors can be overridden by instances.

Python methods (including "staticmethod()" and "classmethod()") are
implemented as non-data descriptors.  Accordingly, instances can
redefine and override methods.  This allows individual instances to
acquire behaviors that differ from other instances of the same class.

The "property()" function is implemented as a data descriptor.
Accordingly, instances cannot override the behavior of a property.


__slots__
---------

By default, instances of both old and new-style classes have a
dictionary for attribute storage.  This wastes space for objects
having very few instance variables.  The space consumption can become
acute when creating large numbers of instances.

The default can be overridden by defining *__slots__* in a new-style
class definition.  The *__slots__* declaration takes a sequence of
instance variables and reserves just enough space in each instance to
hold a value for each variable.  Space is saved because *__dict__* is
not created for each instance.

__slots__

   This class variable can be assigned a string, iterable, or sequence
   of strings with variable names used by instances.  If defined in a
   new-style class, *__slots__* reserves space for the declared
   variables and prevents the automatic creation of *__dict__* and
   *__weakref__* for each instance.

   New in version 2.2.

Notes on using *__slots__*

* When inheriting from a class without *__slots__*, the *__dict__*
  attribute of that class will always be accessible, so a *__slots__*
  definition in the subclass is meaningless.

* Without a *__dict__* variable, instances cannot be assigned new
  variables not listed in the *__slots__* definition.  Attempts to
  assign to an unlisted variable name raises "AttributeError". If
  dynamic assignment of new variables is desired, then add
  "'__dict__'" to the sequence of strings in the *__slots__*
  declaration.

  Changed in version 2.3: Previously, adding "'__dict__'" to the
  *__slots__* declaration would not enable the assignment of new
  attributes not specifically listed in the sequence of instance
  variable names.

* Without a *__weakref__* variable for each instance, classes
  defining *__slots__* do not support weak references to its
  instances. If weak reference support is needed, then add
  "'__weakref__'" to the sequence of strings in the *__slots__*
  declaration.

  Changed in version 2.3: Previously, adding "'__weakref__'" to the
  *__slots__* declaration would not enable support for weak
  references.

* *__slots__* are implemented at the class level by creating
  descriptors (*Implementing Descriptors*) for each variable name.  As
  a result, class attributes cannot be used to set default values for
  instance variables defined by *__slots__*; otherwise, the class
  attribute would overwrite the descriptor assignment.

* The action of a *__slots__* declaration is limited to the class
  where it is defined.  As a result, subclasses will have a *__dict__*
  unless they also define *__slots__* (which must only contain names
  of any *additional* slots).

* If a class defines a slot also defined in a base class, the
  instance variable defined by the base class slot is inaccessible
  (except by retrieving its descriptor directly from the base class).
  This renders the meaning of the program undefined.  In the future, a
  check may be added to prevent this.

* Nonempty *__slots__* does not work for classes derived from
  "variable-length" built-in types such as "long", "str" and "tuple".

* Any non-string iterable may be assigned to *__slots__*. Mappings
  may also be used; however, in the future, special meaning may be
  assigned to the values corresponding to each key.

* *__class__* assignment works only if both classes have the same
  *__slots__*.

  Changed in version 2.6: Previously, *__class__* assignment raised an
  error if either new or old class had *__slots__*.


Customizing class creation
==========================

By default, new-style classes are constructed using "type()". A class
definition is read into a separate namespace and the value of class
name is bound to the result of "type(name, bases, dict)".

When the class definition is read, if *__metaclass__* is defined then
the callable assigned to it will be called instead of "type()". This
allows classes or functions to be written which monitor or alter the
class creation process:

* Modifying the class dictionary prior to the class being created.

* Returning an instance of another class -- essentially performing
  the role of a factory function.

These steps will have to be performed in the metaclass's "__new__()"
method -- "type.__new__()" can then be called from this method to
create a class with different properties.  This example adds a new
element to the class dictionary before creating the class:

   class metacls(type):
       def __new__(mcs, name, bases, dict):
           dict['foo'] = 'metacls was here'
           return type.__new__(mcs, name, bases, dict)

You can of course also override other class methods (or add new
methods); for example defining a custom "__call__()" method in the
metaclass allows custom behavior when the class is called, e.g. not
always creating a new instance.

__metaclass__

   This variable can be any callable accepting arguments for "name",
   "bases", and "dict".  Upon class creation, the callable is used
   instead of the built-in "type()".

   New in version 2.2.

The appropriate metaclass is determined by the following precedence
rules:

* If "dict['__metaclass__']" exists, it is used.

* Otherwise, if there is at least one base class, its metaclass is
  used (this looks for a *__class__* attribute first and if not found,
  uses its type).

* Otherwise, if a global variable named __metaclass__ exists, it is
  used.

* Otherwise, the old-style, classic metaclass (types.ClassType) is
  used.

The potential uses for metaclasses are boundless. Some ideas that have
been explored including logging, interface checking, automatic
delegation, automatic property creation, proxies, frameworks, and
automatic resource locking/synchronization.


Customizing instance and subclass checks
========================================

New in version 2.6.

The following methods are used to override the default behavior of the
"isinstance()" and "issubclass()" built-in functions.

In particular, the metaclass "abc.ABCMeta" implements these methods in
order to allow the addition of Abstract Base Classes (ABCs) as
"virtual base classes" to any class or type (including built-in
types), including other ABCs.

class.__instancecheck__(self, instance)

   Return true if *instance* should be considered a (direct or
   indirect) instance of *class*. If defined, called to implement
   "isinstance(instance, class)".

class.__subclasscheck__(self, subclass)

   Return true if *subclass* should be considered a (direct or
   indirect) subclass of *class*.  If defined, called to implement
   "issubclass(subclass, class)".

Note that these methods are looked up on the type (metaclass) of a
class.  They cannot be defined as class methods in the actual class.
This is consistent with the lookup of special methods that are called
on instances, only in this case the instance is itself a class.

See also: **PEP 3119** - Introducing Abstract Base Classes

     Includes the specification for customizing "isinstance()" and
     "issubclass()" behavior through "__instancecheck__()" and
     "__subclasscheck__()", with motivation for this functionality in
     the context of adding Abstract Base Classes (see the "abc"
     module) to the language.


Emulating callable objects
==========================

object.__call__(self[, args...])

   Called when the instance is "called" as a function; if this method
   is defined, "x(arg1, arg2, ...)" is a shorthand for
   "x.__call__(arg1, arg2, ...)".


Emulating container types
=========================

The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to
emulate a mapping; the difference is that for a sequence, the
allowable keys should be the integers *k* for which "0 <= k < N" where
*N* is the length of the sequence, or slice objects, which define a
range of items. (For backwards compatibility, the method
"__getslice__()" (see below) can also be defined to handle simple, but
not extended slices.) It is also recommended that mappings provide the
methods "keys()", "values()", "items()", "has_key()", "get()",
"clear()", "setdefault()", "iterkeys()", "itervalues()",
"iteritems()", "pop()", "popitem()", "copy()", and "update()" behaving
similar to those for Python's standard dictionary objects.  The
"UserDict" module provides a "DictMixin" class to help create those
methods from a base set of "__getitem__()", "__setitem__()",
"__delitem__()", and "keys()". Mutable sequences should provide
methods "append()", "count()", "index()", "extend()", "insert()",
"pop()", "remove()", "reverse()" and "sort()", like Python standard
list objects.  Finally, sequence types should implement addition
(meaning concatenation) and multiplication (meaning repetition) by
defining the methods "__add__()", "__radd__()", "__iadd__()",
"__mul__()", "__rmul__()" and "__imul__()" described below; they
should not define "__coerce__()" or other numerical operators.  It is
recommended that both mappings and sequences implement the
"__contains__()" method to allow efficient use of the "in" operator;
for mappings, "in" should be equivalent of "has_key()"; for sequences,
it should search through the values.  It is further recommended that
both mappings and sequences implement the "__iter__()" method to allow
efficient iteration through the container; for mappings, "__iter__()"
should be the same as "iterkeys()"; for sequences, it should iterate
through the values.

object.__len__(self)

   Called to implement the built-in function "len()".  Should return
   the length of the object, an integer ">=" 0.  Also, an object that
   doesn't define a "__nonzero__()" method and whose "__len__()"
   method returns zero is considered to be false in a Boolean context.

object.__getitem__(self, key)

   Called to implement evaluation of "self[key]". For sequence types,
   the accepted keys should be integers and slice objects.  Note that
   the special interpretation of negative indexes (if the class wishes
   to emulate a sequence type) is up to the "__getitem__()" method. If
   *key* is of an inappropriate type, "TypeError" may be raised; if of
   a value outside the set of indexes for the sequence (after any
   special interpretation of negative values), "IndexError" should be
   raised. For mapping types, if *key* is missing (not in the
   container), "KeyError" should be raised.

   Note: "for" loops expect that an "IndexError" will be raised for
     illegal indexes to allow proper detection of the end of the
     sequence.

object.__setitem__(self, key, value)

   Called to implement assignment to "self[key]".  Same note as for
   "__getitem__()".  This should only be implemented for mappings if
   the objects support changes to the values for keys, or if new keys
   can be added, or for sequences if elements can be replaced.  The
   same exceptions should be raised for improper *key* values as for
   the "__getitem__()" method.

object.__delitem__(self, key)

   Called to implement deletion of "self[key]".  Same note as for
   "__getitem__()".  This should only be implemented for mappings if
   the objects support removal of keys, or for sequences if elements
   can be removed from the sequence.  The same exceptions should be
   raised for improper *key* values as for the "__getitem__()" method.

object.__iter__(self)

   This method is called when an iterator is required for a container.
   This method should return a new iterator object that can iterate
   over all the objects in the container.  For mappings, it should
   iterate over the keys of the container, and should also be made
   available as the method "iterkeys()".

   Iterator objects also need to implement this method; they are
   required to return themselves.  For more information on iterator
   objects, see *Iterator Types*.

object.__reversed__(self)

   Called (if present) by the "reversed()" built-in to implement
   reverse iteration.  It should return a new iterator object that
   iterates over all the objects in the container in reverse order.

   If the "__reversed__()" method is not provided, the "reversed()"
   built-in will fall back to using the sequence protocol ("__len__()"
   and "__getitem__()").  Objects that support the sequence protocol
   should only provide "__reversed__()" if they can provide an
   implementation that is more efficient than the one provided by
   "reversed()".

   New in version 2.6.

The membership test operators ("in" and "not in") are normally
implemented as an iteration through a sequence.  However, container
objects can supply the following special method with a more efficient
implementation, which also does not require the object be a sequence.

object.__contains__(self, item)

   Called to implement membership test operators.  Should return true
   if *item* is in *self*, false otherwise.  For mapping objects, this
   should consider the keys of the mapping rather than the values or
   the key-item pairs.

   For objects that don't define "__contains__()", the membership test
   first tries iteration via "__iter__()", then the old sequence
   iteration protocol via "__getitem__()", see *this section in the
   language reference*.


Additional methods for emulation of sequence types
==================================================

The following optional methods can be defined to further emulate
sequence objects.  Immutable sequences methods should at most only
define "__getslice__()"; mutable sequences might define all three
methods.

object.__getslice__(self, i, j)

   Deprecated since version 2.0: Support slice objects as parameters
   to the "__getitem__()" method. (However, built-in types in CPython
   currently still implement "__getslice__()".  Therefore, you have to
   override it in derived classes when implementing slicing.)

   Called to implement evaluation of "self[i:j]". The returned object
   should be of the same type as *self*.  Note that missing *i* or *j*
   in the slice expression are replaced by zero or "sys.maxint",
   respectively.  If negative indexes are used in the slice, the
   length of the sequence is added to that index. If the instance does
   not implement the "__len__()" method, an "AttributeError" is
   raised. No guarantee is made that indexes adjusted this way are not
   still negative.  Indexes which are greater than the length of the
   sequence are not modified. If no "__getslice__()" is found, a slice
   object is created instead, and passed to "__getitem__()" instead.

object.__setslice__(self, i, j, sequence)

   Called to implement assignment to "self[i:j]". Same notes for *i*
   and *j* as for "__getslice__()".

   This method is deprecated. If no "__setslice__()" is found, or for
   extended slicing of the form "self[i:j:k]", a slice object is
   created, and passed to "__setitem__()", instead of "__setslice__()"
   being called.

object.__delslice__(self, i, j)

   Called to implement deletion of "self[i:j]". Same notes for *i* and
   *j* as for "__getslice__()". This method is deprecated. If no
   "__delslice__()" is found, or for extended slicing of the form
   "self[i:j:k]", a slice object is created, and passed to
   "__delitem__()", instead of "__delslice__()" being called.

Notice that these methods are only invoked when a single slice with a
single colon is used, and the slice method is available.  For slice
operations involving extended slice notation, or in absence of the
slice methods, "__getitem__()", "__setitem__()" or "__delitem__()" is
called with a slice object as argument.

The following example demonstrate how to make your program or module
compatible with earlier versions of Python (assuming that methods
"__getitem__()", "__setitem__()" and "__delitem__()" support slice
objects as arguments):

   class MyClass:
       ...
       def __getitem__(self, index):
           ...
       def __setitem__(self, index, value):
           ...
       def __delitem__(self, index):
           ...

       if sys.version_info < (2, 0):
           # They won't be defined if version is at least 2.0 final

           def __getslice__(self, i, j):
               return self[max(0, i):max(0, j):]
           def __setslice__(self, i, j, seq):
               self[max(0, i):max(0, j):] = seq
           def __delslice__(self, i, j):
               del self[max(0, i):max(0, j):]
       ...

Note the calls to "max()"; these are necessary because of the handling
of negative indices before the "__*slice__()" methods are called.
When negative indexes are used, the "__*item__()" methods receive them
as provided, but the "__*slice__()" methods get a "cooked" form of the
index values.  For each negative index value, the length of the
sequence is added to the index before calling the method (which may
still result in a negative index); this is the customary handling of
negative indexes by the built-in sequence types, and the "__*item__()"
methods are expected to do this as well.  However, since they should
already be doing that, negative indexes cannot be passed in; they must
be constrained to the bounds of the sequence before being passed to
the "__*item__()" methods. Calling "max(0, i)" conveniently returns
the proper value.


Emulating numeric types
=======================

The following methods can be defined to emulate numeric objects.
Methods corresponding to operations that are not supported by the
particular kind of number implemented (e.g., bitwise operations for
non-integral numbers) should be left undefined.

object.__add__(self, other)
object.__sub__(self, other)
object.__mul__(self, other)
object.__floordiv__(self, other)
object.__mod__(self, other)
object.__divmod__(self, other)
object.__pow__(self, other[, modulo])
object.__lshift__(self, other)
object.__rshift__(self, other)
object.__and__(self, other)
object.__xor__(self, other)
object.__or__(self, other)

   These methods are called to implement the binary arithmetic
   operations ("+", "-", "*", "//", "%", "divmod()", "pow()", "**",
   "<<", ">>", "&", "^", "|").  For instance, to evaluate the
   expression "x + y", where *x* is an instance of a class that has an
   "__add__()" method, "x.__add__(y)" is called.  The "__divmod__()"
   method should be the equivalent to using "__floordiv__()" and
   "__mod__()"; it should not be related to "__truediv__()" (described
   below).  Note that "__pow__()" should be defined to accept an
   optional third argument if the ternary version of the built-in
   "pow()" function is to be supported.

   If one of those methods does not support the operation with the
   supplied arguments, it should return "NotImplemented".

object.__div__(self, other)
object.__truediv__(self, other)

   The division operator ("/") is implemented by these methods.  The
   "__truediv__()" method is used when "__future__.division" is in
   effect, otherwise "__div__()" is used.  If only one of these two
   methods is defined, the object will not support division in the
   alternate context; "TypeError" will be raised instead.

object.__radd__(self, other)
object.__rsub__(self, other)
object.__rmul__(self, other)
object.__rdiv__(self, other)
object.__rtruediv__(self, other)
object.__rfloordiv__(self, other)
object.__rmod__(self, other)
object.__rdivmod__(self, other)
object.__rpow__(self, other)
object.__rlshift__(self, other)
object.__rrshift__(self, other)
object.__rand__(self, other)
object.__rxor__(self, other)
object.__ror__(self, other)

   These methods are called to implement the binary arithmetic
   operations ("+", "-", "*", "/", "%", "divmod()", "pow()", "**",
   "<<", ">>", "&", "^", "|") with reflected (swapped) operands.
   These functions are only called if the left operand does not
   support the corresponding operation and the operands are of
   different types. [2] For instance, to evaluate the expression "x -
   y", where *y* is an instance of a class that has an "__rsub__()"
   method, "y.__rsub__(x)" is called if "x.__sub__(y)" returns
   *NotImplemented*.

   Note that ternary "pow()" will not try calling "__rpow__()" (the
   coercion rules would become too complicated).

   Note: If the right operand's type is a subclass of the left
     operand's type and that subclass provides the reflected method
     for the operation, this method will be called before the left
     operand's non-reflected method.  This behavior allows subclasses
     to override their ancestors' operations.

object.__iadd__(self, other)
object.__isub__(self, other)
object.__imul__(self, other)
object.__idiv__(self, other)
object.__itruediv__(self, other)
object.__ifloordiv__(self, other)
object.__imod__(self, other)
object.__ipow__(self, other[, modulo])
object.__ilshift__(self, other)
object.__irshift__(self, other)
object.__iand__(self, other)
object.__ixor__(self, other)
object.__ior__(self, other)

   These methods are called to implement the augmented arithmetic
   assignments ("+=", "-=", "*=", "/=", "//=", "%=", "**=", "<<=",
   ">>=", "&=", "^=", "|=").  These methods should attempt to do the
   operation in-place (modifying *self*) and return the result (which
   could be, but does not have to be, *self*).  If a specific method
   is not defined, the augmented assignment falls back to the normal
   methods.  For instance, to execute the statement "x += y", where
   *x* is an instance of a class that has an "__iadd__()" method,
   "x.__iadd__(y)" is called.  If *x* is an instance of a class that
   does not define a "__iadd__()" method, "x.__add__(y)" and
   "y.__radd__(x)" are considered, as with the evaluation of "x + y".

object.__neg__(self)
object.__pos__(self)
object.__abs__(self)
object.__invert__(self)

   Called to implement the unary arithmetic operations ("-", "+",
   "abs()" and "~").

object.__complex__(self)
object.__int__(self)
object.__long__(self)
object.__float__(self)

   Called to implement the built-in functions "complex()", "int()",
   "long()", and "float()".  Should return a value of the appropriate
   type.

object.__oct__(self)
object.__hex__(self)

   Called to implement the built-in functions "oct()" and "hex()".
   Should return a string value.

object.__index__(self)

   Called to implement "operator.index()".  Also called whenever
   Python needs an integer object (such as in slicing).  Must return
   an integer (int or long).

   New in version 2.5.

object.__coerce__(self, other)

   Called to implement "mixed-mode" numeric arithmetic.  Should either
   return a 2-tuple containing *self* and *other* converted to a
   common numeric type, or "None" if conversion is impossible.  When
   the common type would be the type of "other", it is sufficient to
   return "None", since the interpreter will also ask the other object
   to attempt a coercion (but sometimes, if the implementation of the
   other type cannot be changed, it is useful to do the conversion to
   the other type here).  A return value of "NotImplemented" is
   equivalent to returning "None".


Coercion rules
==============

This section used to document the rules for coercion.  As the language
has evolved, the coercion rules have become hard to document
precisely; documenting what one version of one particular
implementation does is undesirable.  Instead, here are some informal
guidelines regarding coercion.  In Python 3, coercion will not be
supported.

* If the left operand of a % operator is a string or Unicode object,
  no coercion takes place and the string formatting operation is
  invoked instead.

* It is no longer recommended to define a coercion operation. Mixed-
  mode operations on types that don't define coercion pass the
  original arguments to the operation.

* New-style classes (those derived from "object") never invoke the
  "__coerce__()" method in response to a binary operator; the only
  time "__coerce__()" is invoked is when the built-in function
  "coerce()" is called.

* For most intents and purposes, an operator that returns
  "NotImplemented" is treated the same as one that is not implemented
  at all.

* Below, "__op__()" and "__rop__()" are used to signify the generic
  method names corresponding to an operator; "__iop__()" is used for
  the corresponding in-place operator.  For example, for the operator
  '"+"', "__add__()" and "__radd__()" are used for the left and right
  variant of the binary operator, and "__iadd__()" for the in-place
  variant.

* For objects *x* and *y*, first "x.__op__(y)" is tried.  If this is
  not implemented or returns "NotImplemented", "y.__rop__(x)" is
  tried.  If this is also not implemented or returns "NotImplemented",
  a "TypeError" exception is raised.  But see the following exception:

* Exception to the previous item: if the left operand is an instance
  of a built-in type or a new-style class, and the right operand is an
  instance of a proper subclass of that type or class and overrides
  the base's "__rop__()" method, the right operand's "__rop__()"
  method is tried *before* the left operand's "__op__()" method.

  This is done so that a subclass can completely override binary
  operators. Otherwise, the left operand's "__op__()" method would
  always accept the right operand: when an instance of a given class
  is expected, an instance of a subclass of that class is always
  acceptable.

* When either operand type defines a coercion, this coercion is
  called before that type's "__op__()" or "__rop__()" method is
  called, but no sooner.  If the coercion returns an object of a
  different type for the operand whose coercion is invoked, part of
  the process is redone using the new object.

* When an in-place operator (like '"+="') is used, if the left
  operand implements "__iop__()", it is invoked without any coercion.
  When the operation falls back to "__op__()" and/or "__rop__()", the
  normal coercion rules apply.

* In "x + y", if *x* is a sequence that implements sequence
  concatenation, sequence concatenation is invoked.

* In "x * y", if one operand is a sequence that implements sequence
  repetition, and the other is an integer ("int" or "long"), sequence
  repetition is invoked.

* Rich comparisons (implemented by methods "__eq__()" and so on)
  never use coercion.  Three-way comparison (implemented by
  "__cmp__()") does use coercion under the same conditions as other
  binary operations use it.

* In the current implementation, the built-in numeric types "int",
  "long", "float", and "complex" do not use coercion. All these types
  implement a "__coerce__()" method, for use by the built-in
  "coerce()" function.

  Changed in version 2.7: The complex type no longer makes implicit
  calls to the "__coerce__()" method for mixed-type binary arithmetic
  operations.


With Statement Context Managers
===============================

New in version 2.5.

A *context manager* is an object that defines the runtime context to
be established when executing a "with" statement. The context manager
handles the entry into, and the exit from, the desired runtime context
for the execution of the block of code.  Context managers are normally
invoked using the "with" statement (described in section *The with
statement*), but can also be used by directly invoking their methods.

Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.

For more information on context managers, see *Context Manager Types*.

object.__enter__(self)

   Enter the runtime context related to this object. The "with"
   statement will bind this method's return value to the target(s)
   specified in the "as" clause of the statement, if any.

object.__exit__(self, exc_type, exc_value, traceback)

   Exit the runtime context related to this object. The parameters
   describe the exception that caused the context to be exited. If the
   context was exited without an exception, all three arguments will
   be "None".

   If an exception is supplied, and the method wishes to suppress the
   exception (i.e., prevent it from being propagated), it should
   return a true value. Otherwise, the exception will be processed
   normally upon exit from this method.

   Note that "__exit__()" methods should not reraise the passed-in
   exception; this is the caller's responsibility.

See also: **PEP 0343** - The "with" statement

     The specification, background, and examples for the Python "with"
     statement.


Special method lookup for old-style classes
===========================================

For old-style classes, special methods are always looked up in exactly
the same way as any other method or attribute. This is the case
regardless of whether the method is being looked up explicitly as in
"x.__getitem__(i)" or implicitly as in "x[i]".

This behaviour means that special methods may exhibit different
behaviour for different instances of a single old-style class if the
appropriate special attributes are set differently:

   >>> class C:
   ...     pass
   ...
   >>> c1 = C()
   >>> c2 = C()
   >>> c1.__len__ = lambda: 5
   >>> c2.__len__ = lambda: 9
   >>> len(c1)
   5
   >>> len(c2)
   9


Special method lookup for new-style classes
===========================================

For new-style classes, implicit invocations of special methods are
only guaranteed to work correctly if defined on an object's type, not
in the object's instance dictionary.  That behaviour is the reason why
the following code raises an exception (unlike the equivalent example
with old-style classes):

   >>> class C(object):
   ...     pass
   ...
   >>> c = C()
   >>> c.__len__ = lambda: 5
   >>> len(c)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: object of type 'C' has no len()

The rationale behind this behaviour lies with a number of special
methods such as "__hash__()" and "__repr__()" that are implemented by
all objects, including type objects. If the implicit lookup of these
methods used the conventional lookup process, they would fail when
invoked on the type object itself:

   >>> 1 .__hash__() == hash(1)
   True
   >>> int.__hash__() == hash(int)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: descriptor '__hash__' of 'int' object needs an argument

Incorrectly attempting to invoke an unbound method of a class in this
way is sometimes referred to as 'metaclass confusion', and is avoided
by bypassing the instance when looking up special methods:

   >>> type(1).__hash__(1) == hash(1)
   True
   >>> type(int).__hash__(int) == hash(int)
   True

In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses
the "__getattribute__()" method even of the object's metaclass:

   >>> class Meta(type):
   ...    def __getattribute__(*args):
   ...       print "Metaclass getattribute invoked"
   ...       return type.__getattribute__(*args)
   ...
   >>> class C(object):
   ...     __metaclass__ = Meta
   ...     def __len__(self):
   ...         return 10
   ...     def __getattribute__(*args):
   ...         print "Class getattribute invoked"
   ...         return object.__getattribute__(*args)
   ...
   >>> c = C()
   >>> c.__len__()                 # Explicit lookup via instance
   Class getattribute invoked
   10
   >>> type(c).__len__(c)          # Explicit lookup via type
   Metaclass getattribute invoked
   10
   >>> len(c)                      # Implicit lookup
   10

Bypassing the "__getattribute__()" machinery in this fashion provides
significant scope for speed optimisations within the interpreter, at
the cost of some flexibility in the handling of special methods (the
special method *must* be set on the class object itself in order to be
consistently invoked by the interpreter).

-[ Footnotes ]-

[1] It *is* possible in some cases to change an object's type,
    under certain controlled conditions. It generally isn't a good
    idea though, since it can lead to some very strange behaviour if
    it is handled incorrectly.

[2] For operands of the same type, it is assumed that if the non-
    reflected method (such as "__add__()") fails the operation is not
    supported, which is why the reflected method is not called.
t   specialnamesuB  
String Methods
**************

Below are listed the string methods which both 8-bit strings and
Unicode objects support.  Some of them are also available on
"bytearray" objects.

In addition, Python's strings support the sequence type methods
described in the *Sequence Types --- str, unicode, list, tuple,
bytearray, buffer, xrange* section. To output formatted strings use
template strings or the "%" operator described in the *String
Formatting Operations* section. Also, see the "re" module for string
functions based on regular expressions.

str.capitalize()

   Return a copy of the string with its first character capitalized
   and the rest lowercased.

   For 8-bit strings, this method is locale-dependent.

str.center(width[, fillchar])

   Return centered in a string of length *width*. Padding is done
   using the specified *fillchar* (default is a space).

   Changed in version 2.4: Support for the *fillchar* argument.

str.count(sub[, start[, end]])

   Return the number of non-overlapping occurrences of substring *sub*
   in the range [*start*, *end*].  Optional arguments *start* and
   *end* are interpreted as in slice notation.

str.decode([encoding[, errors]])

   Decodes the string using the codec registered for *encoding*.
   *encoding* defaults to the default string encoding.  *errors* may
   be given to set a different error handling scheme.  The default is
   "'strict'", meaning that encoding errors raise "UnicodeError".
   Other possible values are "'ignore'", "'replace'" and any other
   name registered via "codecs.register_error()", see section *Codec
   Base Classes*.

   New in version 2.2.

   Changed in version 2.3: Support for other error handling schemes
   added.

   Changed in version 2.7: Support for keyword arguments added.

str.encode([encoding[, errors]])

   Return an encoded version of the string.  Default encoding is the
   current default string encoding.  *errors* may be given to set a
   different error handling scheme.  The default for *errors* is
   "'strict'", meaning that encoding errors raise a "UnicodeError".
   Other possible values are "'ignore'", "'replace'",
   "'xmlcharrefreplace'", "'backslashreplace'" and any other name
   registered via "codecs.register_error()", see section *Codec Base
   Classes*. For a list of possible encodings, see section *Standard
   Encodings*.

   New in version 2.0.

   Changed in version 2.3: Support for "'xmlcharrefreplace'" and
   "'backslashreplace'" and other error handling schemes added.

   Changed in version 2.7: Support for keyword arguments added.

str.endswith(suffix[, start[, end]])

   Return "True" if the string ends with the specified *suffix*,
   otherwise return "False".  *suffix* can also be a tuple of suffixes
   to look for.  With optional *start*, test beginning at that
   position.  With optional *end*, stop comparing at that position.

   Changed in version 2.5: Accept tuples as *suffix*.

str.expandtabs([tabsize])

   Return a copy of the string where all tab characters are replaced
   by one or more spaces, depending on the current column and the
   given tab size.  Tab positions occur every *tabsize* characters
   (default is 8, giving tab positions at columns 0, 8, 16 and so on).
   To expand the string, the current column is set to zero and the
   string is examined character by character.  If the character is a
   tab ("\t"), one or more space characters are inserted in the result
   until the current column is equal to the next tab position. (The
   tab character itself is not copied.)  If the character is a newline
   ("\n") or return ("\r"), it is copied and the current column is
   reset to zero.  Any other character is copied unchanged and the
   current column is incremented by one regardless of how the
   character is represented when printed.

   >>> '01\t012\t0123\t01234'.expandtabs()
   '01      012     0123    01234'
   >>> '01\t012\t0123\t01234'.expandtabs(4)
   '01  012 0123    01234'

str.find(sub[, start[, end]])

   Return the lowest index in the string where substring *sub* is
   found, such that *sub* is contained in the slice "s[start:end]".
   Optional arguments *start* and *end* are interpreted as in slice
   notation.  Return "-1" if *sub* is not found.

   Note: The "find()" method should be used only if you need to know
     the position of *sub*.  To check if *sub* is a substring or not,
     use the "in" operator:

        >>> 'Py' in 'Python'
        True

str.format(*args, **kwargs)

   Perform a string formatting operation.  The string on which this
   method is called can contain literal text or replacement fields
   delimited by braces "{}".  Each replacement field contains either
   the numeric index of a positional argument, or the name of a
   keyword argument.  Returns a copy of the string where each
   replacement field is replaced with the string value of the
   corresponding argument.

   >>> "The sum of 1 + 2 is {0}".format(1+2)
   'The sum of 1 + 2 is 3'

   See *Format String Syntax* for a description of the various
   formatting options that can be specified in format strings.

   This method of string formatting is the new standard in Python 3,
   and should be preferred to the "%" formatting described in *String
   Formatting Operations* in new code.

   New in version 2.6.

str.index(sub[, start[, end]])

   Like "find()", but raise "ValueError" when the substring is not
   found.

str.isalnum()

   Return true if all characters in the string are alphanumeric and
   there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isalpha()

   Return true if all characters in the string are alphabetic and
   there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isdigit()

   Return true if all characters in the string are digits and there is
   at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.islower()

   Return true if all cased characters [4] in the string are lowercase
   and there is at least one cased character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isspace()

   Return true if there are only whitespace characters in the string
   and there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.istitle()

   Return true if the string is a titlecased string and there is at
   least one character, for example uppercase characters may only
   follow uncased characters and lowercase characters only cased ones.
   Return false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isupper()

   Return true if all cased characters [4] in the string are uppercase
   and there is at least one cased character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.join(iterable)

   Return a string which is the concatenation of the strings in the
   *iterable* *iterable*.  The separator between elements is the
   string providing this method.

str.ljust(width[, fillchar])

   Return the string left justified in a string of length *width*.
   Padding is done using the specified *fillchar* (default is a
   space).  The original string is returned if *width* is less than or
   equal to "len(s)".

   Changed in version 2.4: Support for the *fillchar* argument.

str.lower()

   Return a copy of the string with all the cased characters [4]
   converted to lowercase.

   For 8-bit strings, this method is locale-dependent.

str.lstrip([chars])

   Return a copy of the string with leading characters removed.  The
   *chars* argument is a string specifying the set of characters to be
   removed.  If omitted or "None", the *chars* argument defaults to
   removing whitespace.  The *chars* argument is not a prefix; rather,
   all combinations of its values are stripped:

   >>> '   spacious   '.lstrip()
   'spacious   '
   >>> 'www.example.com'.lstrip('cmowz.')
   'example.com'

   Changed in version 2.2.2: Support for the *chars* argument.

str.partition(sep)

   Split the string at the first occurrence of *sep*, and return a
   3-tuple containing the part before the separator, the separator
   itself, and the part after the separator.  If the separator is not
   found, return a 3-tuple containing the string itself, followed by
   two empty strings.

   New in version 2.5.

str.replace(old, new[, count])

   Return a copy of the string with all occurrences of substring *old*
   replaced by *new*.  If the optional argument *count* is given, only
   the first *count* occurrences are replaced.

str.rfind(sub[, start[, end]])

   Return the highest index in the string where substring *sub* is
   found, such that *sub* is contained within "s[start:end]".
   Optional arguments *start* and *end* are interpreted as in slice
   notation.  Return "-1" on failure.

str.rindex(sub[, start[, end]])

   Like "rfind()" but raises "ValueError" when the substring *sub* is
   not found.

str.rjust(width[, fillchar])

   Return the string right justified in a string of length *width*.
   Padding is done using the specified *fillchar* (default is a
   space). The original string is returned if *width* is less than or
   equal to "len(s)".

   Changed in version 2.4: Support for the *fillchar* argument.

str.rpartition(sep)

   Split the string at the last occurrence of *sep*, and return a
   3-tuple containing the part before the separator, the separator
   itself, and the part after the separator.  If the separator is not
   found, return a 3-tuple containing two empty strings, followed by
   the string itself.

   New in version 2.5.

str.rsplit([sep[, maxsplit]])

   Return a list of the words in the string, using *sep* as the
   delimiter string. If *maxsplit* is given, at most *maxsplit* splits
   are done, the *rightmost* ones.  If *sep* is not specified or
   "None", any whitespace string is a separator.  Except for splitting
   from the right, "rsplit()" behaves like "split()" which is
   described in detail below.

   New in version 2.4.

str.rstrip([chars])

   Return a copy of the string with trailing characters removed.  The
   *chars* argument is a string specifying the set of characters to be
   removed.  If omitted or "None", the *chars* argument defaults to
   removing whitespace.  The *chars* argument is not a suffix; rather,
   all combinations of its values are stripped:

   >>> '   spacious   '.rstrip()
   '   spacious'
   >>> 'mississippi'.rstrip('ipz')
   'mississ'

   Changed in version 2.2.2: Support for the *chars* argument.

str.split([sep[, maxsplit]])

   Return a list of the words in the string, using *sep* as the
   delimiter string.  If *maxsplit* is given, at most *maxsplit*
   splits are done (thus, the list will have at most "maxsplit+1"
   elements).  If *maxsplit* is not specified or "-1", then there is
   no limit on the number of splits (all possible splits are made).

   If *sep* is given, consecutive delimiters are not grouped together
   and are deemed to delimit empty strings (for example,
   "'1,,2'.split(',')" returns "['1', '', '2']").  The *sep* argument
   may consist of multiple characters (for example,
   "'1<>2<>3'.split('<>')" returns "['1', '2', '3']"). Splitting an
   empty string with a specified separator returns "['']".

   If *sep* is not specified or is "None", a different splitting
   algorithm is applied: runs of consecutive whitespace are regarded
   as a single separator, and the result will contain no empty strings
   at the start or end if the string has leading or trailing
   whitespace.  Consequently, splitting an empty string or a string
   consisting of just whitespace with a "None" separator returns "[]".

   For example, "' 1  2   3  '.split()" returns "['1', '2', '3']", and
   "'  1  2   3  '.split(None, 1)" returns "['1', '2   3  ']".

str.splitlines([keepends])

   Return a list of the lines in the string, breaking at line
   boundaries. This method uses the *universal newlines* approach to
   splitting lines. Line breaks are not included in the resulting list
   unless *keepends* is given and true.

   For example, "'ab c\n\nde fg\rkl\r\n'.splitlines()" returns "['ab
   c', '', 'de fg', 'kl']", while the same call with
   "splitlines(True)" returns "['ab c\n', '\n', 'de fg\r', 'kl\r\n']".

   Unlike "split()" when a delimiter string *sep* is given, this
   method returns an empty list for the empty string, and a terminal
   line break does not result in an extra line.

str.startswith(prefix[, start[, end]])

   Return "True" if string starts with the *prefix*, otherwise return
   "False". *prefix* can also be a tuple of prefixes to look for.
   With optional *start*, test string beginning at that position.
   With optional *end*, stop comparing string at that position.

   Changed in version 2.5: Accept tuples as *prefix*.

str.strip([chars])

   Return a copy of the string with the leading and trailing
   characters removed. The *chars* argument is a string specifying the
   set of characters to be removed. If omitted or "None", the *chars*
   argument defaults to removing whitespace. The *chars* argument is
   not a prefix or suffix; rather, all combinations of its values are
   stripped:

   >>> '   spacious   '.strip()
   'spacious'
   >>> 'www.example.com'.strip('cmowz.')
   'example'

   Changed in version 2.2.2: Support for the *chars* argument.

str.swapcase()

   Return a copy of the string with uppercase characters converted to
   lowercase and vice versa.

   For 8-bit strings, this method is locale-dependent.

str.title()

   Return a titlecased version of the string where words start with an
   uppercase character and the remaining characters are lowercase.

   The algorithm uses a simple language-independent definition of a
   word as groups of consecutive letters.  The definition works in
   many contexts but it means that apostrophes in contractions and
   possessives form word boundaries, which may not be the desired
   result:

      >>> "they're bill's friends from the UK".title()
      "They'Re Bill'S Friends From The Uk"

   A workaround for apostrophes can be constructed using regular
   expressions:

      >>> import re
      >>> def titlecase(s):
      ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
      ...                   lambda mo: mo.group(0)[0].upper() +
      ...                              mo.group(0)[1:].lower(),
      ...                   s)
      ...
      >>> titlecase("they're bill's friends.")
      "They're Bill's Friends."

   For 8-bit strings, this method is locale-dependent.

str.translate(table[, deletechars])

   Return a copy of the string where all characters occurring in the
   optional argument *deletechars* are removed, and the remaining
   characters have been mapped through the given translation table,
   which must be a string of length 256.

   You can use the "maketrans()" helper function in the "string"
   module to create a translation table. For string objects, set the
   *table* argument to "None" for translations that only delete
   characters:

   >>> 'read this short text'.translate(None, 'aeiou')
   'rd ths shrt txt'

   New in version 2.6: Support for a "None" *table* argument.

   For Unicode objects, the "translate()" method does not accept the
   optional *deletechars* argument.  Instead, it returns a copy of the
   *s* where all characters have been mapped through the given
   translation table which must be a mapping of Unicode ordinals to
   Unicode ordinals, Unicode strings or "None". Unmapped characters
   are left untouched. Characters mapped to "None" are deleted.  Note,
   a more flexible approach is to create a custom character mapping
   codec using the "codecs" module (see "encodings.cp1251" for an
   example).

str.upper()

   Return a copy of the string with all the cased characters [4]
   converted to uppercase.  Note that "str.upper().isupper()" might be
   "False" if "s" contains uncased characters or if the Unicode
   category of the resulting character(s) is not "Lu" (Letter,
   uppercase), but e.g. "Lt" (Letter, titlecase).

   For 8-bit strings, this method is locale-dependent.

str.zfill(width)

   Return the numeric string left filled with zeros in a string of
   length *width*.  A sign prefix is handled correctly.  The original
   string is returned if *width* is less than or equal to "len(s)".

   New in version 2.2.2.

The following methods are present only on unicode objects:

unicode.isnumeric()

   Return "True" if there are only numeric characters in S, "False"
   otherwise. Numeric characters include digit characters, and all
   characters that have the Unicode numeric value property, e.g.
   U+2155, VULGAR FRACTION ONE FIFTH.

unicode.isdecimal()

   Return "True" if there are only decimal characters in S, "False"
   otherwise. Decimal characters include digit characters, and all
   characters that can be used to form decimal-radix numbers, e.g.
   U+0660, ARABIC-INDIC DIGIT ZERO.
s   string-methodsuH  
String literals
***************

String literals are described by the following lexical definitions:

   stringliteral   ::= [stringprefix](shortstring | longstring)
   stringprefix    ::= "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"
                    | "b" | "B" | "br" | "Br" | "bR" | "BR"
   shortstring     ::= "'" shortstringitem* "'" | '"' shortstringitem* '"'
   longstring      ::= "'''" longstringitem* "'''"
                  | '"""' longstringitem* '"""'
   shortstringitem ::= shortstringchar | escapeseq
   longstringitem  ::= longstringchar | escapeseq
   shortstringchar ::= <any source character except "\" or newline or the quote>
   longstringchar  ::= <any source character except "\">
   escapeseq       ::= "\" <any ASCII character>

One syntactic restriction not indicated by these productions is that
whitespace is not allowed between the "stringprefix" and the rest of
the string literal. The source character set is defined by the
encoding declaration; it is ASCII if no encoding declaration is given
in the source file; see section *Encoding declarations*.

In plain English: String literals can be enclosed in matching single
quotes ("'") or double quotes (""").  They can also be enclosed in
matching groups of three single or double quotes (these are generally
referred to as *triple-quoted strings*).  The backslash ("\")
character is used to escape characters that otherwise have a special
meaning, such as newline, backslash itself, or the quote character.
String literals may optionally be prefixed with a letter "'r'" or
"'R'"; such strings are called *raw strings* and use different rules
for interpreting backslash escape sequences.  A prefix of "'u'" or
"'U'" makes the string a Unicode string.  Unicode strings use the
Unicode character set as defined by the Unicode Consortium and ISO
10646.  Some additional escape sequences, described below, are
available in Unicode strings. A prefix of "'b'" or "'B'" is ignored in
Python 2; it indicates that the literal should become a bytes literal
in Python 3 (e.g. when code is automatically converted with 2to3).  A
"'u'" or "'b'" prefix may be followed by an "'r'" prefix.

In triple-quoted strings, unescaped newlines and quotes are allowed
(and are retained), except that three unescaped quotes in a row
terminate the string.  (A "quote" is the character used to open the
string, i.e. either "'" or """.)

Unless an "'r'" or "'R'" prefix is present, escape sequences in
strings are interpreted according to rules similar to those used by
Standard C.  The recognized escape sequences are:

+-------------------+-----------------------------------+---------+
| Escape Sequence   | Meaning                           | Notes   |
+===================+===================================+=========+
| "\newline"        | Ignored                           |         |
+-------------------+-----------------------------------+---------+
| "\\"              | Backslash ("\")                   |         |
+-------------------+-----------------------------------+---------+
| "\'"              | Single quote ("'")                |         |
+-------------------+-----------------------------------+---------+
| "\""              | Double quote (""")                |         |
+-------------------+-----------------------------------+---------+
| "\a"              | ASCII Bell (BEL)                  |         |
+-------------------+-----------------------------------+---------+
| "\b"              | ASCII Backspace (BS)              |         |
+-------------------+-----------------------------------+---------+
| "\f"              | ASCII Formfeed (FF)               |         |
+-------------------+-----------------------------------+---------+
| "\n"              | ASCII Linefeed (LF)               |         |
+-------------------+-----------------------------------+---------+
| "\N{name}"        | Character named *name* in the     |         |
|                   | Unicode database (Unicode only)   |         |
+-------------------+-----------------------------------+---------+
| "\r"              | ASCII Carriage Return (CR)        |         |
+-------------------+-----------------------------------+---------+
| "\t"              | ASCII Horizontal Tab (TAB)        |         |
+-------------------+-----------------------------------+---------+
| "\uxxxx"          | Character with 16-bit hex value   | (1)     |
|                   | *xxxx* (Unicode only)             |         |
+-------------------+-----------------------------------+---------+
| "\Uxxxxxxxx"      | Character with 32-bit hex value   | (2)     |
|                   | *xxxxxxxx* (Unicode only)         |         |
+-------------------+-----------------------------------+---------+
| "\v"              | ASCII Vertical Tab (VT)           |         |
+-------------------+-----------------------------------+---------+
| "\ooo"            | Character with octal value *ooo*  | (3,5)   |
+-------------------+-----------------------------------+---------+
| "\xhh"            | Character with hex value *hh*     | (4,5)   |
+-------------------+-----------------------------------+---------+

Notes:

1. Individual code units which form parts of a surrogate pair can
   be encoded using this escape sequence.

2. Any Unicode character can be encoded this way, but characters
   outside the Basic Multilingual Plane (BMP) will be encoded using a
   surrogate pair if Python is compiled to use 16-bit code units (the
   default).

3. As in Standard C, up to three octal digits are accepted.

4. Unlike in Standard C, exactly two hex digits are required.

5. In a string literal, hexadecimal and octal escapes denote the
   byte with the given value; it is not necessary that the byte
   encodes a character in the source character set. In a Unicode
   literal, these escapes denote a Unicode character with the given
   value.

Unlike Standard C, all unrecognized escape sequences are left in the
string unchanged, i.e., *the backslash is left in the string*.  (This
behavior is useful when debugging: if an escape sequence is mistyped,
the resulting output is more easily recognized as broken.)  It is also
important to note that the escape sequences marked as "(Unicode only)"
in the table above fall into the category of unrecognized escapes for
non-Unicode string literals.

When an "'r'" or "'R'" prefix is present, a character following a
backslash is included in the string without change, and *all
backslashes are left in the string*.  For example, the string literal
"r"\n"" consists of two characters: a backslash and a lowercase "'n'".
String quotes can be escaped with a backslash, but the backslash
remains in the string; for example, "r"\""" is a valid string literal
consisting of two characters: a backslash and a double quote; "r"\""
is not a valid string literal (even a raw string cannot end in an odd
number of backslashes).  Specifically, *a raw string cannot end in a
single backslash* (since the backslash would escape the following
quote character).  Note also that a single backslash followed by a
newline is interpreted as those two characters as part of the string,
*not* as a line continuation.

When an "'r'" or "'R'" prefix is used in conjunction with a "'u'" or
"'U'" prefix, then the "\uXXXX" and "\UXXXXXXXX" escape sequences are
processed while  *all other backslashes are left in the string*. For
example, the string literal "ur"\u0062\n"" consists of three Unicode
characters: 'LATIN SMALL LETTER B', 'REVERSE SOLIDUS', and 'LATIN
SMALL LETTER N'. Backslashes can be escaped with a preceding
backslash; however, both remain in the string.  As a result, "\uXXXX"
escape sequences are only recognized when there are an odd number of
backslashes.
t   stringsu  
Subscriptions
*************

A subscription selects an item of a sequence (string, tuple or list)
or mapping (dictionary) object:

   subscription ::= primary "[" expression_list "]"

The primary must evaluate to an object of a sequence or mapping type.

If the primary is a mapping, the expression list must evaluate to an
object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that
key.  (The expression list is a tuple except if it has exactly one
item.)

If the primary is a sequence, the expression (list) must evaluate to a
plain integer.  If this value is negative, the length of the sequence
is added to it (so that, e.g., "x[-1]" selects the last item of "x".)
The resulting value must be a nonnegative integer less than the number
of items in the sequence, and the subscription selects the item whose
index is that value (counting from zero).

A string's items are characters.  A character is not a separate data
type but a string of exactly one character.
t   subscriptionsu  
Truth Value Testing
*******************

Any object can be tested for truth value, for use in an "if" or
"while" condition or as operand of the Boolean operations below. The
following values are considered false:

* "None"

* "False"

* zero of any numeric type, for example, "0", "0L", "0.0", "0j".

* any empty sequence, for example, "''", "()", "[]".

* any empty mapping, for example, "{}".

* instances of user-defined classes, if the class defines a
  "__nonzero__()" or "__len__()" method, when that method returns the
  integer zero or "bool" value "False". [1]

All other values are considered true --- so objects of many types are
always true.

Operations and built-in functions that have a Boolean result always
return "0" or "False" for false and "1" or "True" for true, unless
otherwise stated. (Important exception: the Boolean operations "or"
and "and" always return one of their operands.)
t   truthu  
The "try" statement
*******************

The "try" statement specifies exception handlers and/or cleanup code
for a group of statements:

   try_stmt  ::= try1_stmt | try2_stmt
   try1_stmt ::= "try" ":" suite
                 ("except" [expression [("as" | ",") identifier]] ":" suite)+
                 ["else" ":" suite]
                 ["finally" ":" suite]
   try2_stmt ::= "try" ":" suite
                 "finally" ":" suite

Changed in version 2.5: In previous versions of Python,
"try"..."except"..."finally" did not work. "try"..."except" had to be
nested in "try"..."finally".

The "except" clause(s) specify one or more exception handlers. When no
exception occurs in the "try" clause, no exception handler is
executed. When an exception occurs in the "try" suite, a search for an
exception handler is started.  This search inspects the except clauses
in turn until one is found that matches the exception.  An expression-
less except clause, if present, must be last; it matches any
exception.  For an except clause with an expression, that expression
is evaluated, and the clause matches the exception if the resulting
object is "compatible" with the exception.  An object is compatible
with an exception if it is the class or a base class of the exception
object, or a tuple containing an item compatible with the exception.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
[1]

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and
a search starts for the new exception in the surrounding code and on
the call stack (it is treated as if the entire "try" statement raised
the exception).

When a matching except clause is found, the exception is assigned to
the target specified in that except clause, if present, and the except
clause's suite is executed.  All except clauses must have an
executable block.  When the end of this block is reached, execution
continues normally after the entire try statement.  (This means that
if two nested handlers exist for the same exception, and the exception
occurs in the try clause of the inner handler, the outer handler will
not handle the exception.)

Before an except clause's suite is executed, details about the
exception are assigned to three variables in the "sys" module:
"sys.exc_type" receives the object identifying the exception;
"sys.exc_value" receives the exception's parameter;
"sys.exc_traceback" receives a traceback object (see section *The
standard type hierarchy*) identifying the point in the program where
the exception occurred. These details are also available through the
"sys.exc_info()" function, which returns a tuple "(exc_type,
exc_value, exc_traceback)".  Use of the corresponding variables is
deprecated in favor of this function, since their use is unsafe in a
threaded program.  As of Python 1.5, the variables are restored to
their previous values (before the call) when returning from a function
that handled an exception.

The optional "else" clause is executed if and when control flows off
the end of the "try" clause. [2] Exceptions in the "else" clause are
not handled by the preceding "except" clauses.

If "finally" is present, it specifies a 'cleanup' handler.  The "try"
clause is executed, including any "except" and "else" clauses.  If an
exception occurs in any of the clauses and is not handled, the
exception is temporarily saved. The "finally" clause is executed.  If
there is a saved exception, it is re-raised at the end of the
"finally" clause. If the "finally" clause raises another exception or
executes a "return" or "break" statement, the saved exception is
discarded:

   >>> def f():
   ...     try:
   ...         1/0
   ...     finally:
   ...         return 42
   ...
   >>> f()
   42

The exception information is not available to the program during
execution of the "finally" clause.

When a "return", "break" or "continue" statement is executed in the
"try" suite of a "try"..."finally" statement, the "finally" clause is
also executed 'on the way out.' A "continue" statement is illegal in
the "finally" clause. (The reason is a problem with the current
implementation --- this restriction may be lifted in the future).

The return value of a function is determined by the last "return"
statement executed.  Since the "finally" clause always executes, a
"return" statement executed in the "finally" clause will always be the
last one executed:

   >>> def foo():
   ...     try:
   ...         return 'try'
   ...     finally:
   ...         return 'finally'
   ...
   >>> foo()
   'finally'

Additional information on exceptions can be found in section
*Exceptions*, and information on using the "raise" statement to
generate exceptions may be found in section *The raise statement*.
t   tryu  
The standard type hierarchy
***************************

Below is a list of the types that are built into Python.  Extension
modules (written in C, Java, or other languages, depending on the
implementation) can define additional types.  Future versions of
Python may add types to the type hierarchy (e.g., rational numbers,
efficiently stored arrays of integers, etc.).

Some of the type descriptions below contain a paragraph listing
'special attributes.'  These are attributes that provide access to the
implementation and are not intended for general use.  Their definition
may change in the future.

None
   This type has a single value.  There is a single object with this
   value. This object is accessed through the built-in name "None". It
   is used to signify the absence of a value in many situations, e.g.,
   it is returned from functions that don't explicitly return
   anything. Its truth value is false.

NotImplemented
   This type has a single value.  There is a single object with this
   value. This object is accessed through the built-in name
   "NotImplemented". Numeric methods and rich comparison methods may
   return this value if they do not implement the operation for the
   operands provided.  (The interpreter will then try the reflected
   operation, or some other fallback, depending on the operator.)  Its
   truth value is true.

Ellipsis
   This type has a single value.  There is a single object with this
   value. This object is accessed through the built-in name
   "Ellipsis". It is used to indicate the presence of the "..." syntax
   in a slice.  Its truth value is true.

"numbers.Number"
   These are created by numeric literals and returned as results by
   arithmetic operators and arithmetic built-in functions.  Numeric
   objects are immutable; once created their value never changes.
   Python numbers are of course strongly related to mathematical
   numbers, but subject to the limitations of numerical representation
   in computers.

   Python distinguishes between integers, floating point numbers, and
   complex numbers:

   "numbers.Integral"
      These represent elements from the mathematical set of integers
      (positive and negative).

      There are three types of integers:

      Plain integers
         These represent numbers in the range -2147483648 through
         2147483647. (The range may be larger on machines with a
         larger natural word size, but not smaller.)  When the result
         of an operation would fall outside this range, the result is
         normally returned as a long integer (in some cases, the
         exception "OverflowError" is raised instead).  For the
         purpose of shift and mask operations, integers are assumed to
         have a binary, 2's complement notation using 32 or more bits,
         and hiding no bits from the user (i.e., all 4294967296
         different bit patterns correspond to different values).

      Long integers
         These represent numbers in an unlimited range, subject to
         available (virtual) memory only.  For the purpose of shift
         and mask operations, a binary representation is assumed, and
         negative numbers are represented in a variant of 2's
         complement which gives the illusion of an infinite string of
         sign bits extending to the left.

      Booleans
         These represent the truth values False and True.  The two
         objects representing the values "False" and "True" are the
         only Boolean objects. The Boolean type is a subtype of plain
         integers, and Boolean values behave like the values 0 and 1,
         respectively, in almost all contexts, the exception being
         that when converted to a string, the strings ""False"" or
         ""True"" are returned, respectively.

      The rules for integer representation are intended to give the
      most meaningful interpretation of shift and mask operations
      involving negative integers and the least surprises when
      switching between the plain and long integer domains.  Any
      operation, if it yields a result in the plain integer domain,
      will yield the same result in the long integer domain or when
      using mixed operands.  The switch between domains is transparent
      to the programmer.

   "numbers.Real" ("float")
      These represent machine-level double precision floating point
      numbers. You are at the mercy of the underlying machine
      architecture (and C or Java implementation) for the accepted
      range and handling of overflow. Python does not support single-
      precision floating point numbers; the savings in processor and
      memory usage that are usually the reason for using these are
      dwarfed by the overhead of using objects in Python, so there is
      no reason to complicate the language with two kinds of floating
      point numbers.

   "numbers.Complex"
      These represent complex numbers as a pair of machine-level
      double precision floating point numbers.  The same caveats apply
      as for floating point numbers. The real and imaginary parts of a
      complex number "z" can be retrieved through the read-only
      attributes "z.real" and "z.imag".

Sequences
   These represent finite ordered sets indexed by non-negative
   numbers. The built-in function "len()" returns the number of items
   of a sequence. When the length of a sequence is *n*, the index set
   contains the numbers 0, 1, ..., *n*-1.  Item *i* of sequence *a* is
   selected by "a[i]".

   Sequences also support slicing: "a[i:j]" selects all items with
   index *k* such that *i* "<=" *k* "<" *j*.  When used as an
   expression, a slice is a sequence of the same type.  This implies
   that the index set is renumbered so that it starts at 0.

   Some sequences also support "extended slicing" with a third "step"
   parameter: "a[i:j:k]" selects all items of *a* with index *x* where
   "x = i + n*k", *n* ">=" "0" and *i* "<=" *x* "<" *j*.

   Sequences are distinguished according to their mutability:

   Immutable sequences
      An object of an immutable sequence type cannot change once it is
      created.  (If the object contains references to other objects,
      these other objects may be mutable and may be changed; however,
      the collection of objects directly referenced by an immutable
      object cannot change.)

      The following types are immutable sequences:

      Strings
         The items of a string are characters.  There is no separate
         character type; a character is represented by a string of one
         item. Characters represent (at least) 8-bit bytes.  The
         built-in functions "chr()" and "ord()" convert between
         characters and nonnegative integers representing the byte
         values.  Bytes with the values 0-127 usually represent the
         corresponding ASCII values, but the interpretation of values
         is up to the program.  The string data type is also used to
         represent arrays of bytes, e.g., to hold data read from a
         file.

         (On systems whose native character set is not ASCII, strings
         may use EBCDIC in their internal representation, provided the
         functions "chr()" and "ord()" implement a mapping between
         ASCII and EBCDIC, and string comparison preserves the ASCII
         order. Or perhaps someone can propose a better rule?)

      Unicode
         The items of a Unicode object are Unicode code units.  A
         Unicode code unit is represented by a Unicode object of one
         item and can hold either a 16-bit or 32-bit value
         representing a Unicode ordinal (the maximum value for the
         ordinal is given in "sys.maxunicode", and depends on how
         Python is configured at compile time).  Surrogate pairs may
         be present in the Unicode object, and will be reported as two
         separate items.  The built-in functions "unichr()" and
         "ord()" convert between code units and nonnegative integers
         representing the Unicode ordinals as defined in the Unicode
         Standard 3.0. Conversion from and to other encodings are
         possible through the Unicode method "encode()" and the built-
         in function "unicode()".

      Tuples
         The items of a tuple are arbitrary Python objects. Tuples of
         two or more items are formed by comma-separated lists of
         expressions.  A tuple of one item (a 'singleton') can be
         formed by affixing a comma to an expression (an expression by
         itself does not create a tuple, since parentheses must be
         usable for grouping of expressions).  An empty tuple can be
         formed by an empty pair of parentheses.

   Mutable sequences
      Mutable sequences can be changed after they are created.  The
      subscription and slicing notations can be used as the target of
      assignment and "del" (delete) statements.

      There are currently two intrinsic mutable sequence types:

      Lists
         The items of a list are arbitrary Python objects.  Lists are
         formed by placing a comma-separated list of expressions in
         square brackets. (Note that there are no special cases needed
         to form lists of length 0 or 1.)

      Byte Arrays
         A bytearray object is a mutable array. They are created by
         the built-in "bytearray()" constructor.  Aside from being
         mutable (and hence unhashable), byte arrays otherwise provide
         the same interface and functionality as immutable bytes
         objects.

      The extension module "array" provides an additional example of a
      mutable sequence type.

Set types
   These represent unordered, finite sets of unique, immutable
   objects. As such, they cannot be indexed by any subscript. However,
   they can be iterated over, and the built-in function "len()"
   returns the number of items in a set. Common uses for sets are fast
   membership testing, removing duplicates from a sequence, and
   computing mathematical operations such as intersection, union,
   difference, and symmetric difference.

   For set elements, the same immutability rules apply as for
   dictionary keys. Note that numeric types obey the normal rules for
   numeric comparison: if two numbers compare equal (e.g., "1" and
   "1.0"), only one of them can be contained in a set.

   There are currently two intrinsic set types:

   Sets
      These represent a mutable set. They are created by the built-in
      "set()" constructor and can be modified afterwards by several
      methods, such as "add()".

   Frozen sets
      These represent an immutable set.  They are created by the
      built-in "frozenset()" constructor.  As a frozenset is immutable
      and *hashable*, it can be used again as an element of another
      set, or as a dictionary key.

Mappings
   These represent finite sets of objects indexed by arbitrary index
   sets. The subscript notation "a[k]" selects the item indexed by "k"
   from the mapping "a"; this can be used in expressions and as the
   target of assignments or "del" statements. The built-in function
   "len()" returns the number of items in a mapping.

   There is currently a single intrinsic mapping type:

   Dictionaries
      These represent finite sets of objects indexed by nearly
      arbitrary values.  The only types of values not acceptable as
      keys are values containing lists or dictionaries or other
      mutable types that are compared by value rather than by object
      identity, the reason being that the efficient implementation of
      dictionaries requires a key's hash value to remain constant.
      Numeric types used for keys obey the normal rules for numeric
      comparison: if two numbers compare equal (e.g., "1" and "1.0")
      then they can be used interchangeably to index the same
      dictionary entry.

      Dictionaries are mutable; they can be created by the "{...}"
      notation (see section *Dictionary displays*).

      The extension modules "dbm", "gdbm", and "bsddb" provide
      additional examples of mapping types.

Callable types
   These are the types to which the function call operation (see
   section *Calls*) can be applied:

   User-defined functions
      A user-defined function object is created by a function
      definition (see section *Function definitions*).  It should be
      called with an argument list containing the same number of items
      as the function's formal parameter list.

      Special attributes:

      +-------------------------+---------------------------------+-------------+
      | Attribute               | Meaning                         |             |
      +=========================+=================================+=============+
      | "__doc__" "func_doc"    | The function's documentation    | Writable    |
      |                         | string, or "None" if            |             |
      |                         | unavailable.                    |             |
      +-------------------------+---------------------------------+-------------+
      | "__name__" "func_name"  | The function's name.            | Writable    |
      +-------------------------+---------------------------------+-------------+
      | "__module__"            | The name of the module the      | Writable    |
      |                         | function was defined in, or     |             |
      |                         | "None" if unavailable.          |             |
      +-------------------------+---------------------------------+-------------+
      | "__defaults__"          | A tuple containing default      | Writable    |
      | "func_defaults"         | argument values for those       |             |
      |                         | arguments that have defaults,   |             |
      |                         | or "None" if no arguments have  |             |
      |                         | a default value.                |             |
      +-------------------------+---------------------------------+-------------+
      | "__code__" "func_code"  | The code object representing    | Writable    |
      |                         | the compiled function body.     |             |
      +-------------------------+---------------------------------+-------------+
      | "__globals__"           | A reference to the dictionary   | Read-only   |
      | "func_globals"          | that holds the function's       |             |
      |                         | global variables --- the global |             |
      |                         | namespace of the module in      |             |
      |                         | which the function was defined. |             |
      +-------------------------+---------------------------------+-------------+
      | "__dict__" "func_dict"  | The namespace supporting        | Writable    |
      |                         | arbitrary function attributes.  |             |
      +-------------------------+---------------------------------+-------------+
      | "__closure__"           | "None" or a tuple of cells that | Read-only   |
      | "func_closure"          | contain bindings for the        |             |
      |                         | function's free variables.      |             |
      +-------------------------+---------------------------------+-------------+

      Most of the attributes labelled "Writable" check the type of the
      assigned value.

      Changed in version 2.4: "func_name" is now writable.

      Changed in version 2.6: The double-underscore attributes
      "__closure__", "__code__", "__defaults__", and "__globals__"
      were introduced as aliases for the corresponding "func_*"
      attributes for forwards compatibility with Python 3.

      Function objects also support getting and setting arbitrary
      attributes, which can be used, for example, to attach metadata
      to functions.  Regular attribute dot-notation is used to get and
      set such attributes. *Note that the current implementation only
      supports function attributes on user-defined functions. Function
      attributes on built-in functions may be supported in the
      future.*

      Additional information about a function's definition can be
      retrieved from its code object; see the description of internal
      types below.

   User-defined methods
      A user-defined method object combines a class, a class instance
      (or "None") and any callable object (normally a user-defined
      function).

      Special read-only attributes: "im_self" is the class instance
      object, "im_func" is the function object; "im_class" is the
      class of "im_self" for bound methods or the class that asked for
      the method for unbound methods; "__doc__" is the method's
      documentation (same as "im_func.__doc__"); "__name__" is the
      method name (same as "im_func.__name__"); "__module__" is the
      name of the module the method was defined in, or "None" if
      unavailable.

      Changed in version 2.2: "im_self" used to refer to the class
      that defined the method.

      Changed in version 2.6: For Python 3 forward-compatibility,
      "im_func" is also available as "__func__", and "im_self" as
      "__self__".

      Methods also support accessing (but not setting) the arbitrary
      function attributes on the underlying function object.

      User-defined method objects may be created when getting an
      attribute of a class (perhaps via an instance of that class), if
      that attribute is a user-defined function object, an unbound
      user-defined method object, or a class method object. When the
      attribute is a user-defined method object, a new method object
      is only created if the class from which it is being retrieved is
      the same as, or a derived class of, the class stored in the
      original method object; otherwise, the original method object is
      used as it is.

      When a user-defined method object is created by retrieving a
      user-defined function object from a class, its "im_self"
      attribute is "None" and the method object is said to be unbound.
      When one is created by retrieving a user-defined function object
      from a class via one of its instances, its "im_self" attribute
      is the instance, and the method object is said to be bound. In
      either case, the new method's "im_class" attribute is the class
      from which the retrieval takes place, and its "im_func"
      attribute is the original function object.

      When a user-defined method object is created by retrieving
      another method object from a class or instance, the behaviour is
      the same as for a function object, except that the "im_func"
      attribute of the new instance is not the original method object
      but its "im_func" attribute.

      When a user-defined method object is created by retrieving a
      class method object from a class or instance, its "im_self"
      attribute is the class itself, and its "im_func" attribute is
      the function object underlying the class method.

      When an unbound user-defined method object is called, the
      underlying function ("im_func") is called, with the restriction
      that the first argument must be an instance of the proper class
      ("im_class") or of a derived class thereof.

      When a bound user-defined method object is called, the
      underlying function ("im_func") is called, inserting the class
      instance ("im_self") in front of the argument list.  For
      instance, when "C" is a class which contains a definition for a
      function "f()", and "x" is an instance of "C", calling "x.f(1)"
      is equivalent to calling "C.f(x, 1)".

      When a user-defined method object is derived from a class method
      object, the "class instance" stored in "im_self" will actually
      be the class itself, so that calling either "x.f(1)" or "C.f(1)"
      is equivalent to calling "f(C,1)" where "f" is the underlying
      function.

      Note that the transformation from function object to (unbound or
      bound) method object happens each time the attribute is
      retrieved from the class or instance. In some cases, a fruitful
      optimization is to assign the attribute to a local variable and
      call that local variable. Also notice that this transformation
      only happens for user-defined functions; other callable objects
      (and all non-callable objects) are retrieved without
      transformation.  It is also important to note that user-defined
      functions which are attributes of a class instance are not
      converted to bound methods; this *only* happens when the
      function is an attribute of the class.

   Generator functions
      A function or method which uses the "yield" statement (see
      section *The yield statement*) is called a *generator function*.
      Such a function, when called, always returns an iterator object
      which can be used to execute the body of the function:  calling
      the iterator's "next()" method will cause the function to
      execute until it provides a value using the "yield" statement.
      When the function executes a "return" statement or falls off the
      end, a "StopIteration" exception is raised and the iterator will
      have reached the end of the set of values to be returned.

   Built-in functions
      A built-in function object is a wrapper around a C function.
      Examples of built-in functions are "len()" and "math.sin()"
      ("math" is a standard built-in module). The number and type of
      the arguments are determined by the C function. Special read-
      only attributes: "__doc__" is the function's documentation
      string, or "None" if unavailable; "__name__" is the function's
      name; "__self__" is set to "None" (but see the next item);
      "__module__" is the name of the module the function was defined
      in or "None" if unavailable.

   Built-in methods
      This is really a different disguise of a built-in function, this
      time containing an object passed to the C function as an
      implicit extra argument.  An example of a built-in method is
      "alist.append()", assuming *alist* is a list object. In this
      case, the special read-only attribute "__self__" is set to the
      object denoted by *alist*.

   Class Types
      Class types, or "new-style classes," are callable.  These
      objects normally act as factories for new instances of
      themselves, but variations are possible for class types that
      override "__new__()".  The arguments of the call are passed to
      "__new__()" and, in the typical case, to "__init__()" to
      initialize the new instance.

   Classic Classes
      Class objects are described below.  When a class object is
      called, a new class instance (also described below) is created
      and returned.  This implies a call to the class's "__init__()"
      method if it has one.  Any arguments are passed on to the
      "__init__()" method.  If there is no "__init__()" method, the
      class must be called without arguments.

   Class instances
      Class instances are described below.  Class instances are
      callable only when the class has a "__call__()" method;
      "x(arguments)" is a shorthand for "x.__call__(arguments)".

Modules
   Modules are imported by the "import" statement (see section *The
   import statement*). A module object has a namespace implemented by
   a dictionary object (this is the dictionary referenced by the
   func_globals attribute of functions defined in the module).
   Attribute references are translated to lookups in this dictionary,
   e.g., "m.x" is equivalent to "m.__dict__["x"]". A module object
   does not contain the code object used to initialize the module
   (since it isn't needed once the initialization is done).

   Attribute assignment updates the module's namespace dictionary,
   e.g., "m.x = 1" is equivalent to "m.__dict__["x"] = 1".

   Special read-only attribute: "__dict__" is the module's namespace
   as a dictionary object.

   **CPython implementation detail:** Because of the way CPython
   clears module dictionaries, the module dictionary will be cleared
   when the module falls out of scope even if the dictionary still has
   live references.  To avoid this, copy the dictionary or keep the
   module around while using its dictionary directly.

   Predefined (writable) attributes: "__name__" is the module's name;
   "__doc__" is the module's documentation string, or "None" if
   unavailable; "__file__" is the pathname of the file from which the
   module was loaded, if it was loaded from a file. The "__file__"
   attribute is not present for C modules that are statically linked
   into the interpreter; for extension modules loaded dynamically from
   a shared library, it is the pathname of the shared library file.

Classes
   Both class types (new-style classes) and class objects (old-
   style/classic classes) are typically created by class definitions
   (see section *Class definitions*).  A class has a namespace
   implemented by a dictionary object. Class attribute references are
   translated to lookups in this dictionary, e.g., "C.x" is translated
   to "C.__dict__["x"]" (although for new-style classes in particular
   there are a number of hooks which allow for other means of locating
   attributes). When the attribute name is not found there, the
   attribute search continues in the base classes.  For old-style
   classes, the search is depth-first, left-to-right in the order of
   occurrence in the base class list. New-style classes use the more
   complex C3 method resolution order which behaves correctly even in
   the presence of 'diamond' inheritance structures where there are
   multiple inheritance paths leading back to a common ancestor.
   Additional details on the C3 MRO used by new-style classes can be
   found in the documentation accompanying the 2.3 release at
   https://www.python.org/download/releases/2.3/mro/.

   When a class attribute reference (for class "C", say) would yield a
   user-defined function object or an unbound user-defined method
   object whose associated class is either "C" or one of its base
   classes, it is transformed into an unbound user-defined method
   object whose "im_class" attribute is "C". When it would yield a
   class method object, it is transformed into a bound user-defined
   method object whose "im_self" attribute is "C".  When it would
   yield a static method object, it is transformed into the object
   wrapped by the static method object. See section *Implementing
   Descriptors* for another way in which attributes retrieved from a
   class may differ from those actually contained in its "__dict__"
   (note that only new-style classes support descriptors).

   Class attribute assignments update the class's dictionary, never
   the dictionary of a base class.

   A class object can be called (see above) to yield a class instance
   (see below).

   Special attributes: "__name__" is the class name; "__module__" is
   the module name in which the class was defined; "__dict__" is the
   dictionary containing the class's namespace; "__bases__" is a tuple
   (possibly empty or a singleton) containing the base classes, in the
   order of their occurrence in the base class list; "__doc__" is the
   class's documentation string, or None if undefined.

Class instances
   A class instance is created by calling a class object (see above).
   A class instance has a namespace implemented as a dictionary which
   is the first place in which attribute references are searched.
   When an attribute is not found there, and the instance's class has
   an attribute by that name, the search continues with the class
   attributes.  If a class attribute is found that is a user-defined
   function object or an unbound user-defined method object whose
   associated class is the class (call it "C") of the instance for
   which the attribute reference was initiated or one of its bases, it
   is transformed into a bound user-defined method object whose
   "im_class" attribute is "C" and whose "im_self" attribute is the
   instance. Static method and class method objects are also
   transformed, as if they had been retrieved from class "C"; see
   above under "Classes". See section *Implementing Descriptors* for
   another way in which attributes of a class retrieved via its
   instances may differ from the objects actually stored in the
   class's "__dict__". If no class attribute is found, and the
   object's class has a "__getattr__()" method, that is called to
   satisfy the lookup.

   Attribute assignments and deletions update the instance's
   dictionary, never a class's dictionary.  If the class has a
   "__setattr__()" or "__delattr__()" method, this is called instead
   of updating the instance dictionary directly.

   Class instances can pretend to be numbers, sequences, or mappings
   if they have methods with certain special names.  See section
   *Special method names*.

   Special attributes: "__dict__" is the attribute dictionary;
   "__class__" is the instance's class.

Files
   A file object represents an open file.  File objects are created by
   the "open()" built-in function, and also by "os.popen()",
   "os.fdopen()", and the "makefile()" method of socket objects (and
   perhaps by other functions or methods provided by extension
   modules).  The objects "sys.stdin", "sys.stdout" and "sys.stderr"
   are initialized to file objects corresponding to the interpreter's
   standard input, output and error streams.  See *File Objects* for
   complete documentation of file objects.

Internal types
   A few types used internally by the interpreter are exposed to the
   user. Their definitions may change with future versions of the
   interpreter, but they are mentioned here for completeness.

   Code objects
      Code objects represent *byte-compiled* executable Python code,
      or *bytecode*. The difference between a code object and a
      function object is that the function object contains an explicit
      reference to the function's globals (the module in which it was
      defined), while a code object contains no context; also the
      default argument values are stored in the function object, not
      in the code object (because they represent values calculated at
      run-time).  Unlike function objects, code objects are immutable
      and contain no references (directly or indirectly) to mutable
      objects.

      Special read-only attributes: "co_name" gives the function name;
      "co_argcount" is the number of positional arguments (including
      arguments with default values); "co_nlocals" is the number of
      local variables used by the function (including arguments);
      "co_varnames" is a tuple containing the names of the local
      variables (starting with the argument names); "co_cellvars" is a
      tuple containing the names of local variables that are
      referenced by nested functions; "co_freevars" is a tuple
      containing the names of free variables; "co_code" is a string
      representing the sequence of bytecode instructions; "co_consts"
      is a tuple containing the literals used by the bytecode;
      "co_names" is a tuple containing the names used by the bytecode;
      "co_filename" is the filename from which the code was compiled;
      "co_firstlineno" is the first line number of the function;
      "co_lnotab" is a string encoding the mapping from bytecode
      offsets to line numbers (for details see the source code of the
      interpreter); "co_stacksize" is the required stack size
      (including local variables); "co_flags" is an integer encoding a
      number of flags for the interpreter.

      The following flag bits are defined for "co_flags": bit "0x04"
      is set if the function uses the "*arguments" syntax to accept an
      arbitrary number of positional arguments; bit "0x08" is set if
      the function uses the "**keywords" syntax to accept arbitrary
      keyword arguments; bit "0x20" is set if the function is a
      generator.

      Future feature declarations ("from __future__ import division")
      also use bits in "co_flags" to indicate whether a code object
      was compiled with a particular feature enabled: bit "0x2000" is
      set if the function was compiled with future division enabled;
      bits "0x10" and "0x1000" were used in earlier versions of
      Python.

      Other bits in "co_flags" are reserved for internal use.

      If a code object represents a function, the first item in
      "co_consts" is the documentation string of the function, or
      "None" if undefined.

   Frame objects
      Frame objects represent execution frames.  They may occur in
      traceback objects (see below).

      Special read-only attributes: "f_back" is to the previous stack
      frame (towards the caller), or "None" if this is the bottom
      stack frame; "f_code" is the code object being executed in this
      frame; "f_locals" is the dictionary used to look up local
      variables; "f_globals" is used for global variables;
      "f_builtins" is used for built-in (intrinsic) names;
      "f_restricted" is a flag indicating whether the function is
      executing in restricted execution mode; "f_lasti" gives the
      precise instruction (this is an index into the bytecode string
      of the code object).

      Special writable attributes: "f_trace", if not "None", is a
      function called at the start of each source code line (this is
      used by the debugger); "f_exc_type", "f_exc_value",
      "f_exc_traceback" represent the last exception raised in the
      parent frame provided another exception was ever raised in the
      current frame (in all other cases they are None); "f_lineno" is
      the current line number of the frame --- writing to this from
      within a trace function jumps to the given line (only for the
      bottom-most frame).  A debugger can implement a Jump command
      (aka Set Next Statement) by writing to f_lineno.

   Traceback objects
      Traceback objects represent a stack trace of an exception.  A
      traceback object is created when an exception occurs.  When the
      search for an exception handler unwinds the execution stack, at
      each unwound level a traceback object is inserted in front of
      the current traceback.  When an exception handler is entered,
      the stack trace is made available to the program. (See section
      *The try statement*.) It is accessible as "sys.exc_traceback",
      and also as the third item of the tuple returned by
      "sys.exc_info()".  The latter is the preferred interface, since
      it works correctly when the program is using multiple threads.
      When the program contains no suitable handler, the stack trace
      is written (nicely formatted) to the standard error stream; if
      the interpreter is interactive, it is also made available to the
      user as "sys.last_traceback".

      Special read-only attributes: "tb_next" is the next level in the
      stack trace (towards the frame where the exception occurred), or
      "None" if there is no next level; "tb_frame" points to the
      execution frame of the current level; "tb_lineno" gives the line
      number where the exception occurred; "tb_lasti" indicates the
      precise instruction.  The line number and last instruction in
      the traceback may differ from the line number of its frame
      object if the exception occurred in a "try" statement with no
      matching except clause or with a finally clause.

   Slice objects
      Slice objects are used to represent slices when *extended slice
      syntax* is used. This is a slice using two colons, or multiple
      slices or ellipses separated by commas, e.g., "a[i:j:step]",
      "a[i:j, k:l]", or "a[..., i:j]".  They are also created by the
      built-in "slice()" function.

      Special read-only attributes: "start" is the lower bound; "stop"
      is the upper bound; "step" is the step value; each is "None" if
      omitted.  These attributes can have any type.

      Slice objects support one method:

      slice.indices(self, length)

         This method takes a single integer argument *length* and
         computes information about the extended slice that the slice
         object would describe if applied to a sequence of *length*
         items.  It returns a tuple of three integers; respectively
         these are the *start* and *stop* indices and the *step* or
         stride length of the slice. Missing or out-of-bounds indices
         are handled in a manner consistent with regular slices.

         New in version 2.3.

   Static method objects
      Static method objects provide a way of defeating the
      transformation of function objects to method objects described
      above. A static method object is a wrapper around any other
      object, usually a user-defined method object. When a static
      method object is retrieved from a class or a class instance, the
      object actually returned is the wrapped object, which is not
      subject to any further transformation. Static method objects are
      not themselves callable, although the objects they wrap usually
      are. Static method objects are created by the built-in
      "staticmethod()" constructor.

   Class method objects
      A class method object, like a static method object, is a wrapper
      around another object that alters the way in which that object
      is retrieved from classes and class instances. The behaviour of
      class method objects upon such retrieval is described above,
      under "User-defined methods". Class method objects are created
      by the built-in "classmethod()" constructor.
t   typesu  
Functions
*********

Function objects are created by function definitions.  The only
operation on a function object is to call it: "func(argument-list)".

There are really two flavors of function objects: built-in functions
and user-defined functions.  Both support the same operation (to call
the function), but the implementation is different, hence the
different object types.

See *Function definitions* for more information.
t   typesfunctionsu-  
Mapping Types --- "dict"
************************

A *mapping* object maps *hashable* values to arbitrary objects.
Mappings are mutable objects.  There is currently only one standard
mapping type, the *dictionary*.  (For other containers see the built
in "list", "set", and "tuple" classes, and the "collections" module.)

A dictionary's keys are *almost* arbitrary values.  Values that are
not *hashable*, that is, values containing lists, dictionaries or
other mutable types (that are compared by value rather than by object
identity) may not be used as keys.  Numeric types used for keys obey
the normal rules for numeric comparison: if two numbers compare equal
(such as "1" and "1.0") then they can be used interchangeably to index
the same dictionary entry.  (Note however, that since computers store
floating-point numbers as approximations it is usually unwise to use
them as dictionary keys.)

Dictionaries can be created by placing a comma-separated list of "key:
value" pairs within braces, for example: "{'jack': 4098, 'sjoerd':
4127}" or "{4098: 'jack', 4127: 'sjoerd'}", or by the "dict"
constructor.

class class dict(**kwarg)
class class dict(mapping, **kwarg)
class class dict(iterable, **kwarg)

   Return a new dictionary initialized from an optional positional
   argument and a possibly empty set of keyword arguments.

   If no positional argument is given, an empty dictionary is created.
   If a positional argument is given and it is a mapping object, a
   dictionary is created with the same key-value pairs as the mapping
   object.  Otherwise, the positional argument must be an *iterable*
   object.  Each item in the iterable must itself be an iterable with
   exactly two objects.  The first object of each item becomes a key
   in the new dictionary, and the second object the corresponding
   value.  If a key occurs more than once, the last value for that key
   becomes the corresponding value in the new dictionary.

   If keyword arguments are given, the keyword arguments and their
   values are added to the dictionary created from the positional
   argument.  If a key being added is already present, the value from
   the keyword argument replaces the value from the positional
   argument.

   To illustrate, the following examples all return a dictionary equal
   to "{"one": 1, "two": 2, "three": 3}":

      >>> a = dict(one=1, two=2, three=3)
      >>> b = {'one': 1, 'two': 2, 'three': 3}
      >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
      >>> d = dict([('two', 2), ('one', 1), ('three', 3)])
      >>> e = dict({'three': 3, 'one': 1, 'two': 2})
      >>> a == b == c == d == e
      True

   Providing keyword arguments as in the first example only works for
   keys that are valid Python identifiers.  Otherwise, any valid keys
   can be used.

   New in version 2.2.

   Changed in version 2.3: Support for building a dictionary from
   keyword arguments added.

   These are the operations that dictionaries support (and therefore,
   custom mapping types should support too):

   len(d)

      Return the number of items in the dictionary *d*.

   d[key]

      Return the item of *d* with key *key*.  Raises a "KeyError" if
      *key* is not in the map.

      New in version 2.5: If a subclass of dict defines a method
      "__missing__()", if the key *key* is not present, the "d[key]"
      operation calls that method with the key *key* as argument.  The
      "d[key]" operation then returns or raises whatever is returned
      or raised by the "__missing__(key)" call if the key is not
      present. No other operations or methods invoke "__missing__()".
      If "__missing__()" is not defined, "KeyError" is raised.
      "__missing__()" must be a method; it cannot be an instance
      variable. For an example, see "collections.defaultdict".

   d[key] = value

      Set "d[key]" to *value*.

   del d[key]

      Remove "d[key]" from *d*.  Raises a "KeyError" if *key* is not
      in the map.

   key in d

      Return "True" if *d* has a key *key*, else "False".

      New in version 2.2.

   key not in d

      Equivalent to "not key in d".

      New in version 2.2.

   iter(d)

      Return an iterator over the keys of the dictionary.  This is a
      shortcut for "iterkeys()".

   clear()

      Remove all items from the dictionary.

   copy()

      Return a shallow copy of the dictionary.

   fromkeys(seq[, value])

      Create a new dictionary with keys from *seq* and values set to
      *value*.

      "fromkeys()" is a class method that returns a new dictionary.
      *value* defaults to "None".

      New in version 2.3.

   get(key[, default])

      Return the value for *key* if *key* is in the dictionary, else
      *default*. If *default* is not given, it defaults to "None", so
      that this method never raises a "KeyError".

   has_key(key)

      Test for the presence of *key* in the dictionary.  "has_key()"
      is deprecated in favor of "key in d".

   items()

      Return a copy of the dictionary's list of "(key, value)" pairs.

      **CPython implementation detail:** Keys and values are listed in
      an arbitrary order which is non-random, varies across Python
      implementations, and depends on the dictionary's history of
      insertions and deletions.

      If "items()", "keys()", "values()", "iteritems()", "iterkeys()",
      and "itervalues()" are called with no intervening modifications
      to the dictionary, the lists will directly correspond.  This
      allows the creation of "(value, key)" pairs using "zip()":
      "pairs = zip(d.values(), d.keys())".  The same relationship
      holds for the "iterkeys()" and "itervalues()" methods: "pairs =
      zip(d.itervalues(), d.iterkeys())" provides the same value for
      "pairs". Another way to create the same list is "pairs = [(v, k)
      for (k, v) in d.iteritems()]".

   iteritems()

      Return an iterator over the dictionary's "(key, value)" pairs.
      See the note for "dict.items()".

      Using "iteritems()" while adding or deleting entries in the
      dictionary may raise a "RuntimeError" or fail to iterate over
      all entries.

      New in version 2.2.

   iterkeys()

      Return an iterator over the dictionary's keys.  See the note for
      "dict.items()".

      Using "iterkeys()" while adding or deleting entries in the
      dictionary may raise a "RuntimeError" or fail to iterate over
      all entries.

      New in version 2.2.

   itervalues()

      Return an iterator over the dictionary's values.  See the note
      for "dict.items()".

      Using "itervalues()" while adding or deleting entries in the
      dictionary may raise a "RuntimeError" or fail to iterate over
      all entries.

      New in version 2.2.

   keys()

      Return a copy of the dictionary's list of keys.  See the note
      for "dict.items()".

   pop(key[, default])

      If *key* is in the dictionary, remove it and return its value,
      else return *default*.  If *default* is not given and *key* is
      not in the dictionary, a "KeyError" is raised.

      New in version 2.3.

   popitem()

      Remove and return an arbitrary "(key, value)" pair from the
      dictionary.

      "popitem()" is useful to destructively iterate over a
      dictionary, as often used in set algorithms.  If the dictionary
      is empty, calling "popitem()" raises a "KeyError".

   setdefault(key[, default])

      If *key* is in the dictionary, return its value.  If not, insert
      *key* with a value of *default* and return *default*.  *default*
      defaults to "None".

   update([other])

      Update the dictionary with the key/value pairs from *other*,
      overwriting existing keys.  Return "None".

      "update()" accepts either another dictionary object or an
      iterable of key/value pairs (as tuples or other iterables of
      length two).  If keyword arguments are specified, the dictionary
      is then updated with those key/value pairs: "d.update(red=1,
      blue=2)".

      Changed in version 2.4: Allowed the argument to be an iterable
      of key/value pairs and allowed keyword arguments.

   values()

      Return a copy of the dictionary's list of values.  See the note
      for "dict.items()".

   viewitems()

      Return a new view of the dictionary's items ("(key, value)"
      pairs).  See below for documentation of view objects.

      New in version 2.7.

   viewkeys()

      Return a new view of the dictionary's keys.  See below for
      documentation of view objects.

      New in version 2.7.

   viewvalues()

      Return a new view of the dictionary's values.  See below for
      documentation of view objects.

      New in version 2.7.


Dictionary view objects
=======================

The objects returned by "dict.viewkeys()", "dict.viewvalues()" and
"dict.viewitems()" are *view objects*.  They provide a dynamic view on
the dictionary's entries, which means that when the dictionary
changes, the view reflects these changes.

Dictionary views can be iterated over to yield their respective data,
and support membership tests:

len(dictview)

   Return the number of entries in the dictionary.

iter(dictview)

   Return an iterator over the keys, values or items (represented as
   tuples of "(key, value)") in the dictionary.

   Keys and values are iterated over in an arbitrary order which is
   non-random, varies across Python implementations, and depends on
   the dictionary's history of insertions and deletions. If keys,
   values and items views are iterated over with no intervening
   modifications to the dictionary, the order of items will directly
   correspond.  This allows the creation of "(value, key)" pairs using
   "zip()": "pairs = zip(d.values(), d.keys())".  Another way to
   create the same list is "pairs = [(v, k) for (k, v) in d.items()]".

   Iterating views while adding or deleting entries in the dictionary
   may raise a "RuntimeError" or fail to iterate over all entries.

x in dictview

   Return "True" if *x* is in the underlying dictionary's keys, values
   or items (in the latter case, *x* should be a "(key, value)"
   tuple).

Keys views are set-like since their entries are unique and hashable.
If all values are hashable, so that (key, value) pairs are unique and
hashable, then the items view is also set-like.  (Values views are not
treated as set-like since the entries are generally not unique.)  Then
these set operations are available ("other" refers either to another
view or a set):

dictview & other

   Return the intersection of the dictview and the other object as a
   new set.

dictview | other

   Return the union of the dictview and the other object as a new set.

dictview - other

   Return the difference between the dictview and the other object
   (all elements in *dictview* that aren't in *other*) as a new set.

dictview ^ other

   Return the symmetric difference (all elements either in *dictview*
   or *other*, but not in both) of the dictview and the other object
   as a new set.

An example of dictionary view usage:

   >>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
   >>> keys = dishes.viewkeys()
   >>> values = dishes.viewvalues()

   >>> # iteration
   >>> n = 0
   >>> for val in values:
   ...     n += val
   >>> print(n)
   504

   >>> # keys and values are iterated over in the same order
   >>> list(keys)
   ['eggs', 'bacon', 'sausage', 'spam']
   >>> list(values)
   [2, 1, 1, 500]

   >>> # view objects are dynamic and reflect dict changes
   >>> del dishes['eggs']
   >>> del dishes['sausage']
   >>> list(keys)
   ['spam', 'bacon']

   >>> # set operations
   >>> keys & {'eggs', 'bacon', 'salad'}
   {'bacon'}
t   typesmappingu|  
Methods
*******

Methods are functions that are called using the attribute notation.
There are two flavors: built-in methods (such as "append()" on lists)
and class instance methods.  Built-in methods are described with the
types that support them.

The implementation adds two special read-only attributes to class
instance methods: "m.im_self" is the object on which the method
operates, and "m.im_func" is the function implementing the method.
Calling "m(arg-1, arg-2, ..., arg-n)" is completely equivalent to
calling "m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)".

Class instance methods are either *bound* or *unbound*, referring to
whether the method was accessed through an instance or a class,
respectively.  When a method is unbound, its "im_self" attribute will
be "None" and if called, an explicit "self" object must be passed as
the first argument.  In this case, "self" must be an instance of the
unbound method's class (or a subclass of that class), otherwise a
"TypeError" is raised.

Like function objects, methods objects support getting arbitrary
attributes. However, since method attributes are actually stored on
the underlying function object ("meth.im_func"), setting method
attributes on either bound or unbound methods is disallowed.
Attempting to set an attribute on a method results in an
"AttributeError" being raised.  In order to set a method attribute,
you need to explicitly set it on the underlying function object:

   >>> class C:
   ...     def method(self):
   ...         pass
   ...
   >>> c = C()
   >>> c.method.whoami = 'my name is method'  # can't set on the method
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   AttributeError: 'instancemethod' object has no attribute 'whoami'
   >>> c.method.im_func.whoami = 'my name is method'
   >>> c.method.whoami
   'my name is method'

See *The standard type hierarchy* for more information.
t   typesmethodsu  
Modules
*******

The only special operation on a module is attribute access: "m.name",
where *m* is a module and *name* accesses a name defined in *m*'s
symbol table. Module attributes can be assigned to.  (Note that the
"import" statement is not, strictly speaking, an operation on a module
object; "import foo" does not require a module object named *foo* to
exist, rather it requires an (external) *definition* for a module
named *foo* somewhere.)

A special attribute of every module is "__dict__". This is the
dictionary containing the module's symbol table. Modifying this
dictionary will actually change the module's symbol table, but direct
assignment to the "__dict__" attribute is not possible (you can write
"m.__dict__['a'] = 1", which defines "m.a" to be "1", but you can't
write "m.__dict__ = {}").  Modifying "__dict__" directly is not
recommended.

Modules built into the interpreter are written like this: "<module
'sys' (built-in)>".  If loaded from a file, they are written as
"<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>".
t   typesmodulesuP  
Sequence Types --- "str", "unicode", "list", "tuple", "bytearray", "buffer", "xrange"
*************************************************************************************

There are seven sequence types: strings, Unicode strings, lists,
tuples, bytearrays, buffers, and xrange objects.

For other containers see the built in "dict" and "set" classes, and
the "collections" module.

String literals are written in single or double quotes: "'xyzzy'",
""frobozz"".  See *String literals* for more about string literals.
Unicode strings are much like strings, but are specified in the syntax
using a preceding "'u'" character: "u'abc'", "u"def"". In addition to
the functionality described here, there are also string-specific
methods described in the *String Methods* section. Lists are
constructed with square brackets, separating items with commas: "[a,
b, c]". Tuples are constructed by the comma operator (not within
square brackets), with or without enclosing parentheses, but an empty
tuple must have the enclosing parentheses, such as "a, b, c" or "()".
A single item tuple must have a trailing comma, such as "(d,)".

Bytearray objects are created with the built-in function
"bytearray()".

Buffer objects are not directly supported by Python syntax, but can be
created by calling the built-in function "buffer()".  They don't
support concatenation or repetition.

Objects of type xrange are similar to buffers in that there is no
specific syntax to create them, but they are created using the
"xrange()" function.  They don't support slicing, concatenation or
repetition, and using "in", "not in", "min()" or "max()" on them is
inefficient.

Most sequence types support the following operations.  The "in" and
"not in" operations have the same priorities as the comparison
operations.  The "+" and "*" operations have the same priority as the
corresponding numeric operations. [3] Additional methods are provided
for *Mutable Sequence Types*.

This table lists the sequence operations sorted in ascending priority.
In the table, *s* and *t* are sequences of the same type; *n*, *i* and
*j* are integers:

+--------------------+----------------------------------+------------+
| Operation          | Result                           | Notes      |
+====================+==================================+============+
| "x in s"           | "True" if an item of *s* is      | (1)        |
|                    | equal to *x*, else "False"       |            |
+--------------------+----------------------------------+------------+
| "x not in s"       | "False" if an item of *s* is     | (1)        |
|                    | equal to *x*, else "True"        |            |
+--------------------+----------------------------------+------------+
| "s + t"            | the concatenation of *s* and *t* | (6)        |
+--------------------+----------------------------------+------------+
| "s * n, n * s"     | *n* shallow copies of *s*        | (2)        |
|                    | concatenated                     |            |
+--------------------+----------------------------------+------------+
| "s[i]"             | *i*th item of *s*, origin 0      | (3)        |
+--------------------+----------------------------------+------------+
| "s[i:j]"           | slice of *s* from *i* to *j*     | (3)(4)     |
+--------------------+----------------------------------+------------+
| "s[i:j:k]"         | slice of *s* from *i* to *j*     | (3)(5)     |
|                    | with step *k*                    |            |
+--------------------+----------------------------------+------------+
| "len(s)"           | length of *s*                    |            |
+--------------------+----------------------------------+------------+
| "min(s)"           | smallest item of *s*             |            |
+--------------------+----------------------------------+------------+
| "max(s)"           | largest item of *s*              |            |
+--------------------+----------------------------------+------------+
| "s.index(x)"       | index of the first occurrence of |            |
|                    | *x* in *s*                       |            |
+--------------------+----------------------------------+------------+
| "s.count(x)"       | total number of occurrences of   |            |
|                    | *x* in *s*                       |            |
+--------------------+----------------------------------+------------+

Sequence types also support comparisons. In particular, tuples and
lists are compared lexicographically by comparing corresponding
elements. This means that to compare equal, every element must compare
equal and the two sequences must be of the same type and have the same
length. (For full details see *Comparisons* in the language
reference.)

Notes:

1. When *s* is a string or Unicode string object the "in" and "not
   in" operations act like a substring test.  In Python versions
   before 2.3, *x* had to be a string of length 1. In Python 2.3 and
   beyond, *x* may be a string of any length.

2. Values of *n* less than "0" are treated as "0" (which yields an
   empty sequence of the same type as *s*).  Note also that the copies
   are shallow; nested structures are not copied.  This often haunts
   new Python programmers; consider:

   >>> lists = [[]] * 3
   >>> lists
   [[], [], []]
   >>> lists[0].append(3)
   >>> lists
   [[3], [3], [3]]

   What has happened is that "[[]]" is a one-element list containing
   an empty list, so all three elements of "[[]] * 3" are (pointers
   to) this single empty list.  Modifying any of the elements of
   "lists" modifies this single list. You can create a list of
   different lists this way:

   >>> lists = [[] for i in range(3)]
   >>> lists[0].append(3)
   >>> lists[1].append(5)
   >>> lists[2].append(7)
   >>> lists
   [[3], [5], [7]]

3. If *i* or *j* is negative, the index is relative to the end of
   the string: "len(s) + i" or "len(s) + j" is substituted.  But note
   that "-0" is still "0".

4. The slice of *s* from *i* to *j* is defined as the sequence of
   items with index *k* such that "i <= k < j".  If *i* or *j* is
   greater than "len(s)", use "len(s)".  If *i* is omitted or "None",
   use "0".  If *j* is omitted or "None", use "len(s)".  If *i* is
   greater than or equal to *j*, the slice is empty.

5. The slice of *s* from *i* to *j* with step *k* is defined as the
   sequence of items with index  "x = i + n*k" such that "0 <= n <
   (j-i)/k".  In other words, the indices are "i", "i+k", "i+2*k",
   "i+3*k" and so on, stopping when *j* is reached (but never
   including *j*).  If *i* or *j* is greater than "len(s)", use
   "len(s)".  If *i* or *j* are omitted or "None", they become "end"
   values (which end depends on the sign of *k*).  Note, *k* cannot be
   zero. If *k* is "None", it is treated like "1".

6. **CPython implementation detail:** If *s* and *t* are both
   strings, some Python implementations such as CPython can usually
   perform an in-place optimization for assignments of the form "s = s
   + t" or "s += t".  When applicable, this optimization makes
   quadratic run-time much less likely.  This optimization is both
   version and implementation dependent.  For performance sensitive
   code, it is preferable to use the "str.join()" method which assures
   consistent linear concatenation performance across versions and
   implementations.

   Changed in version 2.4: Formerly, string concatenation never
   occurred in-place.


String Methods
==============

Below are listed the string methods which both 8-bit strings and
Unicode objects support.  Some of them are also available on
"bytearray" objects.

In addition, Python's strings support the sequence type methods
described in the *Sequence Types --- str, unicode, list, tuple,
bytearray, buffer, xrange* section. To output formatted strings use
template strings or the "%" operator described in the *String
Formatting Operations* section. Also, see the "re" module for string
functions based on regular expressions.

str.capitalize()

   Return a copy of the string with its first character capitalized
   and the rest lowercased.

   For 8-bit strings, this method is locale-dependent.

str.center(width[, fillchar])

   Return centered in a string of length *width*. Padding is done
   using the specified *fillchar* (default is a space).

   Changed in version 2.4: Support for the *fillchar* argument.

str.count(sub[, start[, end]])

   Return the number of non-overlapping occurrences of substring *sub*
   in the range [*start*, *end*].  Optional arguments *start* and
   *end* are interpreted as in slice notation.

str.decode([encoding[, errors]])

   Decodes the string using the codec registered for *encoding*.
   *encoding* defaults to the default string encoding.  *errors* may
   be given to set a different error handling scheme.  The default is
   "'strict'", meaning that encoding errors raise "UnicodeError".
   Other possible values are "'ignore'", "'replace'" and any other
   name registered via "codecs.register_error()", see section *Codec
   Base Classes*.

   New in version 2.2.

   Changed in version 2.3: Support for other error handling schemes
   added.

   Changed in version 2.7: Support for keyword arguments added.

str.encode([encoding[, errors]])

   Return an encoded version of the string.  Default encoding is the
   current default string encoding.  *errors* may be given to set a
   different error handling scheme.  The default for *errors* is
   "'strict'", meaning that encoding errors raise a "UnicodeError".
   Other possible values are "'ignore'", "'replace'",
   "'xmlcharrefreplace'", "'backslashreplace'" and any other name
   registered via "codecs.register_error()", see section *Codec Base
   Classes*. For a list of possible encodings, see section *Standard
   Encodings*.

   New in version 2.0.

   Changed in version 2.3: Support for "'xmlcharrefreplace'" and
   "'backslashreplace'" and other error handling schemes added.

   Changed in version 2.7: Support for keyword arguments added.

str.endswith(suffix[, start[, end]])

   Return "True" if the string ends with the specified *suffix*,
   otherwise return "False".  *suffix* can also be a tuple of suffixes
   to look for.  With optional *start*, test beginning at that
   position.  With optional *end*, stop comparing at that position.

   Changed in version 2.5: Accept tuples as *suffix*.

str.expandtabs([tabsize])

   Return a copy of the string where all tab characters are replaced
   by one or more spaces, depending on the current column and the
   given tab size.  Tab positions occur every *tabsize* characters
   (default is 8, giving tab positions at columns 0, 8, 16 and so on).
   To expand the string, the current column is set to zero and the
   string is examined character by character.  If the character is a
   tab ("\t"), one or more space characters are inserted in the result
   until the current column is equal to the next tab position. (The
   tab character itself is not copied.)  If the character is a newline
   ("\n") or return ("\r"), it is copied and the current column is
   reset to zero.  Any other character is copied unchanged and the
   current column is incremented by one regardless of how the
   character is represented when printed.

   >>> '01\t012\t0123\t01234'.expandtabs()
   '01      012     0123    01234'
   >>> '01\t012\t0123\t01234'.expandtabs(4)
   '01  012 0123    01234'

str.find(sub[, start[, end]])

   Return the lowest index in the string where substring *sub* is
   found, such that *sub* is contained in the slice "s[start:end]".
   Optional arguments *start* and *end* are interpreted as in slice
   notation.  Return "-1" if *sub* is not found.

   Note: The "find()" method should be used only if you need to know
     the position of *sub*.  To check if *sub* is a substring or not,
     use the "in" operator:

        >>> 'Py' in 'Python'
        True

str.format(*args, **kwargs)

   Perform a string formatting operation.  The string on which this
   method is called can contain literal text or replacement fields
   delimited by braces "{}".  Each replacement field contains either
   the numeric index of a positional argument, or the name of a
   keyword argument.  Returns a copy of the string where each
   replacement field is replaced with the string value of the
   corresponding argument.

   >>> "The sum of 1 + 2 is {0}".format(1+2)
   'The sum of 1 + 2 is 3'

   See *Format String Syntax* for a description of the various
   formatting options that can be specified in format strings.

   This method of string formatting is the new standard in Python 3,
   and should be preferred to the "%" formatting described in *String
   Formatting Operations* in new code.

   New in version 2.6.

str.index(sub[, start[, end]])

   Like "find()", but raise "ValueError" when the substring is not
   found.

str.isalnum()

   Return true if all characters in the string are alphanumeric and
   there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isalpha()

   Return true if all characters in the string are alphabetic and
   there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isdigit()

   Return true if all characters in the string are digits and there is
   at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.islower()

   Return true if all cased characters [4] in the string are lowercase
   and there is at least one cased character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isspace()

   Return true if there are only whitespace characters in the string
   and there is at least one character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.istitle()

   Return true if the string is a titlecased string and there is at
   least one character, for example uppercase characters may only
   follow uncased characters and lowercase characters only cased ones.
   Return false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.isupper()

   Return true if all cased characters [4] in the string are uppercase
   and there is at least one cased character, false otherwise.

   For 8-bit strings, this method is locale-dependent.

str.join(iterable)

   Return a string which is the concatenation of the strings in the
   *iterable* *iterable*.  The separator between elements is the
   string providing this method.

str.ljust(width[, fillchar])

   Return the string left justified in a string of length *width*.
   Padding is done using the specified *fillchar* (default is a
   space).  The original string is returned if *width* is less than or
   equal to "len(s)".

   Changed in version 2.4: Support for the *fillchar* argument.

str.lower()

   Return a copy of the string with all the cased characters [4]
   converted to lowercase.

   For 8-bit strings, this method is locale-dependent.

str.lstrip([chars])

   Return a copy of the string with leading characters removed.  The
   *chars* argument is a string specifying the set of characters to be
   removed.  If omitted or "None", the *chars* argument defaults to
   removing whitespace.  The *chars* argument is not a prefix; rather,
   all combinations of its values are stripped:

   >>> '   spacious   '.lstrip()
   'spacious   '
   >>> 'www.example.com'.lstrip('cmowz.')
   'example.com'

   Changed in version 2.2.2: Support for the *chars* argument.

str.partition(sep)

   Split the string at the first occurrence of *sep*, and return a
   3-tuple containing the part before the separator, the separator
   itself, and the part after the separator.  If the separator is not
   found, return a 3-tuple containing the string itself, followed by
   two empty strings.

   New in version 2.5.

str.replace(old, new[, count])

   Return a copy of the string with all occurrences of substring *old*
   replaced by *new*.  If the optional argument *count* is given, only
   the first *count* occurrences are replaced.

str.rfind(sub[, start[, end]])

   Return the highest index in the string where substring *sub* is
   found, such that *sub* is contained within "s[start:end]".
   Optional arguments *start* and *end* are interpreted as in slice
   notation.  Return "-1" on failure.

str.rindex(sub[, start[, end]])

   Like "rfind()" but raises "ValueError" when the substring *sub* is
   not found.

str.rjust(width[, fillchar])

   Return the string right justified in a string of length *width*.
   Padding is done using the specified *fillchar* (default is a
   space). The original string is returned if *width* is less than or
   equal to "len(s)".

   Changed in version 2.4: Support for the *fillchar* argument.

str.rpartition(sep)

   Split the string at the last occurrence of *sep*, and return a
   3-tuple containing the part before the separator, the separator
   itself, and the part after the separator.  If the separator is not
   found, return a 3-tuple containing two empty strings, followed by
   the string itself.

   New in version 2.5.

str.rsplit([sep[, maxsplit]])

   Return a list of the words in the string, using *sep* as the
   delimiter string. If *maxsplit* is given, at most *maxsplit* splits
   are done, the *rightmost* ones.  If *sep* is not specified or
   "None", any whitespace string is a separator.  Except for splitting
   from the right, "rsplit()" behaves like "split()" which is
   described in detail below.

   New in version 2.4.

str.rstrip([chars])

   Return a copy of the string with trailing characters removed.  The
   *chars* argument is a string specifying the set of characters to be
   removed.  If omitted or "None", the *chars* argument defaults to
   removing whitespace.  The *chars* argument is not a suffix; rather,
   all combinations of its values are stripped:

   >>> '   spacious   '.rstrip()
   '   spacious'
   >>> 'mississippi'.rstrip('ipz')
   'mississ'

   Changed in version 2.2.2: Support for the *chars* argument.

str.split([sep[, maxsplit]])

   Return a list of the words in the string, using *sep* as the
   delimiter string.  If *maxsplit* is given, at most *maxsplit*
   splits are done (thus, the list will have at most "maxsplit+1"
   elements).  If *maxsplit* is not specified or "-1", then there is
   no limit on the number of splits (all possible splits are made).

   If *sep* is given, consecutive delimiters are not grouped together
   and are deemed to delimit empty strings (for example,
   "'1,,2'.split(',')" returns "['1', '', '2']").  The *sep* argument
   may consist of multiple characters (for example,
   "'1<>2<>3'.split('<>')" returns "['1', '2', '3']"). Splitting an
   empty string with a specified separator returns "['']".

   If *sep* is not specified or is "None", a different splitting
   algorithm is applied: runs of consecutive whitespace are regarded
   as a single separator, and the result will contain no empty strings
   at the start or end if the string has leading or trailing
   whitespace.  Consequently, splitting an empty string or a string
   consisting of just whitespace with a "None" separator returns "[]".

   For example, "' 1  2   3  '.split()" returns "['1', '2', '3']", and
   "'  1  2   3  '.split(None, 1)" returns "['1', '2   3  ']".

str.splitlines([keepends])

   Return a list of the lines in the string, breaking at line
   boundaries. This method uses the *universal newlines* approach to
   splitting lines. Line breaks are not included in the resulting list
   unless *keepends* is given and true.

   For example, "'ab c\n\nde fg\rkl\r\n'.splitlines()" returns "['ab
   c', '', 'de fg', 'kl']", while the same call with
   "splitlines(True)" returns "['ab c\n', '\n', 'de fg\r', 'kl\r\n']".

   Unlike "split()" when a delimiter string *sep* is given, this
   method returns an empty list for the empty string, and a terminal
   line break does not result in an extra line.

str.startswith(prefix[, start[, end]])

   Return "True" if string starts with the *prefix*, otherwise return
   "False". *prefix* can also be a tuple of prefixes to look for.
   With optional *start*, test string beginning at that position.
   With optional *end*, stop comparing string at that position.

   Changed in version 2.5: Accept tuples as *prefix*.

str.strip([chars])

   Return a copy of the string with the leading and trailing
   characters removed. The *chars* argument is a string specifying the
   set of characters to be removed. If omitted or "None", the *chars*
   argument defaults to removing whitespace. The *chars* argument is
   not a prefix or suffix; rather, all combinations of its values are
   stripped:

   >>> '   spacious   '.strip()
   'spacious'
   >>> 'www.example.com'.strip('cmowz.')
   'example'

   Changed in version 2.2.2: Support for the *chars* argument.

str.swapcase()

   Return a copy of the string with uppercase characters converted to
   lowercase and vice versa.

   For 8-bit strings, this method is locale-dependent.

str.title()

   Return a titlecased version of the string where words start with an
   uppercase character and the remaining characters are lowercase.

   The algorithm uses a simple language-independent definition of a
   word as groups of consecutive letters.  The definition works in
   many contexts but it means that apostrophes in contractions and
   possessives form word boundaries, which may not be the desired
   result:

      >>> "they're bill's friends from the UK".title()
      "They'Re Bill'S Friends From The Uk"

   A workaround for apostrophes can be constructed using regular
   expressions:

      >>> import re
      >>> def titlecase(s):
      ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
      ...                   lambda mo: mo.group(0)[0].upper() +
      ...                              mo.group(0)[1:].lower(),
      ...                   s)
      ...
      >>> titlecase("they're bill's friends.")
      "They're Bill's Friends."

   For 8-bit strings, this method is locale-dependent.

str.translate(table[, deletechars])

   Return a copy of the string where all characters occurring in the
   optional argument *deletechars* are removed, and the remaining
   characters have been mapped through the given translation table,
   which must be a string of length 256.

   You can use the "maketrans()" helper function in the "string"
   module to create a translation table. For string objects, set the
   *table* argument to "None" for translations that only delete
   characters:

   >>> 'read this short text'.translate(None, 'aeiou')
   'rd ths shrt txt'

   New in version 2.6: Support for a "None" *table* argument.

   For Unicode objects, the "translate()" method does not accept the
   optional *deletechars* argument.  Instead, it returns a copy of the
   *s* where all characters have been mapped through the given
   translation table which must be a mapping of Unicode ordinals to
   Unicode ordinals, Unicode strings or "None". Unmapped characters
   are left untouched. Characters mapped to "None" are deleted.  Note,
   a more flexible approach is to create a custom character mapping
   codec using the "codecs" module (see "encodings.cp1251" for an
   example).

str.upper()

   Return a copy of the string with all the cased characters [4]
   converted to uppercase.  Note that "str.upper().isupper()" might be
   "False" if "s" contains uncased characters or if the Unicode
   category of the resulting character(s) is not "Lu" (Letter,
   uppercase), but e.g. "Lt" (Letter, titlecase).

   For 8-bit strings, this method is locale-dependent.

str.zfill(width)

   Return the numeric string left filled with zeros in a string of
   length *width*.  A sign prefix is handled correctly.  The original
   string is returned if *width* is less than or equal to "len(s)".

   New in version 2.2.2.

The following methods are present only on unicode objects:

unicode.isnumeric()

   Return "True" if there are only numeric characters in S, "False"
   otherwise. Numeric characters include digit characters, and all
   characters that have the Unicode numeric value property, e.g.
   U+2155, VULGAR FRACTION ONE FIFTH.

unicode.isdecimal()

   Return "True" if there are only decimal characters in S, "False"
   otherwise. Decimal characters include digit characters, and all
   characters that can be used to form decimal-radix numbers, e.g.
   U+0660, ARABIC-INDIC DIGIT ZERO.


String Formatting Operations
============================

String and Unicode objects have one unique built-in operation: the "%"
operator (modulo).  This is also known as the string *formatting* or
*interpolation* operator.  Given "format % values" (where *format* is
a string or Unicode object), "%" conversion specifications in *format*
are replaced with zero or more elements of *values*.  The effect is
similar to the using "sprintf()" in the C language.  If *format* is a
Unicode object, or if any of the objects being converted using the
"%s" conversion are Unicode objects, the result will also be a Unicode
object.

If *format* requires a single argument, *values* may be a single non-
tuple object. [5]  Otherwise, *values* must be a tuple with exactly
the number of items specified by the format string, or a single
mapping object (for example, a dictionary).

A conversion specifier contains two or more characters and has the
following components, which must occur in this order:

1. The "'%'" character, which marks the start of the specifier.

2. Mapping key (optional), consisting of a parenthesised sequence
   of characters (for example, "(somename)").

3. Conversion flags (optional), which affect the result of some
   conversion types.

4. Minimum field width (optional).  If specified as an "'*'"
   (asterisk), the actual width is read from the next element of the
   tuple in *values*, and the object to convert comes after the
   minimum field width and optional precision.

5. Precision (optional), given as a "'.'" (dot) followed by the
   precision.  If specified as "'*'" (an asterisk), the actual width
   is read from the next element of the tuple in *values*, and the
   value to convert comes after the precision.

6. Length modifier (optional).

7. Conversion type.

When the right argument is a dictionary (or other mapping type), then
the formats in the string *must* include a parenthesised mapping key
into that dictionary inserted immediately after the "'%'" character.
The mapping key selects the value to be formatted from the mapping.
For example:

>>> print '%(language)s has %(number)03d quote types.' % \
...       {"language": "Python", "number": 2}
Python has 002 quote types.

In this case no "*" specifiers may occur in a format (since they
require a sequential parameter list).

The conversion flag characters are:

+-----------+-----------------------------------------------------------------------+
| Flag      | Meaning                                                               |
+===========+=======================================================================+
| "'#'"     | The value conversion will use the "alternate form" (where defined     |
|           | below).                                                               |
+-----------+-----------------------------------------------------------------------+
| "'0'"     | The conversion will be zero padded for numeric values.                |
+-----------+-----------------------------------------------------------------------+
| "'-'"     | The converted value is left adjusted (overrides the "'0'" conversion  |
|           | if both are given).                                                   |
+-----------+-----------------------------------------------------------------------+
| "' '"     | (a space) A blank should be left before a positive number (or empty   |
|           | string) produced by a signed conversion.                              |
+-----------+-----------------------------------------------------------------------+
| "'+'"     | A sign character ("'+'" or "'-'") will precede the conversion         |
|           | (overrides a "space" flag).                                           |
+-----------+-----------------------------------------------------------------------+

A length modifier ("h", "l", or "L") may be present, but is ignored as
it is not necessary for Python -- so e.g. "%ld" is identical to "%d".

The conversion types are:

+--------------+-------------------------------------------------------+---------+
| Conversion   | Meaning                                               | Notes   |
+==============+=======================================================+=========+
| "'d'"        | Signed integer decimal.                               |         |
+--------------+-------------------------------------------------------+---------+
| "'i'"        | Signed integer decimal.                               |         |
+--------------+-------------------------------------------------------+---------+
| "'o'"        | Signed octal value.                                   | (1)     |
+--------------+-------------------------------------------------------+---------+
| "'u'"        | Obsolete type -- it is identical to "'d'".            | (7)     |
+--------------+-------------------------------------------------------+---------+
| "'x'"        | Signed hexadecimal (lowercase).                       | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'X'"        | Signed hexadecimal (uppercase).                       | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'e'"        | Floating point exponential format (lowercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'E'"        | Floating point exponential format (uppercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'f'"        | Floating point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'F'"        | Floating point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'g'"        | Floating point format. Uses lowercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'G'"        | Floating point format. Uses uppercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'c'"        | Single character (accepts integer or single character |         |
|              | string).                                              |         |
+--------------+-------------------------------------------------------+---------+
| "'r'"        | String (converts any Python object using *repr()*).   | (5)     |
+--------------+-------------------------------------------------------+---------+
| "'s'"        | String (converts any Python object using "str()").    | (6)     |
+--------------+-------------------------------------------------------+---------+
| "'%'"        | No argument is converted, results in a "'%'"          |         |
|              | character in the result.                              |         |
+--------------+-------------------------------------------------------+---------+

Notes:

1. The alternate form causes a leading zero ("'0'") to be inserted
   between left-hand padding and the formatting of the number if the
   leading character of the result is not already a zero.

2. The alternate form causes a leading "'0x'" or "'0X'" (depending
   on whether the "'x'" or "'X'" format was used) to be inserted
   between left-hand padding and the formatting of the number if the
   leading character of the result is not already a zero.

3. The alternate form causes the result to always contain a decimal
   point, even if no digits follow it.

   The precision determines the number of digits after the decimal
   point and defaults to 6.

4. The alternate form causes the result to always contain a decimal
   point, and trailing zeroes are not removed as they would otherwise
   be.

   The precision determines the number of significant digits before
   and after the decimal point and defaults to 6.

5. The "%r" conversion was added in Python 2.0.

   The precision determines the maximal number of characters used.

6. If the object or format provided is a "unicode" string, the
   resulting string will also be "unicode".

   The precision determines the maximal number of characters used.

7. See **PEP 237**.

Since Python strings have an explicit length, "%s" conversions do not
assume that "'\0'" is the end of the string.

Changed in version 2.7: "%f" conversions for numbers whose absolute
value is over 1e50 are no longer replaced by "%g" conversions.

Additional string operations are defined in standard modules "string"
and "re".


XRange Type
===========

The "xrange" type is an immutable sequence which is commonly used for
looping.  The advantage of the "xrange" type is that an "xrange"
object will always take the same amount of memory, no matter the size
of the range it represents.  There are no consistent performance
advantages.

XRange objects have very little behavior: they only support indexing,
iteration, and the "len()" function.


Mutable Sequence Types
======================

List and "bytearray" objects support additional operations that allow
in-place modification of the object. Other mutable sequence types
(when added to the language) should also support these operations.
Strings and tuples are immutable sequence types: such objects cannot
be modified once created. The following operations are defined on
mutable sequence types (where *x* is an arbitrary object):

+--------------------------------+----------------------------------+-----------------------+
| Operation                      | Result                           | Notes                 |
+================================+==================================+=======================+
| "s[i] = x"                     | item *i* of *s* is replaced by   |                       |
|                                | *x*                              |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j] = t"                   | slice of *s* from *i* to *j* is  |                       |
|                                | replaced by the contents of the  |                       |
|                                | iterable *t*                     |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j]"                   | same as "s[i:j] = []"            |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j:k] = t"                 | the elements of "s[i:j:k]" are   | (1)                   |
|                                | replaced by those of *t*         |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j:k]"                 | removes the elements of          |                       |
|                                | "s[i:j:k]" from the list         |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.append(x)"                  | same as "s[len(s):len(s)] = [x]" | (2)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.extend(x)"                  | same as "s[len(s):len(s)] = x"   | (3)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.count(x)"                   | return number of *i*'s for which |                       |
|                                | "s[i] == x"                      |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.index(x[, i[, j]])"         | return smallest *k* such that    | (4)                   |
|                                | "s[k] == x" and "i <= k < j"     |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.insert(i, x)"               | same as "s[i:i] = [x]"           | (5)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.pop([i])"                   | same as "x = s[i]; del s[i];     | (6)                   |
|                                | return x"                        |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.remove(x)"                  | same as "del s[s.index(x)]"      | (4)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.reverse()"                  | reverses the items of *s* in     | (7)                   |
|                                | place                            |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.sort([cmp[, key[,           | sort the items of *s* in place   | (7)(8)(9)(10)         |
| reverse]]])"                   |                                  |                       |
+--------------------------------+----------------------------------+-----------------------+

Notes:

1. *t* must have the same length as the slice it is  replacing.

2. The C implementation of Python has historically accepted
   multiple parameters and implicitly joined them into a tuple; this
   no longer works in Python 2.0.  Use of this misfeature has been
   deprecated since Python 1.4.

3. *x* can be any iterable object.

4. Raises "ValueError" when *x* is not found in *s*. When a
   negative index is passed as the second or third parameter to the
   "index()" method, the list length is added, as for slice indices.
   If it is still negative, it is truncated to zero, as for slice
   indices.

   Changed in version 2.3: Previously, "index()" didn't have arguments
   for specifying start and stop positions.

5. When a negative index is passed as the first parameter to the
   "insert()" method, the list length is added, as for slice indices.
   If it is still negative, it is truncated to zero, as for slice
   indices.

   Changed in version 2.3: Previously, all negative indices were
   truncated to zero.

6. The "pop()" method's optional argument *i* defaults to "-1", so
   that by default the last item is removed and returned.

7. The "sort()" and "reverse()" methods modify the list in place
   for economy of space when sorting or reversing a large list.  To
   remind you that they operate by side effect, they don't return the
   sorted or reversed list.

8. The "sort()" method takes optional arguments for controlling the
   comparisons.

   *cmp* specifies a custom comparison function of two arguments (list
   items) which should return a negative, zero or positive number
   depending on whether the first argument is considered smaller than,
   equal to, or larger than the second argument: "cmp=lambda x,y:
   cmp(x.lower(), y.lower())".  The default value is "None".

   *key* specifies a function of one argument that is used to extract
   a comparison key from each list element: "key=str.lower".  The
   default value is "None".

   *reverse* is a boolean value.  If set to "True", then the list
   elements are sorted as if each comparison were reversed.

   In general, the *key* and *reverse* conversion processes are much
   faster than specifying an equivalent *cmp* function.  This is
   because *cmp* is called multiple times for each list element while
   *key* and *reverse* touch each element only once.  Use
   "functools.cmp_to_key()" to convert an old-style *cmp* function to
   a *key* function.

   Changed in version 2.3: Support for "None" as an equivalent to
   omitting *cmp* was added.

   Changed in version 2.4: Support for *key* and *reverse* was added.

9. Starting with Python 2.3, the "sort()" method is guaranteed to
   be stable.  A sort is stable if it guarantees not to change the
   relative order of elements that compare equal --- this is helpful
   for sorting in multiple passes (for example, sort by department,
   then by salary grade).

10. **CPython implementation detail:** While a list is being
    sorted, the effect of attempting to mutate, or even inspect, the
    list is undefined.  The C implementation of Python 2.3 and newer
    makes the list appear empty for the duration, and raises
    "ValueError" if it can detect that the list has been mutated
    during a sort.
t   typessequ  
Mutable Sequence Types
**********************

List and "bytearray" objects support additional operations that allow
in-place modification of the object. Other mutable sequence types
(when added to the language) should also support these operations.
Strings and tuples are immutable sequence types: such objects cannot
be modified once created. The following operations are defined on
mutable sequence types (where *x* is an arbitrary object):

+--------------------------------+----------------------------------+-----------------------+
| Operation                      | Result                           | Notes                 |
+================================+==================================+=======================+
| "s[i] = x"                     | item *i* of *s* is replaced by   |                       |
|                                | *x*                              |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j] = t"                   | slice of *s* from *i* to *j* is  |                       |
|                                | replaced by the contents of the  |                       |
|                                | iterable *t*                     |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j]"                   | same as "s[i:j] = []"            |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j:k] = t"                 | the elements of "s[i:j:k]" are   | (1)                   |
|                                | replaced by those of *t*         |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j:k]"                 | removes the elements of          |                       |
|                                | "s[i:j:k]" from the list         |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.append(x)"                  | same as "s[len(s):len(s)] = [x]" | (2)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.extend(x)"                  | same as "s[len(s):len(s)] = x"   | (3)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.count(x)"                   | return number of *i*'s for which |                       |
|                                | "s[i] == x"                      |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.index(x[, i[, j]])"         | return smallest *k* such that    | (4)                   |
|                                | "s[k] == x" and "i <= k < j"     |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.insert(i, x)"               | same as "s[i:i] = [x]"           | (5)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.pop([i])"                   | same as "x = s[i]; del s[i];     | (6)                   |
|                                | return x"                        |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.remove(x)"                  | same as "del s[s.index(x)]"      | (4)                   |
+--------------------------------+----------------------------------+-----------------------+
| "s.reverse()"                  | reverses the items of *s* in     | (7)                   |
|                                | place                            |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s.sort([cmp[, key[,           | sort the items of *s* in place   | (7)(8)(9)(10)         |
| reverse]]])"                   |                                  |                       |
+--------------------------------+----------------------------------+-----------------------+

Notes:

1. *t* must have the same length as the slice it is  replacing.

2. The C implementation of Python has historically accepted
   multiple parameters and implicitly joined them into a tuple; this
   no longer works in Python 2.0.  Use of this misfeature has been
   deprecated since Python 1.4.

3. *x* can be any iterable object.

4. Raises "ValueError" when *x* is not found in *s*. When a
   negative index is passed as the second or third parameter to the
   "index()" method, the list length is added, as for slice indices.
   If it is still negative, it is truncated to zero, as for slice
   indices.

   Changed in version 2.3: Previously, "index()" didn't have arguments
   for specifying start and stop positions.

5. When a negative index is passed as the first parameter to the
   "insert()" method, the list length is added, as for slice indices.
   If it is still negative, it is truncated to zero, as for slice
   indices.

   Changed in version 2.3: Previously, all negative indices were
   truncated to zero.

6. The "pop()" method's optional argument *i* defaults to "-1", so
   that by default the last item is removed and returned.

7. The "sort()" and "reverse()" methods modify the list in place
   for economy of space when sorting or reversing a large list.  To
   remind you that they operate by side effect, they don't return the
   sorted or reversed list.

8. The "sort()" method takes optional arguments for controlling the
   comparisons.

   *cmp* specifies a custom comparison function of two arguments (list
   items) which should return a negative, zero or positive number
   depending on whether the first argument is considered smaller than,
   equal to, or larger than the second argument: "cmp=lambda x,y:
   cmp(x.lower(), y.lower())".  The default value is "None".

   *key* specifies a function of one argument that is used to extract
   a comparison key from each list element: "key=str.lower".  The
   default value is "None".

   *reverse* is a boolean value.  If set to "True", then the list
   elements are sorted as if each comparison were reversed.

   In general, the *key* and *reverse* conversion processes are much
   faster than specifying an equivalent *cmp* function.  This is
   because *cmp* is called multiple times for each list element while
   *key* and *reverse* touch each element only once.  Use
   "functools.cmp_to_key()" to convert an old-style *cmp* function to
   a *key* function.

   Changed in version 2.3: Support for "None" as an equivalent to
   omitting *cmp* was added.

   Changed in version 2.4: Support for *key* and *reverse* was added.

9. Starting with Python 2.3, the "sort()" method is guaranteed to
   be stable.  A sort is stable if it guarantees not to change the
   relative order of elements that compare equal --- this is helpful
   for sorting in multiple passes (for example, sort by department,
   then by salary grade).

10. **CPython implementation detail:** While a list is being
    sorted, the effect of attempting to mutate, or even inspect, the
    list is undefined.  The C implementation of Python 2.3 and newer
    makes the list appear empty for the duration, and raises
    "ValueError" if it can detect that the list has been mutated
    during a sort.
s   typesseq-mutableu  
Unary arithmetic and bitwise operations
***************************************

All unary arithmetic and bitwise operations have the same priority:

   u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr

The unary "-" (minus) operator yields the negation of its numeric
argument.

The unary "+" (plus) operator yields its numeric argument unchanged.

The unary "~" (invert) operator yields the bitwise inversion of its
plain or long integer argument.  The bitwise inversion of "x" is
defined as "-(x+1)".  It only applies to integral numbers.

In all three cases, if the argument does not have the proper type, a
"TypeError" exception is raised.
t   unaryu  
The "while" statement
*********************

The "while" statement is used for repeated execution as long as an
expression is true:

   while_stmt ::= "while" expression ":" suite
                  ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time
it is tested) the suite of the "else" clause, if present, is executed
and the loop terminates.

A "break" statement executed in the first suite terminates the loop
without executing the "else" clause's suite.  A "continue" statement
executed in the first suite skips the rest of the suite and goes back
to testing the expression.
t   whileu	  
The "with" statement
********************

New in version 2.5.

The "with" statement is used to wrap the execution of a block with
methods defined by a context manager (see section *With Statement
Context Managers*). This allows common "try"..."except"..."finally"
usage patterns to be encapsulated for convenient reuse.

   with_stmt ::= "with" with_item ("," with_item)* ":" suite
   with_item ::= expression ["as" target]

The execution of the "with" statement with one "item" proceeds as
follows:

1. The context expression (the expression given in the "with_item")
   is evaluated to obtain a context manager.

2. The context manager's "__exit__()" is loaded for later use.

3. The context manager's "__enter__()" method is invoked.

4. If a target was included in the "with" statement, the return
   value from "__enter__()" is assigned to it.

   Note: The "with" statement guarantees that if the "__enter__()"
     method returns without an error, then "__exit__()" will always be
     called. Thus, if an error occurs during the assignment to the
     target list, it will be treated the same as an error occurring
     within the suite would be. See step 6 below.

5. The suite is executed.

6. The context manager's "__exit__()" method is invoked. If an
   exception caused the suite to be exited, its type, value, and
   traceback are passed as arguments to "__exit__()". Otherwise, three
   "None" arguments are supplied.

   If the suite was exited due to an exception, and the return value
   from the "__exit__()" method was false, the exception is reraised.
   If the return value was true, the exception is suppressed, and
   execution continues with the statement following the "with"
   statement.

   If the suite was exited for any reason other than an exception, the
   return value from "__exit__()" is ignored, and execution proceeds
   at the normal location for the kind of exit that was taken.

With more than one item, the context managers are processed as if
multiple "with" statements were nested:

   with A() as a, B() as b:
       suite

is equivalent to

   with A() as a:
       with B() as b:
           suite

Note: In Python 2.5, the "with" statement is only allowed when the
  "with_statement" feature has been enabled.  It is always enabled in
  Python 2.6.

Changed in version 2.7: Support for multiple context expressions.

See also: **PEP 0343** - The "with" statement

     The specification, background, and examples for the Python "with"
     statement.
t   withu  
The "yield" statement
*********************

   yield_stmt ::= yield_expression

The "yield" statement is only used when defining a generator function,
and is only used in the body of the generator function. Using a
"yield" statement in a function definition is sufficient to cause that
definition to create a generator function instead of a normal
function.

When a generator function is called, it returns an iterator known as a
generator iterator, or more commonly, a generator.  The body of the
generator function is executed by calling the generator's "next()"
method repeatedly until it raises an exception.

When a "yield" statement is executed, the state of the generator is
frozen and the value of "expression_list" is returned to "next()"'s
caller.  By "frozen" we mean that all local state is retained,
including the current bindings of local variables, the instruction
pointer, and the internal evaluation stack: enough information is
saved so that the next time "next()" is invoked, the function can
proceed exactly as if the "yield" statement were just another external
call.

As of Python version 2.5, the "yield" statement is now allowed in the
"try" clause of a "try" ...  "finally" construct.  If the generator is
not resumed before it is finalized (by reaching a zero reference count
or by being garbage collected), the generator-iterator's "close()"
method will be called, allowing any pending "finally" clauses to
execute.

For full details of "yield" semantics, refer to the *Yield
expressions* section.

Note: In Python 2.2, the "yield" statement was only allowed when the
  "generators" feature has been enabled.  This "__future__" import
  statement was used to enable the feature:

     from __future__ import generators

See also: **PEP 0255** - Simple Generators

     The proposal for adding generators and the "yield" statement to
     Python.

  **PEP 0342** - Coroutines via Enhanced Generators
     The proposal that, among other generator enhancements, proposed
     allowing "yield" to appear inside a "try" ... "finally" block.
t   yieldN(   t   topics(    (    (    s'   /usr/lib/python2.7/pydoc_data/topics.pyt   <module>   s   
                                                                                                                                                   usr/lib/python2.7/quopri.py                                                                         0100755 0000000 0000000 00000015470 12734733752 014314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python2.7

"""Conversions to/from quoted-printable transport encoding as per RFC 1521."""

# (Dec 1991 version).

__all__ = ["encode", "decode", "encodestring", "decodestring"]

ESCAPE = '='
MAXLINESIZE = 76
HEX = '0123456789ABCDEF'
EMPTYSTRING = ''

try:
    from binascii import a2b_qp, b2a_qp
except ImportError:
    a2b_qp = None
    b2a_qp = None


def needsquoting(c, quotetabs, header):
    """Decide whether a particular character needs to be quoted.

    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    """
    if c in ' \t':
        return quotetabs
    # if header, we have to escape _ because _ is used to escape space
    if c == '_':
        return header
    return c == ESCAPE or not (' ' <= c <= '~')

def quote(c):
    """Quote a single character."""
    i = ord(c)
    return ESCAPE + HEX[i//16] + HEX[i%16]



def encode(input, output, quotetabs, header = 0):
    """Read 'input', apply quoted-printable encoding, and write to 'output'.

    'input' and 'output' are files with readline() and write() methods.
    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    The 'header' flag indicates whether we are encoding spaces as _ as per
    RFC 1522.
    """

    if b2a_qp is not None:
        data = input.read()
        odata = b2a_qp(data, quotetabs = quotetabs, header = header)
        output.write(odata)
        return

    def write(s, output=output, lineEnd='\n'):
        # RFC 1521 requires that the line ending in a space or tab must have
        # that trailing character encoded.
        if s and s[-1:] in ' \t':
            output.write(s[:-1] + quote(s[-1]) + lineEnd)
        elif s == '.':
            output.write(quote(s) + lineEnd)
        else:
            output.write(s + lineEnd)

    prevline = None
    while 1:
        line = input.readline()
        if not line:
            break
        outline = []
        # Strip off any readline induced trailing newline
        stripped = ''
        if line[-1:] == '\n':
            line = line[:-1]
            stripped = '\n'
        # Calculate the un-length-limited encoded line
        for c in line:
            if needsquoting(c, quotetabs, header):
                c = quote(c)
            if header and c == ' ':
                outline.append('_')
            else:
                outline.append(c)
        # First, write out the previous line
        if prevline is not None:
            write(prevline)
        # Now see if we need any soft line breaks because of RFC-imposed
        # length limitations.  Then do the thisline->prevline dance.
        thisline = EMPTYSTRING.join(outline)
        while len(thisline) > MAXLINESIZE:
            # Don't forget to include the soft line break `=' sign in the
            # length calculation!
            write(thisline[:MAXLINESIZE-1], lineEnd='=\n')
            thisline = thisline[MAXLINESIZE-1:]
        # Write out the current line
        prevline = thisline
    # Write out the last line, without a trailing newline
    if prevline is not None:
        write(prevline, lineEnd=stripped)

def encodestring(s, quotetabs = 0, header = 0):
    if b2a_qp is not None:
        return b2a_qp(s, quotetabs = quotetabs, header = header)
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    encode(infp, outfp, quotetabs, header)
    return outfp.getvalue()



def decode(input, output, header = 0):
    """Read 'input', apply quoted-printable decoding, and write to 'output'.
    'input' and 'output' are files with readline() and write() methods.
    If 'header' is true, decode underscore as space (per RFC 1522)."""

    if a2b_qp is not None:
        data = input.read()
        odata = a2b_qp(data, header = header)
        output.write(odata)
        return

    new = ''
    while 1:
        line = input.readline()
        if not line: break
        i, n = 0, len(line)
        if n > 0 and line[n-1] == '\n':
            partial = 0; n = n-1
            # Strip trailing whitespace
            while n > 0 and line[n-1] in " \t\r":
                n = n-1
        else:
            partial = 1
        while i < n:
            c = line[i]
            if c == '_' and header:
                new = new + ' '; i = i+1
            elif c != ESCAPE:
                new = new + c; i = i+1
            elif i+1 == n and not partial:
                partial = 1; break
            elif i+1 < n and line[i+1] == ESCAPE:
                new = new + ESCAPE; i = i+2
            elif i+2 < n and ishex(line[i+1]) and ishex(line[i+2]):
                new = new + chr(unhex(line[i+1:i+3])); i = i+3
            else: # Bad escape sequence -- leave it in
                new = new + c; i = i+1
        if not partial:
            output.write(new + '\n')
            new = ''
    if new:
        output.write(new)

def decodestring(s, header = 0):
    if a2b_qp is not None:
        return a2b_qp(s, header = header)
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    decode(infp, outfp, header = header)
    return outfp.getvalue()



# Other helper functions
def ishex(c):
    """Return true if the character 'c' is a hexadecimal digit."""
    return '0' <= c <= '9' or 'a' <= c <= 'f' or 'A' <= c <= 'F'

def unhex(s):
    """Get the integer value of a hexadecimal number."""
    bits = 0
    for c in s:
        if '0' <= c <= '9':
            i = ord('0')
        elif 'a' <= c <= 'f':
            i = ord('a')-10
        elif 'A' <= c <= 'F':
            i = ord('A')-10
        else:
            break
        bits = bits*16 + (ord(c) - i)
    return bits



def main():
    import sys
    import getopt
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'td')
    except getopt.error, msg:
        sys.stdout = sys.stderr
        print msg
        print "usage: quopri [-t | -d] [file] ..."
        print "-t: quote tabs"
        print "-d: decode; default encode"
        sys.exit(2)
    deco = 0
    tabs = 0
    for o, a in opts:
        if o == '-t': tabs = 1
        if o == '-d': deco = 1
    if tabs and deco:
        sys.stdout = sys.stderr
        print "-t and -d are mutually exclusive"
        sys.exit(2)
    if not args: args = ['-']
    sts = 0
    for file in args:
        if file == '-':
            fp = sys.stdin
        else:
            try:
                fp = open(file)
            except IOError, msg:
                sys.stderr.write("%s: can't open (%s)\n" % (file, msg))
                sts = 1
                continue
        if deco:
            decode(fp, sys.stdout)
        else:
            encode(fp, sys.stdout, tabs)
        if fp is not sys.stdin:
            fp.close()
    if sts:
        sys.exit(sts)



if __name__ == '__main__':
    main()
                                                                                                                                                                                                        usr/lib/python2.7/quopri.pyc                                                                        0100644 0000000 0000000 00000014626 13077704274 014454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s   d  Z  d d d d g Z d Z d Z d Z d Z y d	 d
 l m Z m Z Wn e	 k
 ri d Z d Z n Xd   Z d   Z d d  Z d d d  Z d d  Z d d  Z d   Z d   Z d   Z e d k r e   n  d S(   sH   Conversions to/from quoted-printable transport encoding as per RFC 1521.t   encodet   decodet   encodestringt   decodestringt   =iL   t   0123456789ABCDEFt    i(   t   a2b_qpt   b2a_qpc         C   sG   |  d k r | S|  d k r  | S|  t  k pF d |  k oC d k n S(   s   Decide whether a particular character needs to be quoted.

    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    s    	t   _t    t   ~(   t   ESCAPE(   t   ct	   quotetabst   header(    (    s   /usr/lib/python2.7/quopri.pyt   needsquoting   s
    c         C   s(   t  |   } t t | d t | d S(   s   Quote a single character.i   (   t   ordR   t   HEX(   R   t   i(    (    s   /usr/lib/python2.7/quopri.pyt   quote#   s    i    c         C   s  t  d k	 rA |  j   } t  | d | d | } | j |  d S| d d  } d } x|  j   } | so Pn  g  }	 d }
 | d d k r | d  } d }
 n  x^ | D]V } t | | |  r t |  } n  | r | d k r |	 j d	  q |	 j |  q W| d k	 r| |  n  t j	 |	  } x< t
 |  t k re| | t d
  d d | t d
 } q*W| } qY | d k	 r| | d |
 n  d S(   s  Read 'input', apply quoted-printable encoding, and write to 'output'.

    'input' and 'output' are files with readline() and write() methods.
    The 'quotetabs' flag indicates whether embedded tabs and spaces should be
    quoted.  Note that line-ending tabs and spaces are always encoded, as per
    RFC 1521.
    The 'header' flag indicates whether we are encoding spaces as _ as per
    RFC 1522.
    R   R   Ns   
c         S   sw   |  r< |  d d k r< | j  |  d  t |  d  |  n7 |  d k rb | j  t |   |  n | j  |  |  d  S(   Nis    	t   .(   t   writeR   (   t   st   outputt   lineEnd(    (    s   /usr/lib/python2.7/quopri.pyR   ;   s
    &R   iR
   R	   i   R   s   =
(   R   t   Nonet   readR   t   readlineR   R   t   appendt   EMPTYSTRINGt   joint   lent   MAXLINESIZE(   t   inputR   R   R   t   datat   odataR   t   prevlinet   linet   outlinet   strippedR   t   thisline(    (    s   /usr/lib/python2.7/quopri.pyR    *   s>    

		c         C   sd   t  d  k	 r" t  |  d | d | Sd d l m } | |   } |   } t | | | |  | j   S(   NR   R   i(   t   StringIO(   R   R   t	   cStringIOR*   R    t   getvalue(   R   R   R   R*   t   infpt   outfp(    (    s   /usr/lib/python2.7/quopri.pyR   i   s    	c         C   sW  t  d k	 r; |  j   } t  | d | } | j |  d Sd } x|  j   } | sZ Pn  d t |  } } | d k r | | d d k r d }	 | d } x7 | d k r | | d d k r | d } q Wn d }	 x@| | k  r| | }
 |
 d k r| r| d	 } | d } q |
 t k r<| |
 } | d } q | d | k r]|	 r]d }	 Pq | d | k  r| | d t k r| t } | d
 } q | d
 | k  rt | | d  rt | | d
  r| t t	 | | d | d !  } | d } q | |
 } | d } q W|	 sD | j | d  d } qD qD | rS| j |  n  d S(   s   Read 'input', apply quoted-printable decoding, and write to 'output'.
    'input' and 'output' are files with readline() and write() methods.
    If 'header' is true, decode underscore as space (per RFC 1522).R   NR   i    i   s   
s    	R	   R
   i   i   (
   R   R   R   R   R   R    R   t   ishext   chrt   unhex(   R"   R   R   R#   R$   t   newR&   R   t   nt   partialR   (    (    s   /usr/lib/python2.7/quopri.pyR   t   sR       
#

 
  $
 8% 
 c         C   s^   t  d  k	 r t  |  d | Sd d l m } | |   } |   } t | | d | | j   S(   NR   i(   R*   (   R   R   R+   R*   R   R,   (   R   R   R*   R-   R.   (    (    s   /usr/lib/python2.7/quopri.pyR      s    	c         C   sP   d |  k o d k n pO d |  k o3 d k n pO d |  k oM d k SS(   s8   Return true if the character 'c' is a hexadecimal digit.t   0t   9t   at   ft   At   F(    (   R   (    (    s   /usr/lib/python2.7/quopri.pyR/      s    c         C   s   d } x |  D] } d | k o* d k n r> t  d  } n_ d | k oU d k n rm t  d  d } n0 d | k o d k n r t  d  d } n P| d	 t  |  | } q W| S(
   s.   Get the integer value of a hexadecimal number.i    R5   R6   R7   R8   i
   R9   R:   i   (   R   (   R   t   bitsR   R   (    (    s   /usr/lib/python2.7/quopri.pyR1      s    c          C   s  d d  l  }  d d  l } y# | j |  j d d  \ } } WnC | j k
 r } |  j |  _ | GHd GHd GHd GH|  j d  n Xd } d } x> | D]6 \ } } | d	 k r d } n  | d
 k r d } q q W| r | r |  j |  _ d GH|  j d  n  | sd g } n  d }	 x | D] }
 |
 d k r8|  j } nI y t |
  } Wn6 t	 k
 r} |  j j
 d |
 | f  d }	 qn X| rt | |  j  n t | |  j |  | |  j k	 r| j   qqW|	 r|  j |	  n  d  S(   Nii   t   tds"   usage: quopri [-t | -d] [file] ...s   -t: quote tabss   -d: decode; default encodei   i    s   -ts   -ds    -t and -d are mutually exclusivet   -s   %s: can't open (%s)
(   t   syst   getoptt   argvt   errort   stderrt   stdoutt   exitt   stdint   opent   IOErrorR   R   R    t   close(   R>   R?   t   optst   argst   msgt   decot   tabst   oR7   t   stst   filet   fp(    (    s   /usr/lib/python2.7/quopri.pyt   main   sR    # 	  t   __main__N(   t   __doc__t   __all__R   R!   R   R   t   binasciiR   R   t   ImportErrorR   R   R   R    R   R   R   R/   R1   RR   t   __name__(    (    (    s   /usr/lib/python2.7/quopri.pyt   <module>   s*   
		?+			,                                                                                                          usr/lib/python2.7/random.py                                                                         0100644 0000000 0000000 00000077103 12734733742 014252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Random variable generators.

    integers
    --------
           uniform within range

    sequences
    ---------
           pick random element
           pick random sample
           generate random permutation

    distributions on the real line:
    ------------------------------
           uniform
           triangular
           normal (Gaussian)
           lognormal
           negative exponential
           gamma
           beta
           pareto
           Weibull

    distributions on the circle (angles 0 to 2pi)
    ---------------------------------------------
           circular uniform
           von Mises

General notes on the underlying Mersenne Twister core generator:

* The period is 2**19937-1.
* It is one of the most extensively tested generators in existence.
* Without a direct way to compute N steps forward, the semantics of
  jumpahead(n) are weakened to simply jump to another distant state and rely
  on the large period to avoid overlapping sequences.
* The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.

"""

from __future__ import division
from warnings import warn as _warn
from types import MethodType as _MethodType, BuiltinMethodType as _BuiltinMethodType
from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from os import urandom as _urandom
from binascii import hexlify as _hexlify
import hashlib as _hashlib

__all__ = ["Random","seed","random","uniform","randint","choice","sample",
           "randrange","shuffle","normalvariate","lognormvariate",
           "expovariate","vonmisesvariate","gammavariate","triangular",
           "gauss","betavariate","paretovariate","weibullvariate",
           "getstate","setstate","jumpahead", "WichmannHill", "getrandbits",
           "SystemRandom"]

NV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)
TWOPI = 2.0*_pi
LOG4 = _log(4.0)
SG_MAGICCONST = 1.0 + _log(4.5)
BPF = 53        # Number of bits in a float
RECIP_BPF = 2**-BPF


# Translated by Guido van Rossum from C source provided by
# Adrian Baddeley.  Adapted by Raymond Hettinger for use with
# the Mersenne Twister  and os.urandom() core generators.

import _random

class Random(_random.Random):
    """Random number generator base class used by bound module functions.

    Used to instantiate instances of Random to get generators that don't
    share state.  Especially useful for multi-threaded programs, creating
    a different instance of Random for each thread, and using the jumpahead()
    method to ensure that the generated sequences seen by each thread don't
    overlap.

    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods: random(), seed(), getstate(), setstate() and jumpahead().
    Optionally, implement a getrandbits() method so that randrange() can cover
    arbitrarily large ranges.

    """

    VERSION = 3     # used by getstate/setstate

    def __init__(self, x=None):
        """Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().
        """

        self.seed(x)
        self.gauss_next = None

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.
        """

        if a is None:
            try:
                # Seed with enough bytes to span the 19937 bit
                # state space for the Mersenne Twister
                a = long(_hexlify(_urandom(2500)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        super(Random, self).seed(a)
        self.gauss_next = None

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, super(Random, self).getstate(), self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 3:
            version, internalstate, self.gauss_next = state
            super(Random, self).setstate(internalstate)
        elif version == 2:
            version, internalstate, self.gauss_next = state
            # In version 2, the state was saved as signed ints, which causes
            #   inconsistencies between 32/64-bit systems. The state is
            #   really unsigned 32-bit ints, so we convert negative ints from
            #   version 2 to positive longs for version 3.
            try:
                internalstate = tuple( long(x) % (2**32) for x in internalstate )
            except ValueError, e:
                raise TypeError, e
            super(Random, self).setstate(internalstate)
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

    def jumpahead(self, n):
        """Change the internal state to one that is likely far away
        from the current state.  This method will not be in Py3.x,
        so it is better to simply reseed.
        """
        # The super.jumpahead() method uses shuffling to change state,
        # so it needs a large and "interesting" n to work with.  Here,
        # we use hashing to create a large n for the shuffle.
        s = repr(n) + repr(self.getstate())
        n = int(_hashlib.new('sha512', s).hexdigest(), 16)
        super(Random, self).jumpahead(n)

## ---- Methods below this point do not need to be overridden when
## ---- subclassing for the purpose of using a different core generator.

## -------------------- pickle support  -------------------

    def __getstate__(self): # for pickle
        return self.getstate()

    def __setstate__(self, state):  # for pickle
        self.setstate(state)

    def __reduce__(self):
        return self.__class__, (), self.getstate()

## -------------------- integer methods  -------------------

    def randrange(self, start, stop=None, step=1, _int=int, _maxwidth=1L<<BPF):
        """Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.

        """

        # This code is a bit messy to make it fast for the
        # common case while still doing adequate error checking.
        istart = _int(start)
        if istart != start:
            raise ValueError, "non-integer arg 1 for randrange()"
        if stop is None:
            if istart > 0:
                if istart >= _maxwidth:
                    return self._randbelow(istart)
                return _int(self.random() * istart)
            raise ValueError, "empty range for randrange()"

        # stop argument supplied.
        istop = _int(stop)
        if istop != stop:
            raise ValueError, "non-integer stop for randrange()"
        width = istop - istart
        if step == 1 and width > 0:
            # Note that
            #     int(istart + self.random()*width)
            # instead would be incorrect.  For example, consider istart
            # = -2 and istop = 0.  Then the guts would be in
            # -2.0 to 0.0 exclusive on both ends (ignoring that random()
            # might return 0.0), and because int() truncates toward 0, the
            # final result would be -1 or 0 (instead of -2 or -1).
            #     istart + int(self.random()*width)
            # would also be incorrect, for a subtler reason:  the RHS
            # can return a long, and then randrange() would also return
            # a long, but we're supposed to return an int (for backward
            # compatibility).

            if width >= _maxwidth:
                return _int(istart + self._randbelow(width))
            return _int(istart + _int(self.random()*width))
        if step == 1:
            raise ValueError, "empty range for randrange() (%d,%d, %d)" % (istart, istop, width)

        # Non-unit step argument supplied.
        istep = _int(step)
        if istep != step:
            raise ValueError, "non-integer step for randrange()"
        if istep > 0:
            n = (width + istep - 1) // istep
        elif istep < 0:
            n = (width + istep + 1) // istep
        else:
            raise ValueError, "zero step for randrange()"

        if n <= 0:
            raise ValueError, "empty range for randrange()"

        if n >= _maxwidth:
            return istart + istep*self._randbelow(n)
        return istart + istep*_int(self.random() * n)

    def randint(self, a, b):
        """Return random integer in range [a, b], including both end points.
        """

        return self.randrange(a, b+1)

    def _randbelow(self, n, _log=_log, _int=int, _maxwidth=1L<<BPF,
                   _Method=_MethodType, _BuiltinMethod=_BuiltinMethodType):
        """Return a random int in the range [0,n)

        Handles the case where n has more bits than returned
        by a single call to the underlying generator.
        """

        try:
            getrandbits = self.getrandbits
        except AttributeError:
            pass
        else:
            # Only call self.getrandbits if the original random() builtin method
            # has not been overridden or if a new getrandbits() was supplied.
            # This assures that the two methods correspond.
            if type(self.random) is _BuiltinMethod or type(getrandbits) is _Method:
                k = _int(1.00001 + _log(n-1, 2.0))   # 2**k > n-1 > 2**(k-2)
                r = getrandbits(k)
                while r >= n:
                    r = getrandbits(k)
                return r
        if n >= _maxwidth:
            _warn("Underlying random() generator does not supply \n"
                "enough bits to choose from a population range this large")
        return _int(self.random() * n)

## -------------------- sequence methods  -------------------

    def choice(self, seq):
        """Choose a random element from a non-empty sequence."""
        return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty

    def shuffle(self, x, random=None):
        """x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        """

        if random is None:
            random = self.random
        _int = int
        for i in reversed(xrange(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _int(random() * (i+1))
            x[i], x[j] = x[j], x[i]

    def sample(self, population, k):
        """Chooses k unique random elements from a population sequence.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use xrange as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(xrange(10000000), 60)
        """

        # Sampling without replacement entails tracking either potential
        # selections (the pool) in a list or previous selections in a set.

        # When the number of selections is small compared to the
        # population, then tracking selections is efficient, requiring
        # only a small set and an occasional reselection.  For
        # a larger number of selections, the pool tracking method is
        # preferred since the list takes less space than the
        # set and it doesn't suffer from frequent reselections.

        n = len(population)
        if not 0 <= k <= n:
            raise ValueError("sample larger than population")
        random = self.random
        _int = int
        result = [None] * k
        setsize = 21        # size of a small set minus size of an empty list
        if k > 5:
            setsize += 4 ** _ceil(_log(k * 3, 4)) # table size for big sets
        if n <= setsize or hasattr(population, "keys"):
            # An n-length list is smaller than a k-length set, or this is a
            # mapping type so the other algorithm wouldn't work.
            pool = list(population)
            for i in xrange(k):         # invariant:  non-selected at [0,n-i)
                j = _int(random() * (n-i))
                result[i] = pool[j]
                pool[j] = pool[n-i-1]   # move non-selected item into vacancy
        else:
            try:
                selected = set()
                selected_add = selected.add
                for i in xrange(k):
                    j = _int(random() * n)
                    while j in selected:
                        j = _int(random() * n)
                    selected_add(j)
                    result[i] = population[j]
            except (TypeError, KeyError):   # handle (at least) sets
                if isinstance(population, list):
                    raise
                return self.sample(tuple(population), k)
        return result

## -------------------- real-valued distributions  -------------------

## -------------------- uniform distribution -------------------

    def uniform(self, a, b):
        "Get a random number in the range [a, b) or [a, b] depending on rounding."
        return a + (b-a) * self.random()

## -------------------- triangular --------------------

    def triangular(self, low=0.0, high=1.0, mode=None):
        """Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        """
        u = self.random()
        try:
            c = 0.5 if mode is None else (mode - low) / (high - low)
        except ZeroDivisionError:
            return low
        if u > c:
            u = 1.0 - u
            c = 1.0 - c
            low, high = high, low
        return low + (high - low) * (u * c) ** 0.5

## -------------------- normal distribution --------------------

    def normalvariate(self, mu, sigma):
        """Normal distribution.

        mu is the mean, and sigma is the standard deviation.

        """
        # mu = mean, sigma = standard deviation

        # Uses Kinderman and Monahan method. Reference: Kinderman,
        # A.J. and Monahan, J.F., "Computer generation of random
        # variables using the ratio of uniform deviates", ACM Trans
        # Math Software, 3, (1977), pp257-260.

        random = self.random
        while 1:
            u1 = random()
            u2 = 1.0 - random()
            z = NV_MAGICCONST*(u1-0.5)/u2
            zz = z*z/4.0
            if zz <= -_log(u2):
                break
        return mu + z*sigma

## -------------------- lognormal distribution --------------------

    def lognormvariate(self, mu, sigma):
        """Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.

        """
        return _exp(self.normalvariate(mu, sigma))

## -------------------- exponential distribution --------------------

    def expovariate(self, lambd):
        """Exponential distribution.

        lambd is 1.0 divided by the desired mean.  It should be
        nonzero.  (The parameter would be called "lambda", but that is
        a reserved word in Python.)  Returned values range from 0 to
        positive infinity if lambd is positive, and from negative
        infinity to 0 if lambd is negative.

        """
        # lambd: rate lambd = 1/mean
        # ('lambda' is a Python reserved word)

        # we use 1-random() instead of random() to preclude the
        # possibility of taking the log of zero.
        return -_log(1.0 - self.random())/lambd

## -------------------- von Mises distribution --------------------

    def vonmisesvariate(self, mu, kappa):
        """Circular data distribution.

        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.

        """
        # mu:    mean angle (in radians between 0 and 2*pi)
        # kappa: concentration parameter kappa (>= 0)
        # if kappa = 0 generate uniform random angle

        # Based upon an algorithm published in: Fisher, N.I.,
        # "Statistical Analysis of Circular Data", Cambridge
        # University Press, 1993.

        # Thanks to Magnus Kessler for a correction to the
        # implementation of step 4.

        random = self.random
        if kappa <= 1e-6:
            return TWOPI * random()

        s = 0.5 / kappa
        r = s + _sqrt(1.0 + s * s)

        while 1:
            u1 = random()
            z = _cos(_pi * u1)

            d = z / (r + z)
            u2 = random()
            if u2 < 1.0 - d * d or u2 <= (1.0 - d) * _exp(d):
                break

        q = 1.0 / r
        f = (q + z) / (1.0 + q * z)
        u3 = random()
        if u3 > 0.5:
            theta = (mu + _acos(f)) % TWOPI
        else:
            theta = (mu - _acos(f)) % TWOPI

        return theta

## -------------------- gamma distribution --------------------

    def gammavariate(self, alpha, beta):
        """Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha > 0 and beta > 0.

        The probability distribution function is:

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha

        """

        # alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2

        # Warning: a few older sources define the gamma distribution in terms
        # of alpha > -1.0
        if alpha <= 0.0 or beta <= 0.0:
            raise ValueError, 'gammavariate: alpha and beta must be > 0.0'

        random = self.random
        if alpha > 1.0:

            # Uses R.C.H. Cheng, "The generation of Gamma
            # variables with non-integral shape parameters",
            # Applied Statistics, (1977), 26, No. 1, p71-74

            ainv = _sqrt(2.0 * alpha - 1.0)
            bbb = alpha - LOG4
            ccc = alpha + ainv

            while 1:
                u1 = random()
                if not 1e-7 < u1 < .9999999:
                    continue
                u2 = 1.0 - random()
                v = _log(u1/(1.0-u1))/ainv
                x = alpha*_exp(v)
                z = u1*u1*u2
                r = bbb+ccc*v-x
                if r + SG_MAGICCONST - 4.5*z >= 0.0 or r >= _log(z):
                    return x * beta

        elif alpha == 1.0:
            # expovariate(1)
            u = random()
            while u <= 1e-7:
                u = random()
            return -_log(u) * beta

        else:   # alpha is between 0 and 1 (exclusive)

            # Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle

            while 1:
                u = random()
                b = (_e + alpha)/_e
                p = b*u
                if p <= 1.0:
                    x = p ** (1.0/alpha)
                else:
                    x = -_log((b-p)/alpha)
                u1 = random()
                if p > 1.0:
                    if u1 <= x ** (alpha - 1.0):
                        break
                elif u1 <= _exp(-x):
                    break
            return x * beta

## -------------------- Gauss (faster alternative) --------------------

    def gauss(self, mu, sigma):
        """Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.

        Not thread-safe without a lock around calls.

        """

        # When x and y are two variables from [0, 1), uniformly
        # distributed, then
        #
        #    cos(2*pi*x)*sqrt(-2*log(1-y))
        #    sin(2*pi*x)*sqrt(-2*log(1-y))
        #
        # are two *independent* variables with normal distribution
        # (mu = 0, sigma = 1).
        # (Lambert Meertens)
        # (corrected version; bug discovered by Mike Miller, fixed by LM)

        # Multithreading note: When two threads call this function
        # simultaneously, it is possible that they will receive the
        # same return value.  The window is very small though.  To
        # avoid this, you have to use a lock around all calls.  (I
        # didn't want to slow this down in the serial case by using a
        # lock here.)

        random = self.random
        z = self.gauss_next
        self.gauss_next = None
        if z is None:
            x2pi = random() * TWOPI
            g2rad = _sqrt(-2.0 * _log(1.0 - random()))
            z = _cos(x2pi) * g2rad
            self.gauss_next = _sin(x2pi) * g2rad

        return mu + z*sigma

## -------------------- beta --------------------
## See
## http://mail.python.org/pipermail/python-bugs-list/2001-January/003752.html
## for Ivan Frohne's insightful analysis of why the original implementation:
##
##    def betavariate(self, alpha, beta):
##        # Discrete Event Simulation in C, pp 87-88.
##
##        y = self.expovariate(alpha)
##        z = self.expovariate(1.0/beta)
##        return z/(y+z)
##
## was dead wrong, and how it probably got that way.

    def betavariate(self, alpha, beta):
        """Beta distribution.

        Conditions on the parameters are alpha > 0 and beta > 0.
        Returned values range between 0 and 1.

        """

        # This version due to Janne Sinkkonen, and matches all the std
        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").
        y = self.gammavariate(alpha, 1.)
        if y == 0:
            return 0.0
        else:
            return y / (y + self.gammavariate(beta, 1.))

## -------------------- Pareto --------------------

    def paretovariate(self, alpha):
        """Pareto distribution.  alpha is the shape parameter."""
        # Jain, pg. 495

        u = 1.0 - self.random()
        return 1.0 / pow(u, 1.0/alpha)

## -------------------- Weibull --------------------

    def weibullvariate(self, alpha, beta):
        """Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.

        """
        # Jain, pg. 499; bug fix courtesy Bill Arms

        u = 1.0 - self.random()
        return alpha * pow(-_log(u), 1.0/beta)

## -------------------- Wichmann-Hill -------------------

class WichmannHill(Random):

    VERSION = 1     # used by getstate/setstate

    def seed(self, a=None):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.

        If a is an int or long, a is used directly.  Distinct values between
        0 and 27814431486575L inclusive are guaranteed to yield distinct
        internal states (this guarantee is specific to the default
        Wichmann-Hill generator).
        """

        if a is None:
            try:
                a = long(_hexlify(_urandom(16)), 16)
            except NotImplementedError:
                import time
                a = long(time.time() * 256) # use fractional seconds

        if not isinstance(a, (int, long)):
            a = hash(a)

        a, x = divmod(a, 30268)
        a, y = divmod(a, 30306)
        a, z = divmod(a, 30322)
        self._seed = int(x)+1, int(y)+1, int(z)+1

        self.gauss_next = None

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""

        # Wichman-Hill random number generator.
        #
        # Wichmann, B. A. & Hill, I. D. (1982)
        # Algorithm AS 183:
        # An efficient and portable pseudo-random number generator
        # Applied Statistics 31 (1982) 188-190
        #
        # see also:
        #        Correction to Algorithm AS 183
        #        Applied Statistics 33 (1984) 123
        #
        #        McLeod, A. I. (1985)
        #        A remark on Algorithm AS 183
        #        Applied Statistics 34 (1985),198-200

        # This part is thread-unsafe:
        # BEGIN CRITICAL SECTION
        x, y, z = self._seed
        x = (171 * x) % 30269
        y = (172 * y) % 30307
        z = (170 * z) % 30323
        self._seed = x, y, z
        # END CRITICAL SECTION

        # Note:  on a platform using IEEE-754 double arithmetic, this can
        # never return 0.0 (asserted by Tim; proof too long for a comment).
        return (x/30269.0 + y/30307.0 + z/30323.0) % 1.0

    def getstate(self):
        """Return internal state; can be passed to setstate() later."""
        return self.VERSION, self._seed, self.gauss_next

    def setstate(self, state):
        """Restore internal state from object returned by getstate()."""
        version = state[0]
        if version == 1:
            version, self._seed, self.gauss_next = state
        else:
            raise ValueError("state with version %s passed to "
                             "Random.setstate() of version %s" %
                             (version, self.VERSION))

    def jumpahead(self, n):
        """Act as if n calls to random() were made, but quickly.

        n is an int, greater than or equal to 0.

        Example use:  If you have 2 threads and know that each will
        consume no more than a million random numbers, create two Random
        objects r1 and r2, then do
            r2.setstate(r1.getstate())
            r2.jumpahead(1000000)
        Then r1 and r2 will use guaranteed-disjoint segments of the full
        period.
        """

        if not n >= 0:
            raise ValueError("n must be >= 0")
        x, y, z = self._seed
        x = int(x * pow(171, n, 30269)) % 30269
        y = int(y * pow(172, n, 30307)) % 30307
        z = int(z * pow(170, n, 30323)) % 30323
        self._seed = x, y, z

    def __whseed(self, x=0, y=0, z=0):
        """Set the Wichmann-Hill seed from (x, y, z).

        These must be integers in the range [0, 256).
        """

        if not type(x) == type(y) == type(z) == int:
            raise TypeError('seeds must be integers')
        if not (0 <= x < 256 and 0 <= y < 256 and 0 <= z < 256):
            raise ValueError('seeds must be in range(0, 256)')
        if 0 == x == y == z:
            # Initialize from current time
            import time
            t = long(time.time() * 256)
            t = int((t&0xffffff) ^ (t>>24))
            t, x = divmod(t, 256)
            t, y = divmod(t, 256)
            t, z = divmod(t, 256)
        # Zero is a poor seed, so substitute 1
        self._seed = (x or 1, y or 1, z or 1)

        self.gauss_next = None

    def whseed(self, a=None):
        """Seed from hashable object's hash code.

        None or no argument seeds from current time.  It is not guaranteed
        that objects with distinct hash codes lead to distinct internal
        states.

        This is obsolete, provided for compatibility with the seed routine
        used prior to Python 2.1.  Use the .seed() method instead.
        """

        if a is None:
            self.__whseed()
            return
        a = hash(a)
        a, x = divmod(a, 256)
        a, y = divmod(a, 256)
        a, z = divmod(a, 256)
        x = (x + a) % 256 or 1
        y = (y + a) % 256 or 1
        z = (z + a) % 256 or 1
        self.__whseed(x, y, z)

## --------------- Operating System Random Source  ------------------

class SystemRandom(Random):
    """Alternate random number generator using sources provided
    by the operating system (such as /dev/urandom on Unix or
    CryptGenRandom on Windows).

     Not available on all systems (see os.urandom() for details).
    """

    def random(self):
        """Get the next random number in the range [0.0, 1.0)."""
        return (long(_hexlify(_urandom(7)), 16) >> 3) * RECIP_BPF

    def getrandbits(self, k):
        """getrandbits(k) -> x.  Generates a long int with k random bits."""
        if k <= 0:
            raise ValueError('number of bits must be greater than zero')
        if k != int(k):
            raise TypeError('number of bits should be an integer')
        bytes = (k + 7) // 8                    # bits / 8 and rounded up
        x = long(_hexlify(_urandom(bytes)), 16)
        return x >> (bytes * 8 - k)             # trim excess bits

    def _stub(self, *args, **kwds):
        "Stub method.  Not used for a system random number generator."
        return None
    seed = jumpahead = _stub

    def _notimplemented(self, *args, **kwds):
        "Method should not be called for a system random number generator."
        raise NotImplementedError('System entropy source does not have state.')
    getstate = setstate = _notimplemented

## -------------------- test program --------------------

def _test_generator(n, func, args):
    import time
    print n, 'times', func.__name__
    total = 0.0
    sqsum = 0.0
    smallest = 1e10
    largest = -1e10
    t0 = time.time()
    for i in range(n):
        x = func(*args)
        total += x
        sqsum = sqsum + x*x
        smallest = min(x, smallest)
        largest = max(x, largest)
    t1 = time.time()
    print round(t1-t0, 3), 'sec,',
    avg = total/n
    stddev = _sqrt(sqsum/n - avg*avg)
    print 'avg %g, stddev %g, min %g, max %g' % \
              (avg, stddev, smallest, largest)


def _test(N=2000):
    _test_generator(N, random, ())
    _test_generator(N, normalvariate, (0.0, 1.0))
    _test_generator(N, lognormvariate, (0.0, 1.0))
    _test_generator(N, vonmisesvariate, (0.0, 1.0))
    _test_generator(N, gammavariate, (0.01, 1.0))
    _test_generator(N, gammavariate, (0.1, 1.0))
    _test_generator(N, gammavariate, (0.1, 2.0))
    _test_generator(N, gammavariate, (0.5, 1.0))
    _test_generator(N, gammavariate, (0.9, 1.0))
    _test_generator(N, gammavariate, (1.0, 1.0))
    _test_generator(N, gammavariate, (2.0, 1.0))
    _test_generator(N, gammavariate, (20.0, 1.0))
    _test_generator(N, gammavariate, (200.0, 1.0))
    _test_generator(N, gauss, (0.0, 1.0))
    _test_generator(N, betavariate, (3.0, 3.0))
    _test_generator(N, triangular, (0.0, 1.0, 1.0/3.0))

# Create one instance, seeded from current time, and export its methods
# as module-level functions.  The functions share state across all uses
#(both in the user's code and in the Python libraries), but that's fine
# for most programs and is easier for the casual user than making them
# instantiate their own Random() instance.

_inst = Random()
seed = _inst.seed
random = _inst.random
uniform = _inst.uniform
triangular = _inst.triangular
randint = _inst.randint
choice = _inst.choice
randrange = _inst.randrange
sample = _inst.sample
shuffle = _inst.shuffle
normalvariate = _inst.normalvariate
lognormvariate = _inst.lognormvariate
expovariate = _inst.expovariate
vonmisesvariate = _inst.vonmisesvariate
gammavariate = _inst.gammavariate
gauss = _inst.gauss
betavariate = _inst.betavariate
paretovariate = _inst.paretovariate
weibullvariate = _inst.weibullvariate
getstate = _inst.getstate
setstate = _inst.setstate
jumpahead = _inst.jumpahead
getrandbits = _inst.getrandbits

if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/random.pyc                                                                        0100644 0000000 0000000 00000061610 13077704256 014410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s  d  Z  d d l m Z d d l m Z d d l m Z m	 Z
 d d l m Z m Z m Z m Z m Z d d l m Z m Z m Z m Z d d l m Z  d d l! m" Z# d d	 l$ Z% d
 d d d d d d d d d d d d d d d d d d d d d d  d! d" g Z& d# e d$  e d%  Z' d% e Z( e d&  Z) d' e d(  Z* d) Z+ d* e+ Z, d d	 l- Z- d
 e- j. f d+     YZ. d  e. f d,     YZ/ d" e. f d-     YZ0 d.   Z1 d/ d0  Z2 e.   Z3 e3 j4 Z4 e3 j5 Z5 e3 j6 Z6 e3 j7 Z7 e3 j8 Z8 e3 j9 Z9 e3 j: Z: e3 j; Z; e3 j< Z< e3 j= Z= e3 j> Z> e3 j? Z? e3 j@ Z@ e3 jA ZA e3 jB ZB e3 jC ZC e3 jD ZD e3 jE ZE e3 jF ZF e3 jG ZG e3 jH ZH e3 jI ZI eJ d1 k re2   n  d	 S(2   sP  Random variable generators.

    integers
    --------
           uniform within range

    sequences
    ---------
           pick random element
           pick random sample
           generate random permutation

    distributions on the real line:
    ------------------------------
           uniform
           triangular
           normal (Gaussian)
           lognormal
           negative exponential
           gamma
           beta
           pareto
           Weibull

    distributions on the circle (angles 0 to 2pi)
    ---------------------------------------------
           circular uniform
           von Mises

General notes on the underlying Mersenne Twister core generator:

* The period is 2**19937-1.
* It is one of the most extensively tested generators in existence.
* Without a direct way to compute N steps forward, the semantics of
  jumpahead(n) are weakened to simply jump to another distant state and rely
  on the large period to avoid overlapping sequences.
* The random() method is implemented in C, executes in a single Python step,
  and is, therefore, threadsafe.

i(   t   division(   t   warn(   t
   MethodTypet   BuiltinMethodType(   t   logt   expt   pit   et   ceil(   t   sqrtt   acost   cost   sin(   t   urandom(   t   hexlifyNt   Randomt   seedt   randomt   uniformt   randintt   choicet   samplet	   randranget   shufflet   normalvariatet   lognormvariatet   expovariatet   vonmisesvariatet   gammavariatet
   triangulart   gausst   betavariatet   paretovariatet   weibullvariatet   getstatet   setstatet	   jumpaheadt   WichmannHillt   getrandbitst   SystemRandomi   g      g       @g      @g      ?g      @i5   i   c           B   s*  e  Z d  Z d Z d d  Z d d  Z d   Z d   Z d   Z	 d   Z
 d   Z d	   Z d d
 e d e >d  Z d   Z e e d e >e e d  Z d   Z d d  Z d   Z d   Z d d d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z  d   Z! d   Z" RS(    s  Random number generator base class used by bound module functions.

    Used to instantiate instances of Random to get generators that don't
    share state.  Especially useful for multi-threaded programs, creating
    a different instance of Random for each thread, and using the jumpahead()
    method to ensure that the generated sequences seen by each thread don't
    overlap.

    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods: random(), seed(), getstate(), setstate() and jumpahead().
    Optionally, implement a getrandbits() method so that randrange() can cover
    arbitrarily large ranges.

    i   c         C   s   |  j  |  d |  _ d S(   se   Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().
        N(   R   t   Nonet
   gauss_next(   t   selft   x(    (    s   /usr/lib/python2.7/random.pyt   __init__[   s    c         C   s   | d k rd y t t t d   d  } Wqd t k
 r` d d l } t | j   d  } qd Xn  t t |   j |  d |  _	 d S(   s   Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.
        i	  i   iNi   (
   R(   t   longt   _hexlifyt   _urandomt   NotImplementedErrort   timet   superR   R   R)   (   R*   t   aR1   (    (    s   /usr/lib/python2.7/random.pyR   d   s    	c         C   s"   |  j  t t |   j   |  j f S(   s9   Return internal state; can be passed to setstate() later.(   t   VERSIONR2   R   R"   R)   (   R*   (    (    s   /usr/lib/python2.7/random.pyR"   y   s    c         C   s   | d } | d k rA | \ } } |  _  t t |   j |  n | d k r | \ } } |  _  y t d   | D  } Wn t k
 r } t |  n Xt t |   j |  n t d | |  j f   d S(   s:   Restore internal state from object returned by getstate().i    i   i   c         s   s   |  ] } t  |  d Vq d S(   i   i    NI       (   R-   (   t   .0R+   (    (    s   /usr/lib/python2.7/random.pys	   <genexpr>   s    s?   state with version %s passed to Random.setstate() of version %sN(   R)   R2   R   R#   t   tuplet
   ValueErrort	   TypeErrorR4   (   R*   t   statet   versiont   internalstateR   (    (    s   /usr/lib/python2.7/random.pyR#   }   s    
c         C   sW   t  |  t  |  j    } t t j d |  j   d  } t t |   j |  d S(   s   Change the internal state to one that is likely far away
        from the current state.  This method will not be in Py3.x,
        so it is better to simply reseed.
        t   sha512i   N(	   t   reprR"   t   intt   _hashlibt   newt	   hexdigestR2   R   R$   (   R*   t   nt   s(    (    s   /usr/lib/python2.7/random.pyR$      s    !c         C   s
   |  j    S(   N(   R"   (   R*   (    (    s   /usr/lib/python2.7/random.pyt   __getstate__   s    c         C   s   |  j  |  d  S(   N(   R#   (   R*   R9   (    (    s   /usr/lib/python2.7/random.pyt   __setstate__   s    c         C   s   |  j  d |  j   f S(   N(    (   t	   __class__R"   (   R*   (    (    s   /usr/lib/python2.7/random.pyt
   __reduce__   s    i   l    c         C   s  | |  } | | k r$ t  d  n  | d	 k ru | d k ri | | k rU |  j |  S| |  j   |  St  d  n  | |  } | | k r t  d  n  | | } | d k r | d k r | | k r | | |  j |   S| | | |  j   |   S| d k r!t  d | | | f  n  | |  }	 |	 | k rEt  d  n  |	 d k rf| |	 d |	 }
 n* |	 d k  r| |	 d |	 }
 n	 t  d  |
 d k rt  d  n  |
 | k r| |	 |  j |
  S| |	 | |  j   |
  S(
   s   Choose a random item from range(start, stop[, step]).

        This fixes the problem with randint() which includes the
        endpoint; in Python this is usually not what you want.

        s!   non-integer arg 1 for randrange()i    s   empty range for randrange()s    non-integer stop for randrange()i   s'   empty range for randrange() (%d,%d, %d)s    non-integer step for randrange()s   zero step for randrange()N(   R7   R(   t
   _randbelowR   (   R*   t   startt   stopt   stept   _intt	   _maxwidtht   istartt   istopt   widtht   istepRB   (    (    s   /usr/lib/python2.7/random.pyR      s@    

	c         C   s   |  j  | | d  S(   sJ   Return random integer in range [a, b], including both end points.
        i   (   R   (   R*   R3   t   b(    (    s   /usr/lib/python2.7/random.pyR      s    c   
      C   s   y |  j  } Wn t k
 r  nt Xt |  j  | k sH t |  | k r | d | | d d   } | |  }	 x |	 | k r | |  }	 qt W|	 S| | k r t d  n  | |  j   |  S(   s   Return a random int in the range [0,n)

        Handles the case where n has more bits than returned
        by a single call to the underlying generator.
        grZ|
 ?i   g       @sg   Underlying random() generator does not supply 
enough bits to choose from a population range this large(   R&   t   AttributeErrort   typeR   t   _warn(
   R*   RB   t   _logRL   RM   t   _Methodt   _BuiltinMethodR&   t   kt   r(    (    s   /usr/lib/python2.7/random.pyRH      s    'c         C   s   | t  |  j   t |   S(   s2   Choose a random element from a non-empty sequence.(   R>   R   t   len(   R*   t   seq(    (    s   /usr/lib/python2.7/random.pyR     s    c         C   s|   | d k r |  j } n  t } xW t t d t |    D]: } | |   | d  } | | | | | | <| | <q: Wd S(   s   x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        i   N(   R(   R   R>   t   reversedt   xrangeR[   (   R*   R+   R   RL   t   it   j(    (    s   /usr/lib/python2.7/random.pyR     s    "c         C   s  t  |  } d | k o# | k n s7 t d   n  |  j } t } d	 g | } d } | d k r | d t t | d d   7} n  | | k s t | d  rt |  } xt	 |  D]A }	 | |   | |	  }
 | |
 | |	 <| | |	 d | |
 <q Wn y~ t
   } | j } xe t	 |  D]W }	 | |   |  }
 x# |
 | k re| |   |  }
 qCW| |
  | |
 | |	 <q'WWn? t t f k
 rt | t  r  n  |  j t |  |  SX| S(
   s8  Chooses k unique random elements from a population sequence.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use xrange as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(xrange(10000000), 60)
        i    s   sample larger than populationi   i   i   i   t   keysi   N(   R[   R7   R   R>   R(   t   _ceilRV   t   hasattrt   listR^   t   sett   addR8   t   KeyErrort
   isinstanceR   R6   (   R*   t
   populationRY   RB   R   RL   t   resultt   setsizet   poolR_   R`   t   selectedt   selected_add(    (    s   /usr/lib/python2.7/random.pyR   %  s:    	$		
c         C   s   | | | |  j    S(   sH   Get a random number in the range [a, b) or [a, b] depending on rounding.(   R   (   R*   R3   RR   (    (    s   /usr/lib/python2.7/random.pyR   f  s    g        g      ?c         C   s   |  j    } y( | d k r! d n | | | | } Wn t k
 rH | SX| | k ry d | } d | } | | } } n  | | | | | d S(   s   Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        g      ?g      ?N(   R   R(   t   ZeroDivisionError(   R*   t   lowt   hight   modet   ut   c(    (    s   /usr/lib/python2.7/random.pyR   l  s    	(

c         C   sh   |  j  } xP |   } d |   } t | d | } | | d } | t |  k r Pq q | | | S(   s\   Normal distribution.

        mu is the mean, and sigma is the standard deviation.

        g      ?g      ?g      @(   R   t   NV_MAGICCONSTRV   (   R*   t   mut   sigmaR   t   u1t   u2t   zt   zz(    (    s   /usr/lib/python2.7/random.pyR     s    		c         C   s   t  |  j | |   S(   s   Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.

        (   t   _expR   (   R*   Rv   Rw   (    (    s   /usr/lib/python2.7/random.pyR     s    c         C   s   t  d |  j    | S(   s^  Exponential distribution.

        lambd is 1.0 divided by the desired mean.  It should be
        nonzero.  (The parameter would be called "lambda", but that is
        a reserved word in Python.)  Returned values range from 0 to
        positive infinity if lambd is positive, and from negative
        infinity to 0 if lambd is negative.

        g      ?(   RV   R   (   R*   t   lambd(    (    s   /usr/lib/python2.7/random.pyR     s    c         C   s  |  j  } | d k r  t |   Sd | } | t d | |  } xe |   } t t |  } | | | } |   }	 |	 d | | k  s |	 d | t |  k rE PqE qE d | }
 |
 | d |
 | } |   } | d k r | t |  t } n | t |  t } | S(   sF  Circular data distribution.

        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.

        g>g      ?g      ?(   R   t   TWOPIt   _sqrtt   _cost   _piR|   t   _acos(   R*   Rv   t   kappaR   RC   RZ   Rx   Rz   t   dRy   t   qt   ft   u3t   theta(    (    s   /usr/lib/python2.7/random.pyR     s&    	
		.
	c         C   s  | d k s | d k r$ t  d  n  |  j } | d k rt d | d  } | t } | | } x|   } d | k  o d k  n s qd n  d |   } t | d |  | }	 | t |	  }
 | | | } | | |	 |
 } | t d | d k s| t |  k rd |
 | Sqd n | d k r\|   } x | d k rL|   } q4Wt |  | Sx |   } t | t } | | } | d k r| d | }
 n t | | |  }
 |   } | d k r| |
 | d k rPqq_| t |
  k r_Pq_q_|
 | Sd S(	   sZ  Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha > 0 and beta > 0.

        The probability distribution function is:

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha

        g        s*   gammavariate: alpha and beta must be > 0.0g      ?g       @gHz>gP?g      @N(   R7   R   R   t   LOG4RV   R|   t   SG_MAGICCONSTt   _e(   R*   t   alphat   betaR   t   ainvt   bbbt   cccRx   Ry   t   vR+   Rz   RZ   Rs   RR   t   p(    (    s   /usr/lib/python2.7/random.pyR     sJ    	

	*		
	c         C   s   |  j  } |  j } d |  _ | d k rw |   t } t d t d |     } t |  | } t |  | |  _ n  | | | S(   s   Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.

        Not thread-safe without a lock around calls.

        g       g      ?N(   R   R)   R(   R~   R   RV   R   t   _sin(   R*   Rv   Rw   R   Rz   t   x2pit   g2rad(    (    s   /usr/lib/python2.7/random.pyR   2  s    			c         C   s>   |  j  | d  } | d k r" d S| | |  j  | d  Sd S(   s   Beta distribution.

        Conditions on the parameters are alpha > 0 and beta > 0.
        Returned values range between 0 and 1.

        g      ?i    g        N(   R   (   R*   R   R   t   y(    (    s   /usr/lib/python2.7/random.pyR   g  s    
c         C   s%   d |  j    } d t | d |  S(   s3   Pareto distribution.  alpha is the shape parameter.g      ?(   R   t   pow(   R*   R   Rs   (    (    s   /usr/lib/python2.7/random.pyR    y  s    c         C   s,   d |  j    } | t t |  d |  S(   sf   Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.

        g      ?(   R   R   RV   (   R*   R   R   Rs   (    (    s   /usr/lib/python2.7/random.pyR!     s    N(#   t   __name__t
   __module__t   __doc__R4   R(   R,   R   R"   R#   R$   RD   RE   RG   R>   t   BPFR   R   RV   t   _MethodTypet   _BuiltinMethodTypeRH   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   (    (    (    s   /usr/lib/python2.7/random.pyR   H   s8   							?			A					0	H	5			c           B   s\   e  Z d  Z d	 d  Z d   Z d   Z d   Z d   Z d d d d  Z	 d	 d  Z
 RS(
   i   c         C   s  | d k rd y t t t d   d  } Wqd t k
 r` d d l } t | j   d  } qd Xn  t | t t f  s t |  } n  t	 | d  \ } } t	 | d  \ } } t	 | d  \ } } t |  d t |  d t |  d f |  _
 d |  _ d S(	   s  Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If a is not None or an int or long, hash(a) is used instead.

        If a is an int or long, a is used directly.  Distinct values between
        0 and 27814431486575L inclusive are guaranteed to yield distinct
        internal states (this guarantee is specific to the default
        Wichmann-Hill generator).
        i   iNi   i<v  ibv  irv  i   (   R(   R-   R.   R/   R0   R1   Rh   R>   t   hasht   divmodt   _seedR)   (   R*   R3   R1   R+   R   Rz   (    (    s   /usr/lib/python2.7/random.pyR     s    0c         C   sj   |  j  \ } } } d | d } d | d } d | d } | | | f |  _  | d | d | d	 d
 S(   s3   Get the next random number in the range [0.0, 1.0).i   i=v  i   icv  i   isv  g    @@g    @g    @g      ?(   R   (   R*   R+   R   Rz   (    (    s   /usr/lib/python2.7/random.pyR     s    c         C   s   |  j  |  j |  j f S(   s9   Return internal state; can be passed to setstate() later.(   R4   R   R)   (   R*   (    (    s   /usr/lib/python2.7/random.pyR"     s    c         C   sK   | d } | d k r. | \ } |  _  |  _ n t d | |  j f   d S(   s:   Restore internal state from object returned by getstate().i    i   s?   state with version %s passed to Random.setstate() of version %sN(   R   R)   R7   R4   (   R*   R9   R:   (    (    s   /usr/lib/python2.7/random.pyR#     s
    
c         C   s   | d k s t  d   n  |  j \ } } } t | t d | d   d } t | t d | d   d } t | t d | d   d } | | | f |  _ d	 S(
   s  Act as if n calls to random() were made, but quickly.

        n is an int, greater than or equal to 0.

        Example use:  If you have 2 threads and know that each will
        consume no more than a million random numbers, create two Random
        objects r1 and r2, then do
            r2.setstate(r1.getstate())
            r2.jumpahead(1000000)
        Then r1 and r2 will use guaranteed-disjoint segments of the full
        period.
        i    s   n must be >= 0i   i=v  i   icv  i   isv  N(   R7   R   R>   R   (   R*   RB   R+   R   Rz   (    (    s   /usr/lib/python2.7/random.pyR$     s       i    c         C   s  t  |  t  |  k o4 t  |  k o4 t k n sH t d   n  d | k o_ d k  n o d | k o{ d k  n o d | k o d k  n s t d   n  d | k o | k o | k n rNd d l } t | j   d  } t | d @| d ?A } t | d  \ } } t | d  \ } } t | d  \ } } n  | pWd	 | p`d	 | pid	 f |  _ d |  _	 d S(
   sj   Set the Wichmann-Hill seed from (x, y, z).

        These must be integers in the range [0, 256).
        s   seeds must be integersi    i   s   seeds must be in range(0, 256)iNi i   i   (
   RT   R>   R8   R7   R1   R-   R   R   R(   R)   (   R*   R+   R   Rz   R1   t   t(    (    s   /usr/lib/python2.7/random.pyt   __whseed  s    9T'$c         C   s   | d k r |  j   d St |  } t | d  \ } } t | d  \ } } t | d  \ } } | | d pv d } | | d p d } | | d p d } |  j | | |  d S(   sb  Seed from hashable object's hash code.

        None or no argument seeds from current time.  It is not guaranteed
        that objects with distinct hash codes lead to distinct internal
        states.

        This is obsolete, provided for compatibility with the seed routine
        used prior to Python 2.1.  Use the .seed() method instead.
        Ni   i   (   R(   t   _WichmannHill__whseedR   R   (   R*   R3   R+   R   Rz   (    (    s   /usr/lib/python2.7/random.pyt   whseed  s    
N(   R   R   R4   R(   R   R   R"   R#   R$   R   R   (    (    (    s   /usr/lib/python2.7/random.pyR%     s   			
	c           B   sF   e  Z d  Z d   Z d   Z d   Z e Z Z d   Z e Z	 Z
 RS(   s   Alternate random number generator using sources provided
    by the operating system (such as /dev/urandom on Unix or
    CryptGenRandom on Windows).

     Not available on all systems (see os.urandom() for details).
    c         C   s!   t  t t d   d  d ?t S(   s3   Get the next random number in the range [0.0, 1.0).i   i   i   (   R-   R.   R/   t	   RECIP_BPF(   R*   (    (    s   /usr/lib/python2.7/random.pyR   -  s    c         C   su   | d k r t  d   n  | t |  k r< t d   n  | d d } t t t |   d  } | | d | ?S(   s>   getrandbits(k) -> x.  Generates a long int with k random bits.i    s(   number of bits must be greater than zeros#   number of bits should be an integeri   i   i   (   R7   R>   R8   R-   R.   R/   (   R*   RY   t   bytesR+   (    (    s   /usr/lib/python2.7/random.pyR&   1  s    c         O   s   d S(   s<   Stub method.  Not used for a system random number generator.N(   R(   (   R*   t   argst   kwds(    (    s   /usr/lib/python2.7/random.pyt   _stub;  s    c         O   s   t  d   d S(   sA   Method should not be called for a system random number generator.s*   System entropy source does not have state.N(   R0   (   R*   R   R   (    (    s   /usr/lib/python2.7/random.pyt   _notimplemented@  s    (   R   R   R   R   R&   R   R   R$   R   R"   R#   (    (    (    s   /usr/lib/python2.7/random.pyR'   %  s   		
	
	c         C   s   d d  l  } |  Gd G| j GHd } d } d } d } | j    } xV t |   D]H }	 | |   }
 | |
 7} | |
 |
 } t |
 |  } t |
 |  } qM W| j    } t | | d  Gd G| |  } t | |  | |  } d | | | | f GHd  S(	   Nit   timesg        g    _Bg    _i   s   sec,s!   avg %g, stddev %g, min %g, max %g(   R1   R   t   ranget   mint   maxt   roundR   (   RB   t   funcR   R1   t   totalt   sqsumt   smallestt   largestt   t0R_   R+   t   t1t   avgt   stddev(    (    s   /usr/lib/python2.7/random.pyt   _test_generatorG  s&    

i  c         C   s  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d  t  |  t d d d f  d  S(   Ng        g      ?g{Gz?g?g       @g      ?g?g      4@g      i@g      @(    (   g        g      ?(   g        g      ?(   g        g      ?(   g{Gz?g      ?(   g?g      ?(   g?g       @(   g      ?g      ?(   g?g      ?(   g      ?g      ?(   g       @g      ?(   g      4@g      ?(   g      i@g      ?(   g        g      ?(   g      @g      @gUUUUUU?(	   R   R   R   R   R   R   R   R   R   (   t   N(    (    s   /usr/lib/python2.7/random.pyt   _test]  s     t   __main__(K   R   t
   __future__R    t   warningsR   RU   t   typesR   R   R   R   t   mathR   RV   R   R|   R   R   R   R   R   Rb   R	   R   R
   R   R   R   R   R   t   osR   R/   t   binasciiR   R.   t   hashlibR?   t   __all__Ru   R~   R   R   R   R   t   _randomR   R%   R'   R   R   t   _instR   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   R"   R#   R$   R&   R   (    (    (    s   /usr/lib/python2.7/random.pyt   <module>(   sj   ("	
  I"																								                                                                                                                        usr/lib/python2.7/re.py                                                                             0100644 0000000 0000000 00000032157 12734733742 013400  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #
# Secret Labs' Regular Expression Engine
#
# re-compatible interface for the sre matching engine
#
# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
#
# This version of the SRE library can be redistributed under CNRI's
# Python 1.6 license.  For any other use, please contact Secret Labs
# AB (info@pythonware.com).
#
# Portions of this engine have been developed in cooperation with
# CNRI.  Hewlett-Packard provided funding for 1.6 integration and
# other compatibility work.
#

r"""Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl.  It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves.  You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ... matches next, but doesn't consume the string.
    (?!...)  Matches if ... doesn't match next.
    (?<=...) Matches if preceded by ... (must be fixed length).
    (?<!...) Matches if not preceded by ... (must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9].
    \D       Matches any non-digit character; equivalent to the set [^0-9].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match    Match a regular expression pattern to the beginning of a string.
    search   Search a string for the presence of a pattern.
    sub      Substitute occurrences of a pattern found in a string.
    subn     Same as sub, but also return the number of substitutions made.
    split    Split a string by the occurrences of a pattern.
    findall  Find all occurrences of a pattern in a string.
    finditer Return an iterator yielding a match object for each match.
    compile  Compile a pattern into a RegexObject.
    purge    Clear the regular expression cache.
    escape   Backslash all non-alphanumerics in a string.

Some of the functions in this module takes flags as optional parameters:
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.

This module also defines an exception 'error'.

"""

import sys
import sre_compile
import sre_parse
try:
    import _locale
except ImportError:
    _locale = None

# public symbols
__all__ = [ "match", "search", "sub", "subn", "split", "findall",
    "compile", "purge", "template", "escape", "I", "L", "M", "S", "X",
    "U", "IGNORECASE", "LOCALE", "MULTILINE", "DOTALL", "VERBOSE",
    "UNICODE", "error" ]

__version__ = "2.2.1"

# flags
I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE # ignore case
L = LOCALE = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale
U = UNICODE = sre_compile.SRE_FLAG_UNICODE # assume unicode locale
M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline
S = DOTALL = sre_compile.SRE_FLAG_DOTALL # make dot match newline
X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments

# sre extensions (experimental, don't rely on these)
T = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking
DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation

# sre exception
error = sre_compile.error

# --------------------------------------------------------------------
# public interface

def match(pattern, string, flags=0):
    """Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).match(string)

def search(pattern, string, flags=0):
    """Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).search(string)

def sub(pattern, repl, string, count=0, flags=0):
    """Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it's passed the match object and must return
    a replacement string to be used."""
    return _compile(pattern, flags).sub(repl, string, count)

def subn(pattern, repl, string, count=0, flags=0):
    """Return a 2-tuple containing (new_string, number).
    new_string is the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in the source
    string by the replacement repl.  number is the number of
    substitutions that were made. repl can be either a string or a
    callable; if a string, backslash escapes in it are processed.
    If it is a callable, it's passed the match object and must
    return a replacement string to be used."""
    return _compile(pattern, flags).subn(repl, string, count)

def split(pattern, string, maxsplit=0, flags=0):
    """Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings."""
    return _compile(pattern, flags).split(string, maxsplit)

def findall(pattern, string, flags=0):
    """Return a list of all non-overlapping matches in the string.

    If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern
    has more than one group.

    Empty matches are included in the result."""
    return _compile(pattern, flags).findall(string)

if sys.hexversion >= 0x02020000:
    __all__.append("finditer")
    def finditer(pattern, string, flags=0):
        """Return an iterator over all non-overlapping matches in the
        string.  For each match, the iterator returns a match object.

        Empty matches are included in the result."""
        return _compile(pattern, flags).finditer(string)

def compile(pattern, flags=0):
    "Compile a regular expression pattern, returning a pattern object."
    return _compile(pattern, flags)

def purge():
    "Clear the regular expression cache"
    _cache.clear()
    _cache_repl.clear()

def template(pattern, flags=0):
    "Compile a template pattern, returning a pattern object"
    return _compile(pattern, flags|T)

_alphanum = frozenset(
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")

def escape(pattern):
    "Escape all non-alphanumeric characters in pattern."
    s = list(pattern)
    alphanum = _alphanum
    for i, c in enumerate(pattern):
        if c not in alphanum:
            if c == "\000":
                s[i] = "\\000"
            else:
                s[i] = "\\" + c
    return pattern[:0].join(s)

# --------------------------------------------------------------------
# internals

_cache = {}
_cache_repl = {}

_pattern_type = type(sre_compile.compile("", 0))

_MAXCACHE = 100

def _compile(*key):
    # internal: compile pattern
    pattern, flags = key
    bypass_cache = flags & DEBUG
    if not bypass_cache:
        cachekey = (type(key[0]),) + key
        try:
            p, loc = _cache[cachekey]
            if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE):
                return p
        except KeyError:
            pass
    if isinstance(pattern, _pattern_type):
        if flags:
            raise ValueError('Cannot process flags argument with a compiled pattern')
        return pattern
    if not sre_compile.isstring(pattern):
        raise TypeError, "first argument must be string or compiled pattern"
    try:
        p = sre_compile.compile(pattern, flags)
    except error, v:
        raise error, v # invalid expression
    if not bypass_cache:
        if len(_cache) >= _MAXCACHE:
            _cache.clear()
        if p.flags & LOCALE:
            if not _locale:
                return p
            loc = _locale.setlocale(_locale.LC_CTYPE)
        else:
            loc = None
        _cache[cachekey] = p, loc
    return p

def _compile_repl(*key):
    # internal: compile replacement pattern
    p = _cache_repl.get(key)
    if p is not None:
        return p
    repl, pattern = key
    try:
        p = sre_parse.parse_template(repl, pattern)
    except error, v:
        raise error, v # invalid expression
    if len(_cache_repl) >= _MAXCACHE:
        _cache_repl.clear()
    _cache_repl[key] = p
    return p

def _expand(pattern, match, template):
    # internal: match.expand implementation hook
    template = sre_parse.parse_template(template, pattern)
    return sre_parse.expand_template(template, match)

def _subx(pattern, template):
    # internal: pattern.sub/subn implementation helper
    template = _compile_repl(template, pattern)
    if not template[0] and len(template[1]) == 1:
        # literal replacement
        return template[1][0]
    def filter(match, template=template):
        return sre_parse.expand_template(template, match)
    return filter

# register myself for pickling

import copy_reg

def _pickle(p):
    return _compile, (p.pattern, p.flags)

copy_reg.pickle(_pattern_type, _pickle, _compile)

# --------------------------------------------------------------------
# experimental stuff (see python-dev discussions for details)

class Scanner:
    def __init__(self, lexicon, flags=0):
        from sre_constants import BRANCH, SUBPATTERN
        self.lexicon = lexicon
        # combine phrases into a compound pattern
        p = []
        s = sre_parse.Pattern()
        s.flags = flags
        for phrase, action in lexicon:
            p.append(sre_parse.SubPattern(s, [
                (SUBPATTERN, (len(p)+1, sre_parse.parse(phrase, flags))),
                ]))
        s.groups = len(p)+1
        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])
        self.scanner = sre_compile.compile(p)
    def scan(self, string):
        result = []
        append = result.append
        match = self.scanner.scanner(string).match
        i = 0
        while 1:
            m = match()
            if not m:
                break
            j = m.end()
            if i == j:
                break
            action = self.lexicon[m.lastindex-1][1]
            if hasattr(action, '__call__'):
                self.match = m
                action = action(self, m.group())
            if action is not None:
                append(action)
            i = j
        return result, string[i:]
                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python2.7/re.pyc                                                                            0100644 0000000 0000000 00000032072 13077704256 013536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   sQ  d  Z  d d l Z d d l Z d d l Z y d d l Z Wn e k
 rS d Z n Xd d d d d d d	 d
 d d d d d d d d d d d d d d d g Z d Z e j	 Z
 Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z Z e j Z e j  Z  d d  Z! d d  Z" d d d  Z# d d d  Z$ d d d   Z% d d!  Z& e j' d" k re j( d#  d d$  Z) n  d d%  Z* d&   Z+ d d'  Z, e- d(  Z. d)   Z/ i  Z0 i  Z1 e2 e j* d* d   Z3 d+ Z4 d,   Z5 d-   Z6 d.   Z7 d/   Z8 d d l9 Z9 d0   Z: e9 j; e3 e: e5  d1 d3 d2     YZ< d S(4   s  Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl.  It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves.  You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ... matches next, but doesn't consume the string.
    (?!...)  Matches if ... doesn't match next.
    (?<=...) Matches if preceded by ... (must be fixed length).
    (?<!...) Matches if not preceded by ... (must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9].
    \D       Matches any non-digit character; equivalent to the set [^0-9].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].
    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match    Match a regular expression pattern to the beginning of a string.
    search   Search a string for the presence of a pattern.
    sub      Substitute occurrences of a pattern found in a string.
    subn     Same as sub, but also return the number of substitutions made.
    split    Split a string by the occurrences of a pattern.
    findall  Find all occurrences of a pattern in a string.
    finditer Return an iterator yielding a match object for each match.
    compile  Compile a pattern into a RegexObject.
    purge    Clear the regular expression cache.
    escape   Backslash all non-alphanumerics in a string.

Some of the functions in this module takes flags as optional parameters:
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.

This module also defines an exception 'error'.

iNt   matcht   searcht   subt   subnt   splitt   findallt   compilet   purget   templatet   escapet   It   Lt   Mt   St   Xt   Ut
   IGNORECASEt   LOCALEt	   MULTILINEt   DOTALLt   VERBOSEt   UNICODEt   errors   2.2.1i    c         C   s   t  |  |  j |  S(   sq   Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found.(   t   _compileR    (   t   patternt   stringt   flags(    (    s   /usr/lib/python2.7/re.pyR       s    c         C   s   t  |  |  j |  S(   st   Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    c         C   s   t  |  |  j | | |  S(   sZ  Return the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in string by the
    replacement repl.  repl can be either a string or a callable;
    if a string, backslash escapes in it are processed.  If it is
    a callable, it's passed the match object and must return
    a replacement string to be used.(   R   R   (   R   t   replR   t   countR   (    (    s   /usr/lib/python2.7/re.pyR      s    c         C   s   t  |  |  j | | |  S(   s  Return a 2-tuple containing (new_string, number).
    new_string is the string obtained by replacing the leftmost
    non-overlapping occurrences of the pattern in the source
    string by the replacement repl.  number is the number of
    substitutions that were made. repl can be either a string or a
    callable; if a string, backslash escapes in it are processed.
    If it is a callable, it's passed the match object and must
    return a replacement string to be used.(   R   R   (   R   R   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    	c         C   s   t  |  |  j | |  S(   st   Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings.(   R   R   (   R   R   t   maxsplitR   (    (    s   /usr/lib/python2.7/re.pyR      s    c         C   s   t  |  |  j |  S(   s  Return a list of all non-overlapping matches in the string.

    If one or more groups are present in the pattern, return a
    list of groups; this will be a list of tuples if the pattern
    has more than one group.

    Empty matches are included in the result.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    i  t   finditerc         C   s   t  |  |  j |  S(   s   Return an iterator over all non-overlapping matches in the
        string.  For each match, the iterator returns a match object.

        Empty matches are included in the result.(   R   R   (   R   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    c         C   s   t  |  |  S(   sA   Compile a regular expression pattern, returning a pattern object.(   R   (   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    c           C   s   t  j   t j   d S(   s"   Clear the regular expression cacheN(   t   _cachet   cleart   _cache_repl(    (    (    s   /usr/lib/python2.7/re.pyR      s    
c         C   s   t  |  | t B S(   s6   Compile a template pattern, returning a pattern object(   R   t   T(   R   R   (    (    s   /usr/lib/python2.7/re.pyR      s    t>   abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789c         C   sv   t  |   } t } xP t |   D]B \ } } | | k r | d k rP d | | <qa d | | | <q q W|  d  j |  S(   s2   Escape all non-alphanumeric characters in pattern.t    s   \000s   \i    (   t   listt	   _alphanumt	   enumeratet   join(   R   t   st   alphanumt   it   c(    (    s   /usr/lib/python2.7/re.pyR	      s    t    id   c          G   sl  |  \ } } | t  @} | s t |  d  f |  } y< t | \ } } | d  k sj | t j t j  k rn | SWq t k
 r q Xn  t | t	  r | r t
 d   n  | St j |  s t d  n  y t j | |  } Wn t k
 r } t |  n X| sht t  t k r#t j   n  | j t @rOt s:| St j t j  } n d  } | | f t | <n  | S(   Ni    s5   Cannot process flags argument with a compiled patterns1   first argument must be string or compiled pattern(   t   DEBUGt   typeR   t   Nonet   _localet	   setlocalet   LC_CTYPEt   KeyErrort
   isinstancet   _pattern_typet
   ValueErrort   sre_compilet   isstringt	   TypeErrorR   R   t   lent	   _MAXCACHER    R   R   (   t   keyR   R   t   bypass_cachet   cachekeyt   pt   loct   v(    (    s   /usr/lib/python2.7/re.pyR      s<    
$c          G   s   t  j |   } | d  k	 r | S|  \ } } y t j | |  } Wn t k
 r_ } t |  n Xt t   t k r t  j   n  | t  |  <| S(   N(	   R!   t   getR0   t	   sre_parset   parse_templateR   R;   R<   R    (   R=   R@   R   R   RB   (    (    s   /usr/lib/python2.7/re.pyt   _compile_repl  s    
c         C   s"   t  j | |   } t  j | |  S(   N(   RD   RE   t   expand_template(   R   R    R   (    (    s   /usr/lib/python2.7/re.pyt   _expand  s    c         C   sL   t  | |   } | d r< t | d  d k r< | d d S| d  } | S(   Ni    i   c         S   s   t  j | |   S(   N(   RD   RG   (   R    R   (    (    s   /usr/lib/python2.7/re.pyt   filter"  s    (   RF   R;   (   R   R   RI   (    (    s   /usr/lib/python2.7/re.pyt   _subx  s
    !c         C   s   t  |  j |  j f f S(   N(   R   R   R   (   R@   (    (    s   /usr/lib/python2.7/re.pyt   _pickle*  s    t   Scannerc           B   s   e  Z d  d  Z d   Z RS(   i    c   	   	   C   s   d d l  m } m } | |  _ g  } t j   } | | _ xR | D]J \ } } | j t j | | t	 |  d t j
 | |  f f g   qA Wt	 |  d | _ t j | | d  | f f g  } t j |  |  _ d  S(   Ni(   t   BRANCHt
   SUBPATTERNi   (   t   sre_constantsRM   RN   t   lexiconRD   t   PatternR   t   appendt
   SubPatternR;   t   parset   groupsR0   R8   R   t   scanner(	   t   selfRP   R   RM   RN   R@   R)   t   phraset   action(    (    s   /usr/lib/python2.7/re.pyt   __init__3  s    		3!c   	      C   s   g  } | j  } |  j j |  j } d } x |   } | s@ Pn  | j   } | | k r\ Pn  |  j | j d d } t | d  r | |  _ | |  | j    } n  | d  k	 r | |  n  | } q- | | | f S(   Ni    i   t   __call__(	   RR   RV   R    t   endRP   t	   lastindext   hasattrt   groupR0   (	   RW   R   t   resultRR   R    R+   t   mt   jRY   (    (    s   /usr/lib/python2.7/re.pyt   scanA  s&    				(   t   __name__t
   __module__RZ   Rc   (    (    (    s   /usr/lib/python2.7/re.pyRL   2  s   (    (=   t   __doc__t   sysR8   RD   R1   t   ImportErrorR0   t   __all__t   __version__t   SRE_FLAG_IGNORECASER
   R   t   SRE_FLAG_LOCALER   R   t   SRE_FLAG_UNICODER   R   t   SRE_FLAG_MULTILINER   R   t   SRE_FLAG_DOTALLR   R   t   SRE_FLAG_VERBOSER   R   t   SRE_FLAG_TEMPLATER"   t   TEMPLATEt   SRE_FLAG_DEBUGR.   R   R    R   R   R   R   R   t
   hexversionRR   R   R   R   R   t	   frozensetR&   R	   R   R!   R/   R6   R<   R   RF   RH   RJ   t   copy_regRK   t   pickleRL   (    (    (    s   /usr/lib/python2.7/re.pyt   <module>f   s`   
			
				"				                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/repr.py                                                                           0100644 0000000 0000000 00000010310 12734733742 013725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Redo the builtin repr() (representation) but with limits on most sizes."""

__all__ = ["Repr","repr"]

import __builtin__
from itertools import islice

class Repr:

    def __init__(self):
        self.maxlevel = 6
        self.maxtuple = 6
        self.maxlist = 6
        self.maxarray = 5
        self.maxdict = 4
        self.maxset = 6
        self.maxfrozenset = 6
        self.maxdeque = 6
        self.maxstring = 30
        self.maxlong = 40
        self.maxother = 20

    def repr(self, x):
        return self.repr1(x, self.maxlevel)

    def repr1(self, x, level):
        typename = type(x).__name__
        if ' ' in typename:
            parts = typename.split()
            typename = '_'.join(parts)
        if hasattr(self, 'repr_' + typename):
            return getattr(self, 'repr_' + typename)(x, level)
        else:
            s = __builtin__.repr(x)
            if len(s) > self.maxother:
                i = max(0, (self.maxother-3)//2)
                j = max(0, self.maxother-3-i)
                s = s[:i] + '...' + s[len(s)-j:]
            return s

    def _repr_iterable(self, x, level, left, right, maxiter, trail=''):
        n = len(x)
        if level <= 0 and n:
            s = '...'
        else:
            newlevel = level - 1
            repr1 = self.repr1
            pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]
            if n > maxiter:  pieces.append('...')
            s = ', '.join(pieces)
            if n == 1 and trail:  right = trail + right
        return '%s%s%s' % (left, s, right)

    def repr_tuple(self, x, level):
        return self._repr_iterable(x, level, '(', ')', self.maxtuple, ',')

    def repr_list(self, x, level):
        return self._repr_iterable(x, level, '[', ']', self.maxlist)

    def repr_array(self, x, level):
        header = "array('%s', [" % x.typecode
        return self._repr_iterable(x, level, header, '])', self.maxarray)

    def repr_set(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'set([', '])', self.maxset)

    def repr_frozenset(self, x, level):
        x = _possibly_sorted(x)
        return self._repr_iterable(x, level, 'frozenset([', '])',
                                   self.maxfrozenset)

    def repr_deque(self, x, level):
        return self._repr_iterable(x, level, 'deque([', '])', self.maxdeque)

    def repr_dict(self, x, level):
        n = len(x)
        if n == 0: return '{}'
        if level <= 0: return '{...}'
        newlevel = level - 1
        repr1 = self.repr1
        pieces = []
        for key in islice(_possibly_sorted(x), self.maxdict):
            keyrepr = repr1(key, newlevel)
            valrepr = repr1(x[key], newlevel)
            pieces.append('%s: %s' % (keyrepr, valrepr))
        if n > self.maxdict: pieces.append('...')
        s = ', '.join(pieces)
        return '{%s}' % (s,)

    def repr_str(self, x, level):
        s = __builtin__.repr(x[:self.maxstring])
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = __builtin__.repr(x[:i] + x[len(x)-j:])
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_long(self, x, level):
        s = __builtin__.repr(x) # XXX Hope this isn't too slow...
        if len(s) > self.maxlong:
            i = max(0, (self.maxlong-3)//2)
            j = max(0, self.maxlong-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_instance(self, x, level):
        try:
            s = __builtin__.repr(x)
            # Bugs in x.__repr__() can cause arbitrary
            # exceptions -- then make up something
        except Exception:
            return '<%s instance at %x>' % (x.__class__.__name__, id(x))
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = s[:i] + '...' + s[len(s)-j:]
        return s


def _possibly_sorted(x):
    # Since not all sequences of items can be sorted and comparison
    # functions may raise arbitrary exceptions, return an unsorted
    # sequence in that case.
    try:
        return sorted(x)
    except Exception:
        return list(x)

aRepr = Repr()
repr = aRepr.repr
                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/repr.pyc                                                                          0100644 0000000 0000000 00000012347 13077704256 014103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s`   d  Z  d d g Z d d l Z d d l m Z d d d     YZ d   Z e   Z e j Z d S(	   sG   Redo the builtin repr() (representation) but with limits on most sizes.t   Reprt   repriN(   t   islicec           B   s   e  Z d    Z d   Z d   Z d d  Z d   Z d   Z d   Z d   Z	 d	   Z
 d
   Z d   Z d   Z d   Z d   Z RS(   c         C   sg   d |  _  d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _ d |  _	 d |  _
 d  S(   Ni   i   i   i   i(   i   (   t   maxlevelt   maxtuplet   maxlistt   maxarrayt   maxdictt   maxsett   maxfrozensett   maxdequet	   maxstringt   maxlongt   maxother(   t   self(    (    s   /usr/lib/python2.7/repr.pyt   __init__
   s    										c         C   s   |  j  | |  j  S(   N(   t   repr1R   (   R   t   x(    (    s   /usr/lib/python2.7/repr.pyR      s    c         C   s   t  |  j } d | k r9 | j   } d j |  } n  t |  d |  rf t |  d |  | |  St j |  } t |  |  j	 k r t
 d |  j	 d d  } t
 d |  j	 d |  } | |  d | t |  | } n  | Sd  S(   Nt    t   _t   repr_i    i   i   s   ...(   t   typet   __name__t   splitt   joint   hasattrt   getattrt   __builtin__R   t   lenR   t   max(   R   R   t   levelt   typenamet   partst   st   it   j(    (    s   /usr/lib/python2.7/repr.pyR      s    #t    c         C   s   t  |  } | d k r' | r' d } n | d }	 |  j }
 g  t | |  D] } |
 | |	  ^ qJ } | | k r | j d  n  d j |  } | d k r | r | | } n  d | | | f S(   Ni    s   ...i   s   , s   %s%s%s(   R   R   R   t   appendR   (   R   R   R   t   leftt   rightt   maxitert   trailt   nR!   t   newlevelR   t   elemt   pieces(    (    s   /usr/lib/python2.7/repr.pyt   _repr_iterable)   s    	
	+  c         C   s   |  j  | | d d |  j d  S(   Nt   (t   )t   ,(   R.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt
   repr_tuple6   s    c         C   s   |  j  | | d d |  j  S(   Nt   [t   ](   R.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_list9   s    c         C   s)   d | j  } |  j | | | d |  j  S(   Ns   array('%s', [s   ])(   t   typecodeR.   R   (   R   R   R   t   header(    (    s   /usr/lib/python2.7/repr.pyt
   repr_array<   s    c         C   s(   t  |  } |  j | | d d |  j  S(   Ns   set([s   ])(   t   _possibly_sortedR.   R   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt   repr_set@   s    c         C   s(   t  |  } |  j | | d d |  j  S(   Ns   frozenset([s   ])(   R9   R.   R	   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt   repr_frozensetD   s    c         C   s   |  j  | | d d |  j  S(   Ns   deque([s   ])(   R.   R
   (   R   R   R   (    (    s   /usr/lib/python2.7/repr.pyt
   repr_dequeI   s    c         C   s   t  |  } | d k r d S| d k r, d S| d } |  j } g  } xY t t |  |  j  D]? } | | |  } | | | |  }	 | j d | |	 f  q^ W| |  j k r | j d  n  d j |  }
 d |
 f S(	   Ni    s   {}s   {...}i   s   %s: %ss   ...s   , s   {%s}(   R   R   R   R9   R   R%   R   (   R   R   R   R*   R+   R   R-   t   keyt   keyreprt   valreprR!   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_dictL   s       
	 c         C   s   t  j | |  j   } t |  |  j k r t d |  j d d  } t d |  j d |  } t  j | |  | t |  |  } | |  d | t |  | } n  | S(   Ni    i   i   s   ...(   R   R   R   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt   repr_str[   s    %#c         C   s   t  j |  } t |  |  j k r{ t d |  j d d  } t d |  j d |  } | |  d | t |  | } n  | S(   Ni    i   i   s   ...(   R   R   R   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt	   repr_longd   s    #c         C   s   y t  j |  } Wn( t k
 r= d | j j t |  f SXt |  |  j k r t d |  j d d  } t d |  j d |  } | |  d | t |  | } n  | S(   Ns   <%s instance at %x>i    i   i   s   ...(	   R   R   t	   Exceptiont	   __class__R   t   idR   R   R   (   R   R   R   R!   R"   R#   (    (    s   /usr/lib/python2.7/repr.pyt   repr_instancel   s    #(   R   t
   __module__R   R   R   R.   R2   R5   R8   R:   R;   R<   R@   RA   RB   RF   (    (    (    s   /usr/lib/python2.7/repr.pyR       s   													c         C   s-   y t  |   SWn t k
 r( t |   SXd  S(   N(   t   sortedRC   t   list(   R   (    (    s   /usr/lib/python2.7/repr.pyR9   z   s    (    (	   t   __doc__t   __all__R   t	   itertoolsR   R    R9   t   aReprR   (    (    (    s   /usr/lib/python2.7/repr.pyt   <module>   s   r			                                                                                                                                                                                                                                                                                         usr/lib/python2.7/rexec.py                                                                          0100644 0000000 0000000 00000047264 12734733742 014105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Restricted execution facilities.

The class RExec exports methods r_exec(), r_eval(), r_execfile(), and
r_import(), which correspond roughly to the built-in operations
exec, eval(), execfile() and import, but executing the code in an
environment that only exposes those built-in operations that are
deemed safe.  To this end, a modest collection of 'fake' modules is
created which mimics the standard modules by the same names.  It is a
policy decision which built-in modules and operations are made
available; this module provides a reasonable default, but derived
classes can change the policies e.g. by overriding or extending class
variables like ok_builtin_modules or methods like make_sys().

XXX To do:
- r_open should allow writing tmp dir
- r_exec etc. with explicit globals/locals? (Use rexec("exec ... in ...")?)

"""
from warnings import warnpy3k
warnpy3k("the rexec module has been removed in Python 3.0", stacklevel=2)
del warnpy3k


import sys
import __builtin__
import os
import ihooks
import imp

__all__ = ["RExec"]

class FileBase:

    ok_file_methods = ('fileno', 'flush', 'isatty', 'read', 'readline',
            'readlines', 'seek', 'tell', 'write', 'writelines', 'xreadlines',
            '__iter__')


class FileWrapper(FileBase):

    # XXX This is just like a Bastion -- should use that!

    def __init__(self, f):
        for m in self.ok_file_methods:
            if not hasattr(self, m) and hasattr(f, m):
                setattr(self, m, getattr(f, m))

    def close(self):
        self.flush()


TEMPLATE = """
def %s(self, *args):
        return getattr(self.mod, self.name).%s(*args)
"""

class FileDelegate(FileBase):

    def __init__(self, mod, name):
        self.mod = mod
        self.name = name

    for m in FileBase.ok_file_methods + ('close',):
        exec TEMPLATE % (m, m)


class RHooks(ihooks.Hooks):

    def __init__(self, *args):
        # Hacks to support both old and new interfaces:
        # old interface was RHooks(rexec[, verbose])
        # new interface is RHooks([verbose])
        verbose = 0
        rexec = None
        if args and type(args[-1]) == type(0):
            verbose = args[-1]
            args = args[:-1]
        if args and hasattr(args[0], '__class__'):
            rexec = args[0]
            args = args[1:]
        if args:
            raise TypeError, "too many arguments"
        ihooks.Hooks.__init__(self, verbose)
        self.rexec = rexec

    def set_rexec(self, rexec):
        # Called by RExec instance to complete initialization
        self.rexec = rexec

    def get_suffixes(self):
        return self.rexec.get_suffixes()

    def is_builtin(self, name):
        return self.rexec.is_builtin(name)

    def init_builtin(self, name):
        m = __import__(name)
        return self.rexec.copy_except(m, ())

    def init_frozen(self, name): raise SystemError, "don't use this"
    def load_source(self, *args): raise SystemError, "don't use this"
    def load_compiled(self, *args): raise SystemError, "don't use this"
    def load_package(self, *args): raise SystemError, "don't use this"

    def load_dynamic(self, name, filename, file):
        return self.rexec.load_dynamic(name, filename, file)

    def add_module(self, name):
        return self.rexec.add_module(name)

    def modules_dict(self):
        return self.rexec.modules

    def default_path(self):
        return self.rexec.modules['sys'].path


# XXX Backwards compatibility
RModuleLoader = ihooks.FancyModuleLoader
RModuleImporter = ihooks.ModuleImporter


class RExec(ihooks._Verbose):
    """Basic restricted execution framework.

    Code executed in this restricted environment will only have access to
    modules and functions that are deemed safe; you can subclass RExec to
    add or remove capabilities as desired.

    The RExec class can prevent code from performing unsafe operations like
    reading or writing disk files, or using TCP/IP sockets.  However, it does
    not protect against code using extremely large amounts of memory or
    processor time.

    """

    ok_path = tuple(sys.path)           # That's a policy decision

    ok_builtin_modules = ('audioop', 'array', 'binascii',
                          'cmath', 'errno', 'imageop',
                          'marshal', 'math', 'md5', 'operator',
                          'parser', 'select',
                          'sha', '_sre', 'strop', 'struct', 'time',
                          '_weakref')

    ok_posix_names = ('error', 'fstat', 'listdir', 'lstat', 'readlink',
                      'stat', 'times', 'uname', 'getpid', 'getppid',
                      'getcwd', 'getuid', 'getgid', 'geteuid', 'getegid')

    ok_sys_names = ('byteorder', 'copyright', 'exit', 'getdefaultencoding',
                    'getrefcount', 'hexversion', 'maxint', 'maxunicode',
                    'platform', 'ps1', 'ps2', 'version', 'version_info')

    nok_builtin_names = ('open', 'file', 'reload', '__import__')

    ok_file_types = (imp.C_EXTENSION, imp.PY_SOURCE)

    def __init__(self, hooks = None, verbose = 0):
        """Returns an instance of the RExec class.

        The hooks parameter is an instance of the RHooks class or a subclass
        of it.  If it is omitted or None, the default RHooks class is
        instantiated.

        Whenever the RExec module searches for a module (even a built-in one)
        or reads a module's code, it doesn't actually go out to the file
        system itself.  Rather, it calls methods of an RHooks instance that
        was passed to or created by its constructor.  (Actually, the RExec
        object doesn't make these calls --- they are made by a module loader
        object that's part of the RExec object.  This allows another level of
        flexibility, which can be useful when changing the mechanics of
        import within the restricted environment.)

        By providing an alternate RHooks object, we can control the file
        system accesses made to import a module, without changing the
        actual algorithm that controls the order in which those accesses are
        made.  For instance, we could substitute an RHooks object that
        passes all filesystem requests to a file server elsewhere, via some
        RPC mechanism such as ILU.  Grail's applet loader uses this to support
        importing applets from a URL for a directory.

        If the verbose parameter is true, additional debugging output may be
        sent to standard output.

        """

        raise RuntimeError, "This code is not secure in Python 2.2 and later"

        ihooks._Verbose.__init__(self, verbose)
        # XXX There's a circular reference here:
        self.hooks = hooks or RHooks(verbose)
        self.hooks.set_rexec(self)
        self.modules = {}
        self.ok_dynamic_modules = self.ok_builtin_modules
        list = []
        for mname in self.ok_builtin_modules:
            if mname in sys.builtin_module_names:
                list.append(mname)
        self.ok_builtin_modules = tuple(list)
        self.set_trusted_path()
        self.make_builtin()
        self.make_initial_modules()
        # make_sys must be last because it adds the already created
        # modules to its builtin_module_names
        self.make_sys()
        self.loader = RModuleLoader(self.hooks, verbose)
        self.importer = RModuleImporter(self.loader, verbose)

    def set_trusted_path(self):
        # Set the path from which dynamic modules may be loaded.
        # Those dynamic modules must also occur in ok_builtin_modules
        self.trusted_path = filter(os.path.isabs, sys.path)

    def load_dynamic(self, name, filename, file):
        if name not in self.ok_dynamic_modules:
            raise ImportError, "untrusted dynamic module: %s" % name
        if name in sys.modules:
            src = sys.modules[name]
        else:
            src = imp.load_dynamic(name, filename, file)
        dst = self.copy_except(src, [])
        return dst

    def make_initial_modules(self):
        self.make_main()
        self.make_osname()

    # Helpers for RHooks

    def get_suffixes(self):
        return [item   # (suff, mode, type)
                for item in imp.get_suffixes()
                if item[2] in self.ok_file_types]

    def is_builtin(self, mname):
        return mname in self.ok_builtin_modules

    # The make_* methods create specific built-in modules

    def make_builtin(self):
        m = self.copy_except(__builtin__, self.nok_builtin_names)
        m.__import__ = self.r_import
        m.reload = self.r_reload
        m.open = m.file = self.r_open

    def make_main(self):
        self.add_module('__main__')

    def make_osname(self):
        osname = os.name
        src = __import__(osname)
        dst = self.copy_only(src, self.ok_posix_names)
        dst.environ = e = {}
        for key, value in os.environ.items():
            e[key] = value

    def make_sys(self):
        m = self.copy_only(sys, self.ok_sys_names)
        m.modules = self.modules
        m.argv = ['RESTRICTED']
        m.path = map(None, self.ok_path)
        m.exc_info = self.r_exc_info
        m = self.modules['sys']
        l = self.modules.keys() + list(self.ok_builtin_modules)
        l.sort()
        m.builtin_module_names = tuple(l)

    # The copy_* methods copy existing modules with some changes

    def copy_except(self, src, exceptions):
        dst = self.copy_none(src)
        for name in dir(src):
            setattr(dst, name, getattr(src, name))
        for name in exceptions:
            try:
                delattr(dst, name)
            except AttributeError:
                pass
        return dst

    def copy_only(self, src, names):
        dst = self.copy_none(src)
        for name in names:
            try:
                value = getattr(src, name)
            except AttributeError:
                continue
            setattr(dst, name, value)
        return dst

    def copy_none(self, src):
        m = self.add_module(src.__name__)
        m.__doc__ = src.__doc__
        return m

    # Add a module -- return an existing module or create one

    def add_module(self, mname):
        m = self.modules.get(mname)
        if m is None:
            self.modules[mname] = m = self.hooks.new_module(mname)
        m.__builtins__ = self.modules['__builtin__']
        return m

    # The r* methods are public interfaces

    def r_exec(self, code):
        """Execute code within a restricted environment.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        """
        m = self.add_module('__main__')
        exec code in m.__dict__

    def r_eval(self, code):
        """Evaluate code within a restricted environment.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        """
        m = self.add_module('__main__')
        return eval(code, m.__dict__)

    def r_execfile(self, file):
        """Execute the Python code in the file in the restricted
        environment's __main__ module.

        """
        m = self.add_module('__main__')
        execfile(file, m.__dict__)

    def r_import(self, mname, globals={}, locals={}, fromlist=[]):
        """Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.import_module(mname, globals, locals, fromlist)

    def r_reload(self, m):
        """Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.reload(m)

    def r_unload(self, m):
        """Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        return self.importer.unload(m)

    # The s_* methods are similar but also swap std{in,out,err}

    def make_delegate_files(self):
        s = self.modules['sys']
        self.delegate_stdin = FileDelegate(s, 'stdin')
        self.delegate_stdout = FileDelegate(s, 'stdout')
        self.delegate_stderr = FileDelegate(s, 'stderr')
        self.restricted_stdin = FileWrapper(sys.stdin)
        self.restricted_stdout = FileWrapper(sys.stdout)
        self.restricted_stderr = FileWrapper(sys.stderr)

    def set_files(self):
        if not hasattr(self, 'save_stdin'):
            self.save_files()
        if not hasattr(self, 'delegate_stdin'):
            self.make_delegate_files()
        s = self.modules['sys']
        s.stdin = self.restricted_stdin
        s.stdout = self.restricted_stdout
        s.stderr = self.restricted_stderr
        sys.stdin = self.delegate_stdin
        sys.stdout = self.delegate_stdout
        sys.stderr = self.delegate_stderr

    def reset_files(self):
        self.restore_files()
        s = self.modules['sys']
        self.restricted_stdin = s.stdin
        self.restricted_stdout = s.stdout
        self.restricted_stderr = s.stderr


    def save_files(self):
        self.save_stdin = sys.stdin
        self.save_stdout = sys.stdout
        self.save_stderr = sys.stderr

    def restore_files(self):
        sys.stdin = self.save_stdin
        sys.stdout = self.save_stdout
        sys.stderr = self.save_stderr

    def s_apply(self, func, args=(), kw={}):
        self.save_files()
        try:
            self.set_files()
            r = func(*args, **kw)
        finally:
            self.restore_files()
        return r

    def s_exec(self, *args):
        """Execute code within a restricted environment.

        Similar to the r_exec() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        """
        return self.s_apply(self.r_exec, args)

    def s_eval(self, *args):
        """Evaluate code within a restricted environment.

        Similar to the r_eval() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        """
        return self.s_apply(self.r_eval, args)

    def s_execfile(self, *args):
        """Execute the Python code in the file in the restricted
        environment's __main__ module.

        Similar to the r_execfile() method, but the code will be granted
        access to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        """
        return self.s_apply(self.r_execfile, args)

    def s_import(self, *args):
        """Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_import() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_import, args)

    def s_reload(self, *args):
        """Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_reload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_reload, args)

    def s_unload(self, *args):
        """Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_unload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        """
        return self.s_apply(self.r_unload, args)

    # Restricted open(...)

    def r_open(self, file, mode='r', buf=-1):
        """Method called when open() is called in the restricted environment.

        The arguments are identical to those of the open() function, and a
        file object (or a class instance compatible with file objects)
        should be returned.  RExec's default behaviour is allow opening
        any file for reading, but forbidding any attempt to write a file.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        """
        mode = str(mode)
        if mode not in ('r', 'rb'):
            raise IOError, "can't open files for writing in restricted mode"
        return open(file, mode, buf)

    # Restricted version of sys.exc_info()

    def r_exc_info(self):
        ty, va, tr = sys.exc_info()
        tr = None
        return ty, va, tr


def test():
    import getopt, traceback
    opts, args = getopt.getopt(sys.argv[1:], 'vt:')
    verbose = 0
    trusted = []
    for o, a in opts:
        if o == '-v':
            verbose = verbose+1
        if o == '-t':
            trusted.append(a)
    r = RExec(verbose=verbose)
    if trusted:
        r.ok_builtin_modules = r.ok_builtin_modules + tuple(trusted)
    if args:
        r.modules['sys'].argv = args
        r.modules['sys'].path.insert(0, os.path.dirname(args[0]))
    else:
        r.modules['sys'].path.insert(0, "")
    fp = sys.stdin
    if args and args[0] != '-':
        try:
            fp = open(args[0])
        except IOError, msg:
            print "%s: can't open file %r" % (sys.argv[0], args[0])
            return 1
    if fp.isatty():
        try:
            import readline
        except ImportError:
            pass
        import code
        class RestrictedConsole(code.InteractiveConsole):
            def runcode(self, co):
                self.locals['__builtins__'] = r.modules['__builtin__']
                r.s_apply(code.InteractiveConsole.runcode, (self, co))
        try:
            RestrictedConsole(r.modules['__main__'].__dict__).interact()
        except SystemExit, n:
            return n
    else:
        text = fp.read()
        fp.close()
        c = compile(text, fp.name, 'exec')
        try:
            r.s_exec(c)
        except SystemExit, n:
            return n
        except:
            traceback.print_exc()
            return 1


if __name__ == '__main__':
    sys.exit(test())
                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/rexec.pyc                                                                         0100644 0000000 0000000 00000056714 13077704275 014250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s#  d  Z  d d l m Z e d d d [ d d l Z d d l Z d d l Z d d l Z d d l Z d g Z d f  d	     YZ	 d
 e	 f d     YZ
 d Z d e	 f d     YZ d e j f d     YZ e j Z e j Z d e j f d     YZ d   Z e d k re j e    n  d S(   s9  Restricted execution facilities.

The class RExec exports methods r_exec(), r_eval(), r_execfile(), and
r_import(), which correspond roughly to the built-in operations
exec, eval(), execfile() and import, but executing the code in an
environment that only exposes those built-in operations that are
deemed safe.  To this end, a modest collection of 'fake' modules is
created which mimics the standard modules by the same names.  It is a
policy decision which built-in modules and operations are made
available; this module provides a reasonable default, but derived
classes can change the policies e.g. by overriding or extending class
variables like ok_builtin_modules or methods like make_sys().

XXX To do:
- r_open should allow writing tmp dir
- r_exec etc. with explicit globals/locals? (Use rexec("exec ... in ...")?)

i(   t   warnpy3ks/   the rexec module has been removed in Python 3.0t
   stackleveli   Nt   RExect   FileBasec           B   s   e  Z d Z RS(   t   filenot   flusht   isattyt   readt   readlinet	   readlinest   seekt   tellt   writet
   writelinest
   xreadlinest   __iter__(   s   filenos   flushs   isattys   reads   readlines	   readliness   seeks   tells   writes
   writeliness
   xreadliness   __iter__(   t   __name__t
   __module__t   ok_file_methods(    (    (    s   /usr/lib/python2.7/rexec.pyR       s     t   FileWrapperc           B   s   e  Z d    Z d   Z RS(   c         C   sS   xL |  j  D]A } t |  |  r
 t | |  r
 t |  | t | |   q
 q
 Wd  S(   N(   R   t   hasattrt   setattrt   getattr(   t   selft   ft   m(    (    s   /usr/lib/python2.7/rexec.pyt   __init__+   s    c         C   s   |  j    d  S(   N(   R   (   R   (    (    s   /usr/lib/python2.7/rexec.pyt   close0   s    (   R   R   R   R   (    (    (    s   /usr/lib/python2.7/rexec.pyR   '   s   	sL   
def %s(self, *args):
        return getattr(self.mod, self.name).%s(*args)
t   FileDelegatec           B   s;   e  Z d    Z x' e j d D] Z e e e f d Uq WRS(   c         C   s   | |  _  | |  _ d  S(   N(   t   modt   name(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR   ;   s    	R   N(   s   close(   R   R   R   R   R   R   t   TEMPLATE(    (    (    s   /usr/lib/python2.7/rexec.pyR   9   s   	t   RHooksc           B   s}   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 d	   Z d
   Z d   Z d   Z RS(   c         G   s   d } d  } | rE t | d  t d  k rE | d } | d  } n  | ru t | d d  ru | d } | d } n  | r t d  n  t j j |  |  | |  _ d  S(   Ni    it	   __class__i   s   too many arguments(   t   Nonet   typeR   t	   TypeErrort   ihookst   HooksR   t   rexec(   R   t   argst   verboseR'   (    (    s   /usr/lib/python2.7/rexec.pyR   E   s    "

c         C   s   | |  _  d  S(   N(   R'   (   R   R'   (    (    s   /usr/lib/python2.7/rexec.pyt	   set_rexecV   s    c         C   s   |  j  j   S(   N(   R'   t   get_suffixes(   R   (    (    s   /usr/lib/python2.7/rexec.pyR+   Z   s    c         C   s   |  j  j |  S(   N(   R'   t
   is_builtin(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR,   ]   s    c         C   s   t  |  } |  j j | d  S(   N(    (   t
   __import__R'   t   copy_except(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   init_builtin`   s    c         C   s   t  d  d  S(   Ns   don't use this(   t   SystemError(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   init_frozend   s    c         G   s   t  d  d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_sourcee   s    c         G   s   t  d  d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_compiledf   s    c         G   s   t  d  d  S(   Ns   don't use this(   R0   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   load_packageg   s    c         C   s   |  j  j | | |  S(   N(   R'   t   load_dynamic(   R   R   t   filenamet   file(    (    s   /usr/lib/python2.7/rexec.pyR5   i   s    c         C   s   |  j  j |  S(   N(   R'   t
   add_module(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR8   l   s    c         C   s
   |  j  j S(   N(   R'   t   modules(   R   (    (    s   /usr/lib/python2.7/rexec.pyt   modules_dicto   s    c         C   s   |  j  j d j S(   Nt   sys(   R'   R9   t   path(   R   (    (    s   /usr/lib/python2.7/rexec.pyt   default_pathr   s    (   R   R   R   R*   R+   R,   R/   R1   R2   R3   R4   R5   R8   R:   R=   (    (    (    s   /usr/lib/python2.7/rexec.pyR    C   s   												c           B   s  e  Z d  Z e e j  Z dX Z dY Z dZ Z	 d[ Z
 e j e j f Z d\ d3 d4  Z d5   Z d6   Z d7   Z d8   Z d9   Z d:   Z d;   Z d<   Z d=   Z d>   Z d?   Z d@   Z dA   Z dB   Z dC   Z dD   Z  i  i  g  dE  Z! dF   Z" dG   Z# dH   Z$ dI   Z% dJ   Z& dK   Z' dL   Z( d] i  dM  Z) dN   Z* dO   Z+ dP   Z, dQ   Z- dR   Z. dS   Z/ dT dU dV  Z0 dW   Z1 RS(^   s  Basic restricted execution framework.

    Code executed in this restricted environment will only have access to
    modules and functions that are deemed safe; you can subclass RExec to
    add or remove capabilities as desired.

    The RExec class can prevent code from performing unsafe operations like
    reading or writing disk files, or using TCP/IP sockets.  However, it does
    not protect against code using extremely large amounts of memory or
    processor time.

    t   audioopt   arrayt   binasciit   cmatht   errnot   imageopt   marshalt   matht   md5t   operatort   parsert   selectt   shat   _sret   stropt   structt   timet   _weakreft   errort   fstatt   listdirt   lstatt   readlinkt   statt   timest   unamet   getpidt   getppidt   getcwdt   getuidt   getgidt   geteuidt   getegidt	   byteordert	   copyrightt   exitt   getdefaultencodingt   getrefcountt
   hexversiont   maxintt
   maxunicodet   platformt   ps1t   ps2t   versiont   version_infot   openR7   t   reloadR-   i    c         C   s   t  d  t j j |  |  | p+ t |  |  _ |  j j |   i  |  _ |  j |  _	 g  } x0 |  j D]% } | t
 j k rf | j |  qf qf Wt |  |  _ |  j   |  j   |  j   |  j   t |  j |  |  _ t |  j |  |  _ d S(   s  Returns an instance of the RExec class.

        The hooks parameter is an instance of the RHooks class or a subclass
        of it.  If it is omitted or None, the default RHooks class is
        instantiated.

        Whenever the RExec module searches for a module (even a built-in one)
        or reads a module's code, it doesn't actually go out to the file
        system itself.  Rather, it calls methods of an RHooks instance that
        was passed to or created by its constructor.  (Actually, the RExec
        object doesn't make these calls --- they are made by a module loader
        object that's part of the RExec object.  This allows another level of
        flexibility, which can be useful when changing the mechanics of
        import within the restricted environment.)

        By providing an alternate RHooks object, we can control the file
        system accesses made to import a module, without changing the
        actual algorithm that controls the order in which those accesses are
        made.  For instance, we could substitute an RHooks object that
        passes all filesystem requests to a file server elsewhere, via some
        RPC mechanism such as ILU.  Grail's applet loader uses this to support
        importing applets from a URL for a directory.

        If the verbose parameter is true, additional debugging output may be
        sent to standard output.

        s/   This code is not secure in Python 2.2 and laterN(   t   RuntimeErrorR%   t   _VerboseR   R    t   hooksR*   R9   t   ok_builtin_modulest   ok_dynamic_modulesR;   t   builtin_module_namest   appendt   tuplet   set_trusted_patht   make_builtint   make_initial_modulest   make_syst   RModuleLoadert   loadert   RModuleImportert   importer(   R   Rp   R)   t   listt   mname(    (    s   /usr/lib/python2.7/rexec.pyR      s"    		



c         C   s   t  t j j t j  |  _ d  S(   N(   t   filtert   osR<   t   isabsR;   t   trusted_path(   R   (    (    s   /usr/lib/python2.7/rexec.pyRv      s    c         C   si   | |  j  k r t d |  n  | t j k r> t j | } n t j | | |  } |  j | g   } | S(   Ns   untrusted dynamic module: %s(   Rr   t   ImportErrorR;   R9   t   impR5   R.   (   R   R   R6   R7   t   srct   dst(    (    s   /usr/lib/python2.7/rexec.pyR5      s    c         C   s   |  j    |  j   d  S(   N(   t	   make_maint   make_osname(   R   (    (    s   /usr/lib/python2.7/rexec.pyRx      s    
c         C   s0   g  t  j   D] } | d |  j k r | ^ q S(   Ni   (   R   R+   t   ok_file_types(   R   t   item(    (    s   /usr/lib/python2.7/rexec.pyR+      s    c         C   s   | |  j  k S(   N(   Rq   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR,      s    c         C   sD   |  j  t |  j  } |  j | _ |  j | _ |  j | _ | _	 d  S(   N(
   R.   t   __builtin__t   nok_builtin_namest   r_importR-   t   r_reloadRm   t   r_openRl   R7   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyRw      s    c         C   s   |  j  d  d  S(   Nt   __main__(   R8   (   R   (    (    s   /usr/lib/python2.7/rexec.pyR      s    c         C   se   t  j } t |  } |  j | |  j  } i  | _ } x' t  j j   D] \ } } | | | <qG Wd  S(   N(   R   R   R-   t	   copy_onlyt   ok_posix_namest   environt   items(   R   t   osnameR   R   t   et   keyt   value(    (    s   /usr/lib/python2.7/rexec.pyR      s    	c         C   s   |  j  t |  j  } |  j | _ d g | _ t d  |  j  | _ |  j	 | _
 |  j d } |  j j   t |  j  } | j   t |  | _ d  S(   Nt
   RESTRICTEDR;   (   R   R;   t   ok_sys_namesR9   t   argvt   mapR"   t   ok_pathR<   t
   r_exc_infot   exc_infot   keysR~   Rq   t   sortRu   Rs   (   R   R   t   l(    (    s   /usr/lib/python2.7/rexec.pyRy     s    
c         C   sy   |  j  |  } x- t |  D] } t | | t | |   q Wx3 | D]+ } y t | |  WqF t k
 rp qF XqF W| S(   N(   t	   copy_nonet   dirR   R   t   delattrt   AttributeError(   R   R   t
   exceptionsR   R   (    (    s   /usr/lib/python2.7/rexec.pyR.     s    c         C   s^   |  j  |  } xH | D]@ } y t | |  } Wn t k
 rE q n Xt | | |  q W| S(   N(   R   R   R   R   (   R   R   t   namesR   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR     s    c         C   s"   |  j  | j  } | j | _ | S(   N(   R8   R   t   __doc__(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR   #  s    c         C   sR   |  j  j |  } | d  k r> |  j j |  |  j  | <} n  |  j  d | _ | S(   NR   (   R9   t   getR"   Rp   t
   new_modulet   __builtins__(   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR8   *  s
     c         B   s   |  j  d  } | | j Ud S(   s  Execute code within a restricted environment.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        R   N(   R8   t   __dict__(   R   t   codeR   (    (    s   /usr/lib/python2.7/rexec.pyt   r_exec3  s    c         C   s   |  j  d  } t | | j  S(   sF  Evaluate code within a restricted environment.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        R   (   R8   t   evalR   (   R   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   r_eval>  s    	c         C   s#   |  j  d  } t | | j  d S(   sf   Execute the Python code in the file in the restricted
        environment's __main__ module.

        R   N(   R8   t   execfileR   (   R   R7   R   (    (    s   /usr/lib/python2.7/rexec.pyt
   r_execfileJ  s    c         C   s   |  j  j | | | |  S(   s=  Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   t   import_module(   R   R   t   globalst   localst   fromlist(    (    s   /usr/lib/python2.7/rexec.pyR   R  s    	c         C   s   |  j  j |  S(   s  Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   Rm   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyR   ]  s    c         C   s   |  j  j |  S(   s@  Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        (   R}   t   unload(   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   r_unloadg  s    
c         C   s}   |  j  d } t | d  |  _ t | d  |  _ t | d  |  _ t t j  |  _ t t j	  |  _
 t t j  |  _ d  S(   NR;   t   stdint   stdoutt   stderr(   R9   R   t   delegate_stdint   delegate_stdoutt   delegate_stderrR   R;   R   t   restricted_stdinR   t   restricted_stdoutR   t   restricted_stderr(   R   t   s(    (    s   /usr/lib/python2.7/rexec.pyt   make_delegate_filesu  s    c         C   s   t  |  d  s |  j   n  t  |  d  s8 |  j   n  |  j d } |  j | _ |  j | _ |  j | _	 |  j
 t _ |  j t _ |  j t _	 d  S(   Nt
   save_stdinR   R;   (   R   t
   save_filesR   R9   R   R   R   R   R   R   R   R;   R   R   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt	   set_files~  s    c         C   s?   |  j    |  j d } | j |  _ | j |  _ | j |  _ d  S(   NR;   (   t   restore_filesR9   R   R   R   R   R   R   (   R   R   (    (    s   /usr/lib/python2.7/rexec.pyt   reset_files  s
    
c         C   s(   t  j |  _ t  j |  _ t  j |  _ d  S(   N(   R;   R   R   R   t   save_stdoutR   t   save_stderr(   R   (    (    s   /usr/lib/python2.7/rexec.pyR     s    c         C   s(   |  j  t _ |  j t _ |  j t _ d  S(   N(   R   R;   R   R   R   R   R   (   R   (    (    s   /usr/lib/python2.7/rexec.pyR     s    c         C   s9   |  j    z |  j   | | |   } Wd  |  j   X| S(   N(   R   R   R   (   R   t   funcR(   t   kwt   r(    (    s   /usr/lib/python2.7/rexec.pyt   s_apply  s    

c         G   s   |  j  |  j |  S(   s  Execute code within a restricted environment.

        Similar to the r_exec() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing one or more
        lines of Python code, or a compiled code object, which will be
        executed in the restricted environment's __main__ module.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_exec  s    c         G   s   |  j  |  j |  S(   s  Evaluate code within a restricted environment.

        Similar to the r_eval() method, but the code will be granted access
        to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        The code parameter must either be a string containing a Python
        expression, or a compiled code object, which will be evaluated in
        the restricted environment's __main__ module.  The value of the
        expression or code object will be returned.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_eval  s    c         G   s   |  j  |  j |  S(   s!  Execute the Python code in the file in the restricted
        environment's __main__ module.

        Similar to the r_execfile() method, but the code will be granted
        access to restricted versions of the standard I/O streams sys.stdin,
        sys.stderr, and sys.stdout.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt
   s_execfile  s    	c         G   s   |  j  |  j |  S(   s  Import a module, raising an ImportError exception if the module
        is considered unsafe.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_import() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_import  s    c         G   s   |  j  |  j |  S(   s  Reload the module object, re-parsing and re-initializing it.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_reload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_reload  s    c         G   s   |  j  |  j |  S(   s  Unload the module.

        Removes it from the restricted environment's sys.modules dictionary.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        Similar to the r_unload() method, but has access to restricted
        versions of the standard I/O streams sys.stdin, sys.stderr, and
        sys.stdout.

        (   R   R   (   R   R(   (    (    s   /usr/lib/python2.7/rexec.pyt   s_unload  s    R   ic         C   s4   t  |  } | d k r$ t d  n  t | | |  S(   sG  Method called when open() is called in the restricted environment.

        The arguments are identical to those of the open() function, and a
        file object (or a class instance compatible with file objects)
        should be returned.  RExec's default behaviour is allow opening
        any file for reading, but forbidding any attempt to write a file.

        This method is implicitly called by code executing in the
        restricted environment.  Overriding this method in a subclass is
        used to change the policies enforced by a restricted environment.

        R   t   rbs/   can't open files for writing in restricted mode(   R   s   rb(   t   strt   IOErrorRl   (   R   R7   t   modet   buf(    (    s   /usr/lib/python2.7/rexec.pyR     s    c         C   s(   t  j   \ } } } d  } | | | f S(   N(   R;   R   R"   (   R   t   tyt   vat   tr(    (    s   /usr/lib/python2.7/rexec.pyR     s    (   R>   R?   R@   RA   s   errnoRC   s   marshalRE   RF   RG   RH   RI   RJ   RK   RL   RM   RN   s   _weakref(   s   errors   fstats   listdirs   lstats   readlinks   stats   timess   unames   getpids   getppids   getcwds   getuids   getgids   geteuids   getegid(   s	   byteorders	   copyrights   exits   getdefaultencodings   getrefcounts
   hexversions   maxints
   maxunicodes   platformRh   Ri   s   versions   version_info(   s   opens   files   reloads
   __import__N(    (2   R   R   R   Ru   R;   R<   R   Rq   R   R   R   R   t   C_EXTENSIONt	   PY_SOURCER   R"   R   Rv   R5   Rx   R+   R,   Rw   R   R   Ry   R.   R   R   R8   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/rexec.pyR   {   sd            3		
									
							
														c             s  d d  l  }  d d  l } |  j  t j d d  \ } } d } g  } xI | D]A \ } } | d k ro | d } n  | d k rJ | j |  qJ qJ Wt d |   | r  j t |   _ n  | r |  j d _  j d j	 j
 d t j	 j | d   n  j d j	 j
 d d	  t j } | r| d d
 k ry t | d  } Wqt k
 r}}	 d t j d | d f GHd SXn  | j   ry d d  l }
 Wn t k
 rn Xd d  l   d   j f    f d     Y} y |  j d j  j   Wq{t k
 r} | SXnd | j   } | j   t | | j d  } y  j |  Wn% t k
 ri} | S| j   d SXd  S(   Nii   s   vt:i    s   -vs   -tR)   R;   t    t   -s   %s: can't open file %rt   RestrictedConsolec              s   e  Z    f d    Z RS(   c            s4    j  d |  j d < j   j j |  | f  d  S(   NR   R   (   R9   R   R   t   InteractiveConsolet   runcode(   R   t   co(   R   R   (    s   /usr/lib/python2.7/rexec.pyR   7  s    (   R   R   R   (    (   R   R   (    s   /usr/lib/python2.7/rexec.pyR   6  s   R   t   exec(   t   getoptt	   tracebackR;   R   Rt   R   Rq   Ru   R9   R<   t   insertR   t   dirnameR   Rl   R   R   R   R   R   R   R   t   interactt
   SystemExitR   R   t   compileR   R   t	   print_exc(   R   R   t   optsR(   R)   t   trustedt   ot   at   fpt   msgR   R   t   nt   textt   c(    (   R   R   s   /usr/lib/python2.7/rexec.pyt   test  sX    -	"

R   (   R   t   warningsR    R;   R   R   R%   R   t   __all__R   R   R   R   R&   R    t   FancyModuleLoaderRz   t   ModuleImporterR|   Ro   R   R   R   Ra   (    (    (    s   /usr/lib/python2.7/rexec.pyt   <module>   s*   	
4		 	4                                                    usr/lib/python2.7/rfc822.py                                                                         0100644 0000000 0000000 00000101017 12734733742 013770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """RFC 2822 message manipulation.

Note: This is only a very rough sketch of a full RFC-822 parser; in particular
the tokenizing of addresses does not adhere to all the quoting rules.

Note: RFC 2822 is a long awaited update to RFC 822.  This module should
conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
effort at RFC 2822 updates have been made, but a thorough audit has not been
performed.  Consider any RFC 2822 non-conformance to be a bug.

    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)

Directions for use:

To create a Message object: first open a file, e.g.:

  fp = open(file, 'r')

You can use any other legal way of getting an open file object, e.g. use
sys.stdin or call os.popen().  Then pass the open file object to the Message()
constructor:

  m = Message(fp)

This class can work with any input object that supports a readline method.  If
the input object has seek and tell capability, the rewindbody method will
work; also illegal lines will be pushed back onto the input stream.  If the
input object lacks seek but has an `unread' method that can push back a line
of input, Message will use that to push back illegal lines.  Thus this class
can be used to parse messages coming from a buffered stream.

The optional `seekable' argument is provided as a workaround for certain stdio
libraries in which tell() discards buffered data before discovering that the
lseek() system call doesn't work.  For maximum portability, you should set the
seekable argument to zero to prevent that initial \code{tell} when passing in
an unseekable object such as a file object created from a socket object.  If
it is 1 on entry -- which it is by default -- the tell() method of the open
file object is called once; if this raises an exception, seekable is reset to
0.  For other nonzero values of seekable, this test is not made.

To get the text of a particular header there are several methods:

  str = m.getheader(name)
  str = m.getrawheader(name)

where name is the name of the header, e.g. 'Subject'.  The difference is that
getheader() strips the leading and trailing whitespace, while getrawheader()
doesn't.  Both functions retain embedded whitespace (including newlines)
exactly as they are specified in the header, and leave the case of the text
unchanged.

For addresses and address lists there are functions

  realname, mailaddress = m.getaddr(name)
  list = m.getaddrlist(name)

where the latter returns a list of (realname, mailaddr) tuples.

There is also a method

  time = m.getdate(name)

which parses a Date-like field and returns a time-compatible tuple,
i.e. a tuple such as returned by time.localtime() or accepted by
time.mktime().

See the class definition for lower level access methods.

There are also some utility functions here.
"""
# Cleanup and extensions by Eric S. Raymond <esr@thyrsus.com>

import time

from warnings import warnpy3k
warnpy3k("in 3.x, rfc822 has been removed in favor of the email package",
         stacklevel=2)

__all__ = ["Message","AddressList","parsedate","parsedate_tz","mktime_tz"]

_blanklines = ('\r\n', '\n')            # Optimization for islast()


class Message:
    """Represents a single RFC 2822-compliant message."""

    def __init__(self, fp, seekable = 1):
        """Initialize the class instance and read the headers."""
        if seekable == 1:
            # Exercise tell() to make sure it works
            # (and then assume seek() works, too)
            try:
                fp.tell()
            except (AttributeError, IOError):
                seekable = 0
        self.fp = fp
        self.seekable = seekable
        self.startofheaders = None
        self.startofbody = None
        #
        if self.seekable:
            try:
                self.startofheaders = self.fp.tell()
            except IOError:
                self.seekable = 0
        #
        self.readheaders()
        #
        if self.seekable:
            try:
                self.startofbody = self.fp.tell()
            except IOError:
                self.seekable = 0

    def rewindbody(self):
        """Rewind the file to the start of the body (if seekable)."""
        if not self.seekable:
            raise IOError, "unseekable file"
        self.fp.seek(self.startofbody)

    def readheaders(self):
        """Read header lines.

        Read header lines up to the entirely blank line that terminates them.
        The (normally blank) line that ends the headers is skipped, but not
        included in the returned list.  If a non-header line ends the headers,
        (which is an error), an attempt is made to backspace over it; it is
        never included in the returned list.

        The variable self.status is set to the empty string if all went well,
        otherwise it is an error message.  The variable self.headers is a
        completely uninterpreted list of lines contained in the header (so
        printing them will reproduce the header exactly as it appears in the
        file).
        """
        self.dict = {}
        self.unixfrom = ''
        self.headers = lst = []
        self.status = ''
        headerseen = ""
        firstline = 1
        startofline = unread = tell = None
        if hasattr(self.fp, 'unread'):
            unread = self.fp.unread
        elif self.seekable:
            tell = self.fp.tell
        while 1:
            if tell:
                try:
                    startofline = tell()
                except IOError:
                    startofline = tell = None
                    self.seekable = 0
            line = self.fp.readline()
            if not line:
                self.status = 'EOF in headers'
                break
            # Skip unix From name time lines
            if firstline and line.startswith('From '):
                self.unixfrom = self.unixfrom + line
                continue
            firstline = 0
            if headerseen and line[0] in ' \t':
                # It's a continuation line.
                lst.append(line)
                x = (self.dict[headerseen] + "\n " + line.strip())
                self.dict[headerseen] = x.strip()
                continue
            elif self.iscomment(line):
                # It's a comment.  Ignore it.
                continue
            elif self.islast(line):
                # Note! No pushback here!  The delimiter line gets eaten.
                break
            headerseen = self.isheader(line)
            if headerseen:
                # It's a legal header line, save it.
                lst.append(line)
                self.dict[headerseen] = line[len(headerseen)+1:].strip()
                continue
            else:
                # It's not a header line; throw it back and stop here.
                if not self.dict:
                    self.status = 'No headers'
                else:
                    self.status = 'Non-header line where header expected'
                # Try to undo the read.
                if unread:
                    unread(line)
                elif tell:
                    self.fp.seek(startofline)
                else:
                    self.status = self.status + '; bad seek'
                break

    def isheader(self, line):
        """Determine whether a given line is a legal header.

        This method should return the header name, suitably canonicalized.
        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats with special header formats.
        """
        i = line.find(':')
        if i > 0:
            return line[:i].lower()
        return None

    def islast(self, line):
        """Determine whether a line is a legal end of RFC 2822 headers.

        You may override this method if your application wants to bend the
        rules, e.g. to strip trailing whitespace, or to recognize MH template
        separators ('--------').  For convenience (e.g. for code reading from
        sockets) a line consisting of \\r\\n also matches.
        """
        return line in _blanklines

    def iscomment(self, line):
        """Determine whether a line should be skipped entirely.

        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats that support embedded comments or
        free-text data.
        """
        return False

    def getallmatchingheaders(self, name):
        """Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.
        """
        name = name.lower() + ':'
        n = len(name)
        lst = []
        hit = 0
        for line in self.headers:
            if line[:n].lower() == name:
                hit = 1
            elif not line[:1].isspace():
                hit = 0
            if hit:
                lst.append(line)
        return lst

    def getfirstmatchingheader(self, name):
        """Get the first header line matching name.

        This is similar to getallmatchingheaders, but it returns only the
        first matching header (and its continuation lines).
        """
        name = name.lower() + ':'
        n = len(name)
        lst = []
        hit = 0
        for line in self.headers:
            if hit:
                if not line[:1].isspace():
                    break
            elif line[:n].lower() == name:
                hit = 1
            if hit:
                lst.append(line)
        return lst

    def getrawheader(self, name):
        """A higher-level interface to getfirstmatchingheader().

        Return a string containing the literal text of the header but with the
        keyword stripped.  All leading, trailing and embedded whitespace is
        kept in the string, however.  Return None if the header does not
        occur.
        """

        lst = self.getfirstmatchingheader(name)
        if not lst:
            return None
        lst[0] = lst[0][len(name) + 1:]
        return ''.join(lst)

    def getheader(self, name, default=None):
        """Get the header value for a name.

        This is the normal interface: it returns a stripped version of the
        header value for a given header name, or None if it doesn't exist.
        This uses the dictionary version which finds the *last* such header.
        """
        return self.dict.get(name.lower(), default)
    get = getheader

    def getheaders(self, name):
        """Get all values for a header.

        This returns a list of values for headers given more than once; each
        value in the result list is stripped in the same way as the result of
        getheader().  If the header is not given, return an empty list.
        """
        result = []
        current = ''
        have_header = 0
        for s in self.getallmatchingheaders(name):
            if s[0].isspace():
                if current:
                    current = "%s\n %s" % (current, s.strip())
                else:
                    current = s.strip()
            else:
                if have_header:
                    result.append(current)
                current = s[s.find(":") + 1:].strip()
                have_header = 1
        if have_header:
            result.append(current)
        return result

    def getaddr(self, name):
        """Get a single address from a header, as a tuple.

        An example return value:
        ('Guido van Rossum', 'guido@cwi.nl')
        """
        # New, by Ben Escoto
        alist = self.getaddrlist(name)
        if alist:
            return alist[0]
        else:
            return (None, None)

    def getaddrlist(self, name):
        """Get a list of addresses from a header.

        Retrieves a list of addresses from a header, where each address is a
        tuple as returned by getaddr().  Scans all named headers, so it works
        properly with multiple To: or Cc: headers for example.
        """
        raw = []
        for h in self.getallmatchingheaders(name):
            if h[0] in ' \t':
                raw.append(h)
            else:
                if raw:
                    raw.append(', ')
                i = h.find(':')
                if i > 0:
                    addr = h[i+1:]
                raw.append(addr)
        alladdrs = ''.join(raw)
        a = AddressList(alladdrs)
        return a.addresslist

    def getdate(self, name):
        """Retrieve a date field from a header.

        Retrieves a date field from the named header, returning a tuple
        compatible with time.mktime().
        """
        try:
            data = self[name]
        except KeyError:
            return None
        return parsedate(data)

    def getdate_tz(self, name):
        """Retrieve a date field from a header as a 10-tuple.

        The first 9 elements make up a tuple compatible with time.mktime(),
        and the 10th is the offset of the poster's time zone from GMT/UTC.
        """
        try:
            data = self[name]
        except KeyError:
            return None
        return parsedate_tz(data)


    # Access as a dictionary (only finds *last* header of each type):

    def __len__(self):
        """Get the number of headers in a message."""
        return len(self.dict)

    def __getitem__(self, name):
        """Get a specific header, as from a dictionary."""
        return self.dict[name.lower()]

    def __setitem__(self, name, value):
        """Set the value of a header.

        Note: This is not a perfect inversion of __getitem__, because any
        changed headers get stuck at the end of the raw-headers list rather
        than where the altered header was.
        """
        del self[name] # Won't fail if it doesn't exist
        self.dict[name.lower()] = value
        text = name + ": " + value
        for line in text.split("\n"):
            self.headers.append(line + "\n")

    def __delitem__(self, name):
        """Delete all occurrences of a specific header, if it is present."""
        name = name.lower()
        if not name in self.dict:
            return
        del self.dict[name]
        name = name + ':'
        n = len(name)
        lst = []
        hit = 0
        for i in range(len(self.headers)):
            line = self.headers[i]
            if line[:n].lower() == name:
                hit = 1
            elif not line[:1].isspace():
                hit = 0
            if hit:
                lst.append(i)
        for i in reversed(lst):
            del self.headers[i]

    def setdefault(self, name, default=""):
        lowername = name.lower()
        if lowername in self.dict:
            return self.dict[lowername]
        else:
            text = name + ": " + default
            for line in text.split("\n"):
                self.headers.append(line + "\n")
            self.dict[lowername] = default
            return default

    def has_key(self, name):
        """Determine whether a message contains the named header."""
        return name.lower() in self.dict

    def __contains__(self, name):
        """Determine whether a message contains the named header."""
        return name.lower() in self.dict

    def __iter__(self):
        return iter(self.dict)

    def keys(self):
        """Get all of a message's header field names."""
        return self.dict.keys()

    def values(self):
        """Get all of a message's header field values."""
        return self.dict.values()

    def items(self):
        """Get all of a message's headers.

        Returns a list of name, value tuples.
        """
        return self.dict.items()

    def __str__(self):
        return ''.join(self.headers)


# Utility functions
# -----------------

# XXX Should fix unquote() and quote() to be really conformant.
# XXX The inverses of the parse functions may also be useful.


def unquote(s):
    """Remove quotes from a string."""
    if len(s) > 1:
        if s.startswith('"') and s.endswith('"'):
            return s[1:-1].replace('\\\\', '\\').replace('\\"', '"')
        if s.startswith('<') and s.endswith('>'):
            return s[1:-1]
    return s


def quote(s):
    """Add quotes around a string."""
    return s.replace('\\', '\\\\').replace('"', '\\"')


def parseaddr(address):
    """Parse an address into a (realname, mailaddr) tuple."""
    a = AddressList(address)
    lst = a.addresslist
    if not lst:
        return (None, None)
    return lst[0]


class AddrlistClass:
    """Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of
    RFC 2822 in front of you.

    http://www.faqs.org/rfcs/rfc2822.html

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    """

    def __init__(self, field):
        """Initialize a new instance.

        `field' is an unparsed address header field, containing one or more
        addresses.
        """
        self.specials = '()<>@,:;.\"[]'
        self.pos = 0
        self.LWS = ' \t'
        self.CR = '\r\n'
        self.atomends = self.specials + self.LWS + self.CR
        # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
        # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
        # syntax, so allow dots in phrases.
        self.phraseends = self.atomends.replace('.', '')
        self.field = field
        self.commentlist = []

    def gotonext(self):
        """Parse up to the start of the next address."""
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS + '\n\r':
                self.pos = self.pos + 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            else: break

    def getaddrlist(self):
        """Parse all addresses.

        Returns a list containing all of the addresses.
        """
        result = []
        ad = self.getaddress()
        while ad:
            result += ad
            ad = self.getaddress()
        return result

    def getaddress(self):
        """Parse the next address."""
        self.commentlist = []
        self.gotonext()

        oldpos = self.pos
        oldcl = self.commentlist
        plist = self.getphraselist()

        self.gotonext()
        returnlist = []

        if self.pos >= len(self.field):
            # Bad email address technically, no domain.
            if plist:
                returnlist = [(' '.join(self.commentlist), plist[0])]

        elif self.field[self.pos] in '.@':
            # email address is just an addrspec
            # this isn't very efficient since we start over
            self.pos = oldpos
            self.commentlist = oldcl
            addrspec = self.getaddrspec()
            returnlist = [(' '.join(self.commentlist), addrspec)]

        elif self.field[self.pos] == ':':
            # address is a group
            returnlist = []

            fieldlen = len(self.field)
            self.pos += 1
            while self.pos < len(self.field):
                self.gotonext()
                if self.pos < fieldlen and self.field[self.pos] == ';':
                    self.pos += 1
                    break
                returnlist = returnlist + self.getaddress()

        elif self.field[self.pos] == '<':
            # Address is a phrase then a route addr
            routeaddr = self.getrouteaddr()

            if self.commentlist:
                returnlist = [(' '.join(plist) + ' (' + \
                         ' '.join(self.commentlist) + ')', routeaddr)]
            else: returnlist = [(' '.join(plist), routeaddr)]

        else:
            if plist:
                returnlist = [(' '.join(self.commentlist), plist[0])]
            elif self.field[self.pos] in self.specials:
                self.pos += 1

        self.gotonext()
        if self.pos < len(self.field) and self.field[self.pos] == ',':
            self.pos += 1
        return returnlist

    def getrouteaddr(self):
        """Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        """
        if self.field[self.pos] != '<':
            return

        expectroute = 0
        self.pos += 1
        self.gotonext()
        adlist = ""
        while self.pos < len(self.field):
            if expectroute:
                self.getdomain()
                expectroute = 0
            elif self.field[self.pos] == '>':
                self.pos += 1
                break
            elif self.field[self.pos] == '@':
                self.pos += 1
                expectroute = 1
            elif self.field[self.pos] == ':':
                self.pos += 1
            else:
                adlist = self.getaddrspec()
                self.pos += 1
                break
            self.gotonext()

        return adlist

    def getaddrspec(self):
        """Parse an RFC 2822 addr-spec."""
        aslist = []

        self.gotonext()
        while self.pos < len(self.field):
            if self.field[self.pos] == '.':
                aslist.append('.')
                self.pos += 1
            elif self.field[self.pos] == '"':
                aslist.append('"%s"' % self.getquote())
            elif self.field[self.pos] in self.atomends:
                break
            else: aslist.append(self.getatom())
            self.gotonext()

        if self.pos >= len(self.field) or self.field[self.pos] != '@':
            return ''.join(aslist)

        aslist.append('@')
        self.pos += 1
        self.gotonext()
        return ''.join(aslist) + self.getdomain()

    def getdomain(self):
        """Get the complete domain name from an address."""
        sdlist = []
        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] == '[':
                sdlist.append(self.getdomainliteral())
            elif self.field[self.pos] == '.':
                self.pos += 1
                sdlist.append('.')
            elif self.field[self.pos] in self.atomends:
                break
            else: sdlist.append(self.getatom())
        return ''.join(sdlist)

    def getdelimited(self, beginchar, endchars, allowcomments = 1):
        """Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.  If self is not
        looking at an instance of `beginchar' then getdelimited returns the
        empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        """
        if self.field[self.pos] != beginchar:
            return ''

        slist = ['']
        quote = 0
        self.pos += 1
        while self.pos < len(self.field):
            if quote == 1:
                slist.append(self.field[self.pos])
                quote = 0
            elif self.field[self.pos] in endchars:
                self.pos += 1
                break
            elif allowcomments and self.field[self.pos] == '(':
                slist.append(self.getcomment())
                continue        # have already advanced pos from getcomment
            elif self.field[self.pos] == '\\':
                quote = 1
            else:
                slist.append(self.field[self.pos])
            self.pos += 1

        return ''.join(slist)

    def getquote(self):
        """Get a quote-delimited fragment from self's field."""
        return self.getdelimited('"', '"\r', 0)

    def getcomment(self):
        """Get a parenthesis-delimited fragment from self's field."""
        return self.getdelimited('(', ')\r', 1)

    def getdomainliteral(self):
        """Parse an RFC 2822 domain-literal."""
        return '[%s]' % self.getdelimited('[', ']\r', 0)

    def getatom(self, atomends=None):
        """Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases)."""
        atomlist = ['']
        if atomends is None:
            atomends = self.atomends

        while self.pos < len(self.field):
            if self.field[self.pos] in atomends:
                break
            else: atomlist.append(self.field[self.pos])
            self.pos += 1

        return ''.join(atomlist)

    def getphraselist(self):
        """Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        """
        plist = []

        while self.pos < len(self.field):
            if self.field[self.pos] in self.LWS:
                self.pos += 1
            elif self.field[self.pos] == '"':
                plist.append(self.getquote())
            elif self.field[self.pos] == '(':
                self.commentlist.append(self.getcomment())
            elif self.field[self.pos] in self.phraseends:
                break
            else:
                plist.append(self.getatom(self.phraseends))

        return plist

class AddressList(AddrlistClass):
    """An AddressList encapsulates a list of parsed RFC 2822 addresses."""
    def __init__(self, field):
        AddrlistClass.__init__(self, field)
        if field:
            self.addresslist = self.getaddrlist()
        else:
            self.addresslist = []

    def __len__(self):
        return len(self.addresslist)

    def __str__(self):
        return ", ".join(map(dump_address_pair, self.addresslist))

    def __add__(self, other):
        # Set union
        newaddr = AddressList(None)
        newaddr.addresslist = self.addresslist[:]
        for x in other.addresslist:
            if not x in self.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __iadd__(self, other):
        # Set union, in-place
        for x in other.addresslist:
            if not x in self.addresslist:
                self.addresslist.append(x)
        return self

    def __sub__(self, other):
        # Set difference
        newaddr = AddressList(None)
        for x in self.addresslist:
            if not x in other.addresslist:
                newaddr.addresslist.append(x)
        return newaddr

    def __isub__(self, other):
        # Set difference, in-place
        for x in other.addresslist:
            if x in self.addresslist:
                self.addresslist.remove(x)
        return self

    def __getitem__(self, index):
        # Make indexing, slices, and 'in' work
        return self.addresslist[index]

def dump_address_pair(pair):
    """Dump a (name, address) pair in a canonicalized form."""
    if pair[0]:
        return '"' + pair[0] + '" <' + pair[1] + '>'
    else:
        return pair[1]

# Parse a date field

_monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
               'aug', 'sep', 'oct', 'nov', 'dec',
               'january', 'february', 'march', 'april', 'may', 'june', 'july',
               'august', 'september', 'october', 'november', 'december']
_daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']

# The timezone table does not include the military time zones defined
# in RFC822, other than Z.  According to RFC1123, the description in
# RFC822 gets the signs wrong, so we can't rely on any such time
# zones.  RFC1123 recommends that numeric timezone indicators be used
# instead of timezone names.

_timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,
              'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)
              'EST': -500, 'EDT': -400,  # Eastern
              'CST': -600, 'CDT': -500,  # Central
              'MST': -700, 'MDT': -600,  # Mountain
              'PST': -800, 'PDT': -700   # Pacific
              }


def parsedate_tz(data):
    """Convert a date string to a time tuple.

    Accounts for military timezones.
    """
    if not data:
        return None
    data = data.split()
    if data[0][-1] in (',', '.') or data[0].lower() in _daynames:
        # There's a dayname here. Skip it
        del data[0]
    else:
        # no space after the "weekday,"?
        i = data[0].rfind(',')
        if i >= 0:
            data[0] = data[0][i+1:]
    if len(data) == 3: # RFC 850 date, deprecated
        stuff = data[0].split('-')
        if len(stuff) == 3:
            data = stuff + data[1:]
    if len(data) == 4:
        s = data[3]
        i = s.find('+')
        if i > 0:
            data[3:] = [s[:i], s[i+1:]]
        else:
            data.append('') # Dummy tz
    if len(data) < 5:
        return None
    data = data[:5]
    [dd, mm, yy, tm, tz] = data
    mm = mm.lower()
    if not mm in _monthnames:
        dd, mm = mm, dd.lower()
        if not mm in _monthnames:
            return None
    mm = _monthnames.index(mm)+1
    if mm > 12: mm = mm - 12
    if dd[-1] == ',':
        dd = dd[:-1]
    i = yy.find(':')
    if i > 0:
        yy, tm = tm, yy
    if yy[-1] == ',':
        yy = yy[:-1]
    if not yy[0].isdigit():
        yy, tz = tz, yy
    if tm[-1] == ',':
        tm = tm[:-1]
    tm = tm.split(':')
    if len(tm) == 2:
        [thh, tmm] = tm
        tss = '0'
    elif len(tm) == 3:
        [thh, tmm, tss] = tm
    else:
        return None
    try:
        yy = int(yy)
        dd = int(dd)
        thh = int(thh)
        tmm = int(tmm)
        tss = int(tss)
    except ValueError:
        return None
    tzoffset = None
    tz = tz.upper()
    if tz in _timezones:
        tzoffset = _timezones[tz]
    else:
        try:
            tzoffset = int(tz)
        except ValueError:
            pass
    # Convert a timezone offset into seconds ; -0500 -> -18000
    if tzoffset:
        if tzoffset < 0:
            tzsign = -1
            tzoffset = -tzoffset
        else:
            tzsign = 1
        tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)
    return (yy, mm, dd, thh, tmm, tss, 0, 1, 0, tzoffset)


def parsedate(data):
    """Convert a time string to a time tuple."""
    t = parsedate_tz(data)
    if t is None:
        return t
    return t[:9]


def mktime_tz(data):
    """Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp."""
    if data[9] is None:
        # No zone info, so localtime is better assumption than GMT
        return time.mktime(data[:8] + (-1,))
    else:
        t = time.mktime(data[:8] + (0,))
        return t - data[9] - time.timezone

def formatdate(timeval=None):
    """Returns time format preferred for Internet standards.

    Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123

    According to RFC 1123, day and month names must always be in
    English.  If not for that, this code could use strftime().  It
    can't because strftime() honors the locale and could generated
    non-English names.
    """
    if timeval is None:
        timeval = time.time()
    timeval = time.gmtime(timeval)
    return "%s, %02d %s %04d %02d:%02d:%02d GMT" % (
            ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")[timeval[6]],
            timeval[2],
            ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")[timeval[1]-1],
                                timeval[0], timeval[3], timeval[4], timeval[5])


# When used as script, run a small test program.
# The first command line argument must be a filename containing one
# message in RFC-822 format.

if __name__ == '__main__':
    import sys, os
    file = os.path.join(os.environ['HOME'], 'Mail/inbox/1')
    if sys.argv[1:]: file = sys.argv[1]
    f = open(file, 'r')
    m = Message(f)
    print 'From:', m.getaddr('from')
    print 'To:', m.getaddrlist('to')
    print 'Subject:', m.getheader('subject')
    print 'Date:', m.getheader('date')
    date = m.getdate_tz('date')
    tz = date[-1]
    date = time.localtime(mktime_tz(date))
    if date:
        print 'ParsedDate:', time.asctime(date),
        hhmmss = tz
        hhmm, ss = divmod(hhmmss, 60)
        hh, mm = divmod(hhmm, 60)
        print "%+03d%02d" % (hh, mm),
        if ss: print ".%02d" % ss,
        print
    else:
        print 'ParsedDate:', None
    m.rewindbody()
    n = 0
    while f.readline():
        n += 1
    print 'Lines:', n
    print '-'*70
    print 'len =', len(m)
    if 'Date' in m: print 'Date =', m['Date']
    if 'X-Nonsense' in m: pass
    print 'keys =', m.keys()
    print 'values =', m.values()
    print 'items =', m.items()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python2.7/rfc822.pyc                                                                        0100644 0000000 0000000 00000075667 13077704274 014157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s  d  Z  d d l Z d d l m Z e d d d d d d	 d
 d g Z d d f Z d f  d     YZ d   Z d   Z d   Z	 d f  d     YZ
 d e
 f d     YZ d   Z d d d d d d d d d d d  d! d" d# d$ d% d d& d' d( d) d* d+ d, g Z d- d. d/ d0 d1 d2 d3 g Z i d4 d5 6d4 d6 6d4 d7 6d4 d8 6d9 d: 6d; d< 6d= d> 6d9 d? 6d@ dA 6d= dB 6dC dD 6d@ dE 6dF dG 6dC dH 6Z dI   Z dJ   Z dK   Z e dL  Z e dM k rd d l Z d d l Z e j j e j dN dO  Z e j dP re j dP Z n  e e dQ  Z e e  Z dR Ge j  dS  GHdT Ge j! dU  GHdV Ge j" dW  GHdX Ge j" dY  GHe j# dY  Z$ e$ d Z% e j& e e$   Z$ e$ rdZ Ge j' e$  Ge% Z( e) e( d[  \ Z* Z+ e) e* d[  \ Z, Z- d\ e, e- f Ge+ rd] e+ Gn  Hn	 dZ Ge GHe j.   d4 Z/ x e j0   r8e/ dP 7Z/ qWd^ Ge/ GHd_ d` GHda Ge1 e  GHdb e k rvdc Ge db GHn  dd e k rn  de Ge j2   GHdf Ge j3   GHdg Ge j4   GHn  d S(h   s*  RFC 2822 message manipulation.

Note: This is only a very rough sketch of a full RFC-822 parser; in particular
the tokenizing of addresses does not adhere to all the quoting rules.

Note: RFC 2822 is a long awaited update to RFC 822.  This module should
conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
effort at RFC 2822 updates have been made, but a thorough audit has not been
performed.  Consider any RFC 2822 non-conformance to be a bug.

    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)

Directions for use:

To create a Message object: first open a file, e.g.:

  fp = open(file, 'r')

You can use any other legal way of getting an open file object, e.g. use
sys.stdin or call os.popen().  Then pass the open file object to the Message()
constructor:

  m = Message(fp)

This class can work with any input object that supports a readline method.  If
the input object has seek and tell capability, the rewindbody method will
work; also illegal lines will be pushed back onto the input stream.  If the
input object lacks seek but has an `unread' method that can push back a line
of input, Message will use that to push back illegal lines.  Thus this class
can be used to parse messages coming from a buffered stream.

The optional `seekable' argument is provided as a workaround for certain stdio
libraries in which tell() discards buffered data before discovering that the
lseek() system call doesn't work.  For maximum portability, you should set the
seekable argument to zero to prevent that initial \code{tell} when passing in
an unseekable object such as a file object created from a socket object.  If
it is 1 on entry -- which it is by default -- the tell() method of the open
file object is called once; if this raises an exception, seekable is reset to
0.  For other nonzero values of seekable, this test is not made.

To get the text of a particular header there are several methods:

  str = m.getheader(name)
  str = m.getrawheader(name)

where name is the name of the header, e.g. 'Subject'.  The difference is that
getheader() strips the leading and trailing whitespace, while getrawheader()
doesn't.  Both functions retain embedded whitespace (including newlines)
exactly as they are specified in the header, and leave the case of the text
unchanged.

For addresses and address lists there are functions

  realname, mailaddress = m.getaddr(name)
  list = m.getaddrlist(name)

where the latter returns a list of (realname, mailaddr) tuples.

There is also a method

  time = m.getdate(name)

which parses a Date-like field and returns a time-compatible tuple,
i.e. a tuple such as returned by time.localtime() or accepted by
time.mktime().

See the class definition for lower level access methods.

There are also some utility functions here.
iN(   t   warnpy3ks=   in 3.x, rfc822 has been removed in favor of the email packaget
   stackleveli   t   Messaget   AddressListt	   parsedatet   parsedate_tzt	   mktime_tzs   
s   
c           B   s  e  Z d  Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z	 d	   Z
 d
   Z d d  Z e Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z RS(   s/   Represents a single RFC 2822-compliant message.i   c         C   s   | d k r= y | j    Wq= t t f k
 r9 d } q= Xn  | |  _ | |  _ d |  _ d |  _ |  j r y |  j j    |  _ Wq t k
 r d |  _ q Xn  |  j   |  j r y |  j j    |  _ Wq t k
 r d |  _ q Xn  d S(   s3   Initialize the class instance and read the headers.i   i    N(	   t   tellt   AttributeErrort   IOErrort   fpt   seekablet   Nonet   startofheaderst   startofbodyt   readheaders(   t   selfR
   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __init__X   s(    					
	c         C   s,   |  j  s t d  n  |  j j |  j  d S(   s7   Rewind the file to the start of the body (if seekable).s   unseekable fileN(   R   R	   R
   t   seekR   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt
   rewindbodyt   s    	c   	      C   s8  i  |  _  d |  _ g  |  _ } d |  _ d } d } d } } } t |  j d  rc |  j j } n |  j r{ |  j j	 } n  x| r y |   } Wq t
 k
 r d } } d |  _ q Xn  |  j j   } | s d |  _ Pn  | r| j d  r|  j | |  _ q~ n  d } | re| d d k re| j |  |  j  | d | j   } | j   |  j  | <q~ n( |  j |  rzq~ n |  j |  rPn  |  j |  } | r| j |  | t |  d j   |  j  | <q~ q~ |  j  sd	 |  _ n	 d
 |  _ | r| |  n) | r |  j j |  n |  j d |  _ Pq~ d S(   s  Read header lines.

        Read header lines up to the entirely blank line that terminates them.
        The (normally blank) line that ends the headers is skipped, but not
        included in the returned list.  If a non-header line ends the headers,
        (which is an error), an attempt is made to backspace over it; it is
        never included in the returned list.

        The variable self.status is set to the empty string if all went well,
        otherwise it is an error message.  The variable self.headers is a
        completely uninterpreted list of lines contained in the header (so
        printing them will reproduce the header exactly as it appears in the
        file).
        t    i   t   unreadi    s   EOF in headerss   From s    	s   
 s
   No headerss%   Non-header line where header expecteds
   ; bad seekN(   t   dictt   unixfromt   headerst   statusR   t   hasattrR
   R   R   R   R	   t   readlinet
   startswitht   appendt   stript	   iscommentt   islastt   isheadert   lenR   (	   R   t   lstt
   headerseent	   firstlinet   startoflineR   R   t   linet   x(    (    s   /usr/lib/python2.7/rfc822.pyR   z   sb    				
	!		c         C   s-   | j  d  } | d k r) | |  j   Sd S(   s  Determine whether a given line is a legal header.

        This method should return the header name, suitably canonicalized.
        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats with special header formats.
        t   :i    N(   t   findt   lowerR   (   R   R'   t   i(    (    s   /usr/lib/python2.7/rfc822.pyR!      s    c         C   s
   | t  k S(   sf  Determine whether a line is a legal end of RFC 2822 headers.

        You may override this method if your application wants to bend the
        rules, e.g. to strip trailing whitespace, or to recognize MH template
        separators ('--------').  For convenience (e.g. for code reading from
        sockets) a line consisting of \r\n also matches.
        (   t   _blanklines(   R   R'   (    (    s   /usr/lib/python2.7/rfc822.pyR       s    c         C   s   t  S(   s   Determine whether a line should be skipped entirely.

        You may override this method in order to use Message parsing on tagged
        data in RFC 2822-like formats that support embedded comments or
        free-text data.
        (   t   False(   R   R'   (    (    s   /usr/lib/python2.7/rfc822.pyR      s    c         C   s   | j    d } t |  } g  } d } x_ |  j D]T } | |  j    | k rW d } n | d  j   sp d } n  | r2 | j |  q2 q2 W| S(   s  Find all header lines matching a given header name.

        Look through the list of headers and find all lines matching a given
        header name (and their continuation lines).  A list of the lines is
        returned, without interpretation.  If the header does not occur, an
        empty list is returned.  If the header occurs multiple times, all
        occurrences are returned.  Case is not important in the header name.
        R)   i    i   (   R+   R"   R   t   isspaceR   (   R   t   namet   nR#   t   hitR'   (    (    s   /usr/lib/python2.7/rfc822.pyt   getallmatchingheaders   s    			c         C   s   | j    d } t |  } g  } d } xc |  j D]X } | rU | d  j   st Pqt n | |  j    | k rt d } n  | r2 | j |  q2 q2 W| S(   s   Get the first header line matching name.

        This is similar to getallmatchingheaders, but it returns only the
        first matching header (and its continuation lines).
        R)   i    i   (   R+   R"   R   R/   R   (   R   R0   R1   R#   R2   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt   getfirstmatchingheader   s    	c         C   sB   |  j  |  } | s d S| d t |  d | d <d j |  S(   s2  A higher-level interface to getfirstmatchingheader().

        Return a string containing the literal text of the header but with the
        keyword stripped.  All leading, trailing and embedded whitespace is
        kept in the string, however.  Return None if the header does not
        occur.
        i    i   R   N(   R4   R   R"   t   join(   R   R0   R#   (    (    s   /usr/lib/python2.7/rfc822.pyt   getrawheader  s
    	c         C   s   |  j  j | j   |  S(   s  Get the header value for a name.

        This is the normal interface: it returns a stripped version of the
        header value for a given header name, or None if it doesn't exist.
        This uses the dictionary version which finds the *last* such header.
        (   R   t   getR+   (   R   R0   t   default(    (    s   /usr/lib/python2.7/rfc822.pyt	   getheader  s    c         C   s   g  } d } d } x |  j  |  D]} } | d j   rf | rW d | | j   f } q | j   } q" | r| | j |  n  | | j d  d j   } d } q" W| r | j |  n  | S(   s	  Get all values for a header.

        This returns a list of values for headers given more than once; each
        value in the result list is stripped in the same way as the result of
        getheader().  If the header is not given, return an empty list.
        R   i    s   %s
 %sR)   i   (   R3   R/   R   R   R*   (   R   R0   t   resultt   currentt   have_headert   s(    (    s   /usr/lib/python2.7/rfc822.pyt
   getheaders'  s    
c         C   s%   |  j  |  } | r | d Sd Sd S(   s   Get a single address from a header, as a tuple.

        An example return value:
        ('Guido van Rossum', 'guido@cwi.nl')
        i    N(   NN(   t   getaddrlistR   (   R   R0   t   alist(    (    s   /usr/lib/python2.7/rfc822.pyt   getaddr@  s    c         C   s   g  } x |  j  |  D]u } | d d k r< | j |  q | rR | j d  n  | j d  } | d k r~ | | d } n  | j |  q Wd j |  } t |  } | j S(   s
  Get a list of addresses from a header.

        Retrieves a list of addresses from a header, where each address is a
        tuple as returned by getaddr().  Scans all named headers, so it works
        properly with multiple To: or Cc: headers for example.
        i    s    	s   , R)   i   R   (   R3   R   R*   R5   R   t   addresslist(   R   R0   t   rawt   hR,   t   addrt   alladdrst   a(    (    s   /usr/lib/python2.7/rfc822.pyR?   M  s    c         C   s-   y |  | } Wn t  k
 r" d SXt |  S(   s   Retrieve a date field from a header.

        Retrieves a date field from the named header, returning a tuple
        compatible with time.mktime().
        N(   t   KeyErrorR   R   (   R   R0   t   data(    (    s   /usr/lib/python2.7/rfc822.pyt   getdatec  s
    c         C   s-   y |  | } Wn t  k
 r" d SXt |  S(   s   Retrieve a date field from a header as a 10-tuple.

        The first 9 elements make up a tuple compatible with time.mktime(),
        and the 10th is the offset of the poster's time zone from GMT/UTC.
        N(   RH   R   R   (   R   R0   RI   (    (    s   /usr/lib/python2.7/rfc822.pyt
   getdate_tzo  s
    c         C   s   t  |  j  S(   s'   Get the number of headers in a message.(   R"   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __len__~  s    c         C   s   |  j  | j   S(   s,   Get a specific header, as from a dictionary.(   R   R+   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   __getitem__  s    c         C   sZ   |  | =| |  j  | j   <| d | } x+ | j d  D] } |  j j | d  q8 Wd S(   s   Set the value of a header.

        Note: This is not a perfect inversion of __getitem__, because any
        changed headers get stuck at the end of the raw-headers list rather
        than where the altered header was.
        s   : s   
N(   R   R+   t   splitR   R   (   R   R0   t   valuet   textR'   (    (    s   /usr/lib/python2.7/rfc822.pyt   __setitem__  s
    c         C   s   | j    } | |  j k r d S|  j | =| d } t |  } g  } d } xx t t |  j   D]a } |  j | } | |  j    | k r d } n | d  j   s d } n  | ra | j |  qa qa Wx t |  D] } |  j | =q Wd S(   s>   Delete all occurrences of a specific header, if it is present.NR)   i    i   (   R+   R   R"   t   rangeR   R/   R   t   reversed(   R   R0   R1   R#   R2   R,   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt   __delitem__  s$    

		R   c         C   sw   | j    } | |  j k r& |  j | S| d | } x+ | j d  D] } |  j j | d  qD W| |  j | <| Sd  S(   Ns   : s   
(   R+   R   RN   R   R   (   R   R0   R8   t	   lowernameRP   R'   (    (    s   /usr/lib/python2.7/rfc822.pyt
   setdefault  s    c         C   s   | j    |  j k S(   s6   Determine whether a message contains the named header.(   R+   R   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   has_key  s    c         C   s   | j    |  j k S(   s6   Determine whether a message contains the named header.(   R+   R   (   R   R0   (    (    s   /usr/lib/python2.7/rfc822.pyt   __contains__  s    c         C   s   t  |  j  S(   N(   t   iterR   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __iter__  s    c         C   s   |  j  j   S(   s*   Get all of a message's header field names.(   R   t   keys(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR[     s    c         C   s   |  j  j   S(   s+   Get all of a message's header field values.(   R   t   values(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR\     s    c         C   s   |  j  j   S(   sW   Get all of a message's headers.

        Returns a list of name, value tuples.
        (   R   t   items(   R   (    (    s   /usr/lib/python2.7/rfc822.pyR]     s    c         C   s   d j  |  j  S(   NR   (   R5   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   __str__  s    N(    t   __name__t
   __module__t   __doc__R   R   R   R!   R    R   R3   R4   R6   R   R9   R7   R>   RA   R?   RJ   RK   RL   RM   RQ   RT   RV   RW   RX   RZ   R[   R\   R]   R^   (    (    (    s   /usr/lib/python2.7/rfc822.pyR   U   s:   		K		
																				c         C   s   t  |   d k r |  j d  rS |  j d  rS |  d d !j d d  j d d  S|  j d  r |  j d  r |  d d !Sn  |  S(	   s   Remove quotes from a string.i   t   "is   \\s   \s   \"t   <t   >(   R"   R   t   endswitht   replace(   R=   (    (    s   /usr/lib/python2.7/rfc822.pyt   unquote  s    #c         C   s   |  j  d d  j  d d  S(   s   Add quotes around a string.s   \s   \\Rb   s   \"(   Rf   (   R=   (    (    s   /usr/lib/python2.7/rfc822.pyt   quote  s    c         C   s'   t  |   } | j } | s d S| d S(   s3   Parse an address into a (realname, mailaddr) tuple.i    N(   NN(   R   RB   R   (   t   addressRG   R#   (    (    s   /usr/lib/python2.7/rfc822.pyt	   parseaddr  s
    	t   AddrlistClassc           B   s   e  Z d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d d	  Z
 d
   Z d   Z d   Z d d  Z d   Z RS(   s)  Address parser class by Ben Escoto.

    To understand what this class does, it helps to have a copy of
    RFC 2822 in front of you.

    http://www.faqs.org/rfcs/rfc2822.html

    Note: this class interface is deprecated and may be removed in the future.
    Use rfc822.AddressList instead.
    c         C   sl   d |  _  d |  _ d |  _ d |  _ |  j  |  j |  j |  _ |  j j d d  |  _ | |  _ g  |  _ d S(   s   Initialize a new instance.

        `field' is an unparsed address header field, containing one or more
        addresses.
        s   ()<>@,:;."[]i    s    	s   
t   .R   N(	   t   specialst   post   LWSt   CRt   atomendsRf   t
   phraseendst   fieldt   commentlist(   R   Rs   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    					c         C   s   x| |  j  t |  j  k  r~ |  j |  j  |  j d k rK |  j  d |  _  q |  j |  j  d k rz |  j j |  j    q Pq Wd S(   s*   Parse up to the start of the next address.s   
i   t   (N(   Rn   R"   Rs   Ro   Rt   R   t
   getcomment(   R   (    (    s   /usr/lib/python2.7/rfc822.pyt   gotonext  s    c         C   s9   g  } |  j    } x  | r4 | | 7} |  j    } q W| S(   sV   Parse all addresses.

        Returns a list containing all of the addresses.
        (   t
   getaddress(   R   R:   t   ad(    (    s   /usr/lib/python2.7/rfc822.pyR?     s    	
c         C   s  g  |  _  |  j   |  j } |  j  } |  j   } |  j   g  } |  j t |  j  k r | rPd j |  j   | d f g } qPn|  j |  j d k r | |  _ | |  _  |  j   } d j |  j   | f g } nz|  j |  j d k rg  } t |  j  } |  j d 7_ x=|  j t |  j  k  r|  j   |  j | k  rm|  j |  j d k rm|  j d 7_ Pn  | |  j   } qWn |  j |  j d k r|  j	   } |  j  rd j |  d d j |  j   d	 | f g } qPd j |  | f g } nS | r%d j |  j   | d f g } n+ |  j |  j |  j
 k rP|  j d 7_ n  |  j   |  j t |  j  k  r|  j |  j d
 k r|  j d 7_ n  | S(   s   Parse the next address.t    i    s   .@R)   i   t   ;Rc   s    (t   )t   ,(   Rt   Rw   Rn   t   getphraselistR"   Rs   R5   t   getaddrspecRx   t   getrouteaddrRm   (   R   t   oldpost   oldclt   plistt
   returnlistt   addrspect   fieldlent	   routeaddr(    (    s   /usr/lib/python2.7/rfc822.pyRx   #  sL    	
		
%		
%	3"
.c         C   s   |  j  |  j d k r d Sd } |  j d 7_ |  j   d } x |  j t |  j   k  r| rs |  j   d } n |  j  |  j d k r |  j d 7_ Pnr |  j  |  j d k r |  j d 7_ d } nD |  j  |  j d k r |  j d 7_ n |  j   } |  j d 7_ P|  j   qB W| S(	   s   Parse a route address (Return-path value).

        This method just skips all the route stuff and returns the addrspec.
        Rc   Ni    i   R   Rd   t   @R)   (   Rs   Rn   Rw   R"   t	   getdomainR   (   R   t   expectroutet   adlist(    (    s   /usr/lib/python2.7/rfc822.pyR   ]  s.    

		c         C   sF  g  } |  j    x |  j t |  j  k  r |  j |  j d k r` | j d  |  j d 7_ n` |  j |  j d k r | j d |  j    n0 |  j |  j |  j k r Pn | j |  j    |  j    q W|  j t |  j  k s |  j |  j d k r	d j |  S| j d  |  j d 7_ |  j    d j |  |  j	   S(   s   Parse an RFC 2822 addr-spec.Rl   i   Rb   s   "%s"R   R   (
   Rw   Rn   R"   Rs   R   t   getquoteRq   t   getatomR5   R   (   R   t   aslist(    (    s   /usr/lib/python2.7/rfc822.pyR   }  s$    
.
c         C   s  g  } x|  j  t |  j  k  r|  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k r{ |  j j |  j    q	 |  j |  j  d k r | j |  j    q	 |  j |  j  d k r |  j  d 7_  | j d  q	 |  j |  j  |  j k r Pq	 | j |  j	    q	 Wd j
 |  S(   s-   Get the complete domain name from an address.i   Ru   t   [Rl   R   (   Rn   R"   Rs   Ro   Rt   R   Rv   t   getdomainliteralRq   R   R5   (   R   t   sdlist(    (    s   /usr/lib/python2.7/rfc822.pyR     s    i   c         C   s3  |  j  |  j | k r d Sd g } d } |  j d 7_ x |  j t |  j   k  r%| d k r | j |  j  |  j  d } n |  j  |  j | k r |  j d 7_ Pnk | r |  j  |  j d k r | j |  j    q; n6 |  j  |  j d k r d } n | j |  j  |  j  |  j d 7_ q; Wd j |  S(   s  Parse a header fragment delimited by special characters.

        `beginchar' is the start character for the fragment.  If self is not
        looking at an instance of `beginchar' then getdelimited returns the
        empty string.

        `endchars' is a sequence of allowable end-delimiting characters.
        Parsing stops when one of these is encountered.

        If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
        within the parsed fragment.
        R   i    i   Ru   s   \(   Rs   Rn   R"   R   Rv   R5   (   R   t	   beginchart   endcharst   allowcommentst   slistRh   (    (    s   /usr/lib/python2.7/rfc822.pyt   getdelimited  s(    			c         C   s   |  j  d d d  S(   s1   Get a quote-delimited fragment from self's field.Rb   s   "i    (   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    c         C   s   |  j  d d d  S(   s7   Get a parenthesis-delimited fragment from self's field.Ru   s   )i   (   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRv     s    c         C   s   d |  j  d d d  S(   s!   Parse an RFC 2822 domain-literal.s   [%s]R   s   ]i    (   R   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    c         C   s   d g } | d k r! |  j } n  x\ |  j t |  j  k  r |  j |  j | k rV Pn | j |  j |  j  |  j d 7_ q$ Wd j |  S(   s  Parse an RFC 2822 atom.

        Optional atomends specifies a different set of end token delimiters
        (the default is to use self.atomends).  This is used e.g. in
        getphraselist() since phrase endings must not include the `.' (which
        is legal in phrases).R   i   N(   R   Rq   Rn   R"   Rs   R   R5   (   R   Rq   t   atomlist(    (    s   /usr/lib/python2.7/rfc822.pyR     s    	c         C   s   g  } x |  j  t |  j  k  r |  j |  j  |  j k rL |  j  d 7_  q	 |  j |  j  d k rx | j |  j    q	 |  j |  j  d k r |  j j |  j    q	 |  j |  j  |  j k r Pq	 | j |  j	 |  j   q	 W| S(   s   Parse a sequence of RFC 2822 phrases.

        A phrase is a sequence of words, which are in turn either RFC 2822
        atoms or quoted-strings.  Phrases are canonicalized by squeezing all
        runs of continuous whitespace into one space.
        i   Rb   Ru   (
   Rn   R"   Rs   Ro   R   R   Rt   Rv   Rr   R   (   R   R   (    (    s   /usr/lib/python2.7/rfc822.pyR~     s    N(   R_   R`   Ra   R   Rw   R?   Rx   R   R   R   R   R   Rv   R   R   R   R~   (    (    (    s   /usr/lib/python2.7/rfc822.pyRk     s   
					:	 		%			c           B   sV   e  Z d  Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 RS(	   s@   An AddressList encapsulates a list of parsed RFC 2822 addresses.c         C   s5   t  j |  |  | r( |  j   |  _ n	 g  |  _ d  S(   N(   Rk   R   R?   RB   (   R   Rs   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    c         C   s   t  |  j  S(   N(   R"   RB   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyRL     s    c         C   s   d j  t t |  j   S(   Ns   , (   R5   t   mapt   dump_address_pairRB   (   R   (    (    s   /usr/lib/python2.7/rfc822.pyR^     s    c         C   sS   t  d   } |  j | _ x3 | j D]( } | |  j k r# | j j |  q# q# W| S(   N(   R   R   RB   R   (   R   t   othert   newaddrR(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __add__  s    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j |  q
 q
 W|  S(   N(   RB   R   (   R   R   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __iadd__  s    c         C   sF   t  d   } x3 |  j D]( } | | j k r | j j |  q q W| S(   N(   R   R   RB   R   (   R   R   R   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __sub__!  s
    c         C   s:   x3 | j  D]( } | |  j  k r
 |  j  j |  q
 q
 W|  S(   N(   RB   t   remove(   R   R   R(   (    (    s   /usr/lib/python2.7/rfc822.pyt   __isub__)  s    c         C   s   |  j  | S(   N(   RB   (   R   t   index(    (    s   /usr/lib/python2.7/rfc822.pyRM   0  s    (   R_   R`   Ra   R   RL   R^   R   R   R   R   RM   (    (    (    s   /usr/lib/python2.7/rfc822.pyR     s   								c         C   s2   |  d r& d |  d d |  d d S|  d Sd S(   s4   Dump a (name, address) pair in a canonicalized form.i    Rb   s   " <i   Rd   N(    (   t   pair(    (    s   /usr/lib/python2.7/rfc822.pyR   4  s    
t   jant   febt   mart   aprt   mayt   junt   jult   augt   sept   octt   novt   dect   januaryt   februaryt   marcht   aprilt   junet   julyt   augustt	   septembert   octobert   novembert   decembert   mont   tuet   wedt   thut   frit   satt   suni    t   UTt   UTCt   GMTt   Zipt   ASTit   ADTit   ESTt   EDTit   CSTt   CDTiDt   MSTt   MDTit   PSTt   PDTc      
   C   s  |  s
 d S|  j   }  |  d d d k s@ |  d j   t k rJ |  d =n8 |  d j d  } | d k r |  d | d |  d <n  t |   d k r |  d j d  } t |  d k r | |  d }  q n  t |   d k r3|  d } | j d	  } | d k r#| |  | | d g |  d )q3|  j d
  n  t |   d k  rId S|  d  }  |  \ } } } } } | j   } | t k r| | j   } } | t k rd Sn  t j	 |  d } | d k r| d } n  | d d k r| d  } n  | j d  } | d k r| | } } n  | d d k r7| d  } n  | d j
   sW| | } } n  | d d k rt| d  } n  | j d  } t |  d k r| \ }	 }
 d } n( t |  d k r| \ }	 }
 } n d Sy@ t |  } t |  } t |	  }	 t |
  }
 t |  } Wn t k
 r&d SXd } | j   } | t k rRt | } n$ y t |  } Wn t k
 run X| r| d k  rd } | } n d } | | d d | d d } n  | | | |	 |
 | d d d | f
 S(   sQ   Convert a date string to a time tuple.

    Accounts for military timezones.
    i    iR}   Rl   i   i   t   -i   t   +R   i   i   R)   i   t   0id   i  i<   N(   R}   Rl   (   R   RN   R+   t	   _daynamest   rfindR"   R*   R   t   _monthnamesR   t   isdigitt   intt
   ValueErrort   uppert
   _timezones(   RI   R,   t   stuffR=   t   ddt   mmt   yyt   tmt   tzt   thht   tmmt   tsst   tzoffsett   tzsign(    (    s   /usr/lib/python2.7/rfc822.pyR   R  s    *


 	
!c         C   s$   t  |   } | d k r | S| d  S(   s&   Convert a time string to a time tuple.i	   N(   R   R   (   RI   t   t(    (    s   /usr/lib/python2.7/rfc822.pyR     s    c         C   sS   |  d d k r% t j |  d  d  St j |  d  d  } | |  d t j Sd S(   sC   Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp.i	   i   ii    N(   i(   i    (   R   t   timet   mktimet   timezone(   RI   R   (    (    s   /usr/lib/python2.7/rfc822.pyR     s    c         C   so   |  d k r t j   }  n  t j |   }  d d |  d	 |  d
 d |  d d |  d |  d |  d |  d f S(   s\  Returns time format preferred for Internet standards.

    Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123

    According to RFC 1123, day and month names must always be in
    English.  If not for that, this code could use strftime().  It
    can't because strftime() honors the locale and could generated
    non-English names.
    s#   %s, %02d %s %04d %02d:%02d:%02d GMTt   Mont   Tuet   Wedt   Thut   Frit   Satt   Suni   i   t   Jant   Febt   Mart   Aprt   Mayt   Junt   Jult   Augt   Sept   Octt   Novt   Deci   i    i   i   i   N(   R   R   R   R   R   R   R   (   R   R   R   R   R   R   R   R   R   R   R   R   (   R   R   t   gmtime(   t   timeval(    (    s   /usr/lib/python2.7/rfc822.pyt
   formatdate  s    
 t   __main__t   HOMEs   Mail/inbox/1i   t   rs   From:t   froms   To:t   tos   Subject:t   subjects   Date:t   dates   ParsedDate:i<   s	   %+03d%02ds   .%02ds   Lines:R   iF   s   len =t   Dates   Date =s
   X-Nonsenses   keys =s   values =s   items =(5   Ra   R   t   warningsR    t   __all__R-   R   Rg   Rh   Rj   Rk   R   R   R   R   R   R   R   R   R   R   R_   t   syst   ost   pathR5   t   environt   filet   argvt   opent   ft   mRA   R?   R9   RK   R  R   t	   localtimet   asctimet   hhmmsst   divmodt   hhmmt   sst   hhR   R   R1   R   R"   R[   R\   R]   (    (    (    s   /usr/lib/python2.7/rfc822.pyt   <module>G   s   	 	
			 2			U			 
 	
		                                                                           usr/lib/python2.7/rlcompleter.py                                                                    0100644 0000000 0000000 00000013270 12734733742 015315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Word completion for GNU readline.

The completer completes keywords, built-ins and globals in a selectable
namespace (which defaults to __main__); when completing NAME.NAME..., it
evaluates (!) the expression up to the last dot and completes its attributes.

It's very cool to do "import sys" type "sys.", hit the completion key (twice),
and see the list of names defined by the sys module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and generally cause
  the completion to fail).  This is a feature -- since readline sets the tty
  device in raw (or cbreak) mode, printing a traceback wouldn't work well
  without some complicated hoopla to save, reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary application
  defined code to be executed if an object with a __getattr__ hook is found.
  Since it is the responsibility of the application (or the user) to enable this
  feature, I consider this an acceptable risk.  More complicated expressions
  (e.g. function calls or indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
  used, and this module (and the readline module) are silently inactive.

"""

import __builtin__
import __main__

__all__ = ["Completer"]

class Completer:
    def __init__(self, namespace = None):
        """Create a new completer for the command line.

        Completer([namespace]) -> completer instance.

        If unspecified, the default namespace where completions are performed
        is __main__ (technically, __main__.__dict__). Namespaces should be
        given as dictionaries.

        Completer instances should be used as the completion mechanism of
        readline via the set_completer() call:

        readline.set_completer(Completer(my_namespace).complete)
        """

        if namespace and not isinstance(namespace, dict):
            raise TypeError,'namespace must be a dictionary'

        # Don't bind to namespace quite yet, but flag whether the user wants a
        # specific namespace or to use __main__.__dict__. This will allow us
        # to bind to __main__.__dict__ at completion time, not now.
        if namespace is None:
            self.use_main_ns = 1
        else:
            self.use_main_ns = 0
            self.namespace = namespace

    def complete(self, text, state):
        """Return the next possible completion for 'text'.

        This is called successively with state == 0, 1, 2, ... until it
        returns None.  The completion should begin with 'text'.

        """
        if self.use_main_ns:
            self.namespace = __main__.__dict__

        if state == 0:
            if "." in text:
                self.matches = self.attr_matches(text)
            else:
                self.matches = self.global_matches(text)
        try:
            return self.matches[state]
        except IndexError:
            return None

    def _callable_postfix(self, val, word):
        if hasattr(val, '__call__'):
            word = word + "("
        return word

    def global_matches(self, text):
        """Compute matches when text is a simple name.

        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace that match.

        """
        import keyword
        matches = []
        n = len(text)
        for word in keyword.kwlist:
            if word[:n] == text:
                matches.append(word)
        for nspace in [__builtin__.__dict__, self.namespace]:
            for word, val in nspace.items():
                if word[:n] == text and word != "__builtins__":
                    matches.append(self._callable_postfix(val, word))
        return matches

    def attr_matches(self, text):
        """Compute matches when text contains a dot.

        Assuming the text is of the form NAME.NAME....[NAME], and is
        evaluable in self.namespace, it will be evaluated and its attributes
        (as revealed by dir()) are used as possible completions.  (For class
        instances, class members are also considered.)

        WARNING: this can still invoke arbitrary C code, if an object
        with a __getattr__ hook is evaluated.

        """
        import re
        m = re.match(r"(\w+(\.\w+)*)\.(\w*)", text)
        if not m:
            return []
        expr, attr = m.group(1, 3)
        try:
            thisobject = eval(expr, self.namespace)
        except Exception:
            return []

        # get the content of the object, except __builtins__
        words = dir(thisobject)
        if "__builtins__" in words:
            words.remove("__builtins__")

        if hasattr(thisobject, '__class__'):
            words.append('__class__')
            words.extend(get_class_members(thisobject.__class__))
        matches = []
        n = len(attr)
        for word in words:
            if word[:n] == attr and hasattr(thisobject, word):
                val = getattr(thisobject, word)
                word = self._callable_postfix(val, "%s.%s" % (expr, word))
                matches.append(word)
        return matches

def get_class_members(klass):
    ret = dir(klass)
    if hasattr(klass,'__bases__'):
        for base in klass.__bases__:
            ret = ret + get_class_members(base)
    return ret

try:
    import readline
except ImportError:
    pass
else:
    readline.set_completer(Completer().complete)
                                                                                                                                                                                                                                                                                                                                        usr/lib/python2.7/rlcompleter.pyc                                                                   0100644 0000000 0000000 00000013512 13077704274 015456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s~   d  Z  d d l Z d d l Z d g Z d d d     YZ d   Z y d d l Z Wn e k
 rf n Xe j e   j	  d S(   sC  Word completion for GNU readline.

The completer completes keywords, built-ins and globals in a selectable
namespace (which defaults to __main__); when completing NAME.NAME..., it
evaluates (!) the expression up to the last dot and completes its attributes.

It's very cool to do "import sys" type "sys.", hit the completion key (twice),
and see the list of names defined by the sys module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and generally cause
  the completion to fail).  This is a feature -- since readline sets the tty
  device in raw (or cbreak) mode, printing a traceback wouldn't work well
  without some complicated hoopla to save, reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary application
  defined code to be executed if an object with a __getattr__ hook is found.
  Since it is the responsibility of the application (or the user) to enable this
  feature, I consider this an acceptable risk.  More complicated expressions
  (e.g. function calls or indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
  used, and this module (and the readline module) are silently inactive.

iNt	   Completerc           B   s8   e  Z d d   Z d   Z d   Z d   Z d   Z RS(   c         C   sP   | r" t  | t  r" t d  n  | d k r: d |  _ n d |  _ | |  _ d S(   s  Create a new completer for the command line.

        Completer([namespace]) -> completer instance.

        If unspecified, the default namespace where completions are performed
        is __main__ (technically, __main__.__dict__). Namespaces should be
        given as dictionaries.

        Completer instances should be used as the completion mechanism of
        readline via the set_completer() call:

        readline.set_completer(Completer(my_namespace).complete)
        s   namespace must be a dictionaryi   i    N(   t
   isinstancet   dictt	   TypeErrort   Nonet   use_main_nst	   namespace(   t   selfR   (    (    s!   /usr/lib/python2.7/rlcompleter.pyt   __init__,   s    	c         C   s   |  j  r t j |  _ n  | d k rZ d | k rE |  j |  |  _ qZ |  j |  |  _ n  y |  j | SWn t k
 r} d SXd S(   s   Return the next possible completion for 'text'.

        This is called successively with state == 0, 1, 2, ... until it
        returns None.  The completion should begin with 'text'.

        i    t   .N(	   R   t   __main__t   __dict__R   t   attr_matchest   matchest   global_matchest
   IndexErrorR   (   R   t   textt   state(    (    s!   /usr/lib/python2.7/rlcompleter.pyt   completeG   s    	c         C   s    t  | d  r | d } n  | S(   Nt   __call__t   ((   t   hasattr(   R   t   valt   word(    (    s!   /usr/lib/python2.7/rlcompleter.pyt   _callable_postfix[   s    c         C   s   d d l  } g  } t |  } x1 | j D]& } | |  | k r( | j |  q( q( Wxo t j |  j g D][ } xR | j   D]D \ } } | |  | k rx | d k rx | j |  j | |   qx qx Wqe W| S(   s   Compute matches when text is a simple name.

        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace that match.

        iNt   __builtins__(	   t   keywordt   lent   kwlistt   appendt   __builtin__R   R   t   itemsR   (   R   R   R   R   t   nR   t   nspaceR   (    (    s!   /usr/lib/python2.7/rlcompleter.pyR   `   s    $c         C   sI  d d l  } | j d |  } | s( g  S| j d d  \ } } y t | |  j  } Wn t k
 rj g  SXt |  } d | k r | j d  n  t | d  r | j	 d  | j
 t | j   n  g  } t |  }	 xh | D]` }
 |
 |	  | k r t | |
  r t | |
  } |  j | d | |
 f  }
 | j	 |
  q q W| S(	   s  Compute matches when text contains a dot.

        Assuming the text is of the form NAME.NAME....[NAME], and is
        evaluable in self.namespace, it will be evaluated and its attributes
        (as revealed by dir()) are used as possible completions.  (For class
        instances, class members are also considered.)

        WARNING: this can still invoke arbitrary C code, if an object
        with a __getattr__ hook is evaluated.

        iNs   (\w+(\.\w+)*)\.(\w*)i   i   R   t	   __class__s   %s.%s(   t   ret   matcht   groupt   evalR   t	   Exceptiont   dirt   removeR   R   t   extendt   get_class_membersR"   R   t   getattrR   (   R   R   R#   t   mt   exprt   attrt
   thisobjectt   wordsR   R    R   R   (    (    s!   /usr/lib/python2.7/rlcompleter.pyR   s   s.    N(   t   __name__t
   __module__R   R   R   R   R   R   (    (    (    s!   /usr/lib/python2.7/rlcompleter.pyR    +   s
   			c         C   sF   t  |   } t |  d  rB x$ |  j D] } | t |  } q% Wn  | S(   Nt	   __bases__(   R(   R   R4   R+   (   t   klasst   rett   base(    (    s!   /usr/lib/python2.7/rlcompleter.pyR+      s
    (    (
   t   __doc__R   R
   t   __all__R    R+   t   readlinet   ImportErrort   set_completerR   (    (    (    s!   /usr/lib/python2.7/rlcompleter.pyt   <module>$   s   	o	                                                                                                                                                                                      usr/lib/python2.7/robotparser.py                                                                    0100644 0000000 0000000 00000016644 12734733742 015337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """ robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt

"""
import urlparse
import urllib

__all__ = ["RobotFileParser"]


class RobotFileParser:
    """ This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

    """

    def __init__(self, url=''):
        self.entries = []
        self.default_entry = None
        self.disallow_all = False
        self.allow_all = False
        self.set_url(url)
        self.last_checked = 0

    def mtime(self):
        """Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        """
        return self.last_checked

    def modified(self):
        """Sets the time the robots.txt file was last fetched to the
        current time.

        """
        import time
        self.last_checked = time.time()

    def set_url(self, url):
        """Sets the URL referring to a robots.txt file."""
        self.url = url
        self.host, self.path = urlparse.urlparse(url)[1:3]

    def read(self):
        """Reads the robots.txt URL and feeds it to the parser."""
        opener = URLopener()
        f = opener.open(self.url)
        lines = [line.strip() for line in f]
        f.close()
        self.errcode = opener.errcode
        if self.errcode in (401, 403):
            self.disallow_all = True
        elif self.errcode >= 400 and self.errcode < 500:
            self.allow_all = True
        elif self.errcode == 200 and lines:
            self.parse(lines)

    def _add_entry(self, entry):
        if "*" in entry.useragents:
            # the default entry is considered last
            if self.default_entry is None:
                # the first default entry wins
                self.default_entry = entry
        else:
            self.entries.append(entry)

    def parse(self, lines):
        """parse the input lines from a robots.txt file.
           We allow that a user-agent: line is not preceded by
           one or more blank lines."""
        # states:
        #   0: start state
        #   1: saw user-agent line
        #   2: saw an allow or disallow line
        state = 0
        linenumber = 0
        entry = Entry()

        self.modified()
        for line in lines:
            linenumber += 1
            if not line:
                if state == 1:
                    entry = Entry()
                    state = 0
                elif state == 2:
                    self._add_entry(entry)
                    entry = Entry()
                    state = 0
            # remove optional comment and strip line
            i = line.find('#')
            if i >= 0:
                line = line[:i]
            line = line.strip()
            if not line:
                continue
            line = line.split(':', 1)
            if len(line) == 2:
                line[0] = line[0].strip().lower()
                line[1] = urllib.unquote(line[1].strip())
                if line[0] == "user-agent":
                    if state == 2:
                        self._add_entry(entry)
                        entry = Entry()
                    entry.useragents.append(line[1])
                    state = 1
                elif line[0] == "disallow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], False))
                        state = 2
                elif line[0] == "allow":
                    if state != 0:
                        entry.rulelines.append(RuleLine(line[1], True))
                        state = 2
        if state == 2:
            self._add_entry(entry)


    def can_fetch(self, useragent, url):
        """using the parsed robots.txt decide if useragent can fetch url"""
        if self.disallow_all:
            return False
        if self.allow_all:
            return True

        # Until the robots.txt file has been read or found not
        # to exist, we must assume that no url is allowable.
        # This prevents false positives when a user erronenously
        # calls can_fetch() before calling read().
        if not self.last_checked:
            return False

        # search for given user agent matches
        # the first match counts
        parsed_url = urlparse.urlparse(urllib.unquote(url))
        url = urlparse.urlunparse(('', '', parsed_url.path,
            parsed_url.params, parsed_url.query, parsed_url.fragment))
        url = urllib.quote(url)
        if not url:
            url = "/"
        for entry in self.entries:
            if entry.applies_to(useragent):
                return entry.allowance(url)
        # try the default entry last
        if self.default_entry:
            return self.default_entry.allowance(url)
        # agent not found ==> access granted
        return True


    def __str__(self):
        return ''.join([str(entry) + "\n" for entry in self.entries])


class RuleLine:
    """A rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path."""
    def __init__(self, path, allowance):
        if path == '' and not allowance:
            # an empty value means allow all
            allowance = True
        path = urlparse.urlunparse(urlparse.urlparse(path))
        self.path = urllib.quote(path)
        self.allowance = allowance

    def applies_to(self, filename):
        return self.path == "*" or filename.startswith(self.path)

    def __str__(self):
        return (self.allowance and "Allow" or "Disallow") + ": " + self.path


class Entry:
    """An entry has one or more user-agents and zero or more rulelines"""
    def __init__(self):
        self.useragents = []
        self.rulelines = []

    def __str__(self):
        ret = []
        for agent in self.useragents:
            ret.extend(["User-agent: ", agent, "\n"])
        for line in self.rulelines:
            ret.extend([str(line), "\n"])
        return ''.join(ret)

    def applies_to(self, useragent):
        """check if this entry applies to the specified agent"""
        # split the name token and make it lower case
        useragent = useragent.split("/")[0].lower()
        for agent in self.useragents:
            if agent == '*':
                # we have the catch-all agent
                return True
            agent = agent.lower()
            if agent in useragent:
                return True
        return False

    def allowance(self, filename):
        """Preconditions:
        - our agent applies to this entry
        - filename is URL decoded"""
        for line in self.rulelines:
            if line.applies_to(filename):
                return line.allowance
        return True

class URLopener(urllib.FancyURLopener):
    def __init__(self, *args):
        urllib.FancyURLopener.__init__(self, *args)
        self.errcode = 200

    def prompt_user_passwd(self, host, realm):
        ## If robots.txt file is accessible only with a password,
        ## we act as if the file wasn't there.
        return None, None

    def http_error_default(self, url, fp, errcode, errmsg, headers):
        self.errcode = errcode
        return urllib.FancyURLopener.http_error_default(self, url, fp, errcode,
                                                        errmsg, headers)
                                                                                            usr/lib/python2.7/robotparser.pyc                                                                   0100644 0000000 0000000 00000017350 13077704274 015474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s}   d  Z  d d l Z d d l Z d g Z d d d     YZ d d d     YZ d d d     YZ d	 e j f d
     YZ d S(   s&   robotparser.py

    Copyright (C) 2000  Bastian Kleineidam

    You can choose between two licenses when using this package:
    1) GNU GPLv2
    2) PSF license for Python 2.2

    The robots.txt Exclusion Protocol is implemented as specified in
    http://www.robotstxt.org/norobots-rfc.txt

iNt   RobotFileParserc           B   sb   e  Z d  Z d d  Z d   Z d   Z d   Z d   Z d   Z d   Z	 d	   Z
 d
   Z RS(   ss    This class provides a set of methods to read, parse and answer
    questions about a single robots.txt file.

    t    c         C   s>   g  |  _  d  |  _ t |  _ t |  _ |  j |  d |  _ d  S(   Ni    (   t   entriest   Nonet   default_entryt   Falset   disallow_allt	   allow_allt   set_urlt   last_checked(   t   selft   url(    (    s!   /usr/lib/python2.7/robotparser.pyt   __init__   s    				c         C   s   |  j  S(   s   Returns the time the robots.txt file was last fetched.

        This is useful for long-running web spiders that need to
        check for new robots.txt files periodically.

        (   R	   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyt   mtime!   s    c         C   s   d d l  } | j    |  _ d S(   sY   Sets the time the robots.txt file was last fetched to the
        current time.

        iN(   t   timeR	   (   R
   R   (    (    s!   /usr/lib/python2.7/robotparser.pyt   modified*   s    c         C   s/   | |  _  t j |  d d !\ |  _ |  _ d S(   s,   Sets the URL referring to a robots.txt file.i   i   N(   R   t   urlparset   hostt   path(   R
   R   (    (    s!   /usr/lib/python2.7/robotparser.pyR   2   s    	c         C   s   t    } | j |  j  } g  | D] } | j   ^ q" } | j   | j |  _ |  j d k rk t |  _ nO |  j d k r |  j d k  r t |  _ n% |  j d k r | r |  j	 |  n  d S(   s4   Reads the robots.txt URL and feeds it to the parser.i  i  i  i  i   N(   i  i  (
   t	   URLopenert   openR   t   stript   closet   errcodet   TrueR   R   t   parse(   R
   t   openert   ft   linet   lines(    (    s!   /usr/lib/python2.7/robotparser.pyt   read7   s    	
c         C   sA   d | j  k r- |  j d  k r= | |  _ q= n |  j j |  d  S(   Nt   *(   t
   useragentsR   R   R   t   append(   R
   t   entry(    (    s!   /usr/lib/python2.7/robotparser.pyt
   _add_entryE   s    c         C   s&  d } d } t    } |  j   x| D]} | d 7} | s | d k rZ t    } d } q | d k r |  j |  t    } d } q n  | j d  } | d k r | |  } n  | j   } | s q& n  | j d d  } t |  d k r& | d j   j   | d <t j	 | d j    | d <| d d k ru| d k rX|  j |  t    } n  | j
 j | d  d } q| d d k r| d k r| j j t | d t   d } qq| d d k r| d k r| j j t | d t   d } qqq& q& W| d k r"|  j |  n  d	 S(
   s   parse the input lines from a robots.txt file.
           We allow that a user-agent: line is not preceded by
           one or more blank lines.i    i   i   t   #t   :s
   user-agentt   disallowt   allowN(   t   EntryR   R#   t   findR   t   splitt   lent   lowert   urllibt   unquoteR    R!   t	   rulelinest   RuleLineR   R   (   R
   R   t   statet
   linenumberR"   R   t   i(    (    s!   /usr/lib/python2.7/robotparser.pyR   N   sP    	

				c         C   s   |  j  r t S|  j r t S|  j s' t St j t j |   } t j d d | j	 | j
 | j | j f  } t j |  } | s d } n  x- |  j D]" } | j |  r | j |  Sq W|  j r |  j j |  St S(   s=   using the parsed robots.txt decide if useragent can fetch urlR   t   /(   R   R   R   R   R	   R   R-   R.   t
   urlunparseR   t   paramst   queryt   fragmentt   quoteR   t
   applies_tot	   allowanceR   (   R
   t	   useragentR   t
   parsed_urlR"   (    (    s!   /usr/lib/python2.7/robotparser.pyt	   can_fetch   s$    					c         C   s-   d j  g  |  j D] } t |  d ^ q  S(   NR   s   
(   t   joinR   t   str(   R
   R"   (    (    s!   /usr/lib/python2.7/robotparser.pyt   __str__   s    (   t   __name__t
   __module__t   __doc__R   R   R   R   R   R#   R   R>   RA   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR       s   								4	 R0   c           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   so   A rule line is a single "Allow:" (allowance==True) or "Disallow:"
       (allowance==False) followed by a path.c         C   sS   | d k r | r t  } n  t j t j |   } t j |  |  _ | |  _ d  S(   NR   (   R   R   R5   R-   R9   R   R;   (   R
   R   R;   (    (    s!   /usr/lib/python2.7/robotparser.pyR      s
    	c         C   s   |  j  d k p | j |  j   S(   NR   (   R   t
   startswith(   R
   t   filename(    (    s!   /usr/lib/python2.7/robotparser.pyR:      s    c         C   s   |  j  r d p d d |  j S(   Nt   Allowt   Disallows   : (   R;   R   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyRA      s    (   RB   RC   RD   R   R:   RA   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR0      s   		R(   c           B   s2   e  Z d  Z d   Z d   Z d   Z d   Z RS(   s?   An entry has one or more user-agents and zero or more rulelinesc         C   s   g  |  _  g  |  _ d  S(   N(   R    R/   (   R
   (    (    s!   /usr/lib/python2.7/robotparser.pyR      s    	c         C   sj   g  } x' |  j  D] } | j d | d g  q Wx* |  j D] } | j t |  d g  q: Wd j |  S(   Ns   User-agent: s   
R   (   R    t   extendR/   R@   R?   (   R
   t   rett   agentR   (    (    s!   /usr/lib/python2.7/robotparser.pyRA      s    c         C   s]   | j  d  d j   } x= |  j D]2 } | d k r9 t S| j   } | | k r# t Sq# Wt S(   s2   check if this entry applies to the specified agentR4   i    R   (   R*   R,   R    R   R   (   R
   R<   RK   (    (    s!   /usr/lib/python2.7/robotparser.pyR:      s    c         C   s.   x' |  j  D] } | j |  r
 | j Sq
 Wt S(   sZ   Preconditions:
        - our agent applies to this entry
        - filename is URL decoded(   R/   R:   R;   R   (   R
   RF   R   (    (    s!   /usr/lib/python2.7/robotparser.pyR;      s    (   RB   RC   RD   R   RA   R:   R;   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR(      s
   			R   c           B   s#   e  Z d    Z d   Z d   Z RS(   c         G   s    t  j j |  |  d |  _ d  S(   Ni   (   R-   t   FancyURLopenerR   R   (   R
   t   args(    (    s!   /usr/lib/python2.7/robotparser.pyR      s    c         C   s   d S(   N(   NN(   R   (   R
   R   t   realm(    (    s!   /usr/lib/python2.7/robotparser.pyt   prompt_user_passwd   s    c         C   s(   | |  _  t j j |  | | | | |  S(   N(   R   R-   RL   t   http_error_default(   R
   R   t   fpR   t   errmsgt   headers(    (    s!   /usr/lib/python2.7/robotparser.pyRP      s    	(   RB   RC   R   RO   RP   (    (    (    s!   /usr/lib/python2.7/robotparser.pyR      s   		(    (    (    (	   RD   R   R-   t   __all__R    R0   R(   RL   R   (    (    (    s!   /usr/lib/python2.7/robotparser.pyt   <module>   s   	$                                                                                                                                                                                                                                                                                        usr/lib/python2.7/runpy.py                                                                          0100644 0000000 0000000 00000024712 12734733742 014145  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """runpy.py - locating and running Python code using the module namespace

Provides support for locating and running Python scripts using the Python
module namespace instead of the native filesystem.

This allows Python code to play nicely with non-filesystem based PEP 302
importers when locating support scripts as well as when importing modules.
"""
# Written by Nick Coghlan <ncoghlan at gmail.com>
#    to implement PEP 338 (Executing Modules as Scripts)

import sys
import imp
from pkgutil import read_code
try:
    from imp import get_loader
except ImportError:
    from pkgutil import get_loader

__all__ = [
    "run_module", "run_path",
]

class _TempModule(object):
    """Temporarily replace a module in sys.modules with an empty namespace"""
    def __init__(self, mod_name):
        self.mod_name = mod_name
        self.module = imp.new_module(mod_name)
        self._saved_module = []

    def __enter__(self):
        mod_name = self.mod_name
        try:
            self._saved_module.append(sys.modules[mod_name])
        except KeyError:
            pass
        sys.modules[mod_name] = self.module
        return self

    def __exit__(self, *args):
        if self._saved_module:
            sys.modules[self.mod_name] = self._saved_module[0]
        else:
            del sys.modules[self.mod_name]
        self._saved_module = []

class _ModifiedArgv0(object):
    def __init__(self, value):
        self.value = value
        self._saved_value = self._sentinel = object()

    def __enter__(self):
        if self._saved_value is not self._sentinel:
            raise RuntimeError("Already preserving saved value")
        self._saved_value = sys.argv[0]
        sys.argv[0] = self.value

    def __exit__(self, *args):
        self.value = self._sentinel
        sys.argv[0] = self._saved_value

def _run_code(code, run_globals, init_globals=None,
              mod_name=None, mod_fname=None,
              mod_loader=None, pkg_name=None):
    """Helper to run code in nominated namespace"""
    if init_globals is not None:
        run_globals.update(init_globals)
    run_globals.update(__name__ = mod_name,
                       __file__ = mod_fname,
                       __loader__ = mod_loader,
                       __package__ = pkg_name)
    exec code in run_globals
    return run_globals

def _run_module_code(code, init_globals=None,
                    mod_name=None, mod_fname=None,
                    mod_loader=None, pkg_name=None):
    """Helper to run code in new namespace with sys modified"""
    with _TempModule(mod_name) as temp_module, _ModifiedArgv0(mod_fname):
        mod_globals = temp_module.module.__dict__
        _run_code(code, mod_globals, init_globals,
                  mod_name, mod_fname, mod_loader, pkg_name)
    # Copy the globals of the temporary module, as they
    # may be cleared when the temporary module goes away
    return mod_globals.copy()


# This helper is needed due to a missing component in the PEP 302
# loader protocol (specifically, "get_filename" is non-standard)
# Since we can't introduce new features in maintenance releases,
# support was added to zipimporter under the name '_get_filename'
def _get_filename(loader, mod_name):
    for attr in ("get_filename", "_get_filename"):
        meth = getattr(loader, attr, None)
        if meth is not None:
            return meth(mod_name)
    return None

# Helper to get the loader, code and filename for a module
def _get_module_details(mod_name):
    loader = get_loader(mod_name)
    if loader is None:
        raise ImportError("No module named %s" % mod_name)
    if loader.is_package(mod_name):
        if mod_name == "__main__" or mod_name.endswith(".__main__"):
            raise ImportError("Cannot use package as __main__ module")
        try:
            pkg_main_name = mod_name + ".__main__"
            return _get_module_details(pkg_main_name)
        except ImportError, e:
            raise ImportError(("%s; %r is a package and cannot " +
                               "be directly executed") %(e, mod_name))
    code = loader.get_code(mod_name)
    if code is None:
        raise ImportError("No code object available for %s" % mod_name)
    filename = _get_filename(loader, mod_name)
    return mod_name, loader, code, filename


def _get_main_module_details():
    # Helper that gives a nicer error message when attempting to
    # execute a zipfile or directory by invoking __main__.py
    main_name = "__main__"
    try:
        return _get_module_details(main_name)
    except ImportError as exc:
        if main_name in str(exc):
            raise ImportError("can't find %r module in %r" %
                              (main_name, sys.path[0]))
        raise

# This function is the actual implementation of the -m switch and direct
# execution of zipfiles and directories and is deliberately kept private.
# This avoids a repeat of the situation where run_module() no longer met the
# needs of mainmodule.c, but couldn't be changed because it was public
def _run_module_as_main(mod_name, alter_argv=True):
    """Runs the designated module in the __main__ namespace

       Note that the executed module will have full access to the
       __main__ namespace. If this is not desirable, the run_module()
       function should be used to run the module code in a fresh namespace.

       At the very least, these variables in __main__ will be overwritten:
           __name__
           __file__
           __loader__
           __package__
    """
    try:
        if alter_argv or mod_name != "__main__": # i.e. -m switch
            mod_name, loader, code, fname = _get_module_details(mod_name)
        else:          # i.e. directory or zipfile execution
            mod_name, loader, code, fname = _get_main_module_details()
    except ImportError as exc:
        msg = "%s: %s" % (sys.executable, str(exc))
        sys.exit(msg)
    pkg_name = mod_name.rpartition('.')[0]
    main_globals = sys.modules["__main__"].__dict__
    if alter_argv:
        sys.argv[0] = fname
    return _run_code(code, main_globals, None,
                     "__main__", fname, loader, pkg_name)

def run_module(mod_name, init_globals=None,
               run_name=None, alter_sys=False):
    """Execute a module's code without importing it

       Returns the resulting top level namespace dictionary
    """
    mod_name, loader, code, fname = _get_module_details(mod_name)
    if run_name is None:
        run_name = mod_name
    pkg_name = mod_name.rpartition('.')[0]
    if alter_sys:
        return _run_module_code(code, init_globals, run_name,
                                fname, loader, pkg_name)
    else:
        # Leave the sys module alone
        return _run_code(code, {}, init_globals, run_name,
                         fname, loader, pkg_name)


# XXX (ncoghlan): Perhaps expose the C API function
# as imp.get_importer instead of reimplementing it in Python?
def _get_importer(path_name):
    """Python version of PyImport_GetImporter C API function"""
    cache = sys.path_importer_cache
    try:
        importer = cache[path_name]
    except KeyError:
        # Not yet cached. Flag as using the
        # standard machinery until we finish
        # checking the hooks
        cache[path_name] = None
        for hook in sys.path_hooks:
            try:
                importer = hook(path_name)
                break
            except ImportError:
                pass
        else:
            # The following check looks a bit odd. The trick is that
            # NullImporter raises ImportError if the supplied path is a
            # *valid* directory entry (and hence able to be handled
            # by the standard import machinery)
            try:
                importer = imp.NullImporter(path_name)
            except ImportError:
                return None
        cache[path_name] = importer
    return importer

def _get_code_from_file(fname):
    # Check for a compiled file first
    with open(fname, "rb") as f:
        code = read_code(f)
    if code is None:
        # That didn't work, so try it as normal source code
        with open(fname, "rU") as f:
            code = compile(f.read(), fname, 'exec')
    return code

def run_path(path_name, init_globals=None, run_name=None):
    """Execute code located at the specified filesystem location

       Returns the resulting top level namespace dictionary

       The file path may refer directly to a Python script (i.e.
       one that could be directly executed with execfile) or else
       it may refer to a zipfile or directory containing a top
       level __main__.py script.
    """
    if run_name is None:
        run_name = "<run_path>"
    importer = _get_importer(path_name)
    if isinstance(importer, imp.NullImporter):
        # Not a valid sys.path entry, so run the code directly
        # execfile() doesn't help as we want to allow compiled files
        code = _get_code_from_file(path_name)
        return _run_module_code(code, init_globals, run_name, path_name)
    else:
        # Importer is defined for path, so add it to
        # the start of sys.path
        sys.path.insert(0, path_name)
        try:
            # Here's where things are a little different from the run_module
            # case. There, we only had to replace the module in sys while the
            # code was running and doing so was somewhat optional. Here, we
            # have no choice and we have to remove it even while we read the
            # code. If we don't do this, a __loader__ attribute in the
            # existing __main__ module may prevent location of the new module.
            main_name = "__main__"
            saved_main = sys.modules[main_name]
            del sys.modules[main_name]
            try:
                mod_name, loader, code, fname = _get_main_module_details()
            finally:
                sys.modules[main_name] = saved_main
            pkg_name = ""
            with _TempModule(run_name) as temp_module, \
                 _ModifiedArgv0(path_name):
                mod_globals = temp_module.module.__dict__
                return _run_code(code, mod_globals, init_globals,
                                    run_name, fname, loader, pkg_name).copy()
        finally:
            try:
                sys.path.remove(path_name)
            except ValueError:
                pass


if __name__ == "__main__":
    # Run the module specified as the next command line argument
    if len(sys.argv) < 2:
        print >> sys.stderr, "No module specified for execution"
    else:
        del sys.argv[0] # Make the requested module sys.argv[0]
        _run_module_as_main(sys.argv[0])
                                                      usr/lib/python2.7/runpy.pyc                                                                         0100644 0000000 0000000 00000020255 13077704256 014305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
sWc           @   s{  d  Z  d d l Z d d l Z d d l m Z y d d l m Z Wn! e k
 re d d l m Z n Xd d g Z d e f d     YZ	 d	 e f d
     YZ
 d d d d d d  Z d d d d d d  Z d   Z d   Z d   Z e d  Z d d e d  Z d   Z d   Z d d d  Z e d k rwe e j  d k  rYe j d IJqwe j d =e e j d  n  d S(   sZ  runpy.py - locating and running Python code using the module namespace

Provides support for locating and running Python scripts using the Python
module namespace instead of the native filesystem.

This allows Python code to play nicely with non-filesystem based PEP 302
importers when locating support scripts as well as when importing modules.
iN(   t	   read_code(   t
   get_loadert
   run_modulet   run_patht   _TempModulec           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   sC   Temporarily replace a module in sys.modules with an empty namespacec         C   s(   | |  _  t j |  |  _ g  |  _ d  S(   N(   t   mod_namet   impt
   new_modulet   modulet   _saved_module(   t   selfR   (    (    s   /usr/lib/python2.7/runpy.pyt   __init__   s    	c         C   sL   |  j  } y |  j j t j |  Wn t k
 r7 n X|  j t j | <|  S(   N(   R   R	   t   appendt   syst   modulest   KeyErrorR   (   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyt	   __enter__   s    	c         G   s=   |  j  r# |  j  d t j |  j <n t j |  j =g  |  _  d  S(   Ni    (   R	   R   R   R   (   R
   t   args(    (    s   /usr/lib/python2.7/runpy.pyt   __exit__(   s    	(   t   __name__t
   __module__t   __doc__R   R   R   (    (    (    s   /usr/lib/python2.7/runpy.pyR      s   			t   _ModifiedArgv0c           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s    | |  _  t   |  _ |  _ d  S(   N(   t   valuet   objectt   _saved_valuet	   _sentinel(   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyR   0   s    	c         C   sE   |  j  |  j k	 r! t d   n  t j d |  _  |  j t j d <d  S(   Ns   Already preserving saved valuei    (   R   R   t   RuntimeErrorR   t   argvR   (   R
   (    (    s   /usr/lib/python2.7/runpy.pyR   4   s    c         G   s    |  j  |  _ |  j t j d <d  S(   Ni    (   R   R   R   R   R   (   R
   R   (    (    s   /usr/lib/python2.7/runpy.pyR   :   s    (   R   R   R   R   R   (    (    (    s   /usr/lib/python2.7/runpy.pyR   /   s   		c      	   B   sJ   | d k	 r | j |  n  | j d | d | d | d |  |  | U| S(   s)   Helper to run code in nominated namespaceR   t   __file__t
   __loader__t   __package__N(   t   Nonet   update(   t   codet   run_globalst   init_globalsR   t	   mod_fnamet
   mod_loadert   pkg_name(    (    s   /usr/lib/python2.7/runpy.pyt	   _run_code>   s    c         C   sZ   t  |  B } t |  - | j j } t |  | | | | | |  Wd QXWd QX| j   S(   s5   Helper to run code in new namespace with sys modifiedN(   R   R   R   t   __dict__R(   t   copy(   R"   R$   R   R%   R&   R'   t   temp_modulet   mod_globals(    (    s   /usr/lib/python2.7/runpy.pyt   _run_module_codeK   s     c         C   s=   x6 d D]. } t  |  | d   } | d  k	 r | |  Sq Wd  S(   Nt   get_filenamet   _get_filename(   s   get_filenames   _get_filename(   t   getattrR    (   t   loaderR   t   attrt   meth(    (    s   /usr/lib/python2.7/runpy.pyR/   \   s
    c         C   s   t  |   } | d  k r+ t d |    n  | j |   r |  d k sU |  j d  rd t d   n  y |  d } t |  SWq t k
 r } t d d | |  f   q Xn  | j |   } | d  k r t d |    n  t | |   } |  | | | f S(   Ns   No module named %st   __main__s	   .__main__s%   Cannot use package as __main__ modules   %s; %r is a package and cannot s   be directly executeds   No code object available for %s(   R   R    t   ImportErrort
   is_packaget   endswitht   _get_module_detailst   get_codeR/   (   R   R1   t   pkg_main_namet   eR"   t   filename(    (    s   /usr/lib/python2.7/runpy.pyR8   d   s"    
c          C   sc   d }  y t  |   SWnH t k
 r^ } |  t |  k rX t d |  t j d f   n    n Xd  S(   NR4   s   can't find %r module in %ri    (   R8   R5   t   strR   t   path(   t	   main_namet   exc(    (    s   /usr/lib/python2.7/runpy.pyt   _get_main_module_detailsx   s    c   	      C   s   yF | s |  d k r0 t  |   \ }  } } } n t   \ }  } } } Wn9 t k
 r } d t j t |  f } t j |  n X|  j d  d } t j d j	 } | r | t j
 d <n  t | | d d | | |  S(   s  Runs the designated module in the __main__ namespace

       Note that the executed module will have full access to the
       __main__ namespace. If this is not desirable, the run_module()
       function should be used to run the module code in a fresh namespace.

       At the very least, these variables in __main__ will be overwritten:
           __name__
           __file__
           __loader__
           __package__
    R4   s   %s: %st   .i    N(   R8   RA   R5   R   t
   executableR=   t   exitt
   rpartitionR   R)   R   R(   R    (	   R   t
   alter_argvR1   R"   t   fnameR@   t   msgR'   t   main_globals(    (    s   /usr/lib/python2.7/runpy.pyt   _run_module_as_main   s    c         C   s   t  |   \ }  } } } | d k r- |  } n  |  j d  d } | r_ t | | | | | |  St | i  | | | | |  Sd S(   sn   Execute a module's code without importing it

       Returns the resulting top level namespace dictionary
    RB   i    N(   R8   R    RE   R-   R(   (   R   R$   t   run_namet	   alter_sysR1   R"   RG   R'   (    (    s   /usr/lib/python2.7/runpy.pyR      s    	c         C   s   t  j } y | |  } Wn t k
 r d | |  <x^ t  j D]+ } y | |   } PWq; t k
 re q; Xq; Wy t j |   } Wn t k
 r d SX| | |  <n X| S(   s5   Python version of PyImport_GetImporter C API functionN(   R   t   path_importer_cacheR   R    t
   path_hooksR5   R   t   NullImporter(   t	   path_namet   cachet   importert   hook(    (    s   /usr/lib/python2.7/runpy.pyt   _get_importer   s"    	
c      	   C   sg   t  |  d   } t |  } Wd  QX| d  k rc t  |  d   } t | j   |  d  } Wd  QXn  | S(   Nt   rbt   rUt   exec(   t   openR    R    t   compilet   read(   RG   t   fR"   (    (    s   /usr/lib/python2.7/runpy.pyt   _get_code_from_file   s    !c         C   s<  | d k r d } n  t |   } t | t j  rR t |   } t | | | |   St j j	 d |   z d } t j
 | } t j
 | =z t   \ } } } }	 Wd | t j
 | <Xd }
 t |  H } t |   3 | j j } t | | | | |	 | |
  j   SWd QXWd QXWd y t j j |   Wn t k
 r6n XXd S(   s_  Execute code located at the specified filesystem location

       Returns the resulting top level namespace dictionary

       The file path may refer directly to a Python script (i.e.
       one that could be directly executed with execfile) or else
       it may refer to a zipfile or directory containing a top
       level __main__.py script.
    s
   <run_path>i    R4   Nt    (   R    RT   t
   isinstanceR   RO   R\   R-   R   R>   t   insertR   RA   R   R   R   R)   R(   R*   t   removet
   ValueError(   RP   R$   RK   RR   R"   R?   t
   saved_mainR   R1   RG   R'   R+   R,   (    (    s   /usr/lib/python2.7/runpy.pyR      s0    
	
&R4   i   s!   No module specified for executioni    (   R   R   R   t   pkgutilR    R   R5   t   __all__R   R   R   R    R(   R-   R/   R8   RA   t   TrueRJ   t   FalseR   RT   R\   R   R   t   lenR   t   stderr(    (    (    s   /usr/lib/python2.7/runpy.pyt   <module>   s<   					
1
                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/sched.py                                                                          0100644 0000000 0000000 00000011740 12734733742 014053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """A generally useful event scheduler class.

Each instance of this class manages its own queue.
No multi-threading is implied; you are supposed to hack that
yourself, or use a single instance per application.

Each instance is parametrized with two functions, one that is
supposed to return the current time, one that is supposed to
implement a delay.  You can implement real-time scheduling by
substituting time and sleep from built-in module time, or you can
implement simulated time by writing your own functions.  This can
also be used to integrate scheduling with STDWIN events; the delay
function is allowed to modify the queue.  Time can be expressed as
integers or floating point numbers, as long as it is consistent.

Events are specified by tuples (time, priority, action, argument).
As in UNIX, lower priority numbers mean higher priority; in this
way the queue can be maintained as a priority queue.  Execution of the
event means calling the action function, passing it the argument
sequence in "argument" (remember that in Python, multiple function
arguments are be packed in a sequence).
The action function may be an instance method so it
has another way to reference private data (besides global variables).
"""

# XXX The timefunc and delayfunc should have been defined as methods
# XXX so you can define new kinds of schedulers using subclassing
# XXX instead of having to define a module or class just to hold
# XXX the global state of your particular time and delay functions.

import heapq
from collections import namedtuple

__all__ = ["scheduler"]

Event = namedtuple('Event', 'time, priority, action, argument')

class scheduler:
    def __init__(self, timefunc, delayfunc):
        """Initialize a new instance, passing the time and delay
        functions"""
        self._queue = []
        self.timefunc = timefunc
        self.delayfunc = delayfunc

    def enterabs(self, time, priority, action, argument):
        """Enter a new event in the queue at an absolute time.

        Returns an ID for the event which can be used to remove it,
        if necessary.

        """
        event = Event(time, priority, action, argument)
        heapq.heappush(self._queue, event)
        return event # The ID

    def enter(self, delay, priority, action, argument):
        """A variant that specifies the time as a relative time.

        This is actually the more commonly used interface.

        """
        time = self.timefunc() + delay
        return self.enterabs(time, priority, action, argument)

    def cancel(self, event):
        """Remove an event from the queue.

        This must be presented the ID as returned by enter().
        If the event is not in the queue, this raises ValueError.

        """
        self._queue.remove(event)
        heapq.heapify(self._queue)

    def empty(self):
        """Check whether the queue is empty."""
        return not self._queue

    def run(self):
        """Execute events until the queue is empty.

        When there is a positive delay until the first event, the
        delay function is called and the event is left in the queue;
        otherwise, the event is removed from the queue and executed
        (its action function is called, passing it the argument).  If
        the delay function returns prematurely, it is simply
        restarted.

        It is legal for both the delay function and the action
        function to modify the queue or to raise an exception;
        exceptions are not caught but the scheduler's state remains
        well-defined so run() may be called aga