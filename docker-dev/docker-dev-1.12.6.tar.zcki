int numPoints, double width, int capStyle, 
				int joinStyle, double * rectPtr));
/* 88 */
EXTERN void		TkWmAddToColormapWindows _ANSI_ARGS_((
				TkWindow * winPtr));
/* 89 */
EXTERN void		TkWmDeadWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 90 */
EXTERN TkWindow *	TkWmFocusToplevel _ANSI_ARGS_((TkWindow * winPtr));
/* 91 */
EXTERN void		TkWmMapWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 92 */
EXTERN void		TkWmNewWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 93 */
EXTERN void		TkWmProtocolEventProc _ANSI_ARGS_((TkWindow * winPtr, 
				XEvent * evenvPtr));
/* 94 */
EXTERN void		TkWmRemoveFromColormapWindows _ANSI_ARGS_((
				TkWindow * winPtr));
/* 95 */
EXTERN void		TkWmRestackToplevel _ANSI_ARGS_((TkWindow * winPtr, 
				int aboveBelow, TkWindow * otherPtr));
/* 96 */
EXTERN void		TkWmSetClass _ANSI_ARGS_((TkWindow * winPtr));
/* 97 */
EXTERN void		TkWmUnmapWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 98 */
EXTERN Tcl_Obj *	TkDebugBitmap _ANSI_ARGS_((Tk_Window tkwin, 
				char * name));
/* 99 */
EXTERN Tcl_Obj *	TkDebugBorder _ANSI_ARGS_((Tk_Window tkwin, 
				char * name));
/* 100 */
EXTERN Tcl_Obj *	TkDebugCursor _ANSI_ARGS_((Tk_Window tkwin, 
				char * name));
/* 101 */
EXTERN Tcl_Obj *	TkDebugColor _ANSI_ARGS_((Tk_Window tkwin, 
				char * name));
/* 102 */
EXTERN Tcl_Obj *	TkDebugConfig _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_OptionTable table));
/* 103 */
EXTERN Tcl_Obj *	TkDebugFont _ANSI_ARGS_((Tk_Window tkwin, 
				char * name));
/* 104 */
EXTERN int		TkFindStateNumObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * optionPtr, 
				CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr));
/* 105 */
EXTERN Tcl_HashTable *	TkGetBitmapPredefTable _ANSI_ARGS_((void));
/* 106 */
EXTERN TkDisplay *	TkGetDisplayList _ANSI_ARGS_((void));
/* 107 */
EXTERN TkMainInfo *	TkGetMainInfoList _ANSI_ARGS_((void));
/* 108 */
EXTERN int		TkGetWindowFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tcl_Obj * objPtr, 
				Tk_Window * windowPtr));
/* 109 */
EXTERN char *		TkpGetString _ANSI_ARGS_((TkWindow * winPtr, 
				XEvent * eventPtr, Tcl_DString * dsPtr));
/* 110 */
EXTERN void		TkpGetSubFonts _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Font tkfont));
/* 111 */
EXTERN Tcl_Obj *	TkpGetSystemDefault _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * dbName, CONST char * className));
/* 112 */
EXTERN void		TkpMenuThreadInit _ANSI_ARGS_((void));
#ifdef __WIN32__
/* 113 */
EXTERN void		TkClipBox _ANSI_ARGS_((TkRegion rgn, 
				XRectangle* rect_return));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 113 */
EXTERN void		TkClipBox _ANSI_ARGS_((TkRegion rgn, 
				XRectangle* rect_return));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 113 */
EXTERN void		TkClipBox _ANSI_ARGS_((TkRegion rgn, 
				XRectangle* rect_return));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 114 */
EXTERN TkRegion		TkCreateRegion _ANSI_ARGS_((void));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 114 */
EXTERN TkRegion		TkCreateRegion _ANSI_ARGS_((void));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 114 */
EXTERN TkRegion		TkCreateRegion _ANSI_ARGS_((void));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 115 */
EXTERN void		TkDestroyRegion _ANSI_ARGS_((TkRegion rgn));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 115 */
EXTERN void		TkDestroyRegion _ANSI_ARGS_((TkRegion rgn));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 115 */
EXTERN void		TkDestroyRegion _ANSI_ARGS_((TkRegion rgn));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 116 */
EXTERN void		TkIntersectRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 116 */
EXTERN void		TkIntersectRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 116 */
EXTERN void		TkIntersectRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 117 */
EXTERN int		TkRectInRegion _ANSI_ARGS_((TkRegion rgn, int x, 
				int y, unsigned int width, 
				unsigned int height));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 117 */
EXTERN int		TkRectInRegion _ANSI_ARGS_((TkRegion rgn, int x, 
				int y, unsigned int width, 
				unsigned int height));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 117 */
EXTERN int		TkRectInRegion _ANSI_ARGS_((TkRegion rgn, int x, 
				int y, unsigned int width, 
				unsigned int height));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 118 */
EXTERN void		TkSetRegion _ANSI_ARGS_((Display* display, GC gc, 
				TkRegion rgn));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 118 */
EXTERN void		TkSetRegion _ANSI_ARGS_((Display* display, GC gc, 
				TkRegion rgn));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 118 */
EXTERN void		TkSetRegion _ANSI_ARGS_((Display* display, GC gc, 
				TkRegion rgn));
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
/* 119 */
EXTERN void		TkUnionRectWithRegion _ANSI_ARGS_((XRectangle* rect, 
				TkRegion src, TkRegion dr_return));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 119 */
EXTERN void		TkUnionRectWithRegion _ANSI_ARGS_((XRectangle* rect, 
				TkRegion src, TkRegion dr_return));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 119 */
EXTERN void		TkUnionRectWithRegion _ANSI_ARGS_((XRectangle* rect, 
				TkRegion src, TkRegion dr_return));
#endif /* MAC_OSX_TK */
/* Slot 120 is reserved */
#ifdef MAC_TCL
/* 121 */
EXTERN Pixmap		TkpCreateNativeBitmap _ANSI_ARGS_((Display * display, 
				CONST char * source));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 121 */
EXTERN Pixmap		TkpCreateNativeBitmap _ANSI_ARGS_((Display * display, 
				CONST char * source));
#endif /* MAC_OSX_TK */
#ifdef MAC_TCL
/* 122 */
EXTERN void		TkpDefineNativeBitmaps _ANSI_ARGS_((void));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 122 */
EXTERN void		TkpDefineNativeBitmaps _ANSI_ARGS_((void));
#endif /* MAC_OSX_TK */
/* Slot 123 is reserved */
#ifdef MAC_TCL
/* 124 */
EXTERN Pixmap		TkpGetNativeAppBitmap _ANSI_ARGS_((Display * display, 
				CONST char * name, int * width, int * height));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 124 */
EXTERN Pixmap		TkpGetNativeAppBitmap _ANSI_ARGS_((Display * display, 
				CONST char * name, int * width, int * height));
#endif /* MAC_OSX_TK */
/* Slot 125 is reserved */
/* Slot 126 is reserved */
/* Slot 127 is reserved */
/* Slot 128 is reserved */
/* Slot 129 is reserved */
/* Slot 130 is reserved */
/* Slot 131 is reserved */
/* Slot 132 is reserved */
/* Slot 133 is reserved */
/* Slot 134 is reserved */
/* 135 */
EXTERN void		TkpDrawHighlightBorder _ANSI_ARGS_((Tk_Window tkwin, 
				GC fgGC, GC bgGC, int highlightWidth, 
				Drawable drawable));
/* 136 */
EXTERN void		TkSetFocusWin _ANSI_ARGS_((TkWindow * winPtr, 
				int force));
/* 137 */
EXTERN void		TkpSetKeycodeAndState _ANSI_ARGS_((Tk_Window tkwin, 
				KeySym keySym, XEvent * eventPtr));
/* 138 */
EXTERN KeySym		TkpGetKeySym _ANSI_ARGS_((TkDisplay * dispPtr, 
				XEvent * eventPtr));
/* 139 */
EXTERN void		TkpInitKeymapInfo _ANSI_ARGS_((TkDisplay * dispPtr));
/* 140 */
EXTERN TkRegion		TkPhotoGetValidRegion _ANSI_ARGS_((
				Tk_PhotoHandle handle));
/* 141 */
EXTERN TkWindow **	TkWmStackorderToplevel _ANSI_ARGS_((
				TkWindow * parentPtr));
/* 142 */
EXTERN void		TkFocusFree _ANSI_ARGS_((TkMainInfo * mainPtr));
/* 143 */
EXTERN void		TkClipCleanup _ANSI_ARGS_((TkDisplay * dispPtr));
/* 144 */
EXTERN void		TkGCCleanup _ANSI_ARGS_((TkDisplay * dispPtr));
#ifdef __WIN32__
/* 145 */
EXTERN void		TkSubtractRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 145 */
EXTERN void		TkSubtractRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 145 */
EXTERN void		TkSubtractRegion _ANSI_ARGS_((TkRegion sra, 
				TkRegion srcb, TkRegion dr_return));
#endif /* MAC_OSX_TK */
/* 146 */
EXTERN void		TkStylePkgInit _ANSI_ARGS_((TkMainInfo * mainPtr));
/* 147 */
EXTERN void		TkStylePkgFree _ANSI_ARGS_((TkMainInfo * mainPtr));
/* 148 */
EXTERN Tk_Window	TkToplevelWindowForCommand _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * cmdName));
/* 149 */
EXTERN CONST Tk_OptionSpec * TkGetOptionSpec _ANSI_ARGS_((CONST char * name, 
				Tk_OptionTable optionTable));
/* Slot 150 is reserved */
/* Slot 151 is reserved */
/* 152 */
EXTERN void		TkpDrawFrame _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_3DBorder border, int highlightWidth, 
				int borderWidth, int relief));

typedef struct TkIntStubs {
    int magic;
    struct TkIntStubHooks *hooks;

    TkWindow * (*tkAllocWindow) _ANSI_ARGS_((TkDisplay * dispPtr, int screenNum, TkWindow * parentPtr)); /* 0 */
    void (*tkBezierPoints) _ANSI_ARGS_((double control[], int numSteps, double * coordPtr)); /* 1 */
    void (*tkBezierScreenPoints) _ANSI_ARGS_((Tk_Canvas canvas, double control[], int numSteps, XPoint * xPointPtr)); /* 2 */
    void (*tkBindDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 3 */
    void (*tkBindEventProc) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr)); /* 4 */
    void (*tkBindFree) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 5 */
    void (*tkBindInit) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 6 */
    void (*tkChangeEventWindow) _ANSI_ARGS_((XEvent * eventPtr, TkWindow * winPtr)); /* 7 */
    int (*tkClipInit) _ANSI_ARGS_((Tcl_Interp * interp, TkDisplay * dispPtr)); /* 8 */
    void (*tkComputeAnchor) _ANSI_ARGS_((Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int * xPtr, int * yPtr)); /* 9 */
    int (*tkCopyAndGlobalEval) _ANSI_ARGS_((Tcl_Interp * interp, char * script)); /* 10 */
    unsigned long (*tkCreateBindingProcedure) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventString, TkBindEvalProc * evalProc, TkBindFreeProc * freeProc, ClientData clientData)); /* 11 */
    TkCursor * (*tkCreateCursorFromData) _ANSI_ARGS_((Tk_Window tkwin, CONST char * source, CONST char * mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg)); /* 12 */
    int (*tkCreateFrame) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, int argc, char ** argv, int toplevel, char * appName)); /* 13 */
    Tk_Window (*tkCreateMainWindow) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * screenName, char * baseName)); /* 14 */
    Time (*tkCurrentTime) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 15 */
    void (*tkDeleteAllImages) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 16 */
    void (*tkDoConfigureNotify) _ANSI_ARGS_((TkWindow * winPtr)); /* 17 */
    void (*tkDrawInsetFocusHighlight) _ANSI_ARGS_((Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding)); /* 18 */
    void (*tkEventDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 19 */
    void (*tkFillPolygon) _ANSI_ARGS_((Tk_Canvas canvas, double * coordPtr, int numPoints, Display * display, Drawable drawable, GC gc, GC outlineGC)); /* 20 */
    int (*tkFindStateNum) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * option, CONST TkStateMap * mapPtr, CONST char * strKey)); /* 21 */
    char * (*tkFindStateString) _ANSI_ARGS_((CONST TkStateMap * mapPtr, int numKey)); /* 22 */
    void (*tkFocusDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 23 */
    int (*tkFocusFilterEvent) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr)); /* 24 */
    TkWindow * (*tkFocusKeyEvent) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr)); /* 25 */
    void (*tkFontPkgInit) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 26 */
    void (*tkFontPkgFree) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 27 */
    void (*tkFreeBindingTags) _ANSI_ARGS_((TkWindow * winPtr)); /* 28 */
    void (*tkpFreeCursor) _ANSI_ARGS_((TkCursor * cursorPtr)); /* 29 */
    char * (*tkGetBitmapData) _ANSI_ARGS_((Tcl_Interp * interp, char * string, char * fileName, int * widthPtr, int * heightPtr, int * hotXPtr, int * hotYPtr)); /* 30 */
    void (*tkGetButtPoints) _ANSI_ARGS_((double p1[], double p2[], double width, int project, double m1[], double m2[])); /* 31 */
    TkCursor * (*tkGetCursorByName) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid string)); /* 32 */
    CONST84_RETURN char * (*tkGetDefaultScreenName) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * screenName)); /* 33 */
    TkDisplay * (*tkGetDisplay) _ANSI_ARGS_((Display * display)); /* 34 */
    int (*tkGetDisplayOf) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], Tk_Window * tkwinPtr)); /* 35 */
    TkWindow * (*tkGetFocusWin) _ANSI_ARGS_((TkWindow * winPtr)); /* 36 */
    int (*tkGetInterpNames) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin)); /* 37 */
    int (*tkGetMiterPoints) _ANSI_ARGS_((double p1[], double p2[], double p3[], double width, double m1[], double m2[])); /* 38 */
    void (*tkGetPointerCoords) _ANSI_ARGS_((Tk_Window tkwin, int * xPtr, int * yPtr)); /* 39 */
    void (*tkGetServerInfo) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin)); /* 40 */
    void (*tkGrabDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 41 */
    int (*tkGrabState) _ANSI_ARGS_((TkWindow * winPtr)); /* 42 */
    void (*tkIncludePoint) _ANSI_ARGS_((Tk_Item * itemPtr, double * pointPtr)); /* 43 */
    void (*tkInOutEvents) _ANSI_ARGS_((XEvent * eventPtr, TkWindow * sourcePtr, TkWindow * destPtr, int leaveType, int enterType, Tcl_QueuePosition position)); /* 44 */
    void (*tkInstallFrameMenu) _ANSI_ARGS_((Tk_Window tkwin)); /* 45 */
    char * (*tkKeysymToString) _ANSI_ARGS_((KeySym keysym)); /* 46 */
    int (*tkLineToArea) _ANSI_ARGS_((double end1Ptr[], double end2Ptr[], double rectPtr[])); /* 47 */
    double (*tkLineToPoint) _ANSI_ARGS_((double end1Ptr[], double end2Ptr[], double pointPtr[])); /* 48 */
    int (*tkMakeBezierCurve) _ANSI_ARGS_((Tk_Canvas canvas, double * pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[])); /* 49 */
    void (*tkMakeBezierPostscript) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, double * pointPtr, int numPoints)); /* 50 */
    void (*tkOptionClassChanged) _ANSI_ARGS_((TkWindow * winPtr)); /* 51 */
    void (*tkOptionDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 52 */
    int (*tkOvalToArea) _ANSI_ARGS_((double * ovalPtr, double * rectPtr)); /* 53 */
    double (*tkOvalToPoint) _ANSI_ARGS_((double ovalPtr[], double width, int filled, double pointPtr[])); /* 54 */
    int (*tkpChangeFocus) _ANSI_ARGS_((TkWindow * winPtr, int force)); /* 55 */
    void (*tkpCloseDisplay) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 56 */
    void (*tkpClaimFocus) _ANSI_ARGS_((TkWindow * topLevelPtr, int force)); /* 57 */
    void (*tkpDisplayWarning) _ANSI_ARGS_((CONST char * msg, CONST char * title)); /* 58 */
    void (*tkpGetAppName) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_DString * name)); /* 59 */
    TkWindow * (*tkpGetOtherWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 60 */
    TkWindow * (*tkpGetWrapperWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 61 */
    int (*tkpInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 62 */
    void (*tkpInitializeMenuBindings) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable)); /* 63 */
    void (*tkpMakeContainer) _ANSI_ARGS_((Tk_Window tkwin)); /* 64 */
    void (*tkpMakeMenuWindow) _ANSI_ARGS_((Tk_Window tkwin, int transient)); /* 65 */
    Window (*tkpMakeWindow) _ANSI_ARGS_((TkWindow * winPtr, Window parent)); /* 66 */
    void (*tkpMenuNotifyToplevelCreate) _ANSI_ARGS_((Tcl_Interp * interp1, char * menuName)); /* 67 */
    TkDisplay * (*tkpOpenDisplay) _ANSI_ARGS_((CONST char * display_name)); /* 68 */
    int (*tkPointerEvent) _ANSI_ARGS_((XEvent * eventPtr, TkWindow * winPtr)); /* 69 */
    int (*tkPolygonToArea) _ANSI_ARGS_((double * polyPtr, int numPoints, double * rectPtr)); /* 70 */
    double (*tkPolygonToPoint) _ANSI_ARGS_((double * polyPtr, int numPoints, double * pointPtr)); /* 71 */
    int (*tkPositionInTree) _ANSI_ARGS_((TkWindow * winPtr, TkWindow * treePtr)); /* 72 */
    void (*tkpRedirectKeyEvent) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr)); /* 73 */
    void (*tkpSetMainMenubar) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, char * menuName)); /* 74 */
    int (*tkpUseWindow) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * string)); /* 75 */
    int (*tkpWindowWasRecentlyDeleted) _ANSI_ARGS_((Window win, TkDisplay * dispPtr)); /* 76 */
    void (*tkQueueEventForAllChildren) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr)); /* 77 */
    int (*tkReadBitmapFile) _ANSI_ARGS_((Display* display, Drawable d, CONST char* filename, unsigned int* width_return, unsigned int* height_return, Pixmap* bitmap_return, int* x_hot_return, int* y_hot_return)); /* 78 */
    int (*tkScrollWindow) _ANSI_ARGS_((Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn)); /* 79 */
    void (*tkSelDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 80 */
    void (*tkSelEventProc) _ANSI_ARGS_((Tk_Window tkwin, XEvent * eventPtr)); /* 81 */
    void (*tkSelInit) _ANSI_ARGS_((Tk_Window tkwin)); /* 82 */
    void (*tkSelPropProc) _ANSI_ARGS_((XEvent * eventPtr)); /* 83 */
    void *reserved84;
    void (*tkSetWindowMenuBar) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, char * oldMenuName, char * menuName)); /* 85 */
    KeySym (*tkStringToKeysym) _ANSI_ARGS_((char * name)); /* 86 */
    int (*tkThickPolyLineToArea) _ANSI_ARGS_((double * coordPtr, int numPoints, double width, int capStyle, int joinStyle, double * rectPtr)); /* 87 */
    void (*tkWmAddToColormapWindows) _ANSI_ARGS_((TkWindow * winPtr)); /* 88 */
    void (*tkWmDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 89 */
    TkWindow * (*tkWmFocusToplevel) _ANSI_ARGS_((TkWindow * winPtr)); /* 90 */
    void (*tkWmMapWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 91 */
    void (*tkWmNewWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 92 */
    void (*tkWmProtocolEventProc) _ANSI_ARGS_((TkWindow * winPtr, XEvent * evenvPtr)); /* 93 */
    void (*tkWmRemoveFromColormapWindows) _ANSI_ARGS_((TkWindow * winPtr)); /* 94 */
    void (*tkWmRestackToplevel) _ANSI_ARGS_((TkWindow * winPtr, int aboveBelow, TkWindow * otherPtr)); /* 95 */
    void (*tkWmSetClass) _ANSI_ARGS_((TkWindow * winPtr)); /* 96 */
    void (*tkWmUnmapWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 97 */
    Tcl_Obj * (*tkDebugBitmap) _ANSI_ARGS_((Tk_Window tkwin, char * name)); /* 98 */
    Tcl_Obj * (*tkDebugBorder) _ANSI_ARGS_((Tk_Window tkwin, char * name)); /* 99 */
    Tcl_Obj * (*tkDebugCursor) _ANSI_ARGS_((Tk_Window tkwin, char * name)); /* 100 */
    Tcl_Obj * (*tkDebugColor) _ANSI_ARGS_((Tk_Window tkwin, char * name)); /* 101 */
    Tcl_Obj * (*tkDebugConfig) _ANSI_ARGS_((Tcl_Interp * interp, Tk_OptionTable table)); /* 102 */
    Tcl_Obj * (*tkDebugFont) _ANSI_ARGS_((Tk_Window tkwin, char * name)); /* 103 */
    int (*tkFindStateNumObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * optionPtr, CONST TkStateMap * mapPtr, Tcl_Obj * keyPtr)); /* 104 */
    Tcl_HashTable * (*tkGetBitmapPredefTable) _ANSI_ARGS_((void)); /* 105 */
    TkDisplay * (*tkGetDisplayList) _ANSI_ARGS_((void)); /* 106 */
    TkMainInfo * (*tkGetMainInfoList) _ANSI_ARGS_((void)); /* 107 */
    int (*tkGetWindowFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr, Tk_Window * windowPtr)); /* 108 */
    char * (*tkpGetString) _ANSI_ARGS_((TkWindow * winPtr, XEvent * eventPtr, Tcl_DString * dsPtr)); /* 109 */
    void (*tkpGetSubFonts) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Font tkfont)); /* 110 */
    Tcl_Obj * (*tkpGetSystemDefault) _ANSI_ARGS_((Tk_Window tkwin, CONST char * dbName, CONST char * className)); /* 111 */
    void (*tkpMenuThreadInit) _ANSI_ARGS_((void)); /* 112 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved113;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkClipBox) _ANSI_ARGS_((TkRegion rgn, XRectangle* rect_return)); /* 113 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkClipBox) _ANSI_ARGS_((TkRegion rgn, XRectangle* rect_return)); /* 113 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkClipBox) _ANSI_ARGS_((TkRegion rgn, XRectangle* rect_return)); /* 113 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved114;
#endif /* UNIX */
#ifdef __WIN32__
    TkRegion (*tkCreateRegion) _ANSI_ARGS_((void)); /* 114 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    TkRegion (*tkCreateRegion) _ANSI_ARGS_((void)); /* 114 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    TkRegion (*tkCreateRegion) _ANSI_ARGS_((void)); /* 114 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved115;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkDestroyRegion) _ANSI_ARGS_((TkRegion rgn)); /* 115 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkDestroyRegion) _ANSI_ARGS_((TkRegion rgn)); /* 115 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkDestroyRegion) _ANSI_ARGS_((TkRegion rgn)); /* 115 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved116;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkIntersectRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 116 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkIntersectRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 116 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkIntersectRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 116 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved117;
#endif /* UNIX */
#ifdef __WIN32__
    int (*tkRectInRegion) _ANSI_ARGS_((TkRegion rgn, int x, int y, unsigned int width, unsigned int height)); /* 117 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    int (*tkRectInRegion) _ANSI_ARGS_((TkRegion rgn, int x, int y, unsigned int width, unsigned int height)); /* 117 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    int (*tkRectInRegion) _ANSI_ARGS_((TkRegion rgn, int x, int y, unsigned int width, unsigned int height)); /* 117 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved118;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkSetRegion) _ANSI_ARGS_((Display* display, GC gc, TkRegion rgn)); /* 118 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkSetRegion) _ANSI_ARGS_((Display* display, GC gc, TkRegion rgn)); /* 118 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkSetRegion) _ANSI_ARGS_((Display* display, GC gc, TkRegion rgn)); /* 118 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved119;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkUnionRectWithRegion) _ANSI_ARGS_((XRectangle* rect, TkRegion src, TkRegion dr_return)); /* 119 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkUnionRectWithRegion) _ANSI_ARGS_((XRectangle* rect, TkRegion src, TkRegion dr_return)); /* 119 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkUnionRectWithRegion) _ANSI_ARGS_((XRectangle* rect, TkRegion src, TkRegion dr_return)); /* 119 */
#endif /* MAC_OSX_TK */
    void *reserved120;
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved121;
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved121;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    Pixmap (*tkpCreateNativeBitmap) _ANSI_ARGS_((Display * display, CONST char * source)); /* 121 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    Pixmap (*tkpCreateNativeBitmap) _ANSI_ARGS_((Display * display, CONST char * source)); /* 121 */
#endif /* MAC_OSX_TK */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved122;
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved122;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkpDefineNativeBitmaps) _ANSI_ARGS_((void)); /* 122 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkpDefineNativeBitmaps) _ANSI_ARGS_((void)); /* 122 */
#endif /* MAC_OSX_TK */
    void *reserved123;
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved124;
#endif /* UNIX */
#ifdef __WIN32__
    void *reserved124;
#endif /* __WIN32__ */
#ifdef MAC_TCL
    Pixmap (*tkpGetNativeAppBitmap) _ANSI_ARGS_((Display * display, CONST char * name, int * width, int * height)); /* 124 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    Pixmap (*tkpGetNativeAppBitmap) _ANSI_ARGS_((Display * display, CONST char * name, int * width, int * height)); /* 124 */
#endif /* MAC_OSX_TK */
    void *reserved125;
    void *reserved126;
    void *reserved127;
    void *reserved128;
    void *reserved129;
    void *reserved130;
    void *reserved131;
    void *reserved132;
    void *reserved133;
    void *reserved134;
    void (*tkpDrawHighlightBorder) _ANSI_ARGS_((Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable)); /* 135 */
    void (*tkSetFocusWin) _ANSI_ARGS_((TkWindow * winPtr, int force)); /* 136 */
    void (*tkpSetKeycodeAndState) _ANSI_ARGS_((Tk_Window tkwin, KeySym keySym, XEvent * eventPtr)); /* 137 */
    KeySym (*tkpGetKeySym) _ANSI_ARGS_((TkDisplay * dispPtr, XEvent * eventPtr)); /* 138 */
    void (*tkpInitKeymapInfo) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 139 */
    TkRegion (*tkPhotoGetValidRegion) _ANSI_ARGS_((Tk_PhotoHandle handle)); /* 140 */
    TkWindow ** (*tkWmStackorderToplevel) _ANSI_ARGS_((TkWindow * parentPtr)); /* 141 */
    void (*tkFocusFree) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 142 */
    void (*tkClipCleanup) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 143 */
    void (*tkGCCleanup) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 144 */
#if !defined(__WIN32__) && !defined(MAC_TCL) /* UNIX */
    void *reserved145;
#endif /* UNIX */
#ifdef __WIN32__
    void (*tkSubtractRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 145 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkSubtractRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 145 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkSubtractRegion) _ANSI_ARGS_((TkRegion sra, TkRegion srcb, TkRegion dr_return)); /* 145 */
#endif /* MAC_OSX_TK */
    void (*tkStylePkgInit) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 146 */
    void (*tkStylePkgFree) _ANSI_ARGS_((TkMainInfo * mainPtr)); /* 147 */
    Tk_Window (*tkToplevelWindowForCommand) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * cmdName)); /* 148 */
    CONST Tk_OptionSpec * (*tkGetOptionSpec) _ANSI_ARGS_((CONST char * name, Tk_OptionTable optionTable)); /* 149 */
    void *reserved150;
    void *reserved151;
    void (*tkpDrawFrame) _ANSI_ARGS_((Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief)); /* 152 */
} TkIntStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntStubs *tkIntStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifndef TkAllocWindow
#define TkAllocWindow \
	(tkIntStubsPtr->tkAllocWindow) /* 0 */
#endif
#ifndef TkBezierPoints
#define TkBezierPoints \
	(tkIntStubsPtr->tkBezierPoints) /* 1 */
#endif
#ifndef TkBezierScreenPoints
#define TkBezierScreenPoints \
	(tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
#endif
#ifndef TkBindDeadWindow
#define TkBindDeadWindow \
	(tkIntStubsPtr->tkBindDeadWindow) /* 3 */
#endif
#ifndef TkBindEventProc
#define TkBindEventProc \
	(tkIntStubsPtr->tkBindEventProc) /* 4 */
#endif
#ifndef TkBindFree
#define TkBindFree \
	(tkIntStubsPtr->tkBindFree) /* 5 */
#endif
#ifndef TkBindInit
#define TkBindInit \
	(tkIntStubsPtr->tkBindInit) /* 6 */
#endif
#ifndef TkChangeEventWindow
#define TkChangeEventWindow \
	(tkIntStubsPtr->tkChangeEventWindow) /* 7 */
#endif
#ifndef TkClipInit
#define TkClipInit \
	(tkIntStubsPtr->tkClipInit) /* 8 */
#endif
#ifndef TkComputeAnchor
#define TkComputeAnchor \
	(tkIntStubsPtr->tkComputeAnchor) /* 9 */
#endif
#ifndef TkCopyAndGlobalEval
#define TkCopyAndGlobalEval \
	(tkIntStubsPtr->tkCopyAndGlobalEval) /* 10 */
#endif
#ifndef TkCreateBindingProcedure
#define TkCreateBindingProcedure \
	(tkIntStubsPtr->tkCreateBindingProcedure) /* 11 */
#endif
#ifndef TkCreateCursorFromData
#define TkCreateCursorFromData \
	(tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
#endif
#ifndef TkCreateFrame
#define TkCreateFrame \
	(tkIntStubsPtr->tkCreateFrame) /* 13 */
#endif
#ifndef TkCreateMainWindow
#define TkCreateMainWindow \
	(tkIntStubsPtr->tkCreateMainWindow) /* 14 */
#endif
#ifndef TkCurrentTime
#define TkCurrentTime \
	(tkIntStubsPtr->tkCurrentTime) /* 15 */
#endif
#ifndef TkDeleteAllImages
#define TkDeleteAllImages \
	(tkIntStubsPtr->tkDeleteAllImages) /* 16 */
#endif
#ifndef TkDoConfigureNotify
#define TkDoConfigureNotify \
	(tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
#endif
#ifndef TkDrawInsetFocusHighlight
#define TkDrawInsetFocusHighlight \
	(tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
#endif
#ifndef TkEventDeadWindow
#define TkEventDeadWindow \
	(tkIntStubsPtr->tkEventDeadWindow) /* 19 */
#endif
#ifndef TkFillPolygon
#define TkFillPolygon \
	(tkIntStubsPtr->tkFillPolygon) /* 20 */
#endif
#ifndef TkFindStateNum
#define TkFindStateNum \
	(tkIntStubsPtr->tkFindStateNum) /* 21 */
#endif
#ifndef TkFindStateString
#define TkFindStateString \
	(tkIntStubsPtr->tkFindStateString) /* 22 */
#endif
#ifndef TkFocusDeadWindow
#define TkFocusDeadWindow \
	(tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
#endif
#ifndef TkFocusFilterEvent
#define TkFocusFilterEvent \
	(tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
#endif
#ifndef TkFocusKeyEvent
#define TkFocusKeyEvent \
	(tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
#endif
#ifndef TkFontPkgInit
#define TkFontPkgInit \
	(tkIntStubsPtr->tkFontPkgInit) /* 26 */
#endif
#ifndef TkFontPkgFree
#define TkFontPkgFree \
	(tkIntStubsPtr->tkFontPkgFree) /* 27 */
#endif
#ifndef TkFreeBindingTags
#define TkFreeBindingTags \
	(tkIntStubsPtr->tkFreeBindingTags) /* 28 */
#endif
#ifndef TkpFreeCursor
#define TkpFreeCursor \
	(tkIntStubsPtr->tkpFreeCursor) /* 29 */
#endif
#ifndef TkGetBitmapData
#define TkGetBitmapData \
	(tkIntStubsPtr->tkGetBitmapData) /* 30 */
#endif
#ifndef TkGetButtPoints
#define TkGetButtPoints \
	(tkIntStubsPtr->tkGetButtPoints) /* 31 */
#endif
#ifndef TkGetCursorByName
#define TkGetCursorByName \
	(tkIntStubsPtr->tkGetCursorByName) /* 32 */
#endif
#ifndef TkGetDefaultScreenName
#define TkGetDefaultScreenName \
	(tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
#endif
#ifndef TkGetDisplay
#define TkGetDisplay \
	(tkIntStubsPtr->tkGetDisplay) /* 34 */
#endif
#ifndef TkGetDisplayOf
#define TkGetDisplayOf \
	(tkIntStubsPtr->tkGetDisplayOf) /* 35 */
#endif
#ifndef TkGetFocusWin
#define TkGetFocusWin \
	(tkIntStubsPtr->tkGetFocusWin) /* 36 */
#endif
#ifndef TkGetInterpNames
#define TkGetInterpNames \
	(tkIntStubsPtr->tkGetInterpNames) /* 37 */
#endif
#ifndef TkGetMiterPoints
#define TkGetMiterPoints \
	(tkIntStubsPtr->tkGetMiterPoints) /* 38 */
#endif
#ifndef TkGetPointerCoords
#define TkGetPointerCoords \
	(tkIntStubsPtr->tkGetPointerCoords) /* 39 */
#endif
#ifndef TkGetServerInfo
#define TkGetServerInfo \
	(tkIntStubsPtr->tkGetServerInfo) /* 40 */
#endif
#ifndef TkGrabDeadWindow
#define TkGrabDeadWindow \
	(tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
#endif
#ifndef TkGrabState
#define TkGrabState \
	(tkIntStubsPtr->tkGrabState) /* 42 */
#endif
#ifndef TkIncludePoint
#define TkIncludePoint \
	(tkIntStubsPtr->tkIncludePoint) /* 43 */
#endif
#ifndef TkInOutEvents
#define TkInOutEvents \
	(tkIntStubsPtr->tkInOutEvents) /* 44 */
#endif
#ifndef TkInstallFrameMenu
#define TkInstallFrameMenu \
	(tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
#endif
#ifndef TkKeysymToString
#define TkKeysymToString \
	(tkIntStubsPtr->tkKeysymToString) /* 46 */
#endif
#ifndef TkLineToArea
#define TkLineToArea \
	(tkIntStubsPtr->tkLineToArea) /* 47 */
#endif
#ifndef TkLineToPoint
#define TkLineToPoint \
	(tkIntStubsPtr->tkLineToPoint) /* 48 */
#endif
#ifndef TkMakeBezierCurve
#define TkMakeBezierCurve \
	(tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
#endif
#ifndef TkMakeBezierPostscript
#define TkMakeBezierPostscript \
	(tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
#endif
#ifndef TkOptionClassChanged
#define TkOptionClassChanged \
	(tkIntStubsPtr->tkOptionClassChanged) /* 51 */
#endif
#ifndef TkOptionDeadWindow
#define TkOptionDeadWindow \
	(tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
#endif
#ifndef TkOvalToArea
#define TkOvalToArea \
	(tkIntStubsPtr->tkOvalToArea) /* 53 */
#endif
#ifndef TkOvalToPoint
#define TkOvalToPoint \
	(tkIntStubsPtr->tkOvalToPoint) /* 54 */
#endif
#ifndef TkpChangeFocus
#define TkpChangeFocus \
	(tkIntStubsPtr->tkpChangeFocus) /* 55 */
#endif
#ifndef TkpCloseDisplay
#define TkpCloseDisplay \
	(tkIntStubsPtr->tkpCloseDisplay) /* 56 */
#endif
#ifndef TkpClaimFocus
#define TkpClaimFocus \
	(tkIntStubsPtr->tkpClaimFocus) /* 57 */
#endif
#ifndef TkpDisplayWarning
#define TkpDisplayWarning \
	(tkIntStubsPtr->tkpDisplayWarning) /* 58 */
#endif
#ifndef TkpGetAppName
#define TkpGetAppName \
	(tkIntStubsPtr->tkpGetAppName) /* 59 */
#endif
#ifndef TkpGetOtherWindow
#define TkpGetOtherWindow \
	(tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
#endif
#ifndef TkpGetWrapperWindow
#define TkpGetWrapperWindow \
	(tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
#endif
#ifndef TkpInit
#define TkpInit \
	(tkIntStubsPtr->tkpInit) /* 62 */
#endif
#ifndef TkpInitializeMenuBindings
#define TkpInitializeMenuBindings \
	(tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
#endif
#ifndef TkpMakeContainer
#define TkpMakeContainer \
	(tkIntStubsPtr->tkpMakeContainer) /* 64 */
#endif
#ifndef TkpMakeMenuWindow
#define TkpMakeMenuWindow \
	(tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
#endif
#ifndef TkpMakeWindow
#define TkpMakeWindow \
	(tkIntStubsPtr->tkpMakeWindow) /* 66 */
#endif
#ifndef TkpMenuNotifyToplevelCreate
#define TkpMenuNotifyToplevelCreate \
	(tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
#endif
#ifndef TkpOpenDisplay
#define TkpOpenDisplay \
	(tkIntStubsPtr->tkpOpenDisplay) /* 68 */
#endif
#ifndef TkPointerEvent
#define TkPointerEvent \
	(tkIntStubsPtr->tkPointerEvent) /* 69 */
#endif
#ifndef TkPolygonToArea
#define TkPolygonToArea \
	(tkIntStubsPtr->tkPolygonToArea) /* 70 */
#endif
#ifndef TkPolygonToPoint
#define TkPolygonToPoint \
	(tkIntStubsPtr->tkPolygonToPoint) /* 71 */
#endif
#ifndef TkPositionInTree
#define TkPositionInTree \
	(tkIntStubsPtr->tkPositionInTree) /* 72 */
#endif
#ifndef TkpRedirectKeyEvent
#define TkpRedirectKeyEvent \
	(tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
#endif
#ifndef TkpSetMainMenubar
#define TkpSetMainMenubar \
	(tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
#endif
#ifndef TkpUseWindow
#define TkpUseWindow \
	(tkIntStubsPtr->tkpUseWindow) /* 75 */
#endif
#ifndef TkpWindowWasRecentlyDeleted
#define TkpWindowWasRecentlyDeleted \
	(tkIntStubsPtr->tkpWindowWasRecentlyDeleted) /* 76 */
#endif
#ifndef TkQueueEventForAllChildren
#define TkQueueEventForAllChildren \
	(tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
#endif
#ifndef TkReadBitmapFile
#define TkReadBitmapFile \
	(tkIntStubsPtr->tkReadBitmapFile) /* 78 */
#endif
#ifndef TkScrollWindow
#define TkScrollWindow \
	(tkIntStubsPtr->tkScrollWindow) /* 79 */
#endif
#ifndef TkSelDeadWindow
#define TkSelDeadWindow \
	(tkIntStubsPtr->tkSelDeadWindow) /* 80 */
#endif
#ifndef TkSelEventProc
#define TkSelEventProc \
	(tkIntStubsPtr->tkSelEventProc) /* 81 */
#endif
#ifndef TkSelInit
#define TkSelInit \
	(tkIntStubsPtr->tkSelInit) /* 82 */
#endif
#ifndef TkSelPropProc
#define TkSelPropProc \
	(tkIntStubsPtr->tkSelPropProc) /* 83 */
#endif
/* Slot 84 is reserved */
#ifndef TkSetWindowMenuBar
#define TkSetWindowMenuBar \
	(tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
#endif
#ifndef TkStringToKeysym
#define TkStringToKeysym \
	(tkIntStubsPtr->tkStringToKeysym) /* 86 */
#endif
#ifndef TkThickPolyLineToArea
#define TkThickPolyLineToArea \
	(tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
#endif
#ifndef TkWmAddToColormapWindows
#define TkWmAddToColormapWindows \
	(tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
#endif
#ifndef TkWmDeadWindow
#define TkWmDeadWindow \
	(tkIntStubsPtr->tkWmDeadWindow) /* 89 */
#endif
#ifndef TkWmFocusToplevel
#define TkWmFocusToplevel \
	(tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
#endif
#ifndef TkWmMapWindow
#define TkWmMapWindow \
	(tkIntStubsPtr->tkWmMapWindow) /* 91 */
#endif
#ifndef TkWmNewWindow
#define TkWmNewWindow \
	(tkIntStubsPtr->tkWmNewWindow) /* 92 */
#endif
#ifndef TkWmProtocolEventProc
#define TkWmProtocolEventProc \
	(tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
#endif
#ifndef TkWmRemoveFromColormapWindows
#define TkWmRemoveFromColormapWindows \
	(tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
#endif
#ifndef TkWmRestackToplevel
#define TkWmRestackToplevel \
	(tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
#endif
#ifndef TkWmSetClass
#define TkWmSetClass \
	(tkIntStubsPtr->tkWmSetClass) /* 96 */
#endif
#ifndef TkWmUnmapWindow
#define TkWmUnmapWindow \
	(tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
#endif
#ifndef TkDebugBitmap
#define TkDebugBitmap \
	(tkIntStubsPtr->tkDebugBitmap) /* 98 */
#endif
#ifndef TkDebugBorder
#define TkDebugBorder \
	(tkIntStubsPtr->tkDebugBorder) /* 99 */
#endif
#ifndef TkDebugCursor
#define TkDebugCursor \
	(tkIntStubsPtr->tkDebugCursor) /* 100 */
#endif
#ifndef TkDebugColor
#define TkDebugColor \
	(tkIntStubsPtr->tkDebugColor) /* 101 */
#endif
#ifndef TkDebugConfig
#define TkDebugConfig \
	(tkIntStubsPtr->tkDebugConfig) /* 102 */
#endif
#ifndef TkDebugFont
#define TkDebugFont \
	(tkIntStubsPtr->tkDebugFont) /* 103 */
#endif
#ifndef TkFindStateNumObj
#define TkFindStateNumObj \
	(tkIntStubsPtr->tkFindStateNumObj) /* 104 */
#endif
#ifndef TkGetBitmapPredefTable
#define TkGetBitmapPredefTable \
	(tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
#endif
#ifndef TkGetDisplayList
#define TkGetDisplayList \
	(tkIntStubsPtr->tkGetDisplayList) /* 106 */
#endif
#ifndef TkGetMainInfoList
#define TkGetMainInfoList \
	(tkIntStubsPtr->tkGetMainInfoList) /* 107 */
#endif
#ifndef TkGetWindowFromObj
#define TkGetWindowFromObj \
	(tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
#endif
#ifndef TkpGetString
#define TkpGetString \
	(tkIntStubsPtr->tkpGetString) /* 109 */
#endif
#ifndef TkpGetSubFonts
#define TkpGetSubFonts \
	(tkIntStubsPtr->tkpGetSubFonts) /* 110 */
#endif
#ifndef TkpGetSystemDefault
#define TkpGetSystemDefault \
	(tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
#endif
#ifndef TkpMenuThreadInit
#define TkpMenuThreadInit \
	(tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
#endif
#ifdef __WIN32__
#ifndef TkClipBox
#define TkClipBox \
	(tkIntStubsPtr->tkClipBox) /* 113 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkClipBox
#define TkClipBox \
	(tkIntStubsPtr->tkClipBox) /* 113 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkClipBox
#define TkClipBox \
	(tkIntStubsPtr->tkClipBox) /* 113 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkCreateRegion
#define TkCreateRegion \
	(tkIntStubsPtr->tkCreateRegion) /* 114 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkCreateRegion
#define TkCreateRegion \
	(tkIntStubsPtr->tkCreateRegion) /* 114 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkCreateRegion
#define TkCreateRegion \
	(tkIntStubsPtr->tkCreateRegion) /* 114 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkDestroyRegion
#define TkDestroyRegion \
	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkDestroyRegion
#define TkDestroyRegion \
	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkDestroyRegion
#define TkDestroyRegion \
	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkIntersectRegion
#define TkIntersectRegion \
	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkIntersectRegion
#define TkIntersectRegion \
	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkIntersectRegion
#define TkIntersectRegion \
	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkRectInRegion
#define TkRectInRegion \
	(tkIntStubsPtr->tkRectInRegion) /* 117 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkRectInRegion
#define TkRectInRegion \
	(tkIntStubsPtr->tkRectInRegion) /* 117 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkRectInRegion
#define TkRectInRegion \
	(tkIntStubsPtr->tkRectInRegion) /* 117 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkSetRegion
#define TkSetRegion \
	(tkIntStubsPtr->tkSetRegion) /* 118 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkSetRegion
#define TkSetRegion \
	(tkIntStubsPtr->tkSetRegion) /* 118 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkSetRegion
#define TkSetRegion \
	(tkIntStubsPtr->tkSetRegion) /* 118 */
#endif
#endif /* MAC_OSX_TK */
#ifdef __WIN32__
#ifndef TkUnionRectWithRegion
#define TkUnionRectWithRegion \
	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkUnionRectWithRegion
#define TkUnionRectWithRegion \
	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkUnionRectWithRegion
#define TkUnionRectWithRegion \
	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
#endif
#endif /* MAC_OSX_TK */
/* Slot 120 is reserved */
#ifdef MAC_TCL
#ifndef TkpCreateNativeBitmap
#define TkpCreateNativeBitmap \
	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkpCreateNativeBitmap
#define TkpCreateNativeBitmap \
	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
#endif
#endif /* MAC_OSX_TK */
#ifdef MAC_TCL
#ifndef TkpDefineNativeBitmaps
#define TkpDefineNativeBitmaps \
	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkpDefineNativeBitmaps
#define TkpDefineNativeBitmaps \
	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
#endif
#endif /* MAC_OSX_TK */
/* Slot 123 is reserved */
#ifdef MAC_TCL
#ifndef TkpGetNativeAppBitmap
#define TkpGetNativeAppBitmap \
	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkpGetNativeAppBitmap
#define TkpGetNativeAppBitmap \
	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
#endif
#endif /* MAC_OSX_TK */
/* Slot 125 is reserved */
/* Slot 126 is reserved */
/* Slot 127 is reserved */
/* Slot 128 is reserved */
/* Slot 129 is reserved */
/* Slot 130 is reserved */
/* Slot 131 is reserved */
/* Slot 132 is reserved */
/* Slot 133 is reserved */
/* Slot 134 is reserved */
#ifndef TkpDrawHighlightBorder
#define TkpDrawHighlightBorder \
	(tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
#endif
#ifndef TkSetFocusWin
#define TkSetFocusWin \
	(tkIntStubsPtr->tkSetFocusWin) /* 136 */
#endif
#ifndef TkpSetKeycodeAndState
#define TkpSetKeycodeAndState \
	(tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
#endif
#ifndef TkpGetKeySym
#define TkpGetKeySym \
	(tkIntStubsPtr->tkpGetKeySym) /* 138 */
#endif
#ifndef TkpInitKeymapInfo
#define TkpInitKeymapInfo \
	(tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
#endif
#ifndef TkPhotoGetValidRegion
#define TkPhotoGetValidRegion \
	(tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
#endif
#ifndef TkWmStackorderToplevel
#define TkWmStackorderToplevel \
	(tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
#endif
#ifndef TkFocusFree
#define TkFocusFree \
	(tkIntStubsPtr->tkFocusFree) /* 142 */
#endif
#ifndef TkClipCleanup
#define TkClipCleanup \
	(tkIntStubsPtr->tkClipCleanup) /* 143 */
#endif
#ifndef TkGCCleanup
#define TkGCCleanup \
	(tkIntStubsPtr->tkGCCleanup) /* 144 */
#endif
#ifdef __WIN32__
#ifndef TkSubtractRegion
#define TkSubtractRegion \
	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkSubtractRegion
#define TkSubtractRegion \
	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkSubtractRegion
#define TkSubtractRegion \
	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
#endif
#endif /* MAC_OSX_TK */
#ifndef TkStylePkgInit
#define TkStylePkgInit \
	(tkIntStubsPtr->tkStylePkgInit) /* 146 */
#endif
#ifndef TkStylePkgFree
#define TkStylePkgFree \
	(tkIntStubsPtr->tkStylePkgFree) /* 147 */
#endif
#ifndef TkToplevelWindowForCommand
#define TkToplevelWindowForCommand \
	(tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
#endif
#ifndef TkGetOptionSpec
#define TkGetOptionSpec \
	(tkIntStubsPtr->tkGetOptionSpec) /* 149 */
#endif
/* Slot 150 is reserved */
/* Slot 151 is reserved */
#ifndef TkpDrawFrame
#define TkpDrawFrame \
	(tkIntStubsPtr->tkpDrawFrame) /* 152 */
#endif

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTDECLS */

                                                                                                                                                                                                                                                                                                                                                                                tkIntPlatDecls.h                                                                                    0100644 0001750 0001750 00000124745 11001664475 035470  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk-private                                                             /*
 * tkIntPlatDecls.h --
 *
 *	This file contains the declarations for all platform dependent
 *	unsupported functions that are exported by the Tk library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @(#) $Id: tkIntPlatDecls.h,v 1.15.2.4 2005/11/27 02:44:25 das Exp $
 */

#ifndef _TKINTPLATDECLS
#define _TKINTPLATDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tkInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__
/* 0 */
EXTERN char *		TkAlignImageData _ANSI_ARGS_((XImage * image, 
				int alignment, int bitOrder));
/* Slot 1 is reserved */
/* 2 */
EXTERN void		TkGenerateActivateEvents _ANSI_ARGS_((
				TkWindow * winPtr, int active));
/* 3 */
EXTERN unsigned long	TkpGetMS _ANSI_ARGS_((void));
/* 4 */
EXTERN void		TkPointerDeadWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 5 */
EXTERN void		TkpPrintWindowId _ANSI_ARGS_((char * buf, 
				Window window));
/* 6 */
EXTERN int		TkpScanWindowId _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, Window * idPtr));
/* 7 */
EXTERN void		TkpSetCapture _ANSI_ARGS_((TkWindow * winPtr));
/* 8 */
EXTERN void		TkpSetCursor _ANSI_ARGS_((TkpCursor cursor));
/* 9 */
EXTERN void		TkpWmSetState _ANSI_ARGS_((TkWindow * winPtr, 
				int state));
/* 10 */
EXTERN void		TkSetPixmapColormap _ANSI_ARGS_((Pixmap pixmap, 
				Colormap colormap));
/* 11 */
EXTERN void		TkWinCancelMouseTimer _ANSI_ARGS_((void));
/* 12 */
EXTERN void		TkWinClipboardRender _ANSI_ARGS_((
				TkDisplay * dispPtr, UINT format));
/* 13 */
EXTERN LRESULT		TkWinEmbeddedEventProc _ANSI_ARGS_((HWND hwnd, 
				UINT message, WPARAM wParam, LPARAM lParam));
/* 14 */
EXTERN void		TkWinFillRect _ANSI_ARGS_((HDC dc, int x, int y, 
				int width, int height, int pixel));
/* 15 */
EXTERN COLORREF		TkWinGetBorderPixels _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_3DBorder border, int which));
/* 16 */
EXTERN HDC		TkWinGetDrawableDC _ANSI_ARGS_((Display * display, 
				Drawable d, TkWinDCState* state));
/* 17 */
EXTERN int		TkWinGetModifierState _ANSI_ARGS_((void));
/* 18 */
EXTERN HPALETTE		TkWinGetSystemPalette _ANSI_ARGS_((void));
/* 19 */
EXTERN HWND		TkWinGetWrapperWindow _ANSI_ARGS_((Tk_Window tkwin));
/* 20 */
EXTERN int		TkWinHandleMenuEvent _ANSI_ARGS_((HWND * phwnd, 
				UINT * pMessage, WPARAM * pwParam, 
				LPARAM * plParam, LRESULT * plResult));
/* 21 */
EXTERN int		TkWinIndexOfColor _ANSI_ARGS_((XColor * colorPtr));
/* 22 */
EXTERN void		TkWinReleaseDrawableDC _ANSI_ARGS_((Drawable d, 
				HDC hdc, TkWinDCState* state));
/* 23 */
EXTERN LRESULT		TkWinResendEvent _ANSI_ARGS_((WNDPROC wndproc, 
				HWND hwnd, XEvent * eventPtr));
/* 24 */
EXTERN HPALETTE		TkWinSelectPalette _ANSI_ARGS_((HDC dc, 
				Colormap colormap));
/* 25 */
EXTERN void		TkWinSetMenu _ANSI_ARGS_((Tk_Window tkwin, 
				HMENU hMenu));
/* 26 */
EXTERN void		TkWinSetWindowPos _ANSI_ARGS_((HWND hwnd, 
				HWND siblingHwnd, int pos));
/* 27 */
EXTERN void		TkWinWmCleanup _ANSI_ARGS_((HINSTANCE hInstance));
/* 28 */
EXTERN void		TkWinXCleanup _ANSI_ARGS_((ClientData clientData));
/* 29 */
EXTERN void		TkWinXInit _ANSI_ARGS_((HINSTANCE hInstance));
/* 30 */
EXTERN void		TkWinSetForegroundWindow _ANSI_ARGS_((
				TkWindow * winPtr));
/* 31 */
EXTERN void		TkWinDialogDebug _ANSI_ARGS_((int debug));
/* 32 */
EXTERN Tcl_Obj *	TkWinGetMenuSystemDefault _ANSI_ARGS_((
				Tk_Window tkwin, CONST char * dbName, 
				CONST char * className));
/* 33 */
EXTERN int		TkWinGetPlatformId _ANSI_ARGS_((void));
/* 34 */
EXTERN void		TkWinSetHINSTANCE _ANSI_ARGS_((HINSTANCE hInstance));
/* 35 */
EXTERN int		TkWinGetPlatformTheme _ANSI_ARGS_((void));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 0 */
EXTERN void		TkGenerateActivateEvents _ANSI_ARGS_((
				TkWindow * winPtr, int active));
/* Slot 1 is reserved */
/* Slot 2 is reserved */
/* 3 */
EXTERN unsigned long	TkpGetMS _ANSI_ARGS_((void));
/* Slot 4 is reserved */
/* 5 */
EXTERN void		TkPointerDeadWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 6 */
EXTERN void		TkpSetCapture _ANSI_ARGS_((TkWindow * winPtr));
/* 7 */
EXTERN void		TkpSetCursor _ANSI_ARGS_((TkpCursor cursor));
/* 8 */
EXTERN void		TkpWmSetState _ANSI_ARGS_((TkWindow * winPtr, 
				int state));
/* Slot 9 is reserved */
/* 10 */
EXTERN void		TkAboutDlg _ANSI_ARGS_((void));
/* Slot 11 is reserved */
/* Slot 12 is reserved */
/* 13 */
EXTERN Window		TkGetTransientMaster _ANSI_ARGS_((TkWindow * winPtr));
/* 14 */
EXTERN int		TkGenerateButtonEvent _ANSI_ARGS_((int x, int y, 
				Window window, unsigned int state));
/* Slot 15 is reserved */
/* 16 */
EXTERN void		TkGenWMDestroyEvent _ANSI_ARGS_((Tk_Window tkwin));
/* Slot 17 is reserved */
/* 18 */
EXTERN unsigned int	TkMacButtonKeyState _ANSI_ARGS_((void));
/* 19 */
EXTERN void		TkMacClearMenubarActive _ANSI_ARGS_((void));
/* Slot 20 is reserved */
/* 21 */
EXTERN int		TkMacDispatchMenuEvent _ANSI_ARGS_((int menuID, 
				int index));
/* 22 */
EXTERN void		TkMacInstallCursor _ANSI_ARGS_((int resizeOverride));
/* Slot 23 is reserved */
/* 24 */
EXTERN void		TkMacHandleTearoffMenu _ANSI_ARGS_((void));
/* Slot 25 is reserved */
/* Slot 26 is reserved */
/* 27 */
EXTERN void		TkMacDoHLEvent _ANSI_ARGS_((EventRecord * theEvent));
/* Slot 28 is reserved */
/* 29 */
EXTERN Time		TkMacGenerateTime _ANSI_ARGS_((void));
/* Slot 30 is reserved */
/* 31 */
EXTERN TkWindow *	TkMacGetScrollbarGrowWindow _ANSI_ARGS_((
				TkWindow * winPtr));
/* 32 */
EXTERN Window		TkMacGetXWindow _ANSI_ARGS_((WindowRef macWinPtr));
/* 33 */
EXTERN int		TkMacGrowToplevel _ANSI_ARGS_((WindowRef whichWindow, 
				Point start));
/* 34 */
EXTERN void		TkMacHandleMenuSelect _ANSI_ARGS_((long mResult, 
				int optionKeyPressed));
/* Slot 35 is reserved */
/* Slot 36 is reserved */
/* Slot 37 is reserved */
/* 38 */
EXTERN void		TkMacInvalidateWindow _ANSI_ARGS_((
				MacDrawable * macWin, int flag));
/* 39 */
EXTERN int		TkMacIsCharacterMissing _ANSI_ARGS_((Tk_Font tkfont, 
				unsigned int searchChar));
/* 40 */
EXTERN void		TkMacMakeRealWindowExist _ANSI_ARGS_((
				TkWindow * winPtr));
/* 41 */
EXTERN BitMapPtr	TkMacMakeStippleMap _ANSI_ARGS_((Drawable d1, 
				Drawable d2));
/* 42 */
EXTERN void		TkMacMenuClick _ANSI_ARGS_((void));
/* 43 */
EXTERN void		TkMacRegisterOffScreenWindow _ANSI_ARGS_((
				Window window, GWorldPtr portPtr));
/* 44 */
EXTERN int		TkMacResizable _ANSI_ARGS_((TkWindow * winPtr));
/* Slot 45 is reserved */
/* 46 */
EXTERN void		TkMacSetHelpMenuItemCount _ANSI_ARGS_((void));
/* 47 */
EXTERN void		TkMacSetScrollbarGrow _ANSI_ARGS_((TkWindow * winPtr, 
				int flag));
/* 48 */
EXTERN void		TkMacSetUpClippingRgn _ANSI_ARGS_((Drawable drawable));
/* 49 */
EXTERN void		TkMacSetUpGraphicsPort _ANSI_ARGS_((GC gc));
/* 50 */
EXTERN void		TkMacUpdateClipRgn _ANSI_ARGS_((TkWindow * winPtr));
/* 51 */
EXTERN void		TkMacUnregisterMacWindow _ANSI_ARGS_((
				GWorldPtr portPtr));
/* 52 */
EXTERN int		TkMacUseMenuID _ANSI_ARGS_((short macID));
/* 53 */
EXTERN RgnHandle	TkMacVisableClipRgn _ANSI_ARGS_((TkWindow * winPtr));
/* 54 */
EXTERN void		TkMacWinBounds _ANSI_ARGS_((TkWindow * winPtr, 
				Rect * geometry));
/* 55 */
EXTERN void		TkMacWindowOffset _ANSI_ARGS_((WindowRef wRef, 
				int * xOffset, int * yOffset));
/* Slot 56 is reserved */
/* 57 */
EXTERN int		TkSetMacColor _ANSI_ARGS_((unsigned long pixel, 
				RGBColor * macColor));
/* 58 */
EXTERN void		TkSetWMName _ANSI_ARGS_((TkWindow * winPtr, 
				Tk_Uid titleUid));
/* 59 */
EXTERN void		TkSuspendClipboard _ANSI_ARGS_((void));
/* Slot 60 is reserved */
/* 61 */
EXTERN int		TkMacZoomToplevel _ANSI_ARGS_((WindowPtr whichWindow, 
				Point where, short zoomPart));
/* 62 */
EXTERN Tk_Window	Tk_TopCoordsToWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int rootX, int rootY, int * newX, int * newY));
/* 63 */
EXTERN MacDrawable *	TkMacContainerId _ANSI_ARGS_((TkWindow * winPtr));
/* 64 */
EXTERN MacDrawable *	TkMacGetHostToplevel _ANSI_ARGS_((TkWindow * winPtr));
/* 65 */
EXTERN void		TkMacPreprocessMenu _ANSI_ARGS_((void));
/* 66 */
EXTERN int		TkpIsWindowFloating _ANSI_ARGS_((WindowRef window));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 0 */
EXTERN void		TkGenerateActivateEvents _ANSI_ARGS_((
				TkWindow * winPtr, int active));
/* Slot 1 is reserved */
/* Slot 2 is reserved */
/* 3 */
EXTERN void		TkPointerDeadWindow _ANSI_ARGS_((TkWindow * winPtr));
/* 4 */
EXTERN void		TkpSetCapture _ANSI_ARGS_((TkWindow * winPtr));
/* 5 */
EXTERN void		TkpSetCursor _ANSI_ARGS_((TkpCursor cursor));
/* 6 */
EXTERN void		TkpWmSetState _ANSI_ARGS_((TkWindow * winPtr, 
				int state));
/* 7 */
EXTERN void		TkAboutDlg _ANSI_ARGS_((void));
/* 8 */
EXTERN unsigned int	TkMacOSXButtonKeyState _ANSI_ARGS_((void));
/* 9 */
EXTERN void		TkMacOSXClearMenubarActive _ANSI_ARGS_((void));
/* 10 */
EXTERN int		TkMacOSXDispatchMenuEvent _ANSI_ARGS_((int menuID, 
				int index));
/* 11 */
EXTERN void		TkMacOSXInstallCursor _ANSI_ARGS_((
				int resizeOverride));
/* 12 */
EXTERN void		TkMacOSXHandleTearoffMenu _ANSI_ARGS_((void));
/* Slot 13 is reserved */
/* 14 */
EXTERN int		TkMacOSXDoHLEvent _ANSI_ARGS_((
				EventRecord * theEvent));
/* Slot 15 is reserved */
/* 16 */
EXTERN Window		TkMacOSXGetXWindow _ANSI_ARGS_((WindowRef macWinPtr));
/* 17 */
EXTERN int		TkMacOSXGrowToplevel _ANSI_ARGS_((
				WindowRef whichWindow, Point start));
/* 18 */
EXTERN void		TkMacOSXHandleMenuSelect _ANSI_ARGS_((MenuID theMenu, 
				MenuItemIndex theItem, int optionKeyPressed));
/* Slot 19 is reserved */
/* Slot 20 is reserved */
/* 21 */
EXTERN void		TkMacOSXInvalidateWindow _ANSI_ARGS_((
				MacDrawable * macWin, int flag));
/* 22 */
EXTERN int		TkMacOSXIsCharacterMissing _ANSI_ARGS_((
				Tk_Font tkfont, unsigned int searchChar));
/* 23 */
EXTERN void		TkMacOSXMakeRealWindowExist _ANSI_ARGS_((
				TkWindow * winPtr));
/* 24 */
EXTERN BitMapPtr	TkMacOSXMakeStippleMap _ANSI_ARGS_((Drawable d1, 
				Drawable d2));
/* 25 */
EXTERN void		TkMacOSXMenuClick _ANSI_ARGS_((void));
/* 26 */
EXTERN void		TkMacOSXRegisterOffScreenWindow _ANSI_ARGS_((
				Window window, GWorldPtr portPtr));
/* 27 */
EXTERN int		TkMacOSXResizable _ANSI_ARGS_((TkWindow * winPtr));
/* 28 */
EXTERN void		TkMacOSXSetHelpMenuItemCount _ANSI_ARGS_((void));
/* 29 */
EXTERN void		TkMacOSXSetScrollbarGrow _ANSI_ARGS_((
				TkWindow * winPtr, int flag));
/* 30 */
EXTERN void		TkMacOSXSetUpClippingRgn _ANSI_ARGS_((
				Drawable drawable));
/* 31 */
EXTERN void		TkMacOSXSetUpGraphicsPort _ANSI_ARGS_((GC gc, 
				GWorldPtr destPort));
/* 32 */
EXTERN void		TkMacOSXUpdateClipRgn _ANSI_ARGS_((TkWindow * winPtr));
/* 33 */
EXTERN void		TkMacOSXUnregisterMacWindow _ANSI_ARGS_((
				WindowRef portPtr));
/* 34 */
EXTERN int		TkMacOSXUseMenuID _ANSI_ARGS_((short macID));
/* 35 */
EXTERN RgnHandle	TkMacOSXVisableClipRgn _ANSI_ARGS_((
				TkWindow * winPtr));
/* 36 */
EXTERN void		TkMacOSXWinBounds _ANSI_ARGS_((TkWindow * winPtr, 
				Rect * geometry));
/* 37 */
EXTERN void		TkMacOSXWindowOffset _ANSI_ARGS_((WindowRef wRef, 
				int * xOffset, int * yOffset));
/* 38 */
EXTERN int		TkSetMacColor _ANSI_ARGS_((unsigned long pixel, 
				RGBColor * macColor));
/* 39 */
EXTERN void		TkSetWMName _ANSI_ARGS_((TkWindow * winPtr, 
				Tk_Uid titleUid));
/* 40 */
EXTERN void		TkSuspendClipboard _ANSI_ARGS_((void));
/* 41 */
EXTERN int		TkMacOSXZoomToplevel _ANSI_ARGS_((
				WindowPtr whichWindow, short zoomPart));
/* 42 */
EXTERN Tk_Window	Tk_TopCoordsToWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int rootX, int rootY, int * newX, int * newY));
/* 43 */
EXTERN MacDrawable *	TkMacOSXContainerId _ANSI_ARGS_((TkWindow * winPtr));
/* 44 */
EXTERN MacDrawable *	TkMacOSXGetHostToplevel _ANSI_ARGS_((
				TkWindow * winPtr));
/* 45 */
EXTERN void		TkMacOSXPreprocessMenu _ANSI_ARGS_((void));
/* 46 */
EXTERN int		TkpIsWindowFloating _ANSI_ARGS_((WindowRef window));
/* 47 */
EXTERN Tk_Window	TkMacOSXGetCapture _ANSI_ARGS_((void));
/* Slot 48 is reserved */
/* 49 */
EXTERN Window		TkGetTransientMaster _ANSI_ARGS_((TkWindow * winPtr));
/* 50 */
EXTERN int		TkGenerateButtonEvent _ANSI_ARGS_((int x, int y, 
				Window window, unsigned int state));
/* 51 */
EXTERN void		TkGenWMDestroyEvent _ANSI_ARGS_((Tk_Window tkwin));
/* Slot 52 is reserved */
/* 53 */
EXTERN unsigned long	TkpGetMS _ANSI_ARGS_((void));
#endif /* MAC_OSX_TK */
#if !(defined(__WIN32__) || defined(MAC_TCL) || defined(MAC_OSX_TK)) /* X11 */
/* 0 */
EXTERN void		TkCreateXEventSource _ANSI_ARGS_((void));
/* 1 */
EXTERN void		TkFreeWindowId _ANSI_ARGS_((TkDisplay * dispPtr, 
				Window w));
/* 2 */
EXTERN void		TkInitXId _ANSI_ARGS_((TkDisplay * dispPtr));
/* 3 */
EXTERN int		TkpCmapStressed _ANSI_ARGS_((Tk_Window tkwin, 
				Colormap colormap));
/* 4 */
EXTERN void		TkpSync _ANSI_ARGS_((Display * display));
/* 5 */
EXTERN Window		TkUnixContainerId _ANSI_ARGS_((TkWindow * winPtr));
/* 6 */
EXTERN int		TkUnixDoOneXEvent _ANSI_ARGS_((Tcl_Time * timePtr));
/* 7 */
EXTERN void		TkUnixSetMenubar _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_Window menubar));
/* 8 */
EXTERN int		TkpScanWindowId _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * string, Window * idPtr));
/* 9 */
EXTERN void		TkWmCleanup _ANSI_ARGS_((TkDisplay * dispPtr));
/* 10 */
EXTERN void		TkSendCleanup _ANSI_ARGS_((TkDisplay * dispPtr));
/* 11 */
EXTERN void		TkFreeXId _ANSI_ARGS_((TkDisplay * dispPtr));
/* 12 */
EXTERN int		TkpWmSetState _ANSI_ARGS_((TkWindow * winPtr, 
				int state));
#endif /* X11 */

typedef struct TkIntPlatStubs {
    int magic;
    struct TkIntPlatStubHooks *hooks;

#ifdef __WIN32__
    char * (*tkAlignImageData) _ANSI_ARGS_((XImage * image, int alignment, int bitOrder)); /* 0 */
    void *reserved1;
    void (*tkGenerateActivateEvents) _ANSI_ARGS_((TkWindow * winPtr, int active)); /* 2 */
    unsigned long (*tkpGetMS) _ANSI_ARGS_((void)); /* 3 */
    void (*tkPointerDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 4 */
    void (*tkpPrintWindowId) _ANSI_ARGS_((char * buf, Window window)); /* 5 */
    int (*tkpScanWindowId) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, Window * idPtr)); /* 6 */
    void (*tkpSetCapture) _ANSI_ARGS_((TkWindow * winPtr)); /* 7 */
    void (*tkpSetCursor) _ANSI_ARGS_((TkpCursor cursor)); /* 8 */
    void (*tkpWmSetState) _ANSI_ARGS_((TkWindow * winPtr, int state)); /* 9 */
    void (*tkSetPixmapColormap) _ANSI_ARGS_((Pixmap pixmap, Colormap colormap)); /* 10 */
    void (*tkWinCancelMouseTimer) _ANSI_ARGS_((void)); /* 11 */
    void (*tkWinClipboardRender) _ANSI_ARGS_((TkDisplay * dispPtr, UINT format)); /* 12 */
    LRESULT (*tkWinEmbeddedEventProc) _ANSI_ARGS_((HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)); /* 13 */
    void (*tkWinFillRect) _ANSI_ARGS_((HDC dc, int x, int y, int width, int height, int pixel)); /* 14 */
    COLORREF (*tkWinGetBorderPixels) _ANSI_ARGS_((Tk_Window tkwin, Tk_3DBorder border, int which)); /* 15 */
    HDC (*tkWinGetDrawableDC) _ANSI_ARGS_((Display * display, Drawable d, TkWinDCState* state)); /* 16 */
    int (*tkWinGetModifierState) _ANSI_ARGS_((void)); /* 17 */
    HPALETTE (*tkWinGetSystemPalette) _ANSI_ARGS_((void)); /* 18 */
    HWND (*tkWinGetWrapperWindow) _ANSI_ARGS_((Tk_Window tkwin)); /* 19 */
    int (*tkWinHandleMenuEvent) _ANSI_ARGS_((HWND * phwnd, UINT * pMessage, WPARAM * pwParam, LPARAM * plParam, LRESULT * plResult)); /* 20 */
    int (*tkWinIndexOfColor) _ANSI_ARGS_((XColor * colorPtr)); /* 21 */
    void (*tkWinReleaseDrawableDC) _ANSI_ARGS_((Drawable d, HDC hdc, TkWinDCState* state)); /* 22 */
    LRESULT (*tkWinResendEvent) _ANSI_ARGS_((WNDPROC wndproc, HWND hwnd, XEvent * eventPtr)); /* 23 */
    HPALETTE (*tkWinSelectPalette) _ANSI_ARGS_((HDC dc, Colormap colormap)); /* 24 */
    void (*tkWinSetMenu) _ANSI_ARGS_((Tk_Window tkwin, HMENU hMenu)); /* 25 */
    void (*tkWinSetWindowPos) _ANSI_ARGS_((HWND hwnd, HWND siblingHwnd, int pos)); /* 26 */
    void (*tkWinWmCleanup) _ANSI_ARGS_((HINSTANCE hInstance)); /* 27 */
    void (*tkWinXCleanup) _ANSI_ARGS_((ClientData clientData)); /* 28 */
    void (*tkWinXInit) _ANSI_ARGS_((HINSTANCE hInstance)); /* 29 */
    void (*tkWinSetForegroundWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 30 */
    void (*tkWinDialogDebug) _ANSI_ARGS_((int debug)); /* 31 */
    Tcl_Obj * (*tkWinGetMenuSystemDefault) _ANSI_ARGS_((Tk_Window tkwin, CONST char * dbName, CONST char * className)); /* 32 */
    int (*tkWinGetPlatformId) _ANSI_ARGS_((void)); /* 33 */
    void (*tkWinSetHINSTANCE) _ANSI_ARGS_((HINSTANCE hInstance)); /* 34 */
    int (*tkWinGetPlatformTheme) _ANSI_ARGS_((void)); /* 35 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tkGenerateActivateEvents) _ANSI_ARGS_((TkWindow * winPtr, int active)); /* 0 */
    void *reserved1;
    void *reserved2;
    unsigned long (*tkpGetMS) _ANSI_ARGS_((void)); /* 3 */
    void *reserved4;
    void (*tkPointerDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 5 */
    void (*tkpSetCapture) _ANSI_ARGS_((TkWindow * winPtr)); /* 6 */
    void (*tkpSetCursor) _ANSI_ARGS_((TkpCursor cursor)); /* 7 */
    void (*tkpWmSetState) _ANSI_ARGS_((TkWindow * winPtr, int state)); /* 8 */
    void *reserved9;
    void (*tkAboutDlg) _ANSI_ARGS_((void)); /* 10 */
    void *reserved11;
    void *reserved12;
    Window (*tkGetTransientMaster) _ANSI_ARGS_((TkWindow * winPtr)); /* 13 */
    int (*tkGenerateButtonEvent) _ANSI_ARGS_((int x, int y, Window window, unsigned int state)); /* 14 */
    void *reserved15;
    void (*tkGenWMDestroyEvent) _ANSI_ARGS_((Tk_Window tkwin)); /* 16 */
    void *reserved17;
    unsigned int (*tkMacButtonKeyState) _ANSI_ARGS_((void)); /* 18 */
    void (*tkMacClearMenubarActive) _ANSI_ARGS_((void)); /* 19 */
    void *reserved20;
    int (*tkMacDispatchMenuEvent) _ANSI_ARGS_((int menuID, int index)); /* 21 */
    void (*tkMacInstallCursor) _ANSI_ARGS_((int resizeOverride)); /* 22 */
    void *reserved23;
    void (*tkMacHandleTearoffMenu) _ANSI_ARGS_((void)); /* 24 */
    void *reserved25;
    void *reserved26;
    void (*tkMacDoHLEvent) _ANSI_ARGS_((EventRecord * theEvent)); /* 27 */
    void *reserved28;
    Time (*tkMacGenerateTime) _ANSI_ARGS_((void)); /* 29 */
    void *reserved30;
    TkWindow * (*tkMacGetScrollbarGrowWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 31 */
    Window (*tkMacGetXWindow) _ANSI_ARGS_((WindowRef macWinPtr)); /* 32 */
    int (*tkMacGrowToplevel) _ANSI_ARGS_((WindowRef whichWindow, Point start)); /* 33 */
    void (*tkMacHandleMenuSelect) _ANSI_ARGS_((long mResult, int optionKeyPressed)); /* 34 */
    void *reserved35;
    void *reserved36;
    void *reserved37;
    void (*tkMacInvalidateWindow) _ANSI_ARGS_((MacDrawable * macWin, int flag)); /* 38 */
    int (*tkMacIsCharacterMissing) _ANSI_ARGS_((Tk_Font tkfont, unsigned int searchChar)); /* 39 */
    void (*tkMacMakeRealWindowExist) _ANSI_ARGS_((TkWindow * winPtr)); /* 40 */
    BitMapPtr (*tkMacMakeStippleMap) _ANSI_ARGS_((Drawable d1, Drawable d2)); /* 41 */
    void (*tkMacMenuClick) _ANSI_ARGS_((void)); /* 42 */
    void (*tkMacRegisterOffScreenWindow) _ANSI_ARGS_((Window window, GWorldPtr portPtr)); /* 43 */
    int (*tkMacResizable) _ANSI_ARGS_((TkWindow * winPtr)); /* 44 */
    void *reserved45;
    void (*tkMacSetHelpMenuItemCount) _ANSI_ARGS_((void)); /* 46 */
    void (*tkMacSetScrollbarGrow) _ANSI_ARGS_((TkWindow * winPtr, int flag)); /* 47 */
    void (*tkMacSetUpClippingRgn) _ANSI_ARGS_((Drawable drawable)); /* 48 */
    void (*tkMacSetUpGraphicsPort) _ANSI_ARGS_((GC gc)); /* 49 */
    void (*tkMacUpdateClipRgn) _ANSI_ARGS_((TkWindow * winPtr)); /* 50 */
    void (*tkMacUnregisterMacWindow) _ANSI_ARGS_((GWorldPtr portPtr)); /* 51 */
    int (*tkMacUseMenuID) _ANSI_ARGS_((short macID)); /* 52 */
    RgnHandle (*tkMacVisableClipRgn) _ANSI_ARGS_((TkWindow * winPtr)); /* 53 */
    void (*tkMacWinBounds) _ANSI_ARGS_((TkWindow * winPtr, Rect * geometry)); /* 54 */
    void (*tkMacWindowOffset) _ANSI_ARGS_((WindowRef wRef, int * xOffset, int * yOffset)); /* 55 */
    void *reserved56;
    int (*tkSetMacColor) _ANSI_ARGS_((unsigned long pixel, RGBColor * macColor)); /* 57 */
    void (*tkSetWMName) _ANSI_ARGS_((TkWindow * winPtr, Tk_Uid titleUid)); /* 58 */
    void (*tkSuspendClipboard) _ANSI_ARGS_((void)); /* 59 */
    void *reserved60;
    int (*tkMacZoomToplevel) _ANSI_ARGS_((WindowPtr whichWindow, Point where, short zoomPart)); /* 61 */
    Tk_Window (*tk_TopCoordsToWindow) _ANSI_ARGS_((Tk_Window tkwin, int rootX, int rootY, int * newX, int * newY)); /* 62 */
    MacDrawable * (*tkMacContainerId) _ANSI_ARGS_((TkWindow * winPtr)); /* 63 */
    MacDrawable * (*tkMacGetHostToplevel) _ANSI_ARGS_((TkWindow * winPtr)); /* 64 */
    void (*tkMacPreprocessMenu) _ANSI_ARGS_((void)); /* 65 */
    int (*tkpIsWindowFloating) _ANSI_ARGS_((WindowRef window)); /* 66 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tkGenerateActivateEvents) _ANSI_ARGS_((TkWindow * winPtr, int active)); /* 0 */
    void *reserved1;
    void *reserved2;
    void (*tkPointerDeadWindow) _ANSI_ARGS_((TkWindow * winPtr)); /* 3 */
    void (*tkpSetCapture) _ANSI_ARGS_((TkWindow * winPtr)); /* 4 */
    void (*tkpSetCursor) _ANSI_ARGS_((TkpCursor cursor)); /* 5 */
    void (*tkpWmSetState) _ANSI_ARGS_((TkWindow * winPtr, int state)); /* 6 */
    void (*tkAboutDlg) _ANSI_ARGS_((void)); /* 7 */
    unsigned int (*tkMacOSXButtonKeyState) _ANSI_ARGS_((void)); /* 8 */
    void (*tkMacOSXClearMenubarActive) _ANSI_ARGS_((void)); /* 9 */
    int (*tkMacOSXDispatchMenuEvent) _ANSI_ARGS_((int menuID, int index)); /* 10 */
    void (*tkMacOSXInstallCursor) _ANSI_ARGS_((int resizeOverride)); /* 11 */
    void (*tkMacOSXHandleTearoffMenu) _ANSI_ARGS_((void)); /* 12 */
    void *reserved13;
    int (*tkMacOSXDoHLEvent) _ANSI_ARGS_((EventRecord * theEvent)); /* 14 */
    void *reserved15;
    Window (*tkMacOSXGetXWindow) _ANSI_ARGS_((WindowRef macWinPtr)); /* 16 */
    int (*tkMacOSXGrowToplevel) _ANSI_ARGS_((WindowRef whichWindow, Point start)); /* 17 */
    void (*tkMacOSXHandleMenuSelect) _ANSI_ARGS_((MenuID theMenu, MenuItemIndex theItem, int optionKeyPressed)); /* 18 */
    void *reserved19;
    void *reserved20;
    void (*tkMacOSXInvalidateWindow) _ANSI_ARGS_((MacDrawable * macWin, int flag)); /* 21 */
    int (*tkMacOSXIsCharacterMissing) _ANSI_ARGS_((Tk_Font tkfont, unsigned int searchChar)); /* 22 */
    void (*tkMacOSXMakeRealWindowExist) _ANSI_ARGS_((TkWindow * winPtr)); /* 23 */
    BitMapPtr (*tkMacOSXMakeStippleMap) _ANSI_ARGS_((Drawable d1, Drawable d2)); /* 24 */
    void (*tkMacOSXMenuClick) _ANSI_ARGS_((void)); /* 25 */
    void (*tkMacOSXRegisterOffScreenWindow) _ANSI_ARGS_((Window window, GWorldPtr portPtr)); /* 26 */
    int (*tkMacOSXResizable) _ANSI_ARGS_((TkWindow * winPtr)); /* 27 */
    void (*tkMacOSXSetHelpMenuItemCount) _ANSI_ARGS_((void)); /* 28 */
    void (*tkMacOSXSetScrollbarGrow) _ANSI_ARGS_((TkWindow * winPtr, int flag)); /* 29 */
    void (*tkMacOSXSetUpClippingRgn) _ANSI_ARGS_((Drawable drawable)); /* 30 */
    void (*tkMacOSXSetUpGraphicsPort) _ANSI_ARGS_((GC gc, GWorldPtr destPort)); /* 31 */
    void (*tkMacOSXUpdateClipRgn) _ANSI_ARGS_((TkWindow * winPtr)); /* 32 */
    void (*tkMacOSXUnregisterMacWindow) _ANSI_ARGS_((WindowRef portPtr)); /* 33 */
    int (*tkMacOSXUseMenuID) _ANSI_ARGS_((short macID)); /* 34 */
    RgnHandle (*tkMacOSXVisableClipRgn) _ANSI_ARGS_((TkWindow * winPtr)); /* 35 */
    void (*tkMacOSXWinBounds) _ANSI_ARGS_((TkWindow * winPtr, Rect * geometry)); /* 36 */
    void (*tkMacOSXWindowOffset) _ANSI_ARGS_((WindowRef wRef, int * xOffset, int * yOffset)); /* 37 */
    int (*tkSetMacColor) _ANSI_ARGS_((unsigned long pixel, RGBColor * macColor)); /* 38 */
    void (*tkSetWMName) _ANSI_ARGS_((TkWindow * winPtr, Tk_Uid titleUid)); /* 39 */
    void (*tkSuspendClipboard) _ANSI_ARGS_((void)); /* 40 */
    int (*tkMacOSXZoomToplevel) _ANSI_ARGS_((WindowPtr whichWindow, short zoomPart)); /* 41 */
    Tk_Window (*tk_TopCoordsToWindow) _ANSI_ARGS_((Tk_Window tkwin, int rootX, int rootY, int * newX, int * newY)); /* 42 */
    MacDrawable * (*tkMacOSXContainerId) _ANSI_ARGS_((TkWindow * winPtr)); /* 43 */
    MacDrawable * (*tkMacOSXGetHostToplevel) _ANSI_ARGS_((TkWindow * winPtr)); /* 44 */
    void (*tkMacOSXPreprocessMenu) _ANSI_ARGS_((void)); /* 45 */
    int (*tkpIsWindowFloating) _ANSI_ARGS_((WindowRef window)); /* 46 */
    Tk_Window (*tkMacOSXGetCapture) _ANSI_ARGS_((void)); /* 47 */
    void *reserved48;
    Window (*tkGetTransientMaster) _ANSI_ARGS_((TkWindow * winPtr)); /* 49 */
    int (*tkGenerateButtonEvent) _ANSI_ARGS_((int x, int y, Window window, unsigned int state)); /* 50 */
    void (*tkGenWMDestroyEvent) _ANSI_ARGS_((Tk_Window tkwin)); /* 51 */
    void *reserved52;
    unsigned long (*tkpGetMS) _ANSI_ARGS_((void)); /* 53 */
#endif /* MAC_OSX_TK */
#if !(defined(__WIN32__) || defined(MAC_TCL) || defined(MAC_OSX_TK)) /* X11 */
    void (*tkCreateXEventSource) _ANSI_ARGS_((void)); /* 0 */
    void (*tkFreeWindowId) _ANSI_ARGS_((TkDisplay * dispPtr, Window w)); /* 1 */
    void (*tkInitXId) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 2 */
    int (*tkpCmapStressed) _ANSI_ARGS_((Tk_Window tkwin, Colormap colormap)); /* 3 */
    void (*tkpSync) _ANSI_ARGS_((Display * display)); /* 4 */
    Window (*tkUnixContainerId) _ANSI_ARGS_((TkWindow * winPtr)); /* 5 */
    int (*tkUnixDoOneXEvent) _ANSI_ARGS_((Tcl_Time * timePtr)); /* 6 */
    void (*tkUnixSetMenubar) _ANSI_ARGS_((Tk_Window tkwin, Tk_Window menubar)); /* 7 */
    int (*tkpScanWindowId) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * string, Window * idPtr)); /* 8 */
    void (*tkWmCleanup) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 9 */
    void (*tkSendCleanup) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 10 */
    void (*tkFreeXId) _ANSI_ARGS_((TkDisplay * dispPtr)); /* 11 */
    int (*tkpWmSetState) _ANSI_ARGS_((TkWindow * winPtr, int state)); /* 12 */
#endif /* X11 */
} TkIntPlatStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntPlatStubs *tkIntPlatStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__
#ifndef TkAlignImageData
#define TkAlignImageData \
	(tkIntPlatStubsPtr->tkAlignImageData) /* 0 */
#endif
/* Slot 1 is reserved */
#ifndef TkGenerateActivateEvents
#define TkGenerateActivateEvents \
	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 2 */
#endif
#ifndef TkpGetMS
#define TkpGetMS \
	(tkIntPlatStubsPtr->tkpGetMS) /* 3 */
#endif
#ifndef TkPointerDeadWindow
#define TkPointerDeadWindow \
	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 4 */
#endif
#ifndef TkpPrintWindowId
#define TkpPrintWindowId \
	(tkIntPlatStubsPtr->tkpPrintWindowId) /* 5 */
#endif
#ifndef TkpScanWindowId
#define TkpScanWindowId \
	(tkIntPlatStubsPtr->tkpScanWindowId) /* 6 */
#endif
#ifndef TkpSetCapture
#define TkpSetCapture \
	(tkIntPlatStubsPtr->tkpSetCapture) /* 7 */
#endif
#ifndef TkpSetCursor
#define TkpSetCursor \
	(tkIntPlatStubsPtr->tkpSetCursor) /* 8 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 9 */
#endif
#ifndef TkSetPixmapColormap
#define TkSetPixmapColormap \
	(tkIntPlatStubsPtr->tkSetPixmapColormap) /* 10 */
#endif
#ifndef TkWinCancelMouseTimer
#define TkWinCancelMouseTimer \
	(tkIntPlatStubsPtr->tkWinCancelMouseTimer) /* 11 */
#endif
#ifndef TkWinClipboardRender
#define TkWinClipboardRender \
	(tkIntPlatStubsPtr->tkWinClipboardRender) /* 12 */
#endif
#ifndef TkWinEmbeddedEventProc
#define TkWinEmbeddedEventProc \
	(tkIntPlatStubsPtr->tkWinEmbeddedEventProc) /* 13 */
#endif
#ifndef TkWinFillRect
#define TkWinFillRect \
	(tkIntPlatStubsPtr->tkWinFillRect) /* 14 */
#endif
#ifndef TkWinGetBorderPixels
#define TkWinGetBorderPixels \
	(tkIntPlatStubsPtr->tkWinGetBorderPixels) /* 15 */
#endif
#ifndef TkWinGetDrawableDC
#define TkWinGetDrawableDC \
	(tkIntPlatStubsPtr->tkWinGetDrawableDC) /* 16 */
#endif
#ifndef TkWinGetModifierState
#define TkWinGetModifierState \
	(tkIntPlatStubsPtr->tkWinGetModifierState) /* 17 */
#endif
#ifndef TkWinGetSystemPalette
#define TkWinGetSystemPalette \
	(tkIntPlatStubsPtr->tkWinGetSystemPalette) /* 18 */
#endif
#ifndef TkWinGetWrapperWindow
#define TkWinGetWrapperWindow \
	(tkIntPlatStubsPtr->tkWinGetWrapperWindow) /* 19 */
#endif
#ifndef TkWinHandleMenuEvent
#define TkWinHandleMenuEvent \
	(tkIntPlatStubsPtr->tkWinHandleMenuEvent) /* 20 */
#endif
#ifndef TkWinIndexOfColor
#define TkWinIndexOfColor \
	(tkIntPlatStubsPtr->tkWinIndexOfColor) /* 21 */
#endif
#ifndef TkWinReleaseDrawableDC
#define TkWinReleaseDrawableDC \
	(tkIntPlatStubsPtr->tkWinReleaseDrawableDC) /* 22 */
#endif
#ifndef TkWinResendEvent
#define TkWinResendEvent \
	(tkIntPlatStubsPtr->tkWinResendEvent) /* 23 */
#endif
#ifndef TkWinSelectPalette
#define TkWinSelectPalette \
	(tkIntPlatStubsPtr->tkWinSelectPalette) /* 24 */
#endif
#ifndef TkWinSetMenu
#define TkWinSetMenu \
	(tkIntPlatStubsPtr->tkWinSetMenu) /* 25 */
#endif
#ifndef TkWinSetWindowPos
#define TkWinSetWindowPos \
	(tkIntPlatStubsPtr->tkWinSetWindowPos) /* 26 */
#endif
#ifndef TkWinWmCleanup
#define TkWinWmCleanup \
	(tkIntPlatStubsPtr->tkWinWmCleanup) /* 27 */
#endif
#ifndef TkWinXCleanup
#define TkWinXCleanup \
	(tkIntPlatStubsPtr->tkWinXCleanup) /* 28 */
#endif
#ifndef TkWinXInit
#define TkWinXInit \
	(tkIntPlatStubsPtr->tkWinXInit) /* 29 */
#endif
#ifndef TkWinSetForegroundWindow
#define TkWinSetForegroundWindow \
	(tkIntPlatStubsPtr->tkWinSetForegroundWindow) /* 30 */
#endif
#ifndef TkWinDialogDebug
#define TkWinDialogDebug \
	(tkIntPlatStubsPtr->tkWinDialogDebug) /* 31 */
#endif
#ifndef TkWinGetMenuSystemDefault
#define TkWinGetMenuSystemDefault \
	(tkIntPlatStubsPtr->tkWinGetMenuSystemDefault) /* 32 */
#endif
#ifndef TkWinGetPlatformId
#define TkWinGetPlatformId \
	(tkIntPlatStubsPtr->tkWinGetPlatformId) /* 33 */
#endif
#ifndef TkWinSetHINSTANCE
#define TkWinSetHINSTANCE \
	(tkIntPlatStubsPtr->tkWinSetHINSTANCE) /* 34 */
#endif
#ifndef TkWinGetPlatformTheme
#define TkWinGetPlatformTheme \
	(tkIntPlatStubsPtr->tkWinGetPlatformTheme) /* 35 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef TkGenerateActivateEvents
#define TkGenerateActivateEvents \
	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
#endif
/* Slot 1 is reserved */
/* Slot 2 is reserved */
#ifndef TkpGetMS
#define TkpGetMS \
	(tkIntPlatStubsPtr->tkpGetMS) /* 3 */
#endif
/* Slot 4 is reserved */
#ifndef TkPointerDeadWindow
#define TkPointerDeadWindow \
	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 5 */
#endif
#ifndef TkpSetCapture
#define TkpSetCapture \
	(tkIntPlatStubsPtr->tkpSetCapture) /* 6 */
#endif
#ifndef TkpSetCursor
#define TkpSetCursor \
	(tkIntPlatStubsPtr->tkpSetCursor) /* 7 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 8 */
#endif
/* Slot 9 is reserved */
#ifndef TkAboutDlg
#define TkAboutDlg \
	(tkIntPlatStubsPtr->tkAboutDlg) /* 10 */
#endif
/* Slot 11 is reserved */
/* Slot 12 is reserved */
#ifndef TkGetTransientMaster
#define TkGetTransientMaster \
	(tkIntPlatStubsPtr->tkGetTransientMaster) /* 13 */
#endif
#ifndef TkGenerateButtonEvent
#define TkGenerateButtonEvent \
	(tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 14 */
#endif
/* Slot 15 is reserved */
#ifndef TkGenWMDestroyEvent
#define TkGenWMDestroyEvent \
	(tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 16 */
#endif
/* Slot 17 is reserved */
#ifndef TkMacButtonKeyState
#define TkMacButtonKeyState \
	(tkIntPlatStubsPtr->tkMacButtonKeyState) /* 18 */
#endif
#ifndef TkMacClearMenubarActive
#define TkMacClearMenubarActive \
	(tkIntPlatStubsPtr->tkMacClearMenubarActive) /* 19 */
#endif
/* Slot 20 is reserved */
#ifndef TkMacDispatchMenuEvent
#define TkMacDispatchMenuEvent \
	(tkIntPlatStubsPtr->tkMacDispatchMenuEvent) /* 21 */
#endif
#ifndef TkMacInstallCursor
#define TkMacInstallCursor \
	(tkIntPlatStubsPtr->tkMacInstallCursor) /* 22 */
#endif
/* Slot 23 is reserved */
#ifndef TkMacHandleTearoffMenu
#define TkMacHandleTearoffMenu \
	(tkIntPlatStubsPtr->tkMacHandleTearoffMenu) /* 24 */
#endif
/* Slot 25 is reserved */
/* Slot 26 is reserved */
#ifndef TkMacDoHLEvent
#define TkMacDoHLEvent \
	(tkIntPlatStubsPtr->tkMacDoHLEvent) /* 27 */
#endif
/* Slot 28 is reserved */
#ifndef TkMacGenerateTime
#define TkMacGenerateTime \
	(tkIntPlatStubsPtr->tkMacGenerateTime) /* 29 */
#endif
/* Slot 30 is reserved */
#ifndef TkMacGetScrollbarGrowWindow
#define TkMacGetScrollbarGrowWindow \
	(tkIntPlatStubsPtr->tkMacGetScrollbarGrowWindow) /* 31 */
#endif
#ifndef TkMacGetXWindow
#define TkMacGetXWindow \
	(tkIntPlatStubsPtr->tkMacGetXWindow) /* 32 */
#endif
#ifndef TkMacGrowToplevel
#define TkMacGrowToplevel \
	(tkIntPlatStubsPtr->tkMacGrowToplevel) /* 33 */
#endif
#ifndef TkMacHandleMenuSelect
#define TkMacHandleMenuSelect \
	(tkIntPlatStubsPtr->tkMacHandleMenuSelect) /* 34 */
#endif
/* Slot 35 is reserved */
/* Slot 36 is reserved */
/* Slot 37 is reserved */
#ifndef TkMacInvalidateWindow
#define TkMacInvalidateWindow \
	(tkIntPlatStubsPtr->tkMacInvalidateWindow) /* 38 */
#endif
#ifndef TkMacIsCharacterMissing
#define TkMacIsCharacterMissing \
	(tkIntPlatStubsPtr->tkMacIsCharacterMissing) /* 39 */
#endif
#ifndef TkMacMakeRealWindowExist
#define TkMacMakeRealWindowExist \
	(tkIntPlatStubsPtr->tkMacMakeRealWindowExist) /* 40 */
#endif
#ifndef TkMacMakeStippleMap
#define TkMacMakeStippleMap \
	(tkIntPlatStubsPtr->tkMacMakeStippleMap) /* 41 */
#endif
#ifndef TkMacMenuClick
#define TkMacMenuClick \
	(tkIntPlatStubsPtr->tkMacMenuClick) /* 42 */
#endif
#ifndef TkMacRegisterOffScreenWindow
#define TkMacRegisterOffScreenWindow \
	(tkIntPlatStubsPtr->tkMacRegisterOffScreenWindow) /* 43 */
#endif
#ifndef TkMacResizable
#define TkMacResizable \
	(tkIntPlatStubsPtr->tkMacResizable) /* 44 */
#endif
/* Slot 45 is reserved */
#ifndef TkMacSetHelpMenuItemCount
#define TkMacSetHelpMenuItemCount \
	(tkIntPlatStubsPtr->tkMacSetHelpMenuItemCount) /* 46 */
#endif
#ifndef TkMacSetScrollbarGrow
#define TkMacSetScrollbarGrow \
	(tkIntPlatStubsPtr->tkMacSetScrollbarGrow) /* 47 */
#endif
#ifndef TkMacSetUpClippingRgn
#define TkMacSetUpClippingRgn \
	(tkIntPlatStubsPtr->tkMacSetUpClippingRgn) /* 48 */
#endif
#ifndef TkMacSetUpGraphicsPort
#define TkMacSetUpGraphicsPort \
	(tkIntPlatStubsPtr->tkMacSetUpGraphicsPort) /* 49 */
#endif
#ifndef TkMacUpdateClipRgn
#define TkMacUpdateClipRgn \
	(tkIntPlatStubsPtr->tkMacUpdateClipRgn) /* 50 */
#endif
#ifndef TkMacUnregisterMacWindow
#define TkMacUnregisterMacWindow \
	(tkIntPlatStubsPtr->tkMacUnregisterMacWindow) /* 51 */
#endif
#ifndef TkMacUseMenuID
#define TkMacUseMenuID \
	(tkIntPlatStubsPtr->tkMacUseMenuID) /* 52 */
#endif
#ifndef TkMacVisableClipRgn
#define TkMacVisableClipRgn \
	(tkIntPlatStubsPtr->tkMacVisableClipRgn) /* 53 */
#endif
#ifndef TkMacWinBounds
#define TkMacWinBounds \
	(tkIntPlatStubsPtr->tkMacWinBounds) /* 54 */
#endif
#ifndef TkMacWindowOffset
#define TkMacWindowOffset \
	(tkIntPlatStubsPtr->tkMacWindowOffset) /* 55 */
#endif
/* Slot 56 is reserved */
#ifndef TkSetMacColor
#define TkSetMacColor \
	(tkIntPlatStubsPtr->tkSetMacColor) /* 57 */
#endif
#ifndef TkSetWMName
#define TkSetWMName \
	(tkIntPlatStubsPtr->tkSetWMName) /* 58 */
#endif
#ifndef TkSuspendClipboard
#define TkSuspendClipboard \
	(tkIntPlatStubsPtr->tkSuspendClipboard) /* 59 */
#endif
/* Slot 60 is reserved */
#ifndef TkMacZoomToplevel
#define TkMacZoomToplevel \
	(tkIntPlatStubsPtr->tkMacZoomToplevel) /* 61 */
#endif
#ifndef Tk_TopCoordsToWindow
#define Tk_TopCoordsToWindow \
	(tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 62 */
#endif
#ifndef TkMacContainerId
#define TkMacContainerId \
	(tkIntPlatStubsPtr->tkMacContainerId) /* 63 */
#endif
#ifndef TkMacGetHostToplevel
#define TkMacGetHostToplevel \
	(tkIntPlatStubsPtr->tkMacGetHostToplevel) /* 64 */
#endif
#ifndef TkMacPreprocessMenu
#define TkMacPreprocessMenu \
	(tkIntPlatStubsPtr->tkMacPreprocessMenu) /* 65 */
#endif
#ifndef TkpIsWindowFloating
#define TkpIsWindowFloating \
	(tkIntPlatStubsPtr->tkpIsWindowFloating) /* 66 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef TkGenerateActivateEvents
#define TkGenerateActivateEvents \
	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
#endif
/* Slot 1 is reserved */
/* Slot 2 is reserved */
#ifndef TkPointerDeadWindow
#define TkPointerDeadWindow \
	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 3 */
#endif
#ifndef TkpSetCapture
#define TkpSetCapture \
	(tkIntPlatStubsPtr->tkpSetCapture) /* 4 */
#endif
#ifndef TkpSetCursor
#define TkpSetCursor \
	(tkIntPlatStubsPtr->tkpSetCursor) /* 5 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 6 */
#endif
#ifndef TkAboutDlg
#define TkAboutDlg \
	(tkIntPlatStubsPtr->tkAboutDlg) /* 7 */
#endif
#ifndef TkMacOSXButtonKeyState
#define TkMacOSXButtonKeyState \
	(tkIntPlatStubsPtr->tkMacOSXButtonKeyState) /* 8 */
#endif
#ifndef TkMacOSXClearMenubarActive
#define TkMacOSXClearMenubarActive \
	(tkIntPlatStubsPtr->tkMacOSXClearMenubarActive) /* 9 */
#endif
#ifndef TkMacOSXDispatchMenuEvent
#define TkMacOSXDispatchMenuEvent \
	(tkIntPlatStubsPtr->tkMacOSXDispatchMenuEvent) /* 10 */
#endif
#ifndef TkMacOSXInstallCursor
#define TkMacOSXInstallCursor \
	(tkIntPlatStubsPtr->tkMacOSXInstallCursor) /* 11 */
#endif
#ifndef TkMacOSXHandleTearoffMenu
#define TkMacOSXHandleTearoffMenu \
	(tkIntPlatStubsPtr->tkMacOSXHandleTearoffMenu) /* 12 */
#endif
/* Slot 13 is reserved */
#ifndef TkMacOSXDoHLEvent
#define TkMacOSXDoHLEvent \
	(tkIntPlatStubsPtr->tkMacOSXDoHLEvent) /* 14 */
#endif
/* Slot 15 is reserved */
#ifndef TkMacOSXGetXWindow
#define TkMacOSXGetXWindow \
	(tkIntPlatStubsPtr->tkMacOSXGetXWindow) /* 16 */
#endif
#ifndef TkMacOSXGrowToplevel
#define TkMacOSXGrowToplevel \
	(tkIntPlatStubsPtr->tkMacOSXGrowToplevel) /* 17 */
#endif
#ifndef TkMacOSXHandleMenuSelect
#define TkMacOSXHandleMenuSelect \
	(tkIntPlatStubsPtr->tkMacOSXHandleMenuSelect) /* 18 */
#endif
/* Slot 19 is reserved */
/* Slot 20 is reserved */
#ifndef TkMacOSXInvalidateWindow
#define TkMacOSXInvalidateWindow \
	(tkIntPlatStubsPtr->tkMacOSXInvalidateWindow) /* 21 */
#endif
#ifndef TkMacOSXIsCharacterMissing
#define TkMacOSXIsCharacterMissing \
	(tkIntPlatStubsPtr->tkMacOSXIsCharacterMissing) /* 22 */
#endif
#ifndef TkMacOSXMakeRealWindowExist
#define TkMacOSXMakeRealWindowExist \
	(tkIntPlatStubsPtr->tkMacOSXMakeRealWindowExist) /* 23 */
#endif
#ifndef TkMacOSXMakeStippleMap
#define TkMacOSXMakeStippleMap \
	(tkIntPlatStubsPtr->tkMacOSXMakeStippleMap) /* 24 */
#endif
#ifndef TkMacOSXMenuClick
#define TkMacOSXMenuClick \
	(tkIntPlatStubsPtr->tkMacOSXMenuClick) /* 25 */
#endif
#ifndef TkMacOSXRegisterOffScreenWindow
#define TkMacOSXRegisterOffScreenWindow \
	(tkIntPlatStubsPtr->tkMacOSXRegisterOffScreenWindow) /* 26 */
#endif
#ifndef TkMacOSXResizable
#define TkMacOSXResizable \
	(tkIntPlatStubsPtr->tkMacOSXResizable) /* 27 */
#endif
#ifndef TkMacOSXSetHelpMenuItemCount
#define TkMacOSXSetHelpMenuItemCount \
	(tkIntPlatStubsPtr->tkMacOSXSetHelpMenuItemCount) /* 28 */
#endif
#ifndef TkMacOSXSetScrollbarGrow
#define TkMacOSXSetScrollbarGrow \
	(tkIntPlatStubsPtr->tkMacOSXSetScrollbarGrow) /* 29 */
#endif
#ifndef TkMacOSXSetUpClippingRgn
#define TkMacOSXSetUpClippingRgn \
	(tkIntPlatStubsPtr->tkMacOSXSetUpClippingRgn) /* 30 */
#endif
#ifndef TkMacOSXSetUpGraphicsPort
#define TkMacOSXSetUpGraphicsPort \
	(tkIntPlatStubsPtr->tkMacOSXSetUpGraphicsPort) /* 31 */
#endif
#ifndef TkMacOSXUpdateClipRgn
#define TkMacOSXUpdateClipRgn \
	(tkIntPlatStubsPtr->tkMacOSXUpdateClipRgn) /* 32 */
#endif
#ifndef TkMacOSXUnregisterMacWindow
#define TkMacOSXUnregisterMacWindow \
	(tkIntPlatStubsPtr->tkMacOSXUnregisterMacWindow) /* 33 */
#endif
#ifndef TkMacOSXUseMenuID
#define TkMacOSXUseMenuID \
	(tkIntPlatStubsPtr->tkMacOSXUseMenuID) /* 34 */
#endif
#ifndef TkMacOSXVisableClipRgn
#define TkMacOSXVisableClipRgn \
	(tkIntPlatStubsPtr->tkMacOSXVisableClipRgn) /* 35 */
#endif
#ifndef TkMacOSXWinBounds
#define TkMacOSXWinBounds \
	(tkIntPlatStubsPtr->tkMacOSXWinBounds) /* 36 */
#endif
#ifndef TkMacOSXWindowOffset
#define TkMacOSXWindowOffset \
	(tkIntPlatStubsPtr->tkMacOSXWindowOffset) /* 37 */
#endif
#ifndef TkSetMacColor
#define TkSetMacColor \
	(tkIntPlatStubsPtr->tkSetMacColor) /* 38 */
#endif
#ifndef TkSetWMName
#define TkSetWMName \
	(tkIntPlatStubsPtr->tkSetWMName) /* 39 */
#endif
#ifndef TkSuspendClipboard
#define TkSuspendClipboard \
	(tkIntPlatStubsPtr->tkSuspendClipboard) /* 40 */
#endif
#ifndef TkMacOSXZoomToplevel
#define TkMacOSXZoomToplevel \
	(tkIntPlatStubsPtr->tkMacOSXZoomToplevel) /* 41 */
#endif
#ifndef Tk_TopCoordsToWindow
#define Tk_TopCoordsToWindow \
	(tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 42 */
#endif
#ifndef TkMacOSXContainerId
#define TkMacOSXContainerId \
	(tkIntPlatStubsPtr->tkMacOSXContainerId) /* 43 */
#endif
#ifndef TkMacOSXGetHostToplevel
#define TkMacOSXGetHostToplevel \
	(tkIntPlatStubsPtr->tkMacOSXGetHostToplevel) /* 44 */
#endif
#ifndef TkMacOSXPreprocessMenu
#define TkMacOSXPreprocessMenu \
	(tkIntPlatStubsPtr->tkMacOSXPreprocessMenu) /* 45 */
#endif
#ifndef TkpIsWindowFloating
#define TkpIsWindowFloating \
	(tkIntPlatStubsPtr->tkpIsWindowFloating) /* 46 */
#endif
#ifndef TkMacOSXGetCapture
#define TkMacOSXGetCapture \
	(tkIntPlatStubsPtr->tkMacOSXGetCapture) /* 47 */
#endif
/* Slot 48 is reserved */
#ifndef TkGetTransientMaster
#define TkGetTransientMaster \
	(tkIntPlatStubsPtr->tkGetTransientMaster) /* 49 */
#endif
#ifndef TkGenerateButtonEvent
#define TkGenerateButtonEvent \
	(tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 50 */
#endif
#ifndef TkGenWMDestroyEvent
#define TkGenWMDestroyEvent \
	(tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 51 */
#endif
/* Slot 52 is reserved */
#ifndef TkpGetMS
#define TkpGetMS \
	(tkIntPlatStubsPtr->tkpGetMS) /* 53 */
#endif
#endif /* MAC_OSX_TK */
#if !(defined(__WIN32__) || defined(MAC_TCL) || defined(MAC_OSX_TK)) /* X11 */
#ifndef TkCreateXEventSource
#define TkCreateXEventSource \
	(tkIntPlatStubsPtr->tkCreateXEventSource) /* 0 */
#endif
#ifndef TkFreeWindowId
#define TkFreeWindowId \
	(tkIntPlatStubsPtr->tkFreeWindowId) /* 1 */
#endif
#ifndef TkInitXId
#define TkInitXId \
	(tkIntPlatStubsPtr->tkInitXId) /* 2 */
#endif
#ifndef TkpCmapStressed
#define TkpCmapStressed \
	(tkIntPlatStubsPtr->tkpCmapStressed) /* 3 */
#endif
#ifndef TkpSync
#define TkpSync \
	(tkIntPlatStubsPtr->tkpSync) /* 4 */
#endif
#ifndef TkUnixContainerId
#define TkUnixContainerId \
	(tkIntPlatStubsPtr->tkUnixContainerId) /* 5 */
#endif
#ifndef TkUnixDoOneXEvent
#define TkUnixDoOneXEvent \
	(tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 6 */
#endif
#ifndef TkUnixSetMenubar
#define TkUnixSetMenubar \
	(tkIntPlatStubsPtr->tkUnixSetMenubar) /* 7 */
#endif
#ifndef TkpScanWindowId
#define TkpScanWindowId \
	(tkIntPlatStubsPtr->tkpScanWindowId) /* 8 */
#endif
#ifndef TkWmCleanup
#define TkWmCleanup \
	(tkIntPlatStubsPtr->tkWmCleanup) /* 9 */
#endif
#ifndef TkSendCleanup
#define TkSendCleanup \
	(tkIntPlatStubsPtr->tkSendCleanup) /* 10 */
#endif
#ifndef TkFreeXId
#define TkFreeXId \
	(tkIntPlatStubsPtr->tkFreeXId) /* 11 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 12 */
#endif
#endif /* X11 */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTPLATDECLS */
                           tkMacOSXDefault.h                                                                                   0100644 0001750 0001750 00000042736 12566232567 035552  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk-private                                                             /*
 * tkMacOSXDefault.h --
 *
 *	This file defines the defaults for all options for all of
 *	the Tk widgets.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkMacOSXDefault.h,v 1.2.2.7 2007/11/09 06:26:55 das Exp $
 */

#ifndef _TKMACDEFAULT
#define _TKMACDEFAULT

/*
 * The definitions below provide symbolic names for the default colors.
 * NORMAL_BG -		Normal background color.
 * ACTIVE_BG -		Background color when widget is active.
 * SELECT_BG -		Background color for selected text.
 * SELECT_FG -		Foreground color for selected text.
 * TROUGH -		Background color for troughs in scales and scrollbars.
 * INDICATOR -		Color for indicator when button is selected.
 * DISABLED -		Foreground color when widget is disabled.
 */

#define BLACK				"Black"
#define WHITE				"White"
#define NORMAL_BG			"systemWindowBody"
#define ACTIVE_BG			"systemButtonFacePressed"
#define ACTIVE_FG			"systemPushButtonPressedText"
#define SELECT_BG			"systemHighlight"
#define SELECT_FG			None
#define INACTIVE_SELECT_BG		"systemHighlightSecondary"
#define TROUGH				"#c3c3c3"
#define INDICATOR			"#b03060"
#define DISABLED			"#a3a3a3"

/*
 * Defaults for labels, buttons, checkbuttons, and radiobuttons:
 */

#define DEF_BUTTON_ANCHOR		"center"
#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
#define DEF_BUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
/* #define DEF_BUTTON_BG_COLOR	"systemButtonFace"*/
#define DEF_BUTTON_BG_COLOR		WHITE
#define DEF_BUTTON_BG_MONO		WHITE
#define DEF_BUTTON_BITMAP		""
#define DEF_BUTTON_BORDER_WIDTH		"2"
#define DEF_BUTTON_CURSOR		""
#define DEF_BUTTON_COMMAND		""
#define DEF_BUTTON_COMPOUND		"none"
#define DEF_BUTTON_DEFAULT		"disabled"
#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
#define DEF_BUTTON_DISABLED_FG_MONO	""
#define DEF_BUTTON_FG			"systemButtonText"
#define DEF_CHKRAD_FG			DEF_BUTTON_FG
#define DEF_BUTTON_FONT			"system"
#define DEF_BUTTON_HEIGHT		"0"
#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
#define DEF_BUTTON_HIGHLIGHT		"systemButtonFrame"
#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
#define DEF_BUTTON_HIGHLIGHT_WIDTH	"4"
#define DEF_BUTTON_IMAGE		(char *) NULL
#define DEF_BUTTON_INDICATOR		"1"
#define DEF_BUTTON_JUSTIFY		"center"
#define DEF_BUTTON_OFF_VALUE		"0"
#define DEF_BUTTON_ON_VALUE		"1"
#define DEF_BUTTON_OVER_RELIEF		""
#define DEF_BUTTON_PADX			"12"
#define DEF_LABCHKRAD_PADX		"1"
#define DEF_BUTTON_PADY			"3"
#define DEF_LABCHKRAD_PADY		"1"
#define DEF_BUTTON_RELIEF		"flat"
#define DEF_LABCHKRAD_RELIEF		"flat"
#define DEF_BUTTON_REPEAT_DELAY		"0"
#define DEF_BUTTON_REPEAT_INTERVAL	"0"
#define DEF_BUTTON_SELECT_COLOR		INDICATOR
#define DEF_BUTTON_SELECT_MONO		BLACK
#define DEF_BUTTON_SELECT_IMAGE		(char *) NULL
#define DEF_BUTTON_STATE		"normal"
#define DEF_LABEL_TAKE_FOCUS		"0"
#define DEF_BUTTON_TAKE_FOCUS		(char *) NULL
#define DEF_BUTTON_TEXT			""
#define DEF_BUTTON_TEXT_VARIABLE	""
#define DEF_BUTTON_UNDERLINE		"-1"
#define DEF_BUTTON_VALUE		""
#define DEF_BUTTON_WIDTH		"0"
#define DEF_BUTTON_WRAP_LENGTH		"0"
#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
#define DEF_CHECKBUTTON_VARIABLE	""

/*
 * Defaults for canvases:
 */

#define DEF_CANVAS_BG_COLOR		NORMAL_BG
#define DEF_CANVAS_BG_MONO		WHITE
#define DEF_CANVAS_BORDER_WIDTH		"0"
#define DEF_CANVAS_CLOSE_ENOUGH		"1"
#define DEF_CANVAS_CONFINE		"1"
#define DEF_CANVAS_CURSOR		""
#define DEF_CANVAS_HEIGHT		"7c"
#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
#define DEF_CANVAS_HIGHLIGHT		BLACK
#define DEF_CANVAS_HIGHLIGHT_WIDTH	"3"
#define DEF_CANVAS_INSERT_BG		BLACK
#define DEF_CANVAS_INSERT_BD_COLOR	"0"
#define DEF_CANVAS_INSERT_BD_MONO	"0"
#define DEF_CANVAS_INSERT_OFF_TIME	"300"
#define DEF_CANVAS_INSERT_ON_TIME	"600"
#define DEF_CANVAS_INSERT_WIDTH		"2"
#define DEF_CANVAS_RELIEF		"flat"
#define DEF_CANVAS_SCROLL_REGION	""
#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
#define DEF_CANVAS_SELECT_MONO		BLACK
#define DEF_CANVAS_SELECT_BD_COLOR	"1"
#define DEF_CANVAS_SELECT_BD_MONO	"0"
#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
#define DEF_CANVAS_SELECT_FG_MONO	WHITE
#define DEF_CANVAS_TAKE_FOCUS		(char *) NULL
#define DEF_CANVAS_WIDTH		"10c"
#define DEF_CANVAS_X_SCROLL_CMD		""
#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
#define DEF_CANVAS_Y_SCROLL_CMD		""
#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"

/*
 * Defaults for entries:
 */

/*
 * I test the following two values in TkpDrawEntryBorderAndFocus
 * to determine whether to use the native entry widget. So if
 * you change the defaults to be different from these, then you
 * won't get the native widget by default.
 */

#define MAC_OSX_FOCUS_WIDTH		3
#define MAC_OSX_ENTRY_BORDER		2
#define MAC_OSX_ENTRY_RELIEF		TK_RELIEF_SUNKEN
#define MAC_OSX_ENTRY_SELECT_RELIEF	TK_RELIEF_FLAT

#define DEF_ENTRY_BG_COLOR		NORMAL_BG
#define DEF_ENTRY_BG_MONO		WHITE
#define DEF_ENTRY_BORDER_WIDTH		"2"
#define DEF_ENTRY_CURSOR		"xterm"
#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
#define DEF_ENTRY_DISABLED_FG		DISABLED
#define DEF_ENTRY_EXPORT_SELECTION	"1"
#define DEF_ENTRY_FONT			"Helvetica 12"
#define DEF_ENTRY_FG			BLACK
#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
#define DEF_ENTRY_HIGHLIGHT		BLACK
/* #define DEF_ENTRY_HIGHLIGHT_WIDTH	"3" */
#define DEF_ENTRY_HIGHLIGHT_WIDTH	"3"
#define DEF_ENTRY_INSERT_BG		BLACK
#define DEF_ENTRY_INSERT_BD_COLOR	"0"
#define DEF_ENTRY_INSERT_BD_MONO	"0"
#define DEF_ENTRY_INSERT_OFF_TIME	"300"
#define DEF_ENTRY_INSERT_ON_TIME	"600"
/* #define DEF_ENTRY_INSERT_WIDTH		"2" */
#define DEF_ENTRY_INSERT_WIDTH		"1"
#define DEF_ENTRY_JUSTIFY		"left"
#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
#define DEF_ENTRY_READONLY_BG_MONO	WHITE
#define DEF_ENTRY_RELIEF		"sunken"
/* #define DEF_ENTRY_RELIEF		"solid" */
#define DEF_ENTRY_SCROLL_COMMAND	""
#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
#define DEF_ENTRY_SELECT_MONO		BLACK
#define DEF_ENTRY_SELECT_BD_COLOR	"1"
#define DEF_ENTRY_SELECT_BD_MONO	"0"
#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
#define DEF_ENTRY_SELECT_FG_MONO	WHITE
#define DEF_ENTRY_SHOW			(char *) NULL
#define DEF_ENTRY_STATE			"normal"
#define DEF_ENTRY_TAKE_FOCUS		(char *) NULL
#define DEF_ENTRY_TEXT_VARIABLE		""
#define DEF_ENTRY_WIDTH			"20"

/*
 * Defaults for frames:
 */

#define DEF_FRAME_BG_COLOR		NORMAL_BG
#define DEF_FRAME_BG_MONO		WHITE
#define DEF_FRAME_BORDER_WIDTH		"0"
#define DEF_FRAME_CLASS			"Frame"
#define DEF_FRAME_COLORMAP		""
#define DEF_FRAME_CONTAINER		"0"
#define DEF_FRAME_CURSOR		""
#define DEF_FRAME_HEIGHT		"0"
#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
#define DEF_FRAME_HIGHLIGHT		BLACK
#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
#define DEF_FRAME_PADX			"0"
#define DEF_FRAME_PADY			"0"
#define DEF_FRAME_RELIEF		"flat"
#define DEF_FRAME_TAKE_FOCUS		"0"
#define DEF_FRAME_VISUAL		""
#define DEF_FRAME_WIDTH			"0"

/*
 * Defaults for labelframes:
 */

#define DEF_LABELFRAME_BORDER_WIDTH	"2"
#define DEF_LABELFRAME_CLASS		"Labelframe"
#define DEF_LABELFRAME_RELIEF		"groove"
#define DEF_LABELFRAME_FG		"systemButtonText"
#define DEF_LABELFRAME_FONT		"system"
#define DEF_LABELFRAME_TEXT		""
#define DEF_LABELFRAME_LABELANCHOR	"nw"

/*
 * Defaults for listboxes:
 */

#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
#define DEF_LISTBOX_BG_COLOR		WHITE
#define DEF_LISTBOX_BG_MONO		WHITE
#define DEF_LISTBOX_BORDER_WIDTH	"1"
#define DEF_LISTBOX_CURSOR		""
#define DEF_LISTBOX_DISABLED_FG		DISABLED
#define DEF_LISTBOX_EXPORT_SELECTION	"1"
#define DEF_LISTBOX_FONT		"application"
#define DEF_LISTBOX_FG			BLACK
#define DEF_LISTBOX_HEIGHT		"10"
#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
#define DEF_LISTBOX_HIGHLIGHT		BLACK
#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"0"
#define DEF_LISTBOX_RELIEF		"solid"
#define DEF_LISTBOX_SCROLL_COMMAND	""
#define DEF_LISTBOX_LIST_VARIABLE	""
#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
#define DEF_LISTBOX_SELECT_MONO		BLACK
#define DEF_LISTBOX_SELECT_BD		"0"
#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
#define DEF_LISTBOX_SELECT_MODE		"browse"
#define DEF_LISTBOX_SET_GRID		"0"
#define DEF_LISTBOX_STATE		"normal"
#define DEF_LISTBOX_TAKE_FOCUS		(char *) NULL
#define DEF_LISTBOX_WIDTH		"20"

/*
 * Defaults for individual entries of menus:
 */

#define DEF_MENU_ENTRY_ACTIVE_BG	(char *) NULL
#define DEF_MENU_ENTRY_ACTIVE_FG	(char *) NULL
#define DEF_MENU_ENTRY_ACCELERATOR	(char *) NULL
#define DEF_MENU_ENTRY_BG		(char *) NULL
#define DEF_MENU_ENTRY_BITMAP		None
#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
#define DEF_MENU_ENTRY_COMMAND		(char *) NULL
#define DEF_MENU_ENTRY_COMPOUND		"none"
#define DEF_MENU_ENTRY_FG		(char *) NULL
#define DEF_MENU_ENTRY_FONT		(char *) NULL
#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
#define DEF_MENU_ENTRY_IMAGE		(char *) NULL
#define DEF_MENU_ENTRY_INDICATOR	"1"
#define DEF_MENU_ENTRY_LABEL		(char *) NULL
#define DEF_MENU_ENTRY_MENU		(char *) NULL
#define DEF_MENU_ENTRY_OFF_VALUE	"0"
#define DEF_MENU_ENTRY_ON_VALUE		"1"
#define DEF_MENU_ENTRY_SELECT_IMAGE	(char *) NULL
#define DEF_MENU_ENTRY_STATE		"normal"
#define DEF_MENU_ENTRY_VALUE		(char *) NULL
#define DEF_MENU_ENTRY_CHECK_VARIABLE	(char *) NULL
#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
#define DEF_MENU_ENTRY_SELECT	(char *) NULL
#define DEF_MENU_ENTRY_UNDERLINE	"-1"

/*
 * Defaults for menus overall:
 */

#define DEF_MENU_ACTIVE_BG_COLOR	"systemMenuActive"
#define DEF_MENU_ACTIVE_BG_MONO		BLACK
#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
#define DEF_MENU_ACTIVE_FG_COLOR	"systemMenuActiveText"
#define DEF_MENU_ACTIVE_FG_MONO		WHITE
#define DEF_MENU_BG_COLOR		"systemMenu"
#define DEF_MENU_BG_MONO		WHITE
#define DEF_MENU_BORDER_WIDTH		"0"
#define DEF_MENU_CURSOR			"arrow"
#define DEF_MENU_DISABLED_FG_COLOR	"systemMenuDisabled"
#define DEF_MENU_DISABLED_FG_MONO	""
#define DEF_MENU_FONT			"menu" /* special: see tkMacOSXMenu.c */
#define DEF_MENU_FG			"systemMenuText"
#define DEF_MENU_POST_COMMAND		""
#define DEF_MENU_RELIEF			"flat"
#define DEF_MENU_SELECT_COLOR		"systemMenuActive"
#define DEF_MENU_SELECT_MONO		BLACK
#define DEF_MENU_TAKE_FOCUS		"0"

/*
 * FIXME: Turn the default back to 1 when we make tearoff menus work again.
 */

#define DEF_MENU_TEAROFF		"0"
#define DEF_MENU_TEAROFF_CMD		(char *) NULL
#define DEF_MENU_TITLE			""
#define DEF_MENU_TYPE			"normal"

/*
 * Defaults for menubuttons:
 */

#define DEF_MENUBUTTON_ANCHOR		"center"
#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
#define DEF_MENUBUTTON_BG_MONO		WHITE
#define DEF_MENUBUTTON_BITMAP		""
#define DEF_MENUBUTTON_BORDER_WIDTH	"2"
#define DEF_MENUBUTTON_CURSOR		""
#define DEF_MENUBUTTON_DIRECTION	"below"
#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
#define DEF_MENUBUTTON_FONT		"system"
#define DEF_MENUBUTTON_FG		BLACK
#define DEF_MENUBUTTON_HEIGHT		"0"
#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
#define DEF_MENUBUTTON_IMAGE		(char *) NULL
#define DEF_MENUBUTTON_INDICATOR	"0"
/* #define DEF_MENUBUTTON_JUSTIFY		"center" */
#define DEF_MENUBUTTON_JUSTIFY		"left"
#define DEF_MENUBUTTON_MENU		""
#define DEF_MENUBUTTON_PADX		"4p"
#define DEF_MENUBUTTON_PADY		"3p"
#define DEF_MENUBUTTON_RELIEF		"flat"
#define DEF_MENUBUTTON_STATE		"normal"
#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
#define DEF_MENUBUTTON_TEXT		""
#define DEF_MENUBUTTON_TEXT_VARIABLE	""
#define DEF_MENUBUTTON_UNDERLINE	"-1"
#define DEF_MENUBUTTON_WIDTH		"0"
#define DEF_MENUBUTTON_WRAP_LENGTH	"0"

/*
 * Defaults for messages:
 */

#define DEF_MESSAGE_ANCHOR		"center"
#define DEF_MESSAGE_ASPECT		"150"
#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
#define DEF_MESSAGE_BG_MONO		WHITE
#define DEF_MESSAGE_BORDER_WIDTH	"1"
#define DEF_MESSAGE_CURSOR		""
#define DEF_MESSAGE_FG			BLACK
#define DEF_MESSAGE_FONT		"system"
#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
#define DEF_MESSAGE_HIGHLIGHT		BLACK
#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
#define DEF_MESSAGE_JUSTIFY		"left"
#define DEF_MESSAGE_PADX		"-1"
#define DEF_MESSAGE_PADY		"-1"
#define DEF_MESSAGE_RELIEF		"flat"
#define DEF_MESSAGE_TAKE_FOCUS		"0"
#define DEF_MESSAGE_TEXT		""
#define DEF_MESSAGE_TEXT_VARIABLE	""
#define DEF_MESSAGE_WIDTH		"0"
/*
 * Defaults for panedwindows
 */

#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
#define DEF_PANEDWINDOW_BG_MONO		WHITE
#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
#define DEF_PANEDWINDOW_CURSOR		""
#define DEF_PANEDWINDOW_HANDLEPAD	"8"
#define DEF_PANEDWINDOW_HANDLESIZE	"8"
#define DEF_PANEDWINDOW_HEIGHT		""
#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
#define DEF_PANEDWINDOW_ORIENT		"horizontal"
#define DEF_PANEDWINDOW_RELIEF		"flat"
#define DEF_PANEDWINDOW_SASHCURSOR	""
#define DEF_PANEDWINDOW_SASHPAD		"0"
#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
#define DEF_PANEDWINDOW_SASHWIDTH	"3"
#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
#define DEF_PANEDWINDOW_WIDTH		""

/*
 * Defaults for panedwindow panes
 */

#define DEF_PANEDWINDOW_PANE_AFTER	""
#define DEF_PANEDWINDOW_PANE_BEFORE	""
#define DEF_PANEDWINDOW_PANE_HEIGHT	""
#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
#define DEF_PANEDWINDOW_PANE_PADX	"0"
#define DEF_PANEDWINDOW_PANE_PADY	"0"
#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
#define DEF_PANEDWINDOW_PANE_WIDTH	""

/*
 * Defaults for scales:
 */

#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
#define DEF_SCALE_BG_COLOR		NORMAL_BG
#define DEF_SCALE_BG_MONO		WHITE
#define DEF_SCALE_BIG_INCREMENT		"0"
#define DEF_SCALE_BORDER_WIDTH		"1"
#define DEF_SCALE_COMMAND		""
#define DEF_SCALE_CURSOR		""
#define DEF_SCALE_DIGITS		"0"
#define DEF_SCALE_FONT			"system"
#define DEF_SCALE_FG_COLOR		BLACK
#define DEF_SCALE_FG_MONO		BLACK
#define DEF_SCALE_FROM			"0"
#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
#define DEF_SCALE_HIGHLIGHT		BLACK
#define DEF_SCALE_HIGHLIGHT_WIDTH	"0"
#define DEF_SCALE_LABEL			""
#define DEF_SCALE_LENGTH		"100"
#define DEF_SCALE_ORIENT		"vertical"
#define DEF_SCALE_RELIEF		"flat"
#define DEF_SCALE_REPEAT_DELAY	"300"
#define DEF_SCALE_REPEAT_INTERVAL	"100"
#define DEF_SCALE_RESOLUTION		"1"
#define DEF_SCALE_TROUGH_COLOR		TROUGH
#define DEF_SCALE_TROUGH_MONO		WHITE
#define DEF_SCALE_SHOW_VALUE		"1"
#define DEF_SCALE_SLIDER_LENGTH		"30"
#define DEF_SCALE_SLIDER_RELIEF		"raised"
#define DEF_SCALE_STATE			"normal"
#define DEF_SCALE_TAKE_FOCUS		(char *) NULL
#define DEF_SCALE_TICK_INTERVAL		"0"
#define DEF_SCALE_TO			"100"
#define DEF_SCALE_VARIABLE		""
#define DEF_SCALE_WIDTH			"15"

/*
 * Defaults for scrollbars:
 */

#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
#define DEF_SCROLLBAR_BG_MONO		WHITE
#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
#define DEF_SCROLLBAR_COMMAND		""
#define DEF_SCROLLBAR_CURSOR		""
#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
#define DEF_SCROLLBAR_JUMP		"0"
#define DEF_SCROLLBAR_ORIENT		"vertical"
#define DEF_SCROLLBAR_RELIEF		"flat"
#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
#define DEF_SCROLLBAR_TAKE_FOCUS	(char *) NULL
#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
#define DEF_SCROLLBAR_WIDTH		"15"

/*
 * Defaults for texts:
 */

#define DEF_TEXT_AUTO_SEPARATORS	"1"
#define DEF_TEXT_BG_COLOR		NORMAL_BG
#define DEF_TEXT_BG_MONO		WHITE
#define DEF_TEXT_BORDER_WIDTH		"0"
#define DEF_TEXT_CURSOR			"xterm"
#define DEF_TEXT_FG			BLACK
#define DEF_TEXT_EXPORT_SELECTION	"1"
#define DEF_TEXT_FONT			"Courier 12"
#define DEF_TEXT_HEIGHT			"24"
#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
#define DEF_TEXT_HIGHLIGHT		BLACK
#define DEF_TEXT_HIGHLIGHT_WIDTH	"3"
#define DEF_TEXT_INSERT_BG		BLACK
#define DEF_TEXT_INSERT_BD_COLOR	"0"
#define DEF_TEXT_INSERT_BD_MONO		"0"
#define DEF_TEXT_INSERT_OFF_TIME	"300"
#define DEF_TEXT_INSERT_ON_TIME		"600"
#define DEF_TEXT_INSERT_WIDTH		"1"
#define DEF_TEXT_MAX_UNDO		"0"
#define DEF_TEXT_PADX			"1"
#define DEF_TEXT_PADY			"1"
#define DEF_TEXT_RELIEF			"flat"
#define DEF_TEXT_SELECT_COLOR		SELECT_BG
#define DEF_TEXT_SELECT_MONO		BLACK
#define DEF_TEXT_SELECT_BD_COLOR	"1"
#define DEF_TEXT_SELECT_BD_MONO		"0"
#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
#define DEF_TEXT_SELECT_FG_MONO		WHITE
#define DEF_TEXT_SELECT_RELIEF		"flat"
#define DEF_TEXT_SET_GRID		"0"
#define DEF_TEXT_SPACING1		"0"
#define DEF_TEXT_SPACING2		"0"
#define DEF_TEXT_SPACING3		"0"
#define DEF_TEXT_STATE			"normal"
#define DEF_TEXT_TABS			""
#define DEF_TEXT_TAKE_FOCUS		(char *) NULL
#define DEF_TEXT_UNDO			"0"
#define DEF_TEXT_WIDTH			"80"
#define DEF_TEXT_WRAP			"char"
#define DEF_TEXT_XSCROLL_COMMAND	""
#define DEF_TEXT_YSCROLL_COMMAND	""

/*
 * Defaults for canvas text:
 */

#define DEF_CANVTEXT_FONT		"Helvetica 12"

/*
 * Defaults for toplevels (most of the defaults for frames also apply
 * to toplevels):
 */

#define DEF_TOPLEVEL_CLASS		"Toplevel"
#define DEF_TOPLEVEL_MENU		""
#define DEF_TOPLEVEL_SCREEN		""
#define DEF_TOPLEVEL_USE		""

#endif /* _TKMACDEFAULT */
                                  tkMacOSXInt.h                                                                                       0100644 0001750 0001750 00000012071 12526746632 034704  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk-private                                                             /*
 * tkMacOSXInt.h --
 *
 *	Declarations of Macintosh specific shared variables and procedures.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkMacOSXInt.h,v 1.3.2.23 2007/11/09 06:26:55 das Exp $
 */

#ifndef _TKMACINT
#define _TKMACINT

#ifndef _TKINT
#include "tkInt.h"
#endif

#define TextStyle MacTextStyle
#include <Carbon/Carbon.h>
#include <ApplicationServices/ApplicationServicesPriv.h>
#undef TextStyle

/*
 * Include platform specific public interfaces.
 */

#ifndef _TKMAC
#include "tkMacOSX.h"
#endif

struct TkWindowPrivate {
    TkWindow *winPtr;		/* Ptr to tk window or NULL if Pixmap */
    CGrafPtr grafPtr;
    CGContextRef context;
    ControlRef rootControl;
    int xOff;			/* X offset from toplevel window */
    int yOff;			/* Y offset from toplevel window */
    CGSize size;
    HIShapeRef visRgn;		/* Visible region of window */
    HIShapeRef aboveVisRgn;	/* Visible region of window & its children */
    CGRect drawRect;		/* Clipped drawing rect */
    int referenceCount;		/* Don't delete toplevel until children are
				 * gone. */
    struct TkWindowPrivate *toplevel;
				/* Pointer to the toplevel datastruct. */
    int flags;			/* Various state see defines below. */
};
typedef struct TkWindowPrivate MacDrawable;

/*
 * This list is used to keep track of toplevel windows that have a Mac
 * window attached. This is useful for several things, not the least
 * of which is maintaining floating windows.
 */

typedef struct TkMacOSXWindowList {
    struct TkMacOSXWindowList *nextPtr;
				/* The next window in the list. */
    TkWindow *winPtr;		/* This window */
} TkMacOSXWindowList;

/*
 * Defines use for the flags field of the MacDrawable data structure.
 */

#define TK_SCROLLBAR_GROW	0x01
#define TK_CLIP_INVALID		0x02
#define TK_HOST_EXISTS		0x04
#define TK_DRAWN_UNDER_MENU	0x08
#define TK_CLIPPED_DRAW		0x10
#define TK_IS_PIXMAP		0x20
#define TK_IS_BW_PIXMAP		0x40

/*
 * I am reserving TK_EMBEDDED = 0x100 in the MacDrawable flags
 * This is defined in tk.h. We need to duplicate the TK_EMBEDDED flag in the
 * TkWindow structure for the window, but in the MacWin. This way we can
 * still tell what the correct port is after the TKWindow structure has been
 * freed. This actually happens when you bind destroy of a toplevel to
 * Destroy of a child.
 */

/*
 * This structure is for handling Netscape-type in process
 * embedding where Tk does not control the top-level. It contains
 * various functions that are needed by Mac specific routines, like
 * TkMacOSXGetDrawablePort. The definitions of the function types
 * are in tkMacOSX.h.
 */

typedef struct {
    Tk_MacOSXEmbedRegisterWinProc *registerWinProc;
    Tk_MacOSXEmbedGetGrafPortProc *getPortProc;
    Tk_MacOSXEmbedMakeContainerExistProc *containerExistProc;
    Tk_MacOSXEmbedGetClipProc *getClipProc;
    Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc;
} TkMacOSXEmbedHandler;

MODULE_SCOPE TkMacOSXEmbedHandler *tkMacOSXEmbedHandler;

/*
 * Defines used for TkMacOSXInvalidateWindow
 */

#define TK_WINDOW_ONLY 0
#define TK_PARENT_WINDOW 1

/*
 * Accessor for the privatePtr flags field for the TK_HOST_EXISTS field
 */

#define TkMacOSXHostToplevelExists(tkwin) \
    (((TkWindow *) (tkwin))->privatePtr->toplevel->flags & TK_HOST_EXISTS)

/*
 * Defines use for the flags argument to TkGenWMConfigureEvent.
 */

#define TK_LOCATION_CHANGED	1
#define TK_SIZE_CHANGED		2
#define TK_BOTH_CHANGED		3

/*
 * Globals shared among TkAqua.
 */

MODULE_SCOPE MenuHandle tkCurrentAppleMenu; /* Handle to current Apple Menu */
MODULE_SCOPE MenuHandle tkAppleMenu;	/* Handle to default Apple Menu */
MODULE_SCOPE MenuHandle tkFileMenu;	/* Handles to menus */
MODULE_SCOPE MenuHandle tkEditMenu;	/* Handles to menus */
MODULE_SCOPE int tkPictureIsOpen;	/* If this is 1, we are drawing to a
					 * picture The clipping should then be
					 * done relative to the bounds of the
					 * picture rather than the window. As
					 * of OS X.0.4, something is seriously
					 * wrong: The clipping bounds only
					 * seem to work if the top,left values
					 * are 0,0 The destination rectangle
					 * for CopyBits should also have
					 * top,left values of 0,0
					 */
MODULE_SCOPE TkMacOSXWindowList *tkMacOSXWindowListPtr; /* List of toplevels */
MODULE_SCOPE Tcl_Encoding TkMacOSXCarbonEncoding;

/*
 * Prototypes of internal procs not in the stubs table.
 */

MODULE_SCOPE void TkMacOSXDefaultStartupScript(void);
#if 0
MODULE_SCOPE int XSetClipRectangles(Display *d, GC gc, int clip_x_origin,
	int clip_y_origin, XRectangle* rectangles, int n, int ordering);
#endif
MODULE_SCOPE void TkpClipDrawableToRect(Display *display, Drawable d, int x,
	int y, int width, int height);
MODULE_SCOPE void TkpRetainRegion(TkRegion r);
MODULE_SCOPE void TkpReleaseRegion(TkRegion r);

/*
 * Include the stubbed internal platform-specific API.
 */

#include "tkIntPlatDecls.h"

#endif /* _TKMACINT */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       tkMacOSXPort.h                                                                                      0100644 0001750 0001750 00000011213 10615001152 035045  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk-private                                                             /*
 * tkMacOSXPort.h --
 *
 *	This file is included by all of the Tk C files. It contains
 *	information that may be configuration-dependent, such as
 *	#includes for system include files and a few other things.
 *
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkMacOSXPort.h,v 1.3.2.7 2007/04/29 02:26:50 das Exp $
 */

#ifndef _TKMACPORT
#define _TKMACPORT

/*
 * Macro to use instead of "void" for arguments that must have
 * type "void *" in ANSI C; maps them to type "char *" in
 * non-ANSI systems. This macro may be used in some of the include
 * files below, which is why it is defined here.
 */

#ifndef VOID
#   ifdef __STDC__
#	define VOID void
#   else
#	define VOID char
#   endif
#endif

#include <stdio.h>
#include <ctype.h>
#include <fcntl.h>
#include <limits.h>
#include <math.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/file.h>
#ifdef HAVE_SYS_SELECT_H
#   include <sys/select.h>
#endif
#include <sys/stat.h>
#ifndef _TCL
#   include <tcl.h>
#endif
#if TIME_WITH_SYS_TIME
#   include <sys/time.h>
#   include <time.h>
#else
#   if HAVE_SYS_TIME_H
#	include <sys/time.h>
#   else
#	include <time.h>
#   endif
#endif
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/cursorfont.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include <X11/Xfuncproto.h>
#include <X11/Xutil.h>
#include "tkIntXlibDecls.h"

/*
 * The following macro defines the type of the mask arguments to
 * select:
 */

#ifndef NO_FD_SET
#   define SELECT_MASK fd_set
#else
#   ifndef _AIX
	typedef long fd_mask;
#   endif
#   if defined(_IBMR2)
#	define SELECT_MASK void
#   else
#	define SELECT_MASK int
#   endif
#endif

/*
 * The following macro defines the number of fd_masks in an fd_set:
 */

#ifndef FD_SETSIZE
#   ifdef OPEN_MAX
#	define FD_SETSIZE OPEN_MAX
#   else
#	define FD_SETSIZE 256
#   endif
#endif
#if !defined(howmany)
#   define howmany(x, y) (((x)+((y)-1))/(y))
#endif
#ifndef NFDBITS
#   define NFDBITS NBBY*sizeof(fd_mask)
#endif
#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)

/*
 * Define "NBBY" (number of bits per byte) if it's not already defined.
 */

#ifndef NBBY
#   define NBBY 8
#endif

/*
 * The following define causes Tk to use its internal keysym hash table
 */

#define REDO_KEYSYM_LOOKUP

/*
 * Defines for X functions that are used by Tk but are treated as
 * no-op functions on the Macintosh.
 */

#define XFlush(display)
#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
#define XGrabServer(display)
#define XNoOp(display) {display->request++;}
#define XUngrabServer(display)
#define XSynchronize(display, bool) {display->request++;}
#define XVisualIDFromVisual(visual) (visual->visualid)

/*
 * The following functions are not used on the Mac, so we stub them out.
 */

#define TkFreeWindowId(dispPtr,w)
#define TkInitXId(dispPtr)
#define TkpButtonSetDefaults(specPtr) {}
#define TkpCmapStressed(tkwin,colormap) (0)
#define TkpFreeColor(tkColPtr)
#define TkSetPixmapColormap(p,c) {}
#define TkpSync(display)

/*
 * The following macro returns the pixel value that corresponds to the
 * RGB values in the given XColor structure.
 */

#define PIXEL_MAGIC ((unsigned char) 0x69)
#define TkpGetPixel(p) ((((((PIXEL_MAGIC << 8) \
	| (((p)->red >> 8) & 0xff)) << 8) \
	| (((p)->green >> 8) & 0xff)) << 8) \
	| (((p)->blue >> 8) & 0xff))

/*
 * This macro stores a representation of the window handle in a string.
 * This should perhaps use the real size of an XID.
 */

#define TkpPrintWindowId(buf,w) \
	sprintf((buf), "0x%x", (unsigned int) (w))

/*
 * TkpScanWindowId is just an alias for Tcl_GetInt on Unix.
 */

#define TkpScanWindowId(i,s,wp) \
	Tcl_GetInt((i),(s),(int *) (wp))

/*
 * Turn off Tk double-buffering as Aqua windows are already double-buffered.
 */

#define TK_NO_DOUBLE_BUFFERING 1

/*
 * Magic pixel code values for system colors.
 *
 * NOTE: values must be kept in sync with indices into the
 *	 systemColorMap array in tkMacOSXColor.c !
 */

#define TRANSPARENT_PIXEL		30
#define HIGHLIGHT_PIXEL			31
#define HIGHLIGHT_SECONDARY_PIXEL	32
#define HIGHLIGHT_TEXT_PIXEL		33
#define HIGHLIGHT_ALTERNATE_PIXEL	34
#define CONTROL_TEXT_PIXEL		35
#define CONTROL_BODY_PIXEL		37
#define CONTROL_FRAME_PIXEL		39
#define WINDOW_BODY_PIXEL		41
#define MENU_ACTIVE_PIXEL		43
#define MENU_ACTIVE_TEXT_PIXEL		45
#define MENU_BACKGROUND_PIXEL		47
#define MENU_DISABLED_PIXEL		49
#define MENU_TEXT_PIXEL			51
#define APPEARANCE_PIXEL		52

#endif /* _TKMACPORT */
                                                                                                                                                                                                                                                                                                                                                                                     tkPort.h                                                                                            0100644 0001750 0001750 00000001423 12566232527 034057  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk-private                                                             /*
 * tkPort.h --
 *
 *	This header file handles porting issues that occur because of
 *	differences between systems.  It reads in platform specific
 *	portability files.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkPort.h,v 1.3.2.1 2004/01/01 00:34:56 das Exp $
 */

#ifndef _TKPORT
#define _TKPORT

#ifndef _TK
#include "tk.h"
#endif
#ifndef _TCL
#include "tcl.h"
#endif

#if defined(__WIN32__) || defined(_WIN32)
#   include "tkWinPort.h"
#else
#   if defined(MAC_TCL)
#	include "tkMacPort.h"
#   elif defined(MAC_OSX_TK)
#	include "tkMacOSXPort.h"
#   else
#	include "tkUnixPort.h"
#   endif
#endif

#endif /* _TKPORT */
                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers/tk.h0100644 0001750 0001750 00000156771 12526746632 031227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * tk.h --
 *
 *	Declarations for Tk-related things that are visible
 *	outside of the Tk module itself.
 *
 * Copyright (c) 1989-1994 The Regents of the University of California.
 * Copyright (c) 1994 The Australian National University.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 Ajuba Solutions.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tk.h,v 1.74.2.22 2008/04/07 19:17:54 dgp Exp $
 */

#ifndef _TK
#define _TK

#ifndef _TCL
#include <tcl.h>
#if (TCL_MAJOR_VERSION != 8) || (TCL_MINOR_VERSION != 4)
#	error Tk 8.4 must be compiled with tcl.h from Tcl 8.4
#endif
#endif

/*
 * For C++ compilers, use extern "C"
 */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * When version numbers change here, you must also go into the following files
 * and update the version numbers:
 *
 * library/tk.tcl	(only if Major.minor changes, not patchlevel)
 * unix/configure.in	(2 LOC Major, 2 LOC minor, 1 LOC patch)
 * win/configure.in	(as above)
 * win/makefile.vc	(not patchlevel)
 * README		(sections 0 and 1)
 * mac/README		(not patchlevel)
 * win/README		(not patchlevel)
 * unix/README		(not patchlevel)
 * unix/tk.spec		(3 LOC Major/Minor, 2 LOC patch)
 * win/tcl.m4		(not patchlevel)
 *
 * You may also need to update some of these files when the numbers change
 * for the version of Tcl that this release of Tk is compiled against.
 */

#define TK_MAJOR_VERSION   8
#define TK_MINOR_VERSION   4
#define TK_RELEASE_LEVEL   TCL_FINAL_RELEASE
#define TK_RELEASE_SERIAL  19

#define TK_VERSION	"8.4"
#define TK_PATCH_LEVEL	"8.4.19"

/* 
 * A special definition used to allow this header file to be included
 * from windows or mac resource files so that they can obtain version
 * information.  RC_INVOKED is defined by default by the windows RC tool
 * and manually set for macintosh.
 *
 * Resource compilers don't like all the C stuff, like typedefs and
 * procedure declarations, that occur below, so block them out.
 */
    
#ifndef RC_INVOKED
    
#ifndef _XLIB_H
#   if defined (MAC_TCL)
#	include <Xlib.h>
#	include <X.h>
#   elif defined(MAC_OSX_TK)
#	include <X11/Xlib.h>
#	include <X11/X.h>
#   else
#	include <X11/Xlib.h>
#   endif
#endif
#ifdef __STDC__
#   include <stddef.h>
#endif

#ifdef BUILD_tk
# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * Decide whether or not to use input methods.
 */

#ifdef XNQueryInputStyle
#define TK_USE_INPUT_METHODS
#endif

/*
 * Dummy types that are used by clients:
 */

typedef struct Tk_BindingTable_ *Tk_BindingTable;
typedef struct Tk_Canvas_ *Tk_Canvas;
typedef struct Tk_Cursor_ *Tk_Cursor;
typedef struct Tk_ErrorHandler_ *Tk_ErrorHandler;
typedef struct Tk_Font_ *Tk_Font;
typedef struct Tk_Image__ *Tk_Image;
typedef struct Tk_ImageMaster_ *Tk_ImageMaster;
typedef struct Tk_OptionTable_ *Tk_OptionTable;
typedef struct Tk_PostscriptInfo_ *Tk_PostscriptInfo;
typedef struct Tk_TextLayout_ *Tk_TextLayout;
typedef struct Tk_Window_ *Tk_Window;
typedef struct Tk_3DBorder_ *Tk_3DBorder;
typedef struct Tk_Style_ *Tk_Style;
typedef struct Tk_StyleEngine_ *Tk_StyleEngine;
typedef struct Tk_StyledElement_ *Tk_StyledElement;

/*
 * Additional types exported to clients.
 */

typedef CONST char *Tk_Uid;

/*
 * The enum below defines the valid types for Tk configuration options
 * as implemented by Tk_InitOptions, Tk_SetOptions, etc.
 */

typedef enum {
    TK_OPTION_BOOLEAN,
    TK_OPTION_INT,
    TK_OPTION_DOUBLE,
    TK_OPTION_STRING,
    TK_OPTION_STRING_TABLE,
    TK_OPTION_COLOR,
    TK_OPTION_FONT,
    TK_OPTION_BITMAP,
    TK_OPTION_BORDER,
    TK_OPTION_RELIEF,
    TK_OPTION_CURSOR,
    TK_OPTION_JUSTIFY,
    TK_OPTION_ANCHOR,
    TK_OPTION_SYNONYM,
    TK_OPTION_PIXELS,
    TK_OPTION_WINDOW,
    TK_OPTION_END,
    TK_OPTION_CUSTOM,
    TK_OPTION_STYLE
} Tk_OptionType;

/*
 * Structures of the following type are used by widgets to specify
 * their configuration options.  Typically each widget has a static
 * array of these structures, where each element of the array describes
 * a single configuration option.  The array is passed to
 * Tk_CreateOptionTable.
 */

typedef struct Tk_OptionSpec {
    Tk_OptionType type;		/* Type of option, such as TK_OPTION_COLOR; 
				 * see definitions above. Last option in
				 * table must have type TK_OPTION_END. */
    char *optionName;		/* Name used to specify option in Tcl	
				 * commands. */
    char *dbName;		/* Name for option in option database. */
    char *dbClass;		/* Class for option in database. */
    char *defValue;		/* Default value for option if not specified
				 * in command line, the option database,
				 * or the system. */
    int objOffset;		/* Where in record to store a Tcl_Obj * that
				 * holds the value of this option, specified
				 * as an offset in bytes from the start of
				 * the record. Use the Tk_Offset macro to
				 * generate values for this.  -1 means don't
				 * store the Tcl_Obj in the record. */
    int internalOffset;		/* Where in record to store the internal
				 * representation of the value of this option,
				 * such as an int or XColor *.  This field
				 * is specified as an offset in bytes
				 * from the start of the record. Use the
				 * Tk_Offset macro to generate values for it.
				 * -1 means don't store the internal
				 * representation in the record. */
    int flags;			/* Any combination of the values defined
				 * below. */
    ClientData clientData;	/* An alternate place to put option-specific
    				 * data. Used for the monochrome default value
				 * for colors, etc. */
    int typeMask;		/* An arbitrary bit mask defined by the
				 * class manager; typically bits correspond
				 * to certain kinds of options such as all
				 * those that require a redisplay when they
				 * change.  Tk_SetOptions returns the bit-wise
				 * OR of the typeMasks of all options that
				 * were changed. */
} Tk_OptionSpec;

/*
 * Flag values for Tk_OptionSpec structures.  These flags are shared by
 * Tk_ConfigSpec structures, so be sure to coordinate any changes
 * carefully.
 */

#define TK_OPTION_NULL_OK		(1 << 0)
#define TK_OPTION_DONT_SET_DEFAULT	(1 << 3)

/*
 * The following structure and function types are used by TK_OPTION_CUSTOM
 * options; the structure holds pointers to the functions needed by the Tk
 * option config code to handle a custom option.
 */

typedef int (Tk_CustomOptionSetProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj **value, char *widgRec,
	int offset, char *saveInternalPtr, int flags));
typedef Tcl_Obj *(Tk_CustomOptionGetProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *widgRec, int offset));
typedef void (Tk_CustomOptionRestoreProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *internalPtr, char *saveInternalPtr));
typedef void (Tk_CustomOptionFreeProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *internalPtr));
    
typedef struct Tk_ObjCustomOption {
    char *name;				/* Name of the custom option. */
    Tk_CustomOptionSetProc *setProc;	/* Function to use to set a record's
					 * option value from a Tcl_Obj */
    Tk_CustomOptionGetProc *getProc;	/* Function to use to get a Tcl_Obj
					 * representation from an internal
					 * representation of an option. */
    Tk_CustomOptionRestoreProc *restoreProc;	/* Function to use to restore a
						 * saved value for the internal
						 * representation. */
    Tk_CustomOptionFreeProc *freeProc;	/* Function to use to free the internal
					 * representation of an option. */
    ClientData clientData;		/* Arbitrary one-word value passed to
					 * the handling procs. */
} Tk_ObjCustomOption;


/*
 * Macro to use to fill in "offset" fields of the Tk_OptionSpec.
 * struct.  Computes number of bytes from beginning of structure
 * to a given field.
 */

#ifdef offsetof
#define Tk_Offset(type, field) ((int) offsetof(type, field))
#else
#define Tk_Offset(type, field) ((int) ((char *) &((type *) 0)->field))
#endif

/*
 * The following two structures are used for error handling.  When
 * configuration options are being modified, the old values are
 * saved in a Tk_SavedOptions structure.  If an error occurs, then the
 * contents of the structure can be used to restore all of the old
 * values.  The contents of this structure are for the private use
 * Tk.  No-one outside Tk should ever read or write any of the fields
 * of these structures.
 */

typedef struct Tk_SavedOption {
    struct TkOption *optionPtr;		/* Points to information that describes
					 * the option. */
    Tcl_Obj *valuePtr;			/* The old value of the option, in
					 * the form of a Tcl object; may be
					 * NULL if the value wasn't saved as
					 * an object. */
    double internalForm;		/* The old value of the option, in
					 * some internal representation such
					 * as an int or (XColor *).  Valid
					 * only if optionPtr->specPtr->objOffset
					 * is < 0.  The space must be large
					 * enough to accommodate a double, a
					 * long, or a pointer; right now it
					 * looks like a double is big
					 * enough.  Also, using a double
					 * guarantees that the field is
					 * properly aligned for storing large
					 * values. */
} Tk_SavedOption;

#ifdef TCL_MEM_DEBUG
#   define TK_NUM_SAVED_OPTIONS 2
#else
#   define TK_NUM_SAVED_OPTIONS 20
#endif

typedef struct Tk_SavedOptions {
    char *recordPtr;			/* The data structure in which to
					 * restore configuration options. */
    Tk_Window tkwin;			/* Window associated with recordPtr;
					 * needed to restore certain options. */
    int numItems;			/* The number of valid items in 
					 * items field. */
    Tk_SavedOption items[TK_NUM_SAVED_OPTIONS];
					/* Items used to hold old values. */
    struct Tk_SavedOptions *nextPtr;	/* Points to next structure in list;	
					 * needed if too many options changed
					 * to hold all the old values in a
					 * single structure.  NULL means no
					 * more structures. */
} Tk_SavedOptions;

/*
 * Structure used to describe application-specific configuration
 * options:  indicates procedures to call to parse an option and
 * to return a text string describing an option. THESE ARE
 * DEPRECATED; PLEASE USE THE NEW STRUCTURES LISTED ABOVE.
 */

/*
 * This is a temporary flag used while tkObjConfig and new widgets
 * are in development.
 */

#ifndef __NO_OLD_CONFIG

typedef int (Tk_OptionParseProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, CONST84 char *value, char *widgRec,
	int offset));
typedef char *(Tk_OptionPrintProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *widgRec, int offset,
	Tcl_FreeProc **freeProcPtr));

typedef struct Tk_CustomOption {
    Tk_OptionParseProc *parseProc;	/* Procedure to call to parse an
					 * option and store it in converted
					 * form. */
    Tk_OptionPrintProc *printProc;	/* Procedure to return a printable
					 * string describing an existing
					 * option. */
    ClientData clientData;		/* Arbitrary one-word value used by
					 * option parser:  passed to
					 * parseProc and printProc. */
} Tk_CustomOption;

/*
 * Structure used to specify information for Tk_ConfigureWidget.  Each
 * structure gives complete information for one option, including
 * how the option is specified on the command line, where it appears
 * in the option database, etc.
 */

typedef struct Tk_ConfigSpec {
    int type;			/* Type of option, such as TK_CONFIG_COLOR;
				 * see definitions below.  Last option in
				 * table must have type TK_CONFIG_END. */
    char *argvName;		/* Switch used to specify option in argv.
				 * NULL means this spec is part of a group. */
    Tk_Uid dbName;		/* Name for option in option database. */
    Tk_Uid dbClass;		/* Class for option in database. */
    Tk_Uid defValue;		/* Default value for option if not
				 * specified in command line or database. */
    int offset;			/* Where in widget record to store value;
				 * use Tk_Offset macro to generate values
				 * for this. */
    int specFlags;		/* Any combination of the values defined
				 * below;  other bits are used internally
				 * by tkConfig.c. */
    Tk_CustomOption *customPtr;	/* If type is TK_CONFIG_CUSTOM then this is
				 * a pointer to info about how to parse and
				 * print the option.  Otherwise it is
				 * irrelevant. */
} Tk_ConfigSpec;

/*
 * Type values for Tk_ConfigSpec structures.  See the user
 * documentation for details.
 */

typedef enum {
    TK_CONFIG_BOOLEAN, TK_CONFIG_INT, TK_CONFIG_DOUBLE, TK_CONFIG_STRING,
    TK_CONFIG_UID, TK_CONFIG_COLOR, TK_CONFIG_FONT, TK_CONFIG_BITMAP,
    TK_CONFIG_BORDER, TK_CONFIG_RELIEF, TK_CONFIG_CURSOR, 
    TK_CONFIG_ACTIVE_CURSOR, TK_CONFIG_JUSTIFY, TK_CONFIG_ANCHOR, 
    TK_CONFIG_SYNONYM, TK_CONFIG_CAP_STYLE, TK_CONFIG_JOIN_STYLE,
    TK_CONFIG_PIXELS, TK_CONFIG_MM, TK_CONFIG_WINDOW, TK_CONFIG_CUSTOM, 
    TK_CONFIG_END
} Tk_ConfigTypes;

/*
 * Possible values for flags argument to Tk_ConfigureWidget:
 */

#define TK_CONFIG_ARGV_ONLY	1
#define TK_CONFIG_OBJS		0x80

/*
 * Possible flag values for Tk_ConfigSpec structures.  Any bits at
 * or above TK_CONFIG_USER_BIT may be used by clients for selecting
 * certain entries.  Before changing any values here, coordinate with
 * tkOldConfig.c (internal-use-only flags are defined there).
 */

#define TK_CONFIG_NULL_OK		(1 << 0)
#define TK_CONFIG_COLOR_ONLY		(1 << 1)
#define TK_CONFIG_MONO_ONLY		(1 << 2)
#define TK_CONFIG_DONT_SET_DEFAULT	(1 << 3)
#define TK_CONFIG_OPTION_SPECIFIED      (1 << 4)
#define TK_CONFIG_USER_BIT		0x100
#endif /* __NO_OLD_CONFIG */

/*
 * Structure used to specify how to handle argv options.
 */

typedef struct {
    char *key;		/* The key string that flags the option in the
			 * argv array. */
    int type;		/* Indicates option type;  see below. */
    char *src;		/* Value to be used in setting dst;  usage
			 * depends on type. */
    char *dst;		/* Address of value to be modified;  usage
			 * depends on type. */
    char *help;		/* Documentation message describing this option. */
} Tk_ArgvInfo;

/*
 * Legal values for the type field of a Tk_ArgvInfo: see the user
 * documentation for details.
 */

#define TK_ARGV_CONSTANT		15
#define TK_ARGV_INT			16
#define TK_ARGV_STRING			17
#define TK_ARGV_UID			18
#define TK_ARGV_REST			19
#define TK_ARGV_FLOAT			20
#define TK_ARGV_FUNC			21
#define TK_ARGV_GENFUNC			22
#define TK_ARGV_HELP			23
#define TK_ARGV_CONST_OPTION		24
#define TK_ARGV_OPTION_VALUE		25
#define TK_ARGV_OPTION_NAME_VALUE	26
#define TK_ARGV_END			27

/*
 * Flag bits for passing to Tk_ParseArgv:
 */

#define TK_ARGV_NO_DEFAULTS		0x1
#define TK_ARGV_NO_LEFTOVERS		0x2
#define TK_ARGV_NO_ABBREV		0x4
#define TK_ARGV_DONT_SKIP_FIRST_ARG	0x8

/*
 * Enumerated type for describing actions to be taken in response
 * to a restrictProc established by Tk_RestrictEvents.
 */

typedef enum {
    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT
} Tk_RestrictAction;

/*
 * Priority levels to pass to Tk_AddOption:
 */

#define TK_WIDGET_DEFAULT_PRIO	20
#define TK_STARTUP_FILE_PRIO	40
#define TK_USER_DEFAULT_PRIO	60
#define TK_INTERACTIVE_PRIO	80
#define TK_MAX_PRIO		100

/*
 * Relief values returned by Tk_GetRelief:
 */

#define TK_RELIEF_NULL		-1
#define TK_RELIEF_FLAT		0
#define TK_RELIEF_GROOVE	1
#define TK_RELIEF_RAISED	2
#define TK_RELIEF_RIDGE		3
#define TK_RELIEF_SOLID		4
#define TK_RELIEF_SUNKEN	5

/*
 * "Which" argument values for Tk_3DBorderGC:
 */

#define TK_3D_FLAT_GC		1
#define TK_3D_LIGHT_GC		2
#define TK_3D_DARK_GC		3

/*
 * Special EnterNotify/LeaveNotify "mode" for use in events
 * generated by tkShare.c.  Pick a high enough value that it's
 * unlikely to conflict with existing values (like NotifyNormal)
 * or any new values defined in the future.
 */

#define TK_NOTIFY_SHARE		20

/*
 * Enumerated type for describing a point by which to anchor something:
 */

typedef enum {
    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,
    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,
    TK_ANCHOR_CENTER
} Tk_Anchor;

/*
 * Enumerated type for describing a style of justification:
 */

typedef enum {
    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER
} Tk_Justify;

/*
 * The following structure is used by Tk_GetFontMetrics() to return
 * information about the properties of a Tk_Font.  
 */

typedef struct Tk_FontMetrics {
    int ascent;			/* The amount in pixels that the tallest
				 * letter sticks up above the baseline, plus
				 * any extra blank space added by the designer
				 * of the font. */
    int descent;		/* The largest amount in pixels that any
				 * letter sticks below the baseline, plus any
				 * extra blank space added by the designer of
				 * the font. */
    int linespace;		/* The sum of the ascent and descent.  How
				 * far apart two lines of text in the same
				 * font should be placed so that none of the
				 * characters in one line overlap any of the
				 * characters in the other line. */
} Tk_FontMetrics;

/*
 * Flags passed to Tk_MeasureChars:
 */

#define TK_WHOLE_WORDS		1
#define TK_AT_LEAST_ONE		2
#define TK_PARTIAL_OK		4

/*
 * Flags passed to Tk_ComputeTextLayout:
 */

#define TK_IGNORE_TABS		8
#define TK_IGNORE_NEWLINES	16

/*
 * Widget class procedures used to implement platform specific widget
 * behavior.
 */

typedef Window (Tk_ClassCreateProc) _ANSI_ARGS_((Tk_Window tkwin,
	Window parent, ClientData instanceData));
typedef void (Tk_ClassWorldChangedProc) _ANSI_ARGS_((ClientData instanceData));
typedef void (Tk_ClassModalProc) _ANSI_ARGS_((Tk_Window tkwin,
	XEvent *eventPtr));

typedef struct Tk_ClassProcs {
    unsigned int size;
    Tk_ClassWorldChangedProc *worldChangedProc;
				/* Procedure to invoke when the widget needs to
				 * respond in some way to a change in the
				 * world (font changes, etc.) */
    Tk_ClassCreateProc *createProc;
				/* Procedure to invoke when the
				 * platform-dependent window needs to be
                                 * created. */
    Tk_ClassModalProc *modalProc;
				/* Procedure to invoke after all bindings on a
				 * widget have been triggered in order to
				 * handle a modal loop. */
} Tk_ClassProcs;

/*
 * Simple accessor for Tk_ClassProcs structure.  Checks that the structure
 * is not NULL, then checks the size field and returns either the requested
 * field, if present, or NULL if the structure is too small to have the field
 * (or NULL if the structure is NULL).
 *
 * A more general version of this function may be useful if other
 * size-versioned structure pop up in the future:
 *
 *	#define Tk_GetField(name, who, which) \
 *	    (((who) == NULL) ? NULL :
 *	    (((who)->size <= Tk_Offset(name, which)) ? NULL :(name)->which))
 */

#define Tk_GetClassProc(procs, which) \
    (((procs) == NULL) ? NULL : \
    (((procs)->size <= Tk_Offset(Tk_ClassProcs, which)) ? NULL:(procs)->which))

/*
 * Each geometry manager (the packer, the placer, etc.) is represented
 * by a structure of the following form, which indicates procedures
 * to invoke in the geometry manager to carry out certain functions.
 */

typedef void (Tk_GeomRequestProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin));
typedef void (Tk_GeomLostSlaveProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin));

typedef struct Tk_GeomMgr {
    char *name;			/* Name of the geometry manager (command
				 * used to invoke it, or name of widget
				 * class that allows embedded widgets). */
    Tk_GeomRequestProc *requestProc;
				/* Procedure to invoke when a slave's
				 * requested geometry changes. */
    Tk_GeomLostSlaveProc *lostSlaveProc;
				/* Procedure to invoke when a slave is
				 * taken away from one geometry manager
				 * by another.  NULL means geometry manager
				 * doesn't care when slaves are lost. */
} Tk_GeomMgr;

/*
 * Result values returned by Tk_GetScrollInfo:
 */

#define TK_SCROLL_MOVETO	1
#define TK_SCROLL_PAGES		2
#define TK_SCROLL_UNITS		3
#define TK_SCROLL_ERROR		4

/*
 *---------------------------------------------------------------------------
 *
 * Extensions to the X event set
 *
 *---------------------------------------------------------------------------
 */

#define VirtualEvent	    (MappingNotify + 1)
#define ActivateNotify	    (MappingNotify + 2)
#define DeactivateNotify    (MappingNotify + 3)
#define MouseWheelEvent     (MappingNotify + 4)
#define TK_LASTEVENT	    (MappingNotify + 5)

#define MouseWheelMask	    (1L << 28)
#define ActivateMask	    (1L << 29)
#define VirtualEventMask    (1L << 30)

/*
 * A virtual event shares most of its fields with the XKeyEvent and
 * XButtonEvent structures.  99% of the time a virtual event will be
 * an abstraction of a key or button event, so this structure provides
 * the most information to the user.  The only difference is the changing
 * of the detail field for a virtual event so that it holds the name of the
 * virtual event being triggered.
 */

typedef struct {
    int type;
    unsigned long serial;   /* # of last request processed by server */
    Bool send_event;	    /* True if this came from a SendEvent request */
    Display *display;	    /* Display the event was read from */
    Window event;	    /* Window on which event was requested. */
    Window root;	    /* root window that the event occured on */
    Window subwindow;	    /* child window */
    Time time;		    /* milliseconds */
    int x, y;		    /* pointer x, y coordinates in event window */
    int x_root, y_root;	    /* coordinates relative to root */
    unsigned int state;	    /* key or button mask */
    Tk_Uid name;	    /* Name of virtual event. */
    Bool same_screen;	    /* same screen flag */
} XVirtualEvent;

typedef struct {
    int type;
    unsigned long serial;   /* # of last request processed by server */
    Bool send_event;	    /* True if this came from a SendEvent request */
    Display *display;	    /* Display the event was read from */
    Window window;	    /* Window in which event occurred. */
} XActivateDeactivateEvent;
typedef XActivateDeactivateEvent XActivateEvent;
typedef XActivateDeactivateEvent XDeactivateEvent;

/*
 *--------------------------------------------------------------
 *
 * Macros for querying Tk_Window structures.  See the
 * manual entries for documentation.
 *
 *--------------------------------------------------------------
 */

#define Tk_Display(tkwin)		(((Tk_FakeWin *) (tkwin))->display)
#define Tk_ScreenNumber(tkwin)		(((Tk_FakeWin *) (tkwin))->screenNum)
#define Tk_Screen(tkwin)		(ScreenOfDisplay(Tk_Display(tkwin), \
	Tk_ScreenNumber(tkwin)))
#define Tk_Depth(tkwin)			(((Tk_FakeWin *) (tkwin))->depth)
#define Tk_Visual(tkwin)		(((Tk_FakeWin *) (tkwin))->visual)
#define Tk_WindowId(tkwin)		(((Tk_FakeWin *) (tkwin))->window)
#define Tk_PathName(tkwin) 		(((Tk_FakeWin *) (tkwin))->pathName)
#define Tk_Name(tkwin)			(((Tk_FakeWin *) (tkwin))->nameUid)
#define Tk_Class(tkwin) 		(((Tk_FakeWin *) (tkwin))->classUid)
#define Tk_X(tkwin)			(((Tk_FakeWin *) (tkwin))->changes.x)
#define Tk_Y(tkwin)			(((Tk_FakeWin *) (tkwin))->changes.y)
#define Tk_Width(tkwin)			(((Tk_FakeWin *) (tkwin))->changes.width)
#define Tk_Height(tkwin) \
    (((Tk_FakeWin *) (tkwin))->changes.height)
#define Tk_Changes(tkwin)		(&((Tk_FakeWin *) (tkwin))->changes)
#define Tk_Attributes(tkwin)		(&((Tk_FakeWin *) (tkwin))->atts)
#define Tk_IsEmbedded(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_EMBEDDED)
#define Tk_IsContainer(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_CONTAINER)
#define Tk_IsMapped(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_MAPPED)
#define Tk_IsTopLevel(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_LEVEL)
#define Tk_HasWrapper(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_HAS_WRAPPER)
#define Tk_WinManaged(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_WIN_MANAGED)
#define Tk_TopWinHierarchy(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_HIERARCHY)
#define Tk_ReqWidth(tkwin)		(((Tk_FakeWin *) (tkwin))->reqWidth)
#define Tk_ReqHeight(tkwin)		(((Tk_FakeWin *) (tkwin))->reqHeight)
/* Tk_InternalBorderWidth is deprecated */
#define Tk_InternalBorderWidth(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)
#define Tk_InternalBorderLeft(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)
#define Tk_InternalBorderRight(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderRight)
#define Tk_InternalBorderTop(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderTop)
#define Tk_InternalBorderBottom(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderBottom)
#define Tk_MinReqWidth(tkwin)		(((Tk_FakeWin *) (tkwin))->minReqWidth)
#define Tk_MinReqHeight(tkwin)		(((Tk_FakeWin *) (tkwin))->minReqHeight)
#define Tk_Parent(tkwin)		(((Tk_FakeWin *) (tkwin))->parentPtr)
#define Tk_Colormap(tkwin)		(((Tk_FakeWin *) (tkwin))->atts.colormap)

/*
 * The structure below is needed by the macros above so that they can
 * access the fields of a Tk_Window.  The fields not needed by the macros
 * are declared as "dummyX".  The structure has its own type in order to
 * prevent applications from accessing Tk_Window fields except using
 * official macros.  WARNING!! The structure definition must be kept
 * consistent with the TkWindow structure in tkInt.h.  If you change one,
 * then change the other.  See the declaration in tkInt.h for
 * documentation on what the fields are used for internally.
 */

typedef struct Tk_FakeWin {
    Display *display;
    char *dummy1;		/* dispPtr */
    int screenNum;
    Visual *visual;
    int depth;
    Window window;
    char *dummy2;		/* childList */
    char *dummy3;		/* lastChildPtr */
    Tk_Window parentPtr;	/* parentPtr */
    char *dummy4;		/* nextPtr */
    char *dummy5;		/* mainPtr */
    char *pathName;
    Tk_Uid nameUid;
    Tk_Uid classUid;
    XWindowChanges changes;
    unsigned int dummy6;	/* dirtyChanges */
    XSetWindowAttributes atts;
    unsigned long dummy7;	/* dirtyAtts */
    unsigned int flags;
    char *dummy8;		/* handlerList */
#ifdef TK_USE_INPUT_METHODS
    XIC dummy9;			/* inputContext */
#endif /* TK_USE_INPUT_METHODS */
    ClientData *dummy10;	/* tagPtr */
    int dummy11;		/* numTags */
    int dummy12;		/* optionLevel */
    char *dummy13;		/* selHandlerList */
    char *dummy14;		/* geomMgrPtr */
    ClientData dummy15;		/* geomData */
    int reqWidth, reqHeight;
    int internalBorderLeft;
    char *dummy16;		/* wmInfoPtr */
    char *dummy17;		/* classProcPtr */
    ClientData dummy18;		/* instanceData */
    char *dummy19;		/* privatePtr */
    int internalBorderRight;
    int internalBorderTop;
    int internalBorderBottom;
    int minReqWidth;
    int minReqHeight;
} Tk_FakeWin;

/*
 * Flag values for TkWindow (and Tk_FakeWin) structures are:
 *
 * TK_MAPPED:			1 means window is currently mapped,
 *				0 means unmapped.
 * TK_TOP_LEVEL:		1 means this is a top-level widget.
 * TK_ALREADY_DEAD:		1 means the window is in the process of
 *				being destroyed already.
 * TK_NEED_CONFIG_NOTIFY:	1 means that the window has been reconfigured
 *				before it was made to exist.  At the time of
 *				making it exist a ConfigureNotify event needs
 *				to be generated.
 * TK_GRAB_FLAG:		Used to manage grabs.  See tkGrab.c for
 *				details.
 * TK_CHECKED_IC:		1 means we've already tried to get an input
 *				context for this window;  if the ic field
 *				is NULL it means that there isn't a context
 *				for the field.
 * TK_DONT_DESTROY_WINDOW:	1 means that Tk_DestroyWindow should not
 *				invoke XDestroyWindow to destroy this widget's
 *				X window.  The flag is set when the window
 *				has already been destroyed elsewhere (e.g.
 *				by another application) or when it will be
 *				destroyed later (e.g. by destroying its
 *				parent).
 * TK_WM_COLORMAP_WINDOW:	1 means that this window has at some time
 *				appeared in the WM_COLORMAP_WINDOWS property
 *				for its toplevel, so we have to remove it
 *				from that property if the window is
 *				deleted and the toplevel isn't.
 * TK_EMBEDDED:			1 means that this window (which must be a
 *				toplevel) is not a free-standing window but
 *				rather is embedded in some other application.
 * TK_CONTAINER:		1 means that this window is a container, and
 *				that some other application (either in
 *				this process or elsewhere) may be
 *				embedding itself inside the window.
 * TK_BOTH_HALVES:		1 means that this window is used for
 *				application embedding (either as
 *				container or embedded application), and
 *				both the containing and embedded halves
 *				are associated with windows in this
 *				particular process.
 * TK_DEFER_MODAL:		1 means that this window has deferred a modal
 *				loop until all of the bindings for the current
 *				event have been invoked.
 * TK_WRAPPER:			1 means that this window is the extra
 *				wrapper window created around a toplevel
 *				to hold the menubar under Unix.  See
 *				tkUnixWm.c for more information.
 * TK_REPARENTED:		1 means that this window has been reparented
 *				so that as far as the window system is
 *				concerned it isn't a child of its Tk
 *				parent.  Initially this is used only for
 *				special Unix menubar windows.
 * TK_ANONYMOUS_WINDOW:		1 means that this window has no name, and is
 *				thus not accessible from Tk.
 * TK_HAS_WRAPPER		1 means that this window has a wrapper window
 * TK_WIN_MANAGED		1 means that this window is a child of the
 *				root window, and is managed by the window
 *				manager.
 * TK_TOP_HIERARCHY		1 means this window is at the top of a
 *				physical window hierarchy within this
 *				process, i.e. the window's parent
 *				either doesn't exist or is not owned by
 *				this Tk application.
 * TK_PROP_PROPCHANGE		1 means that PropertyNotify events in
 *				this window's children should propagate
 *				up to this window.
 */


#define TK_MAPPED		1
#define TK_TOP_LEVEL		2
#define TK_ALREADY_DEAD		4
#define TK_NEED_CONFIG_NOTIFY	8
#define TK_GRAB_FLAG		0x10
#define TK_CHECKED_IC		0x20
#define TK_DONT_DESTROY_WINDOW	0x40
#define TK_WM_COLORMAP_WINDOW	0x80
#define TK_EMBEDDED		0x100
#define TK_CONTAINER		0x200
#define TK_BOTH_HALVES		0x400
#define TK_DEFER_MODAL		0x800
#define TK_WRAPPER		0x1000
#define TK_REPARENTED		0x2000
#define TK_ANONYMOUS_WINDOW	0x4000
#define TK_HAS_WRAPPER		0x8000
#define TK_WIN_MANAGED		0x10000
#define TK_TOP_HIERARCHY	0x20000
#define TK_PROP_PROPCHANGE	0x40000

/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for defining new canvas
 * items:
 *
 *--------------------------------------------------------------
 */

typedef enum {
    TK_STATE_NULL = -1, TK_STATE_ACTIVE, TK_STATE_DISABLED,
    TK_STATE_NORMAL, TK_STATE_HIDDEN
} Tk_State;

typedef struct Tk_SmoothMethod {
    char *name;
    int (*coordProc) _ANSI_ARGS_((Tk_Canvas canvas,
		double *pointPtr, int numPoints, int numSteps,
		XPoint xPoints[], double dblPoints[]));
    void (*postscriptProc) _ANSI_ARGS_((Tcl_Interp *interp,
		Tk_Canvas canvas, double *coordPtr,
		int numPoints, int numSteps));
} Tk_SmoothMethod;

/*
 * For each item in a canvas widget there exists one record with
 * the following structure.  Each actual item is represented by
 * a record with the following stuff at its beginning, plus additional
 * type-specific stuff after that.
 */

#define TK_TAG_SPACE 3

typedef struct Tk_Item  {
    int id;				/* Unique identifier for this item
					 * (also serves as first tag for
					 * item). */
    struct Tk_Item *nextPtr;		/* Next in display list of all
					 * items in this canvas.  Later items
					 * in list are drawn on top of earlier
					 * ones. */
    Tk_Uid staticTagSpace[TK_TAG_SPACE];/* Built-in space for limited # of
					 * tags. */
    Tk_Uid *tagPtr;			/* Pointer to array of tags.  Usually
					 * points to staticTagSpace, but
					 * may point to malloc-ed space if
					 * there are lots of tags. */
    int tagSpace;			/* Total amount of tag space available
					 * at tagPtr. */
    int numTags;			/* Number of tag slots actually used
					 * at *tagPtr. */
    struct Tk_ItemType *typePtr;	/* Table of procedures that implement
					 * this type of item. */
    int x1, y1, x2, y2;			/* Bounding box for item, in integer
					 * canvas units. Set by item-specific
					 * code and guaranteed to contain every
					 * pixel drawn in item.  Item area
					 * includes x1 and y1 but not x2
					 * and y2. */
    struct Tk_Item *prevPtr;		/* Previous in display list of all
					 * items in this canvas. Later items
					 * in list are drawn just below earlier
					 * ones. */
    Tk_State state;			/* state of item */
    char *reserved1;			/* reserved for future use */
    int redraw_flags;			/* some flags used in the canvas */

    /*
     *------------------------------------------------------------------
     * Starting here is additional type-specific stuff;  see the
     * declarations for individual types to see what is part of
     * each type.  The actual space below is determined by the
     * "itemInfoSize" of the type's Tk_ItemType record.
     *------------------------------------------------------------------
     */
} Tk_Item;

/*
 * Flag bits for canvases (redraw_flags):
 *
 * TK_ITEM_STATE_DEPENDANT -	1 means that object needs to be
 *				redrawn if the canvas state changes.
 * TK_ITEM_DONT_REDRAW - 	1 means that the object redraw is already
 *				been prepared, so the general canvas code
 *				doesn't need to do that any more.
 */

#define TK_ITEM_STATE_DEPENDANT		1
#define TK_ITEM_DONT_REDRAW		2

/*
 * Records of the following type are used to describe a type of
 * item (e.g.  lines, circles, etc.) that can form part of a
 * canvas widget.
 */

#ifdef USE_OLD_CANVAS
typedef int	Tk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv));
typedef int	Tk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv, int flags));
typedef int	Tk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv));
#else
typedef int	Tk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *CONST objv[]));
typedef int	Tk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *CONST objv[], int flags));
typedef int	Tk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *CONST argv[]));
#endif
typedef void	Tk_ItemDeleteProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, Display *display));
typedef void	Tk_ItemDisplayProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, Display *display, Drawable dst,
		    int x, int y, int width, int height));
typedef double	Tk_ItemPointProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double *pointPtr));
typedef int	Tk_ItemAreaProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double *rectPtr));
typedef int	Tk_ItemPostscriptProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int prepass));
typedef void	Tk_ItemScaleProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double originX, double originY,
		    double scaleX, double scaleY));
typedef void	Tk_ItemTranslateProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double deltaX, double deltaY));
typedef int	Tk_ItemIndexProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, char *indexString,
		    int *indexPtr));
typedef void	Tk_ItemCursorProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int index));
typedef int	Tk_ItemSelectionProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int offset, char *buffer,
		    int maxBytes));
typedef void	Tk_ItemInsertProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int beforeThis, char *string));
typedef void	Tk_ItemDCharsProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int first, int last));

#ifndef __NO_OLD_CONFIG

typedef struct Tk_ItemType {
    char *name;				/* The name of this type of item, such
					 * as "line". */
    int itemSize;			/* Total amount of space needed for
					 * item's record. */
    Tk_ItemCreateProc *createProc;	/* Procedure to create a new item of
					 * this type. */
    Tk_ConfigSpec *configSpecs;		/* Pointer to array of configuration
					 * specs for this type.  Used for
					 * returning configuration info. */
    Tk_ItemConfigureProc *configProc;	/* Procedure to call to change
					 * configuration options. */
    Tk_ItemCoordProc *coordProc;	/* Procedure to call to get and set
					 * the item's coordinates. */
    Tk_ItemDeleteProc *deleteProc;	/* Procedure to delete existing item of
					 * this type. */
    Tk_ItemDisplayProc *displayProc;	/* Procedure to display items of
					 * this type. */
    int alwaysRedraw;			/* Non-zero means displayProc should
					 * be called even when the item has
  					 * been moved off-screen. */
    Tk_ItemPointProc *pointProc;	/* Computes distance from item to
					 * a given point. */
    Tk_ItemAreaProc *areaProc;		/* Computes whether item is inside,
					 * outside, or overlapping an area. */
    Tk_ItemPostscriptProc *postscriptProc;
					/* Procedure to write a Postscript
					 * description for items of this
					 * type. */
    Tk_ItemScaleProc *scaleProc;	/* Procedure to rescale items of
					 * this type. */
    Tk_ItemTranslateProc *translateProc;/* Procedure to translate items of
					 * this type. */
    Tk_ItemIndexProc *indexProc;	/* Procedure to determine index of
					 * indicated character.  NULL if
					 * item doesn't support indexing. */
    Tk_ItemCursorProc *icursorProc;	/* Procedure to set insert cursor pos.
					 * to just before a given position. */
    Tk_ItemSelectionProc *selectionProc;/* Procedure to return selection (in
					 * STRING format) when it is in this
					 * item. */
    Tk_ItemInsertProc *insertProc;	/* Procedure to insert something into
					 * an item. */
    Tk_ItemDCharsProc *dCharsProc;	/* Procedure to delete characters
					 * from an item. */
    struct Tk_ItemType *nextPtr;	/* Used to link types together into
					 * a list. */
    char *reserved1;			/* Reserved for future extension. */
    int   reserved2;			/* Carefully compatible with */
    char *reserved3;			/* Jan Nijtmans dash patch */
    char *reserved4;
} Tk_ItemType;

#endif

/*
 * The following structure provides information about the selection and
 * the insertion cursor.  It is needed by only a few items, such as
 * those that display text.  It is shared by the generic canvas code
 * and the item-specific code, but most of the fields should be written
 * only by the canvas generic code.
 */

typedef struct Tk_CanvasTextInfo {
    Tk_3DBorder selBorder;	/* Border and background for selected
				 * characters.  Read-only to items.*/
    int selBorderWidth;		/* Width of border around selection. 
				 * Read-only to items. */
    XColor *selFgColorPtr;	/* Foreground color for selected text.
				 * Read-only to items. */
    Tk_Item *selItemPtr;	/* Pointer to selected item.  NULL means
				 * selection isn't in this canvas.
				 * Writable by items. */
    int selectFirst;		/* Character index of first selected
				 * character.  Writable by items. */
    int selectLast;		/* Character index of last selected
				 * character.  Writable by items. */
    Tk_Item *anchorItemPtr;	/* Item corresponding to "selectAnchor":
				 * not necessarily selItemPtr.   Read-only
				 * to items. */
    int selectAnchor;		/* Character index of fixed end of
				 * selection (i.e. "select to" operation will
				 * use this as one end of the selection).
				 * Writable by items. */
    Tk_3DBorder insertBorder;	/* Used to draw vertical bar for insertion
				 * cursor.  Read-only to items. */
    int insertWidth;		/* Total width of insertion cursor.  Read-only
				 * to items. */
    int insertBorderWidth;	/* Width of 3-D border around insert cursor.
				 * Read-only to items. */
    Tk_Item *focusItemPtr;	/* Item that currently has the input focus,
				 * or NULL if no such item.  Read-only to
				 * items.  */
    int gotFocus;		/* Non-zero means that the canvas widget has
				 * the input focus.  Read-only to items.*/
    int cursorOn;		/* Non-zero means that an insertion cursor
				 * should be displayed in focusItemPtr.
				 * Read-only to items.*/
} Tk_CanvasTextInfo;

/*
 * Structures used for Dashing and Outline.
 */

typedef struct Tk_Dash {
    int number;
    union {
	char *pt;
	char array[sizeof(char *)];
    } pattern;
} Tk_Dash;

typedef struct Tk_TSOffset {
    int flags;			/* flags; see below for possible values */
    int xoffset;		/* x offset */
    int yoffset;		/* y offset */
} Tk_TSOffset;

/*
 * Bit fields in Tk_Offset->flags:
 */

#define TK_OFFSET_INDEX		1
#define TK_OFFSET_RELATIVE	2
#define TK_OFFSET_LEFT		4
#define TK_OFFSET_CENTER	8
#define TK_OFFSET_RIGHT		16
#define TK_OFFSET_TOP		32
#define TK_OFFSET_MIDDLE	64
#define TK_OFFSET_BOTTOM	128

typedef struct Tk_Outline {
    GC gc;			/* Graphics context. */
    double width;		/* Width of outline. */
    double activeWidth;		/* Width of outline. */
    double disabledWidth;	/* Width of outline. */
    int offset;			/* Dash offset */
    Tk_Dash dash;		/* Dash pattern */
    Tk_Dash activeDash;		/* Dash pattern if state is active*/
    Tk_Dash disabledDash;	/* Dash pattern if state is disabled*/
    VOID *reserved1;		/* reserved for future expansion */
    VOID *reserved2;
    VOID *reserved3;
    Tk_TSOffset tsoffset;	/* stipple offset for outline*/
    XColor *color;		/* Outline color. */
    XColor *activeColor;	/* Outline color if state is active. */
    XColor *disabledColor;	/* Outline color if state is disabled. */
    Pixmap stipple;		/* Outline Stipple pattern. */
    Pixmap activeStipple;	/* Outline Stipple pattern if state is active. */
    Pixmap disabledStipple;	/* Outline Stipple pattern if state is disabled. */
} Tk_Outline;


/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for managing images:
 *
 *--------------------------------------------------------------
 */

typedef struct Tk_ImageType Tk_ImageType;
#ifdef USE_OLD_IMAGE
typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *name, int argc, char **argv, Tk_ImageType *typePtr,
	Tk_ImageMaster master, ClientData *masterDataPtr));
#else
typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *name, int objc, Tcl_Obj *CONST objv[], Tk_ImageType *typePtr,
	Tk_ImageMaster master, ClientData *masterDataPtr));
#endif
typedef ClientData (Tk_ImageGetProc) _ANSI_ARGS_((Tk_Window tkwin,
	ClientData masterData));
typedef void (Tk_ImageDisplayProc) _ANSI_ARGS_((ClientData instanceData,
	Display *display, Drawable drawable, int imageX, int imageY,
	int width, int height, int drawableX, int drawableY));
typedef void (Tk_ImageFreeProc) _ANSI_ARGS_((ClientData instanceData,
	Display *display));
typedef void (Tk_ImageDeleteProc) _ANSI_ARGS_((ClientData masterData));
typedef void (Tk_ImageChangedProc) _ANSI_ARGS_((ClientData clientData,
	int x, int y, int width, int height, int imageWidth,
	int imageHeight));
typedef int (Tk_ImagePostscriptProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo,
	int x, int y, int width, int height, int prepass));

/*
 * The following structure represents a particular type of image
 * (bitmap, xpm image, etc.).  It provides information common to
 * all images of that type, such as the type name and a collection
 * of procedures in the image manager that respond to various
 * events.  Each image manager is represented by one of these
 * structures.
 */

struct Tk_ImageType {
    char *name;			/* Name of image type. */
    Tk_ImageCreateProc *createProc;
				/* Procedure to call to create a new image
				 * of this type. */
    Tk_ImageGetProc *getProc;	/* Procedure to call the first time
				 * Tk_GetImage is called in a new way
				 * (new visual or screen). */
    Tk_ImageDisplayProc *displayProc;
				/* Call to draw image, in response to
				 * Tk_RedrawImage calls. */
    Tk_ImageFreeProc *freeProc;	/* Procedure to call whenever Tk_FreeImage
				 * is called to release an instance of an
				 * image. */
    Tk_ImageDeleteProc *deleteProc;
				/* Procedure to call to delete image.  It
				 * will not be called until after freeProc
				 * has been called for each instance of the
				 * image. */
    Tk_ImagePostscriptProc *postscriptProc;
				/* Procedure to call to produce postscript
				 * output for the image. */
    struct Tk_ImageType *nextPtr;
				/* Next in list of all image types currently
				 * known.  Filled in by Tk, not by image
				 * manager. */
    char *reserved;		/* reserved for future expansion */
};

/*
 *--------------------------------------------------------------
 *
 * Additional definitions used to manage images of type "photo".
 *
 *--------------------------------------------------------------
 */

/*
 * The following type is used to identify a particular photo image
 * to be manipulated:
 */

typedef void *Tk_PhotoHandle;

/*
 * The following structure describes a block of pixels in memory:
 */

typedef struct Tk_PhotoImageBlock {
    unsigned char *pixelPtr;	/* Pointer to the first pixel. */
    int		width;		/* Width of block, in pixels. */
    int		height;		/* Height of block, in pixels. */
    int		pitch;		/* Address difference between corresponding
				 * pixels in successive lines. */
    int		pixelSize;	/* Address difference between successive
				 * pixels in the same line. */
    int		offset[4];	/* Address differences between the red, green,
				 * blue and alpha components of the pixel and
				 * the pixel as a whole. */
} Tk_PhotoImageBlock;

/*
 * The following values control how blocks are combined into photo
 * images when the alpha component of a pixel is not 255, a.k.a. the
 * compositing rule.
 */

#define TK_PHOTO_COMPOSITE_OVERLAY	0
#define TK_PHOTO_COMPOSITE_SET		1

/*
 * Procedure prototypes and structures used in reading and
 * writing photo images:
 */

typedef struct Tk_PhotoImageFormat Tk_PhotoImageFormat;
#ifdef USE_OLD_IMAGE
typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,
	char *fileName, char *formatString, int *widthPtr, int *heightPtr));
typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((char *string,
	char *formatString, int *widthPtr, int *heightPtr));
typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Channel chan, char *fileName, char *formatString,
	Tk_PhotoHandle imageHandle, int destX, int destY,
	int width, int height, int srcX, int srcY));
typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *string, char *formatString, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *fileName, char *formatString, Tk_PhotoImageBlock *blockPtr));
typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *dataPtr, char *formatString,
	Tk_PhotoImageBlock *blockPtr));
#else
typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr, Tcl_Interp *interp));
typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr,
	Tcl_Interp *interp));
typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Channel chan, CONST char *fileName, Tcl_Obj *format,
	Tk_PhotoHandle imageHandle, int destX, int destY,
	int width, int height, int srcX, int srcY));
typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Obj *dataObj, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	CONST char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
#endif

/*
 * The following structure represents a particular file format for
 * storing images (e.g., PPM, GIF, JPEG, etc.).  It provides information
 * to allow image files of that format to be recognized and read into
 * a photo image.
 */

struct Tk_PhotoImageFormat {
    char *name;			/* Name of image file format */
    Tk_ImageFileMatchProc *fileMatchProc;
				/* Procedure to call to determine whether
				 * an image file matches this format. */
    Tk_ImageStringMatchProc *stringMatchProc;
				/* Procedure to call to determine whether
				 * the data in a string matches this format. */
    Tk_ImageFileReadProc *fileReadProc;
				/* Procedure to call to read data from
				 * an image file into a photo image. */
    Tk_ImageStringReadProc *stringReadProc;
				/* Procedure to call to read data from
				 * a string into a photo image. */
    Tk_ImageFileWriteProc *fileWriteProc;
				/* Procedure to call to write data from
				 * a photo image to a file. */
    Tk_ImageStringWriteProc *stringWriteProc;
				/* Procedure to call to obtain a string
				 * representation of the data in a photo
				 * image.*/
    struct Tk_PhotoImageFormat *nextPtr;
				/* Next in list of all photo image formats
				 * currently known.  Filled in by Tk, not
				 * by image format handler. */
};

EXTERN void		Tk_CreateOldImageType _ANSI_ARGS_((
				Tk_ImageType *typePtr));
EXTERN void		Tk_CreateOldPhotoImageFormat _ANSI_ARGS_((
				Tk_PhotoImageFormat *formatPtr));

#if !defined(USE_TK_STUBS) && defined(USE_OLD_IMAGE)
#define Tk_CreateImageType Tk_CreateOldImageType
#define Tk_CreatePhotoImageFormat Tk_CreateOldPhotoImageFormat
#endif


/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for managing styles:
 *
 *--------------------------------------------------------------
 */

/*
 * Style support version tag.
 */
#define TK_STYLE_VERSION_1      0x1
#define TK_STYLE_VERSION        TK_STYLE_VERSION_1

/*
 * The following structures and prototypes are used as static templates to
 * declare widget elements.
 */

typedef void (Tk_GetElementSizeProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, CONST Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        int width, int height, int inner, int *widthPtr, int *heightPtr));
typedef void (Tk_GetElementBoxProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, CONST Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        int x, int y, int width, int height, int inner, int *xPtr, int *yPtr,
        int *widthPtr, int *heightPtr));
typedef int (Tk_GetElementBorderWidthProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, CONST Tk_OptionSpec **optionsPtr, Tk_Window tkwin));
typedef void (Tk_DrawElementProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, CONST Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        Drawable d, int x, int y, int width, int height, int state));

typedef struct Tk_ElementOptionSpec {
    char *name;                 /* Name of the required option. */
    Tk_OptionType type;         /* Accepted option type. TK_OPTION_END means
                                 * any. */
} Tk_ElementOptionSpec;

typedef struct Tk_ElementSpec {
    int version;                /* Version of the style support. */
    char *name;                 /* Name of element. */
    Tk_ElementOptionSpec *options;
                                /* List of required options. Last one's name
                                 * must be NULL. */

    /*
     * Hooks
     */

    Tk_GetElementSizeProc *getSize;
                                /* Compute the external (resp. internal) size of
                                 * the element from its desired internal (resp.
                                 * external) size. */
    Tk_GetElementBoxProc *getBox;
                                /* Compute the inscribed or bounding boxes
                                 * within a given area. */
    Tk_GetElementBorderWidthProc *getBorderWidth;
                                /* Return the element's internal border width.
                                 * Mostly useful for widgets. */
    Tk_DrawElementProc *draw;   /* Draw the element in the given bounding box.*/
} Tk_ElementSpec;

/*
 * Element state flags. Can be OR'ed.
 */

#define TK_ELEMENT_STATE_ACTIVE         1<<0
#define TK_ELEMENT_STATE_DISABLED       1<<1
#define TK_ELEMENT_STATE_FOCUS          1<<2
#define TK_ELEMENT_STATE_PRESSED        1<<3

/*
 *--------------------------------------------------------------
 *
 * The definitions below provide backward compatibility for
 * functions and types related to event handling that used to
 * be in Tk but have moved to Tcl.
 *
 *--------------------------------------------------------------
 */

#define TK_READABLE		TCL_READABLE
#define TK_WRITABLE		TCL_WRITABLE
#define TK_EXCEPTION		TCL_EXCEPTION

#define TK_DONT_WAIT		TCL_DONT_WAIT
#define TK_X_EVENTS		TCL_WINDOW_EVENTS
#define TK_WINDOW_EVENTS	TCL_WINDOW_EVENTS
#define TK_FILE_EVENTS		TCL_FILE_EVENTS
#define TK_TIMER_EVENTS		TCL_TIMER_EVENTS
#define TK_IDLE_EVENTS		TCL_IDLE_EVENTS
#define TK_ALL_EVENTS		TCL_ALL_EVENTS

#define Tk_IdleProc		Tcl_IdleProc
#define Tk_FileProc		Tcl_FileProc
#define Tk_TimerProc		Tcl_TimerProc
#define Tk_TimerToken		Tcl_TimerToken

#define Tk_BackgroundError	Tcl_BackgroundError
#define Tk_CancelIdleCall	Tcl_CancelIdleCall
#define Tk_CreateFileHandler	Tcl_CreateFileHandler
#define Tk_CreateTimerHandler	Tcl_CreateTimerHandler
#define Tk_DeleteFileHandler	Tcl_DeleteFileHandler
#define Tk_DeleteTimerHandler	Tcl_DeleteTimerHandler
#define Tk_DoOneEvent		Tcl_DoOneEvent
#define Tk_DoWhenIdle		Tcl_DoWhenIdle
#define Tk_Sleep		Tcl_Sleep

/* Additional stuff that has moved to Tcl: */

#define Tk_EventuallyFree	Tcl_EventuallyFree
#define Tk_FreeProc		Tcl_FreeProc
#define Tk_Preserve		Tcl_Preserve
#define Tk_Release		Tcl_Release

/* Removed Tk_Main, use macro instead */
#define Tk_Main(argc, argv, proc) \
    Tk_MainEx(argc, argv, proc, Tcl_CreateInterp())

CONST char *Tk_InitStubs _ANSI_ARGS_((Tcl_Interp *interp, char *version, int exact));

#ifndef USE_TK_STUBS

#define Tk_InitStubs(interp, version, exact) \
    Tcl_PkgRequire(interp, "Tk", version, exact)

#endif

void Tk_InitImageArgs _ANSI_ARGS_((Tcl_Interp *interp, int argc, char ***argv));

#if !defined(USE_TK_STUBS) || !defined(USE_OLD_IMAGE)

#define Tk_InitImageArgs(interp, argc, argv) /**/

#endif


/*
 *--------------------------------------------------------------
 *
 * Additional procedure types defined by Tk.
 *
 *--------------------------------------------------------------
 */

typedef int (Tk_ErrorProc) _ANSI_ARGS_((ClientData clientData,
	XErrorEvent *errEventPtr));
typedef void (Tk_EventProc) _ANSI_ARGS_((ClientData clientData,
	XEvent *eventPtr));
typedef int (Tk_GenericProc) _ANSI_ARGS_((ClientData clientData,
	XEvent *eventPtr));
typedef int (Tk_ClientMessageProc) _ANSI_ARGS_((Tk_Window tkwin,
	XEvent *eventPtr));
typedef int (Tk_GetSelProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, char *portion));
typedef void (Tk_LostSelProc) _ANSI_ARGS_((ClientData clientData));
typedef Tk_RestrictAction (Tk_RestrictProc) _ANSI_ARGS_((
	ClientData clientData, XEvent *eventPtr));
typedef int (Tk_SelectionProc) _ANSI_ARGS_((ClientData clientData,
	int offset, char *buffer, int maxBytes));


/*
 *--------------------------------------------------------------
 *
 * Platform independant exported procedures and variables.
 *
 *--------------------------------------------------------------
 */

#include "tkDecls.h"

/*
 * Allow users to say that they don't want to alter their source to
 * add the extra argument to Tk_PhotoPutBlock(); DO NOT DEFINE THIS
 * WHEN BUILDING TK.
 *
 * This goes after the inclusion of the stubbed-decls so that the
 * declarations of what is actually there can be correct.
 */

#ifdef USE_COMPOSITELESS_PHOTO_PUT_BLOCK
#   ifdef Tk_PhotoPutBlock
#	undef Tk_PhotoPutBlock
#   endif
#   define Tk_PhotoPutBlock		Tk_PhotoPutBlock_NoComposite
#   ifdef Tk_PhotoPutZoomedBlock
#	undef Tk_PhotoPutZoomedBlock
#   endif
#   define Tk_PhotoPutZoomedBlock	Tk_PhotoPutZoomedBlock_NoComposite
#endif /* USE_COMPOSITELESS_PHOTO_PUT_BLOCK */

/*
 * Tcl commands exported by Tk:
 */


#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* RC_INVOKED */

/*
 * end block for C++
 */
    
#ifdef __cplusplus
}
#endif
    
#endif /* _TK */
       tkDecls.h                                                                                           0100644 0001750 0001750 00000260103 11001664475 032073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers                                                                        /*
 * tkDecls.h --
 *
 *	Declarations of functions in the platform independent public Tcl API.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkDecls.h,v 1.23 2002/08/05 04:30:38 dgp Exp $
 */

#ifndef _TKDECLS
#define _TKDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tk.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

/* 0 */
EXTERN void		Tk_MainLoop _ANSI_ARGS_((void));
/* 1 */
EXTERN XColor *		Tk_3DBorderColor _ANSI_ARGS_((Tk_3DBorder border));
/* 2 */
EXTERN GC		Tk_3DBorderGC _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_3DBorder border, int which));
/* 3 */
EXTERN void		Tk_3DHorizontalBevel _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, int x, 
				int y, int width, int height, int leftIn, 
				int rightIn, int topBevel, int relief));
/* 4 */
EXTERN void		Tk_3DVerticalBevel _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, int x, 
				int y, int width, int height, int leftBevel, 
				int relief));
/* 5 */
EXTERN void		Tk_AddOption _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * name, CONST char * value, 
				int priority));
/* 6 */
EXTERN void		Tk_BindEvent _ANSI_ARGS_((
				Tk_BindingTable bindingTable, 
				XEvent * eventPtr, Tk_Window tkwin, 
				int numObjects, ClientData * objectPtr));
/* 7 */
EXTERN void		Tk_CanvasDrawableCoords _ANSI_ARGS_((
				Tk_Canvas canvas, double x, double y, 
				short * drawableXPtr, short * drawableYPtr));
/* 8 */
EXTERN void		Tk_CanvasEventuallyRedraw _ANSI_ARGS_((
				Tk_Canvas canvas, int x1, int y1, int x2, 
				int y2));
/* 9 */
EXTERN int		Tk_CanvasGetCoord _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, CONST char * str, 
				double * doublePtr));
/* 10 */
EXTERN Tk_CanvasTextInfo * Tk_CanvasGetTextInfo _ANSI_ARGS_((
				Tk_Canvas canvas));
/* 11 */
EXTERN int		Tk_CanvasPsBitmap _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, Pixmap bitmap, int x, 
				int y, int width, int height));
/* 12 */
EXTERN int		Tk_CanvasPsColor _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, XColor * colorPtr));
/* 13 */
EXTERN int		Tk_CanvasPsFont _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, Tk_Font font));
/* 14 */
EXTERN void		Tk_CanvasPsPath _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, double * coordPtr, 
				int numPoints));
/* 15 */
EXTERN int		Tk_CanvasPsStipple _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Canvas canvas, Pixmap bitmap));
/* 16 */
EXTERN double		Tk_CanvasPsY _ANSI_ARGS_((Tk_Canvas canvas, double y));
/* 17 */
EXTERN void		Tk_CanvasSetStippleOrigin _ANSI_ARGS_((
				Tk_Canvas canvas, GC gc));
/* 18 */
EXTERN int		Tk_CanvasTagsParseProc _ANSI_ARGS_((
				ClientData clientData, Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * value, 
				char * widgRec, int offset));
/* 19 */
EXTERN char *		Tk_CanvasTagsPrintProc _ANSI_ARGS_((
				ClientData clientData, Tk_Window tkwin, 
				char * widgRec, int offset, 
				Tcl_FreeProc ** freeProcPtr));
/* 20 */
EXTERN Tk_Window	Tk_CanvasTkwin _ANSI_ARGS_((Tk_Canvas canvas));
/* 21 */
EXTERN void		Tk_CanvasWindowCoords _ANSI_ARGS_((Tk_Canvas canvas, 
				double x, double y, short * screenXPtr, 
				short * screenYPtr));
/* 22 */
EXTERN void		Tk_ChangeWindowAttributes _ANSI_ARGS_((
				Tk_Window tkwin, unsigned long valueMask, 
				XSetWindowAttributes * attsPtr));
/* 23 */
EXTERN int		Tk_CharBbox _ANSI_ARGS_((Tk_TextLayout layout, 
				int index, int * xPtr, int * yPtr, 
				int * widthPtr, int * heightPtr));
/* 24 */
EXTERN void		Tk_ClearSelection _ANSI_ARGS_((Tk_Window tkwin, 
				Atom selection));
/* 25 */
EXTERN int		Tk_ClipboardAppend _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Atom target, Atom format, 
				char* buffer));
/* 26 */
EXTERN int		Tk_ClipboardClear _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin));
/* 27 */
EXTERN int		Tk_ConfigureInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_ConfigSpec * specs, 
				char * widgRec, CONST char * argvName, 
				int flags));
/* 28 */
EXTERN int		Tk_ConfigureValue _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_ConfigSpec * specs, 
				char * widgRec, CONST char * argvName, 
				int flags));
/* 29 */
EXTERN int		Tk_ConfigureWidget _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_ConfigSpec * specs, 
				int argc, CONST84 char ** argv, 
				char * widgRec, int flags));
/* 30 */
EXTERN void		Tk_ConfigureWindow _ANSI_ARGS_((Tk_Window tkwin, 
				unsigned int valueMask, 
				XWindowChanges * valuePtr));
/* 31 */
EXTERN Tk_TextLayout	Tk_ComputeTextLayout _ANSI_ARGS_((Tk_Font font, 
				CONST char * str, int numChars, 
				int wrapLength, Tk_Justify justify, 
				int flags, int * widthPtr, int * heightPtr));
/* 32 */
EXTERN Tk_Window	Tk_CoordsToWindow _ANSI_ARGS_((int rootX, int rootY, 
				Tk_Window tkwin));
/* 33 */
EXTERN unsigned long	Tk_CreateBinding _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_BindingTable bindingTable, 
				ClientData object, CONST char * eventStr, 
				CONST char * command, int append));
/* 34 */
EXTERN Tk_BindingTable	Tk_CreateBindingTable _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 35 */
EXTERN Tk_ErrorHandler	Tk_CreateErrorHandler _ANSI_ARGS_((Display * display, 
				int errNum, int request, int minorCode, 
				Tk_ErrorProc * errorProc, 
				ClientData clientData));
/* 36 */
EXTERN void		Tk_CreateEventHandler _ANSI_ARGS_((Tk_Window token, 
				unsigned long mask, Tk_EventProc * proc, 
				ClientData clientData));
/* 37 */
EXTERN void		Tk_CreateGenericHandler _ANSI_ARGS_((
				Tk_GenericProc * proc, ClientData clientData));
/* 38 */
EXTERN void		Tk_CreateImageType _ANSI_ARGS_((
				Tk_ImageType * typePtr));
/* 39 */
EXTERN void		Tk_CreateItemType _ANSI_ARGS_((Tk_ItemType * typePtr));
/* 40 */
EXTERN void		Tk_CreatePhotoImageFormat _ANSI_ARGS_((
				Tk_PhotoImageFormat * formatPtr));
/* 41 */
EXTERN void		Tk_CreateSelHandler _ANSI_ARGS_((Tk_Window tkwin, 
				Atom selection, Atom target, 
				Tk_SelectionProc * proc, 
				ClientData clientData, Atom format));
/* 42 */
EXTERN Tk_Window	Tk_CreateWindow _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window parent, CONST char * name, 
				CONST char * screenName));
/* 43 */
EXTERN Tk_Window	Tk_CreateWindowFromPath _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				CONST char * pathName, 
				CONST char * screenName));
/* 44 */
EXTERN int		Tk_DefineBitmap _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, CONST char * source, 
				int width, int height));
/* 45 */
EXTERN void		Tk_DefineCursor _ANSI_ARGS_((Tk_Window window, 
				Tk_Cursor cursor));
/* 46 */
EXTERN void		Tk_DeleteAllBindings _ANSI_ARGS_((
				Tk_BindingTable bindingTable, 
				ClientData object));
/* 47 */
EXTERN int		Tk_DeleteBinding _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_BindingTable bindingTable, 
				ClientData object, CONST char * eventStr));
/* 48 */
EXTERN void		Tk_DeleteBindingTable _ANSI_ARGS_((
				Tk_BindingTable bindingTable));
/* 49 */
EXTERN void		Tk_DeleteErrorHandler _ANSI_ARGS_((
				Tk_ErrorHandler handler));
/* 50 */
EXTERN void		Tk_DeleteEventHandler _ANSI_ARGS_((Tk_Window token, 
				unsigned long mask, Tk_EventProc * proc, 
				ClientData clientData));
/* 51 */
EXTERN void		Tk_DeleteGenericHandler _ANSI_ARGS_((
				Tk_GenericProc * proc, ClientData clientData));
/* 52 */
EXTERN void		Tk_DeleteImage _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name));
/* 53 */
EXTERN void		Tk_DeleteSelHandler _ANSI_ARGS_((Tk_Window tkwin, 
				Atom selection, Atom target));
/* 54 */
EXTERN void		Tk_DestroyWindow _ANSI_ARGS_((Tk_Window tkwin));
/* 55 */
EXTERN CONST84_RETURN char * Tk_DisplayName _ANSI_ARGS_((Tk_Window tkwin));
/* 56 */
EXTERN int		Tk_DistanceToTextLayout _ANSI_ARGS_((
				Tk_TextLayout layout, int x, int y));
/* 57 */
EXTERN void		Tk_Draw3DPolygon _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, 
				XPoint * pointPtr, int numPoints, 
				int borderWidth, int leftRelief));
/* 58 */
EXTERN void		Tk_Draw3DRectangle _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, int x, 
				int y, int width, int height, 
				int borderWidth, int relief));
/* 59 */
EXTERN void		Tk_DrawChars _ANSI_ARGS_((Display * display, 
				Drawable drawable, GC gc, Tk_Font tkfont, 
				CONST char * source, int numBytes, int x, 
				int y));
/* 60 */
EXTERN void		Tk_DrawFocusHighlight _ANSI_ARGS_((Tk_Window tkwin, 
				GC gc, int width, Drawable drawable));
/* 61 */
EXTERN void		Tk_DrawTextLayout _ANSI_ARGS_((Display * display, 
				Drawable drawable, GC gc, 
				Tk_TextLayout layout, int x, int y, 
				int firstChar, int lastChar));
/* 62 */
EXTERN void		Tk_Fill3DPolygon _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, 
				XPoint * pointPtr, int numPoints, 
				int borderWidth, int leftRelief));
/* 63 */
EXTERN void		Tk_Fill3DRectangle _ANSI_ARGS_((Tk_Window tkwin, 
				Drawable drawable, Tk_3DBorder border, int x, 
				int y, int width, int height, 
				int borderWidth, int relief));
/* 64 */
EXTERN Tk_PhotoHandle	Tk_FindPhoto _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * imageName));
/* 65 */
EXTERN Font		Tk_FontId _ANSI_ARGS_((Tk_Font font));
/* 66 */
EXTERN void		Tk_Free3DBorder _ANSI_ARGS_((Tk_3DBorder border));
/* 67 */
EXTERN void		Tk_FreeBitmap _ANSI_ARGS_((Display * display, 
				Pixmap bitmap));
/* 68 */
EXTERN void		Tk_FreeColor _ANSI_ARGS_((XColor * colorPtr));
/* 69 */
EXTERN void		Tk_FreeColormap _ANSI_ARGS_((Display * display, 
				Colormap colormap));
/* 70 */
EXTERN void		Tk_FreeCursor _ANSI_ARGS_((Display * display, 
				Tk_Cursor cursor));
/* 71 */
EXTERN void		Tk_FreeFont _ANSI_ARGS_((Tk_Font f));
/* 72 */
EXTERN void		Tk_FreeGC _ANSI_ARGS_((Display * display, GC gc));
/* 73 */
EXTERN void		Tk_FreeImage _ANSI_ARGS_((Tk_Image image));
/* 74 */
EXTERN void		Tk_FreeOptions _ANSI_ARGS_((Tk_ConfigSpec * specs, 
				char * widgRec, Display * display, 
				int needFlags));
/* 75 */
EXTERN void		Tk_FreePixmap _ANSI_ARGS_((Display * display, 
				Pixmap pixmap));
/* 76 */
EXTERN void		Tk_FreeTextLayout _ANSI_ARGS_((
				Tk_TextLayout textLayout));
/* 77 */
EXTERN void		Tk_FreeXId _ANSI_ARGS_((Display * display, XID xid));
/* 78 */
EXTERN GC		Tk_GCForColor _ANSI_ARGS_((XColor * colorPtr, 
				Drawable drawable));
/* 79 */
EXTERN void		Tk_GeometryRequest _ANSI_ARGS_((Tk_Window tkwin, 
				int reqWidth, int reqHeight));
/* 80 */
EXTERN Tk_3DBorder	Tk_Get3DBorder _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_Uid colorName));
/* 81 */
EXTERN void		Tk_GetAllBindings _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_BindingTable bindingTable, 
				ClientData object));
/* 82 */
EXTERN int		Tk_GetAnchor _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, Tk_Anchor * anchorPtr));
/* 83 */
EXTERN CONST84_RETURN char * Tk_GetAtomName _ANSI_ARGS_((Tk_Window tkwin, 
				Atom atom));
/* 84 */
EXTERN CONST84_RETURN char * Tk_GetBinding _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_BindingTable bindingTable, 
				ClientData object, CONST char * eventStr));
/* 85 */
EXTERN Pixmap		Tk_GetBitmap _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str));
/* 86 */
EXTERN Pixmap		Tk_GetBitmapFromData _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				CONST char * source, int width, int height));
/* 87 */
EXTERN int		Tk_GetCapStyle _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * capPtr));
/* 88 */
EXTERN XColor *		Tk_GetColor _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_Uid name));
/* 89 */
EXTERN XColor *		Tk_GetColorByValue _ANSI_ARGS_((Tk_Window tkwin, 
				XColor * colorPtr));
/* 90 */
EXTERN Colormap		Tk_GetColormap _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str));
/* 91 */
EXTERN Tk_Cursor	Tk_GetCursor _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_Uid str));
/* 92 */
EXTERN Tk_Cursor	Tk_GetCursorFromData _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				CONST char * source, CONST char * mask, 
				int width, int height, int xHot, int yHot, 
				Tk_Uid fg, Tk_Uid bg));
/* 93 */
EXTERN Tk_Font		Tk_GetFont _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str));
/* 94 */
EXTERN Tk_Font		Tk_GetFontFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 95 */
EXTERN void		Tk_GetFontMetrics _ANSI_ARGS_((Tk_Font font, 
				Tk_FontMetrics * fmPtr));
/* 96 */
EXTERN GC		Tk_GetGC _ANSI_ARGS_((Tk_Window tkwin, 
				unsigned long valueMask, 
				XGCValues * valuePtr));
/* 97 */
EXTERN Tk_Image		Tk_GetImage _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * name, 
				Tk_ImageChangedProc * changeProc, 
				ClientData clientData));
/* 98 */
EXTERN ClientData	Tk_GetImageMasterData _ANSI_ARGS_((
				Tcl_Interp * interp, CONST char * name, 
				Tk_ImageType ** typePtrPtr));
/* 99 */
EXTERN Tk_ItemType *	Tk_GetItemTypes _ANSI_ARGS_((void));
/* 100 */
EXTERN int		Tk_GetJoinStyle _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, int * joinPtr));
/* 101 */
EXTERN int		Tk_GetJustify _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * str, Tk_Justify * justifyPtr));
/* 102 */
EXTERN int		Tk_GetNumMainWindows _ANSI_ARGS_((void));
/* 103 */
EXTERN Tk_Uid		Tk_GetOption _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * name, CONST char * className));
/* 104 */
EXTERN int		Tk_GetPixels _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str, 
				int * intPtr));
/* 105 */
EXTERN Pixmap		Tk_GetPixmap _ANSI_ARGS_((Display * display, 
				Drawable d, int width, int height, int depth));
/* 106 */
EXTERN int		Tk_GetRelief _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name, int * reliefPtr));
/* 107 */
EXTERN void		Tk_GetRootCoords _ANSI_ARGS_((Tk_Window tkwin, 
				int * xPtr, int * yPtr));
/* 108 */
EXTERN int		Tk_GetScrollInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				int argc, CONST84 char ** argv, 
				double * dblPtr, int * intPtr));
/* 109 */
EXTERN int		Tk_GetScreenMM _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str, 
				double * doublePtr));
/* 110 */
EXTERN int		Tk_GetSelection _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Atom selection, Atom target, 
				Tk_GetSelProc * proc, ClientData clientData));
/* 111 */
EXTERN Tk_Uid		Tk_GetUid _ANSI_ARGS_((CONST char * str));
/* 112 */
EXTERN Visual *		Tk_GetVisual _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, CONST char * str, 
				int * depthPtr, Colormap * colormapPtr));
/* 113 */
EXTERN void		Tk_GetVRootGeometry _ANSI_ARGS_((Tk_Window tkwin, 
				int * xPtr, int * yPtr, int * widthPtr, 
				int * heightPtr));
/* 114 */
EXTERN int		Tk_Grab _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, int grabGlobal));
/* 115 */
EXTERN void		Tk_HandleEvent _ANSI_ARGS_((XEvent * eventPtr));
/* 116 */
EXTERN Tk_Window	Tk_IdToWindow _ANSI_ARGS_((Display * display, 
				Window window));
/* 117 */
EXTERN void		Tk_ImageChanged _ANSI_ARGS_((Tk_ImageMaster master, 
				int x, int y, int width, int height, 
				int imageWidth, int imageHeight));
/* 118 */
EXTERN int		Tk_Init _ANSI_ARGS_((Tcl_Interp * interp));
/* 119 */
EXTERN Atom		Tk_InternAtom _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * name));
/* 120 */
EXTERN int		Tk_IntersectTextLayout _ANSI_ARGS_((
				Tk_TextLayout layout, int x, int y, 
				int width, int height));
/* 121 */
EXTERN void		Tk_MaintainGeometry _ANSI_ARGS_((Tk_Window slave, 
				Tk_Window master, int x, int y, int width, 
				int height));
/* 122 */
EXTERN Tk_Window	Tk_MainWindow _ANSI_ARGS_((Tcl_Interp * interp));
/* 123 */
EXTERN void		Tk_MakeWindowExist _ANSI_ARGS_((Tk_Window tkwin));
/* 124 */
EXTERN void		Tk_ManageGeometry _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_GeomMgr * mgrPtr, ClientData clientData));
/* 125 */
EXTERN void		Tk_MapWindow _ANSI_ARGS_((Tk_Window tkwin));
/* 126 */
EXTERN int		Tk_MeasureChars _ANSI_ARGS_((Tk_Font tkfont, 
				CONST char * source, int numBytes, 
				int maxPixels, int flags, int * lengthPtr));
/* 127 */
EXTERN void		Tk_MoveResizeWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int x, int y, int width, int height));
/* 128 */
EXTERN void		Tk_MoveWindow _ANSI_ARGS_((Tk_Window tkwin, int x, 
				int y));
/* 129 */
EXTERN void		Tk_MoveToplevelWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int x, int y));
/* 130 */
EXTERN CONST84_RETURN char * Tk_NameOf3DBorder _ANSI_ARGS_((
				Tk_3DBorder border));
/* 131 */
EXTERN CONST84_RETURN char * Tk_NameOfAnchor _ANSI_ARGS_((Tk_Anchor anchor));
/* 132 */
EXTERN CONST84_RETURN char * Tk_NameOfBitmap _ANSI_ARGS_((Display * display, 
				Pixmap bitmap));
/* 133 */
EXTERN CONST84_RETURN char * Tk_NameOfCapStyle _ANSI_ARGS_((int cap));
/* 134 */
EXTERN CONST84_RETURN char * Tk_NameOfColor _ANSI_ARGS_((XColor * colorPtr));
/* 135 */
EXTERN CONST84_RETURN char * Tk_NameOfCursor _ANSI_ARGS_((Display * display, 
				Tk_Cursor cursor));
/* 136 */
EXTERN CONST84_RETURN char * Tk_NameOfFont _ANSI_ARGS_((Tk_Font font));
/* 137 */
EXTERN CONST84_RETURN char * Tk_NameOfImage _ANSI_ARGS_((
				Tk_ImageMaster imageMaster));
/* 138 */
EXTERN CONST84_RETURN char * Tk_NameOfJoinStyle _ANSI_ARGS_((int join));
/* 139 */
EXTERN CONST84_RETURN char * Tk_NameOfJustify _ANSI_ARGS_((
				Tk_Justify justify));
/* 140 */
EXTERN CONST84_RETURN char * Tk_NameOfRelief _ANSI_ARGS_((int relief));
/* 141 */
EXTERN Tk_Window	Tk_NameToWindow _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * pathName, Tk_Window tkwin));
/* 142 */
EXTERN void		Tk_OwnSelection _ANSI_ARGS_((Tk_Window tkwin, 
				Atom selection, Tk_LostSelProc * proc, 
				ClientData clientData));
/* 143 */
EXTERN int		Tk_ParseArgv _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, int * argcPtr, 
				CONST84 char ** argv, Tk_ArgvInfo * argTable, 
				int flags));
/* 144 */
EXTERN void		Tk_PhotoPutBlock_NoComposite _ANSI_ARGS_((
				Tk_PhotoHandle handle, 
				Tk_PhotoImageBlock * blockPtr, int x, int y, 
				int width, int height));
/* 145 */
EXTERN void		Tk_PhotoPutZoomedBlock_NoComposite _ANSI_ARGS_((
				Tk_PhotoHandle handle, 
				Tk_PhotoImageBlock * blockPtr, int x, int y, 
				int width, int height, int zoomX, int zoomY, 
				int subsampleX, int subsampleY));
/* 146 */
EXTERN int		Tk_PhotoGetImage _ANSI_ARGS_((Tk_PhotoHandle handle, 
				Tk_PhotoImageBlock * blockPtr));
/* 147 */
EXTERN void		Tk_PhotoBlank _ANSI_ARGS_((Tk_PhotoHandle handle));
/* 148 */
EXTERN void		Tk_PhotoExpand _ANSI_ARGS_((Tk_PhotoHandle handle, 
				int width, int height));
/* 149 */
EXTERN void		Tk_PhotoGetSize _ANSI_ARGS_((Tk_PhotoHandle handle, 
				int * widthPtr, int * heightPtr));
/* 150 */
EXTERN void		Tk_PhotoSetSize _ANSI_ARGS_((Tk_PhotoHandle handle, 
				int width, int height));
/* 151 */
EXTERN int		Tk_PointToChar _ANSI_ARGS_((Tk_TextLayout layout, 
				int x, int y));
/* 152 */
EXTERN int		Tk_PostscriptFontName _ANSI_ARGS_((Tk_Font tkfont, 
				Tcl_DString * dsPtr));
/* 153 */
EXTERN void		Tk_PreserveColormap _ANSI_ARGS_((Display * display, 
				Colormap colormap));
/* 154 */
EXTERN void		Tk_QueueWindowEvent _ANSI_ARGS_((XEvent * eventPtr, 
				Tcl_QueuePosition position));
/* 155 */
EXTERN void		Tk_RedrawImage _ANSI_ARGS_((Tk_Image image, 
				int imageX, int imageY, int width, 
				int height, Drawable drawable, int drawableX, 
				int drawableY));
/* 156 */
EXTERN void		Tk_ResizeWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int width, int height));
/* 157 */
EXTERN int		Tk_RestackWindow _ANSI_ARGS_((Tk_Window tkwin, 
				int aboveBelow, Tk_Window other));
/* 158 */
EXTERN Tk_RestrictProc * Tk_RestrictEvents _ANSI_ARGS_((
				Tk_RestrictProc * proc, ClientData arg, 
				ClientData * prevArgPtr));
/* 159 */
EXTERN int		Tk_SafeInit _ANSI_ARGS_((Tcl_Interp * interp));
/* 160 */
EXTERN CONST char *	Tk_SetAppName _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * name));
/* 161 */
EXTERN void		Tk_SetBackgroundFromBorder _ANSI_ARGS_((
				Tk_Window tkwin, Tk_3DBorder border));
/* 162 */
EXTERN void		Tk_SetClass _ANSI_ARGS_((Tk_Window tkwin, 
				CONST char * className));
/* 163 */
EXTERN void		Tk_SetGrid _ANSI_ARGS_((Tk_Window tkwin, 
				int reqWidth, int reqHeight, int gridWidth, 
				int gridHeight));
/* 164 */
EXTERN void		Tk_SetInternalBorder _ANSI_ARGS_((Tk_Window tkwin, 
				int width));
/* 165 */
EXTERN void		Tk_SetWindowBackground _ANSI_ARGS_((Tk_Window tkwin, 
				unsigned long pixel));
/* 166 */
EXTERN void		Tk_SetWindowBackgroundPixmap _ANSI_ARGS_((
				Tk_Window tkwin, Pixmap pixmap));
/* 167 */
EXTERN void		Tk_SetWindowBorder _ANSI_ARGS_((Tk_Window tkwin, 
				unsigned long pixel));
/* 168 */
EXTERN void		Tk_SetWindowBorderWidth _ANSI_ARGS_((Tk_Window tkwin, 
				int width));
/* 169 */
EXTERN void		Tk_SetWindowBorderPixmap _ANSI_ARGS_((
				Tk_Window tkwin, Pixmap pixmap));
/* 170 */
EXTERN void		Tk_SetWindowColormap _ANSI_ARGS_((Tk_Window tkwin, 
				Colormap colormap));
/* 171 */
EXTERN int		Tk_SetWindowVisual _ANSI_ARGS_((Tk_Window tkwin, 
				Visual * visual, int depth, 
				Colormap colormap));
/* 172 */
EXTERN void		Tk_SizeOfBitmap _ANSI_ARGS_((Display * display, 
				Pixmap bitmap, int * widthPtr, 
				int * heightPtr));
/* 173 */
EXTERN void		Tk_SizeOfImage _ANSI_ARGS_((Tk_Image image, 
				int * widthPtr, int * heightPtr));
/* 174 */
EXTERN int		Tk_StrictMotif _ANSI_ARGS_((Tk_Window tkwin));
/* 175 */
EXTERN void		Tk_TextLayoutToPostscript _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_TextLayout layout));
/* 176 */
EXTERN int		Tk_TextWidth _ANSI_ARGS_((Tk_Font font, 
				CONST char * str, int numBytes));
/* 177 */
EXTERN void		Tk_UndefineCursor _ANSI_ARGS_((Tk_Window window));
/* 178 */
EXTERN void		Tk_UnderlineChars _ANSI_ARGS_((Display * display, 
				Drawable drawable, GC gc, Tk_Font tkfont, 
				CONST char * source, int x, int y, 
				int firstByte, int lastByte));
/* 179 */
EXTERN void		Tk_UnderlineTextLayout _ANSI_ARGS_((
				Display * display, Drawable drawable, GC gc, 
				Tk_TextLayout layout, int x, int y, 
				int underline));
/* 180 */
EXTERN void		Tk_Ungrab _ANSI_ARGS_((Tk_Window tkwin));
/* 181 */
EXTERN void		Tk_UnmaintainGeometry _ANSI_ARGS_((Tk_Window slave, 
				Tk_Window master));
/* 182 */
EXTERN void		Tk_UnmapWindow _ANSI_ARGS_((Tk_Window tkwin));
/* 183 */
EXTERN void		Tk_UnsetGrid _ANSI_ARGS_((Tk_Window tkwin));
/* 184 */
EXTERN void		Tk_UpdatePointer _ANSI_ARGS_((Tk_Window tkwin, int x, 
				int y, int state));
/* 185 */
EXTERN Pixmap		Tk_AllocBitmapFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 186 */
EXTERN Tk_3DBorder	Tk_Alloc3DBorderFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 187 */
EXTERN XColor *		Tk_AllocColorFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 188 */
EXTERN Tk_Cursor	Tk_AllocCursorFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 189 */
EXTERN Tk_Font		Tk_AllocFontFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tcl_Obj * objPtr));
/* 190 */
EXTERN Tk_OptionTable	Tk_CreateOptionTable _ANSI_ARGS_((
				Tcl_Interp * interp, 
				CONST Tk_OptionSpec * templatePtr));
/* 191 */
EXTERN void		Tk_DeleteOptionTable _ANSI_ARGS_((
				Tk_OptionTable optionTable));
/* 192 */
EXTERN void		Tk_Free3DBorderFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 193 */
EXTERN void		Tk_FreeBitmapFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 194 */
EXTERN void		Tk_FreeColorFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 195 */
EXTERN void		Tk_FreeConfigOptions _ANSI_ARGS_((char * recordPtr, 
				Tk_OptionTable optionToken, Tk_Window tkwin));
/* 196 */
EXTERN void		Tk_FreeSavedOptions _ANSI_ARGS_((
				Tk_SavedOptions * savePtr));
/* 197 */
EXTERN void		Tk_FreeCursorFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 198 */
EXTERN void		Tk_FreeFontFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 199 */
EXTERN Tk_3DBorder	Tk_Get3DBorderFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 200 */
EXTERN int		Tk_GetAnchorFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, Tk_Anchor * anchorPtr));
/* 201 */
EXTERN Pixmap		Tk_GetBitmapFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 202 */
EXTERN XColor *		Tk_GetColorFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 203 */
EXTERN Tk_Cursor	Tk_GetCursorFromObj _ANSI_ARGS_((Tk_Window tkwin, 
				Tcl_Obj * objPtr));
/* 204 */
EXTERN Tcl_Obj *	Tk_GetOptionInfo _ANSI_ARGS_((Tcl_Interp * interp, 
				char * recordPtr, Tk_OptionTable optionTable, 
				Tcl_Obj * namePtr, Tk_Window tkwin));
/* 205 */
EXTERN Tcl_Obj *	Tk_GetOptionValue _ANSI_ARGS_((Tcl_Interp * interp, 
				char * recordPtr, Tk_OptionTable optionTable, 
				Tcl_Obj * namePtr, Tk_Window tkwin));
/* 206 */
EXTERN int		Tk_GetJustifyFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr, 
				Tk_Justify * justifyPtr));
/* 207 */
EXTERN int		Tk_GetMMFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tcl_Obj * objPtr, 
				double * doublePtr));
/* 208 */
EXTERN int		Tk_GetPixelsFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tcl_Obj * objPtr, 
				int * intPtr));
/* 209 */
EXTERN int		Tk_GetReliefFromObj _ANSI_ARGS_((Tcl_Interp * interp, 
				Tcl_Obj * objPtr, int * resultPtr));
/* 210 */
EXTERN int		Tk_GetScrollInfoObj _ANSI_ARGS_((Tcl_Interp * interp, 
				int objc, Tcl_Obj *CONST objv[], 
				double * dblPtr, int * intPtr));
/* 211 */
EXTERN int		Tk_InitOptions _ANSI_ARGS_((Tcl_Interp * interp, 
				char * recordPtr, Tk_OptionTable optionToken, 
				Tk_Window tkwin));
/* 212 */
EXTERN void		Tk_MainEx _ANSI_ARGS_((int argc, char ** argv, 
				Tcl_AppInitProc * appInitProc, 
				Tcl_Interp * interp));
/* 213 */
EXTERN void		Tk_RestoreSavedOptions _ANSI_ARGS_((
				Tk_SavedOptions * savePtr));
/* 214 */
EXTERN int		Tk_SetOptions _ANSI_ARGS_((Tcl_Interp * interp, 
				char * recordPtr, Tk_OptionTable optionTable, 
				int objc, Tcl_Obj *CONST objv[], 
				Tk_Window tkwin, Tk_SavedOptions * savePtr, 
				int * maskPtr));
/* 215 */
EXTERN void		Tk_InitConsoleChannels _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 216 */
EXTERN int		Tk_CreateConsoleWindow _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 217 */
EXTERN void		Tk_CreateSmoothMethod _ANSI_ARGS_((
				Tcl_Interp * interp, 
				Tk_SmoothMethod * method));
/* Slot 218 is reserved */
/* Slot 219 is reserved */
/* 220 */
EXTERN int		Tk_GetDash _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * value, Tk_Dash * dash));
/* 221 */
EXTERN void		Tk_CreateOutline _ANSI_ARGS_((Tk_Outline * outline));
/* 222 */
EXTERN void		Tk_DeleteOutline _ANSI_ARGS_((Display * display, 
				Tk_Outline * outline));
/* 223 */
EXTERN int		Tk_ConfigOutlineGC _ANSI_ARGS_((XGCValues * gcValues, 
				Tk_Canvas canvas, Tk_Item * item, 
				Tk_Outline * outline));
/* 224 */
EXTERN int		Tk_ChangeOutlineGC _ANSI_ARGS_((Tk_Canvas canvas, 
				Tk_Item * item, Tk_Outline * outline));
/* 225 */
EXTERN int		Tk_ResetOutlineGC _ANSI_ARGS_((Tk_Canvas canvas, 
				Tk_Item * item, Tk_Outline * outline));
/* 226 */
EXTERN int		Tk_CanvasPsOutline _ANSI_ARGS_((Tk_Canvas canvas, 
				Tk_Item * item, Tk_Outline * outline));
/* 227 */
EXTERN void		Tk_SetTSOrigin _ANSI_ARGS_((Tk_Window tkwin, GC gc, 
				int x, int y));
/* 228 */
EXTERN int		Tk_CanvasGetCoordFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Canvas canvas, 
				Tcl_Obj * obj, double * doublePtr));
/* 229 */
EXTERN void		Tk_CanvasSetOffset _ANSI_ARGS_((Tk_Canvas canvas, 
				GC gc, Tk_TSOffset * offset));
/* 230 */
EXTERN void		Tk_DitherPhoto _ANSI_ARGS_((Tk_PhotoHandle handle, 
				int x, int y, int width, int height));
/* 231 */
EXTERN int		Tk_PostscriptBitmap _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_Window tkwin, Tk_PostscriptInfo psInfo, 
				Pixmap bitmap, int startX, int startY, 
				int width, int height));
/* 232 */
EXTERN int		Tk_PostscriptColor _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_PostscriptInfo psInfo, XColor * colorPtr));
/* 233 */
EXTERN int		Tk_PostscriptFont _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_PostscriptInfo psInfo, Tk_Font font));
/* 234 */
EXTERN int		Tk_PostscriptImage _ANSI_ARGS_((Tk_Image image, 
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tk_PostscriptInfo psinfo, int x, int y, 
				int width, int height, int prepass));
/* 235 */
EXTERN void		Tk_PostscriptPath _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_PostscriptInfo psInfo, double * coordPtr, 
				int numPoints));
/* 236 */
EXTERN int		Tk_PostscriptStipple _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window tkwin, 
				Tk_PostscriptInfo psInfo, Pixmap bitmap));
/* 237 */
EXTERN double		Tk_PostscriptY _ANSI_ARGS_((double y, 
				Tk_PostscriptInfo psInfo));
/* 238 */
EXTERN int		Tk_PostscriptPhoto _ANSI_ARGS_((Tcl_Interp * interp, 
				Tk_PhotoImageBlock * blockPtr, 
				Tk_PostscriptInfo psInfo, int width, 
				int height));
/* 239 */
EXTERN void		Tk_CreateClientMessageHandler _ANSI_ARGS_((
				Tk_ClientMessageProc * proc));
/* 240 */
EXTERN void		Tk_DeleteClientMessageHandler _ANSI_ARGS_((
				Tk_ClientMessageProc * proc));
/* 241 */
EXTERN Tk_Window	Tk_CreateAnonymousWindow _ANSI_ARGS_((
				Tcl_Interp * interp, Tk_Window parent, 
				CONST char * screenName));
/* 242 */
EXTERN void		Tk_SetClassProcs _ANSI_ARGS_((Tk_Window tkwin, 
				Tk_ClassProcs * procs, 
				ClientData instanceData));
/* 243 */
EXTERN void		Tk_SetInternalBorderEx _ANSI_ARGS_((Tk_Window tkwin, 
				int left, int right, int top, int bottom));
/* 244 */
EXTERN void		Tk_SetMinimumRequestSize _ANSI_ARGS_((
				Tk_Window tkwin, int minWidth, int minHeight));
/* 245 */
EXTERN void		Tk_SetCaretPos _ANSI_ARGS_((Tk_Window tkwin, int x, 
				int y, int height));
/* 246 */
EXTERN void		Tk_PhotoPutBlock _ANSI_ARGS_((Tk_PhotoHandle handle, 
				Tk_PhotoImageBlock * blockPtr, int x, int y, 
				int width, int height, int compRule));
/* 247 */
EXTERN void		Tk_PhotoPutZoomedBlock _ANSI_ARGS_((
				Tk_PhotoHandle handle, 
				Tk_PhotoImageBlock * blockPtr, int x, int y, 
				int width, int height, int zoomX, int zoomY, 
				int subsampleX, int subsampleY, int compRule));
/* 248 */
EXTERN int		Tk_CollapseMotionEvents _ANSI_ARGS_((
				Display * display, int collapse));
/* 249 */
EXTERN Tk_StyleEngine	Tk_RegisterStyleEngine _ANSI_ARGS_((
				CONST char * name, Tk_StyleEngine parent));
/* 250 */
EXTERN Tk_StyleEngine	Tk_GetStyleEngine _ANSI_ARGS_((CONST char * name));
/* 251 */
EXTERN int		Tk_RegisterStyledElement _ANSI_ARGS_((
				Tk_StyleEngine engine, 
				Tk_ElementSpec * templatePtr));
/* 252 */
EXTERN int		Tk_GetElementId _ANSI_ARGS_((CONST char * name));
/* 253 */
EXTERN Tk_Style		Tk_CreateStyle _ANSI_ARGS_((CONST char * name, 
				Tk_StyleEngine engine, ClientData clientData));
/* 254 */
EXTERN Tk_Style		Tk_GetStyle _ANSI_ARGS_((Tcl_Interp * interp, 
				CONST char * name));
/* 255 */
EXTERN void		Tk_FreeStyle _ANSI_ARGS_((Tk_Style style));
/* 256 */
EXTERN CONST char *	Tk_NameOfStyle _ANSI_ARGS_((Tk_Style style));
/* 257 */
EXTERN Tk_Style		Tk_AllocStyleFromObj _ANSI_ARGS_((
				Tcl_Interp * interp, Tcl_Obj * objPtr));
/* 258 */
EXTERN Tk_Style		Tk_GetStyleFromObj _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 259 */
EXTERN void		Tk_FreeStyleFromObj _ANSI_ARGS_((Tcl_Obj * objPtr));
/* 260 */
EXTERN Tk_StyledElement	 Tk_GetStyledElement _ANSI_ARGS_((Tk_Style style, 
				int elementId, Tk_OptionTable optionTable));
/* 261 */
EXTERN void		Tk_GetElementSize _ANSI_ARGS_((Tk_Style style, 
				Tk_StyledElement element, char * recordPtr, 
				Tk_Window tkwin, int width, int height, 
				int inner, int * widthPtr, int * heightPtr));
/* 262 */
EXTERN void		Tk_GetElementBox _ANSI_ARGS_((Tk_Style style, 
				Tk_StyledElement element, char * recordPtr, 
				Tk_Window tkwin, int x, int y, int width, 
				int height, int inner, int * xPtr, 
				int * yPtr, int * widthPtr, int * heightPtr));
/* 263 */
EXTERN int		Tk_GetElementBorderWidth _ANSI_ARGS_((Tk_Style style, 
				Tk_StyledElement element, char * recordPtr, 
				Tk_Window tkwin));
/* 264 */
EXTERN void		Tk_DrawElement _ANSI_ARGS_((Tk_Style style, 
				Tk_StyledElement element, char * recordPtr, 
				Tk_Window tkwin, Drawable d, int x, int y, 
				int width, int height, int state));

typedef struct TkStubHooks {
    struct TkPlatStubs *tkPlatStubs;
    struct TkIntStubs *tkIntStubs;
    struct TkIntPlatStubs *tkIntPlatStubs;
    struct TkIntXlibStubs *tkIntXlibStubs;
} TkStubHooks;

typedef struct TkStubs {
    int magic;
    struct TkStubHooks *hooks;

    void (*tk_MainLoop) _ANSI_ARGS_((void)); /* 0 */
    XColor * (*tk_3DBorderColor) _ANSI_ARGS_((Tk_3DBorder border)); /* 1 */
    GC (*tk_3DBorderGC) _ANSI_ARGS_((Tk_Window tkwin, Tk_3DBorder border, int which)); /* 2 */
    void (*tk_3DHorizontalBevel) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftIn, int rightIn, int topBevel, int relief)); /* 3 */
    void (*tk_3DVerticalBevel) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftBevel, int relief)); /* 4 */
    void (*tk_AddOption) _ANSI_ARGS_((Tk_Window tkwin, CONST char * name, CONST char * value, int priority)); /* 5 */
    void (*tk_BindEvent) _ANSI_ARGS_((Tk_BindingTable bindingTable, XEvent * eventPtr, Tk_Window tkwin, int numObjects, ClientData * objectPtr)); /* 6 */
    void (*tk_CanvasDrawableCoords) _ANSI_ARGS_((Tk_Canvas canvas, double x, double y, short * drawableXPtr, short * drawableYPtr)); /* 7 */
    void (*tk_CanvasEventuallyRedraw) _ANSI_ARGS_((Tk_Canvas canvas, int x1, int y1, int x2, int y2)); /* 8 */
    int (*tk_CanvasGetCoord) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, CONST char * str, double * doublePtr)); /* 9 */
    Tk_CanvasTextInfo * (*tk_CanvasGetTextInfo) _ANSI_ARGS_((Tk_Canvas canvas)); /* 10 */
    int (*tk_CanvasPsBitmap) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, Pixmap bitmap, int x, int y, int width, int height)); /* 11 */
    int (*tk_CanvasPsColor) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, XColor * colorPtr)); /* 12 */
    int (*tk_CanvasPsFont) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, Tk_Font font)); /* 13 */
    void (*tk_CanvasPsPath) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, double * coordPtr, int numPoints)); /* 14 */
    int (*tk_CanvasPsStipple) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, Pixmap bitmap)); /* 15 */
    double (*tk_CanvasPsY) _ANSI_ARGS_((Tk_Canvas canvas, double y)); /* 16 */
    void (*tk_CanvasSetStippleOrigin) _ANSI_ARGS_((Tk_Canvas canvas, GC gc)); /* 17 */
    int (*tk_CanvasTagsParseProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp * interp, Tk_Window tkwin, CONST char * value, char * widgRec, int offset)); /* 18 */
    char * (*tk_CanvasTagsPrintProc) _ANSI_ARGS_((ClientData clientData, Tk_Window tkwin, char * widgRec, int offset, Tcl_FreeProc ** freeProcPtr)); /* 19 */
    Tk_Window (*tk_CanvasTkwin) _ANSI_ARGS_((Tk_Canvas canvas)); /* 20 */
    void (*tk_CanvasWindowCoords) _ANSI_ARGS_((Tk_Canvas canvas, double x, double y, short * screenXPtr, short * screenYPtr)); /* 21 */
    void (*tk_ChangeWindowAttributes) _ANSI_ARGS_((Tk_Window tkwin, unsigned long valueMask, XSetWindowAttributes * attsPtr)); /* 22 */
    int (*tk_CharBbox) _ANSI_ARGS_((Tk_TextLayout layout, int index, int * xPtr, int * yPtr, int * widthPtr, int * heightPtr)); /* 23 */
    void (*tk_ClearSelection) _ANSI_ARGS_((Tk_Window tkwin, Atom selection)); /* 24 */
    int (*tk_ClipboardAppend) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Atom target, Atom format, char* buffer)); /* 25 */
    int (*tk_ClipboardClear) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin)); /* 26 */
    int (*tk_ConfigureInfo) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_ConfigSpec * specs, char * widgRec, CONST char * argvName, int flags)); /* 27 */
    int (*tk_ConfigureValue) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_ConfigSpec * specs, char * widgRec, CONST char * argvName, int flags)); /* 28 */
    int (*tk_ConfigureWidget) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_ConfigSpec * specs, int argc, CONST84 char ** argv, char * widgRec, int flags)); /* 29 */
    void (*tk_ConfigureWindow) _ANSI_ARGS_((Tk_Window tkwin, unsigned int valueMask, XWindowChanges * valuePtr)); /* 30 */
    Tk_TextLayout (*tk_ComputeTextLayout) _ANSI_ARGS_((Tk_Font font, CONST char * str, int numChars, int wrapLength, Tk_Justify justify, int flags, int * widthPtr, int * heightPtr)); /* 31 */
    Tk_Window (*tk_CoordsToWindow) _ANSI_ARGS_((int rootX, int rootY, Tk_Window tkwin)); /* 32 */
    unsigned long (*tk_CreateBinding) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventStr, CONST char * command, int append)); /* 33 */
    Tk_BindingTable (*tk_CreateBindingTable) _ANSI_ARGS_((Tcl_Interp * interp)); /* 34 */
    Tk_ErrorHandler (*tk_CreateErrorHandler) _ANSI_ARGS_((Display * display, int errNum, int request, int minorCode, Tk_ErrorProc * errorProc, ClientData clientData)); /* 35 */
    void (*tk_CreateEventHandler) _ANSI_ARGS_((Tk_Window token, unsigned long mask, Tk_EventProc * proc, ClientData clientData)); /* 36 */
    void (*tk_CreateGenericHandler) _ANSI_ARGS_((Tk_GenericProc * proc, ClientData clientData)); /* 37 */
    void (*tk_CreateImageType) _ANSI_ARGS_((Tk_ImageType * typePtr)); /* 38 */
    void (*tk_CreateItemType) _ANSI_ARGS_((Tk_ItemType * typePtr)); /* 39 */
    void (*tk_CreatePhotoImageFormat) _ANSI_ARGS_((Tk_PhotoImageFormat * formatPtr)); /* 40 */
    void (*tk_CreateSelHandler) _ANSI_ARGS_((Tk_Window tkwin, Atom selection, Atom target, Tk_SelectionProc * proc, ClientData clientData, Atom format)); /* 41 */
    Tk_Window (*tk_CreateWindow) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window parent, CONST char * name, CONST char * screenName)); /* 42 */
    Tk_Window (*tk_CreateWindowFromPath) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * pathName, CONST char * screenName)); /* 43 */
    int (*tk_DefineBitmap) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, CONST char * source, int width, int height)); /* 44 */
    void (*tk_DefineCursor) _ANSI_ARGS_((Tk_Window window, Tk_Cursor cursor)); /* 45 */
    void (*tk_DeleteAllBindings) _ANSI_ARGS_((Tk_BindingTable bindingTable, ClientData object)); /* 46 */
    int (*tk_DeleteBinding) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventStr)); /* 47 */
    void (*tk_DeleteBindingTable) _ANSI_ARGS_((Tk_BindingTable bindingTable)); /* 48 */
    void (*tk_DeleteErrorHandler) _ANSI_ARGS_((Tk_ErrorHandler handler)); /* 49 */
    void (*tk_DeleteEventHandler) _ANSI_ARGS_((Tk_Window token, unsigned long mask, Tk_EventProc * proc, ClientData clientData)); /* 50 */
    void (*tk_DeleteGenericHandler) _ANSI_ARGS_((Tk_GenericProc * proc, ClientData clientData)); /* 51 */
    void (*tk_DeleteImage) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 52 */
    void (*tk_DeleteSelHandler) _ANSI_ARGS_((Tk_Window tkwin, Atom selection, Atom target)); /* 53 */
    void (*tk_DestroyWindow) _ANSI_ARGS_((Tk_Window tkwin)); /* 54 */
    CONST84_RETURN char * (*tk_DisplayName) _ANSI_ARGS_((Tk_Window tkwin)); /* 55 */
    int (*tk_DistanceToTextLayout) _ANSI_ARGS_((Tk_TextLayout layout, int x, int y)); /* 56 */
    void (*tk_Draw3DPolygon) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint * pointPtr, int numPoints, int borderWidth, int leftRelief)); /* 57 */
    void (*tk_Draw3DRectangle) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief)); /* 58 */
    void (*tk_DrawChars) _ANSI_ARGS_((Display * display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char * source, int numBytes, int x, int y)); /* 59 */
    void (*tk_DrawFocusHighlight) _ANSI_ARGS_((Tk_Window tkwin, GC gc, int width, Drawable drawable)); /* 60 */
    void (*tk_DrawTextLayout) _ANSI_ARGS_((Display * display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int firstChar, int lastChar)); /* 61 */
    void (*tk_Fill3DPolygon) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint * pointPtr, int numPoints, int borderWidth, int leftRelief)); /* 62 */
    void (*tk_Fill3DRectangle) _ANSI_ARGS_((Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief)); /* 63 */
    Tk_PhotoHandle (*tk_FindPhoto) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * imageName)); /* 64 */
    Font (*tk_FontId) _ANSI_ARGS_((Tk_Font font)); /* 65 */
    void (*tk_Free3DBorder) _ANSI_ARGS_((Tk_3DBorder border)); /* 66 */
    void (*tk_FreeBitmap) _ANSI_ARGS_((Display * display, Pixmap bitmap)); /* 67 */
    void (*tk_FreeColor) _ANSI_ARGS_((XColor * colorPtr)); /* 68 */
    void (*tk_FreeColormap) _ANSI_ARGS_((Display * display, Colormap colormap)); /* 69 */
    void (*tk_FreeCursor) _ANSI_ARGS_((Display * display, Tk_Cursor cursor)); /* 70 */
    void (*tk_FreeFont) _ANSI_ARGS_((Tk_Font f)); /* 71 */
    void (*tk_FreeGC) _ANSI_ARGS_((Display * display, GC gc)); /* 72 */
    void (*tk_FreeImage) _ANSI_ARGS_((Tk_Image image)); /* 73 */
    void (*tk_FreeOptions) _ANSI_ARGS_((Tk_ConfigSpec * specs, char * widgRec, Display * display, int needFlags)); /* 74 */
    void (*tk_FreePixmap) _ANSI_ARGS_((Display * display, Pixmap pixmap)); /* 75 */
    void (*tk_FreeTextLayout) _ANSI_ARGS_((Tk_TextLayout textLayout)); /* 76 */
    void (*tk_FreeXId) _ANSI_ARGS_((Display * display, XID xid)); /* 77 */
    GC (*tk_GCForColor) _ANSI_ARGS_((XColor * colorPtr, Drawable drawable)); /* 78 */
    void (*tk_GeometryRequest) _ANSI_ARGS_((Tk_Window tkwin, int reqWidth, int reqHeight)); /* 79 */
    Tk_3DBorder (*tk_Get3DBorder) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid colorName)); /* 80 */
    void (*tk_GetAllBindings) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object)); /* 81 */
    int (*tk_GetAnchor) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, Tk_Anchor * anchorPtr)); /* 82 */
    CONST84_RETURN char * (*tk_GetAtomName) _ANSI_ARGS_((Tk_Window tkwin, Atom atom)); /* 83 */
    CONST84_RETURN char * (*tk_GetBinding) _ANSI_ARGS_((Tcl_Interp * interp, Tk_BindingTable bindingTable, ClientData object, CONST char * eventStr)); /* 84 */
    Pixmap (*tk_GetBitmap) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str)); /* 85 */
    Pixmap (*tk_GetBitmapFromData) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * source, int width, int height)); /* 86 */
    int (*tk_GetCapStyle) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * capPtr)); /* 87 */
    XColor * (*tk_GetColor) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid name)); /* 88 */
    XColor * (*tk_GetColorByValue) _ANSI_ARGS_((Tk_Window tkwin, XColor * colorPtr)); /* 89 */
    Colormap (*tk_GetColormap) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str)); /* 90 */
    Tk_Cursor (*tk_GetCursor) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_Uid str)); /* 91 */
    Tk_Cursor (*tk_GetCursorFromData) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * source, CONST char * mask, int width, int height, int xHot, int yHot, Tk_Uid fg, Tk_Uid bg)); /* 92 */
    Tk_Font (*tk_GetFont) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str)); /* 93 */
    Tk_Font (*tk_GetFontFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 94 */
    void (*tk_GetFontMetrics) _ANSI_ARGS_((Tk_Font font, Tk_FontMetrics * fmPtr)); /* 95 */
    GC (*tk_GetGC) _ANSI_ARGS_((Tk_Window tkwin, unsigned long valueMask, XGCValues * valuePtr)); /* 96 */
    Tk_Image (*tk_GetImage) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * name, Tk_ImageChangedProc * changeProc, ClientData clientData)); /* 97 */
    ClientData (*tk_GetImageMasterData) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, Tk_ImageType ** typePtrPtr)); /* 98 */
    Tk_ItemType * (*tk_GetItemTypes) _ANSI_ARGS_((void)); /* 99 */
    int (*tk_GetJoinStyle) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, int * joinPtr)); /* 100 */
    int (*tk_GetJustify) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * str, Tk_Justify * justifyPtr)); /* 101 */
    int (*tk_GetNumMainWindows) _ANSI_ARGS_((void)); /* 102 */
    Tk_Uid (*tk_GetOption) _ANSI_ARGS_((Tk_Window tkwin, CONST char * name, CONST char * className)); /* 103 */
    int (*tk_GetPixels) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str, int * intPtr)); /* 104 */
    Pixmap (*tk_GetPixmap) _ANSI_ARGS_((Display * display, Drawable d, int width, int height, int depth)); /* 105 */
    int (*tk_GetRelief) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name, int * reliefPtr)); /* 106 */
    void (*tk_GetRootCoords) _ANSI_ARGS_((Tk_Window tkwin, int * xPtr, int * yPtr)); /* 107 */
    int (*tk_GetScrollInfo) _ANSI_ARGS_((Tcl_Interp * interp, int argc, CONST84 char ** argv, double * dblPtr, int * intPtr)); /* 108 */
    int (*tk_GetScreenMM) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str, double * doublePtr)); /* 109 */
    int (*tk_GetSelection) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc * proc, ClientData clientData)); /* 110 */
    Tk_Uid (*tk_GetUid) _ANSI_ARGS_((CONST char * str)); /* 111 */
    Visual * (*tk_GetVisual) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, CONST char * str, int * depthPtr, Colormap * colormapPtr)); /* 112 */
    void (*tk_GetVRootGeometry) _ANSI_ARGS_((Tk_Window tkwin, int * xPtr, int * yPtr, int * widthPtr, int * heightPtr)); /* 113 */
    int (*tk_Grab) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, int grabGlobal)); /* 114 */
    void (*tk_HandleEvent) _ANSI_ARGS_((XEvent * eventPtr)); /* 115 */
    Tk_Window (*tk_IdToWindow) _ANSI_ARGS_((Display * display, Window window)); /* 116 */
    void (*tk_ImageChanged) _ANSI_ARGS_((Tk_ImageMaster master, int x, int y, int width, int height, int imageWidth, int imageHeight)); /* 117 */
    int (*tk_Init) _ANSI_ARGS_((Tcl_Interp * interp)); /* 118 */
    Atom (*tk_InternAtom) _ANSI_ARGS_((Tk_Window tkwin, CONST char * name)); /* 119 */
    int (*tk_IntersectTextLayout) _ANSI_ARGS_((Tk_TextLayout layout, int x, int y, int width, int height)); /* 120 */
    void (*tk_MaintainGeometry) _ANSI_ARGS_((Tk_Window slave, Tk_Window master, int x, int y, int width, int height)); /* 121 */
    Tk_Window (*tk_MainWindow) _ANSI_ARGS_((Tcl_Interp * interp)); /* 122 */
    void (*tk_MakeWindowExist) _ANSI_ARGS_((Tk_Window tkwin)); /* 123 */
    void (*tk_ManageGeometry) _ANSI_ARGS_((Tk_Window tkwin, Tk_GeomMgr * mgrPtr, ClientData clientData)); /* 124 */
    void (*tk_MapWindow) _ANSI_ARGS_((Tk_Window tkwin)); /* 125 */
    int (*tk_MeasureChars) _ANSI_ARGS_((Tk_Font tkfont, CONST char * source, int numBytes, int maxPixels, int flags, int * lengthPtr)); /* 126 */
    void (*tk_MoveResizeWindow) _ANSI_ARGS_((Tk_Window tkwin, int x, int y, int width, int height)); /* 127 */
    void (*tk_MoveWindow) _ANSI_ARGS_((Tk_Window tkwin, int x, int y)); /* 128 */
    void (*tk_MoveToplevelWindow) _ANSI_ARGS_((Tk_Window tkwin, int x, int y)); /* 129 */
    CONST84_RETURN char * (*tk_NameOf3DBorder) _ANSI_ARGS_((Tk_3DBorder border)); /* 130 */
    CONST84_RETURN char * (*tk_NameOfAnchor) _ANSI_ARGS_((Tk_Anchor anchor)); /* 131 */
    CONST84_RETURN char * (*tk_NameOfBitmap) _ANSI_ARGS_((Display * display, Pixmap bitmap)); /* 132 */
    CONST84_RETURN char * (*tk_NameOfCapStyle) _ANSI_ARGS_((int cap)); /* 133 */
    CONST84_RETURN char * (*tk_NameOfColor) _ANSI_ARGS_((XColor * colorPtr)); /* 134 */
    CONST84_RETURN char * (*tk_NameOfCursor) _ANSI_ARGS_((Display * display, Tk_Cursor cursor)); /* 135 */
    CONST84_RETURN char * (*tk_NameOfFont) _ANSI_ARGS_((Tk_Font font)); /* 136 */
    CONST84_RETURN char * (*tk_NameOfImage) _ANSI_ARGS_((Tk_ImageMaster imageMaster)); /* 137 */
    CONST84_RETURN char * (*tk_NameOfJoinStyle) _ANSI_ARGS_((int join)); /* 138 */
    CONST84_RETURN char * (*tk_NameOfJustify) _ANSI_ARGS_((Tk_Justify justify)); /* 139 */
    CONST84_RETURN char * (*tk_NameOfRelief) _ANSI_ARGS_((int relief)); /* 140 */
    Tk_Window (*tk_NameToWindow) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * pathName, Tk_Window tkwin)); /* 141 */
    void (*tk_OwnSelection) _ANSI_ARGS_((Tk_Window tkwin, Atom selection, Tk_LostSelProc * proc, ClientData clientData)); /* 142 */
    int (*tk_ParseArgv) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, int * argcPtr, CONST84 char ** argv, Tk_ArgvInfo * argTable, int flags)); /* 143 */
    void (*tk_PhotoPutBlock_NoComposite) _ANSI_ARGS_((Tk_PhotoHandle handle, Tk_PhotoImageBlock * blockPtr, int x, int y, int width, int height)); /* 144 */
    void (*tk_PhotoPutZoomedBlock_NoComposite) _ANSI_ARGS_((Tk_PhotoHandle handle, Tk_PhotoImageBlock * blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY)); /* 145 */
    int (*tk_PhotoGetImage) _ANSI_ARGS_((Tk_PhotoHandle handle, Tk_PhotoImageBlock * blockPtr)); /* 146 */
    void (*tk_PhotoBlank) _ANSI_ARGS_((Tk_PhotoHandle handle)); /* 147 */
    void (*tk_PhotoExpand) _ANSI_ARGS_((Tk_PhotoHandle handle, int width, int height)); /* 148 */
    void (*tk_PhotoGetSize) _ANSI_ARGS_((Tk_PhotoHandle handle, int * widthPtr, int * heightPtr)); /* 149 */
    void (*tk_PhotoSetSize) _ANSI_ARGS_((Tk_PhotoHandle handle, int width, int height)); /* 150 */
    int (*tk_PointToChar) _ANSI_ARGS_((Tk_TextLayout layout, int x, int y)); /* 151 */
    int (*tk_PostscriptFontName) _ANSI_ARGS_((Tk_Font tkfont, Tcl_DString * dsPtr)); /* 152 */
    void (*tk_PreserveColormap) _ANSI_ARGS_((Display * display, Colormap colormap)); /* 153 */
    void (*tk_QueueWindowEvent) _ANSI_ARGS_((XEvent * eventPtr, Tcl_QueuePosition position)); /* 154 */
    void (*tk_RedrawImage) _ANSI_ARGS_((Tk_Image image, int imageX, int imageY, int width, int height, Drawable drawable, int drawableX, int drawableY)); /* 155 */
    void (*tk_ResizeWindow) _ANSI_ARGS_((Tk_Window tkwin, int width, int height)); /* 156 */
    int (*tk_RestackWindow) _ANSI_ARGS_((Tk_Window tkwin, int aboveBelow, Tk_Window other)); /* 157 */
    Tk_RestrictProc * (*tk_RestrictEvents) _ANSI_ARGS_((Tk_RestrictProc * proc, ClientData arg, ClientData * prevArgPtr)); /* 158 */
    int (*tk_SafeInit) _ANSI_ARGS_((Tcl_Interp * interp)); /* 159 */
    CONST char * (*tk_SetAppName) _ANSI_ARGS_((Tk_Window tkwin, CONST char * name)); /* 160 */
    void (*tk_SetBackgroundFromBorder) _ANSI_ARGS_((Tk_Window tkwin, Tk_3DBorder border)); /* 161 */
    void (*tk_SetClass) _ANSI_ARGS_((Tk_Window tkwin, CONST char * className)); /* 162 */
    void (*tk_SetGrid) _ANSI_ARGS_((Tk_Window tkwin, int reqWidth, int reqHeight, int gridWidth, int gridHeight)); /* 163 */
    void (*tk_SetInternalBorder) _ANSI_ARGS_((Tk_Window tkwin, int width)); /* 164 */
    void (*tk_SetWindowBackground) _ANSI_ARGS_((Tk_Window tkwin, unsigned long pixel)); /* 165 */
    void (*tk_SetWindowBackgroundPixmap) _ANSI_ARGS_((Tk_Window tkwin, Pixmap pixmap)); /* 166 */
    void (*tk_SetWindowBorder) _ANSI_ARGS_((Tk_Window tkwin, unsigned long pixel)); /* 167 */
    void (*tk_SetWindowBorderWidth) _ANSI_ARGS_((Tk_Window tkwin, int width)); /* 168 */
    void (*tk_SetWindowBorderPixmap) _ANSI_ARGS_((Tk_Window tkwin, Pixmap pixmap)); /* 169 */
    void (*tk_SetWindowColormap) _ANSI_ARGS_((Tk_Window tkwin, Colormap colormap)); /* 170 */
    int (*tk_SetWindowVisual) _ANSI_ARGS_((Tk_Window tkwin, Visual * visual, int depth, Colormap colormap)); /* 171 */
    void (*tk_SizeOfBitmap) _ANSI_ARGS_((Display * display, Pixmap bitmap, int * widthPtr, int * heightPtr)); /* 172 */
    void (*tk_SizeOfImage) _ANSI_ARGS_((Tk_Image image, int * widthPtr, int * heightPtr)); /* 173 */
    int (*tk_StrictMotif) _ANSI_ARGS_((Tk_Window tkwin)); /* 174 */
    void (*tk_TextLayoutToPostscript) _ANSI_ARGS_((Tcl_Interp * interp, Tk_TextLayout layout)); /* 175 */
    int (*tk_TextWidth) _ANSI_ARGS_((Tk_Font font, CONST char * str, int numBytes)); /* 176 */
    void (*tk_UndefineCursor) _ANSI_ARGS_((Tk_Window window)); /* 177 */
    void (*tk_UnderlineChars) _ANSI_ARGS_((Display * display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char * source, int x, int y, int firstByte, int lastByte)); /* 178 */
    void (*tk_UnderlineTextLayout) _ANSI_ARGS_((Display * display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int underline)); /* 179 */
    void (*tk_Ungrab) _ANSI_ARGS_((Tk_Window tkwin)); /* 180 */
    void (*tk_UnmaintainGeometry) _ANSI_ARGS_((Tk_Window slave, Tk_Window master)); /* 181 */
    void (*tk_UnmapWindow) _ANSI_ARGS_((Tk_Window tkwin)); /* 182 */
    void (*tk_UnsetGrid) _ANSI_ARGS_((Tk_Window tkwin)); /* 183 */
    void (*tk_UpdatePointer) _ANSI_ARGS_((Tk_Window tkwin, int x, int y, int state)); /* 184 */
    Pixmap (*tk_AllocBitmapFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr)); /* 185 */
    Tk_3DBorder (*tk_Alloc3DBorderFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr)); /* 186 */
    XColor * (*tk_AllocColorFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr)); /* 187 */
    Tk_Cursor (*tk_AllocCursorFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr)); /* 188 */
    Tk_Font (*tk_AllocFontFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr)); /* 189 */
    Tk_OptionTable (*tk_CreateOptionTable) _ANSI_ARGS_((Tcl_Interp * interp, CONST Tk_OptionSpec * templatePtr)); /* 190 */
    void (*tk_DeleteOptionTable) _ANSI_ARGS_((Tk_OptionTable optionTable)); /* 191 */
    void (*tk_Free3DBorderFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 192 */
    void (*tk_FreeBitmapFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 193 */
    void (*tk_FreeColorFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 194 */
    void (*tk_FreeConfigOptions) _ANSI_ARGS_((char * recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin)); /* 195 */
    void (*tk_FreeSavedOptions) _ANSI_ARGS_((Tk_SavedOptions * savePtr)); /* 196 */
    void (*tk_FreeCursorFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 197 */
    void (*tk_FreeFontFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 198 */
    Tk_3DBorder (*tk_Get3DBorderFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 199 */
    int (*tk_GetAnchorFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, Tk_Anchor * anchorPtr)); /* 200 */
    Pixmap (*tk_GetBitmapFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 201 */
    XColor * (*tk_GetColorFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 202 */
    Tk_Cursor (*tk_GetCursorFromObj) _ANSI_ARGS_((Tk_Window tkwin, Tcl_Obj * objPtr)); /* 203 */
    Tcl_Obj * (*tk_GetOptionInfo) _ANSI_ARGS_((Tcl_Interp * interp, char * recordPtr, Tk_OptionTable optionTable, Tcl_Obj * namePtr, Tk_Window tkwin)); /* 204 */
    Tcl_Obj * (*tk_GetOptionValue) _ANSI_ARGS_((Tcl_Interp * interp, char * recordPtr, Tk_OptionTable optionTable, Tcl_Obj * namePtr, Tk_Window tkwin)); /* 205 */
    int (*tk_GetJustifyFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, Tk_Justify * justifyPtr)); /* 206 */
    int (*tk_GetMMFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr, double * doublePtr)); /* 207 */
    int (*tk_GetPixelsFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tcl_Obj * objPtr, int * intPtr)); /* 208 */
    int (*tk_GetReliefFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr, int * resultPtr)); /* 209 */
    int (*tk_GetScrollInfoObj) _ANSI_ARGS_((Tcl_Interp * interp, int objc, Tcl_Obj *CONST objv[], double * dblPtr, int * intPtr)); /* 210 */
    int (*tk_InitOptions) _ANSI_ARGS_((Tcl_Interp * interp, char * recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin)); /* 211 */
    void (*tk_MainEx) _ANSI_ARGS_((int argc, char ** argv, Tcl_AppInitProc * appInitProc, Tcl_Interp * interp)); /* 212 */
    void (*tk_RestoreSavedOptions) _ANSI_ARGS_((Tk_SavedOptions * savePtr)); /* 213 */
    int (*tk_SetOptions) _ANSI_ARGS_((Tcl_Interp * interp, char * recordPtr, Tk_OptionTable optionTable, int objc, Tcl_Obj *CONST objv[], Tk_Window tkwin, Tk_SavedOptions * savePtr, int * maskPtr)); /* 214 */
    void (*tk_InitConsoleChannels) _ANSI_ARGS_((Tcl_Interp * interp)); /* 215 */
    int (*tk_CreateConsoleWindow) _ANSI_ARGS_((Tcl_Interp * interp)); /* 216 */
    void (*tk_CreateSmoothMethod) _ANSI_ARGS_((Tcl_Interp * interp, Tk_SmoothMethod * method)); /* 217 */
    void *reserved218;
    void *reserved219;
    int (*tk_GetDash) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * value, Tk_Dash * dash)); /* 220 */
    void (*tk_CreateOutline) _ANSI_ARGS_((Tk_Outline * outline)); /* 221 */
    void (*tk_DeleteOutline) _ANSI_ARGS_((Display * display, Tk_Outline * outline)); /* 222 */
    int (*tk_ConfigOutlineGC) _ANSI_ARGS_((XGCValues * gcValues, Tk_Canvas canvas, Tk_Item * item, Tk_Outline * outline)); /* 223 */
    int (*tk_ChangeOutlineGC) _ANSI_ARGS_((Tk_Canvas canvas, Tk_Item * item, Tk_Outline * outline)); /* 224 */
    int (*tk_ResetOutlineGC) _ANSI_ARGS_((Tk_Canvas canvas, Tk_Item * item, Tk_Outline * outline)); /* 225 */
    int (*tk_CanvasPsOutline) _ANSI_ARGS_((Tk_Canvas canvas, Tk_Item * item, Tk_Outline * outline)); /* 226 */
    void (*tk_SetTSOrigin) _ANSI_ARGS_((Tk_Window tkwin, GC gc, int x, int y)); /* 227 */
    int (*tk_CanvasGetCoordFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Canvas canvas, Tcl_Obj * obj, double * doublePtr)); /* 228 */
    void (*tk_CanvasSetOffset) _ANSI_ARGS_((Tk_Canvas canvas, GC gc, Tk_TSOffset * offset)); /* 229 */
    void (*tk_DitherPhoto) _ANSI_ARGS_((Tk_PhotoHandle handle, int x, int y, int width, int height)); /* 230 */
    int (*tk_PostscriptBitmap) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap, int startX, int startY, int width, int height)); /* 231 */
    int (*tk_PostscriptColor) _ANSI_ARGS_((Tcl_Interp * interp, Tk_PostscriptInfo psInfo, XColor * colorPtr)); /* 232 */
    int (*tk_PostscriptFont) _ANSI_ARGS_((Tcl_Interp * interp, Tk_PostscriptInfo psInfo, Tk_Font font)); /* 233 */
    int (*tk_PostscriptImage) _ANSI_ARGS_((Tk_Image image, Tcl_Interp * interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo, int x, int y, int width, int height, int prepass)); /* 234 */
    void (*tk_PostscriptPath) _ANSI_ARGS_((Tcl_Interp * interp, Tk_PostscriptInfo psInfo, double * coordPtr, int numPoints)); /* 235 */
    int (*tk_PostscriptStipple) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap)); /* 236 */
    double (*tk_PostscriptY) _ANSI_ARGS_((double y, Tk_PostscriptInfo psInfo)); /* 237 */
    int (*tk_PostscriptPhoto) _ANSI_ARGS_((Tcl_Interp * interp, Tk_PhotoImageBlock * blockPtr, Tk_PostscriptInfo psInfo, int width, int height)); /* 238 */
    void (*tk_CreateClientMessageHandler) _ANSI_ARGS_((Tk_ClientMessageProc * proc)); /* 239 */
    void (*tk_DeleteClientMessageHandler) _ANSI_ARGS_((Tk_ClientMessageProc * proc)); /* 240 */
    Tk_Window (*tk_CreateAnonymousWindow) _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window parent, CONST char * screenName)); /* 241 */
    void (*tk_SetClassProcs) _ANSI_ARGS_((Tk_Window tkwin, Tk_ClassProcs * procs, ClientData instanceData)); /* 242 */
    void (*tk_SetInternalBorderEx) _ANSI_ARGS_((Tk_Window tkwin, int left, int right, int top, int bottom)); /* 243 */
    void (*tk_SetMinimumRequestSize) _ANSI_ARGS_((Tk_Window tkwin, int minWidth, int minHeight)); /* 244 */
    void (*tk_SetCaretPos) _ANSI_ARGS_((Tk_Window tkwin, int x, int y, int height)); /* 245 */
    void (*tk_PhotoPutBlock) _ANSI_ARGS_((Tk_PhotoHandle handle, Tk_PhotoImageBlock * blockPtr, int x, int y, int width, int height, int compRule)); /* 246 */
    void (*tk_PhotoPutZoomedBlock) _ANSI_ARGS_((Tk_PhotoHandle handle, Tk_PhotoImageBlock * blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule)); /* 247 */
    int (*tk_CollapseMotionEvents) _ANSI_ARGS_((Display * display, int collapse)); /* 248 */
    Tk_StyleEngine (*tk_RegisterStyleEngine) _ANSI_ARGS_((CONST char * name, Tk_StyleEngine parent)); /* 249 */
    Tk_StyleEngine (*tk_GetStyleEngine) _ANSI_ARGS_((CONST char * name)); /* 250 */
    int (*tk_RegisterStyledElement) _ANSI_ARGS_((Tk_StyleEngine engine, Tk_ElementSpec * templatePtr)); /* 251 */
    int (*tk_GetElementId) _ANSI_ARGS_((CONST char * name)); /* 252 */
    Tk_Style (*tk_CreateStyle) _ANSI_ARGS_((CONST char * name, Tk_StyleEngine engine, ClientData clientData)); /* 253 */
    Tk_Style (*tk_GetStyle) _ANSI_ARGS_((Tcl_Interp * interp, CONST char * name)); /* 254 */
    void (*tk_FreeStyle) _ANSI_ARGS_((Tk_Style style)); /* 255 */
    CONST char * (*tk_NameOfStyle) _ANSI_ARGS_((Tk_Style style)); /* 256 */
    Tk_Style (*tk_AllocStyleFromObj) _ANSI_ARGS_((Tcl_Interp * interp, Tcl_Obj * objPtr)); /* 257 */
    Tk_Style (*tk_GetStyleFromObj) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 258 */
    void (*tk_FreeStyleFromObj) _ANSI_ARGS_((Tcl_Obj * objPtr)); /* 259 */
    Tk_StyledElement (*tk_GetStyledElement) _ANSI_ARGS_((Tk_Style style, int elementId, Tk_OptionTable optionTable)); /* 260 */
    void (*tk_GetElementSize) _ANSI_ARGS_((Tk_Style style, Tk_StyledElement element, char * recordPtr, Tk_Window tkwin, int width, int height, int inner, int * widthPtr, int * heightPtr)); /* 261 */
    void (*tk_GetElementBox) _ANSI_ARGS_((Tk_Style style, Tk_StyledElement element, char * recordPtr, Tk_Window tkwin, int x, int y, int width, int height, int inner, int * xPtr, int * yPtr, int * widthPtr, int * heightPtr)); /* 262 */
    int (*tk_GetElementBorderWidth) _ANSI_ARGS_((Tk_Style style, Tk_StyledElement element, char * recordPtr, Tk_Window tkwin)); /* 263 */
    void (*tk_DrawElement) _ANSI_ARGS_((Tk_Style style, Tk_StyledElement element, char * recordPtr, Tk_Window tkwin, Drawable d, int x, int y, int width, int height, int state)); /* 264 */
} TkStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkStubs *tkStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifndef Tk_MainLoop
#define Tk_MainLoop \
	(tkStubsPtr->tk_MainLoop) /* 0 */
#endif
#ifndef Tk_3DBorderColor
#define Tk_3DBorderColor \
	(tkStubsPtr->tk_3DBorderColor) /* 1 */
#endif
#ifndef Tk_3DBorderGC
#define Tk_3DBorderGC \
	(tkStubsPtr->tk_3DBorderGC) /* 2 */
#endif
#ifndef Tk_3DHorizontalBevel
#define Tk_3DHorizontalBevel \
	(tkStubsPtr->tk_3DHorizontalBevel) /* 3 */
#endif
#ifndef Tk_3DVerticalBevel
#define Tk_3DVerticalBevel \
	(tkStubsPtr->tk_3DVerticalBevel) /* 4 */
#endif
#ifndef Tk_AddOption
#define Tk_AddOption \
	(tkStubsPtr->tk_AddOption) /* 5 */
#endif
#ifndef Tk_BindEvent
#define Tk_BindEvent \
	(tkStubsPtr->tk_BindEvent) /* 6 */
#endif
#ifndef Tk_CanvasDrawableCoords
#define Tk_CanvasDrawableCoords \
	(tkStubsPtr->tk_CanvasDrawableCoords) /* 7 */
#endif
#ifndef Tk_CanvasEventuallyRedraw
#define Tk_CanvasEventuallyRedraw \
	(tkStubsPtr->tk_CanvasEventuallyRedraw) /* 8 */
#endif
#ifndef Tk_CanvasGetCoord
#define Tk_CanvasGetCoord \
	(tkStubsPtr->tk_CanvasGetCoord) /* 9 */
#endif
#ifndef Tk_CanvasGetTextInfo
#define Tk_CanvasGetTextInfo \
	(tkStubsPtr->tk_CanvasGetTextInfo) /* 10 */
#endif
#ifndef Tk_CanvasPsBitmap
#define Tk_CanvasPsBitmap \
	(tkStubsPtr->tk_CanvasPsBitmap) /* 11 */
#endif
#ifndef Tk_CanvasPsColor
#define Tk_CanvasPsColor \
	(tkStubsPtr->tk_CanvasPsColor) /* 12 */
#endif
#ifndef Tk_CanvasPsFont
#define Tk_CanvasPsFont \
	(tkStubsPtr->tk_CanvasPsFont) /* 13 */
#endif
#ifndef Tk_CanvasPsPath
#define Tk_CanvasPsPath \
	(tkStubsPtr->tk_CanvasPsPath) /* 14 */
#endif
#ifndef Tk_CanvasPsStipple
#define Tk_CanvasPsStipple \
	(tkStubsPtr->tk_CanvasPsStipple) /* 15 */
#endif
#ifndef Tk_CanvasPsY
#define Tk_CanvasPsY \
	(tkStubsPtr->tk_CanvasPsY) /* 16 */
#endif
#ifndef Tk_CanvasSetStippleOrigin
#define Tk_CanvasSetStippleOrigin \
	(tkStubsPtr->tk_CanvasSetStippleOrigin) /* 17 */
#endif
#ifndef Tk_CanvasTagsParseProc
#define Tk_CanvasTagsParseProc \
	(tkStubsPtr->tk_CanvasTagsParseProc) /* 18 */
#endif
#ifndef Tk_CanvasTagsPrintProc
#define Tk_CanvasTagsPrintProc \
	(tkStubsPtr->tk_CanvasTagsPrintProc) /* 19 */
#endif
#ifndef Tk_CanvasTkwin
#define Tk_CanvasTkwin \
	(tkStubsPtr->tk_CanvasTkwin) /* 20 */
#endif
#ifndef Tk_CanvasWindowCoords
#define Tk_CanvasWindowCoords \
	(tkStubsPtr->tk_CanvasWindowCoords) /* 21 */
#endif
#ifndef Tk_ChangeWindowAttributes
#define Tk_ChangeWindowAttributes \
	(tkStubsPtr->tk_ChangeWindowAttributes) /* 22 */
#endif
#ifndef Tk_CharBbox
#define Tk_CharBbox \
	(tkStubsPtr->tk_CharBbox) /* 23 */
#endif
#ifndef Tk_ClearSelection
#define Tk_ClearSelection \
	(tkStubsPtr->tk_ClearSelection) /* 24 */
#endif
#ifndef Tk_ClipboardAppend
#define Tk_ClipboardAppend \
	(tkStubsPtr->tk_ClipboardAppend) /* 25 */
#endif
#ifndef Tk_ClipboardClear
#define Tk_ClipboardClear \
	(tkStubsPtr->tk_ClipboardClear) /* 26 */
#endif
#ifndef Tk_ConfigureInfo
#define Tk_ConfigureInfo \
	(tkStubsPtr->tk_ConfigureInfo) /* 27 */
#endif
#ifndef Tk_ConfigureValue
#define Tk_ConfigureValue \
	(tkStubsPtr->tk_ConfigureValue) /* 28 */
#endif
#ifndef Tk_ConfigureWidget
#define Tk_ConfigureWidget \
	(tkStubsPtr->tk_ConfigureWidget) /* 29 */
#endif
#ifndef Tk_ConfigureWindow
#define Tk_ConfigureWindow \
	(tkStubsPtr->tk_ConfigureWindow) /* 30 */
#endif
#ifndef Tk_ComputeTextLayout
#define Tk_ComputeTextLayout \
	(tkStubsPtr->tk_ComputeTextLayout) /* 31 */
#endif
#ifndef Tk_CoordsToWindow
#define Tk_CoordsToWindow \
	(tkStubsPtr->tk_CoordsToWindow) /* 32 */
#endif
#ifndef Tk_CreateBinding
#define Tk_CreateBinding \
	(tkStubsPtr->tk_CreateBinding) /* 33 */
#endif
#ifndef Tk_CreateBindingTable
#define Tk_CreateBindingTable \
	(tkStubsPtr->tk_CreateBindingTable) /* 34 */
#endif
#ifndef Tk_CreateErrorHandler
#define Tk_CreateErrorHandler \
	(tkStubsPtr->tk_CreateErrorHandler) /* 35 */
#endif
#ifndef Tk_CreateEventHandler
#define Tk_CreateEventHandler \
	(tkStubsPtr->tk_CreateEventHandler) /* 36 */
#endif
#ifndef Tk_CreateGenericHandler
#define Tk_CreateGenericHandler \
	(tkStubsPtr->tk_CreateGenericHandler) /* 37 */
#endif
#ifndef Tk_CreateImageType
#define Tk_CreateImageType \
	(tkStubsPtr->tk_CreateImageType) /* 38 */
#endif
#ifndef Tk_CreateItemType
#define Tk_CreateItemType \
	(tkStubsPtr->tk_CreateItemType) /* 39 */
#endif
#ifndef Tk_CreatePhotoImageFormat
#define Tk_CreatePhotoImageFormat \
	(tkStubsPtr->tk_CreatePhotoImageFormat) /* 40 */
#endif
#ifndef Tk_CreateSelHandler
#define Tk_CreateSelHandler \
	(tkStubsPtr->tk_CreateSelHandler) /* 41 */
#endif
#ifndef Tk_CreateWindow
#define Tk_CreateWindow \
	(tkStubsPtr->tk_CreateWindow) /* 42 */
#endif
#ifndef Tk_CreateWindowFromPath
#define Tk_CreateWindowFromPath \
	(tkStubsPtr->tk_CreateWindowFromPath) /* 43 */
#endif
#ifndef Tk_DefineBitmap
#define Tk_DefineBitmap \
	(tkStubsPtr->tk_DefineBitmap) /* 44 */
#endif
#ifndef Tk_DefineCursor
#define Tk_DefineCursor \
	(tkStubsPtr->tk_DefineCursor) /* 45 */
#endif
#ifndef Tk_DeleteAllBindings
#define Tk_DeleteAllBindings \
	(tkStubsPtr->tk_DeleteAllBindings) /* 46 */
#endif
#ifndef Tk_DeleteBinding
#define Tk_DeleteBinding \
	(tkStubsPtr->tk_DeleteBinding) /* 47 */
#endif
#ifndef Tk_DeleteBindingTable
#define Tk_DeleteBindingTable \
	(tkStubsPtr->tk_DeleteBindingTable) /* 48 */
#endif
#ifndef Tk_DeleteErrorHandler
#define Tk_DeleteErrorHandler \
	(tkStubsPtr->tk_DeleteErrorHandler) /* 49 */
#endif
#ifndef Tk_DeleteEventHandler
#define Tk_DeleteEventHandler \
	(tkStubsPtr->tk_DeleteEventHandler) /* 50 */
#endif
#ifndef Tk_DeleteGenericHandler
#define Tk_DeleteGenericHandler \
	(tkStubsPtr->tk_DeleteGenericHandler) /* 51 */
#endif
#ifndef Tk_DeleteImage
#define Tk_DeleteImage \
	(tkStubsPtr->tk_DeleteImage) /* 52 */
#endif
#ifndef Tk_DeleteSelHandler
#define Tk_DeleteSelHandler \
	(tkStubsPtr->tk_DeleteSelHandler) /* 53 */
#endif
#ifndef Tk_DestroyWindow
#define Tk_DestroyWindow \
	(tkStubsPtr->tk_DestroyWindow) /* 54 */
#endif
#ifndef Tk_DisplayName
#define Tk_DisplayName \
	(tkStubsPtr->tk_DisplayName) /* 55 */
#endif
#ifndef Tk_DistanceToTextLayout
#define Tk_DistanceToTextLayout \
	(tkStubsPtr->tk_DistanceToTextLayout) /* 56 */
#endif
#ifndef Tk_Draw3DPolygon
#define Tk_Draw3DPolygon \
	(tkStubsPtr->tk_Draw3DPolygon) /* 57 */
#endif
#ifndef Tk_Draw3DRectangle
#define Tk_Draw3DRectangle \
	(tkStubsPtr->tk_Draw3DRectangle) /* 58 */
#endif
#ifndef Tk_DrawChars
#define Tk_DrawChars \
	(tkStubsPtr->tk_DrawChars) /* 59 */
#endif
#ifndef Tk_DrawFocusHighlight
#define Tk_DrawFocusHighlight \
	(tkStubsPtr->tk_DrawFocusHighlight) /* 60 */
#endif
#ifndef Tk_DrawTextLayout
#define Tk_DrawTextLayout \
	(tkStubsPtr->tk_DrawTextLayout) /* 61 */
#endif
#ifndef Tk_Fill3DPolygon
#define Tk_Fill3DPolygon \
	(tkStubsPtr->tk_Fill3DPolygon) /* 62 */
#endif
#ifndef Tk_Fill3DRectangle
#define Tk_Fill3DRectangle \
	(tkStubsPtr->tk_Fill3DRectangle) /* 63 */
#endif
#ifndef Tk_FindPhoto
#define Tk_FindPhoto \
	(tkStubsPtr->tk_FindPhoto) /* 64 */
#endif
#ifndef Tk_FontId
#define Tk_FontId \
	(tkStubsPtr->tk_FontId) /* 65 */
#endif
#ifndef Tk_Free3DBorder
#define Tk_Free3DBorder \
	(tkStubsPtr->tk_Free3DBorder) /* 66 */
#endif
#ifndef Tk_FreeBitmap
#define Tk_FreeBitmap \
	(tkStubsPtr->tk_FreeBitmap) /* 67 */
#endif
#ifndef Tk_FreeColor
#define Tk_FreeColor \
	(tkStubsPtr->tk_FreeColor) /* 68 */
#endif
#ifndef Tk_FreeColormap
#define Tk_FreeColormap \
	(tkStubsPtr->tk_FreeColormap) /* 69 */
#endif
#ifndef Tk_FreeCursor
#define Tk_FreeCursor \
	(tkStubsPtr->tk_FreeCursor) /* 70 */
#endif
#ifndef Tk_FreeFont
#define Tk_FreeFont \
	(tkStubsPtr->tk_FreeFont) /* 71 */
#endif
#ifndef Tk_FreeGC
#define Tk_FreeGC \
	(tkStubsPtr->tk_FreeGC) /* 72 */
#endif
#ifndef Tk_FreeImage
#define Tk_FreeImage \
	(tkStubsPtr->tk_FreeImage) /* 73 */
#endif
#ifndef Tk_FreeOptions
#define Tk_FreeOptions \
	(tkStubsPtr->tk_FreeOptions) /* 74 */
#endif
#ifndef Tk_FreePixmap
#define Tk_FreePixmap \
	(tkStubsPtr->tk_FreePixmap) /* 75 */
#endif
#ifndef Tk_FreeTextLayout
#define Tk_FreeTextLayout \
	(tkStubsPtr->tk_FreeTextLayout) /* 76 */
#endif
#ifndef Tk_FreeXId
#define Tk_FreeXId \
	(tkStubsPtr->tk_FreeXId) /* 77 */
#endif
#ifndef Tk_GCForColor
#define Tk_GCForColor \
	(tkStubsPtr->tk_GCForColor) /* 78 */
#endif
#ifndef Tk_GeometryRequest
#define Tk_GeometryRequest \
	(tkStubsPtr->tk_GeometryRequest) /* 79 */
#endif
#ifndef Tk_Get3DBorder
#define Tk_Get3DBorder \
	(tkStubsPtr->tk_Get3DBorder) /* 80 */
#endif
#ifndef Tk_GetAllBindings
#define Tk_GetAllBindings \
	(tkStubsPtr->tk_GetAllBindings) /* 81 */
#endif
#ifndef Tk_GetAnchor
#define Tk_GetAnchor \
	(tkStubsPtr->tk_GetAnchor) /* 82 */
#endif
#ifndef Tk_GetAtomName
#define Tk_GetAtomName \
	(tkStubsPtr->tk_GetAtomName) /* 83 */
#endif
#ifndef Tk_GetBinding
#define Tk_GetBinding \
	(tkStubsPtr->tk_GetBinding) /* 84 */
#endif
#ifndef Tk_GetBitmap
#define Tk_GetBitmap \
	(tkStubsPtr->tk_GetBitmap) /* 85 */
#endif
#ifndef Tk_GetBitmapFromData
#define Tk_GetBitmapFromData \
	(tkStubsPtr->tk_GetBitmapFromData) /* 86 */
#endif
#ifndef Tk_GetCapStyle
#define Tk_GetCapStyle \
	(tkStubsPtr->tk_GetCapStyle) /* 87 */
#endif
#ifndef Tk_GetColor
#define Tk_GetColor \
	(tkStubsPtr->tk_GetColor) /* 88 */
#endif
#ifndef Tk_GetColorByValue
#define Tk_GetColorByValue \
	(tkStubsPtr->tk_GetColorByValue) /* 89 */
#endif
#ifndef Tk_GetColormap
#define Tk_GetColormap \
	(tkStubsPtr->tk_GetColormap) /* 90 */
#endif
#ifndef Tk_GetCursor
#define Tk_GetCursor \
	(tkStubsPtr->tk_GetCursor) /* 91 */
#endif
#ifndef Tk_GetCursorFromData
#define Tk_GetCursorFromData \
	(tkStubsPtr->tk_GetCursorFromData) /* 92 */
#endif
#ifndef Tk_GetFont
#define Tk_GetFont \
	(tkStubsPtr->tk_GetFont) /* 93 */
#endif
#ifndef Tk_GetFontFromObj
#define Tk_GetFontFromObj \
	(tkStubsPtr->tk_GetFontFromObj) /* 94 */
#endif
#ifndef Tk_GetFontMetrics
#define Tk_GetFontMetrics \
	(tkStubsPtr->tk_GetFontMetrics) /* 95 */
#endif
#ifndef Tk_GetGC
#define Tk_GetGC \
	(tkStubsPtr->tk_GetGC) /* 96 */
#endif
#ifndef Tk_GetImage
#define Tk_GetImage \
	(tkStubsPtr->tk_GetImage) /* 97 */
#endif
#ifndef Tk_GetImageMasterData
#define Tk_GetImageMasterData \
	(tkStubsPtr->tk_GetImageMasterData) /* 98 */
#endif
#ifndef Tk_GetItemTypes
#define Tk_GetItemTypes \
	(tkStubsPtr->tk_GetItemTypes) /* 99 */
#endif
#ifndef Tk_GetJoinStyle
#define Tk_GetJoinStyle \
	(tkStubsPtr->tk_GetJoinStyle) /* 100 */
#endif
#ifndef Tk_GetJustify
#define Tk_GetJustify \
	(tkStubsPtr->tk_GetJustify) /* 101 */
#endif
#ifndef Tk_GetNumMainWindows
#define Tk_GetNumMainWindows \
	(tkStubsPtr->tk_GetNumMainWindows) /* 102 */
#endif
#ifndef Tk_GetOption
#define Tk_GetOption \
	(tkStubsPtr->tk_GetOption) /* 103 */
#endif
#ifndef Tk_GetPixels
#define Tk_GetPixels \
	(tkStubsPtr->tk_GetPixels) /* 104 */
#endif
#ifndef Tk_GetPixmap
#define Tk_GetPixmap \
	(tkStubsPtr->tk_GetPixmap) /* 105 */
#endif
#ifndef Tk_GetRelief
#define Tk_GetRelief \
	(tkStubsPtr->tk_GetRelief) /* 106 */
#endif
#ifndef Tk_GetRootCoords
#define Tk_GetRootCoords \
	(tkStubsPtr->tk_GetRootCoords) /* 107 */
#endif
#ifndef Tk_GetScrollInfo
#define Tk_GetScrollInfo \
	(tkStubsPtr->tk_GetScrollInfo) /* 108 */
#endif
#ifndef Tk_GetScreenMM
#define Tk_GetScreenMM \
	(tkStubsPtr->tk_GetScreenMM) /* 109 */
#endif
#ifndef Tk_GetSelection
#define Tk_GetSelection \
	(tkStubsPtr->tk_GetSelection) /* 110 */
#endif
#ifndef Tk_GetUid
#define Tk_GetUid \
	(tkStubsPtr->tk_GetUid) /* 111 */
#endif
#ifndef Tk_GetVisual
#define Tk_GetVisual \
	(tkStubsPtr->tk_GetVisual) /* 112 */
#endif
#ifndef Tk_GetVRootGeometry
#define Tk_GetVRootGeometry \
	(tkStubsPtr->tk_GetVRootGeometry) /* 113 */
#endif
#ifndef Tk_Grab
#define Tk_Grab \
	(tkStubsPtr->tk_Grab) /* 114 */
#endif
#ifndef Tk_HandleEvent
#define Tk_HandleEvent \
	(tkStubsPtr->tk_HandleEvent) /* 115 */
#endif
#ifndef Tk_IdToWindow
#define Tk_IdToWindow \
	(tkStubsPtr->tk_IdToWindow) /* 116 */
#endif
#ifndef Tk_ImageChanged
#define Tk_ImageChanged \
	(tkStubsPtr->tk_ImageChanged) /* 117 */
#endif
#ifndef Tk_Init
#define Tk_Init \
	(tkStubsPtr->tk_Init) /* 118 */
#endif
#ifndef Tk_InternAtom
#define Tk_InternAtom \
	(tkStubsPtr->tk_InternAtom) /* 119 */
#endif
#ifndef Tk_IntersectTextLayout
#define Tk_IntersectTextLayout \
	(tkStubsPtr->tk_IntersectTextLayout) /* 120 */
#endif
#ifndef Tk_MaintainGeometry
#define Tk_MaintainGeometry \
	(tkStubsPtr->tk_MaintainGeometry) /* 121 */
#endif
#ifndef Tk_MainWindow
#define Tk_MainWindow \
	(tkStubsPtr->tk_MainWindow) /* 122 */
#endif
#ifndef Tk_MakeWindowExist
#define Tk_MakeWindowExist \
	(tkStubsPtr->tk_MakeWindowExist) /* 123 */
#endif
#ifndef Tk_ManageGeometry
#define Tk_ManageGeometry \
	(tkStubsPtr->tk_ManageGeometry) /* 124 */
#endif
#ifndef Tk_MapWindow
#define Tk_MapWindow \
	(tkStubsPtr->tk_MapWindow) /* 125 */
#endif
#ifndef Tk_MeasureChars
#define Tk_MeasureChars \
	(tkStubsPtr->tk_MeasureChars) /* 126 */
#endif
#ifndef Tk_MoveResizeWindow
#define Tk_MoveResizeWindow \
	(tkStubsPtr->tk_MoveResizeWindow) /* 127 */
#endif
#ifndef Tk_MoveWindow
#define Tk_MoveWindow \
	(tkStubsPtr->tk_MoveWindow) /* 128 */
#endif
#ifndef Tk_MoveToplevelWindow
#define Tk_MoveToplevelWindow \
	(tkStubsPtr->tk_MoveToplevelWindow) /* 129 */
#endif
#ifndef Tk_NameOf3DBorder
#define Tk_NameOf3DBorder \
	(tkStubsPtr->tk_NameOf3DBorder) /* 130 */
#endif
#ifndef Tk_NameOfAnchor
#define Tk_NameOfAnchor \
	(tkStubsPtr->tk_NameOfAnchor) /* 131 */
#endif
#ifndef Tk_NameOfBitmap
#define Tk_NameOfBitmap \
	(tkStubsPtr->tk_NameOfBitmap) /* 132 */
#endif
#ifndef Tk_NameOfCapStyle
#define Tk_NameOfCapStyle \
	(tkStubsPtr->tk_NameOfCapStyle) /* 133 */
#endif
#ifndef Tk_NameOfColor
#define Tk_NameOfColor \
	(tkStubsPtr->tk_NameOfColor) /* 134 */
#endif
#ifndef Tk_NameOfCursor
#define Tk_NameOfCursor \
	(tkStubsPtr->tk_NameOfCursor) /* 135 */
#endif
#ifndef Tk_NameOfFont
#define Tk_NameOfFont \
	(tkStubsPtr->tk_NameOfFont) /* 136 */
#endif
#ifndef Tk_NameOfImage
#define Tk_NameOfImage \
	(tkStubsPtr->tk_NameOfImage) /* 137 */
#endif
#ifndef Tk_NameOfJoinStyle
#define Tk_NameOfJoinStyle \
	(tkStubsPtr->tk_NameOfJoinStyle) /* 138 */
#endif
#ifndef Tk_NameOfJustify
#define Tk_NameOfJustify \
	(tkStubsPtr->tk_NameOfJustify) /* 139 */
#endif
#ifndef Tk_NameOfRelief
#define Tk_NameOfRelief \
	(tkStubsPtr->tk_NameOfRelief) /* 140 */
#endif
#ifndef Tk_NameToWindow
#define Tk_NameToWindow \
	(tkStubsPtr->tk_NameToWindow) /* 141 */
#endif
#ifndef Tk_OwnSelection
#define Tk_OwnSelection \
	(tkStubsPtr->tk_OwnSelection) /* 142 */
#endif
#ifndef Tk_ParseArgv
#define Tk_ParseArgv \
	(tkStubsPtr->tk_ParseArgv) /* 143 */
#endif
#ifndef Tk_PhotoPutBlock_NoComposite
#define Tk_PhotoPutBlock_NoComposite \
	(tkStubsPtr->tk_PhotoPutBlock_NoComposite) /* 144 */
#endif
#ifndef Tk_PhotoPutZoomedBlock_NoComposite
#define Tk_PhotoPutZoomedBlock_NoComposite \
	(tkStubsPtr->tk_PhotoPutZoomedBlock_NoComposite) /* 145 */
#endif
#ifndef Tk_PhotoGetImage
#define Tk_PhotoGetImage \
	(tkStubsPtr->tk_PhotoGetImage) /* 146 */
#endif
#ifndef Tk_PhotoBlank
#define Tk_PhotoBlank \
	(tkStubsPtr->tk_PhotoBlank) /* 147 */
#endif
#ifndef Tk_PhotoExpand
#define Tk_PhotoExpand \
	(tkStubsPtr->tk_PhotoExpand) /* 148 */
#endif
#ifndef Tk_PhotoGetSize
#define Tk_PhotoGetSize \
	(tkStubsPtr->tk_PhotoGetSize) /* 149 */
#endif
#ifndef Tk_PhotoSetSize
#define Tk_PhotoSetSize \
	(tkStubsPtr->tk_PhotoSetSize) /* 150 */
#endif
#ifndef Tk_PointToChar
#define Tk_PointToChar \
	(tkStubsPtr->tk_PointToChar) /* 151 */
#endif
#ifndef Tk_PostscriptFontName
#define Tk_PostscriptFontName \
	(tkStubsPtr->tk_PostscriptFontName) /* 152 */
#endif
#ifndef Tk_PreserveColormap
#define Tk_PreserveColormap \
	(tkStubsPtr->tk_PreserveColormap) /* 153 */
#endif
#ifndef Tk_QueueWindowEvent
#define Tk_QueueWindowEvent \
	(tkStubsPtr->tk_QueueWindowEvent) /* 154 */
#endif
#ifndef Tk_RedrawImage
#define Tk_RedrawImage \
	(tkStubsPtr->tk_RedrawImage) /* 155 */
#endif
#ifndef Tk_ResizeWindow
#define Tk_ResizeWindow \
	(tkStubsPtr->tk_ResizeWindow) /* 156 */
#endif
#ifndef Tk_RestackWindow
#define Tk_RestackWindow \
	(tkStubsPtr->tk_RestackWindow) /* 157 */
#endif
#ifndef Tk_RestrictEvents
#define Tk_RestrictEvents \
	(tkStubsPtr->tk_RestrictEvents) /* 158 */
#endif
#ifndef Tk_SafeInit
#define Tk_SafeInit \
	(tkStubsPtr->tk_SafeInit) /* 159 */
#endif
#ifndef Tk_SetAppName
#define Tk_SetAppName \
	(tkStubsPtr->tk_SetAppName) /* 160 */
#endif
#ifndef Tk_SetBackgroundFromBorder
#define Tk_SetBackgroundFromBorder \
	(tkStubsPtr->tk_SetBackgroundFromBorder) /* 161 */
#endif
#ifndef Tk_SetClass
#define Tk_SetClass \
	(tkStubsPtr->tk_SetClass) /* 162 */
#endif
#ifndef Tk_SetGrid
#define Tk_SetGrid \
	(tkStubsPtr->tk_SetGrid) /* 163 */
#endif
#ifndef Tk_SetInternalBorder
#define Tk_SetInternalBorder \
	(tkStubsPtr->tk_SetInternalBorder) /* 164 */
#endif
#ifndef Tk_SetWindowBackground
#define Tk_SetWindowBackground \
	(tkStubsPtr->tk_SetWindowBackground) /* 165 */
#endif
#ifndef Tk_SetWindowBackgroundPixmap
#define Tk_SetWindowBackgroundPixmap \
	(tkStubsPtr->tk_SetWindowBackgroundPixmap) /* 166 */
#endif
#ifndef Tk_SetWindowBorder
#define Tk_SetWindowBorder \
	(tkStubsPtr->tk_SetWindowBorder) /* 167 */
#endif
#ifndef Tk_SetWindowBorderWidth
#define Tk_SetWindowBorderWidth \
	(tkStubsPtr->tk_SetWindowBorderWidth) /* 168 */
#endif
#ifndef Tk_SetWindowBorderPixmap
#define Tk_SetWindowBorderPixmap \
	(tkStubsPtr->tk_SetWindowBorderPixmap) /* 169 */
#endif
#ifndef Tk_SetWindowColormap
#define Tk_SetWindowColormap \
	(tkStubsPtr->tk_SetWindowColormap) /* 170 */
#endif
#ifndef Tk_SetWindowVisual
#define Tk_SetWindowVisual \
	(tkStubsPtr->tk_SetWindowVisual) /* 171 */
#endif
#ifndef Tk_SizeOfBitmap
#define Tk_SizeOfBitmap \
	(tkStubsPtr->tk_SizeOfBitmap) /* 172 */
#endif
#ifndef Tk_SizeOfImage
#define Tk_SizeOfImage \
	(tkStubsPtr->tk_SizeOfImage) /* 173 */
#endif
#ifndef Tk_StrictMotif
#define Tk_StrictMotif \
	(tkStubsPtr->tk_StrictMotif) /* 174 */
#endif
#ifndef Tk_TextLayoutToPostscript
#define Tk_TextLayoutToPostscript \
	(tkStubsPtr->tk_TextLayoutToPostscript) /* 175 */
#endif
#ifndef Tk_TextWidth
#define Tk_TextWidth \
	(tkStubsPtr->tk_TextWidth) /* 176 */
#endif
#ifndef Tk_UndefineCursor
#define Tk_UndefineCursor \
	(tkStubsPtr->tk_UndefineCursor) /* 177 */
#endif
#ifndef Tk_UnderlineChars
#define Tk_UnderlineChars \
	(tkStubsPtr->tk_UnderlineChars) /* 178 */
#endif
#ifndef Tk_UnderlineTextLayout
#define Tk_UnderlineTextLayout \
	(tkStubsPtr->tk_UnderlineTextLayout) /* 179 */
#endif
#ifndef Tk_Ungrab
#define Tk_Ungrab \
	(tkStubsPtr->tk_Ungrab) /* 180 */
#endif
#ifndef Tk_UnmaintainGeometry
#define Tk_UnmaintainGeometry \
	(tkStubsPtr->tk_UnmaintainGeometry) /* 181 */
#endif
#ifndef Tk_UnmapWindow
#define Tk_UnmapWindow \
	(tkStubsPtr->tk_UnmapWindow) /* 182 */
#endif
#ifndef Tk_UnsetGrid
#define Tk_UnsetGrid \
	(tkStubsPtr->tk_UnsetGrid) /* 183 */
#endif
#ifndef Tk_UpdatePointer
#define Tk_UpdatePointer \
	(tkStubsPtr->tk_UpdatePointer) /* 184 */
#endif
#ifndef Tk_AllocBitmapFromObj
#define Tk_AllocBitmapFromObj \
	(tkStubsPtr->tk_AllocBitmapFromObj) /* 185 */
#endif
#ifndef Tk_Alloc3DBorderFromObj
#define Tk_Alloc3DBorderFromObj \
	(tkStubsPtr->tk_Alloc3DBorderFromObj) /* 186 */
#endif
#ifndef Tk_AllocColorFromObj
#define Tk_AllocColorFromObj \
	(tkStubsPtr->tk_AllocColorFromObj) /* 187 */
#endif
#ifndef Tk_AllocCursorFromObj
#define Tk_AllocCursorFromObj \
	(tkStubsPtr->tk_AllocCursorFromObj) /* 188 */
#endif
#ifndef Tk_AllocFontFromObj
#define Tk_AllocFontFromObj \
	(tkStubsPtr->tk_AllocFontFromObj) /* 189 */
#endif
#ifndef Tk_CreateOptionTable
#define Tk_CreateOptionTable \
	(tkStubsPtr->tk_CreateOptionTable) /* 190 */
#endif
#ifndef Tk_DeleteOptionTable
#define Tk_DeleteOptionTable \
	(tkStubsPtr->tk_DeleteOptionTable) /* 191 */
#endif
#ifndef Tk_Free3DBorderFromObj
#define Tk_Free3DBorderFromObj \
	(tkStubsPtr->tk_Free3DBorderFromObj) /* 192 */
#endif
#ifndef Tk_FreeBitmapFromObj
#define Tk_FreeBitmapFromObj \
	(tkStubsPtr->tk_FreeBitmapFromObj) /* 193 */
#endif
#ifndef Tk_FreeColorFromObj
#define Tk_FreeColorFromObj \
	(tkStubsPtr->tk_FreeColorFromObj) /* 194 */
#endif
#ifndef Tk_FreeConfigOptions
#define Tk_FreeConfigOptions \
	(tkStubsPtr->tk_FreeConfigOptions) /* 195 */
#endif
#ifndef Tk_FreeSavedOptions
#define Tk_FreeSavedOptions \
	(tkStubsPtr->tk_FreeSavedOptions) /* 196 */
#endif
#ifndef Tk_FreeCursorFromObj
#define Tk_FreeCursorFromObj \
	(tkStubsPtr->tk_FreeCursorFromObj) /* 197 */
#endif
#ifndef Tk_FreeFontFromObj
#define Tk_FreeFontFromObj \
	(tkStubsPtr->tk_FreeFontFromObj) /* 198 */
#endif
#ifndef Tk_Get3DBorderFromObj
#define Tk_Get3DBorderFromObj \
	(tkStubsPtr->tk_Get3DBorderFromObj) /* 199 */
#endif
#ifndef Tk_GetAnchorFromObj
#define Tk_GetAnchorFromObj \
	(tkStubsPtr->tk_GetAnchorFromObj) /* 200 */
#endif
#ifndef Tk_GetBitmapFromObj
#define Tk_GetBitmapFromObj \
	(tkStubsPtr->tk_GetBitmapFromObj) /* 201 */
#endif
#ifndef Tk_GetColorFromObj
#define Tk_GetColorFromObj \
	(tkStubsPtr->tk_GetColorFromObj) /* 202 */
#endif
#ifndef Tk_GetCursorFromObj
#define Tk_GetCursorFromObj \
	(tkStubsPtr->tk_GetCursorFromObj) /* 203 */
#endif
#ifndef Tk_GetOptionInfo
#define Tk_GetOptionInfo \
	(tkStubsPtr->tk_GetOptionInfo) /* 204 */
#endif
#ifndef Tk_GetOptionValue
#define Tk_GetOptionValue \
	(tkStubsPtr->tk_GetOptionValue) /* 205 */
#endif
#ifndef Tk_GetJustifyFromObj
#define Tk_GetJustifyFromObj \
	(tkStubsPtr->tk_GetJustifyFromObj) /* 206 */
#endif
#ifndef Tk_GetMMFromObj
#define Tk_GetMMFromObj \
	(tkStubsPtr->tk_GetMMFromObj) /* 207 */
#endif
#ifndef Tk_GetPixelsFromObj
#define Tk_GetPixelsFromObj \
	(tkStubsPtr->tk_GetPixelsFromObj) /* 208 */
#endif
#ifndef Tk_GetReliefFromObj
#define Tk_GetReliefFromObj \
	(tkStubsPtr->tk_GetReliefFromObj) /* 209 */
#endif
#ifndef Tk_GetScrollInfoObj
#define Tk_GetScrollInfoObj \
	(tkStubsPtr->tk_GetScrollInfoObj) /* 210 */
#endif
#ifndef Tk_InitOptions
#define Tk_InitOptions \
	(tkStubsPtr->tk_InitOptions) /* 211 */
#endif
#ifndef Tk_MainEx
#define Tk_MainEx \
	(tkStubsPtr->tk_MainEx) /* 212 */
#endif
#ifndef Tk_RestoreSavedOptions
#define Tk_RestoreSavedOptions \
	(tkStubsPtr->tk_RestoreSavedOptions) /* 213 */
#endif
#ifndef Tk_SetOptions
#define Tk_SetOptions \
	(tkStubsPtr->tk_SetOptions) /* 214 */
#endif
#ifndef Tk_InitConsoleChannels
#define Tk_InitConsoleChannels \
	(tkStubsPtr->tk_InitConsoleChannels) /* 215 */
#endif
#ifndef Tk_CreateConsoleWindow
#define Tk_CreateConsoleWindow \
	(tkStubsPtr->tk_CreateConsoleWindow) /* 216 */
#endif
#ifndef Tk_CreateSmoothMethod
#define Tk_CreateSmoothMethod \
	(tkStubsPtr->tk_CreateSmoothMethod) /* 217 */
#endif
/* Slot 218 is reserved */
/* Slot 219 is reserved */
#ifndef Tk_GetDash
#define Tk_GetDash \
	(tkStubsPtr->tk_GetDash) /* 220 */
#endif
#ifndef Tk_CreateOutline
#define Tk_CreateOutline \
	(tkStubsPtr->tk_CreateOutline) /* 221 */
#endif
#ifndef Tk_DeleteOutline
#define Tk_DeleteOutline \
	(tkStubsPtr->tk_DeleteOutline) /* 222 */
#endif
#ifndef Tk_ConfigOutlineGC
#define Tk_ConfigOutlineGC \
	(tkStubsPtr->tk_ConfigOutlineGC) /* 223 */
#endif
#ifndef Tk_ChangeOutlineGC
#define Tk_ChangeOutlineGC \
	(tkStubsPtr->tk_ChangeOutlineGC) /* 224 */
#endif
#ifndef Tk_ResetOutlineGC
#define Tk_ResetOutlineGC \
	(tkStubsPtr->tk_ResetOutlineGC) /* 225 */
#endif
#ifndef Tk_CanvasPsOutline
#define Tk_CanvasPsOutline \
	(tkStubsPtr->tk_CanvasPsOutline) /* 226 */
#endif
#ifndef Tk_SetTSOrigin
#define Tk_SetTSOrigin \
	(tkStubsPtr->tk_SetTSOrigin) /* 227 */
#endif
#ifndef Tk_CanvasGetCoordFromObj
#define Tk_CanvasGetCoordFromObj \
	(tkStubsPtr->tk_CanvasGetCoordFromObj) /* 228 */
#endif
#ifndef Tk_CanvasSetOffset
#define Tk_CanvasSetOffset \
	(tkStubsPtr->tk_CanvasSetOffset) /* 229 */
#endif
#ifndef Tk_DitherPhoto
#define Tk_DitherPhoto \
	(tkStubsPtr->tk_DitherPhoto) /* 230 */
#endif
#ifndef Tk_PostscriptBitmap
#define Tk_PostscriptBitmap \
	(tkStubsPtr->tk_PostscriptBitmap) /* 231 */
#endif
#ifndef Tk_PostscriptColor
#define Tk_PostscriptColor \
	(tkStubsPtr->tk_PostscriptColor) /* 232 */
#endif
#ifndef Tk_PostscriptFont
#define Tk_PostscriptFont \
	(tkStubsPtr->tk_PostscriptFont) /* 233 */
#endif
#ifndef Tk_PostscriptImage
#define Tk_PostscriptImage \
	(tkStubsPtr->tk_PostscriptImage) /* 234 */
#endif
#ifndef Tk_PostscriptPath
#define Tk_PostscriptPath \
	(tkStubsPtr->tk_PostscriptPath) /* 235 */
#endif
#ifndef Tk_PostscriptStipple
#define Tk_PostscriptStipple \
	(tkStubsPtr->tk_PostscriptStipple) /* 236 */
#endif
#ifndef Tk_PostscriptY
#define Tk_PostscriptY \
	(tkStubsPtr->tk_PostscriptY) /* 237 */
#endif
#ifndef Tk_PostscriptPhoto
#define Tk_PostscriptPhoto \
	(tkStubsPtr->tk_PostscriptPhoto) /* 238 */
#endif
#ifndef Tk_CreateClientMessageHandler
#define Tk_CreateClientMessageHandler \
	(tkStubsPtr->tk_CreateClientMessageHandler) /* 239 */
#endif
#ifndef Tk_DeleteClientMessageHandler
#define Tk_DeleteClientMessageHandler \
	(tkStubsPtr->tk_DeleteClientMessageHandler) /* 240 */
#endif
#ifndef Tk_CreateAnonymousWindow
#define Tk_CreateAnonymousWindow \
	(tkStubsPtr->tk_CreateAnonymousWindow) /* 241 */
#endif
#ifndef Tk_SetClassProcs
#define Tk_SetClassProcs \
	(tkStubsPtr->tk_SetClassProcs) /* 242 */
#endif
#ifndef Tk_SetInternalBorderEx
#define Tk_SetInternalBorderEx \
	(tkStubsPtr->tk_SetInternalBorderEx) /* 243 */
#endif
#ifndef Tk_SetMinimumRequestSize
#define Tk_SetMinimumRequestSize \
	(tkStubsPtr->tk_SetMinimumRequestSize) /* 244 */
#endif
#ifndef Tk_SetCaretPos
#define Tk_SetCaretPos \
	(tkStubsPtr->tk_SetCaretPos) /* 245 */
#endif
#ifndef Tk_PhotoPutBlock
#define Tk_PhotoPutBlock \
	(tkStubsPtr->tk_PhotoPutBlock) /* 246 */
#endif
#ifndef Tk_PhotoPutZoomedBlock
#define Tk_PhotoPutZoomedBlock \
	(tkStubsPtr->tk_PhotoPutZoomedBlock) /* 247 */
#endif
#ifndef Tk_CollapseMotionEvents
#define Tk_CollapseMotionEvents \
	(tkStubsPtr->tk_CollapseMotionEvents) /* 248 */
#endif
#ifndef Tk_RegisterStyleEngine
#define Tk_RegisterStyleEngine \
	(tkStubsPtr->tk_RegisterStyleEngine) /* 249 */
#endif
#ifndef Tk_GetStyleEngine
#define Tk_GetStyleEngine \
	(tkStubsPtr->tk_GetStyleEngine) /* 250 */
#endif
#ifndef Tk_RegisterStyledElement
#define Tk_RegisterStyledElement \
	(tkStubsPtr->tk_RegisterStyledElement) /* 251 */
#endif
#ifndef Tk_GetElementId
#define Tk_GetElementId \
	(tkStubsPtr->tk_GetElementId) /* 252 */
#endif
#ifndef Tk_CreateStyle
#define Tk_CreateStyle \
	(tkStubsPtr->tk_CreateStyle) /* 253 */
#endif
#ifndef Tk_GetStyle
#define Tk_GetStyle \
	(tkStubsPtr->tk_GetStyle) /* 254 */
#endif
#ifndef Tk_FreeStyle
#define Tk_FreeStyle \
	(tkStubsPtr->tk_FreeStyle) /* 255 */
#endif
#ifndef Tk_NameOfStyle
#define Tk_NameOfStyle \
	(tkStubsPtr->tk_NameOfStyle) /* 256 */
#endif
#ifndef Tk_AllocStyleFromObj
#define Tk_AllocStyleFromObj \
	(tkStubsPtr->tk_AllocStyleFromObj) /* 257 */
#endif
#ifndef Tk_GetStyleFromObj
#define Tk_GetStyleFromObj \
	(tkStubsPtr->tk_GetStyleFromObj) /* 258 */
#endif
#ifndef Tk_FreeStyleFromObj
#define Tk_FreeStyleFromObj \
	(tkStubsPtr->tk_FreeStyleFromObj) /* 259 */
#endif
#ifndef Tk_GetStyledElement
#define Tk_GetStyledElement \
	(tkStubsPtr->tk_GetStyledElement) /* 260 */
#endif
#ifndef Tk_GetElementSize
#define Tk_GetElementSize \
	(tkStubsPtr->tk_GetElementSize) /* 261 */
#endif
#ifndef Tk_GetElementBox
#define Tk_GetElementBox \
	(tkStubsPtr->tk_GetElementBox) /* 262 */
#endif
#ifndef Tk_GetElementBorderWidth
#define Tk_GetElementBorderWidth \
	(tkStubsPtr->tk_GetElementBorderWidth) /* 263 */
#endif
#ifndef Tk_DrawElement
#define Tk_DrawElement \
	(tkStubsPtr->tk_DrawElement) /* 264 */
#endif

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKDECLS */

                                                                                                                                                                                                                                                                                                                                                                                                                                                             tkIntXlibDecls.h                                                                                    0100644 0001750 0001750 00000266121 11001664476 033374  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers                                                                        /*
 * tkIntXlibDecls.h --
 *
 *	This file contains the declarations for all platform dependent
 *	unsupported functions that are exported by the Tk library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @(#) $Id: tkIntXlibDecls.h,v 1.16.2.1 2005/11/27 02:44:25 das Exp $
 */

#ifndef _TKINTXLIBDECLS
#define _TKINTXLIBDECLS

#ifdef MAC_TCL
#include "Xutil.h"
#else
#include "X11/Xutil.h"
#endif

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tkInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__
/* 0 */
EXTERN void		XSetDashes _ANSI_ARGS_((Display* display, GC gc, 
				int dash_offset, _Xconst char* dash_list, 
				int n));
/* 1 */
EXTERN XModifierKeymap*	 XGetModifierMapping _ANSI_ARGS_((Display* d));
/* 2 */
EXTERN XImage *		XCreateImage _ANSI_ARGS_((Display* d, Visual* v, 
				unsigned int ui1, int i1, int i2, char* cp, 
				unsigned int ui2, unsigned int ui3, int i3, 
				int i4));
/* 3 */
EXTERN XImage *		XGetImage _ANSI_ARGS_((Display* d, Drawable dr, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, unsigned long ul, int i3));
/* 4 */
EXTERN char *		XGetAtomName _ANSI_ARGS_((Display* d, Atom a));
/* 5 */
EXTERN char *		XKeysymToString _ANSI_ARGS_((KeySym k));
/* 6 */
EXTERN Colormap		XCreateColormap _ANSI_ARGS_((Display* d, Window w, 
				Visual* v, int i));
/* 7 */
EXTERN Cursor		XCreatePixmapCursor _ANSI_ARGS_((Display* d, 
				Pixmap p1, Pixmap p2, XColor* x1, XColor* x2, 
				unsigned int ui1, unsigned int ui2));
/* 8 */
EXTERN Cursor		XCreateGlyphCursor _ANSI_ARGS_((Display* d, Font f1, 
				Font f2, unsigned int ui1, unsigned int ui2, 
				XColor* x1, XColor* x2));
/* 9 */
EXTERN GContext		XGContextFromGC _ANSI_ARGS_((GC g));
/* 10 */
EXTERN XHostAddress *	XListHosts _ANSI_ARGS_((Display* d, int* i, Bool* b));
/* 11 */
EXTERN KeySym		XKeycodeToKeysym _ANSI_ARGS_((Display* d, 
				unsigned int k, int i));
/* 12 */
EXTERN KeySym		XStringToKeysym _ANSI_ARGS_((_Xconst char* c));
/* 13 */
EXTERN Window		XRootWindow _ANSI_ARGS_((Display* d, int i));
/* 14 */
EXTERN XErrorHandler	XSetErrorHandler _ANSI_ARGS_((XErrorHandler x));
/* 15 */
EXTERN Status		XIconifyWindow _ANSI_ARGS_((Display* d, Window w, 
				int i));
/* 16 */
EXTERN Status		XWithdrawWindow _ANSI_ARGS_((Display* d, Window w, 
				int i));
/* 17 */
EXTERN Status		XGetWMColormapWindows _ANSI_ARGS_((Display* d, 
				Window w, Window** wpp, int* ip));
/* 18 */
EXTERN Status		XAllocColor _ANSI_ARGS_((Display* d, Colormap c, 
				XColor* xp));
/* 19 */
EXTERN void		XBell _ANSI_ARGS_((Display* d, int i));
/* 20 */
EXTERN void		XChangeProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, Atom a2, int i1, int i2, 
				_Xconst unsigned char* c, int i3));
/* 21 */
EXTERN void		XChangeWindowAttributes _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul, 
				XSetWindowAttributes* x));
/* 22 */
EXTERN void		XClearWindow _ANSI_ARGS_((Display* d, Window w));
/* 23 */
EXTERN void		XConfigureWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int i, XWindowChanges* x));
/* 24 */
EXTERN void		XCopyArea _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4));
/* 25 */
EXTERN void		XCopyPlane _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4, unsigned long ul));
/* 26 */
EXTERN Pixmap		XCreateBitmapFromData _ANSI_ARGS_((Display* display, 
				Drawable d, _Xconst char* data, 
				unsigned int width, unsigned int height));
/* 27 */
EXTERN void		XDefineCursor _ANSI_ARGS_((Display* d, Window w, 
				Cursor c));
/* 28 */
EXTERN void		XDeleteProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a));
/* 29 */
EXTERN void		XDestroyWindow _ANSI_ARGS_((Display* d, Window w));
/* 30 */
EXTERN void		XDrawArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 31 */
EXTERN void		XDrawLines _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2));
/* 32 */
EXTERN void		XDrawRectangle _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 33 */
EXTERN void		XFillArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 34 */
EXTERN void		XFillPolygon _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2, int i3));
/* 35 */
EXTERN void		XFillRectangles _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XRectangle* x, int i));
/* 36 */
EXTERN void		XForceScreenSaver _ANSI_ARGS_((Display* d, int i));
/* 37 */
EXTERN void		XFreeColormap _ANSI_ARGS_((Display* d, Colormap c));
/* 38 */
EXTERN void		XFreeColors _ANSI_ARGS_((Display* d, Colormap c, 
				unsigned long* ulp, int i, unsigned long ul));
/* 39 */
EXTERN void		XFreeCursor _ANSI_ARGS_((Display* d, Cursor c));
/* 40 */
EXTERN void		XFreeModifiermap _ANSI_ARGS_((XModifierKeymap* x));
/* 41 */
EXTERN Status		XGetGeometry _ANSI_ARGS_((Display* d, Drawable dr, 
				Window* w, int* i1, int* i2, 
				unsigned int* ui1, unsigned int* ui2, 
				unsigned int* ui3, unsigned int* ui4));
/* 42 */
EXTERN void		XGetInputFocus _ANSI_ARGS_((Display* d, Window* w, 
				int* i));
/* 43 */
EXTERN int		XGetWindowProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, long l1, long l2, Bool b, Atom a2, 
				Atom* ap, int* ip, unsigned long* ulp1, 
				unsigned long* ulp2, unsigned char** cpp));
/* 44 */
EXTERN Status		XGetWindowAttributes _ANSI_ARGS_((Display* d, 
				Window w, XWindowAttributes* x));
/* 45 */
EXTERN int		XGrabKeyboard _ANSI_ARGS_((Display* d, Window w, 
				Bool b, int i1, int i2, Time t));
/* 46 */
EXTERN int		XGrabPointer _ANSI_ARGS_((Display* d, Window w1, 
				Bool b, unsigned int ui, int i1, int i2, 
				Window w2, Cursor c, Time t));
/* 47 */
EXTERN KeyCode		XKeysymToKeycode _ANSI_ARGS_((Display* d, KeySym k));
/* 48 */
EXTERN Status		XLookupColor _ANSI_ARGS_((Display* d, Colormap c1, 
				_Xconst char* c2, XColor* x1, XColor* x2));
/* 49 */
EXTERN void		XMapWindow _ANSI_ARGS_((Display* d, Window w));
/* 50 */
EXTERN void		XMoveResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 51 */
EXTERN void		XMoveWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2));
/* 52 */
EXTERN void		XNextEvent _ANSI_ARGS_((Display* d, XEvent* x));
/* 53 */
EXTERN void		XPutBackEvent _ANSI_ARGS_((Display* d, XEvent* x));
/* 54 */
EXTERN void		XQueryColors _ANSI_ARGS_((Display* d, Colormap c, 
				XColor* x, int i));
/* 55 */
EXTERN Bool		XQueryPointer _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, int* i1, int* i2, 
				int* i3, int* i4, unsigned int* ui));
/* 56 */
EXTERN Status		XQueryTree _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, Window** w4, 
				unsigned int* ui));
/* 57 */
EXTERN void		XRaiseWindow _ANSI_ARGS_((Display* d, Window w));
/* 58 */
EXTERN void		XRefreshKeyboardMapping _ANSI_ARGS_((
				XMappingEvent* x));
/* 59 */
EXTERN void		XResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int ui1, unsigned int ui2));
/* 60 */
EXTERN void		XSelectInput _ANSI_ARGS_((Display* d, Window w, 
				long l));
/* 61 */
EXTERN Status		XSendEvent _ANSI_ARGS_((Display* d, Window w, Bool b, 
				long l, XEvent* x));
/* 62 */
EXTERN void		XSetCommand _ANSI_ARGS_((Display* d, Window w, 
				CONST char** c, int i));
/* 63 */
EXTERN void		XSetIconName _ANSI_ARGS_((Display* d, Window w, 
				_Xconst char* c));
/* 64 */
EXTERN void		XSetInputFocus _ANSI_ARGS_((Display* d, Window w, 
				int i, Time t));
/* 65 */
EXTERN void		XSetSelectionOwner _ANSI_ARGS_((Display* d, Atom a, 
				Window w, Time t));
/* 66 */
EXTERN void		XSetWindowBackground _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul));
/* 67 */
EXTERN void		XSetWindowBackgroundPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 68 */
EXTERN void		XSetWindowBorder _ANSI_ARGS_((Display* d, Window w, 
				unsigned long ul));
/* 69 */
EXTERN void		XSetWindowBorderPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 70 */
EXTERN void		XSetWindowBorderWidth _ANSI_ARGS_((Display* d, 
				Window w, unsigned int ui));
/* 71 */
EXTERN void		XSetWindowColormap _ANSI_ARGS_((Display* d, Window w, 
				Colormap c));
/* 72 */
EXTERN Bool		XTranslateCoordinates _ANSI_ARGS_((Display* d, 
				Window w1, Window w2, int i1, int i2, 
				int* i3, int* i4, Window* w3));
/* 73 */
EXTERN void		XUngrabKeyboard _ANSI_ARGS_((Display* d, Time t));
/* 74 */
EXTERN void		XUngrabPointer _ANSI_ARGS_((Display* d, Time t));
/* 75 */
EXTERN void		XUnmapWindow _ANSI_ARGS_((Display* d, Window w));
/* 76 */
EXTERN void		XWindowEvent _ANSI_ARGS_((Display* d, Window w, 
				long l, XEvent* x));
/* 77 */
EXTERN void		XDestroyIC _ANSI_ARGS_((XIC x));
/* 78 */
EXTERN Bool		XFilterEvent _ANSI_ARGS_((XEvent* x, Window w));
/* 79 */
EXTERN int		XmbLookupString _ANSI_ARGS_((XIC xi, 
				XKeyPressedEvent* xk, char* c, int i, 
				KeySym* k, Status* s));
/* 80 */
EXTERN void		TkPutImage _ANSI_ARGS_((unsigned long * colors, 
				int ncolors, Display* display, Drawable d, 
				GC gc, XImage* image, int src_x, int src_y, 
				int dest_x, int dest_y, unsigned int width, 
				unsigned int height));
/* Slot 81 is reserved */
/* 82 */
EXTERN Status		XParseColor _ANSI_ARGS_((Display * display, 
				Colormap map, _Xconst char* spec, 
				XColor * colorPtr));
/* 83 */
EXTERN GC		XCreateGC _ANSI_ARGS_((Display* display, Drawable d, 
				unsigned long valuemask, XGCValues* values));
/* 84 */
EXTERN void		XFreeGC _ANSI_ARGS_((Display* display, GC gc));
/* 85 */
EXTERN Atom		XInternAtom _ANSI_ARGS_((Display* display, 
				_Xconst char* atom_name, Bool only_if_exists));
/* 86 */
EXTERN void		XSetBackground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 87 */
EXTERN void		XSetForeground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 88 */
EXTERN void		XSetClipMask _ANSI_ARGS_((Display* display, GC gc, 
				Pixmap pixmap));
/* 89 */
EXTERN void		XSetClipOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int clip_x_origin, int clip_y_origin));
/* 90 */
EXTERN void		XSetTSOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int ts_x_origin, int ts_y_origin));
/* 91 */
EXTERN void		XChangeGC _ANSI_ARGS_((Display * d, GC gc, 
				unsigned long mask, XGCValues * values));
/* 92 */
EXTERN void		XSetFont _ANSI_ARGS_((Display * display, GC gc, 
				Font font));
/* 93 */
EXTERN void		XSetArcMode _ANSI_ARGS_((Display * display, GC gc, 
				int arc_mode));
/* 94 */
EXTERN void		XSetStipple _ANSI_ARGS_((Display * display, GC gc, 
				Pixmap stipple));
/* 95 */
EXTERN void		XSetFillRule _ANSI_ARGS_((Display * display, GC gc, 
				int fill_rule));
/* 96 */
EXTERN void		XSetFillStyle _ANSI_ARGS_((Display * display, GC gc, 
				int fill_style));
/* 97 */
EXTERN void		XSetFunction _ANSI_ARGS_((Display * display, GC gc, 
				int function));
/* 98 */
EXTERN void		XSetLineAttributes _ANSI_ARGS_((Display * display, 
				GC gc, unsigned int line_width, 
				int line_style, int cap_style, 
				int join_style));
/* 99 */
EXTERN int		_XInitImageFuncPtrs _ANSI_ARGS_((XImage * image));
/* 100 */
EXTERN XIC		XCreateIC _ANSI_ARGS_((void));
/* 101 */
EXTERN XVisualInfo *	XGetVisualInfo _ANSI_ARGS_((Display* display, 
				long vinfo_mask, XVisualInfo* vinfo_template, 
				int* nitems_return));
/* 102 */
EXTERN void		XSetWMClientMachine _ANSI_ARGS_((Display* display, 
				Window w, XTextProperty* text_prop));
/* 103 */
EXTERN Status		XStringListToTextProperty _ANSI_ARGS_((char** list, 
				int count, XTextProperty* text_prop_return));
/* 104 */
EXTERN void		XDrawLine _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int x1, int y1, int x2, int y2));
/* 105 */
EXTERN void		XWarpPointer _ANSI_ARGS_((Display* d, Window s, 
				Window dw, int sx, int sy, unsigned int sw, 
				unsigned int sh, int dx, int dy));
/* 106 */
EXTERN void		XFillRectangle _ANSI_ARGS_((Display* display, 
				Drawable d, GC gc, int x, int y, 
				unsigned int width, unsigned int height));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 0 */
EXTERN void		XSetDashes _ANSI_ARGS_((Display* display, GC gc, 
				int dash_offset, _Xconst char* dash_list, 
				int n));
/* 1 */
EXTERN XModifierKeymap*	 XGetModifierMapping _ANSI_ARGS_((Display* d));
/* 2 */
EXTERN XImage *		XCreateImage _ANSI_ARGS_((Display* d, Visual* v, 
				unsigned int ui1, int i1, int i2, char* cp, 
				unsigned int ui2, unsigned int ui3, int i3, 
				int i4));
/* 3 */
EXTERN XImage *		XGetImage _ANSI_ARGS_((Display* d, Drawable dr, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, unsigned long ul, int i3));
/* 4 */
EXTERN char *		XGetAtomName _ANSI_ARGS_((Display* d, Atom a));
/* 5 */
EXTERN char *		XKeysymToString _ANSI_ARGS_((KeySym k));
/* 6 */
EXTERN Colormap		XCreateColormap _ANSI_ARGS_((Display* d, Window w, 
				Visual* v, int i));
/* 7 */
EXTERN GContext		XGContextFromGC _ANSI_ARGS_((GC g));
/* 8 */
EXTERN KeySym		XKeycodeToKeysym _ANSI_ARGS_((Display* d, KeyCode k, 
				int i));
/* 9 */
EXTERN KeySym		XStringToKeysym _ANSI_ARGS_((_Xconst char* c));
/* 10 */
EXTERN Window		XRootWindow _ANSI_ARGS_((Display* d, int i));
/* 11 */
EXTERN XErrorHandler	XSetErrorHandler _ANSI_ARGS_((XErrorHandler x));
/* 12 */
EXTERN Status		XAllocColor _ANSI_ARGS_((Display* d, Colormap c, 
				XColor* xp));
/* 13 */
EXTERN void		XBell _ANSI_ARGS_((Display* d, int i));
/* 14 */
EXTERN void		XChangeProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, Atom a2, int i1, int i2, 
				_Xconst unsigned char* c, int i3));
/* 15 */
EXTERN void		XChangeWindowAttributes _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul, 
				XSetWindowAttributes* x));
/* 16 */
EXTERN void		XConfigureWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int i, XWindowChanges* x));
/* 17 */
EXTERN void		XCopyArea _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4));
/* 18 */
EXTERN void		XCopyPlane _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4, unsigned long ul));
/* 19 */
EXTERN Pixmap		XCreateBitmapFromData _ANSI_ARGS_((Display* display, 
				Drawable d, _Xconst char* data, 
				unsigned int width, unsigned int height));
/* 20 */
EXTERN void		XDefineCursor _ANSI_ARGS_((Display* d, Window w, 
				Cursor c));
/* 21 */
EXTERN void		XDestroyWindow _ANSI_ARGS_((Display* d, Window w));
/* 22 */
EXTERN void		XDrawArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 23 */
EXTERN void		XDrawLines _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2));
/* 24 */
EXTERN void		XDrawRectangle _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 25 */
EXTERN void		XFillArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 26 */
EXTERN void		XFillPolygon _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2, int i3));
/* 27 */
EXTERN void		XFillRectangles _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XRectangle* x, int i));
/* 28 */
EXTERN void		XFreeColormap _ANSI_ARGS_((Display* d, Colormap c));
/* 29 */
EXTERN void		XFreeColors _ANSI_ARGS_((Display* d, Colormap c, 
				unsigned long* ulp, int i, unsigned long ul));
/* 30 */
EXTERN void		XFreeModifiermap _ANSI_ARGS_((XModifierKeymap* x));
/* 31 */
EXTERN Status		XGetGeometry _ANSI_ARGS_((Display* d, Drawable dr, 
				Window* w, int* i1, int* i2, 
				unsigned int* ui1, unsigned int* ui2, 
				unsigned int* ui3, unsigned int* ui4));
/* 32 */
EXTERN int		XGetWindowProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, long l1, long l2, Bool b, Atom a2, 
				Atom* ap, int* ip, unsigned long* ulp1, 
				unsigned long* ulp2, unsigned char** cpp));
/* 33 */
EXTERN int		XGrabKeyboard _ANSI_ARGS_((Display* d, Window w, 
				Bool b, int i1, int i2, Time t));
/* 34 */
EXTERN int		XGrabPointer _ANSI_ARGS_((Display* d, Window w1, 
				Bool b, unsigned int ui, int i1, int i2, 
				Window w2, Cursor c, Time t));
/* 35 */
EXTERN KeyCode		XKeysymToKeycode _ANSI_ARGS_((Display* d, KeySym k));
/* 36 */
EXTERN void		XMapWindow _ANSI_ARGS_((Display* d, Window w));
/* 37 */
EXTERN void		XMoveResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 38 */
EXTERN void		XMoveWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2));
/* 39 */
EXTERN Bool		XQueryPointer _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, int* i1, int* i2, 
				int* i3, int* i4, unsigned int* ui));
/* 40 */
EXTERN void		XRaiseWindow _ANSI_ARGS_((Display* d, Window w));
/* 41 */
EXTERN void		XRefreshKeyboardMapping _ANSI_ARGS_((
				XMappingEvent* x));
/* 42 */
EXTERN void		XResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int ui1, unsigned int ui2));
/* 43 */
EXTERN void		XSelectInput _ANSI_ARGS_((Display* d, Window w, 
				long l));
/* 44 */
EXTERN Status		XSendEvent _ANSI_ARGS_((Display* d, Window w, Bool b, 
				long l, XEvent* x));
/* 45 */
EXTERN void		XSetIconName _ANSI_ARGS_((Display* d, Window w, 
				_Xconst char* c));
/* 46 */
EXTERN void		XSetInputFocus _ANSI_ARGS_((Display* d, Window w, 
				int i, Time t));
/* 47 */
EXTERN void		XSetSelectionOwner _ANSI_ARGS_((Display* d, Atom a, 
				Window w, Time t));
/* 48 */
EXTERN void		XSetWindowBackground _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul));
/* 49 */
EXTERN void		XSetWindowBackgroundPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 50 */
EXTERN void		XSetWindowBorder _ANSI_ARGS_((Display* d, Window w, 
				unsigned long ul));
/* 51 */
EXTERN void		XSetWindowBorderPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 52 */
EXTERN void		XSetWindowBorderWidth _ANSI_ARGS_((Display* d, 
				Window w, unsigned int ui));
/* 53 */
EXTERN void		XSetWindowColormap _ANSI_ARGS_((Display* d, Window w, 
				Colormap c));
/* 54 */
EXTERN void		XUngrabKeyboard _ANSI_ARGS_((Display* d, Time t));
/* 55 */
EXTERN void		XUngrabPointer _ANSI_ARGS_((Display* d, Time t));
/* 56 */
EXTERN void		XUnmapWindow _ANSI_ARGS_((Display* d, Window w));
/* 57 */
EXTERN void		TkPutImage _ANSI_ARGS_((unsigned long * colors, 
				int ncolors, Display* display, Drawable d, 
				GC gc, XImage* image, int src_x, int src_y, 
				int dest_x, int dest_y, unsigned int width, 
				unsigned int height));
/* 58 */
EXTERN Status		XParseColor _ANSI_ARGS_((Display * display, 
				Colormap map, _Xconst char* spec, 
				XColor * colorPtr));
/* 59 */
EXTERN GC		XCreateGC _ANSI_ARGS_((Display* display, Drawable d, 
				unsigned long valuemask, XGCValues* values));
/* 60 */
EXTERN void		XFreeGC _ANSI_ARGS_((Display* display, GC gc));
/* 61 */
EXTERN Atom		XInternAtom _ANSI_ARGS_((Display* display, 
				_Xconst char* atom_name, Bool only_if_exists));
/* 62 */
EXTERN void		XSetBackground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 63 */
EXTERN void		XSetForeground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 64 */
EXTERN void		XSetClipMask _ANSI_ARGS_((Display* display, GC gc, 
				Pixmap pixmap));
/* 65 */
EXTERN void		XSetClipOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int clip_x_origin, int clip_y_origin));
/* 66 */
EXTERN void		XSetTSOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int ts_x_origin, int ts_y_origin));
/* 67 */
EXTERN void		XChangeGC _ANSI_ARGS_((Display * d, GC gc, 
				unsigned long mask, XGCValues * values));
/* 68 */
EXTERN void		XSetFont _ANSI_ARGS_((Display * display, GC gc, 
				Font font));
/* 69 */
EXTERN void		XSetArcMode _ANSI_ARGS_((Display * display, GC gc, 
				int arc_mode));
/* 70 */
EXTERN void		XSetStipple _ANSI_ARGS_((Display * display, GC gc, 
				Pixmap stipple));
/* 71 */
EXTERN void		XSetFillRule _ANSI_ARGS_((Display * display, GC gc, 
				int fill_rule));
/* 72 */
EXTERN void		XSetFillStyle _ANSI_ARGS_((Display * display, GC gc, 
				int fill_style));
/* 73 */
EXTERN void		XSetFunction _ANSI_ARGS_((Display * display, GC gc, 
				int function));
/* 74 */
EXTERN void		XSetLineAttributes _ANSI_ARGS_((Display * display, 
				GC gc, unsigned int line_width, 
				int line_style, int cap_style, 
				int join_style));
/* 75 */
EXTERN int		_XInitImageFuncPtrs _ANSI_ARGS_((XImage * image));
/* 76 */
EXTERN XIC		XCreateIC _ANSI_ARGS_((void));
/* 77 */
EXTERN XVisualInfo *	XGetVisualInfo _ANSI_ARGS_((Display* display, 
				long vinfo_mask, XVisualInfo* vinfo_template, 
				int* nitems_return));
/* 78 */
EXTERN void		XSetWMClientMachine _ANSI_ARGS_((Display* display, 
				Window w, XTextProperty* text_prop));
/* 79 */
EXTERN Status		XStringListToTextProperty _ANSI_ARGS_((char** list, 
				int count, XTextProperty* text_prop_return));
/* 80 */
EXTERN void		XDrawSegments _ANSI_ARGS_((Display * display, 
				Drawable d, GC gc, XSegment * segments, 
				int nsegments));
/* 81 */
EXTERN void		XForceScreenSaver _ANSI_ARGS_((Display* display, 
				int mode));
/* 82 */
EXTERN void		XDrawLine _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int x1, int y1, int x2, int y2));
/* 83 */
EXTERN void		XFillRectangle _ANSI_ARGS_((Display* display, 
				Drawable d, GC gc, int x, int y, 
				unsigned int width, unsigned int height));
/* 84 */
EXTERN void		XClearWindow _ANSI_ARGS_((Display* d, Window w));
/* 85 */
EXTERN void		XDrawPoint _ANSI_ARGS_((Display* display, Drawable d, 
				GC gc, int x, int y));
/* 86 */
EXTERN void		XDrawPoints _ANSI_ARGS_((Display* display, 
				Drawable d, GC gc, XPoint * points, 
				int npoints, int mode));
/* 87 */
EXTERN void		XWarpPointer _ANSI_ARGS_((Display* display, 
				Window src_w, Window dest_w, int src_x, 
				int src_y, unsigned int src_width, 
				unsigned int src_height, int dest_x, 
				int dest_y));
/* 88 */
EXTERN void		XQueryColor _ANSI_ARGS_((Display * display, 
				Colormap colormap, XColor * def_in_out));
/* 89 */
EXTERN void		XQueryColors _ANSI_ARGS_((Display * display, 
				Colormap colormap, XColor * defs_in_out, 
				int ncolors));
/* 90 */
EXTERN Status		XQueryTree _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, Window** w4, 
				unsigned int* ui));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 0 */
EXTERN void		XSetDashes _ANSI_ARGS_((Display* display, GC gc, 
				int dash_offset, _Xconst char* dash_list, 
				int n));
/* 1 */
EXTERN XModifierKeymap*	 XGetModifierMapping _ANSI_ARGS_((Display* d));
/* 2 */
EXTERN XImage *		XCreateImage _ANSI_ARGS_((Display* d, Visual* v, 
				unsigned int ui1, int i1, int i2, char* cp, 
				unsigned int ui2, unsigned int ui3, int i3, 
				int i4));
/* 3 */
EXTERN XImage *		XGetImage _ANSI_ARGS_((Display* d, Drawable dr, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, unsigned long ul, int i3));
/* 4 */
EXTERN char *		XGetAtomName _ANSI_ARGS_((Display* d, Atom a));
/* 5 */
EXTERN char *		XKeysymToString _ANSI_ARGS_((KeySym k));
/* 6 */
EXTERN Colormap		XCreateColormap _ANSI_ARGS_((Display* d, Window w, 
				Visual* v, int i));
/* 7 */
EXTERN GContext		XGContextFromGC _ANSI_ARGS_((GC g));
/* 8 */
EXTERN KeySym		XKeycodeToKeysym _ANSI_ARGS_((Display* d, KeyCode k, 
				int i));
/* 9 */
EXTERN KeySym		XStringToKeysym _ANSI_ARGS_((_Xconst char* c));
/* 10 */
EXTERN Window		XRootWindow _ANSI_ARGS_((Display* d, int i));
/* 11 */
EXTERN XErrorHandler	XSetErrorHandler _ANSI_ARGS_((XErrorHandler x));
/* 12 */
EXTERN Status		XAllocColor _ANSI_ARGS_((Display* d, Colormap c, 
				XColor* xp));
/* 13 */
EXTERN void		XBell _ANSI_ARGS_((Display* d, int i));
/* 14 */
EXTERN void		XChangeProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, Atom a2, int i1, int i2, 
				_Xconst unsigned char* c, int i3));
/* 15 */
EXTERN void		XChangeWindowAttributes _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul, 
				XSetWindowAttributes* x));
/* 16 */
EXTERN void		XConfigureWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int i, XWindowChanges* x));
/* 17 */
EXTERN void		XCopyArea _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4));
/* 18 */
EXTERN void		XCopyPlane _ANSI_ARGS_((Display* d, Drawable dr1, 
				Drawable dr2, GC g, int i1, int i2, 
				unsigned int ui1, unsigned int ui2, int i3, 
				int i4, unsigned long ul));
/* 19 */
EXTERN Pixmap		XCreateBitmapFromData _ANSI_ARGS_((Display* display, 
				Drawable d, _Xconst char* data, 
				unsigned int width, unsigned int height));
/* 20 */
EXTERN void		XDefineCursor _ANSI_ARGS_((Display* d, Window w, 
				Cursor c));
/* 21 */
EXTERN void		XDestroyWindow _ANSI_ARGS_((Display* d, Window w));
/* 22 */
EXTERN void		XDrawArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 23 */
EXTERN void		XDrawLines _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2));
/* 24 */
EXTERN void		XDrawRectangle _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 25 */
EXTERN void		XFillArc _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2, int i3, int i4));
/* 26 */
EXTERN void		XFillPolygon _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XPoint* x, int i1, int i2, int i3));
/* 27 */
EXTERN void		XFillRectangles _ANSI_ARGS_((Display* d, Drawable dr, 
				GC g, XRectangle* x, int i));
/* 28 */
EXTERN void		XFreeColormap _ANSI_ARGS_((Display* d, Colormap c));
/* 29 */
EXTERN void		XFreeColors _ANSI_ARGS_((Display* d, Colormap c, 
				unsigned long* ulp, int i, unsigned long ul));
/* 30 */
EXTERN void		XFreeModifiermap _ANSI_ARGS_((XModifierKeymap* x));
/* 31 */
EXTERN Status		XGetGeometry _ANSI_ARGS_((Display* d, Drawable dr, 
				Window* w, int* i1, int* i2, 
				unsigned int* ui1, unsigned int* ui2, 
				unsigned int* ui3, unsigned int* ui4));
/* 32 */
EXTERN int		XGetWindowProperty _ANSI_ARGS_((Display* d, Window w, 
				Atom a1, long l1, long l2, Bool b, Atom a2, 
				Atom* ap, int* ip, unsigned long* ulp1, 
				unsigned long* ulp2, unsigned char** cpp));
/* 33 */
EXTERN int		XGrabKeyboard _ANSI_ARGS_((Display* d, Window w, 
				Bool b, int i1, int i2, Time t));
/* 34 */
EXTERN int		XGrabPointer _ANSI_ARGS_((Display* d, Window w1, 
				Bool b, unsigned int ui, int i1, int i2, 
				Window w2, Cursor c, Time t));
/* 35 */
EXTERN KeyCode		XKeysymToKeycode _ANSI_ARGS_((Display* d, KeySym k));
/* 36 */
EXTERN void		XMapWindow _ANSI_ARGS_((Display* d, Window w));
/* 37 */
EXTERN void		XMoveResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2, unsigned int ui1, 
				unsigned int ui2));
/* 38 */
EXTERN void		XMoveWindow _ANSI_ARGS_((Display* d, Window w, 
				int i1, int i2));
/* 39 */
EXTERN Bool		XQueryPointer _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, int* i1, int* i2, 
				int* i3, int* i4, unsigned int* ui));
/* 40 */
EXTERN void		XRaiseWindow _ANSI_ARGS_((Display* d, Window w));
/* 41 */
EXTERN void		XRefreshKeyboardMapping _ANSI_ARGS_((
				XMappingEvent* x));
/* 42 */
EXTERN void		XResizeWindow _ANSI_ARGS_((Display* d, Window w, 
				unsigned int ui1, unsigned int ui2));
/* 43 */
EXTERN void		XSelectInput _ANSI_ARGS_((Display* d, Window w, 
				long l));
/* 44 */
EXTERN Status		XSendEvent _ANSI_ARGS_((Display* d, Window w, Bool b, 
				long l, XEvent* x));
/* 45 */
EXTERN void		XSetIconName _ANSI_ARGS_((Display* d, Window w, 
				_Xconst char* c));
/* 46 */
EXTERN void		XSetInputFocus _ANSI_ARGS_((Display* d, Window w, 
				int i, Time t));
/* 47 */
EXTERN void		XSetSelectionOwner _ANSI_ARGS_((Display* d, Atom a, 
				Window w, Time t));
/* 48 */
EXTERN void		XSetWindowBackground _ANSI_ARGS_((Display* d, 
				Window w, unsigned long ul));
/* 49 */
EXTERN void		XSetWindowBackgroundPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 50 */
EXTERN void		XSetWindowBorder _ANSI_ARGS_((Display* d, Window w, 
				unsigned long ul));
/* 51 */
EXTERN void		XSetWindowBorderPixmap _ANSI_ARGS_((Display* d, 
				Window w, Pixmap p));
/* 52 */
EXTERN void		XSetWindowBorderWidth _ANSI_ARGS_((Display* d, 
				Window w, unsigned int ui));
/* 53 */
EXTERN void		XSetWindowColormap _ANSI_ARGS_((Display* d, Window w, 
				Colormap c));
/* 54 */
EXTERN void		XUngrabKeyboard _ANSI_ARGS_((Display* d, Time t));
/* 55 */
EXTERN void		XUngrabPointer _ANSI_ARGS_((Display* d, Time t));
/* 56 */
EXTERN void		XUnmapWindow _ANSI_ARGS_((Display* d, Window w));
/* 57 */
EXTERN void		TkPutImage _ANSI_ARGS_((unsigned long * colors, 
				int ncolors, Display* display, Drawable d, 
				GC gc, XImage* image, int src_x, int src_y, 
				int dest_x, int dest_y, unsigned int width, 
				unsigned int height));
/* 58 */
EXTERN Status		XParseColor _ANSI_ARGS_((Display * display, 
				Colormap map, _Xconst char* spec, 
				XColor * colorPtr));
/* 59 */
EXTERN GC		XCreateGC _ANSI_ARGS_((Display* display, Drawable d, 
				unsigned long valuemask, XGCValues* values));
/* 60 */
EXTERN void		XFreeGC _ANSI_ARGS_((Display* display, GC gc));
/* 61 */
EXTERN Atom		XInternAtom _ANSI_ARGS_((Display* display, 
				_Xconst char* atom_name, Bool only_if_exists));
/* 62 */
EXTERN void		XSetBackground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 63 */
EXTERN void		XSetForeground _ANSI_ARGS_((Display* display, GC gc, 
				unsigned long foreground));
/* 64 */
EXTERN void		XSetClipMask _ANSI_ARGS_((Display* display, GC gc, 
				Pixmap pixmap));
/* 65 */
EXTERN void		XSetClipOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int clip_x_origin, int clip_y_origin));
/* 66 */
EXTERN void		XSetTSOrigin _ANSI_ARGS_((Display* display, GC gc, 
				int ts_x_origin, int ts_y_origin));
/* 67 */
EXTERN void		XChangeGC _ANSI_ARGS_((Display * d, GC gc, 
				unsigned long mask, XGCValues * values));
/* 68 */
EXTERN void		XSetFont _ANSI_ARGS_((Display * display, GC gc, 
				Font font));
/* 69 */
EXTERN void		XSetArcMode _ANSI_ARGS_((Display * display, GC gc, 
				int arc_mode));
/* 70 */
EXTERN void		XSetStipple _ANSI_ARGS_((Display * display, GC gc, 
				Pixmap stipple));
/* 71 */
EXTERN void		XSetFillRule _ANSI_ARGS_((Display * display, GC gc, 
				int fill_rule));
/* 72 */
EXTERN void		XSetFillStyle _ANSI_ARGS_((Display * display, GC gc, 
				int fill_style));
/* 73 */
EXTERN void		XSetFunction _ANSI_ARGS_((Display * display, GC gc, 
				int function));
/* 74 */
EXTERN void		XSetLineAttributes _ANSI_ARGS_((Display * display, 
				GC gc, unsigned int line_width, 
				int line_style, int cap_style, 
				int join_style));
/* 75 */
EXTERN int		_XInitImageFuncPtrs _ANSI_ARGS_((XImage * image));
/* 76 */
EXTERN XIC		XCreateIC _ANSI_ARGS_((void));
/* 77 */
EXTERN XVisualInfo *	XGetVisualInfo _ANSI_ARGS_((Display* display, 
				long vinfo_mask, XVisualInfo* vinfo_template, 
				int* nitems_return));
/* 78 */
EXTERN void		XSetWMClientMachine _ANSI_ARGS_((Display* display, 
				Window w, XTextProperty* text_prop));
/* 79 */
EXTERN Status		XStringListToTextProperty _ANSI_ARGS_((char** list, 
				int count, XTextProperty* text_prop_return));
/* 80 */
EXTERN void		XDrawSegments _ANSI_ARGS_((Display * display, 
				Drawable d, GC gc, XSegment * segments, 
				int nsegments));
/* 81 */
EXTERN void		XForceScreenSaver _ANSI_ARGS_((Display* display, 
				int mode));
/* 82 */
EXTERN void		XDrawLine _ANSI_ARGS_((Display* d, Drawable dr, GC g, 
				int x1, int y1, int x2, int y2));
/* 83 */
EXTERN void		XFillRectangle _ANSI_ARGS_((Display* display, 
				Drawable d, GC gc, int x, int y, 
				unsigned int width, unsigned int height));
/* 84 */
EXTERN void		XClearWindow _ANSI_ARGS_((Display* d, Window w));
/* 85 */
EXTERN void		XDrawPoint _ANSI_ARGS_((Display* display, Drawable d, 
				GC gc, int x, int y));
/* 86 */
EXTERN void		XDrawPoints _ANSI_ARGS_((Display* display, 
				Drawable d, GC gc, XPoint * points, 
				int npoints, int mode));
/* 87 */
EXTERN void		XWarpPointer _ANSI_ARGS_((Display* display, 
				Window src_w, Window dest_w, int src_x, 
				int src_y, unsigned int src_width, 
				unsigned int src_height, int dest_x, 
				int dest_y));
/* 88 */
EXTERN void		XQueryColor _ANSI_ARGS_((Display * display, 
				Colormap colormap, XColor * def_in_out));
/* 89 */
EXTERN void		XQueryColors _ANSI_ARGS_((Display * display, 
				Colormap colormap, XColor * defs_in_out, 
				int ncolors));
/* 90 */
EXTERN Status		XQueryTree _ANSI_ARGS_((Display* d, Window w1, 
				Window* w2, Window* w3, Window** w4, 
				unsigned int* ui));
/* 91 */
EXTERN int		XSync _ANSI_ARGS_((Display * display, Bool flag));
#endif /* MAC_OSX_TK */

typedef struct TkIntXlibStubs {
    int magic;
    struct TkIntXlibStubHooks *hooks;

#ifdef __WIN32__
    void (*xSetDashes) _ANSI_ARGS_((Display* display, GC gc, int dash_offset, _Xconst char* dash_list, int n)); /* 0 */
    XModifierKeymap* (*xGetModifierMapping) _ANSI_ARGS_((Display* d)); /* 1 */
    XImage * (*xCreateImage) _ANSI_ARGS_((Display* d, Visual* v, unsigned int ui1, int i1, int i2, char* cp, unsigned int ui2, unsigned int ui3, int i3, int i4)); /* 2 */
    XImage * (*xGetImage) _ANSI_ARGS_((Display* d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3)); /* 3 */
    char * (*xGetAtomName) _ANSI_ARGS_((Display* d, Atom a)); /* 4 */
    char * (*xKeysymToString) _ANSI_ARGS_((KeySym k)); /* 5 */
    Colormap (*xCreateColormap) _ANSI_ARGS_((Display* d, Window w, Visual* v, int i)); /* 6 */
    Cursor (*xCreatePixmapCursor) _ANSI_ARGS_((Display* d, Pixmap p1, Pixmap p2, XColor* x1, XColor* x2, unsigned int ui1, unsigned int ui2)); /* 7 */
    Cursor (*xCreateGlyphCursor) _ANSI_ARGS_((Display* d, Font f1, Font f2, unsigned int ui1, unsigned int ui2, XColor* x1, XColor* x2)); /* 8 */
    GContext (*xGContextFromGC) _ANSI_ARGS_((GC g)); /* 9 */
    XHostAddress * (*xListHosts) _ANSI_ARGS_((Display* d, int* i, Bool* b)); /* 10 */
    KeySym (*xKeycodeToKeysym) _ANSI_ARGS_((Display* d, unsigned int k, int i)); /* 11 */
    KeySym (*xStringToKeysym) _ANSI_ARGS_((_Xconst char* c)); /* 12 */
    Window (*xRootWindow) _ANSI_ARGS_((Display* d, int i)); /* 13 */
    XErrorHandler (*xSetErrorHandler) _ANSI_ARGS_((XErrorHandler x)); /* 14 */
    Status (*xIconifyWindow) _ANSI_ARGS_((Display* d, Window w, int i)); /* 15 */
    Status (*xWithdrawWindow) _ANSI_ARGS_((Display* d, Window w, int i)); /* 16 */
    Status (*xGetWMColormapWindows) _ANSI_ARGS_((Display* d, Window w, Window** wpp, int* ip)); /* 17 */
    Status (*xAllocColor) _ANSI_ARGS_((Display* d, Colormap c, XColor* xp)); /* 18 */
    void (*xBell) _ANSI_ARGS_((Display* d, int i)); /* 19 */
    void (*xChangeProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char* c, int i3)); /* 20 */
    void (*xChangeWindowAttributes) _ANSI_ARGS_((Display* d, Window w, unsigned long ul, XSetWindowAttributes* x)); /* 21 */
    void (*xClearWindow) _ANSI_ARGS_((Display* d, Window w)); /* 22 */
    void (*xConfigureWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int i, XWindowChanges* x)); /* 23 */
    void (*xCopyArea) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 24 */
    void (*xCopyPlane) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul)); /* 25 */
    Pixmap (*xCreateBitmapFromData) _ANSI_ARGS_((Display* display, Drawable d, _Xconst char* data, unsigned int width, unsigned int height)); /* 26 */
    void (*xDefineCursor) _ANSI_ARGS_((Display* d, Window w, Cursor c)); /* 27 */
    void (*xDeleteProperty) _ANSI_ARGS_((Display* d, Window w, Atom a)); /* 28 */
    void (*xDestroyWindow) _ANSI_ARGS_((Display* d, Window w)); /* 29 */
    void (*xDrawArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 30 */
    void (*xDrawLines) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2)); /* 31 */
    void (*xDrawRectangle) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 32 */
    void (*xFillArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 33 */
    void (*xFillPolygon) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2, int i3)); /* 34 */
    void (*xFillRectangles) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XRectangle* x, int i)); /* 35 */
    void (*xForceScreenSaver) _ANSI_ARGS_((Display* d, int i)); /* 36 */
    void (*xFreeColormap) _ANSI_ARGS_((Display* d, Colormap c)); /* 37 */
    void (*xFreeColors) _ANSI_ARGS_((Display* d, Colormap c, unsigned long* ulp, int i, unsigned long ul)); /* 38 */
    void (*xFreeCursor) _ANSI_ARGS_((Display* d, Cursor c)); /* 39 */
    void (*xFreeModifiermap) _ANSI_ARGS_((XModifierKeymap* x)); /* 40 */
    Status (*xGetGeometry) _ANSI_ARGS_((Display* d, Drawable dr, Window* w, int* i1, int* i2, unsigned int* ui1, unsigned int* ui2, unsigned int* ui3, unsigned int* ui4)); /* 41 */
    void (*xGetInputFocus) _ANSI_ARGS_((Display* d, Window* w, int* i)); /* 42 */
    int (*xGetWindowProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom* ap, int* ip, unsigned long* ulp1, unsigned long* ulp2, unsigned char** cpp)); /* 43 */
    Status (*xGetWindowAttributes) _ANSI_ARGS_((Display* d, Window w, XWindowAttributes* x)); /* 44 */
    int (*xGrabKeyboard) _ANSI_ARGS_((Display* d, Window w, Bool b, int i1, int i2, Time t)); /* 45 */
    int (*xGrabPointer) _ANSI_ARGS_((Display* d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t)); /* 46 */
    KeyCode (*xKeysymToKeycode) _ANSI_ARGS_((Display* d, KeySym k)); /* 47 */
    Status (*xLookupColor) _ANSI_ARGS_((Display* d, Colormap c1, _Xconst char* c2, XColor* x1, XColor* x2)); /* 48 */
    void (*xMapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 49 */
    void (*xMoveResizeWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 50 */
    void (*xMoveWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2)); /* 51 */
    void (*xNextEvent) _ANSI_ARGS_((Display* d, XEvent* x)); /* 52 */
    void (*xPutBackEvent) _ANSI_ARGS_((Display* d, XEvent* x)); /* 53 */
    void (*xQueryColors) _ANSI_ARGS_((Display* d, Colormap c, XColor* x, int i)); /* 54 */
    Bool (*xQueryPointer) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, int* i1, int* i2, int* i3, int* i4, unsigned int* ui)); /* 55 */
    Status (*xQueryTree) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, Window** w4, unsigned int* ui)); /* 56 */
    void (*xRaiseWindow) _ANSI_ARGS_((Display* d, Window w)); /* 57 */
    void (*xRefreshKeyboardMapping) _ANSI_ARGS_((XMappingEvent* x)); /* 58 */
    void (*xResizeWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int ui1, unsigned int ui2)); /* 59 */
    void (*xSelectInput) _ANSI_ARGS_((Display* d, Window w, long l)); /* 60 */
    Status (*xSendEvent) _ANSI_ARGS_((Display* d, Window w, Bool b, long l, XEvent* x)); /* 61 */
    void (*xSetCommand) _ANSI_ARGS_((Display* d, Window w, CONST char** c, int i)); /* 62 */
    void (*xSetIconName) _ANSI_ARGS_((Display* d, Window w, _Xconst char* c)); /* 63 */
    void (*xSetInputFocus) _ANSI_ARGS_((Display* d, Window w, int i, Time t)); /* 64 */
    void (*xSetSelectionOwner) _ANSI_ARGS_((Display* d, Atom a, Window w, Time t)); /* 65 */
    void (*xSetWindowBackground) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 66 */
    void (*xSetWindowBackgroundPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 67 */
    void (*xSetWindowBorder) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 68 */
    void (*xSetWindowBorderPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 69 */
    void (*xSetWindowBorderWidth) _ANSI_ARGS_((Display* d, Window w, unsigned int ui)); /* 70 */
    void (*xSetWindowColormap) _ANSI_ARGS_((Display* d, Window w, Colormap c)); /* 71 */
    Bool (*xTranslateCoordinates) _ANSI_ARGS_((Display* d, Window w1, Window w2, int i1, int i2, int* i3, int* i4, Window* w3)); /* 72 */
    void (*xUngrabKeyboard) _ANSI_ARGS_((Display* d, Time t)); /* 73 */
    void (*xUngrabPointer) _ANSI_ARGS_((Display* d, Time t)); /* 74 */
    void (*xUnmapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 75 */
    void (*xWindowEvent) _ANSI_ARGS_((Display* d, Window w, long l, XEvent* x)); /* 76 */
    void (*xDestroyIC) _ANSI_ARGS_((XIC x)); /* 77 */
    Bool (*xFilterEvent) _ANSI_ARGS_((XEvent* x, Window w)); /* 78 */
    int (*xmbLookupString) _ANSI_ARGS_((XIC xi, XKeyPressedEvent* xk, char* c, int i, KeySym* k, Status* s)); /* 79 */
    void (*tkPutImage) _ANSI_ARGS_((unsigned long * colors, int ncolors, Display* display, Drawable d, GC gc, XImage* image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height)); /* 80 */
    void *reserved81;
    Status (*xParseColor) _ANSI_ARGS_((Display * display, Colormap map, _Xconst char* spec, XColor * colorPtr)); /* 82 */
    GC (*xCreateGC) _ANSI_ARGS_((Display* display, Drawable d, unsigned long valuemask, XGCValues* values)); /* 83 */
    void (*xFreeGC) _ANSI_ARGS_((Display* display, GC gc)); /* 84 */
    Atom (*xInternAtom) _ANSI_ARGS_((Display* display, _Xconst char* atom_name, Bool only_if_exists)); /* 85 */
    void (*xSetBackground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 86 */
    void (*xSetForeground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 87 */
    void (*xSetClipMask) _ANSI_ARGS_((Display* display, GC gc, Pixmap pixmap)); /* 88 */
    void (*xSetClipOrigin) _ANSI_ARGS_((Display* display, GC gc, int clip_x_origin, int clip_y_origin)); /* 89 */
    void (*xSetTSOrigin) _ANSI_ARGS_((Display* display, GC gc, int ts_x_origin, int ts_y_origin)); /* 90 */
    void (*xChangeGC) _ANSI_ARGS_((Display * d, GC gc, unsigned long mask, XGCValues * values)); /* 91 */
    void (*xSetFont) _ANSI_ARGS_((Display * display, GC gc, Font font)); /* 92 */
    void (*xSetArcMode) _ANSI_ARGS_((Display * display, GC gc, int arc_mode)); /* 93 */
    void (*xSetStipple) _ANSI_ARGS_((Display * display, GC gc, Pixmap stipple)); /* 94 */
    void (*xSetFillRule) _ANSI_ARGS_((Display * display, GC gc, int fill_rule)); /* 95 */
    void (*xSetFillStyle) _ANSI_ARGS_((Display * display, GC gc, int fill_style)); /* 96 */
    void (*xSetFunction) _ANSI_ARGS_((Display * display, GC gc, int function)); /* 97 */
    void (*xSetLineAttributes) _ANSI_ARGS_((Display * display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style)); /* 98 */
    int (*_XInitImageFuncPtrs) _ANSI_ARGS_((XImage * image)); /* 99 */
    XIC (*xCreateIC) _ANSI_ARGS_((void)); /* 100 */
    XVisualInfo * (*xGetVisualInfo) _ANSI_ARGS_((Display* display, long vinfo_mask, XVisualInfo* vinfo_template, int* nitems_return)); /* 101 */
    void (*xSetWMClientMachine) _ANSI_ARGS_((Display* display, Window w, XTextProperty* text_prop)); /* 102 */
    Status (*xStringListToTextProperty) _ANSI_ARGS_((char** list, int count, XTextProperty* text_prop_return)); /* 103 */
    void (*xDrawLine) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int x1, int y1, int x2, int y2)); /* 104 */
    void (*xWarpPointer) _ANSI_ARGS_((Display* d, Window s, Window dw, int sx, int sy, unsigned int sw, unsigned int sh, int dx, int dy)); /* 105 */
    void (*xFillRectangle) _ANSI_ARGS_((Display* display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height)); /* 106 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*xSetDashes) _ANSI_ARGS_((Display* display, GC gc, int dash_offset, _Xconst char* dash_list, int n)); /* 0 */
    XModifierKeymap* (*xGetModifierMapping) _ANSI_ARGS_((Display* d)); /* 1 */
    XImage * (*xCreateImage) _ANSI_ARGS_((Display* d, Visual* v, unsigned int ui1, int i1, int i2, char* cp, unsigned int ui2, unsigned int ui3, int i3, int i4)); /* 2 */
    XImage * (*xGetImage) _ANSI_ARGS_((Display* d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3)); /* 3 */
    char * (*xGetAtomName) _ANSI_ARGS_((Display* d, Atom a)); /* 4 */
    char * (*xKeysymToString) _ANSI_ARGS_((KeySym k)); /* 5 */
    Colormap (*xCreateColormap) _ANSI_ARGS_((Display* d, Window w, Visual* v, int i)); /* 6 */
    GContext (*xGContextFromGC) _ANSI_ARGS_((GC g)); /* 7 */
    KeySym (*xKeycodeToKeysym) _ANSI_ARGS_((Display* d, KeyCode k, int i)); /* 8 */
    KeySym (*xStringToKeysym) _ANSI_ARGS_((_Xconst char* c)); /* 9 */
    Window (*xRootWindow) _ANSI_ARGS_((Display* d, int i)); /* 10 */
    XErrorHandler (*xSetErrorHandler) _ANSI_ARGS_((XErrorHandler x)); /* 11 */
    Status (*xAllocColor) _ANSI_ARGS_((Display* d, Colormap c, XColor* xp)); /* 12 */
    void (*xBell) _ANSI_ARGS_((Display* d, int i)); /* 13 */
    void (*xChangeProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char* c, int i3)); /* 14 */
    void (*xChangeWindowAttributes) _ANSI_ARGS_((Display* d, Window w, unsigned long ul, XSetWindowAttributes* x)); /* 15 */
    void (*xConfigureWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int i, XWindowChanges* x)); /* 16 */
    void (*xCopyArea) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 17 */
    void (*xCopyPlane) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul)); /* 18 */
    Pixmap (*xCreateBitmapFromData) _ANSI_ARGS_((Display* display, Drawable d, _Xconst char* data, unsigned int width, unsigned int height)); /* 19 */
    void (*xDefineCursor) _ANSI_ARGS_((Display* d, Window w, Cursor c)); /* 20 */
    void (*xDestroyWindow) _ANSI_ARGS_((Display* d, Window w)); /* 21 */
    void (*xDrawArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 22 */
    void (*xDrawLines) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2)); /* 23 */
    void (*xDrawRectangle) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 24 */
    void (*xFillArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 25 */
    void (*xFillPolygon) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2, int i3)); /* 26 */
    void (*xFillRectangles) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XRectangle* x, int i)); /* 27 */
    void (*xFreeColormap) _ANSI_ARGS_((Display* d, Colormap c)); /* 28 */
    void (*xFreeColors) _ANSI_ARGS_((Display* d, Colormap c, unsigned long* ulp, int i, unsigned long ul)); /* 29 */
    void (*xFreeModifiermap) _ANSI_ARGS_((XModifierKeymap* x)); /* 30 */
    Status (*xGetGeometry) _ANSI_ARGS_((Display* d, Drawable dr, Window* w, int* i1, int* i2, unsigned int* ui1, unsigned int* ui2, unsigned int* ui3, unsigned int* ui4)); /* 31 */
    int (*xGetWindowProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom* ap, int* ip, unsigned long* ulp1, unsigned long* ulp2, unsigned char** cpp)); /* 32 */
    int (*xGrabKeyboard) _ANSI_ARGS_((Display* d, Window w, Bool b, int i1, int i2, Time t)); /* 33 */
    int (*xGrabPointer) _ANSI_ARGS_((Display* d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t)); /* 34 */
    KeyCode (*xKeysymToKeycode) _ANSI_ARGS_((Display* d, KeySym k)); /* 35 */
    void (*xMapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 36 */
    void (*xMoveResizeWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 37 */
    void (*xMoveWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2)); /* 38 */
    Bool (*xQueryPointer) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, int* i1, int* i2, int* i3, int* i4, unsigned int* ui)); /* 39 */
    void (*xRaiseWindow) _ANSI_ARGS_((Display* d, Window w)); /* 40 */
    void (*xRefreshKeyboardMapping) _ANSI_ARGS_((XMappingEvent* x)); /* 41 */
    void (*xResizeWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int ui1, unsigned int ui2)); /* 42 */
    void (*xSelectInput) _ANSI_ARGS_((Display* d, Window w, long l)); /* 43 */
    Status (*xSendEvent) _ANSI_ARGS_((Display* d, Window w, Bool b, long l, XEvent* x)); /* 44 */
    void (*xSetIconName) _ANSI_ARGS_((Display* d, Window w, _Xconst char* c)); /* 45 */
    void (*xSetInputFocus) _ANSI_ARGS_((Display* d, Window w, int i, Time t)); /* 46 */
    void (*xSetSelectionOwner) _ANSI_ARGS_((Display* d, Atom a, Window w, Time t)); /* 47 */
    void (*xSetWindowBackground) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 48 */
    void (*xSetWindowBackgroundPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 49 */
    void (*xSetWindowBorder) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 50 */
    void (*xSetWindowBorderPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 51 */
    void (*xSetWindowBorderWidth) _ANSI_ARGS_((Display* d, Window w, unsigned int ui)); /* 52 */
    void (*xSetWindowColormap) _ANSI_ARGS_((Display* d, Window w, Colormap c)); /* 53 */
    void (*xUngrabKeyboard) _ANSI_ARGS_((Display* d, Time t)); /* 54 */
    void (*xUngrabPointer) _ANSI_ARGS_((Display* d, Time t)); /* 55 */
    void (*xUnmapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 56 */
    void (*tkPutImage) _ANSI_ARGS_((unsigned long * colors, int ncolors, Display* display, Drawable d, GC gc, XImage* image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height)); /* 57 */
    Status (*xParseColor) _ANSI_ARGS_((Display * display, Colormap map, _Xconst char* spec, XColor * colorPtr)); /* 58 */
    GC (*xCreateGC) _ANSI_ARGS_((Display* display, Drawable d, unsigned long valuemask, XGCValues* values)); /* 59 */
    void (*xFreeGC) _ANSI_ARGS_((Display* display, GC gc)); /* 60 */
    Atom (*xInternAtom) _ANSI_ARGS_((Display* display, _Xconst char* atom_name, Bool only_if_exists)); /* 61 */
    void (*xSetBackground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 62 */
    void (*xSetForeground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 63 */
    void (*xSetClipMask) _ANSI_ARGS_((Display* display, GC gc, Pixmap pixmap)); /* 64 */
    void (*xSetClipOrigin) _ANSI_ARGS_((Display* display, GC gc, int clip_x_origin, int clip_y_origin)); /* 65 */
    void (*xSetTSOrigin) _ANSI_ARGS_((Display* display, GC gc, int ts_x_origin, int ts_y_origin)); /* 66 */
    void (*xChangeGC) _ANSI_ARGS_((Display * d, GC gc, unsigned long mask, XGCValues * values)); /* 67 */
    void (*xSetFont) _ANSI_ARGS_((Display * display, GC gc, Font font)); /* 68 */
    void (*xSetArcMode) _ANSI_ARGS_((Display * display, GC gc, int arc_mode)); /* 69 */
    void (*xSetStipple) _ANSI_ARGS_((Display * display, GC gc, Pixmap stipple)); /* 70 */
    void (*xSetFillRule) _ANSI_ARGS_((Display * display, GC gc, int fill_rule)); /* 71 */
    void (*xSetFillStyle) _ANSI_ARGS_((Display * display, GC gc, int fill_style)); /* 72 */
    void (*xSetFunction) _ANSI_ARGS_((Display * display, GC gc, int function)); /* 73 */
    void (*xSetLineAttributes) _ANSI_ARGS_((Display * display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style)); /* 74 */
    int (*_XInitImageFuncPtrs) _ANSI_ARGS_((XImage * image)); /* 75 */
    XIC (*xCreateIC) _ANSI_ARGS_((void)); /* 76 */
    XVisualInfo * (*xGetVisualInfo) _ANSI_ARGS_((Display* display, long vinfo_mask, XVisualInfo* vinfo_template, int* nitems_return)); /* 77 */
    void (*xSetWMClientMachine) _ANSI_ARGS_((Display* display, Window w, XTextProperty* text_prop)); /* 78 */
    Status (*xStringListToTextProperty) _ANSI_ARGS_((char** list, int count, XTextProperty* text_prop_return)); /* 79 */
    void (*xDrawSegments) _ANSI_ARGS_((Display * display, Drawable d, GC gc, XSegment * segments, int nsegments)); /* 80 */
    void (*xForceScreenSaver) _ANSI_ARGS_((Display* display, int mode)); /* 81 */
    void (*xDrawLine) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int x1, int y1, int x2, int y2)); /* 82 */
    void (*xFillRectangle) _ANSI_ARGS_((Display* display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height)); /* 83 */
    void (*xClearWindow) _ANSI_ARGS_((Display* d, Window w)); /* 84 */
    void (*xDrawPoint) _ANSI_ARGS_((Display* display, Drawable d, GC gc, int x, int y)); /* 85 */
    void (*xDrawPoints) _ANSI_ARGS_((Display* display, Drawable d, GC gc, XPoint * points, int npoints, int mode)); /* 86 */
    void (*xWarpPointer) _ANSI_ARGS_((Display* display, Window src_w, Window dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y)); /* 87 */
    void (*xQueryColor) _ANSI_ARGS_((Display * display, Colormap colormap, XColor * def_in_out)); /* 88 */
    void (*xQueryColors) _ANSI_ARGS_((Display * display, Colormap colormap, XColor * defs_in_out, int ncolors)); /* 89 */
    Status (*xQueryTree) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, Window** w4, unsigned int* ui)); /* 90 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*xSetDashes) _ANSI_ARGS_((Display* display, GC gc, int dash_offset, _Xconst char* dash_list, int n)); /* 0 */
    XModifierKeymap* (*xGetModifierMapping) _ANSI_ARGS_((Display* d)); /* 1 */
    XImage * (*xCreateImage) _ANSI_ARGS_((Display* d, Visual* v, unsigned int ui1, int i1, int i2, char* cp, unsigned int ui2, unsigned int ui3, int i3, int i4)); /* 2 */
    XImage * (*xGetImage) _ANSI_ARGS_((Display* d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3)); /* 3 */
    char * (*xGetAtomName) _ANSI_ARGS_((Display* d, Atom a)); /* 4 */
    char * (*xKeysymToString) _ANSI_ARGS_((KeySym k)); /* 5 */
    Colormap (*xCreateColormap) _ANSI_ARGS_((Display* d, Window w, Visual* v, int i)); /* 6 */
    GContext (*xGContextFromGC) _ANSI_ARGS_((GC g)); /* 7 */
    KeySym (*xKeycodeToKeysym) _ANSI_ARGS_((Display* d, KeyCode k, int i)); /* 8 */
    KeySym (*xStringToKeysym) _ANSI_ARGS_((_Xconst char* c)); /* 9 */
    Window (*xRootWindow) _ANSI_ARGS_((Display* d, int i)); /* 10 */
    XErrorHandler (*xSetErrorHandler) _ANSI_ARGS_((XErrorHandler x)); /* 11 */
    Status (*xAllocColor) _ANSI_ARGS_((Display* d, Colormap c, XColor* xp)); /* 12 */
    void (*xBell) _ANSI_ARGS_((Display* d, int i)); /* 13 */
    void (*xChangeProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char* c, int i3)); /* 14 */
    void (*xChangeWindowAttributes) _ANSI_ARGS_((Display* d, Window w, unsigned long ul, XSetWindowAttributes* x)); /* 15 */
    void (*xConfigureWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int i, XWindowChanges* x)); /* 16 */
    void (*xCopyArea) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 17 */
    void (*xCopyPlane) _ANSI_ARGS_((Display* d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul)); /* 18 */
    Pixmap (*xCreateBitmapFromData) _ANSI_ARGS_((Display* display, Drawable d, _Xconst char* data, unsigned int width, unsigned int height)); /* 19 */
    void (*xDefineCursor) _ANSI_ARGS_((Display* d, Window w, Cursor c)); /* 20 */
    void (*xDestroyWindow) _ANSI_ARGS_((Display* d, Window w)); /* 21 */
    void (*xDrawArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 22 */
    void (*xDrawLines) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2)); /* 23 */
    void (*xDrawRectangle) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 24 */
    void (*xFillArc) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4)); /* 25 */
    void (*xFillPolygon) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XPoint* x, int i1, int i2, int i3)); /* 26 */
    void (*xFillRectangles) _ANSI_ARGS_((Display* d, Drawable dr, GC g, XRectangle* x, int i)); /* 27 */
    void (*xFreeColormap) _ANSI_ARGS_((Display* d, Colormap c)); /* 28 */
    void (*xFreeColors) _ANSI_ARGS_((Display* d, Colormap c, unsigned long* ulp, int i, unsigned long ul)); /* 29 */
    void (*xFreeModifiermap) _ANSI_ARGS_((XModifierKeymap* x)); /* 30 */
    Status (*xGetGeometry) _ANSI_ARGS_((Display* d, Drawable dr, Window* w, int* i1, int* i2, unsigned int* ui1, unsigned int* ui2, unsigned int* ui3, unsigned int* ui4)); /* 31 */
    int (*xGetWindowProperty) _ANSI_ARGS_((Display* d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom* ap, int* ip, unsigned long* ulp1, unsigned long* ulp2, unsigned char** cpp)); /* 32 */
    int (*xGrabKeyboard) _ANSI_ARGS_((Display* d, Window w, Bool b, int i1, int i2, Time t)); /* 33 */
    int (*xGrabPointer) _ANSI_ARGS_((Display* d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t)); /* 34 */
    KeyCode (*xKeysymToKeycode) _ANSI_ARGS_((Display* d, KeySym k)); /* 35 */
    void (*xMapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 36 */
    void (*xMoveResizeWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2)); /* 37 */
    void (*xMoveWindow) _ANSI_ARGS_((Display* d, Window w, int i1, int i2)); /* 38 */
    Bool (*xQueryPointer) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, int* i1, int* i2, int* i3, int* i4, unsigned int* ui)); /* 39 */
    void (*xRaiseWindow) _ANSI_ARGS_((Display* d, Window w)); /* 40 */
    void (*xRefreshKeyboardMapping) _ANSI_ARGS_((XMappingEvent* x)); /* 41 */
    void (*xResizeWindow) _ANSI_ARGS_((Display* d, Window w, unsigned int ui1, unsigned int ui2)); /* 42 */
    void (*xSelectInput) _ANSI_ARGS_((Display* d, Window w, long l)); /* 43 */
    Status (*xSendEvent) _ANSI_ARGS_((Display* d, Window w, Bool b, long l, XEvent* x)); /* 44 */
    void (*xSetIconName) _ANSI_ARGS_((Display* d, Window w, _Xconst char* c)); /* 45 */
    void (*xSetInputFocus) _ANSI_ARGS_((Display* d, Window w, int i, Time t)); /* 46 */
    void (*xSetSelectionOwner) _ANSI_ARGS_((Display* d, Atom a, Window w, Time t)); /* 47 */
    void (*xSetWindowBackground) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 48 */
    void (*xSetWindowBackgroundPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 49 */
    void (*xSetWindowBorder) _ANSI_ARGS_((Display* d, Window w, unsigned long ul)); /* 50 */
    void (*xSetWindowBorderPixmap) _ANSI_ARGS_((Display* d, Window w, Pixmap p)); /* 51 */
    void (*xSetWindowBorderWidth) _ANSI_ARGS_((Display* d, Window w, unsigned int ui)); /* 52 */
    void (*xSetWindowColormap) _ANSI_ARGS_((Display* d, Window w, Colormap c)); /* 53 */
    void (*xUngrabKeyboard) _ANSI_ARGS_((Display* d, Time t)); /* 54 */
    void (*xUngrabPointer) _ANSI_ARGS_((Display* d, Time t)); /* 55 */
    void (*xUnmapWindow) _ANSI_ARGS_((Display* d, Window w)); /* 56 */
    void (*tkPutImage) _ANSI_ARGS_((unsigned long * colors, int ncolors, Display* display, Drawable d, GC gc, XImage* image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height)); /* 57 */
    Status (*xParseColor) _ANSI_ARGS_((Display * display, Colormap map, _Xconst char* spec, XColor * colorPtr)); /* 58 */
    GC (*xCreateGC) _ANSI_ARGS_((Display* display, Drawable d, unsigned long valuemask, XGCValues* values)); /* 59 */
    void (*xFreeGC) _ANSI_ARGS_((Display* display, GC gc)); /* 60 */
    Atom (*xInternAtom) _ANSI_ARGS_((Display* display, _Xconst char* atom_name, Bool only_if_exists)); /* 61 */
    void (*xSetBackground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 62 */
    void (*xSetForeground) _ANSI_ARGS_((Display* display, GC gc, unsigned long foreground)); /* 63 */
    void (*xSetClipMask) _ANSI_ARGS_((Display* display, GC gc, Pixmap pixmap)); /* 64 */
    void (*xSetClipOrigin) _ANSI_ARGS_((Display* display, GC gc, int clip_x_origin, int clip_y_origin)); /* 65 */
    void (*xSetTSOrigin) _ANSI_ARGS_((Display* display, GC gc, int ts_x_origin, int ts_y_origin)); /* 66 */
    void (*xChangeGC) _ANSI_ARGS_((Display * d, GC gc, unsigned long mask, XGCValues * values)); /* 67 */
    void (*xSetFont) _ANSI_ARGS_((Display * display, GC gc, Font font)); /* 68 */
    void (*xSetArcMode) _ANSI_ARGS_((Display * display, GC gc, int arc_mode)); /* 69 */
    void (*xSetStipple) _ANSI_ARGS_((Display * display, GC gc, Pixmap stipple)); /* 70 */
    void (*xSetFillRule) _ANSI_ARGS_((Display * display, GC gc, int fill_rule)); /* 71 */
    void (*xSetFillStyle) _ANSI_ARGS_((Display * display, GC gc, int fill_style)); /* 72 */
    void (*xSetFunction) _ANSI_ARGS_((Display * display, GC gc, int function)); /* 73 */
    void (*xSetLineAttributes) _ANSI_ARGS_((Display * display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style)); /* 74 */
    int (*_XInitImageFuncPtrs) _ANSI_ARGS_((XImage * image)); /* 75 */
    XIC (*xCreateIC) _ANSI_ARGS_((void)); /* 76 */
    XVisualInfo * (*xGetVisualInfo) _ANSI_ARGS_((Display* display, long vinfo_mask, XVisualInfo* vinfo_template, int* nitems_return)); /* 77 */
    void (*xSetWMClientMachine) _ANSI_ARGS_((Display* display, Window w, XTextProperty* text_prop)); /* 78 */
    Status (*xStringListToTextProperty) _ANSI_ARGS_((char** list, int count, XTextProperty* text_prop_return)); /* 79 */
    void (*xDrawSegments) _ANSI_ARGS_((Display * display, Drawable d, GC gc, XSegment * segments, int nsegments)); /* 80 */
    void (*xForceScreenSaver) _ANSI_ARGS_((Display* display, int mode)); /* 81 */
    void (*xDrawLine) _ANSI_ARGS_((Display* d, Drawable dr, GC g, int x1, int y1, int x2, int y2)); /* 82 */
    void (*xFillRectangle) _ANSI_ARGS_((Display* display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height)); /* 83 */
    void (*xClearWindow) _ANSI_ARGS_((Display* d, Window w)); /* 84 */
    void (*xDrawPoint) _ANSI_ARGS_((Display* display, Drawable d, GC gc, int x, int y)); /* 85 */
    void (*xDrawPoints) _ANSI_ARGS_((Display* display, Drawable d, GC gc, XPoint * points, int npoints, int mode)); /* 86 */
    void (*xWarpPointer) _ANSI_ARGS_((Display* display, Window src_w, Window dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y)); /* 87 */
    void (*xQueryColor) _ANSI_ARGS_((Display * display, Colormap colormap, XColor * def_in_out)); /* 88 */
    void (*xQueryColors) _ANSI_ARGS_((Display * display, Colormap colormap, XColor * defs_in_out, int ncolors)); /* 89 */
    Status (*xQueryTree) _ANSI_ARGS_((Display* d, Window w1, Window* w2, Window* w3, Window** w4, unsigned int* ui)); /* 90 */
    int (*xSync) _ANSI_ARGS_((Display * display, Bool flag)); /* 91 */
#endif /* MAC_OSX_TK */
} TkIntXlibStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntXlibStubs *tkIntXlibStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__
#ifndef XSetDashes
#define XSetDashes \
	(tkIntXlibStubsPtr->xSetDashes) /* 0 */
#endif
#ifndef XGetModifierMapping
#define XGetModifierMapping \
	(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */
#endif
#ifndef XCreateImage
#define XCreateImage \
	(tkIntXlibStubsPtr->xCreateImage) /* 2 */
#endif
#ifndef XGetImage
#define XGetImage \
	(tkIntXlibStubsPtr->xGetImage) /* 3 */
#endif
#ifndef XGetAtomName
#define XGetAtomName \
	(tkIntXlibStubsPtr->xGetAtomName) /* 4 */
#endif
#ifndef XKeysymToString
#define XKeysymToString \
	(tkIntXlibStubsPtr->xKeysymToString) /* 5 */
#endif
#ifndef XCreateColormap
#define XCreateColormap \
	(tkIntXlibStubsPtr->xCreateColormap) /* 6 */
#endif
#ifndef XCreatePixmapCursor
#define XCreatePixmapCursor \
	(tkIntXlibStubsPtr->xCreatePixmapCursor) /* 7 */
#endif
#ifndef XCreateGlyphCursor
#define XCreateGlyphCursor \
	(tkIntXlibStubsPtr->xCreateGlyphCursor) /* 8 */
#endif
#ifndef XGContextFromGC
#define XGContextFromGC \
	(tkIntXlibStubsPtr->xGContextFromGC) /* 9 */
#endif
#ifndef XListHosts
#define XListHosts \
	(tkIntXlibStubsPtr->xListHosts) /* 10 */
#endif
#ifndef XKeycodeToKeysym
#define XKeycodeToKeysym \
	(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 11 */
#endif
#ifndef XStringToKeysym
#define XStringToKeysym \
	(tkIntXlibStubsPtr->xStringToKeysym) /* 12 */
#endif
#ifndef XRootWindow
#define XRootWindow \
	(tkIntXlibStubsPtr->xRootWindow) /* 13 */
#endif
#ifndef XSetErrorHandler
#define XSetErrorHandler \
	(tkIntXlibStubsPtr->xSetErrorHandler) /* 14 */
#endif
#ifndef XIconifyWindow
#define XIconifyWindow \
	(tkIntXlibStubsPtr->xIconifyWindow) /* 15 */
#endif
#ifndef XWithdrawWindow
#define XWithdrawWindow \
	(tkIntXlibStubsPtr->xWithdrawWindow) /* 16 */
#endif
#ifndef XGetWMColormapWindows
#define XGetWMColormapWindows \
	(tkIntXlibStubsPtr->xGetWMColormapWindows) /* 17 */
#endif
#ifndef XAllocColor
#define XAllocColor \
	(tkIntXlibStubsPtr->xAllocColor) /* 18 */
#endif
#ifndef XBell
#define XBell \
	(tkIntXlibStubsPtr->xBell) /* 19 */
#endif
#ifndef XChangeProperty
#define XChangeProperty \
	(tkIntXlibStubsPtr->xChangeProperty) /* 20 */
#endif
#ifndef XChangeWindowAttributes
#define XChangeWindowAttributes \
	(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 21 */
#endif
#ifndef XClearWindow
#define XClearWindow \
	(tkIntXlibStubsPtr->xClearWindow) /* 22 */
#endif
#ifndef XConfigureWindow
#define XConfigureWindow \
	(tkIntXlibStubsPtr->xConfigureWindow) /* 23 */
#endif
#ifndef XCopyArea
#define XCopyArea \
	(tkIntXlibStubsPtr->xCopyArea) /* 24 */
#endif
#ifndef XCopyPlane
#define XCopyPlane \
	(tkIntXlibStubsPtr->xCopyPlane) /* 25 */
#endif
#ifndef XCreateBitmapFromData
#define XCreateBitmapFromData \
	(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 26 */
#endif
#ifndef XDefineCursor
#define XDefineCursor \
	(tkIntXlibStubsPtr->xDefineCursor) /* 27 */
#endif
#ifndef XDeleteProperty
#define XDeleteProperty \
	(tkIntXlibStubsPtr->xDeleteProperty) /* 28 */
#endif
#ifndef XDestroyWindow
#define XDestroyWindow \
	(tkIntXlibStubsPtr->xDestroyWindow) /* 29 */
#endif
#ifndef XDrawArc
#define XDrawArc \
	(tkIntXlibStubsPtr->xDrawArc) /* 30 */
#endif
#ifndef XDrawLines
#define XDrawLines \
	(tkIntXlibStubsPtr->xDrawLines) /* 31 */
#endif
#ifndef XDrawRectangle
#define XDrawRectangle \
	(tkIntXlibStubsPtr->xDrawRectangle) /* 32 */
#endif
#ifndef XFillArc
#define XFillArc \
	(tkIntXlibStubsPtr->xFillArc) /* 33 */
#endif
#ifndef XFillPolygon
#define XFillPolygon \
	(tkIntXlibStubsPtr->xFillPolygon) /* 34 */
#endif
#ifndef XFillRectangles
#define XFillRectangles \
	(tkIntXlibStubsPtr->xFillRectangles) /* 35 */
#endif
#ifndef XForceScreenSaver
#define XForceScreenSaver \
	(tkIntXlibStubsPtr->xForceScreenSaver) /* 36 */
#endif
#ifndef XFreeColormap
#define XFreeColormap \
	(tkIntXlibStubsPtr->xFreeColormap) /* 37 */
#endif
#ifndef XFreeColors
#define XFreeColors \
	(tkIntXlibStubsPtr->xFreeColors) /* 38 */
#endif
#ifndef XFreeCursor
#define XFreeCursor \
	(tkIntXlibStubsPtr->xFreeCursor) /* 39 */
#endif
#ifndef XFreeModifiermap
#define XFreeModifiermap \
	(tkIntXlibStubsPtr->xFreeModifiermap) /* 40 */
#endif
#ifndef XGetGeometry
#define XGetGeometry \
	(tkIntXlibStubsPtr->xGetGeometry) /* 41 */
#endif
#ifndef XGetInputFocus
#define XGetInputFocus \
	(tkIntXlibStubsPtr->xGetInputFocus) /* 42 */
#endif
#ifndef XGetWindowProperty
#define XGetWindowProperty \
	(tkIntXlibStubsPtr->xGetWindowProperty) /* 43 */
#endif
#ifndef XGetWindowAttributes
#define XGetWindowAttributes \
	(tkIntXlibStubsPtr->xGetWindowAttributes) /* 44 */
#endif
#ifndef XGrabKeyboard
#define XGrabKeyboard \
	(tkIntXlibStubsPtr->xGrabKeyboard) /* 45 */
#endif
#ifndef XGrabPointer
#define XGrabPointer \
	(tkIntXlibStubsPtr->xGrabPointer) /* 46 */
#endif
#ifndef XKeysymToKeycode
#define XKeysymToKeycode \
	(tkIntXlibStubsPtr->xKeysymToKeycode) /* 47 */
#endif
#ifndef XLookupColor
#define XLookupColor \
	(tkIntXlibStubsPtr->xLookupColor) /* 48 */
#endif
#ifndef XMapWindow
#define XMapWindow \
	(tkIntXlibStubsPtr->xMapWindow) /* 49 */
#endif
#ifndef XMoveResizeWindow
#define XMoveResizeWindow \
	(tkIntXlibStubsPtr->xMoveResizeWindow) /* 50 */
#endif
#ifndef XMoveWindow
#define XMoveWindow \
	(tkIntXlibStubsPtr->xMoveWindow) /* 51 */
#endif
#ifndef XNextEvent
#define XNextEvent \
	(tkIntXlibStubsPtr->xNextEvent) /* 52 */
#endif
#ifndef XPutBackEvent
#define XPutBackEvent \
	(tkIntXlibStubsPtr->xPutBackEvent) /* 53 */
#endif
#ifndef XQueryColors
#define XQueryColors \
	(tkIntXlibStubsPtr->xQueryColors) /* 54 */
#endif
#ifndef XQueryPointer
#define XQueryPointer \
	(tkIntXlibStubsPtr->xQueryPointer) /* 55 */
#endif
#ifndef XQueryTree
#define XQueryTree \
	(tkIntXlibStubsPtr->xQueryTree) /* 56 */
#endif
#ifndef XRaiseWindow
#define XRaiseWindow \
	(tkIntXlibStubsPtr->xRaiseWindow) /* 57 */
#endif
#ifndef XRefreshKeyboardMapping
#define XRefreshKeyboardMapping \
	(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 58 */
#endif
#ifndef XResizeWindow
#define XResizeWindow \
	(tkIntXlibStubsPtr->xResizeWindow) /* 59 */
#endif
#ifndef XSelectInput
#define XSelectInput \
	(tkIntXlibStubsPtr->xSelectInput) /* 60 */
#endif
#ifndef XSendEvent
#define XSendEvent \
	(tkIntXlibStubsPtr->xSendEvent) /* 61 */
#endif
#ifndef XSetCommand
#define XSetCommand \
	(tkIntXlibStubsPtr->xSetCommand) /* 62 */
#endif
#ifndef XSetIconName
#define XSetIconName \
	(tkIntXlibStubsPtr->xSetIconName) /* 63 */
#endif
#ifndef XSetInputFocus
#define XSetInputFocus \
	(tkIntXlibStubsPtr->xSetInputFocus) /* 64 */
#endif
#ifndef XSetSelectionOwner
#define XSetSelectionOwner \
	(tkIntXlibStubsPtr->xSetSelectionOwner) /* 65 */
#endif
#ifndef XSetWindowBackground
#define XSetWindowBackground \
	(tkIntXlibStubsPtr->xSetWindowBackground) /* 66 */
#endif
#ifndef XSetWindowBackgroundPixmap
#define XSetWindowBackgroundPixmap \
	(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 67 */
#endif
#ifndef XSetWindowBorder
#define XSetWindowBorder \
	(tkIntXlibStubsPtr->xSetWindowBorder) /* 68 */
#endif
#ifndef XSetWindowBorderPixmap
#define XSetWindowBorderPixmap \
	(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 69 */
#endif
#ifndef XSetWindowBorderWidth
#define XSetWindowBorderWidth \
	(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 70 */
#endif
#ifndef XSetWindowColormap
#define XSetWindowColormap \
	(tkIntXlibStubsPtr->xSetWindowColormap) /* 71 */
#endif
#ifndef XTranslateCoordinates
#define XTranslateCoordinates \
	(tkIntXlibStubsPtr->xTranslateCoordinates) /* 72 */
#endif
#ifndef XUngrabKeyboard
#define XUngrabKeyboard \
	(tkIntXlibStubsPtr->xUngrabKeyboard) /* 73 */
#endif
#ifndef XUngrabPointer
#define XUngrabPointer \
	(tkIntXlibStubsPtr->xUngrabPointer) /* 74 */
#endif
#ifndef XUnmapWindow
#define XUnmapWindow \
	(tkIntXlibStubsPtr->xUnmapWindow) /* 75 */
#endif
#ifndef XWindowEvent
#define XWindowEvent \
	(tkIntXlibStubsPtr->xWindowEvent) /* 76 */
#endif
#ifndef XDestroyIC
#define XDestroyIC \
	(tkIntXlibStubsPtr->xDestroyIC) /* 77 */
#endif
#ifndef XFilterEvent
#define XFilterEvent \
	(tkIntXlibStubsPtr->xFilterEvent) /* 78 */
#endif
#ifndef XmbLookupString
#define XmbLookupString \
	(tkIntXlibStubsPtr->xmbLookupString) /* 79 */
#endif
#ifndef TkPutImage
#define TkPutImage \
	(tkIntXlibStubsPtr->tkPutImage) /* 80 */
#endif
/* Slot 81 is reserved */
#ifndef XParseColor
#define XParseColor \
	(tkIntXlibStubsPtr->xParseColor) /* 82 */
#endif
#ifndef XCreateGC
#define XCreateGC \
	(tkIntXlibStubsPtr->xCreateGC) /* 83 */
#endif
#ifndef XFreeGC
#define XFreeGC \
	(tkIntXlibStubsPtr->xFreeGC) /* 84 */
#endif
#ifndef XInternAtom
#define XInternAtom \
	(tkIntXlibStubsPtr->xInternAtom) /* 85 */
#endif
#ifndef XSetBackground
#define XSetBackground \
	(tkIntXlibStubsPtr->xSetBackground) /* 86 */
#endif
#ifndef XSetForeground
#define XSetForeground \
	(tkIntXlibStubsPtr->xSetForeground) /* 87 */
#endif
#ifndef XSetClipMask
#define XSetClipMask \
	(tkIntXlibStubsPtr->xSetClipMask) /* 88 */
#endif
#ifndef XSetClipOrigin
#define XSetClipOrigin \
	(tkIntXlibStubsPtr->xSetClipOrigin) /* 89 */
#endif
#ifndef XSetTSOrigin
#define XSetTSOrigin \
	(tkIntXlibStubsPtr->xSetTSOrigin) /* 90 */
#endif
#ifndef XChangeGC
#define XChangeGC \
	(tkIntXlibStubsPtr->xChangeGC) /* 91 */
#endif
#ifndef XSetFont
#define XSetFont \
	(tkIntXlibStubsPtr->xSetFont) /* 92 */
#endif
#ifndef XSetArcMode
#define XSetArcMode \
	(tkIntXlibStubsPtr->xSetArcMode) /* 93 */
#endif
#ifndef XSetStipple
#define XSetStipple \
	(tkIntXlibStubsPtr->xSetStipple) /* 94 */
#endif
#ifndef XSetFillRule
#define XSetFillRule \
	(tkIntXlibStubsPtr->xSetFillRule) /* 95 */
#endif
#ifndef XSetFillStyle
#define XSetFillStyle \
	(tkIntXlibStubsPtr->xSetFillStyle) /* 96 */
#endif
#ifndef XSetFunction
#define XSetFunction \
	(tkIntXlibStubsPtr->xSetFunction) /* 97 */
#endif
#ifndef XSetLineAttributes
#define XSetLineAttributes \
	(tkIntXlibStubsPtr->xSetLineAttributes) /* 98 */
#endif
#ifndef _XInitImageFuncPtrs
#define _XInitImageFuncPtrs \
	(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 99 */
#endif
#ifndef XCreateIC
#define XCreateIC \
	(tkIntXlibStubsPtr->xCreateIC) /* 100 */
#endif
#ifndef XGetVisualInfo
#define XGetVisualInfo \
	(tkIntXlibStubsPtr->xGetVisualInfo) /* 101 */
#endif
#ifndef XSetWMClientMachine
#define XSetWMClientMachine \
	(tkIntXlibStubsPtr->xSetWMClientMachine) /* 102 */
#endif
#ifndef XStringListToTextProperty
#define XStringListToTextProperty \
	(tkIntXlibStubsPtr->xStringListToTextProperty) /* 103 */
#endif
#ifndef XDrawLine
#define XDrawLine \
	(tkIntXlibStubsPtr->xDrawLine) /* 104 */
#endif
#ifndef XWarpPointer
#define XWarpPointer \
	(tkIntXlibStubsPtr->xWarpPointer) /* 105 */
#endif
#ifndef XFillRectangle
#define XFillRectangle \
	(tkIntXlibStubsPtr->xFillRectangle) /* 106 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef XSetDashes
#define XSetDashes \
	(tkIntXlibStubsPtr->xSetDashes) /* 0 */
#endif
#ifndef XGetModifierMapping
#define XGetModifierMapping \
	(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */
#endif
#ifndef XCreateImage
#define XCreateImage \
	(tkIntXlibStubsPtr->xCreateImage) /* 2 */
#endif
#ifndef XGetImage
#define XGetImage \
	(tkIntXlibStubsPtr->xGetImage) /* 3 */
#endif
#ifndef XGetAtomName
#define XGetAtomName \
	(tkIntXlibStubsPtr->xGetAtomName) /* 4 */
#endif
#ifndef XKeysymToString
#define XKeysymToString \
	(tkIntXlibStubsPtr->xKeysymToString) /* 5 */
#endif
#ifndef XCreateColormap
#define XCreateColormap \
	(tkIntXlibStubsPtr->xCreateColormap) /* 6 */
#endif
#ifndef XGContextFromGC
#define XGContextFromGC \
	(tkIntXlibStubsPtr->xGContextFromGC) /* 7 */
#endif
#ifndef XKeycodeToKeysym
#define XKeycodeToKeysym \
	(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 8 */
#endif
#ifndef XStringToKeysym
#define XStringToKeysym \
	(tkIntXlibStubsPtr->xStringToKeysym) /* 9 */
#endif
#ifndef XRootWindow
#define XRootWindow \
	(tkIntXlibStubsPtr->xRootWindow) /* 10 */
#endif
#ifndef XSetErrorHandler
#define XSetErrorHandler \
	(tkIntXlibStubsPtr->xSetErrorHandler) /* 11 */
#endif
#ifndef XAllocColor
#define XAllocColor \
	(tkIntXlibStubsPtr->xAllocColor) /* 12 */
#endif
#ifndef XBell
#define XBell \
	(tkIntXlibStubsPtr->xBell) /* 13 */
#endif
#ifndef XChangeProperty
#define XChangeProperty \
	(tkIntXlibStubsPtr->xChangeProperty) /* 14 */
#endif
#ifndef XChangeWindowAttributes
#define XChangeWindowAttributes \
	(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 15 */
#endif
#ifndef XConfigureWindow
#define XConfigureWindow \
	(tkIntXlibStubsPtr->xConfigureWindow) /* 16 */
#endif
#ifndef XCopyArea
#define XCopyArea \
	(tkIntXlibStubsPtr->xCopyArea) /* 17 */
#endif
#ifndef XCopyPlane
#define XCopyPlane \
	(tkIntXlibStubsPtr->xCopyPlane) /* 18 */
#endif
#ifndef XCreateBitmapFromData
#define XCreateBitmapFromData \
	(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 19 */
#endif
#ifndef XDefineCursor
#define XDefineCursor \
	(tkIntXlibStubsPtr->xDefineCursor) /* 20 */
#endif
#ifndef XDestroyWindow
#define XDestroyWindow \
	(tkIntXlibStubsPtr->xDestroyWindow) /* 21 */
#endif
#ifndef XDrawArc
#define XDrawArc \
	(tkIntXlibStubsPtr->xDrawArc) /* 22 */
#endif
#ifndef XDrawLines
#define XDrawLines \
	(tkIntXlibStubsPtr->xDrawLines) /* 23 */
#endif
#ifndef XDrawRectangle
#define XDrawRectangle \
	(tkIntXlibStubsPtr->xDrawRectangle) /* 24 */
#endif
#ifndef XFillArc
#define XFillArc \
	(tkIntXlibStubsPtr->xFillArc) /* 25 */
#endif
#ifndef XFillPolygon
#define XFillPolygon \
	(tkIntXlibStubsPtr->xFillPolygon) /* 26 */
#endif
#ifndef XFillRectangles
#define XFillRectangles \
	(tkIntXlibStubsPtr->xFillRectangles) /* 27 */
#endif
#ifndef XFreeColormap
#define XFreeColormap \
	(tkIntXlibStubsPtr->xFreeColormap) /* 28 */
#endif
#ifndef XFreeColors
#define XFreeColors \
	(tkIntXlibStubsPtr->xFreeColors) /* 29 */
#endif
#ifndef XFreeModifiermap
#define XFreeModifiermap \
	(tkIntXlibStubsPtr->xFreeModifiermap) /* 30 */
#endif
#ifndef XGetGeometry
#define XGetGeometry \
	(tkIntXlibStubsPtr->xGetGeometry) /* 31 */
#endif
#ifndef XGetWindowProperty
#define XGetWindowProperty \
	(tkIntXlibStubsPtr->xGetWindowProperty) /* 32 */
#endif
#ifndef XGrabKeyboard
#define XGrabKeyboard \
	(tkIntXlibStubsPtr->xGrabKeyboard) /* 33 */
#endif
#ifndef XGrabPointer
#define XGrabPointer \
	(tkIntXlibStubsPtr->xGrabPointer) /* 34 */
#endif
#ifndef XKeysymToKeycode
#define XKeysymToKeycode \
	(tkIntXlibStubsPtr->xKeysymToKeycode) /* 35 */
#endif
#ifndef XMapWindow
#define XMapWindow \
	(tkIntXlibStubsPtr->xMapWindow) /* 36 */
#endif
#ifndef XMoveResizeWindow
#define XMoveResizeWindow \
	(tkIntXlibStubsPtr->xMoveResizeWindow) /* 37 */
#endif
#ifndef XMoveWindow
#define XMoveWindow \
	(tkIntXlibStubsPtr->xMoveWindow) /* 38 */
#endif
#ifndef XQueryPointer
#define XQueryPointer \
	(tkIntXlibStubsPtr->xQueryPointer) /* 39 */
#endif
#ifndef XRaiseWindow
#define XRaiseWindow \
	(tkIntXlibStubsPtr->xRaiseWindow) /* 40 */
#endif
#ifndef XRefreshKeyboardMapping
#define XRefreshKeyboardMapping \
	(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 41 */
#endif
#ifndef XResizeWindow
#define XResizeWindow \
	(tkIntXlibStubsPtr->xResizeWindow) /* 42 */
#endif
#ifndef XSelectInput
#define XSelectInput \
	(tkIntXlibStubsPtr->xSelectInput) /* 43 */
#endif
#ifndef XSendEvent
#define XSendEvent \
	(tkIntXlibStubsPtr->xSendEvent) /* 44 */
#endif
#ifndef XSetIconName
#define XSetIconName \
	(tkIntXlibStubsPtr->xSetIconName) /* 45 */
#endif
#ifndef XSetInputFocus
#define XSetInputFocus \
	(tkIntXlibStubsPtr->xSetInputFocus) /* 46 */
#endif
#ifndef XSetSelectionOwner
#define XSetSelectionOwner \
	(tkIntXlibStubsPtr->xSetSelectionOwner) /* 47 */
#endif
#ifndef XSetWindowBackground
#define XSetWindowBackground \
	(tkIntXlibStubsPtr->xSetWindowBackground) /* 48 */
#endif
#ifndef XSetWindowBackgroundPixmap
#define XSetWindowBackgroundPixmap \
	(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 49 */
#endif
#ifndef XSetWindowBorder
#define XSetWindowBorder \
	(tkIntXlibStubsPtr->xSetWindowBorder) /* 50 */
#endif
#ifndef XSetWindowBorderPixmap
#define XSetWindowBorderPixmap \
	(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 51 */
#endif
#ifndef XSetWindowBorderWidth
#define XSetWindowBorderWidth \
	(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 52 */
#endif
#ifndef XSetWindowColormap
#define XSetWindowColormap \
	(tkIntXlibStubsPtr->xSetWindowColormap) /* 53 */
#endif
#ifndef XUngrabKeyboard
#define XUngrabKeyboard \
	(tkIntXlibStubsPtr->xUngrabKeyboard) /* 54 */
#endif
#ifndef XUngrabPointer
#define XUngrabPointer \
	(tkIntXlibStubsPtr->xUngrabPointer) /* 55 */
#endif
#ifndef XUnmapWindow
#define XUnmapWindow \
	(tkIntXlibStubsPtr->xUnmapWindow) /* 56 */
#endif
#ifndef TkPutImage
#define TkPutImage \
	(tkIntXlibStubsPtr->tkPutImage) /* 57 */
#endif
#ifndef XParseColor
#define XParseColor \
	(tkIntXlibStubsPtr->xParseColor) /* 58 */
#endif
#ifndef XCreateGC
#define XCreateGC \
	(tkIntXlibStubsPtr->xCreateGC) /* 59 */
#endif
#ifndef XFreeGC
#define XFreeGC \
	(tkIntXlibStubsPtr->xFreeGC) /* 60 */
#endif
#ifndef XInternAtom
#define XInternAtom \
	(tkIntXlibStubsPtr->xInternAtom) /* 61 */
#endif
#ifndef XSetBackground
#define XSetBackground \
	(tkIntXlibStubsPtr->xSetBackground) /* 62 */
#endif
#ifndef XSetForeground
#define XSetForeground \
	(tkIntXlibStubsPtr->xSetForeground) /* 63 */
#endif
#ifndef XSetClipMask
#define XSetClipMask \
	(tkIntXlibStubsPtr->xSetClipMask) /* 64 */
#endif
#ifndef XSetClipOrigin
#define XSetClipOrigin \
	(tkIntXlibStubsPtr->xSetClipOrigin) /* 65 */
#endif
#ifndef XSetTSOrigin
#define XSetTSOrigin \
	(tkIntXlibStubsPtr->xSetTSOrigin) /* 66 */
#endif
#ifndef XChangeGC
#define XChangeGC \
	(tkIntXlibStubsPtr->xChangeGC) /* 67 */
#endif
#ifndef XSetFont
#define XSetFont \
	(tkIntXlibStubsPtr->xSetFont) /* 68 */
#endif
#ifndef XSetArcMode
#define XSetArcMode \
	(tkIntXlibStubsPtr->xSetArcMode) /* 69 */
#endif
#ifndef XSetStipple
#define XSetStipple \
	(tkIntXlibStubsPtr->xSetStipple) /* 70 */
#endif
#ifndef XSetFillRule
#define XSetFillRule \
	(tkIntXlibStubsPtr->xSetFillRule) /* 71 */
#endif
#ifndef XSetFillStyle
#define XSetFillStyle \
	(tkIntXlibStubsPtr->xSetFillStyle) /* 72 */
#endif
#ifndef XSetFunction
#define XSetFunction \
	(tkIntXlibStubsPtr->xSetFunction) /* 73 */
#endif
#ifndef XSetLineAttributes
#define XSetLineAttributes \
	(tkIntXlibStubsPtr->xSetLineAttributes) /* 74 */
#endif
#ifndef _XInitImageFuncPtrs
#define _XInitImageFuncPtrs \
	(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 75 */
#endif
#ifndef XCreateIC
#define XCreateIC \
	(tkIntXlibStubsPtr->xCreateIC) /* 76 */
#endif
#ifndef XGetVisualInfo
#define XGetVisualInfo \
	(tkIntXlibStubsPtr->xGetVisualInfo) /* 77 */
#endif
#ifndef XSetWMClientMachine
#define XSetWMClientMachine \
	(tkIntXlibStubsPtr->xSetWMClientMachine) /* 78 */
#endif
#ifndef XStringListToTextProperty
#define XStringListToTextProperty \
	(tkIntXlibStubsPtr->xStringListToTextProperty) /* 79 */
#endif
#ifndef XDrawSegments
#define XDrawSegments \
	(tkIntXlibStubsPtr->xDrawSegments) /* 80 */
#endif
#ifndef XForceScreenSaver
#define XForceScreenSaver \
	(tkIntXlibStubsPtr->xForceScreenSaver) /* 81 */
#endif
#ifndef XDrawLine
#define XDrawLine \
	(tkIntXlibStubsPtr->xDrawLine) /* 82 */
#endif
#ifndef XFillRectangle
#define XFillRectangle \
	(tkIntXlibStubsPtr->xFillRectangle) /* 83 */
#endif
#ifndef XClearWindow
#define XClearWindow \
	(tkIntXlibStubsPtr->xClearWindow) /* 84 */
#endif
#ifndef XDrawPoint
#define XDrawPoint \
	(tkIntXlibStubsPtr->xDrawPoint) /* 85 */
#endif
#ifndef XDrawPoints
#define XDrawPoints \
	(tkIntXlibStubsPtr->xDrawPoints) /* 86 */
#endif
#ifndef XWarpPointer
#define XWarpPointer \
	(tkIntXlibStubsPtr->xWarpPointer) /* 87 */
#endif
#ifndef XQueryColor
#define XQueryColor \
	(tkIntXlibStubsPtr->xQueryColor) /* 88 */
#endif
#ifndef XQueryColors
#define XQueryColors \
	(tkIntXlibStubsPtr->xQueryColors) /* 89 */
#endif
#ifndef XQueryTree
#define XQueryTree \
	(tkIntXlibStubsPtr->xQueryTree) /* 90 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef XSetDashes
#define XSetDashes \
	(tkIntXlibStubsPtr->xSetDashes) /* 0 */
#endif
#ifndef XGetModifierMapping
#define XGetModifierMapping \
	(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */
#endif
#ifndef XCreateImage
#define XCreateImage \
	(tkIntXlibStubsPtr->xCreateImage) /* 2 */
#endif
#ifndef XGetImage
#define XGetImage \
	(tkIntXlibStubsPtr->xGetImage) /* 3 */
#endif
#ifndef XGetAtomName
#define XGetAtomName \
	(tkIntXlibStubsPtr->xGetAtomName) /* 4 */
#endif
#ifndef XKeysymToString
#define XKeysymToString \
	(tkIntXlibStubsPtr->xKeysymToString) /* 5 */
#endif
#ifndef XCreateColormap
#define XCreateColormap \
	(tkIntXlibStubsPtr->xCreateColormap) /* 6 */
#endif
#ifndef XGContextFromGC
#define XGContextFromGC \
	(tkIntXlibStubsPtr->xGContextFromGC) /* 7 */
#endif
#ifndef XKeycodeToKeysym
#define XKeycodeToKeysym \
	(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 8 */
#endif
#ifndef XStringToKeysym
#define XStringToKeysym \
	(tkIntXlibStubsPtr->xStringToKeysym) /* 9 */
#endif
#ifndef XRootWindow
#define XRootWindow \
	(tkIntXlibStubsPtr->xRootWindow) /* 10 */
#endif
#ifndef XSetErrorHandler
#define XSetErrorHandler \
	(tkIntXlibStubsPtr->xSetErrorHandler) /* 11 */
#endif
#ifndef XAllocColor
#define XAllocColor \
	(tkIntXlibStubsPtr->xAllocColor) /* 12 */
#endif
#ifndef XBell
#define XBell \
	(tkIntXlibStubsPtr->xBell) /* 13 */
#endif
#ifndef XChangeProperty
#define XChangeProperty \
	(tkIntXlibStubsPtr->xChangeProperty) /* 14 */
#endif
#ifndef XChangeWindowAttributes
#define XChangeWindowAttributes \
	(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 15 */
#endif
#ifndef XConfigureWindow
#define XConfigureWindow \
	(tkIntXlibStubsPtr->xConfigureWindow) /* 16 */
#endif
#ifndef XCopyArea
#define XCopyArea \
	(tkIntXlibStubsPtr->xCopyArea) /* 17 */
#endif
#ifndef XCopyPlane
#define XCopyPlane \
	(tkIntXlibStubsPtr->xCopyPlane) /* 18 */
#endif
#ifndef XCreateBitmapFromData
#define XCreateBitmapFromData \
	(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 19 */
#endif
#ifndef XDefineCursor
#define XDefineCursor \
	(tkIntXlibStubsPtr->xDefineCursor) /* 20 */
#endif
#ifndef XDestroyWindow
#define XDestroyWindow \
	(tkIntXlibStubsPtr->xDestroyWindow) /* 21 */
#endif
#ifndef XDrawArc
#define XDrawArc \
	(tkIntXlibStubsPtr->xDrawArc) /* 22 */
#endif
#ifndef XDrawLines
#define XDrawLines \
	(tkIntXlibStubsPtr->xDrawLines) /* 23 */
#endif
#ifndef XDrawRectangle
#define XDrawRectangle \
	(tkIntXlibStubsPtr->xDrawRectangle) /* 24 */
#endif
#ifndef XFillArc
#define XFillArc \
	(tkIntXlibStubsPtr->xFillArc) /* 25 */
#endif
#ifndef XFillPolygon
#define XFillPolygon \
	(tkIntXlibStubsPtr->xFillPolygon) /* 26 */
#endif
#ifndef XFillRectangles
#define XFillRectangles \
	(tkIntXlibStubsPtr->xFillRectangles) /* 27 */
#endif
#ifndef XFreeColormap
#define XFreeColormap \
	(tkIntXlibStubsPtr->xFreeColormap) /* 28 */
#endif
#ifndef XFreeColors
#define XFreeColors \
	(tkIntXlibStubsPtr->xFreeColors) /* 29 */
#endif
#ifndef XFreeModifiermap
#define XFreeModifiermap \
	(tkIntXlibStubsPtr->xFreeModifiermap) /* 30 */
#endif
#ifndef XGetGeometry
#define XGetGeometry \
	(tkIntXlibStubsPtr->xGetGeometry) /* 31 */
#endif
#ifndef XGetWindowProperty
#define XGetWindowProperty \
	(tkIntXlibStubsPtr->xGetWindowProperty) /* 32 */
#endif
#ifndef XGrabKeyboard
#define XGrabKeyboard \
	(tkIntXlibStubsPtr->xGrabKeyboard) /* 33 */
#endif
#ifndef XGrabPointer
#define XGrabPointer \
	(tkIntXlibStubsPtr->xGrabPointer) /* 34 */
#endif
#ifndef XKeysymToKeycode
#define XKeysymToKeycode \
	(tkIntXlibStubsPtr->xKeysymToKeycode) /* 35 */
#endif
#ifndef XMapWindow
#define XMapWindow \
	(tkIntXlibStubsPtr->xMapWindow) /* 36 */
#endif
#ifndef XMoveResizeWindow
#define XMoveResizeWindow \
	(tkIntXlibStubsPtr->xMoveResizeWindow) /* 37 */
#endif
#ifndef XMoveWindow
#define XMoveWindow \
	(tkIntXlibStubsPtr->xMoveWindow) /* 38 */
#endif
#ifndef XQueryPointer
#define XQueryPointer \
	(tkIntXlibStubsPtr->xQueryPointer) /* 39 */
#endif
#ifndef XRaiseWindow
#define XRaiseWindow \
	(tkIntXlibStubsPtr->xRaiseWindow) /* 40 */
#endif
#ifndef XRefreshKeyboardMapping
#define XRefreshKeyboardMapping \
	(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 41 */
#endif
#ifndef XResizeWindow
#define XResizeWindow \
	(tkIntXlibStubsPtr->xResizeWindow) /* 42 */
#endif
#ifndef XSelectInput
#define XSelectInput \
	(tkIntXlibStubsPtr->xSelectInput) /* 43 */
#endif
#ifndef XSendEvent
#define XSendEvent \
	(tkIntXlibStubsPtr->xSendEvent) /* 44 */
#endif
#ifndef XSetIconName
#define XSetIconName \
	(tkIntXlibStubsPtr->xSetIconName) /* 45 */
#endif
#ifndef XSetInputFocus
#define XSetInputFocus \
	(tkIntXlibStubsPtr->xSetInputFocus) /* 46 */
#endif
#ifndef XSetSelectionOwner
#define XSetSelectionOwner \
	(tkIntXlibStubsPtr->xSetSelectionOwner) /* 47 */
#endif
#ifndef XSetWindowBackground
#define XSetWindowBackground \
	(tkIntXlibStubsPtr->xSetWindowBackground) /* 48 */
#endif
#ifndef XSetWindowBackgroundPixmap
#define XSetWindowBackgroundPixmap \
	(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 49 */
#endif
#ifndef XSetWindowBorder
#define XSetWindowBorder \
	(tkIntXlibStubsPtr->xSetWindowBorder) /* 50 */
#endif
#ifndef XSetWindowBorderPixmap
#define XSetWindowBorderPixmap \
	(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 51 */
#endif
#ifndef XSetWindowBorderWidth
#define XSetWindowBorderWidth \
	(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 52 */
#endif
#ifndef XSetWindowColormap
#define XSetWindowColormap \
	(tkIntXlibStubsPtr->xSetWindowColormap) /* 53 */
#endif
#ifndef XUngrabKeyboard
#define XUngrabKeyboard \
	(tkIntXlibStubsPtr->xUngrabKeyboard) /* 54 */
#endif
#ifndef XUngrabPointer
#define XUngrabPointer \
	(tkIntXlibStubsPtr->xUngrabPointer) /* 55 */
#endif
#ifndef XUnmapWindow
#define XUnmapWindow \
	(tkIntXlibStubsPtr->xUnmapWindow) /* 56 */
#endif
#ifndef TkPutImage
#define TkPutImage \
	(tkIntXlibStubsPtr->tkPutImage) /* 57 */
#endif
#ifndef XParseColor
#define XParseColor \
	(tkIntXlibStubsPtr->xParseColor) /* 58 */
#endif
#ifndef XCreateGC
#define XCreateGC \
	(tkIntXlibStubsPtr->xCreateGC) /* 59 */
#endif
#ifndef XFreeGC
#define XFreeGC \
	(tkIntXlibStubsPtr->xFreeGC) /* 60 */
#endif
#ifndef XInternAtom
#define XInternAtom \
	(tkIntXlibStubsPtr->xInternAtom) /* 61 */
#endif
#ifndef XSetBackground
#define XSetBackground \
	(tkIntXlibStubsPtr->xSetBackground) /* 62 */
#endif
#ifndef XSetForeground
#define XSetForeground \
	(tkIntXlibStubsPtr->xSetForeground) /* 63 */
#endif
#ifndef XSetClipMask
#define XSetClipMask \
	(tkIntXlibStubsPtr->xSetClipMask) /* 64 */
#endif
#ifndef XSetClipOrigin
#define XSetClipOrigin \
	(tkIntXlibStubsPtr->xSetClipOrigin) /* 65 */
#endif
#ifndef XSetTSOrigin
#define XSetTSOrigin \
	(tkIntXlibStubsPtr->xSetTSOrigin) /* 66 */
#endif
#ifndef XChangeGC
#define XChangeGC \
	(tkIntXlibStubsPtr->xChangeGC) /* 67 */
#endif
#ifndef XSetFont
#define XSetFont \
	(tkIntXlibStubsPtr->xSetFont) /* 68 */
#endif
#ifndef XSetArcMode
#define XSetArcMode \
	(tkIntXlibStubsPtr->xSetArcMode) /* 69 */
#endif
#ifndef XSetStipple
#define XSetStipple \
	(tkIntXlibStubsPtr->xSetStipple) /* 70 */
#endif
#ifndef XSetFillRule
#define XSetFillRule \
	(tkIntXlibStubsPtr->xSetFillRule) /* 71 */
#endif
#ifndef XSetFillStyle
#define XSetFillStyle \
	(tkIntXlibStubsPtr->xSetFillStyle) /* 72 */
#endif
#ifndef XSetFunction
#define XSetFunction \
	(tkIntXlibStubsPtr->xSetFunction) /* 73 */
#endif
#ifndef XSetLineAttributes
#define XSetLineAttributes \
	(tkIntXlibStubsPtr->xSetLineAttributes) /* 74 */
#endif
#ifndef _XInitImageFuncPtrs
#define _XInitImageFuncPtrs \
	(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 75 */
#endif
#ifndef XCreateIC
#define XCreateIC \
	(tkIntXlibStubsPtr->xCreateIC) /* 76 */
#endif
#ifndef XGetVisualInfo
#define XGetVisualInfo \
	(tkIntXlibStubsPtr->xGetVisualInfo) /* 77 */
#endif
#ifndef XSetWMClientMachine
#define XSetWMClientMachine \
	(tkIntXlibStubsPtr->xSetWMClientMachine) /* 78 */
#endif
#ifndef XStringListToTextProperty
#define XStringListToTextProperty \
	(tkIntXlibStubsPtr->xStringListToTextProperty) /* 79 */
#endif
#ifndef XDrawSegments
#define XDrawSegments \
	(tkIntXlibStubsPtr->xDrawSegments) /* 80 */
#endif
#ifndef XForceScreenSaver
#define XForceScreenSaver \
	(tkIntXlibStubsPtr->xForceScreenSaver) /* 81 */
#endif
#ifndef XDrawLine
#define XDrawLine \
	(tkIntXlibStubsPtr->xDrawLine) /* 82 */
#endif
#ifndef XFillRectangle
#define XFillRectangle \
	(tkIntXlibStubsPtr->xFillRectangle) /* 83 */
#endif
#ifndef XClearWindow
#define XClearWindow \
	(tkIntXlibStubsPtr->xClearWindow) /* 84 */
#endif
#ifndef XDrawPoint
#define XDrawPoint \
	(tkIntXlibStubsPtr->xDrawPoint) /* 85 */
#endif
#ifndef XDrawPoints
#define XDrawPoints \
	(tkIntXlibStubsPtr->xDrawPoints) /* 86 */
#endif
#ifndef XWarpPointer
#define XWarpPointer \
	(tkIntXlibStubsPtr->xWarpPointer) /* 87 */
#endif
#ifndef XQueryColor
#define XQueryColor \
	(tkIntXlibStubsPtr->xQueryColor) /* 88 */
#endif
#ifndef XQueryColors
#define XQueryColors \
	(tkIntXlibStubsPtr->xQueryColors) /* 89 */
#endif
#ifndef XQueryTree
#define XQueryTree \
	(tkIntXlibStubsPtr->xQueryTree) /* 90 */
#endif
#ifndef XSync
#define XSync \
	(tkIntXlibStubsPtr->xSync) /* 91 */
#endif
#endif /* MAC_OSX_TK */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTXLIBDECLS */
                                                                                                                                                                                                                                                                                                                                                                                                                                               tkMacOSX.h                                                                                          0100644 0001750 0001750 00000002151 10615001147 032117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers                                                                        /*
 * tkMacOSX.h --
 *
 *	Declarations of Macintosh specific exported variables and procedures.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkMacOSX.h,v 1.2.2.3 2007/04/29 02:26:47 das Exp $
 */

#ifndef _TKMAC
#define _TKMAC

#ifndef _TK
#include "tk.h"
#endif

#include <Carbon/Carbon.h>

/*
 * Structures and function types for handling Netscape-type in process
 * embedding where Tk does not control the top-level
 */

typedef int (Tk_MacOSXEmbedRegisterWinProc) (int winID, Tk_Window window);
typedef GWorldPtr (Tk_MacOSXEmbedGetGrafPortProc) (Tk_Window window);
typedef int (Tk_MacOSXEmbedMakeContainerExistProc) (Tk_Window window);
typedef void (Tk_MacOSXEmbedGetClipProc) (Tk_Window window, RgnHandle rgn);
typedef void (Tk_MacOSXEmbedGetOffsetInParentProc) (Tk_Window window, Point *ulCorner);

#include "tkPlatDecls.h"

#endif /* _TKMAC */
                                                                                                                                                                                                                                                                                                                                                                                                                       tkPlatDecls.h                                                                                       0100644 0001750 0001750 00000023732 11001664476 032722  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers                                                                        /*
 * tkPlatDecls.h --
 *
 *	Declarations of functions in the platform-specific public Tcl API.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: tkPlatDecls.h,v 1.7.2.1 2006/02/09 19:09:43 das Exp $
 */

#ifndef _TKPLATDECLS
#define _TKPLATDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tk.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__
/* 0 */
EXTERN Window		Tk_AttachHWND _ANSI_ARGS_((Tk_Window tkwin, 
				HWND hwnd));
/* 1 */
EXTERN HINSTANCE	Tk_GetHINSTANCE _ANSI_ARGS_((void));
/* 2 */
EXTERN HWND		Tk_GetHWND _ANSI_ARGS_((Window window));
/* 3 */
EXTERN Tk_Window	Tk_HWNDToWindow _ANSI_ARGS_((HWND hwnd));
/* 4 */
EXTERN void		Tk_PointerEvent _ANSI_ARGS_((HWND hwnd, int x, int y));
/* 5 */
EXTERN int		Tk_TranslateWinEvent _ANSI_ARGS_((HWND hwnd, 
				UINT message, WPARAM wParam, LPARAM lParam, 
				LRESULT * result));
#endif /* __WIN32__ */
#ifdef MAC_TCL
/* 0 */
EXTERN void		Tk_MacSetEmbedHandler _ANSI_ARGS_((
				Tk_MacEmbedRegisterWinProc * registerWinProcPtr, 
				Tk_MacEmbedGetGrafPortProc * getPortProcPtr, 
				Tk_MacEmbedMakeContainerExistProc * containerExistProcPtr, 
				Tk_MacEmbedGetClipProc * getClipProc, 
				Tk_MacEmbedGetOffsetInParentProc * getOffsetProc));
/* 1 */
EXTERN void		Tk_MacTurnOffMenus _ANSI_ARGS_((void));
/* 2 */
EXTERN void		Tk_MacTkOwnsCursor _ANSI_ARGS_((int tkOwnsIt));
/* 3 */
EXTERN void		TkMacInitMenus _ANSI_ARGS_((Tcl_Interp * interp));
/* 4 */
EXTERN void		TkMacInitAppleEvents _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 5 */
EXTERN int		TkMacConvertEvent _ANSI_ARGS_((
				EventRecord * eventPtr));
/* 6 */
EXTERN int		TkMacConvertTkEvent _ANSI_ARGS_((
				EventRecord * eventPtr, Window window));
/* 7 */
EXTERN void		TkGenWMConfigureEvent _ANSI_ARGS_((Tk_Window tkwin, 
				int x, int y, int width, int height, 
				int flags));
/* 8 */
EXTERN void		TkMacInvalClipRgns _ANSI_ARGS_((TkWindow * winPtr));
/* 9 */
EXTERN int		TkMacHaveAppearance _ANSI_ARGS_((void));
/* 10 */
EXTERN GWorldPtr	TkMacGetDrawablePort _ANSI_ARGS_((Drawable drawable));
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
/* 0 */
EXTERN void		Tk_MacOSXSetEmbedHandler _ANSI_ARGS_((
				Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, 
				Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, 
				Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, 
				Tk_MacOSXEmbedGetClipProc * getClipProc, 
				Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc));
/* 1 */
EXTERN void		Tk_MacOSXTurnOffMenus _ANSI_ARGS_((void));
/* 2 */
EXTERN void		Tk_MacOSXTkOwnsCursor _ANSI_ARGS_((int tkOwnsIt));
/* 3 */
EXTERN void		TkMacOSXInitMenus _ANSI_ARGS_((Tcl_Interp * interp));
/* 4 */
EXTERN void		TkMacOSXInitAppleEvents _ANSI_ARGS_((
				Tcl_Interp * interp));
/* 5 */
EXTERN void		TkGenWMConfigureEvent _ANSI_ARGS_((Tk_Window tkwin, 
				int x, int y, int width, int height, 
				int flags));
/* 6 */
EXTERN void		TkMacOSXInvalClipRgns _ANSI_ARGS_((Tk_Window tkwin));
/* 7 */
EXTERN GWorldPtr	TkMacOSXGetDrawablePort _ANSI_ARGS_((
				Drawable drawable));
/* 8 */
EXTERN ControlRef	TkMacOSXGetRootControl _ANSI_ARGS_((
				Drawable drawable));
/* 9 */
EXTERN void		Tk_MacOSXSetupTkNotifier _ANSI_ARGS_((void));
/* 10 */
EXTERN int		Tk_MacOSXIsAppInFront _ANSI_ARGS_((void));
#endif /* MAC_OSX_TK */

typedef struct TkPlatStubs {
    int magic;
    struct TkPlatStubHooks *hooks;

#ifdef __WIN32__
    Window (*tk_AttachHWND) _ANSI_ARGS_((Tk_Window tkwin, HWND hwnd)); /* 0 */
    HINSTANCE (*tk_GetHINSTANCE) _ANSI_ARGS_((void)); /* 1 */
    HWND (*tk_GetHWND) _ANSI_ARGS_((Window window)); /* 2 */
    Tk_Window (*tk_HWNDToWindow) _ANSI_ARGS_((HWND hwnd)); /* 3 */
    void (*tk_PointerEvent) _ANSI_ARGS_((HWND hwnd, int x, int y)); /* 4 */
    int (*tk_TranslateWinEvent) _ANSI_ARGS_((HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * result)); /* 5 */
#endif /* __WIN32__ */
#ifdef MAC_TCL
    void (*tk_MacSetEmbedHandler) _ANSI_ARGS_((Tk_MacEmbedRegisterWinProc * registerWinProcPtr, Tk_MacEmbedGetGrafPortProc * getPortProcPtr, Tk_MacEmbedMakeContainerExistProc * containerExistProcPtr, Tk_MacEmbedGetClipProc * getClipProc, Tk_MacEmbedGetOffsetInParentProc * getOffsetProc)); /* 0 */
    void (*tk_MacTurnOffMenus) _ANSI_ARGS_((void)); /* 1 */
    void (*tk_MacTkOwnsCursor) _ANSI_ARGS_((int tkOwnsIt)); /* 2 */
    void (*tkMacInitMenus) _ANSI_ARGS_((Tcl_Interp * interp)); /* 3 */
    void (*tkMacInitAppleEvents) _ANSI_ARGS_((Tcl_Interp * interp)); /* 4 */
    int (*tkMacConvertEvent) _ANSI_ARGS_((EventRecord * eventPtr)); /* 5 */
    int (*tkMacConvertTkEvent) _ANSI_ARGS_((EventRecord * eventPtr, Window window)); /* 6 */
    void (*tkGenWMConfigureEvent) _ANSI_ARGS_((Tk_Window tkwin, int x, int y, int width, int height, int flags)); /* 7 */
    void (*tkMacInvalClipRgns) _ANSI_ARGS_((TkWindow * winPtr)); /* 8 */
    int (*tkMacHaveAppearance) _ANSI_ARGS_((void)); /* 9 */
    GWorldPtr (*tkMacGetDrawablePort) _ANSI_ARGS_((Drawable drawable)); /* 10 */
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
    void (*tk_MacOSXSetEmbedHandler) _ANSI_ARGS_((Tk_MacOSXEmbedRegisterWinProc * registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc * getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc * containerExistProcPtr, Tk_MacOSXEmbedGetClipProc * getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc * getOffsetProc)); /* 0 */
    void (*tk_MacOSXTurnOffMenus) _ANSI_ARGS_((void)); /* 1 */
    void (*tk_MacOSXTkOwnsCursor) _ANSI_ARGS_((int tkOwnsIt)); /* 2 */
    void (*tkMacOSXInitMenus) _ANSI_ARGS_((Tcl_Interp * interp)); /* 3 */
    void (*tkMacOSXInitAppleEvents) _ANSI_ARGS_((Tcl_Interp * interp)); /* 4 */
    void (*tkGenWMConfigureEvent) _ANSI_ARGS_((Tk_Window tkwin, int x, int y, int width, int height, int flags)); /* 5 */
    void (*tkMacOSXInvalClipRgns) _ANSI_ARGS_((Tk_Window tkwin)); /* 6 */
    GWorldPtr (*tkMacOSXGetDrawablePort) _ANSI_ARGS_((Drawable drawable)); /* 7 */
    ControlRef (*tkMacOSXGetRootControl) _ANSI_ARGS_((Drawable drawable)); /* 8 */
    void (*tk_MacOSXSetupTkNotifier) _ANSI_ARGS_((void)); /* 9 */
    int (*tk_MacOSXIsAppInFront) _ANSI_ARGS_((void)); /* 10 */
#endif /* MAC_OSX_TK */
} TkPlatStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkPlatStubs *tkPlatStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__
#ifndef Tk_AttachHWND
#define Tk_AttachHWND \
	(tkPlatStubsPtr->tk_AttachHWND) /* 0 */
#endif
#ifndef Tk_GetHINSTANCE
#define Tk_GetHINSTANCE \
	(tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */
#endif
#ifndef Tk_GetHWND
#define Tk_GetHWND \
	(tkPlatStubsPtr->tk_GetHWND) /* 2 */
#endif
#ifndef Tk_HWNDToWindow
#define Tk_HWNDToWindow \
	(tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */
#endif
#ifndef Tk_PointerEvent
#define Tk_PointerEvent \
	(tkPlatStubsPtr->tk_PointerEvent) /* 4 */
#endif
#ifndef Tk_TranslateWinEvent
#define Tk_TranslateWinEvent \
	(tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */
#endif
#endif /* __WIN32__ */
#ifdef MAC_TCL
#ifndef Tk_MacSetEmbedHandler
#define Tk_MacSetEmbedHandler \
	(tkPlatStubsPtr->tk_MacSetEmbedHandler) /* 0 */
#endif
#ifndef Tk_MacTurnOffMenus
#define Tk_MacTurnOffMenus \
	(tkPlatStubsPtr->tk_MacTurnOffMenus) /* 1 */
#endif
#ifndef Tk_MacTkOwnsCursor
#define Tk_MacTkOwnsCursor \
	(tkPlatStubsPtr->tk_MacTkOwnsCursor) /* 2 */
#endif
#ifndef TkMacInitMenus
#define TkMacInitMenus \
	(tkPlatStubsPtr->tkMacInitMenus) /* 3 */
#endif
#ifndef TkMacInitAppleEvents
#define TkMacInitAppleEvents \
	(tkPlatStubsPtr->tkMacInitAppleEvents) /* 4 */
#endif
#ifndef TkMacConvertEvent
#define TkMacConvertEvent \
	(tkPlatStubsPtr->tkMacConvertEvent) /* 5 */
#endif
#ifndef TkMacConvertTkEvent
#define TkMacConvertTkEvent \
	(tkPlatStubsPtr->tkMacConvertTkEvent) /* 6 */
#endif
#ifndef TkGenWMConfigureEvent
#define TkGenWMConfigureEvent \
	(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 7 */
#endif
#ifndef TkMacInvalClipRgns
#define TkMacInvalClipRgns \
	(tkPlatStubsPtr->tkMacInvalClipRgns) /* 8 */
#endif
#ifndef TkMacHaveAppearance
#define TkMacHaveAppearance \
	(tkPlatStubsPtr->tkMacHaveAppearance) /* 9 */
#endif
#ifndef TkMacGetDrawablePort
#define TkMacGetDrawablePort \
	(tkPlatStubsPtr->tkMacGetDrawablePort) /* 10 */
#endif
#endif /* MAC_TCL */
#ifdef MAC_OSX_TK
#ifndef Tk_MacOSXSetEmbedHandler
#define Tk_MacOSXSetEmbedHandler \
	(tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */
#endif
#ifndef Tk_MacOSXTurnOffMenus
#define Tk_MacOSXTurnOffMenus \
	(tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */
#endif
#ifndef Tk_MacOSXTkOwnsCursor
#define Tk_MacOSXTkOwnsCursor \
	(tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */
#endif
#ifndef TkMacOSXInitMenus
#define TkMacOSXInitMenus \
	(tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */
#endif
#ifndef TkMacOSXInitAppleEvents
#define TkMacOSXInitAppleEvents \
	(tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */
#endif
#ifndef TkGenWMConfigureEvent
#define TkGenWMConfigureEvent \
	(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */
#endif
#ifndef TkMacOSXInvalClipRgns
#define TkMacOSXInvalClipRgns \
	(tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */
#endif
#ifndef TkMacOSXGetDrawablePort
#define TkMacOSXGetDrawablePort \
	(tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */
#endif
#ifndef TkMacOSXGetRootControl
#define TkMacOSXGetRootControl \
	(tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */
#endif
#ifndef Tk_MacOSXSetupTkNotifier
#define Tk_MacOSXSetupTkNotifier \
	(tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */
#endif
#ifndef Tk_MacOSXIsAppInFront
#define Tk_MacOSXIsAppInFront \
	(tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */
#endif
#endif /* MAC_OSX_TK */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKPLATDECLS */
                                      osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/Tk.tbd      0100644 0001750 0001750 00000063274 12571375071 030124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ---
archs:           [ i386 ]
platform:        macosx
install-name:    /System/Library/Frameworks/Tk.framework/Versions/8.4/Tk
current-version: 8.4.19
compatibility-version: 8.4
exports:         
  - archs:           [ i386 ]
    symbols:         [ _TkAboutDlg, _TkActivateMenuEntry, _TkAllocWindow, 
                       _TkBTreeBytesInLine, _TkBTreeCharTagged, _TkBTreeCharsInLine, 
                       _TkBTreeCheck, _TkBTreeCreate, _TkBTreeDeleteChars, 
                       _TkBTreeDestroy, _TkBTreeFindLine, _TkBTreeGetTags, 
                       _TkBTreeInsertChars, _TkBTreeLineIndex, _TkBTreeLinkSegment, 
                       _TkBTreeNextLine, _TkBTreeNextTag, _TkBTreeNumLines, 
                       _TkBTreePrevTag, _TkBTreePreviousLine, _TkBTreeStartSearch, 
                       _TkBTreeStartSearchBack, _TkBTreeTag, _TkBTreeUnlinkSegment, 
                       _TkBezierPoints, _TkBezierScreenPoints, _TkBindDeadWindow, 
                       _TkBindEventProc, _TkBindFree, _TkBindInit, _TkButtonWorldChanged, 
                       _TkCanvPostscriptCmd, _TkCanvTranslatePath, _TkCanvasDashParseProc, 
                       _TkCanvasDashPrintProc, _TkChangeEventWindow, _TkClipBox, 
                       _TkClipCleanup, _TkClipInit, _TkComputeAnchor, _TkCopyAndGlobalEval, 
                       _TkCreateBindingProcedure, _TkCreateCursorFromData, 
                       _TkCreateExitHandler, _TkCreateFrame, _TkCreateMainWindow, 
                       _TkCreateMenuCmd, _TkCreateMenuReferences, _TkCreateRegion, 
                       _TkCurrentTime, _TkDeadAppCmd, _TkDebugBitmap, _TkDebugBorder, 
                       _TkDebugColor, _TkDebugConfig, _TkDebugCursor, _TkDebugFont, 
                       _TkDeleteAllImages, _TkDeleteExitHandler, _TkDestroyMenu, 
                       _TkDestroyRegion, _TkDoConfigureNotify, _TkDrawInsetFocusHighlight, 
                       _TkEventDeadWindow, _TkEventInit, _TkEventuallyRecomputeMenu, 
                       _TkEventuallyRedrawMenu, _TkEventuallyRedrawScale, 
                       _TkFillPolygon, _TkFinalize, _TkFindMenuReferences, 
                       _TkFindMenuReferencesObj, _TkFindStateNum, _TkFindStateNumObj, 
                       _TkFindStateString, _TkFocusDeadWindow, _TkFocusFilterEvent, 
                       _TkFocusFree, _TkFocusKeyEvent, _TkFontGetAliasList, 
                       _TkFontGetFallbacks, _TkFontGetFirstTextLayout, 
                       _TkFontGetGlobalClass, _TkFontGetPixels, _TkFontGetPoints, 
                       _TkFontGetSymbolClass, _TkFontParseXLFD, _TkFontPkgFree, 
                       _TkFontPkgInit, _TkFreeBindingTags, _TkFreeFileFilters, 
                       _TkFreeMenuReferences, _TkGCCleanup, _TkGenWMConfigureEvent, 
                       _TkGenWMDestroyEvent, _TkGenerateActivateEvents, 
                       _TkGenerateButtonEvent, _TkGenerateButtonEventForXPointer, 
                       _TkGetBitmapData, _TkGetBitmapPredefTable, _TkGetButtPoints, 
                       _TkGetCursorByName, _TkGetDefaultScreenName, _TkGetDisplay, 
                       _TkGetDisplayList, _TkGetDisplayOf, _TkGetDoublePixels, 
                       _TkGetFileFilters, _TkGetFocusWin, _TkGetInterpNames, 
                       _TkGetMainInfoList, _TkGetMenuHashTable, _TkGetMenuIndex, 
                       _TkGetMiterPoints, _TkGetOptionSpec, _TkGetPointerCoords, 
                       _TkGetServerInfo, _TkGetTransientMaster, _TkGetWindowFromObj, 
                       _TkGrabDeadWindow, _TkGrabState, _TkInOutEvents, 
                       _TkIncludePoint, _TkInitFileFilters, _TkInstallFrameMenu, 
                       _TkIntersectRegion, _TkInvokeButton, _TkInvokeMenu, 
                       _TkKeysymToString, _TkLineToArea, _TkLineToPoint, 
                       _TkMacOSHIShapeDifferenceWithRect, _TkMacOSHIShapeUnion, 
                       _TkMacOSHIShapeUnionWithRect, _TkMacOSXBringWindowForward, 
                       _TkMacOSXButtonKeyState, _TkMacOSXCarbonEncoding, 
                       _TkMacOSXClearActiveMenu, _TkMacOSXClearMenubarActive, 
                       _TkMacOSXContainerId, _TkMacOSXDefaultStartupScript, 
                       _TkMacOSXDispatchMenuEvent, _TkMacOSXDisplayChanged, 
                       _TkMacOSXDoHLEvent, _TkMacOSXDrawableWindow, _TkMacOSXEnterExitFullscreen, 
                       _TkMacOSXFlushWindows, _TkMacOSXFreeMenuID, _TkMacOSXGenerateFocusEvent, 
                       _TkMacOSXGenerateMenuSelectEvent, _TkMacOSXGenerateParentMenuSelectEvent, 
                       _TkMacOSXGetCapture, _TkMacOSXGetClipRgn, _TkMacOSXGetDrawablePort, 
                       _TkMacOSXGetHostToplevel, _TkMacOSXGetNamedSymbol, 
                       _TkMacOSXGetNativeRegion, _TkMacOSXGetNewMenuID, 
                       _TkMacOSXGetRootControl, _TkMacOSXGetXWindow, _TkMacOSXGrowToplevel, 
                       _TkMacOSXHIShapeCreateEmpty, _TkMacOSXHIShapeCreateMutableWithRect, 
                       _TkMacOSXHIShapeSetWithShape, _TkMacOSXHandleMenuSelect, 
                       _TkMacOSXHandleTearoffMenu, _TkMacOSXInitAppleEvents, 
                       _TkMacOSXInitCGDrawing, _TkMacOSXInitCarbonEvents, 
                       _TkMacOSXInitControlFontStyle, _TkMacOSXInitKeyboard, 
                       _TkMacOSXInitMenus, _TkMacOSXInitScrollbarMetrics, 
                       _TkMacOSXInstallCursor, _TkMacOSXInstallWindowCarbonEventHandler, 
                       _TkMacOSXInvalClipRgns, _TkMacOSXInvalidateWindow, 
                       _TkMacOSXIsCharacterMissing, _TkMacOSXIsWindowZoomed, 
                       _TkMacOSXKeycodeToUnicode, _TkMacOSXMakeFullscreen, 
                       _TkMacOSXMakeRealWindowExist, _TkMacOSXMakeStippleMap, 
                       _TkMacOSXMenuClick, _TkMacOSXModifierState, _TkMacOSXOffsetRegion, 
                       _TkMacOSXPreprocessMenu, _TkMacOSXProcessAppearanceEvent, 
                       _TkMacOSXProcessApplicationEvent, _TkMacOSXProcessCommandEvent, 
                       _TkMacOSXProcessEvent, _TkMacOSXProcessKeyboardEvent, 
                       _TkMacOSXProcessMenuEvent, _TkMacOSXProcessMouseEvent, 
                       _TkMacOSXProcessWindowEvent, _TkMacOSXReceiveAndDispatchEvent, 
                       _TkMacOSXRegisterOffScreenWindow, _TkMacOSXResizable, 
                       _TkMacOSXRestoreDrawingContext, _TkMacOSXRunTclEventLoop, 
                       _TkMacOSXSetColorInContext, _TkMacOSXSetColorInPort, 
                       _TkMacOSXSetHelpMenuItemCount, _TkMacOSXSetScrollbarGrow, 
                       _TkMacOSXSetUpClippingRgn, _TkMacOSXSetUpGraphicsPort, 
                       _TkMacOSXSetWithNativeRegion, _TkMacOSXSetupDrawingContext, 
                       _TkMacOSXStartTclEventLoopCarbonTimer, _TkMacOSXStopTclEventLoopCarbonTimer, 
                       _TkMacOSXTrackingLoop, _TkMacOSXUnregisterMacWindow, 
                       _TkMacOSXUpdateClipRgn, _TkMacOSXUseAntialiasedText, 
                       _TkMacOSXUseMenuID, _TkMacOSXVisableClipRgn, _TkMacOSXWinBounds, 
                       _TkMacOSXWinCGBounds, _TkMacOSXWindowClass, _TkMacOSXWindowOffset, 
                       _TkMacOSXZoomToplevel, _TkMakeBezierCurve, _TkMakeBezierPostscript, 
                       _TkMenuButtonWorldChanged, _TkMenuConfigureDrawOptions, 
                       _TkMenuConfigureEntryDrawOptions, _TkMenuEntryFreeDrawOptions, 
                       _TkMenuEventProc, _TkMenuFreeDrawOptions, _TkMenuImageProc, 
                       _TkMenuInit, _TkMenuInitializeDrawingFields, _TkMenuInitializeEntryDrawingFields, 
                       _TkMenuSelectImageProc, _TkNewMenuName, _TkOffsetParseProc, 
                       _TkOffsetPrintProc, _TkOptionClassChanged, _TkOptionDeadWindow, 
                       _TkOrientParseProc, _TkOrientPrintProc, _TkOvalToArea, 
                       _TkOvalToPoint, _TkParsePadAmount, _TkPhotoGetValidRegion, 
                       _TkPixelParseProc, _TkPixelPrintProc, _TkPointerDeadWindow, 
                       _TkPointerEvent, _TkPolygonToArea, _TkPolygonToPoint, 
                       _TkPositionInTree, _TkPostCommand, _TkPostSubmenu, 
                       _TkPostTearoffMenu, _TkPostscriptImage, _TkPreprocessMenu, 
                       _TkPrintPadAmount, _TkPutImage, _TkQueueEventForAllChildren, 
                       _TkReadBitmapFile, _TkRecomputeMenu, _TkRectInRegion, 
                       _TkRegisterObjTypes, _TkRoundToResolution, _TkScalePixelToValue, 
                       _TkScaleSetValue, _TkScaleValueToPixel, _TkScrollWindow, 
                       _TkScrollbarEventProc, _TkScrollbarEventuallyRedraw, 
                       _TkSelClearSelection, _TkSelDeadWindow, _TkSelDefaultSelection, 
                       _TkSelEventProc, _TkSelGetInProgress, _TkSelGetSelection, 
                       _TkSelInit, _TkSelPropProc, _TkSelSetInProgress, 
                       _TkSelUpdateClipboard, _TkSetFocusWin, _TkSetMacColor, 
                       _TkSetRegion, _TkSetWMName, _TkSetWindowMenuBar, 
                       _TkSmoothParseProc, _TkSmoothPrintProc, _TkStateParseProc, 
                       _TkStatePrintProc, _TkStringToKeysym, _TkStylePkgFree, 
                       _TkStylePkgInit, _TkSubtractRegion, _TkSuspendClipboard, 
                       _TkTextBindProc, _TkTextChanged, _TkTextCharBbox, 
                       _TkTextCharLayoutProc, _TkTextCreateDInfo, _TkTextCreateTag, 
                       _TkTextDLineInfo, _TkTextEventuallyRepick, _TkTextFreeDInfo, 
                       _TkTextFreeTag, _TkTextGetIndex, _TkTextGetTabs, 
                       _TkTextImageCmd, _TkTextImageIndex, _TkTextIndexBackBytes, 
                       _TkTextIndexBackChars, _TkTextIndexCmp, _TkTextIndexForwBytes, 
                       _TkTextIndexForwChars, _TkTextIndexToSeg, _TkTextInsertDisplayProc, 
                       _TkTextIsElided, _TkTextLostSelection, _TkTextMakeByteIndex, 
                       _TkTextMakeCharIndex, _TkTextMarkCmd, _TkTextMarkNameToIndex, 
                       _TkTextMarkSegToIndex, _TkTextPickCurrent, _TkTextPixelIndex, 
                       _TkTextPrintIndex, _TkTextRedrawRegion, _TkTextRedrawTag, 
                       _TkTextRelayoutWindow, _TkTextScanCmd, _TkTextSeeCmd, 
                       _TkTextSegToOffset, _TkTextSetMark, _TkTextSetYView, 
                       _TkTextTagCmd, _TkTextWindowCmd, _TkTextWindowIndex, 
                       _TkTextWrapModeOption, _TkTextXviewCmd, _TkTextYviewCmd, 
                       _TkThickPolyLineToArea, _TkToplevelWindowForCommand, 
                       _TkUndoApply, _TkUndoClearStack, _TkUndoClearStacks, 
                       _TkUndoFreeStack, _TkUndoInitStack, _TkUndoInsertSeparator, 
                       _TkUndoInsertUndoSeparator, _TkUndoPopStack, _TkUndoPushAction, 
                       _TkUndoPushStack, _TkUndoRevert, _TkUndoSetDepth, 
                       _TkUnionRectWithRegion, _TkUnsupported1ObjCmd, _TkWmAddToColormapWindows, 
                       _TkWmDeadWindow, _TkWmFocusToplevel, _TkWmMapWindow, 
                       _TkWmNewWindow, _TkWmProtocolEventProc, _TkWmRemoveFromColormapWindows, 
                       _TkWmRestackToplevel, _TkWmSetClass, _TkWmStackorderToplevel, 
                       _TkWmUnmapWindow, _Tk_3DBorderColor, _Tk_3DBorderGC, 
                       _Tk_3DHorizontalBevel, _Tk_3DVerticalBevel, _Tk_AddOption, 
                       _Tk_Alloc3DBorderFromObj, _Tk_AllocBitmapFromObj, 
                       _Tk_AllocColorFromObj, _Tk_AllocCursorFromObj, _Tk_AllocFontFromObj, 
                       _Tk_AllocStyleFromObj, _Tk_BellObjCmd, _Tk_BindEvent, 
                       _Tk_BindObjCmd, _Tk_BindtagsObjCmd, _Tk_ButtonObjCmd, 
                       _Tk_CanvasDrawableCoords, _Tk_CanvasEventuallyRedraw, 
                       _Tk_CanvasGetCoord, _Tk_CanvasGetCoordFromObj, _Tk_CanvasGetTextInfo, 
                       _Tk_CanvasObjCmd, _Tk_CanvasPsBitmap, _Tk_CanvasPsColor, 
                       _Tk_CanvasPsFont, _Tk_CanvasPsOutline, _Tk_CanvasPsPath, 
                       _Tk_CanvasPsStipple, _Tk_CanvasPsY, _Tk_CanvasSetOffset, 
                       _Tk_CanvasSetStippleOrigin, _Tk_CanvasTagsParseProc, 
                       _Tk_CanvasTagsPrintProc, _Tk_CanvasTkwin, _Tk_CanvasWindowCoords, 
                       _Tk_ChangeOutlineGC, _Tk_ChangeWindowAttributes, 
                       _Tk_CharBbox, _Tk_CheckbuttonObjCmd, _Tk_ChooseColorObjCmd, 
                       _Tk_ChooseDirectoryObjCmd, _Tk_ClearSelection, _Tk_ClipboardAppend, 
                       _Tk_ClipboardClear, _Tk_ClipboardObjCmd, _Tk_CollapseMotionEvents, 
                       _Tk_ComputeTextLayout, _Tk_ConfigOutlineGC, _Tk_ConfigureInfo, 
                       _Tk_ConfigureValue, _Tk_ConfigureWidget, _Tk_ConfigureWindow, 
                       _Tk_CoordsToWindow, _Tk_CreateAnonymousWindow, _Tk_CreateBinding, 
                       _Tk_CreateBindingTable, _Tk_CreateClientMessageHandler, 
                       _Tk_CreateConsoleWindow, _Tk_CreateErrorHandler, 
                       _Tk_CreateEventHandler, _Tk_CreateGenericHandler, 
                       _Tk_CreateImageType, _Tk_CreateItemType, _Tk_CreateOldImageType, 
                       _Tk_CreateOldPhotoImageFormat, _Tk_CreateOptionTable, 
                       _Tk_CreateOutline, _Tk_CreatePhotoImageFormat, _Tk_CreatePhotoOption, 
                       _Tk_CreateSelHandler, _Tk_CreateSmoothMethod, _Tk_CreateStyle, 
                       _Tk_CreateWindow, _Tk_CreateWindowFromPath, _Tk_DefineBitmap, 
                       _Tk_DefineCursor, _Tk_DeleteAllBindings, _Tk_DeleteBinding, 
                       _Tk_DeleteBindingTable, _Tk_DeleteClientMessageHandler, 
                       _Tk_DeleteErrorHandler, _Tk_DeleteEventHandler, 
                       _Tk_DeleteGenericHandler, _Tk_DeleteImage, _Tk_DeleteOptionTable, 
                       _Tk_DeleteOutline, _Tk_DeleteSelHandler, _Tk_DestroyObjCmd, 
                       _Tk_DestroyWindow, _Tk_DisplayName, _Tk_DistanceToTextLayout, 
                       _Tk_DitherPhoto, _Tk_Draw3DPolygon, _Tk_Draw3DRectangle, 
                       _Tk_DrawChars, _Tk_DrawElement, _Tk_DrawFocusHighlight, 
                       _Tk_DrawTextLayout, _Tk_EntryObjCmd, _Tk_EventObjCmd, 
                       _Tk_Fill3DPolygon, _Tk_Fill3DRectangle, _Tk_FindPhoto, 
                       _Tk_FocusObjCmd, _Tk_FontId, _Tk_FontObjCmd, _Tk_FrameObjCmd, 
                       _Tk_Free3DBorder, _Tk_Free3DBorderFromObj, _Tk_FreeBitmap, 
                       _Tk_FreeBitmapFromObj, _Tk_FreeColor, _Tk_FreeColorFromObj, 
                       _Tk_FreeColormap, _Tk_FreeConfigOptions, _Tk_FreeCursor, 
                       _Tk_FreeCursorFromObj, _Tk_FreeFont, _Tk_FreeFontFromObj, 
                       _Tk_FreeGC, _Tk_FreeImage, _Tk_FreeOptions, _Tk_FreePixmap, 
                       _Tk_FreeSavedOptions, _Tk_FreeStyle, _Tk_FreeStyleFromObj, 
                       _Tk_FreeTextLayout, _Tk_FreeXId, _Tk_GCForColor, 
                       _Tk_GeometryRequest, _Tk_Get3DBorder, _Tk_Get3DBorderFromObj, 
                       _Tk_GetAllBindings, _Tk_GetAnchor, _Tk_GetAnchorFromObj, 
                       _Tk_GetAtomName, _Tk_GetBinding, _Tk_GetBitmap, 
                       _Tk_GetBitmapFromData, _Tk_GetBitmapFromObj, _Tk_GetCapStyle, 
                       _Tk_GetColor, _Tk_GetColorByValue, _Tk_GetColorFromObj, 
                       _Tk_GetColormap, _Tk_GetCursor, _Tk_GetCursorFromData, 
                       _Tk_GetCursorFromObj, _Tk_GetDash, _Tk_GetElementBorderWidth, 
                       _Tk_GetElementBox, _Tk_GetElementId, _Tk_GetElementSize, 
                       _Tk_GetFont, _Tk_GetFontFromObj, _Tk_GetFontMetrics, 
                       _Tk_GetGC, _Tk_GetImage, _Tk_GetImageMasterData, 
                       _Tk_GetItemTypes, _Tk_GetJoinStyle, _Tk_GetJustify, 
                       _Tk_GetJustifyFromObj, _Tk_GetMMFromObj, _Tk_GetNumMainWindows, 
                       _Tk_GetOpenFileObjCmd, _Tk_GetOption, _Tk_GetOptionInfo, 
                       _Tk_GetOptionValue, _Tk_GetPixels, _Tk_GetPixelsFromObj, 
                       _Tk_GetPixmap, _Tk_GetRelief, _Tk_GetReliefFromObj, 
                       _Tk_GetRootCoords, _Tk_GetSaveFileObjCmd, _Tk_GetScreenMM, 
                       _Tk_GetScrollInfo, _Tk_GetScrollInfoObj, _Tk_GetSelection, 
                       _Tk_GetStyle, _Tk_GetStyleEngine, _Tk_GetStyleFromObj, 
                       _Tk_GetStyledElement, _Tk_GetUid, _Tk_GetVRootGeometry, 
                       _Tk_GetVisual, _Tk_Grab, _Tk_GrabObjCmd, _Tk_GridObjCmd, 
                       _Tk_HandleEvent, _Tk_IdToWindow, _Tk_ImageChanged, 
                       _Tk_ImageObjCmd, _Tk_Init, _Tk_InitConsoleChannels, 
                       _Tk_InitOptions, _Tk_InitStubs, _Tk_InternAtom, 
                       _Tk_IntersectTextLayout, _Tk_LabelObjCmd, _Tk_LabelframeObjCmd, 
                       _Tk_ListboxObjCmd, _Tk_LowerObjCmd, _Tk_MacOSXIsAppInFront, 
                       _Tk_MacOSXSetEmbedHandler, _Tk_MacOSXSetupTkNotifier, 
                       _Tk_MacOSXTkOwnsCursor, _Tk_MacOSXTurnOffMenus, 
                       _Tk_MainEx, _Tk_MainLoop, _Tk_MainWindow, _Tk_MaintainGeometry, 
                       _Tk_MakeWindowExist, _Tk_ManageGeometry, _Tk_MapWindow, 
                       _Tk_MeasureChars, _Tk_MenubuttonObjCmd, _Tk_MessageBoxObjCmd, 
                       _Tk_MessageObjCmd, _Tk_MoveResizeWindow, _Tk_MoveToplevelWindow, 
                       _Tk_MoveWindow, _Tk_NameOf3DBorder, _Tk_NameOfAnchor, 
                       _Tk_NameOfBitmap, _Tk_NameOfCapStyle, _Tk_NameOfColor, 
                       _Tk_NameOfCursor, _Tk_NameOfFont, _Tk_NameOfImage, 
                       _Tk_NameOfJoinStyle, _Tk_NameOfJustify, _Tk_NameOfRelief, 
                       _Tk_NameOfStyle, _Tk_NameToWindow, _Tk_OptionObjCmd, 
                       _Tk_OwnSelection, _Tk_PackObjCmd, _Tk_PanedWindowObjCmd, 
                       _Tk_ParseArgv, _Tk_PhotoBlank, _Tk_PhotoExpand, 
                       _Tk_PhotoGetImage, _Tk_PhotoGetSize, _Tk_PhotoPutBlock, 
                       _Tk_PhotoPutBlock_NoComposite, _Tk_PhotoPutZoomedBlock, 
                       _Tk_PhotoPutZoomedBlock_NoComposite, _Tk_PhotoSetSize, 
                       _Tk_PlaceObjCmd, _Tk_PointToChar, _Tk_PostscriptBitmap, 
                       _Tk_PostscriptColor, _Tk_PostscriptFont, _Tk_PostscriptFontName, 
                       _Tk_PostscriptImage, _Tk_PostscriptPath, _Tk_PostscriptPhoto, 
                       _Tk_PostscriptStipple, _Tk_PostscriptY, _Tk_PreserveColormap, 
                       _Tk_QueueWindowEvent, _Tk_RadiobuttonObjCmd, _Tk_RaiseObjCmd, 
                       _Tk_RedrawImage, _Tk_RegisterStyleEngine, _Tk_RegisterStyledElement, 
                       _Tk_ResetOutlineGC, _Tk_ResizeWindow, _Tk_RestackWindow, 
                       _Tk_RestoreSavedOptions, _Tk_RestrictEvents, _Tk_SafeInit, 
                       _Tk_ScaleObjCmd, _Tk_ScrollbarCmd, _Tk_SelectionObjCmd, 
                       _Tk_SendObjCmd, _Tk_SetAppName, _Tk_SetBackgroundFromBorder, 
                       _Tk_SetCaretPos, _Tk_SetClass, _Tk_SetClassProcs, 
                       _Tk_SetGrid, _Tk_SetInternalBorder, _Tk_SetInternalBorderEx, 
                       _Tk_SetMinimumRequestSize, _Tk_SetOptions, _Tk_SetTSOrigin, 
                       _Tk_SetWindowBackground, _Tk_SetWindowBackgroundPixmap, 
                       _Tk_SetWindowBorder, _Tk_SetWindowBorderPixmap, 
                       _Tk_SetWindowBorderWidth, _Tk_SetWindowColormap, 
                       _Tk_SetWindowVisual, _Tk_SizeOfBitmap, _Tk_SizeOfImage, 
                       _Tk_SpinboxObjCmd, _Tk_StrictMotif, _Tk_TextCmd, 
                       _Tk_TextLayoutToPostscript, _Tk_TextWidth, _Tk_TkObjCmd, 
                       _Tk_TkwaitObjCmd, _Tk_TopCoordsToWindow, _Tk_ToplevelObjCmd, 
                       _Tk_UndefineCursor, _Tk_UnderlineChars, _Tk_UnderlineTextLayout, 
                       _Tk_Ungrab, _Tk_UnmaintainGeometry, _Tk_UnmapWindow, 
                       _Tk_UnsetGrid, _Tk_UpdateObjCmd, _Tk_UpdatePointer, 
                       _Tk_WinfoObjCmd, _Tk_WmObjCmd, _TkpAlwaysShowSelection, 
                       _TkpBuildRegionFromAlphaData, _TkpChangeFocus, _TkpClaimFocus, 
                       _TkpClipDrawableToRect, _TkpCloseDisplay, _TkpComputeButtonGeometry, 
                       _TkpComputeMenuButtonGeometry, _TkpComputeMenubarGeometry, 
                       _TkpComputeScrollbarGeometry, _TkpComputeStandardMenuGeometry, 
                       _TkpConfigureMenuEntry, _TkpConfigureScrollbar, 
                       _TkpCreateButton, _TkpCreateMenuButton, _TkpCreateNativeBitmap, 
                       _TkpCreateScale, _TkpCreateScrollbar, _TkpDefineNativeBitmaps, 
                       _TkpDeleteFont, _TkpDestroyButton, _TkpDestroyMenu, 
                       _TkpDestroyMenuButton, _TkpDestroyMenuEntry, _TkpDestroyScale, 
                       _TkpDestroyScrollbar, _TkpDisplayButton, _TkpDisplayMenuButton, 
                       _TkpDisplayScale, _TkpDisplayScrollbar, _TkpDisplayWarning, 
                       _TkpDrawEntryBorderAndFocus, _TkpDrawFrame, _TkpDrawHighlightBorder, 
                       _TkpDrawMenuEntry, _TkpDrawSpinboxButtons, _TkpFontPkgInit, 
                       _TkpFreeBorder, _TkpFreeCursor, _TkpGetAppName, 
                       _TkpGetBorder, _TkpGetColor, _TkpGetColorByValue, 
                       _TkpGetFontFamilies, _TkpGetFontFromAttributes, 
                       _TkpGetKeySym, _TkpGetMS, _TkpGetNativeAppBitmap, 
                       _TkpGetNativeFont, _TkpGetOtherWindow, _TkpGetShadows, 
                       _TkpGetString, _TkpGetSubFonts, _TkpGetSystemDefault, 
                       _TkpGetWrapperWindow, _TkpInit, _TkpInitKeymapInfo, 
                       _TkpInitializeMenuBindings, _TkpIsWindowFloating, 
                       _TkpMakeContainer, _TkpMakeMenuWindow, _TkpMakeWindow, 
                       _TkpMenuInit, _TkpMenuNewEntry, _TkpMenuNotifyToplevelCreate, 
                       _TkpMenuThreadInit, _TkpNewMenu, _TkpOpenDisplay, 
                       _TkpPostMenu, _TkpRedirectKeyEvent, _TkpReleaseRegion, 
                       _TkpRetainRegion, _TkpScaleElement, _TkpScrollbarPosition, 
                       _TkpSetCapture, _TkpSetCursor, _TkpSetKeycodeAndState, 
                       _TkpSetMainMenubar, _TkpSetWindowMenuBar, _TkpTestembedCmd, 
                       _TkpUseWindow, _TkpWindowWasRecentlyDeleted, _TkpWmSetState, 
                       _TkplatformtestInit, _XAllocColor, _XBell, _XChangeGC, 
                       _XChangeProperty, _XChangeWindowAttributes, _XClearWindow, 
                       _XConfigureWindow, _XCopyArea, _XCopyPlane, _XCreateBitmapFromData, 
                       _XCreateColormap, _XCreateGC, _XCreateIC, _XCreateImage, 
                       _XDefineCursor, _XDestroyWindow, _XDrawArc, _XDrawLine, 
                       _XDrawLines, _XDrawPoint, _XDrawPoints, _XDrawRectangle, 
                       _XDrawSegments, _XFillArc, _XFillPolygon, _XFillRectangle, 
                       _XFillRectangles, _XForceScreenSaver, _XFreeColormap, 
                       _XFreeColors, _XFreeGC, _XFreeModifiermap, _XGContextFromGC, 
                       _XGetAtomName, _XGetGeometry, _XGetImage, _XGetModifierMapping, 
                       _XGetVisualInfo, _XGetWindowProperty, _XGrabKeyboard, 
                       _XGrabPointer, _XInternAtom, _XKeycodeToKeysym, 
                       _XKeysymToKeycode, _XKeysymToString, _XMapWindow, 
                       _XMoveResizeWindow, _XMoveWindow, _XParseColor, 
                       _XQueryColor, _XQueryColors, _XQueryPointer, _XQueryTree, 
                       _XRaiseWindow, _XRefreshKeyboardMapping, _XResizeWindow, 
                       _XRootWindow, _XSelectInput, _XSendEvent, _XSetArcMode, 
                       _XSetBackground, _XSetClipMask, _XSetClipOrigin, 
                       _XSetDashes, _XSetErrorHandler, _XSetFillRule, _XSetFillStyle, 
                       _XSetFont, _XSetForeground, _XSetFunction, _XSetIconName, 
                       _XSetInputFocus, _XSetLineAttributes, _XSetSelectionOwner, 
                       _XSetStipple, _XSetTSOrigin, _XSetWMClientMachine, 
                       _XSetWindowBackground, _XSetWindowBackgroundPixmap, 
                       _XSetWindowBorder, _XSetWindowBorderPixmap, _XSetWindowBorderWidth, 
                       _XSetWindowColormap, _XStringListToTextProperty, 
                       _XStringToKeysym, _XSync, _XUngrabKeyboard, _XUngrabPointer, 
                       _XUnmapWindow, _XWarpPointer, __XInitImageFuncPtrs, 
                       _tkAppleMenu, _tkArcType, _tkBTreeDebug, _tkBezierSmoothMethod, 
                       _tkBitmapImageType, _tkBitmapObjType, _tkBitmapType, 
                       _tkBorderObjType, _tkColorObjType, _tkCurrentAppleMenu, 
                       _tkCursorObjType, _tkDefButtonBorderWidth, _tkEditMenu, 
                       _tkFileMenu, _tkFontObjType, _tkImageType, _tkImgFmtGIF, 
                       _tkImgFmtPPM, _tkIntPlatStubs, _tkIntPlatStubsPtr, 
                       _tkIntStubs, _tkIntStubsPtr, _tkIntXlibStubs, _tkIntXlibStubsPtr, 
                       _tkLineType, _tkMacOSXEmbedHandler, _tkMacOSXToolboxVersionNumber, 
                       _tkMacOSXUseCGDrawing, _tkMacOSXWindowListPtr, _tkMacOSXtmpQdRgn, 
                       _tkMenuStateStrings, _tkOptionObjType, _tkOvalType, 
                       _tkPhotoImageType, _tkPictureIsOpen, _tkPlatStubs, 
                       _tkPlatStubsPtr, _tkPolygonType, _tkRectangleType, 
                       _tkStateKeyObjType, _tkStubs, _tkStubsPtr, _tkTextCharType, 
                       _tkTextDebug, _tkTextLeftMarkType, _tkTextRightMarkType, 
                       _tkTextToggleOffType, _tkTextToggleOnType, _tkTextType, 
                       _tkWindowType, _tkpButtonProcs, _tkpMenubuttonClass, 
                       _tkpScrollbarConfigSpecs, _tkpScrollbarProcs ]
...
                                                                                                                                                                                                                                                                                                                                    libtkstub8.4.a                                                                                      0100644 0001750 0001750 00000005360 12566232514 031361  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4                                                                                !<arch>
#1/20           1440298321  0     0     100644  204       `
__.SYMDEF SORTED    8   _                !     0     C     S     x   _Tk_InitStubs _tkIntPlatStubsPtr _tkIntStubsPtr _tkIntXlibStubsPtr _tkPlatStubsPtr _tkStubsPtr _Tk_InitImageArgs        #1/20           1440298228  0     0     100644  1148      `
tkStubLib.o                              H                                           __text          __TEXT                                      __cstring       __TEXT             4                            __pointers      __IMPORT                                      __common        __DATA                                                             P                                                                   $       
  
 )                                            USWV    _ME      t$D$ED$   D$$R1t]   t3Q   QR   QR   II       L$M$D$      ^_[]Tk This implementation of Tk does not support stubs                 }           q           e           Y           J           4                                 p   <   BEa                 %        4        G        W        c                 _Tk_InitStubs _tkIntPlatStubsPtr _tkIntStubsPtr _tkIntXlibStubsPtr _tkPlatStubsPtr _tkStubsPtr _tclStubsPtr radr://5614542  #1/20           1440298295  0     0     100644  1260      `
tkStubImg.o                                                    ,  P  (               __text          __TEXT                 P      x               __cstring       __TEXT             &   G                         __pointers      __IMPORT              p                        __data          __DATA          $     t                         __bss           __DATA          (                                     H     |  X      P                                              x                     $       
  
 )      H                                      USWV<    [  t  	$Q        yLE  UT$   T$$  u   $P}um        u~at]  E     $P  1E M	$X    C9u  M
      <^_[]image cannot find the "image" command          $          (          (          (                   z  $        h           O           @           3  $        )  (                     (        #     $  A     (                            _Tk_InitImageArgs _tclStubsPtr _Tk_InitImageArgs.useNewImage _Tk_InitImageArgs.argv 



                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.4/tkConfig.sh 0100644 0001750 0001750 00000007545 12566232306 031147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # tkConfig.sh --
# 
# This shell script (for sh) is generated automatically by Tk's
# configure script.  It will create shell variables for most of
# the configuration options discovered by the configure script.
# This script is intended to be included by the configure scripts
# for Tk extensions so that they don't have to figure this all
# out for themselves.  This file does not duplicate information
# already provided by tclConfig.sh, so you may need to use that
# file in addition to this one.
#
# The information in this file is specific to a single platform.
#
# RCS: @(#) $Id: tkConfig.sh.in,v 1.8.2.1 2007/09/11 05:17:07 das Exp $

# Tk's version number.
TK_VERSION='8.4'
TK_MAJOR_VERSION='8'
TK_MINOR_VERSION='4'
TK_PATCH_LEVEL='.19'

# -D flags for use with the C compiler.
TK_DEFS=' -DHAVE_LIMITS_H=1 -DHAVE_UNISTD_H=1 -DUSE_THREAD_ALLOC=1 -D_REENTRANT=1 -D_THREAD_SAFE=1 -DHAVE_PTHREAD_ATTR_SETSTACKSIZE=1 -DHAVE_PTHREAD_ATFORK=1 -DTCL_THREADS=1 -DHAVE_COREFOUNDATION=1 -DMAC_OSX_TCL=1 -DTCL_WIDE_INT_IS_LONG=1 -DHAVE_SYS_TIME_H=1 -DTIME_WITH_SYS_TIME=1 -DSTDC_HEADERS=1 -DHAVE_PW_GECOS=1 -DMAC_OSX_TK=1 -DTK_FRAMEWORK=1 '

# Flag, 1: we built a shared lib, 0 we didn't
TK_SHARED_BUILD=1

# This indicates if Tk was build with debugging symbols
TK_DBGX=

# The name of the Tk library (may be either a .a file or a shared library):
TK_LIB_FILE='Tk'

# Additional libraries to use when linking Tk.
TK_LIBS='   -lpthread -framework CoreFoundation -framework Carbon '

# Top-level directory in which Tk's platform-independent files are
# installed.
TK_PREFIX='/usr'

# Top-level directory in which Tk's platform-specific files (e.g.
# executables) are installed.
TK_EXEC_PREFIX='/usr'

# -I switch(es) to use to make all of the X11 include files accessible:
TK_XINCLUDES=''

# Linker switch(es) to use to link with the X11 library archive.
TK_XLIBSW=''

# -l flag to pass to the linker to pick up the Tk library
TK_LIB_FLAG='-framework Tk'

# String to pass to linker to pick up the Tk library from its
# build directory.
TK_BUILD_LIB_SPEC='-F/Library/Caches/com.apple.xbs/Binaries/tcl/tcl-107~132/Objects/OBJROOT1/tk84/Deployment -framework Tk'

# String to pass to linker to pick up the Tk library from its
# installed directory.
TK_LIB_SPEC='-F/System/Library/Frameworks -framework Tk'

# String to pass to the compiler so that an extension can
# find installed Tk headers.
TK_INCLUDE_SPEC='-I/System/Library/Frameworks/Tk.framework/Versions/8.4/Headers'

# Location of the top-level source directory from which Tk was built.
# This is the directory that contains a README file as well as
# subdirectories such as generic, unix, etc.  If Tk was compiled in a
# different place than the directory containing the source files, this
# points to the location of the sources, not the location where Tk was
# compiled.
TK_SRC_DIR='/Library/Caches/com.apple.xbs/Sources/tcl/tcl-107/tk84/tk'

# Needed if you want to make a 'fat' shared library library
# containing tk objects or link a different wish.
TK_CC_SEARCH_FLAGS=''
TK_LD_SEARCH_FLAGS=''

# The name of the Tk stub library (.a):
TK_STUB_LIB_FILE='libtkstub8.4.a'

# -l flag to pass to the linker to pick up the Tk stub library
TK_STUB_LIB_FLAG='-ltkstub8.4'

# String to pass to linker to pick up the Tk stub library from its
# build directory.
TK_BUILD_STUB_LIB_SPEC='-L/Library/Caches/com.apple.xbs/Binaries/tcl/tcl-107~132/Objects/OBJROOT1/tk84/Deployment -ltkstub8.4'

# String to pass to linker to pick up the Tk stub library from its
# installed directory.
TK_STUB_LIB_SPEC='-L/System/Library/Frameworks/Tk.framework/Versions/8.4 -ltkstub8.4'

# Path to the Tk stub library in the build directory.
TK_BUILD_STUB_LIB_PATH='/Library/Caches/com.apple.xbs/Binaries/tcl/tcl-107~132/Objects/OBJROOT1/tk84/Deployment/libtkstub8.4.a'

# Path to the Tk stub library in the install directory.
TK_STUB_LIB_PATH='/System/Library/Frameworks/Tk.framework/Versions/8.4/libtkstub8.4.a'
                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/            0040755 0001750 0001750 00000000000 12612224747 027042  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/    0040755 0001750 0001750 00000000000 12612224747 030415  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11/0040755 0001750 0001750 00000000000 12612224747 030766  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        X.h                                                                                                 0100644 0001750 0001750 00000044341 11056342513 031263  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /*
 *	$XConsortium: X.h,v 1.66 88/09/06 15:55:56 jim Exp $
 */

/* Definitions for the X window system likely to be used by applications */

#ifndef X_H
#define X_H

/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
#define X_PROTOCOL	11		/* current protocol version */
#define X_PROTOCOL_REVISION 0		/* current minor version */

#if defined(MAC_OSX_TK)
#   define Cursor XCursor
#   define Region XRegion
#endif

/* Resources */

#ifdef _WIN64
typedef __int64 XID;
#else
typedef unsigned long XID;
#endif

typedef XID Window;
typedef XID Drawable;
typedef XID Font;
typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;

typedef unsigned long Mask;

typedef unsigned long Atom;

typedef unsigned long VisualID;

typedef unsigned long Time;

typedef unsigned long KeyCode;	/* In order to use IME, the Macintosh needs
				 * to pack 3 bytes into the keyCode field in
				 * the XEvent.  In the real X.h, a KeyCode is
				 * defined as a short, which wouldn't be big
				 * enough. */

/*****************************************************************
 * RESERVED RESOURCE AND CONSTANT DEFINITIONS
 *****************************************************************/

#define None                 0L	/* universal null resource or null atom */

#define ParentRelative       1L	/* background pixmap in CreateWindow
				    and ChangeWindowAttributes */

#define CopyFromParent       0L	/* border pixmap in CreateWindow
				       and ChangeWindowAttributes
				   special VisualID and special window
				       class passed to CreateWindow */

#define PointerWindow        0L	/* destination window in SendEvent */
#define InputFocus           1L	/* destination window in SendEvent */

#define PointerRoot          1L	/* focus window in SetInputFocus */

#define AnyPropertyType      0L	/* special Atom, passed to GetProperty */

#define AnyKey		     0L	/* special Key Code, passed to GrabKey */

#define AnyButton            0L	/* special Button Code, passed to GrabButton */

#define AllTemporary         0L	/* special Resource ID passed to KillClient */

#define CurrentTime          0L	/* special Time */

#define NoSymbol	     0L	/* special KeySym */

/***************************************************************** 
 * EVENT DEFINITIONS 
 *****************************************************************/

/* Input Event Masks. Used as event-mask window attribute and as arguments
   to Grab requests.  Not to be confused with event names.  */

#define NoEventMask			0L
#define KeyPressMask			(1L<<0)  
#define KeyReleaseMask			(1L<<1)  
#define ButtonPressMask			(1L<<2)  
#define ButtonReleaseMask		(1L<<3)  
#define EnterWindowMask			(1L<<4)  
#define LeaveWindowMask			(1L<<5)  
#define PointerMotionMask		(1L<<6)  
#define PointerMotionHintMask		(1L<<7)  
#define Button1MotionMask		(1L<<8)  
#define Button2MotionMask		(1L<<9)  
#define Button3MotionMask		(1L<<10) 
#define Button4MotionMask		(1L<<11) 
#define Button5MotionMask		(1L<<12) 
#define ButtonMotionMask		(1L<<13) 
#define KeymapStateMask			(1L<<14)
#define ExposureMask			(1L<<15) 
#define VisibilityChangeMask		(1L<<16) 
#define StructureNotifyMask		(1L<<17) 
#define ResizeRedirectMask		(1L<<18) 
#define SubstructureNotifyMask		(1L<<19) 
#define SubstructureRedirectMask	(1L<<20) 
#define FocusChangeMask			(1L<<21) 
#define PropertyChangeMask		(1L<<22) 
#define ColormapChangeMask		(1L<<23) 
#define OwnerGrabButtonMask		(1L<<24) 

/* Event names.  Used in "type" field in XEvent structures.  Not to be
confused with event masks above.  They start from 2 because 0 and 1
are reserved in the protocol for errors and replies. */

#define KeyPress		2
#define KeyRelease		3
#define ButtonPress		4
#define ButtonRelease		5
#define MotionNotify		6
#define EnterNotify		7
#define LeaveNotify		8
#define FocusIn			9
#define FocusOut		10
#define KeymapNotify		11
#define Expose			12
#define GraphicsExpose		13
#define NoExpose		14
#define VisibilityNotify	15
#define CreateNotify		16
#define DestroyNotify		17
#define UnmapNotify		18
#define MapNotify		19
#define MapRequest		20
#define ReparentNotify		21
#define ConfigureNotify		22
#define ConfigureRequest	23
#define GravityNotify		24
#define ResizeRequest		25
#define CirculateNotify		26
#define CirculateRequest	27
#define PropertyNotify		28
#define SelectionClear		29
#define SelectionRequest	30
#define SelectionNotify		31
#define ColormapNotify		32
#define ClientMessage		33
#define MappingNotify		34
#define LASTEvent		35	/* must be bigger than any event # */


/* Key masks. Used as modifiers to GrabButton and GrabKey, results of QueryPointer,
   state in various key-, mouse-, and button-related events. */

#define ShiftMask		(1<<0)
#define LockMask		(1<<1)
#define ControlMask		(1<<2)
#define Mod1Mask		(1<<3)
#define Mod2Mask		(1<<4)
#define Mod3Mask		(1<<5)
#define Mod4Mask		(1<<6)
#define Mod5Mask		(1<<7)

/* modifier names.  Used to build a SetModifierMapping request or
   to read a GetModifierMapping request.  These correspond to the
   masks defined above. */
#define ShiftMapIndex		0
#define LockMapIndex		1
#define ControlMapIndex		2
#define Mod1MapIndex		3
#define Mod2MapIndex		4
#define Mod3MapIndex		5
#define Mod4MapIndex		6
#define Mod5MapIndex		7


/* button masks.  Used in same manner as Key masks above. Not to be confused
   with button names below. */

#define Button1Mask		(1<<8)
#define Button2Mask		(1<<9)
#define Button3Mask		(1<<10)
#define Button4Mask		(1<<11)
#define Button5Mask		(1<<12)

#define AnyModifier		(1<<15)  /* used in GrabButton, GrabKey */


/* button names. Used as arguments to GrabButton and as detail in ButtonPress
   and ButtonRelease events.  Not to be confused with button masks above.
   Note that 0 is already defined above as "AnyButton".  */

#define Button1			1
#define Button2			2
#define Button3			3
#define Button4			4
#define Button5			5

/* Notify modes */

#define NotifyNormal		0
#define NotifyGrab		1
#define NotifyUngrab		2
#define NotifyWhileGrabbed	3

#define NotifyHint		1	/* for MotionNotify events */
		       
/* Notify detail */

#define NotifyAncestor		0
#define NotifyVirtual		1
#define NotifyInferior		2
#define NotifyNonlinear		3
#define NotifyNonlinearVirtual	4
#define NotifyPointer		5
#define NotifyPointerRoot	6
#define NotifyDetailNone	7

/* Visibility notify */

#define VisibilityUnobscured		0
#define VisibilityPartiallyObscured	1
#define VisibilityFullyObscured		2

/* Circulation request */

#define PlaceOnTop		0
#define PlaceOnBottom		1

/* protocol families */

#define FamilyInternet		0
#define FamilyDECnet		1
#define FamilyChaos		2

/* Property notification */

#define PropertyNewValue	0
#define PropertyDelete		1

/* Color Map notification */

#define ColormapUninstalled	0
#define ColormapInstalled	1

/* GrabPointer, GrabButton, GrabKeyboard, GrabKey Modes */

#define GrabModeSync		0
#define GrabModeAsync		1

/* GrabPointer, GrabKeyboard reply status */

#define GrabSuccess		0
#define AlreadyGrabbed		1
#define GrabInvalidTime		2
#define GrabNotViewable		3
#define GrabFrozen		4

/* AllowEvents modes */

#define AsyncPointer		0
#define SyncPointer		1
#define ReplayPointer		2
#define AsyncKeyboard		3
#define SyncKeyboard		4
#define ReplayKeyboard		5
#define AsyncBoth		6
#define SyncBoth		7

/* Used in SetInputFocus, GetInputFocus */

#define RevertToNone		(int)None
#define RevertToPointerRoot	(int)PointerRoot
#define RevertToParent		2

/*****************************************************************
 * ERROR CODES 
 *****************************************************************/

#define Success		   0	/* everything's okay */
#define BadRequest	   1	/* bad request code */
#define BadValue	   2	/* int parameter out of range */
#define BadWindow	   3	/* parameter not a Window */
#define BadPixmap	   4	/* parameter not a Pixmap */
#define BadAtom		   5	/* parameter not an Atom */
#define BadCursor	   6	/* parameter not a Cursor */
#define BadFont		   7	/* parameter not a Font */
#define BadMatch	   8	/* parameter mismatch */
#define BadDrawable	   9	/* parameter not a Pixmap or Window */
#define BadAccess	  10	/* depending on context:
				 - key/button already grabbed
				 - attempt to free an illegal 
				   cmap entry 
				- attempt to store into a read-only 
				   color map entry.
 				- attempt to modify the access control
				   list from other than the local host.
				*/
#define BadAlloc	  11	/* insufficient resources */
#define BadColor	  12	/* no such colormap */
#define BadGC		  13	/* parameter not a GC */
#define BadIDChoice	  14	/* choice not in range or already used */
#define BadName		  15	/* font or color name doesn't exist */
#define BadLength	  16	/* Request length incorrect */
#define BadImplementation 17	/* server is defective */

#define FirstExtensionError	128
#define LastExtensionError	255

/*****************************************************************
 * WINDOW DEFINITIONS 
 *****************************************************************/

/* Window classes used by CreateWindow */
/* Note that CopyFromParent is already defined as 0 above */

#define InputOutput		1
#define InputOnly		2

/* Window attributes for CreateWindow and ChangeWindowAttributes */

#define CWBackPixmap		(1L<<0)
#define CWBackPixel		(1L<<1)
#define CWBorderPixmap		(1L<<2)
#define CWBorderPixel           (1L<<3)
#define CWBitGravity		(1L<<4)
#define CWWinGravity		(1L<<5)
#define CWBackingStore          (1L<<6)
#define CWBackingPlanes	        (1L<<7)
#define CWBackingPixel	        (1L<<8)
#define CWOverrideRedirect	(1L<<9)
#define CWSaveUnder		(1L<<10)
#define CWEventMask		(1L<<11)
#define CWDontPropagate	        (1L<<12)
#define CWColormap		(1L<<13)
#define CWCursor	        (1L<<14)

/* ConfigureWindow structure */

#define CWX			(1<<0)
#define CWY			(1<<1)
#define CWWidth			(1<<2)
#define CWHeight		(1<<3)
#define CWBorderWidth		(1<<4)
#define CWSibling		(1<<5)
#define CWStackMode		(1<<6)


/* Bit Gravity */

#define ForgetGravity		0
#define NorthWestGravity	1
#define NorthGravity		2
#define NorthEastGravity	3
#define WestGravity		4
#define CenterGravity		5
#define EastGravity		6
#define SouthWestGravity	7
#define SouthGravity		8
#define SouthEastGravity	9
#define StaticGravity		10

/* Window gravity + bit gravity above */

#define UnmapGravity		0

/* Used in CreateWindow for backing-store hint */

#define NotUseful               0
#define WhenMapped              1
#define Always                  2

/* Used in GetWindowAttributes reply */

#define IsUnmapped		0
#define IsUnviewable		1
#define IsViewable		2

/* Used in ChangeSaveSet */

#define SetModeInsert           0
#define SetModeDelete           1

/* Used in ChangeCloseDownMode */

#define DestroyAll              0
#define RetainPermanent         1
#define RetainTemporary         2

/* Window stacking method (in configureWindow) */

#define Above                   0
#define Below                   1
#define TopIf                   2
#define BottomIf                3
#define Opposite                4

/* Circulation direction */

#define RaiseLowest             0
#define LowerHighest            1

/* Property modes */

#define PropModeReplace         0
#define PropModePrepend         1
#define PropModeAppend          2

/*****************************************************************
 * GRAPHICS DEFINITIONS
 *****************************************************************/

/* graphics functions, as in GC.alu */

#define	GXclear			0x0		/* 0 */
#define GXand			0x1		/* src AND dst */
#define GXandReverse		0x2		/* src AND NOT dst */
#define GXcopy			0x3		/* src */
#define GXandInverted		0x4		/* NOT src AND dst */
#define	GXnoop			0x5		/* dst */
#define GXxor			0x6		/* src XOR dst */
#define GXor			0x7		/* src OR dst */
#define GXnor			0x8		/* NOT src AND NOT dst */
#define GXequiv			0x9		/* NOT src XOR dst */
#define GXinvert		0xa		/* NOT dst */
#define GXorReverse		0xb		/* src OR NOT dst */
#define GXcopyInverted		0xc		/* NOT src */
#define GXorInverted		0xd		/* NOT src OR dst */
#define GXnand			0xe		/* NOT src OR NOT dst */
#define GXset			0xf		/* 1 */

/* LineStyle */

#define LineSolid		0
#define LineOnOffDash		1
#define LineDoubleDash		2

/* capStyle */

#define CapNotLast		0
#define CapButt			1
#define CapRound		2
#define CapProjecting		3

/* joinStyle */

#define JoinMiter		0
#define JoinRound		1
#define JoinBevel		2

/* fillStyle */

#define FillSolid		0
#define FillTiled		1
#define FillStippled		2
#define FillOpaqueStippled	3

/* fillRule */

#define EvenOddRule		0
#define WindingRule		1

/* subwindow mode */

#define ClipByChildren		0
#define IncludeInferiors	1

/* SetClipRectangles ordering */

#define Unsorted		0
#define YSorted			1
#define YXSorted		2
#define YXBanded		3

/* CoordinateMode for drawing routines */

#define CoordModeOrigin		0	/* relative to the origin */
#define CoordModePrevious       1	/* relative to previous point */

/* Polygon shapes */

#define Complex			0	/* paths may intersect */
#define Nonconvex		1	/* no paths intersect, but not convex */
#define Convex			2	/* wholly convex */

/* Arc modes for PolyFillArc */

#define ArcChord		0	/* join endpoints of arc */
#define ArcPieSlice		1	/* join endpoints to center of arc */

/* GC components: masks used in CreateGC, CopyGC, ChangeGC, OR'ed into
   GC.stateChanges */

#define GCFunction              (1L<<0)
#define GCPlaneMask             (1L<<1)
#define GCForeground            (1L<<2)
#define GCBackground            (1L<<3)
#define GCLineWidth             (1L<<4)
#define GCLineStyle             (1L<<5)
#define GCCapStyle              (1L<<6)
#define GCJoinStyle		(1L<<7)
#define GCFillStyle		(1L<<8)
#define GCFillRule		(1L<<9) 
#define GCTile			(1L<<10)
#define GCStipple		(1L<<11)
#define GCTileStipXOrigin	(1L<<12)
#define GCTileStipYOrigin	(1L<<13)
#define GCFont 			(1L<<14)
#define GCSubwindowMode		(1L<<15)
#define GCGraphicsExposures     (1L<<16)
#define GCClipXOrigin		(1L<<17)
#define GCClipYOrigin		(1L<<18)
#define GCClipMask		(1L<<19)
#define GCDashOffset		(1L<<20)
#define GCDashList		(1L<<21)
#define GCArcMode		(1L<<22)

#define GCLastBit		22
/*****************************************************************
 * FONTS 
 *****************************************************************/

/* used in QueryFont -- draw direction */

#define FontLeftToRight		0
#define FontRightToLeft		1

#define FontChange		255

/*****************************************************************
 *  IMAGING 
 *****************************************************************/

/* ImageFormat -- PutImage, GetImage */

#define XYBitmap		0	/* depth 1, XYFormat */
#define XYPixmap		1	/* depth == drawable depth */
#define ZPixmap			2	/* depth == drawable depth */

/*****************************************************************
 *  COLOR MAP STUFF 
 *****************************************************************/

/* For CreateColormap */

#define AllocNone		0	/* create map with no entries */
#define AllocAll		1	/* allocate entire map writeable */


/* Flags used in StoreNamedColor, StoreColors */

#define DoRed			(1<<0)
#define DoGreen			(1<<1)
#define DoBlue			(1<<2)

/*****************************************************************
 * CURSOR STUFF
 *****************************************************************/

/* QueryBestSize Class */

#define CursorShape		0	/* largest size that can be displayed */
#define TileShape		1	/* size tiled fastest */
#define StippleShape		2	/* size stippled fastest */

/***************************************************************** 
 * KEYBOARD/POINTER STUFF
 *****************************************************************/

#define AutoRepeatModeOff	0
#define AutoRepeatModeOn	1
#define AutoRepeatModeDefault	2

#define LedModeOff		0
#define LedModeOn		1

/* masks for ChangeKeyboardControl */

#define KBKeyClickPercent	(1L<<0)
#define KBBellPercent		(1L<<1)
#define KBBellPitch		(1L<<2)
#define KBBellDuration		(1L<<3)
#define KBLed			(1L<<4)
#define KBLedMode		(1L<<5)
#define KBKey			(1L<<6)
#define KBAutoRepeatMode	(1L<<7)

#define MappingSuccess     	0
#define MappingBusy        	1
#define MappingFailed		2

#define MappingModifier		0
#define MappingKeyboard		1
#define MappingPointer		2

/*****************************************************************
 * SCREEN SAVER STUFF 
 *****************************************************************/

#define DontPreferBlanking	0
#define PreferBlanking		1
#define DefaultBlanking		2

#define DisableScreenSaver	0
#define DisableScreenInterval	0

#define DontAllowExposures	0
#define AllowExposures		1
#define DefaultExposures	2

/* for ForceScreenSaver */

#define ScreenSaverReset 0
#define ScreenSaverActive 1

/*****************************************************************
 * HOSTS AND CONNECTIONS
 *****************************************************************/

/* for ChangeHosts */

#define HostInsert		0
#define HostDelete		1

/* for ChangeAccessControl */

#define EnableAccess		1      
#define DisableAccess		0

/* Display classes  used in opening the connection 
 * Note that the statically allocated ones are even numbered and the
 * dynamically changeable ones are odd numbered */

#define StaticGray		0
#define GrayScale		1
#define StaticColor		2
#define PseudoColor		3
#define TrueColor		4
#define DirectColor		5


/* Byte order  used in imageByteOrder and bitmapBitOrder */

#define LSBFirst		0
#define MSBFirst		1

#if defined(MAC_OSX_TK)
#   undef Cursor
#   undef Region
#endif

#endif /* X_H */
                                                                                                                                                                                                                                                                                               Xatom.h                                                                                             0100644 0001750 0001750 00000004726 11056342513 032147  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    #ifndef XATOM_H
#define XATOM_H 1

/* THIS IS A GENERATED FILE
 *
 * Do not change!  Changing this file implies a protocol change!
 */

#define XA_PRIMARY ((Atom) 1)
#define XA_SECONDARY ((Atom) 2)
#define XA_ARC ((Atom) 3)
#define XA_ATOM ((Atom) 4)
#define XA_BITMAP ((Atom) 5)
#define XA_CARDINAL ((Atom) 6)
#define XA_COLORMAP ((Atom) 7)
#define XA_CURSOR ((Atom) 8)
#define XA_CUT_BUFFER0 ((Atom) 9)
#define XA_CUT_BUFFER1 ((Atom) 10)
#define XA_CUT_BUFFER2 ((Atom) 11)
#define XA_CUT_BUFFER3 ((Atom) 12)
#define XA_CUT_BUFFER4 ((Atom) 13)
#define XA_CUT_BUFFER5 ((Atom) 14)
#define XA_CUT_BUFFER6 ((Atom) 15)
#define XA_CUT_BUFFER7 ((Atom) 16)
#define XA_DRAWABLE ((Atom) 17)
#define XA_FONT ((Atom) 18)
#define XA_INTEGER ((Atom) 19)
#define XA_PIXMAP ((Atom) 20)
#define XA_POINT ((Atom) 21)
#define XA_RECTANGLE ((Atom) 22)
#define XA_RESOURCE_MANAGER ((Atom) 23)
#define XA_RGB_COLOR_MAP ((Atom) 24)
#define XA_RGB_BEST_MAP ((Atom) 25)
#define XA_RGB_BLUE_MAP ((Atom) 26)
#define XA_RGB_DEFAULT_MAP ((Atom) 27)
#define XA_RGB_GRAY_MAP ((Atom) 28)
#define XA_RGB_GREEN_MAP ((Atom) 29)
#define XA_RGB_RED_MAP ((Atom) 30)
#define XA_STRING ((Atom) 31)
#define XA_VISUALID ((Atom) 32)
#define XA_WINDOW ((Atom) 33)
#define XA_WM_COMMAND ((Atom) 34)
#define XA_WM_HINTS ((Atom) 35)
#define XA_WM_CLIENT_MACHINE ((Atom) 36)
#define XA_WM_ICON_NAME ((Atom) 37)
#define XA_WM_ICON_SIZE ((Atom) 38)
#define XA_WM_NAME ((Atom) 39)
#define XA_WM_NORMAL_HINTS ((Atom) 40)
#define XA_WM_SIZE_HINTS ((Atom) 41)
#define XA_WM_ZOOM_HINTS ((Atom) 42)
#define XA_MIN_SPACE ((Atom) 43)
#define XA_NORM_SPACE ((Atom) 44)
#define XA_MAX_SPACE ((Atom) 45)
#define XA_END_SPACE ((Atom) 46)
#define XA_SUPERSCRIPT_X ((Atom) 47)
#define XA_SUPERSCRIPT_Y ((Atom) 48)
#define XA_SUBSCRIPT_X ((Atom) 49)
#define XA_SUBSCRIPT_Y ((Atom) 50)
#define XA_UNDERLINE_POSITION ((Atom) 51)
#define XA_UNDERLINE_THICKNESS ((Atom) 52)
#define XA_STRIKEOUT_ASCENT ((Atom) 53)
#define XA_STRIKEOUT_DESCENT ((Atom) 54)
#define XA_ITALIC_ANGLE ((Atom) 55)
#define XA_X_HEIGHT ((Atom) 56)
#define XA_QUAD_WIDTH ((Atom) 57)
#define XA_WEIGHT ((Atom) 58)
#define XA_POINT_SIZE ((Atom) 59)
#define XA_RESOLUTION ((Atom) 60)
#define XA_COPYRIGHT ((Atom) 61)
#define XA_NOTICE ((Atom) 62)
#define XA_FONT_NAME ((Atom) 63)
#define XA_FAMILY_NAME ((Atom) 64)
#define XA_FULL_NAME ((Atom) 65)
#define XA_CAP_HEIGHT ((Atom) 66)
#define XA_WM_CLASS ((Atom) 67)
#define XA_WM_TRANSIENT_FOR ((Atom) 68)

#define XA_LAST_PREDEFINED ((Atom) 68)
#endif /* XATOM_H */
                                          Xfuncproto.h                                                                                        0100644 0001750 0001750 00000003270 11056342513 033217  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: Xfuncproto.h,v 1.7 91/05/13 20:49:21 rws Exp $ */
/* 
 * Copyright 1989, 1991 by the Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided 
 * that the above copyright notice appear in all copies and that both that 
 * copyright notice and this permission notice appear in supporting 
 * documentation, and that the name of M.I.T. not be used in advertising
 * or publicity pertaining to distribution of the software without specific, 
 * written prior permission. M.I.T. makes no representations about the 
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 */

/* Definitions to make function prototypes manageable */

#ifndef _XFUNCPROTO_H_
#define _XFUNCPROTO_H_

#ifndef NeedFunctionPrototypes
#define NeedFunctionPrototypes 1
#endif /* NeedFunctionPrototypes */

#ifndef NeedVarargsPrototypes
#define NeedVarargsPrototypes 0
#endif /* NeedVarargsPrototypes */

#if NeedFunctionPrototypes

#ifndef NeedNestedPrototypes
#define NeedNestedPrototypes 1
#endif /* NeedNestedPrototypes */

#ifndef _Xconst
#define _Xconst const
#endif /* _Xconst */

#ifndef NeedWidePrototypes
#ifdef NARROWPROTO
#define NeedWidePrototypes 0
#else
#define NeedWidePrototypes 1		/* default to make interropt. easier */
#endif
#endif /* NeedWidePrototypes */

#endif /* NeedFunctionPrototypes */

#ifdef __cplusplus
#define _XFUNCPROTOBEGIN extern "C" {
#define _XFUNCPROTOEND }
#endif

#ifndef _XFUNCPROTOBEGIN
#define _XFUNCPROTOBEGIN
#define _XFUNCPROTOEND
#endif /* _XFUNCPROTOBEGIN */

#endif /* _XFUNCPROTO_H_ */
                                                                                                                                                                                                                                                                                                                                        Xlib.h                                                                                              0100644 0001750 0001750 00000117517 11056342513 031760  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: Xlib.h,v 11.221 93/07/02 14:13:28 gildea Exp $ */
/* 
 * Copyright 1985, 1986, 1987, 1991 by the Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided 
 * that the above copyright notice appear in all copies and that both that 
 * copyright notice and this permission notice appear in supporting 
 * documentation, and that the name of M.I.T. not be used in advertising
 * or publicity pertaining to distribution of the software without specific, 
 * written prior permission. M.I.T. makes no representations about the 
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * X Window System is a Trademark of MIT.
 *
 */


/*
 *	Xlib.h - Header definition and support file for the C subroutine
 *	interface library (Xlib) to the X Window System Protocol (V11).
 *	Structures and symbols starting with "_" are private to the library.
 */
#ifndef _XLIB_H_
#define _XLIB_H_

#define XlibSpecificationRelease 5

#if !defined(MAC_OSX_TK)
#   include <X11/X.h>
#endif
#ifdef MAC_OSX_TK
#   include <X11/X.h>
#   define Cursor XCursor
#   define Region XRegion
#endif

/* applications should not depend on these two headers being included! */
#include <X11/Xfuncproto.h>

#ifndef X_WCHAR
#ifdef X_NOT_STDC_ENV
#define X_WCHAR
#endif
#endif

#ifndef X_WCHAR
#include <stddef.h>
#else
/* replace this with #include or typedef appropriate for your system */
typedef unsigned long wchar_t;
#endif

typedef char *XPointer;

#define Bool int
#if defined(MAC_OSX_TK)
/* Use define rather than typedef, since may need to undefine this later */
#define Status int
#else
typedef int Status;
#endif
#define True 1
#define False 0

#define QueuedAlready 0
#define QueuedAfterReading 1
#define QueuedAfterFlush 2

#define ConnectionNumber(dpy) 	((dpy)->fd)
#define RootWindow(dpy, scr) 	(((dpy)->screens[(scr)]).root)
#define DefaultScreen(dpy) 	((dpy)->default_screen)
#define DefaultRootWindow(dpy) 	(((dpy)->screens[(dpy)->default_screen]).root)
#define DefaultVisual(dpy, scr) (((dpy)->screens[(scr)]).root_visual)
#define DefaultGC(dpy, scr) 	(((dpy)->screens[(scr)]).default_gc)
#define BlackPixel(dpy, scr) 	(((dpy)->screens[(scr)]).black_pixel)
#define WhitePixel(dpy, scr) 	(((dpy)->screens[(scr)]).white_pixel)
#define AllPlanes 		((unsigned long)~0L)
#define QLength(dpy) 		((dpy)->qlen)
#define DisplayWidth(dpy, scr) 	(((dpy)->screens[(scr)]).width)
#define DisplayHeight(dpy, scr) (((dpy)->screens[(scr)]).height)
#define DisplayWidthMM(dpy, scr)(((dpy)->screens[(scr)]).mwidth)
#define DisplayHeightMM(dpy, scr)(((dpy)->screens[(scr)]).mheight)
#define DisplayPlanes(dpy, scr) (((dpy)->screens[(scr)]).root_depth)
#define DisplayCells(dpy, scr) 	(DefaultVisual((dpy), (scr))->map_entries)
#define ScreenCount(dpy) 	((dpy)->nscreens)
#define ServerVendor(dpy) 	((dpy)->vendor)
#define ProtocolVersion(dpy) 	((dpy)->proto_major_version)
#define ProtocolRevision(dpy) 	((dpy)->proto_minor_version)
#define VendorRelease(dpy) 	((dpy)->release)
#define DisplayString(dpy) 	((dpy)->display_name)
#define DefaultDepth(dpy, scr) 	(((dpy)->screens[(scr)]).root_depth)
#define DefaultColormap(dpy, scr)(((dpy)->screens[(scr)]).cmap)
#define BitmapUnit(dpy) 	((dpy)->bitmap_unit)
#define BitmapBitOrder(dpy) 	((dpy)->bitmap_bit_order)
#define BitmapPad(dpy) 		((dpy)->bitmap_pad)
#define ImageByteOrder(dpy) 	((dpy)->byte_order)
#define NextRequest(dpy)	((dpy)->request + 1)
#define LastKnownRequestProcessed(dpy)	((dpy)->request)

/* macros for screen oriented applications (toolkit) */
#define ScreenOfDisplay(dpy, scr)(&((dpy)->screens[(scr)]))
#define DefaultScreenOfDisplay(dpy) (&((dpy)->screens[(dpy)->default_screen]))
#define DisplayOfScreen(s)	((s)->display)
#define RootWindowOfScreen(s)	((s)->root)
#define BlackPixelOfScreen(s)	((s)->black_pixel)
#define WhitePixelOfScreen(s)	((s)->white_pixel)
#define DefaultColormapOfScreen(s)((s)->cmap)
#define DefaultDepthOfScreen(s)	((s)->root_depth)
#define DefaultGCOfScreen(s)	((s)->default_gc)
#define DefaultVisualOfScreen(s)((s)->root_visual)
#define WidthOfScreen(s)	((s)->width)
#define HeightOfScreen(s)	((s)->height)
#define WidthMMOfScreen(s)	((s)->mwidth)
#define HeightMMOfScreen(s)	((s)->mheight)
#define PlanesOfScreen(s)	((s)->root_depth)
#define CellsOfScreen(s)	(DefaultVisualOfScreen((s))->map_entries)
#define MinCmapsOfScreen(s)	((s)->min_maps)
#define MaxCmapsOfScreen(s)	((s)->max_maps)
#define DoesSaveUnders(s)	((s)->save_unders)
#define DoesBackingStore(s)	((s)->backing_store)
#define EventMaskOfScreen(s)	((s)->root_input_mask)

/*
 * Extensions need a way to hang private data on some structures.
 */
typedef struct _XExtData {
	int number;		/* number returned by XRegisterExtension */
	struct _XExtData *next;	/* next item on list of data for structure */
	int (*free_private)();	/* called to free private storage */
	XPointer private_data;	/* data private to this extension. */
} XExtData;

/*
 * This file contains structures used by the extension mechanism.
 */
typedef struct {		/* public to extension, cannot be changed */
	int extension;		/* extension number */
	int major_opcode;	/* major op-code assigned by server */
	int first_event;	/* first event number for the extension */
	int first_error;	/* first error number for the extension */
} XExtCodes;

/*
 * Data structure for retrieving info about pixmap formats.
 */

typedef struct {
    int depth;
    int bits_per_pixel;
    int scanline_pad;
} XPixmapFormatValues;


/*
 * Data structure for setting graphics context.
 */
typedef struct {
	int function;		/* logical operation */
	unsigned long plane_mask;/* plane mask */
	unsigned long foreground;/* foreground pixel */
	unsigned long background;/* background pixel */
	int line_width;		/* line width */
	int line_style;	 	/* LineSolid, LineOnOffDash, LineDoubleDash */
	int cap_style;	  	/* CapNotLast, CapButt, 
				   CapRound, CapProjecting */
	int join_style;	 	/* JoinMiter, JoinRound, JoinBevel */
	int fill_style;	 	/* FillSolid, FillTiled, 
				   FillStippled, FillOpaeueStippled */
	int fill_rule;	  	/* EvenOddRule, WindingRule */
	int arc_mode;		/* ArcChord, ArcPieSlice */
	Pixmap tile;		/* tile pixmap for tiling operations */
	Pixmap stipple;		/* stipple 1 plane pixmap for stipping */
	int ts_x_origin;	/* offset for tile or stipple operations */
	int ts_y_origin;
        Font font;	        /* default text font for text operations */
	int subwindow_mode;     /* ClipByChildren, IncludeInferiors */
	Bool graphics_exposures;/* boolean, should exposures be generated */
	int clip_x_origin;	/* origin for clipping */
	int clip_y_origin;
	Pixmap clip_mask;	/* bitmap clipping; other calls for rects */
	int dash_offset;	/* patterned/dashed line information */
	char dashes;
} XGCValues;

/*
 * Graphics context.  The contents of this structure are implementation
 * dependent.  A GC should be treated as opaque by application code.
 */

typedef XGCValues *GC;

/*
 * Visual structure; contains information about colormapping possible.
 */
typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	VisualID visualid;	/* visual id of this visual */
#if defined(__cplusplus) || defined(c_plusplus)
	int c_class;		/* C++ class of screen (monochrome, etc.) */
#else
	int class;		/* class of screen (monochrome, etc.) */
#endif
	unsigned long red_mask, green_mask, blue_mask;	/* mask values */
	int bits_per_rgb;	/* log base 2 of distinct color values */
	int map_entries;	/* color map entries */
} Visual;

/*
 * Depth structure; contains information for each possible depth.
 */	
typedef struct {
	int depth;		/* this depth (Z) of the depth */
	int nvisuals;		/* number of Visual types at this depth */
	Visual *visuals;	/* list of visuals possible at this depth */
} Depth;

/*
 * Information about the screen.  The contents of this structure are
 * implementation dependent.  A Screen should be treated as opaque
 * by application code.
 */
typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	struct _XDisplay *display;/* back pointer to display structure */
	Window root;		/* Root window id. */
	int width, height;	/* width and height of screen */
	int mwidth, mheight;	/* width and height of  in millimeters */
	int ndepths;		/* number of depths possible */
	Depth *depths;		/* list of allowable depths on the screen */
	int root_depth;		/* bits per pixel */
	Visual *root_visual;	/* root visual */
	GC default_gc;		/* GC for the root root visual */
	Colormap cmap;		/* default color map */
	unsigned long white_pixel;
	unsigned long black_pixel;	/* White and Black pixel values */
	int max_maps, min_maps;	/* max and min color maps */
	int backing_store;	/* Never, WhenMapped, Always */
	Bool save_unders;	
	long root_input_mask;	/* initial root input mask */
} Screen;

/*
 * Format structure; describes ZFormat data the screen will understand.
 */
typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	int depth;		/* depth of this image format */
	int bits_per_pixel;	/* bits/pixel at this depth */
	int scanline_pad;	/* scanline must padded to this multiple */
} ScreenFormat;

/*
 * Data structure for setting window attributes.
 */
typedef struct {
    Pixmap background_pixmap;	/* background or None or ParentRelative */
    unsigned long background_pixel;	/* background pixel */
    Pixmap border_pixmap;	/* border of the window */
    unsigned long border_pixel;	/* border pixel value */
    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preseved if possible */
    unsigned long backing_pixel;/* value to use in restoring planes */
    Bool save_under;		/* should bits under be saved? (popups) */
    long event_mask;		/* set of events that should be saved */
    long do_not_propagate_mask;	/* set of events that should not propagate */
    Bool override_redirect;	/* boolean value for override-redirect */
    Colormap colormap;		/* color map to be associated with window */
    Cursor cursor;		/* cursor to be displayed (or None) */
} XSetWindowAttributes;

typedef struct {
    int x, y;			/* location of window */
    int width, height;		/* width and height of window */
    int border_width;		/* border width of window */
    int depth;          	/* depth of window */
    Visual *visual;		/* the associated visual structure */
    Window root;        	/* root of screen containing window */
#if defined(__cplusplus) || defined(c_plusplus)
    int c_class;		/* C++ InputOutput, InputOnly*/
#else
    int class;			/* InputOutput, InputOnly*/
#endif
    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preserved if possible */
    unsigned long backing_pixel;/* value to be used when restoring planes */
    Bool save_under;		/* boolean, should bits under be saved? */
    Colormap colormap;		/* color map to be associated with window */
    Bool map_installed;		/* boolean, is color map currently installed*/
    int map_state;		/* IsUnmapped, IsUnviewable, IsViewable */
    long all_event_masks;	/* set of events all people have interest in*/
    long your_event_mask;	/* my event mask */
    long do_not_propagate_mask; /* set of events that should not propagate */
    Bool override_redirect;	/* boolean value for override-redirect */
    Screen *screen;		/* back pointer to correct screen */
} XWindowAttributes;

/*
 * Data structure for host setting; getting routines.
 *
 */

typedef struct {
	int family;		/* for example FamilyInternet */
	int length;		/* length of address, in bytes */
	char *address;		/* pointer to where to find the bytes */
} XHostAddress;

/*
 * Data structure for "image" data, used by image manipulation routines.
 */
typedef struct _XImage {
    int width, height;		/* size of image */
    int xoffset;		/* number of pixels offset in X direction */
    int format;			/* XYBitmap, XYPixmap, ZPixmap */
    char *data;			/* pointer to image data */
    int byte_order;		/* data byte order, LSBFirst, MSBFirst */
    int bitmap_unit;		/* quant. of scanline 8, 16, 32 */
    int bitmap_bit_order;	/* LSBFirst, MSBFirst */
    int bitmap_pad;		/* 8, 16, 32 either XY or ZPixmap */
    int depth;			/* depth of image */
    int bytes_per_line;		/* accelarator to next line */
    int bits_per_pixel;		/* bits per pixel (ZPixmap) */
    unsigned long red_mask;	/* bits in z arrangment */
    unsigned long green_mask;
    unsigned long blue_mask;
    XPointer obdata;		/* hook for the object routines to hang on */
    struct funcs {		/* image manipulation routines */
	struct _XImage *(*create_image)();
#if NeedFunctionPrototypes
	int (*destroy_image)        (struct _XImage *);
	unsigned long (*get_pixel)  (struct _XImage *, int, int);
	int (*put_pixel)            (struct _XImage *, int, int, unsigned long);
	struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
	int (*add_pixel)            (struct _XImage *, long);
#else
	int (*destroy_image)();
	unsigned long (*get_pixel)();
	int (*put_pixel)();
	struct _XImage *(*sub_image)();
	int (*add_pixel)();
#endif
	} f;
} XImage;

/* 
 * Data structure for XReconfigureWindow
 */
typedef struct {
    int x, y;
    int width, height;
    int border_width;
    Window sibling;
    int stack_mode;
} XWindowChanges;

/*
 * Data structure used by color operations
 */
typedef struct {
	unsigned long pixel;
	unsigned short red, green, blue;
	char flags;  /* do_red, do_green, do_blue */
	char pad;
} XColor;

/* 
 * Data structures for graphics operations.  On most machines, these are
 * congruent with the wire protocol structures, so reformatting the data
 * can be avoided on these architectures.
 */
typedef struct {
    short x1, y1, x2, y2;
} XSegment;

typedef struct {
    short x, y;
} XPoint;
    
typedef struct {
    short x, y;
    unsigned short width, height;
} XRectangle;
    
typedef struct {
    short x, y;
    unsigned short width, height;
    short angle1, angle2;
} XArc;


/* Data structure for XChangeKeyboardControl */

typedef struct {
        int key_click_percent;
        int bell_percent;
        int bell_pitch;
        int bell_duration;
        int led;
        int led_mode;
        int key;
        int auto_repeat_mode;   /* On, Off, Default */
} XKeyboardControl;

/* Data structure for XGetKeyboardControl */

typedef struct {
        int key_click_percent;
	int bell_percent;
	unsigned int bell_pitch, bell_duration;
	unsigned long led_mask;
	int global_auto_repeat;
	char auto_repeats[32];
} XKeyboardState;

/* Data structure for XGetMotionEvents.  */

typedef struct {
        Time time;
	short x, y;
} XTimeCoord;

/* Data structure for X{Set,Get}ModifierMapping */

typedef struct {
 	int max_keypermod;	/* The server's max # of keys per modifier */
 	KeyCode *modifiermap;	/* An 8 by max_keypermod array of modifiers */
} XModifierKeymap;


/*
 * Display datatype maintaining display specific data.
 * The contents of this structure are implementation dependent.
 * A Display should be treated as opaque by application code.
 */
typedef struct _XDisplay {
	XExtData *ext_data;	/* hook for extension to hang data */
	struct _XFreeFuncs *free_funcs; /* internal free functions */
	int fd;			/* Network socket. */
	int conn_checker;         /* ugly thing used by _XEventsQueued */
	int proto_major_version;/* maj. version of server's X protocol */
	int proto_minor_version;/* minor version of servers X protocol */
	char *vendor;		/* vendor of the server hardware */
        XID resource_base;	/* resource ID base */
	XID resource_mask;	/* resource ID mask bits */
	XID resource_id;	/* allocator current ID */
	int resource_shift;	/* allocator shift to correct bits */
	XID (*resource_alloc)(); /* allocator function */
	int byte_order;		/* screen byte order, LSBFirst, MSBFirst */
	int bitmap_unit;	/* padding and data requirements */
	int bitmap_pad;		/* padding requirements on bitmaps */
	int bitmap_bit_order;	/* LeastSignificant or MostSignificant */
	int nformats;		/* number of pixmap formats in list */
	ScreenFormat *pixmap_format;	/* pixmap format list */
	int vnumber;		/* Xlib's X protocol version number. */
	int release;		/* release of the server */
	struct _XSQEvent *head, *tail;	/* Input event queue. */
	int qlen;		/* Length of input event queue */
	unsigned long request;	/* sequence number of last request. */
	char *last_req;		/* beginning of last request, or dummy */
	char *buffer;		/* Output buffer starting address. */
	char *bufptr;		/* Output buffer index pointer. */
	char *bufmax;		/* Output buffer maximum+1 address. */
	unsigned max_request_size; /* maximum number 32 bit words in request*/
	struct _XrmHashBucketRec *db;
	int (*synchandler)();	/* Synchronization handler */
	char *display_name;	/* "host:display" string used on this connect*/
	int default_screen;	/* default screen for operations */
	int nscreens;		/* number of screens on this server*/
	Screen *screens;	/* pointer to list of screens */
	unsigned long motion_buffer;	/* size of motion buffer */
	unsigned long flags;	/* internal connection flags */
	int min_keycode;	/* minimum defined keycode */
	int max_keycode;	/* maximum defined keycode */
	KeySym *keysyms;	/* This server's keysyms */
	XModifierKeymap *modifiermap;	/* This server's modifier keymap */
	int keysyms_per_keycode;/* number of rows */
	char *xdefaults;	/* contents of defaults from server */
	char *scratch_buffer;	/* place to hang scratch buffer */
	unsigned long scratch_length;	/* length of scratch buffer */
	int ext_number;		/* extension number on this display */
	struct _XExten *ext_procs; /* extensions initialized on this display */
	/*
	 * the following can be fixed size, as the protocol defines how
	 * much address space is available. 
	 * While this could be done using the extension vector, there
	 * may be MANY events processed, so a search through the extension
	 * list to find the right procedure for each event might be
	 * expensive if many extensions are being used.
	 */
	Bool (*event_vec[128])();  /* vector for wire to event */
	Status (*wire_vec[128])(); /* vector for event to wire */
	KeySym lock_meaning;	   /* for XLookupString */
	struct _XLockInfo *lock;   /* multi-thread state, display lock */
	struct _XInternalAsync *async_handlers; /* for internal async */
	unsigned long bigreq_size; /* max size of big requests */
	struct _XLockPtrs *lock_fns; /* pointers to threads functions */
	/* things above this line should not move, for binary compatibility */
	struct _XKeytrans *key_bindings; /* for XLookupString */
	Font cursor_font;	   /* for XCreateFontCursor */
	struct _XDisplayAtoms *atoms; /* for XInternAtom */
	unsigned int mode_switch;  /* keyboard group modifiers */
	struct _XContextDB *context_db; /* context database */
	Bool (**error_vec)();      /* vector for wire to error */
	/*
	 * Xcms information
	 */
	struct {
	   XPointer defaultCCCs;  /* pointer to an array of default XcmsCCC */
	   XPointer clientCmaps;  /* pointer to linked list of XcmsCmapRec */
	   XPointer perVisualIntensityMaps;
				  /* linked list of XcmsIntensityMap */
	} cms;
	struct _XIMFilter *im_filters;
	struct _XSQEvent *qfree; /* unallocated event queue elements */
	unsigned long next_event_serial_num; /* inserted into next queue elt */
	int (*savedsynchandler)(); /* user synchandler when Xlib usurps */
} Display;

#if NeedFunctionPrototypes	/* prototypes require event type definitions */
#undef _XEVENT_
#endif
#ifndef _XEVENT_

#define XMaxTransChars 4

/*
 * Definitions of specific events.
 */
typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window it is reported relative to */
	Window root;	        /* root window that the event occured on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int keycode;	/* detail */
	Bool same_screen;	/* same screen flag */
        char trans_chars[XMaxTransChars];
				/* translated characters */
	int nbytes;
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window it is reported relative to */
	Window root;	        /* root window that the event occured on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int button;	/* detail */
	Bool same_screen;	/* same screen flag */
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window reported relative to */
	Window root;	        /* root window that the event occured on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	char is_hint;		/* detail */
	Bool same_screen;	/* same screen flag */
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window reported relative to */
	Window root;	        /* root window that the event occured on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
	int detail;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
	 * NotifyNonlinear,NotifyNonlinearVirtual
	 */
	Bool same_screen;	/* same screen flag */
	Bool focus;		/* boolean focus */
	unsigned int state;	/* key or button mask */
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

typedef struct {
	int type;		/* FocusIn or FocusOut */
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;		/* window of event */
	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
	int detail;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
	 * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
	 * NotifyPointerRoot, NotifyDetailNone 
	 */
} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;

/* generated on EnterWindow and FocusIn  when KeyMapState selected */
typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	char key_vector[32];
} XKeymapEvent;	

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int x, y;
	int width, height;
	int count;		/* if non-zero, at least this many more */
} XExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int x, y;
	int width, height;
	int count;		/* if non-zero, at least this many more */
	int major_code;		/* core is CopyArea or CopyPlane */
	int minor_code;		/* not defined in the core */
} XGraphicsExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int major_code;		/* core is CopyArea or CopyPlane */
	int minor_code;		/* not defined in the core */
} XNoExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int state;		/* Visibility state */
} XVisibilityEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;		/* parent of the window */
	Window window;		/* window id of window created */
	int x, y;		/* window location */
	int width, height;	/* size of window */
	int border_width;	/* border width */
	Bool override_redirect;	/* creation should be overridden */
} XCreateWindowEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
} XDestroyWindowEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Bool from_configure;
} XUnmapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Bool override_redirect;	/* boolean, is override set... */
} XMapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
} XMapRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Window parent;
	int x, y;
	Bool override_redirect;
} XReparentEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	Bool override_redirect;
} XConfigureEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
} XGravityEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int width, height;
} XResizeRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	int detail;		/* Above, Below, TopIf, BottomIf, Opposite */
	unsigned long value_mask;
} XConfigureRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int place;		/* PlaceOnTop, PlaceOnBottom */
} XCirculateEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int place;		/* PlaceOnTop, PlaceOnBottom */
} XCirculateRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom atom;
	Time time;
	int state;		/* NewValue, Deleted */
} XPropertyEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom selection;
	Time time;
} XSelectionClearEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window owner;
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;
	Time time;
} XSelectionRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;		/* ATOM or None */
	Time time;
} XSelectionEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Colormap colormap;	/* COLORMAP or None */
#if defined(__cplusplus) || defined(c_plusplus)
	Bool c_new;		/* C++ */
#else
	Bool new;
#endif
	int state;		/* ColormapInstalled, ColormapUninstalled */
} XColormapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom message_type;
	int format;
	union {
		char b[20];
		short s[10];
		long l[5];
		} data;
} XClientMessageEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;		/* unused */
	int request;		/* one of MappingModifier, MappingKeyboard,
				   MappingPointer */
	int first_keycode;	/* first keycode */
	int count;		/* defines range of change w. first_keycode*/
} XMappingEvent;

typedef struct {
	int type;
	Display *display;	/* Display the event was read from */
	XID resourceid;		/* resource id */
	unsigned long serial;	/* serial number of failed request */
	unsigned char error_code;	/* error code of failed request */
	unsigned char request_code;	/* Major op-code of failed request */
	unsigned char minor_code;	/* Minor op-code of failed request */
} XErrorEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	Bool send_event;	/* true if this came from a SendEvent request */
	Display *display;/* Display the event was read from */
	Window window;	/* window on which event was requested in event mask */
} XAnyEvent;

/*
 * this union is defined so Xlib can always use the same sized
 * event structure internally, to avoid memory fragmentation.
 */
typedef union _XEvent {
        int type;		/* must not be changed; first element */
	XAnyEvent xany;
	XKeyEvent xkey;
	XButtonEvent xbutton;
	XMotionEvent xmotion;
	XCrossingEvent xcrossing;
	XFocusChangeEvent xfocus;
	XExposeEvent xexpose;
	XGraphicsExposeEvent xgraphicsexpose;
	XNoExposeEvent xnoexpose;
	XVisibilityEvent xvisibility;
	XCreateWindowEvent xcreatewindow;
	XDestroyWindowEvent xdestroywindow;
	XUnmapEvent xunmap;
	XMapEvent xmap;
	XMapRequestEvent xmaprequest;
	XReparentEvent xreparent;
	XConfigureEvent xconfigure;
	XGravityEvent xgravity;
	XResizeRequestEvent xresizerequest;
	XConfigureRequestEvent xconfigurerequest;
	XCirculateEvent xcirculate;
	XCirculateRequestEvent xcirculaterequest;
	XPropertyEvent xproperty;
	XSelectionClearEvent xselectionclear;
	XSelectionRequestEvent xselectionrequest;
	XSelectionEvent xselection;
	XColormapEvent xcolormap;
	XClientMessageEvent xclient;
	XMappingEvent xmapping;
	XErrorEvent xerror;
	XKeymapEvent xkeymap;
	long pad[24];
} XEvent;
#endif

#define XAllocID(dpy) ((*(dpy)->resource_alloc)((dpy)))

/*
 * per character font metric information.
 */
typedef struct {
    short	lbearing;	/* origin to left edge of raster */
    short	rbearing;	/* origin to right edge of raster */
    short	width;		/* advance to next char's origin */
    short	ascent;		/* baseline to top edge of raster */
    short	descent;	/* baseline to bottom edge of raster */
    unsigned short attributes;	/* per char flags (not predefined) */
} XCharStruct;

/*
 * To allow arbitrary information with fonts, there are additional properties
 * returned.
 */
typedef struct {
    Atom name;
    unsigned long card32;
} XFontProp;

typedef struct {
    XExtData	*ext_data;	/* hook for extension to hang data */
    Font        fid;            /* Font id for this font */
    unsigned	direction;	/* hint about direction the font is painted */
    unsigned	min_char_or_byte2;/* first character */
    unsigned	max_char_or_byte2;/* last character */
    unsigned	min_byte1;	/* first row that exists */
    unsigned	max_byte1;	/* last row that exists */
    Bool	all_chars_exist;/* flag if all characters have non-zero size*/
    unsigned	default_char;	/* char to print for undefined character */
    int         n_properties;   /* how many properties there are */
    XFontProp	*properties;	/* pointer to array of additional properties*/
    XCharStruct	min_bounds;	/* minimum bounds over all existing char*/
    XCharStruct	max_bounds;	/* maximum bounds over all existing char*/
    XCharStruct	*per_char;	/* first_char to last_char information */
    int		ascent;		/* log. extent above baseline for spacing */
    int		descent;	/* log. descent below baseline for spacing */
} XFontStruct;

/*
 * PolyText routines take these as arguments.
 */
typedef struct {
    char *chars;		/* pointer to string */
    int nchars;			/* number of characters */
    int delta;			/* delta between strings */
    Font font;			/* font to print it in, None don't change */
} XTextItem;

typedef struct {		/* normal 16 bit characters are two bytes */
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;

typedef struct {
    XChar2b *chars;		/* two byte characters */
    int nchars;			/* number of characters */
    int delta;			/* delta between strings */
    Font font;			/* font to print it in, None don't change */
} XTextItem16;


typedef union { Display *display;
		GC gc;
		Visual *visual;
		Screen *screen;
		ScreenFormat *pixmap_format;
		XFontStruct *font; } XEDataObject;

typedef struct {
    XRectangle      max_ink_extent;
    XRectangle      max_logical_extent;
} XFontSetExtents;

typedef struct _XFontSet *XFontSet;

typedef struct {
    char           *chars;
    int             nchars;
    int             delta;
    XFontSet        font_set;
} XmbTextItem;

typedef struct {
    wchar_t        *chars;
    int             nchars;
    int             delta;
    XFontSet        font_set;
} XwcTextItem;

typedef void (*XIMProc)();

typedef struct _XIM *XIM;
typedef struct _XIC *XIC;

typedef unsigned long XIMStyle;

typedef struct {
    unsigned short count_styles;
    XIMStyle *supported_styles;
} XIMStyles;

#define XIMPreeditArea		0x0001L
#define XIMPreeditCallbacks	0x0002L
#define XIMPreeditPosition	0x0004L
#define XIMPreeditNothing	0x0008L
#define XIMPreeditNone		0x0010L
#define XIMStatusArea		0x0100L
#define XIMStatusCallbacks	0x0200L
#define XIMStatusNothing	0x0400L
#define XIMStatusNone		0x0800L

#define XNVaNestedList "XNVaNestedList"
#define XNClientWindow "clientWindow"
#define XNInputStyle "inputStyle"
#define XNFocusWindow "focusWindow"
#define XNResourceName "resourceName"
#define XNResourceClass "resourceClass"
#define XNGeometryCallback "geometryCallback"
#define XNFilterEvents "filterEvents"
#define XNPreeditStartCallback "preeditStartCallback"
#define XNPreeditDoneCallback "preeditDoneCallback"
#define XNPreeditDrawCallback "preeditDrawCallback"
#define XNPreeditCaretCallback "preeditCaretCallback"
#define XNPreeditAttributes "preeditAttributes"
#define XNStatusStartCallback "statusStartCallback"
#define XNStatusDoneCallback "statusDoneCallback"
#define XNStatusDrawCallback "statusDrawCallback"
#define XNStatusAttributes "statusAttributes"
#define XNArea "area"
#define XNAreaNeeded "areaNeeded"
#define XNSpotLocation "spotLocation"
#define XNColormap "colorMap"
#define XNStdColormap "stdColorMap"
#define XNForeground "foreground"
#define XNBackground "background"
#define XNBackgroundPixmap "backgroundPixmap"
#define XNFontSet "fontSet"
#define XNLineSpace "lineSpace"
#define XNCursor "cursor"

#define XBufferOverflow		-1
#define XLookupNone		1
#define XLookupChars		2
#define XLookupKeySym		3
#define XLookupBoth		4

#if NeedFunctionPrototypes
typedef void *XVaNestedList;
#else
typedef XPointer XVaNestedList;
#endif

typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;

typedef unsigned long XIMFeedback;

#define XIMReverse	1
#define XIMUnderline	(1<<1) 
#define XIMHighlight	(1<<2)
#define XIMPrimary 	(1<<5)
#define XIMSecondary	(1<<6)
#define XIMTertiary 	(1<<7)

typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    Bool encoding_is_wchar; 
    union {
	char *multi_byte;
	wchar_t *wide_char;
    } string; 
} XIMText;

typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;		/* Cursor offset within pre-edit string */
    int chg_first;	/* Starting change position */
    int chg_length;	/* Length of the change in character count */
    XIMText *text;
} XIMPreeditDrawCallbackStruct;

typedef enum {
    XIMForwardChar, XIMBackwardChar,
    XIMForwardWord, XIMBackwardWord,
    XIMCaretUp, XIMCaretDown,
    XIMNextLine, XIMPreviousLine,
    XIMLineStart, XIMLineEnd, 
    XIMAbsolutePosition,
    XIMDontChange
} XIMCaretDirection;

typedef enum {
    XIMIsInvisible,	/* Disable caret feedback */ 
    XIMIsPrimary,	/* UI defined caret feedback */
    XIMIsSecondary	/* UI defined caret feedback */
} XIMCaretStyle;

typedef struct _XIMPreeditCaretCallbackStruct {
    int position;		 /* Caret offset within pre-edit string */
    XIMCaretDirection direction; /* Caret moves direction */
    XIMCaretStyle style;	 /* Feedback of the caret */
} XIMPreeditCaretCallbackStruct;

typedef enum {
    XIMTextType,
    XIMBitmapType
} XIMStatusDataType;
	
typedef struct _XIMStatusDrawCallbackStruct {
    XIMStatusDataType type;
    union {
	XIMText *text;
	Pixmap  bitmap;
    } data;
} XIMStatusDrawCallbackStruct;

typedef int (*XErrorHandler) (	    /* WARNING, this type not in Xlib spec */
#if NeedFunctionPrototypes
    Display*		/* display */,
    XErrorEvent*	/* error_event */
#endif
);

_XFUNCPROTOBEGIN



#include "tkIntXlibDecls.h"

_XFUNCPROTOEND

#if defined(MAC_OSX_TK)
#   undef Cursor
#   undef Region
#endif

#endif /* _XLIB_H_ */
                                                                                                                                                                                 Xutil.h                                                                                             0100644 0001750 0001750 00000047411 11056342513 032162  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: Xutil.h,v 11.73 91/07/30 16:21:37 rws Exp $ */

/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef _XUTIL_H_
#define _XUTIL_H_

/* You must include <X11/Xlib.h> before including this file */

#if defined(MAC_OSX_TK)
#   define Region XRegion
#endif

/* 
 * Bitmask returned by XParseGeometry().  Each bit tells if the corresponding
 * value (x, y, width, height) was found in the parsed string.
 */
#define NoValue		0x0000
#define XValue  	0x0001
#define YValue		0x0002
#define WidthValue  	0x0004
#define HeightValue  	0x0008
#define AllValues 	0x000F
#define XNegative 	0x0010
#define YNegative 	0x0020

/*
 * new version containing base_width, base_height, and win_gravity fields;
 * used with WM_NORMAL_HINTS.
 */
typedef struct {
    	long flags;	/* marks which fields in this structure are defined */
	int x, y;		/* obsolete for new window mgrs, but clients */
	int width, height;	/* should set so old wm's don't mess up */
	int min_width, min_height;
	int max_width, max_height;
    	int width_inc, height_inc;
	struct {
		int x;	/* numerator */
		int y;	/* denominator */
	} min_aspect, max_aspect;
	int base_width, base_height;		/* added by ICCCM version 1 */
	int win_gravity;			/* added by ICCCM version 1 */
} XSizeHints;

/*
 * The next block of definitions are for window manager properties that
 * clients and applications use for communication.
 */

/* flags argument in size hints */
#define USPosition	(1L << 0) /* user specified x, y */
#define USSize		(1L << 1) /* user specified width, height */

#define PPosition	(1L << 2) /* program specified position */
#define PSize		(1L << 3) /* program specified size */
#define PMinSize	(1L << 4) /* program specified minimum size */
#define PMaxSize	(1L << 5) /* program specified maximum size */
#define PResizeInc	(1L << 6) /* program specified resize increments */
#define PAspect		(1L << 7) /* program specified min and max aspect ratios */
#define PBaseSize	(1L << 8) /* program specified base for incrementing */
#define PWinGravity	(1L << 9) /* program specified window gravity */

/* obsolete */
#define PAllHints (PPosition|PSize|PMinSize|PMaxSize|PResizeInc|PAspect)



typedef struct {
	long flags;	/* marks which fields in this structure are defined */
	Bool input;	/* does this application rely on the window manager to
			get keyboard input? */
	int initial_state;	/* see below */
	Pixmap icon_pixmap;	/* pixmap to be used as icon */
	Window icon_window; 	/* window to be used as icon */
	int icon_x, icon_y; 	/* initial position of icon */
	Pixmap icon_mask;	/* icon mask bitmap */
	XID window_group;	/* id of related window group */
	/* this structure may be extended in the future */
} XWMHints;

/* definition for flags of XWMHints */

#define InputHint 		(1L << 0)
#define StateHint 		(1L << 1)
#define IconPixmapHint		(1L << 2)
#define IconWindowHint		(1L << 3)
#define IconPositionHint 	(1L << 4)
#define IconMaskHint		(1L << 5)
#define WindowGroupHint		(1L << 6)
#define AllHints (InputHint|StateHint|IconPixmapHint|IconWindowHint| \
IconPositionHint|IconMaskHint|WindowGroupHint)

/* definitions for initial window state */
#define WithdrawnState 0	/* for windows that are not mapped */
#define NormalState 1	/* most applications want to start this way */
#define IconicState 3	/* application wants to start as an icon */

/*
 * Obsolete states no longer defined by ICCCM
 */
#define DontCareState 0	/* don't know or care */
#define ZoomState 2	/* application wants to start zoomed */
#define InactiveState 4	/* application believes it is seldom used; */
			/* some wm's may put it on inactive menu */


/*
 * new structure for manipulating TEXT properties; used with WM_NAME, 
 * WM_ICON_NAME, WM_CLIENT_MACHINE, and WM_COMMAND.
 */
typedef struct {
    unsigned char *value;		/* same as Property routines */
    Atom encoding;			/* prop type */
    int format;				/* prop data format: 8, 16, or 32 */
    unsigned long nitems;		/* number of data items in value */
} XTextProperty;

#define XNoMemory -1
#define XLocaleNotSupported -2
#define XConverterNotFound -3

typedef enum {
    XStringStyle,		/* STRING */
    XCompoundTextStyle,		/* COMPOUND_TEXT */
    XTextStyle,			/* text in owner's encoding (current locale)*/
    XStdICCTextStyle		/* STRING, else COMPOUND_TEXT */
} XICCEncodingStyle;

typedef struct {
	int min_width, min_height;
	int max_width, max_height;
	int width_inc, height_inc;
} XIconSize;

typedef struct {
	char *res_name;
	char *res_class;
} XClassHint;

/*
 * These macros are used to give some sugar to the image routines so that
 * naive people are more comfortable with them.
 */
#define XDestroyImage(ximage) \
	((*((ximage)->f.destroy_image))((ximage)))
#define XGetPixel(ximage, x, y) \
	((*((ximage)->f.get_pixel))((ximage), (x), (y)))
#define XPutPixel(ximage, x, y, pixel) \
	((*((ximage)->f.put_pixel))((ximage), (x), (y), (pixel)))
#define XSubImage(ximage, x, y, width, height)  \
	((*((ximage)->f.sub_image))((ximage), (x), (y), (width), (height)))
#define XAddPixel(ximage, value) \
	((*((ximage)->f.add_pixel))((ximage), (value)))

/*
 * Compose sequence status structure, used in calling XLookupString.
 */
typedef struct _XComposeStatus {
    XPointer compose_ptr;	/* state table pointer */
    int chars_matched;		/* match state */
} XComposeStatus;

/*
 * Keysym macros, used on Keysyms to test for classes of symbols
 */
#define IsKeypadKey(keysym) \
  (((unsigned)(keysym) >= XK_KP_Space) && ((unsigned)(keysym) <= XK_KP_Equal))

#define IsCursorKey(keysym) \
  (((unsigned)(keysym) >= XK_Home)     && ((unsigned)(keysym) <  XK_Select))

#define IsPFKey(keysym) \
  (((unsigned)(keysym) >= XK_KP_F1)     && ((unsigned)(keysym) <= XK_KP_F4))

#define IsFunctionKey(keysym) \
  (((unsigned)(keysym) >= XK_F1)       && ((unsigned)(keysym) <= XK_F35))

#define IsMiscFunctionKey(keysym) \
  (((unsigned)(keysym) >= XK_Select)   && ((unsigned)(keysym) <= XK_Break))

#define IsModifierKey(keysym) \
  ((((unsigned)(keysym) >= XK_Shift_L) && ((unsigned)(keysym) <= XK_Hyper_R)) \
   || ((unsigned)(keysym) == XK_Mode_switch) \
   || ((unsigned)(keysym) == XK_Num_Lock))
/*
 * opaque reference to Region data type 
 */
typedef struct _XRegion *Region; 

/* Return values from XRectInRegion() */
 
#define RectangleOut 0
#define RectangleIn  1
#define RectanglePart 2
 

/*
 * Information used by the visual utility routines to find desired visual
 * type from the many visuals a display may support.
 */

typedef struct {
  Visual *visual;
  VisualID visualid;
  int screen;
  int depth;
#if defined(__cplusplus) || defined(c_plusplus)
  int c_class;					/* C++ */
#else
  int class;
#endif
  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
} XVisualInfo;

#define VisualNoMask		0x0
#define VisualIDMask 		0x1
#define VisualScreenMask	0x2
#define VisualDepthMask		0x4
#define VisualClassMask		0x8
#define VisualRedMaskMask	0x10
#define VisualGreenMaskMask	0x20
#define VisualBlueMaskMask	0x40
#define VisualColormapSizeMask	0x80
#define VisualBitsPerRGBMask	0x100
#define VisualAllMask		0x1FF

/*
 * This defines a window manager property that clients may use to
 * share standard color maps of type RGB_COLOR_MAP:
 */
typedef struct {
	Colormap colormap;
	unsigned long red_max;
	unsigned long red_mult;
	unsigned long green_max;
	unsigned long green_mult;
	unsigned long blue_max;
	unsigned long blue_mult;
	unsigned long base_pixel;
	VisualID visualid;		/* added by ICCCM version 1 */
	XID killid;			/* added by ICCCM version 1 */
} XStandardColormap;

#define ReleaseByFreeingColormap ((XID) 1L)  /* for killid field above */


/*
 * return codes for XReadBitmapFile and XWriteBitmapFile
 */
#define BitmapSuccess		0
#define BitmapOpenFailed 	1
#define BitmapFileInvalid 	2
#define BitmapNoMemory		3

/****************************************************************
 *
 * Context Management
 *
 ****************************************************************/


/* Associative lookup table return codes */

#define XCSUCCESS 0	/* No error. */
#define XCNOMEM   1    /* Out of memory */
#define XCNOENT   2    /* No entry in table */

typedef int XContext;

#define XUniqueContext()       ((XContext) XrmUniqueQuark())
#define XStringToContext(string)   ((XContext) XrmStringToQuark(string))

_XFUNCPROTOBEGIN

/* The following declarations are alphabetized. */

extern XClassHint *XAllocClassHint (
#if NeedFunctionPrototypes
    void
#endif
);

extern XIconSize *XAllocIconSize (
#if NeedFunctionPrototypes
    void
#endif
);

extern XSizeHints *XAllocSizeHints (
#if NeedFunctionPrototypes
    void
#endif
);

extern XStandardColormap *XAllocStandardColormap (
#if NeedFunctionPrototypes
    void
#endif
);

extern XWMHints *XAllocWMHints (
#if NeedFunctionPrototypes
    void
#endif
);

extern void XClipBox(
#if NeedFunctionPrototypes
    Region		/* r */,
    XRectangle*		/* rect_return */
#endif
);

extern Region XCreateRegion(
#if NeedFunctionPrototypes
    void
#endif
);

extern char *XDefaultString(
#if NeedFunctionPrototypes
    void
#endif
);

extern int XDeleteContext(
#if NeedFunctionPrototypes
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */
#endif
);

extern void XDestroyRegion(
#if NeedFunctionPrototypes
    Region		/* r */
#endif
);

extern void XEmptyRegion(
#if NeedFunctionPrototypes
    Region		/* r */
#endif
);

extern void XEqualRegion(
#if NeedFunctionPrototypes
    Region		/* r1 */,
    Region		/* r2 */
#endif
);

extern int XFindContext(
#if NeedFunctionPrototypes
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */,
    XPointer*		/* data_return */
#endif
);

extern Status XGetClassHint(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XClassHint*		/* class_hints_return */
#endif
);

extern Status XGetIconSizes(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XIconSize**		/* size_list_return */,
    int*		/* count_return */
#endif
);

extern Status XGetNormalHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */
#endif
);

extern Status XGetRGBColormaps(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap** /* stdcmap_return */,
    int*		/* count_return */,
    Atom		/* property */
#endif
);

extern Status XGetSizeHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    Atom		/* property */
#endif
);

extern Status XGetStandardColormap(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* colormap_return */,
    Atom		/* property */			    
#endif
);

extern Status XGetTextProperty(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* window */,
    XTextProperty*	/* text_prop_return */,
    Atom		/* property */
#endif
);


extern Status XGetWMClientMachine(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
#endif
);

extern XWMHints *XGetWMHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */		      
#endif
);

extern Status XGetWMIconName(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
#endif
);

extern Status XGetWMName(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
#endif
);

extern Status XGetWMNormalHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    long*		/* supplied_return */ 
#endif
);

extern Status XGetWMSizeHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    long*		/* supplied_return */,
    Atom		/* property */
#endif
);

extern Status XGetZoomHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* zhints_return */
#endif
);

extern void XIntersectRegion(
#if NeedFunctionPrototypes
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
#endif
);

extern int XLookupString(
#if NeedFunctionPrototypes
    XKeyEvent*		/* event_struct */,
    char*		/* buffer_return */,
    int			/* bytes_buffer */,
    KeySym*		/* keysym_return */,
    XComposeStatus*	/* status_in_out */
#endif
);

extern Status XMatchVisualInfo(
#if NeedFunctionPrototypes
    Display*		/* display */,
    int			/* screen */,
    int			/* depth */,
    int			/* class */,
    XVisualInfo*	/* vinfo_return */
#endif
);

extern void XOffsetRegion(
#if NeedFunctionPrototypes
    Region		/* r */,
    int			/* dx */,
    int			/* dy */
#endif
);

extern Bool XPointInRegion(
#if NeedFunctionPrototypes
    Region		/* r */,
    int			/* x */,
    int			/* y */
#endif
);

extern Region XPolygonRegion(
#if NeedFunctionPrototypes
    XPoint*		/* points */,
    int			/* n */,
    int			/* fill_rule */
#endif
);

extern int XRectInRegion(
#if NeedFunctionPrototypes
    Region		/* r */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */
#endif
);

extern int XSaveContext(
#if NeedFunctionPrototypes
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */,
    _Xconst char*	/* data */
#endif
);

extern void XSetClassHint(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XClassHint*		/* class_hints */
#endif
);

extern void XSetIconSizes(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XIconSize*		/* size_list */,
    int			/* count */    
#endif
);

extern void XSetNormalHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */
#endif
);

extern void XSetRGBColormaps(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* stdcmaps */,
    int			/* count */,
    Atom		/* property */
#endif
);

extern void XSetSizeHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */,
    Atom		/* property */
#endif
);

extern void XSetStandardProperties(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    _Xconst char*	/* window_name */,
    _Xconst char*	/* icon_name */,
    Pixmap		/* icon_pixmap */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* hints */
#endif
);

extern void XSetTextProperty(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */,
    Atom		/* property */
#endif
);

extern void XSetWMHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XWMHints*		/* wm_hints */
#endif
);

extern void XSetWMIconName(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */
#endif
);

extern void XSetWMName(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */
#endif
);

extern void XSetWMNormalHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */
#endif
);

extern void XSetWMProperties(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* window_name */,
    XTextProperty*	/* icon_name */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* normal_hints */,
    XWMHints*		/* wm_hints */,
    XClassHint*		/* class_hints */
#endif
);

extern void XmbSetWMProperties(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    _Xconst char*	/* window_name */,
    _Xconst char*	/* icon_name */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* normal_hints */,
    XWMHints*		/* wm_hints */,
    XClassHint*		/* class_hints */
#endif
);

extern void XSetWMSizeHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */,
    Atom		/* property */
#endif
);

extern void XSetRegion(
#if NeedFunctionPrototypes
    Display*		/* display */,
    GC			/* gc */,
    Region		/* r */
#endif
);

extern void XSetStandardColormap(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* colormap */,
    Atom		/* property */
#endif
);

extern void XSetZoomHints(
#if NeedFunctionPrototypes
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* zhints */
#endif
);

extern void XShrinkRegion(
#if NeedFunctionPrototypes
    Region		/* r */,
    int			/* dx */,
    int			/* dy */
#endif
);

extern void XSubtractRegion(
#if NeedFunctionPrototypes
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
#endif
);

extern int XmbTextListToTextProperty(
#if NeedFunctionPrototypes
    Display*		/* display */,
    char**		/* list */,
    int			/* count */,
    XICCEncodingStyle	/* style */,
    XTextProperty*	/* text_prop_return */
#endif
);

extern int XwcTextListToTextProperty(
#if NeedFunctionPrototypes
    Display*		/* display */,
    wchar_t**		/* list */,
    int			/* count */,
    XICCEncodingStyle	/* style */,
    XTextProperty*	/* text_prop_return */
#endif
);

extern void XwcFreeStringList(
#if NeedFunctionPrototypes
    wchar_t**		/* list */
#endif
);

extern Status XTextPropertyToStringList(
#if NeedFunctionPrototypes
    XTextProperty*	/* text_prop */,
    char***		/* list_return */,
    int*		/* count_return */
#endif
);

extern int XmbTextPropertyToTextList(
#if NeedFunctionPrototypes
    Display*		/* display */,
    XTextProperty*	/* text_prop */,
    char***		/* list_return */,
    int*		/* count_return */
#endif
);

extern int XwcTextPropertyToTextList(
#if NeedFunctionPrototypes
    Display*		/* display */,
    XTextProperty*	/* text_prop */,
    wchar_t***		/* list_return */,
    int*		/* count_return */
#endif
);

extern void XUnionRectWithRegion(
#if NeedFunctionPrototypes
    XRectangle*		/* rectangle */,
    Region		/* src_region */,
    Region		/* dest_region_return */
#endif
);

extern void XUnionRegion(
#if NeedFunctionPrototypes
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
#endif
);

extern int XWMGeometry(
#if NeedFunctionPrototypes
    Display*		/* display */,
    int			/* screen_number */,
    _Xconst char*	/* user_geometry */,
    _Xconst char*	/* default_geometry */,
    unsigned int	/* border_width */,
    XSizeHints*		/* hints */,
    int*		/* x_return */,
    int*		/* y_return */,
    int*		/* width_return */,
    int*		/* height_return */,
    int*		/* gravity_return */
#endif
);

extern void XXorRegion(
#if NeedFunctionPrototypes
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
#endif
);

_XFUNCPROTOEND

#if defined(MAC_OSX_TK)
#   undef Region
#endif

#endif /* _XUTIL_H_ */
                                                                                                                                                                                                                                                       cursorfont.h                                                                                        0100644 0001750 0001750 00000003641 11056342513 033256  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: cursorfont.h,v 1.2 88/09/06 16:44:27 jim Exp $ */
#define XC_num_glyphs 154
#define XC_X_cursor 0
#define XC_arrow 2
#define XC_based_arrow_down 4
#define XC_based_arrow_up 6
#define XC_boat 8
#define XC_bogosity 10
#define XC_bottom_left_corner 12
#define XC_bottom_right_corner 14
#define XC_bottom_side 16
#define XC_bottom_tee 18
#define XC_box_spiral 20
#define XC_center_ptr 22
#define XC_circle 24
#define XC_clock 26
#define XC_coffee_mug 28
#define XC_cross 30
#define XC_cross_reverse 32
#define XC_crosshair 34
#define XC_diamond_cross 36
#define XC_dot 38
#define XC_dotbox 40
#define XC_double_arrow 42
#define XC_draft_large 44
#define XC_draft_small 46
#define XC_draped_box 48
#define XC_exchange 50
#define XC_fleur 52
#define XC_gobbler 54
#define XC_gumby 56
#define XC_hand1 58
#define XC_hand2 60
#define XC_heart 62
#define XC_icon 64
#define XC_iron_cross 66
#define XC_left_ptr 68
#define XC_left_side 70
#define XC_left_tee 72
#define XC_leftbutton 74
#define XC_ll_angle 76
#define XC_lr_angle 78
#define XC_man 80
#define XC_middlebutton 82
#define XC_mouse 84
#define XC_pencil 86
#define XC_pirate 88
#define XC_plus 90
#define XC_question_arrow 92
#define XC_right_ptr 94
#define XC_right_side 96
#define XC_right_tee 98
#define XC_rightbutton 100
#define XC_rtl_logo 102
#define XC_sailboat 104
#define XC_sb_down_arrow 106
#define XC_sb_h_double_arrow 108
#define XC_sb_left_arrow 110
#define XC_sb_right_arrow 112
#define XC_sb_up_arrow 114
#define XC_sb_v_double_arrow 116
#define XC_shuttle 118
#define XC_sizing 120
#define XC_spider 122
#define XC_spraycan 124
#define XC_star 126
#define XC_target 128
#define XC_tcross 130
#define XC_top_left_arrow 132
#define XC_top_left_corner 134
#define XC_top_right_corner 136
#define XC_top_side 138
#define XC_top_tee 140
#define XC_trek 142
#define XC_ul_angle 144
#define XC_umbrella 146
#define XC_ur_angle 148
#define XC_watch 150
#define XC_xterm 152
                                                                                               keysym.h                                                                                            0100644 0001750 0001750 00000002652 11056342513 032374  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: keysym.h,v 1.13 91/03/13 20:09:49 rws Exp $ */

/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/* default keysyms */
#define XK_MISCELLANY
#define XK_LATIN1
#define XK_LATIN2
#define XK_LATIN3
#define XK_LATIN4
#define XK_GREEK

#include <X11/keysymdef.h>
                                                                                      keysymdef.h                                                                                         0100644 0001750 0001750 00000146315 11056342513 033060  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /* $XConsortium: keysymdef.h,v 1.15 93/04/02 10:57:36 rws Exp $ */

/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#define XK_VoidSymbol		0xFFFFFF	/* void symbol */

#ifdef XK_MISCELLANY
/*
 * TTY Functions, cleverly chosen to map to ascii, for convenience of
 * programming, but could have been arbitrary (at the cost of lookup
 * tables in client code.
 */

#define XK_BackSpace		0xFF08	/* back space, back char */
#define XK_Tab			0xFF09
#define XK_Linefeed		0xFF0A	/* Linefeed, LF */
#define XK_Clear		0xFF0B
#define XK_Return		0xFF0D	/* Return, enter */
#define XK_Pause		0xFF13	/* Pause, hold */
#define XK_Scroll_Lock		0xFF14
#define XK_Sys_Req		0xFF15
#define XK_Escape		0xFF1B
#define XK_Delete		0xFFFF	/* Delete, rubout */



/* International & multi-key character composition */

#define XK_Multi_key		0xFF20  /* Multi-key character compose */

/* Japanese keyboard support */

#define XK_Kanji		0xFF21	/* Kanji, Kanji convert */
#define XK_Muhenkan		0xFF22  /* Cancel Conversion */
#define XK_Henkan_Mode		0xFF23  /* Start/Stop Conversion */
#define XK_Henkan		0xFF23  /* Alias for Henkan_Mode */
#define XK_Romaji		0xFF24  /* to Romaji */
#define XK_Hiragana		0xFF25  /* to Hiragana */
#define XK_Katakana		0xFF26  /* to Katakana */
#define XK_Hiragana_Katakana	0xFF27  /* Hiragana/Katakana toggle */
#define XK_Zenkaku		0xFF28  /* to Zenkaku */
#define XK_Hankaku		0xFF29  /* to Hankaku */
#define XK_Zenkaku_Hankaku	0xFF2A  /* Zenkaku/Hankaku toggle */
#define XK_Touroku		0xFF2B  /* Add to Dictionary */
#define XK_Massyo		0xFF2C  /* Delete from Dictionary */
#define XK_Kana_Lock		0xFF2D  /* Kana Lock */
#define XK_Kana_Shift		0xFF2E  /* Kana Shift */
#define XK_Eisu_Shift		0xFF2F  /* Alphanumeric Shift */
#define XK_Eisu_toggle		0xFF30  /* Alphanumeric toggle */

/* Cursor control & motion */

#define XK_Home			0xFF50
#define XK_Left			0xFF51	/* Move left, left arrow */
#define XK_Up			0xFF52	/* Move up, up arrow */
#define XK_Right		0xFF53	/* Move right, right arrow */
#define XK_Down			0xFF54	/* Move down, down arrow */
#define XK_Prior		0xFF55	/* Prior, previous */
#define XK_Page_Up		0xFF55
#define XK_Next			0xFF56	/* Next */
#define XK_Page_Down		0xFF56
#define XK_End			0xFF57	/* EOL */
#define XK_Begin		0xFF58	/* BOL */

/* Special Windows keyboard keys */

#define XK_Win_L		0xFF5B	/* Left-hand Windows */
#define XK_Win_R		0xFF5C	/* Right-hand Windows */
#define XK_App			0xFF5D	/* Menu key */

/* Misc Functions */

#define XK_Select		0xFF60	/* Select, mark */
#define XK_Print		0xFF61
#define XK_Execute		0xFF62	/* Execute, run, do */
#define XK_Insert		0xFF63	/* Insert, insert here */
#define XK_Undo			0xFF65	/* Undo, oops */
#define XK_Redo			0xFF66	/* redo, again */
#define XK_Menu			0xFF67
#define XK_Find			0xFF68	/* Find, search */
#define XK_Cancel		0xFF69	/* Cancel, stop, abort, exit */
#define XK_Help			0xFF6A	/* Help, ? */
#define XK_Break		0xFF6B
#define XK_Mode_switch		0xFF7E	/* Character set switch */
#define XK_script_switch        0xFF7E  /* Alias for mode_switch */
#define XK_Num_Lock		0xFF7F

/* Keypad Functions, keypad numbers cleverly chosen to map to ascii */

#define XK_KP_Space		0xFF80	/* space */
#define XK_KP_Tab		0xFF89
#define XK_KP_Enter		0xFF8D	/* enter */
#define XK_KP_F1		0xFF91	/* PF1, KP_A, ... */
#define XK_KP_F2		0xFF92
#define XK_KP_F3		0xFF93
#define XK_KP_F4		0xFF94
#define XK_KP_Home		0xFF95
#define XK_KP_Left		0xFF96
#define XK_KP_Up		0xFF97
#define XK_KP_Right		0xFF98
#define XK_KP_Down		0xFF99
#define XK_KP_Prior		0xFF9A
#define XK_KP_Page_Up		0xFF9A
#define XK_KP_Next		0xFF9B
#define XK_KP_Page_Down		0xFF9B
#define XK_KP_End		0xFF9C
#define XK_KP_Begin		0xFF9D
#define XK_KP_Insert		0xFF9E
#define XK_KP_Delete		0xFF9F
#define XK_KP_Equal		0xFFBD	/* equals */
#define XK_KP_Multiply		0xFFAA
#define XK_KP_Add		0xFFAB
#define XK_KP_Separator		0xFFAC	/* separator, often comma */
#define XK_KP_Subtract		0xFFAD
#define XK_KP_Decimal		0xFFAE
#define XK_KP_Divide		0xFFAF

#define XK_KP_0			0xFFB0
#define XK_KP_1			0xFFB1
#define XK_KP_2			0xFFB2
#define XK_KP_3			0xFFB3
#define XK_KP_4			0xFFB4
#define XK_KP_5			0xFFB5
#define XK_KP_6			0xFFB6
#define XK_KP_7			0xFFB7
#define XK_KP_8			0xFFB8
#define XK_KP_9			0xFFB9



/*
 * Auxilliary Functions; note the duplicate definitions for left and right
 * function keys;  Sun keyboards and a few other manufactures have such
 * function key groups on the left and/or right sides of the keyboard.
 * We've not found a keyboard with more than 35 function keys total.
 */

#define XK_F1			0xFFBE
#define XK_F2			0xFFBF
#define XK_F3			0xFFC0
#define XK_F4			0xFFC1
#define XK_F5			0xFFC2
#define XK_F6			0xFFC3
#define XK_F7			0xFFC4
#define XK_F8			0xFFC5
#define XK_F9			0xFFC6
#define XK_F10			0xFFC7
#define XK_F11			0xFFC8
#define XK_L1			0xFFC8
#define XK_F12			0xFFC9
#define XK_L2			0xFFC9
#define XK_F13			0xFFCA
#define XK_L3			0xFFCA
#define XK_F14			0xFFCB
#define XK_L4			0xFFCB
#define XK_F15			0xFFCC
#define XK_L5			0xFFCC
#define XK_F16			0xFFCD
#define XK_L6			0xFFCD
#define XK_F17			0xFFCE
#define XK_L7			0xFFCE
#define XK_F18			0xFFCF
#define XK_L8			0xFFCF
#define XK_F19			0xFFD0
#define XK_L9			0xFFD0
#define XK_F20			0xFFD1
#define XK_L10			0xFFD1
#define XK_F21			0xFFD2
#define XK_R1			0xFFD2
#define XK_F22			0xFFD3
#define XK_R2			0xFFD3
#define XK_F23			0xFFD4
#define XK_R3			0xFFD4
#define XK_F24			0xFFD5
#define XK_R4			0xFFD5
#define XK_F25			0xFFD6
#define XK_R5			0xFFD6
#define XK_F26			0xFFD7
#define XK_R6			0xFFD7
#define XK_F27			0xFFD8
#define XK_R7			0xFFD8
#define XK_F28			0xFFD9
#define XK_R8			0xFFD9
#define XK_F29			0xFFDA
#define XK_R9			0xFFDA
#define XK_F30			0xFFDB
#define XK_R10			0xFFDB
#define XK_F31			0xFFDC
#define XK_R11			0xFFDC
#define XK_F32			0xFFDD
#define XK_R12			0xFFDD
#define XK_F33			0xFFDE
#define XK_R13			0xFFDE
#define XK_F34			0xFFDF
#define XK_R14			0xFFDF
#define XK_F35			0xFFE0
#define XK_R15			0xFFE0

/* Modifiers */

#define XK_Shift_L		0xFFE1	/* Left shift */
#define XK_Shift_R		0xFFE2	/* Right shift */
#define XK_Control_L		0xFFE3	/* Left control */
#define XK_Control_R		0xFFE4	/* Right control */
#define XK_Caps_Lock		0xFFE5	/* Caps lock */
#define XK_Shift_Lock		0xFFE6	/* Shift lock */

#define XK_Meta_L		0xFFE7	/* Left meta */
#define XK_Meta_R		0xFFE8	/* Right meta */
#define XK_Alt_L		0xFFE9	/* Left alt */
#define XK_Alt_R		0xFFEA	/* Right alt */
#define XK_Super_L		0xFFEB	/* Left super */
#define XK_Super_R		0xFFEC	/* Right super */
#define XK_Hyper_L		0xFFED	/* Left hyper */
#define XK_Hyper_R		0xFFEE	/* Right hyper */
#endif /* XK_MISCELLANY */

/*
 *  Latin 1
 *  Byte 3 = 0
 */
#ifdef XK_LATIN1
#define XK_space               0x020
#define XK_exclam              0x021
#define XK_quotedbl            0x022
#define XK_numbersign          0x023
#define XK_dollar              0x024
#define XK_percent             0x025
#define XK_ampersand           0x026
#define XK_apostrophe          0x027
#define XK_quoteright          0x027	/* deprecated */
#define XK_parenleft           0x028
#define XK_parenright          0x029
#define XK_asterisk            0x02a
#define XK_plus                0x02b
#define XK_comma               0x02c
#define XK_minus               0x02d
#define XK_period              0x02e
#define XK_slash               0x02f
#define XK_0                   0x030
#define XK_1                   0x031
#define XK_2                   0x032
#define XK_3                   0x033
#define XK_4                   0x034
#define XK_5                   0x035
#define XK_6                   0x036
#define XK_7                   0x037
#define XK_8                   0x038
#define XK_9                   0x039
#define XK_colon               0x03a
#define XK_semicolon           0x03b
#define XK_less                0x03c
#define XK_equal               0x03d
#define XK_greater             0x03e
#define XK_question            0x03f
#define XK_at                  0x040
#define XK_A                   0x041
#define XK_B                   0x042
#define XK_C                   0x043
#define XK_D                   0x044
#define XK_E                   0x045
#define XK_F                   0x046
#define XK_G                   0x047
#define XK_H                   0x048
#define XK_I                   0x049
#define XK_J                   0x04a
#define XK_K                   0x04b
#define XK_L                   0x04c
#define XK_M                   0x04d
#define XK_N                   0x04e
#define XK_O                   0x04f
#define XK_P                   0x050
#define XK_Q                   0x051
#define XK_R                   0x052
#define XK_S                   0x053
#define XK_T                   0x054
#define XK_U                   0x055
#define XK_V                   0x056
#define XK_W                   0x057
#define XK_X                   0x058
#define XK_Y                   0x059
#define XK_Z                   0x05a
#define XK_bracketleft         0x05b
#define XK_backslash           0x05c
#define XK_bracketright        0x05d
#define XK_asciicircum         0x05e
#define XK_underscore          0x05f
#define XK_grave               0x060
#define XK_quoteleft           0x060	/* deprecated */
#define XK_a                   0x061
#define XK_b                   0x062
#define XK_c                   0x063
#define XK_d                   0x064
#define XK_e                   0x065
#define XK_f                   0x066
#define XK_g                   0x067
#define XK_h                   0x068
#define XK_i                   0x069
#define XK_j                   0x06a
#define XK_k                   0x06b
#define XK_l                   0x06c
#define XK_m                   0x06d
#define XK_n                   0x06e
#define XK_o                   0x06f
#define XK_p                   0x070
#define XK_q                   0x071
#define XK_r                   0x072
#define XK_s                   0x073
#define XK_t                   0x074
#define XK_u                   0x075
#define XK_v                   0x076
#define XK_w                   0x077
#define XK_x                   0x078
#define XK_y                   0x079
#define XK_z                   0x07a
#define XK_braceleft           0x07b
#define XK_bar                 0x07c
#define XK_braceright          0x07d
#define XK_asciitilde          0x07e

#define XK_nobreakspace        0x0a0
#define XK_exclamdown          0x0a1
#define XK_cent        	       0x0a2
#define XK_sterling            0x0a3
#define XK_currency            0x0a4
#define XK_yen                 0x0a5
#define XK_brokenbar           0x0a6
#define XK_section             0x0a7
#define XK_diaeresis           0x0a8
#define XK_copyright           0x0a9
#define XK_ordfeminine         0x0aa
#define XK_guillemotleft       0x0ab	/* left angle quotation mark */
#define XK_notsign             0x0ac
#define XK_hyphen              0x0ad
#define XK_registered          0x0ae
#define XK_macron              0x0af
#define XK_degree              0x0b0
#define XK_plusminus           0x0b1
#define XK_twosuperior         0x0b2
#define XK_threesuperior       0x0b3
#define XK_acute               0x0b4
#define XK_mu                  0x0b5
#define XK_paragraph           0x0b6
#define XK_periodcentered      0x0b7
#define XK_cedilla             0x0b8
#define XK_onesuperior         0x0b9
#define XK_masculine           0x0ba
#define XK_guillemotright      0x0bb	/* right angle quotation mark */
#define XK_onequarter          0x0bc
#define XK_onehalf             0x0bd
#define XK_threequarters       0x0be
#define XK_questiondown        0x0bf
#define XK_Agrave              0x0c0
#define XK_Aacute              0x0c1
#define XK_Acircumflex         0x0c2
#define XK_Atilde              0x0c3
#define XK_Adiaeresis          0x0c4
#define XK_Aring               0x0c5
#define XK_AE                  0x0c6
#define XK_Ccedilla            0x0c7
#define XK_Egrave              0x0c8
#define XK_Eacute              0x0c9
#define XK_Ecircumflex         0x0ca
#define XK_Ediaeresis          0x0cb
#define XK_Igrave              0x0cc
#define XK_Iacute              0x0cd
#define XK_Icircumflex         0x0ce
#define XK_Idiaeresis          0x0cf
#define XK_ETH                 0x0d0
#define XK_Eth                 0x0d0	/* deprecated */
#define XK_Ntilde              0x0d1
#define XK_Ograve              0x0d2
#define XK_Oacute              0x0d3
#define XK_Ocircumflex         0x0d4
#define XK_Otilde              0x0d5
#define XK_Odiaeresis          0x0d6
#define XK_multiply            0x0d7
#define XK_Ooblique            0x0d8
#define XK_Ugrave              0x0d9
#define XK_Uacute              0x0da
#define XK_Ucircumflex         0x0db
#define XK_Udiaeresis          0x0dc
#define XK_Yacute              0x0dd
#define XK_THORN               0x0de
#define XK_Thorn               0x0de	/* deprecated */
#define XK_ssharp              0x0df
#define XK_agrave              0x0e0
#define XK_aacute              0x0e1
#define XK_acircumflex         0x0e2
#define XK_atilde              0x0e3
#define XK_adiaeresis          0x0e4
#define XK_aring               0x0e5
#define XK_ae                  0x0e6
#define XK_ccedilla            0x0e7
#define XK_egrave              0x0e8
#define XK_eacute              0x0e9
#define XK_ecircumflex         0x0ea
#define XK_ediaeresis          0x0eb
#define XK_igrave              0x0ec
#define XK_iacute              0x0ed
#define XK_icircumflex         0x0ee
#define XK_idiaeresis          0x0ef
#define XK_eth                 0x0f0
#define XK_ntilde              0x0f1
#define XK_ograve              0x0f2
#define XK_oacute              0x0f3
#define XK_ocircumflex         0x0f4
#define XK_otilde              0x0f5
#define XK_odiaeresis          0x0f6
#define XK_division            0x0f7
#define XK_oslash              0x0f8
#define XK_ugrave              0x0f9
#define XK_uacute              0x0fa
#define XK_ucircumflex         0x0fb
#define XK_udiaeresis          0x0fc
#define XK_yacute              0x0fd
#define XK_thorn               0x0fe
#define XK_ydiaeresis          0x0ff
#endif /* XK_LATIN1 */

/*
 *   Latin 2
 *   Byte 3 = 1
 */

#ifdef XK_LATIN2
#define XK_Aogonek             0x1a1
#define XK_breve               0x1a2
#define XK_Lstroke             0x1a3
#define XK_Lcaron              0x1a5
#define XK_Sacute              0x1a6
#define XK_Scaron              0x1a9
#define XK_Scedilla            0x1aa
#define XK_Tcaron              0x1ab
#define XK_Zacute              0x1ac
#define XK_Zcaron              0x1ae
#define XK_Zabovedot           0x1af
#define XK_aogonek             0x1b1
#define XK_ogonek              0x1b2
#define XK_lstroke             0x1b3
#define XK_lcaron              0x1b5
#define XK_sacute              0x1b6
#define XK_caron               0x1b7
#define XK_scaron              0x1b9
#define XK_scedilla            0x1ba
#define XK_tcaron              0x1bb
#define XK_zacute              0x1bc
#define XK_doubleacute         0x1bd
#define XK_zcaron              0x1be
#define XK_zabovedot           0x1bf
#define XK_Racute              0x1c0
#define XK_Abreve              0x1c3
#define XK_Lacute              0x1c5
#define XK_Cacute              0x1c6
#define XK_Ccaron              0x1c8
#define XK_Eogonek             0x1ca
#define XK_Ecaron              0x1cc
#define XK_Dcaron              0x1cf
#define XK_Dstroke             0x1d0
#define XK_Nacute              0x1d1
#define XK_Ncaron              0x1d2
#define XK_Odoubleacute        0x1d5
#define XK_Rcaron              0x1d8
#define XK_Uring               0x1d9
#define XK_Udoubleacute        0x1db
#define XK_Tcedilla            0x1de
#define XK_racute              0x1e0
#define XK_abreve              0x1e3
#define XK_lacute              0x1e5
#define XK_cacute              0x1e6
#define XK_ccaron              0x1e8
#define XK_eogonek             0x1ea
#define XK_ecaron              0x1ec
#define XK_dcaron              0x1ef
#define XK_dstroke             0x1f0
#define XK_nacute              0x1f1
#define XK_ncaron              0x1f2
#define XK_odoubleacute        0x1f5
#define XK_udoubleacute        0x1fb
#define XK_rcaron              0x1f8
#define XK_uring               0x1f9
#define XK_tcedilla            0x1fe
#define XK_abovedot            0x1ff
#endif /* XK_LATIN2 */

/*
 *   Latin 3
 *   Byte 3 = 2
 */

#ifdef XK_LATIN3
#define XK_Hstroke             0x2a1
#define XK_Hcircumflex         0x2a6
#define XK_Iabovedot           0x2a9
#define XK_Gbreve              0x2ab
#define XK_Jcircumflex         0x2ac
#define XK_hstroke             0x2b1
#define XK_hcircumflex         0x2b6
#define XK_idotless            0x2b9
#define XK_gbreve              0x2bb
#define XK_jcircumflex         0x2bc
#define XK_Cabovedot           0x2c5
#define XK_Ccircumflex         0x2c6
#define XK_Gabovedot           0x2d5
#define XK_Gcircumflex         0x2d8
#define XK_Ubreve              0x2dd
#define XK_Scircumflex         0x2de
#define XK_cabovedot           0x2e5
#define XK_ccircumflex         0x2e6
#define XK_gabovedot           0x2f5
#define XK_gcircumflex         0x2f8
#define XK_ubreve              0x2fd
#define XK_scircumflex         0x2fe
#endif /* XK_LATIN3 */


/*
 *   Latin 4
 *   Byte 3 = 3
 */

#ifdef XK_LATIN4
#define XK_kra                 0x3a2
#define XK_kappa               0x3a2	/* deprecated */
#define XK_Rcedilla            0x3a3
#define XK_Itilde              0x3a5
#define XK_Lcedilla            0x3a6
#define XK_Emacron             0x3aa
#define XK_Gcedilla            0x3ab
#define XK_Tslash              0x3ac
#define XK_rcedilla            0x3b3
#define XK_itilde              0x3b5
#define XK_lcedilla            0x3b6
#define XK_emacron             0x3ba
#define XK_gcedilla            0x3bb
#define XK_tslash              0x3bc
#define XK_ENG                 0x3bd
#define XK_eng                 0x3bf
#define XK_Amacron             0x3c0
#define XK_Iogonek             0x3c7
#define XK_Eabovedot           0x3cc
#define XK_Imacron             0x3cf
#define XK_Ncedilla            0x3d1
#define XK_Omacron             0x3d2
#define XK_Kcedilla            0x3d3
#define XK_Uogonek             0x3d9
#define XK_Utilde              0x3dd
#define XK_Umacron             0x3de
#define XK_amacron             0x3e0
#define XK_iogonek             0x3e7
#define XK_eabovedot           0x3ec
#define XK_imacron             0x3ef
#define XK_ncedilla            0x3f1
#define XK_omacron             0x3f2
#define XK_kcedilla            0x3f3
#define XK_uogonek             0x3f9
#define XK_utilde              0x3fd
#define XK_umacron             0x3fe
#endif /* XK_LATIN4 */

/*
 * Katakana
 * Byte 3 = 4
 */

#ifdef XK_KATAKANA
#define XK_overline				       0x47e
#define XK_kana_fullstop                               0x4a1
#define XK_kana_openingbracket                         0x4a2
#define XK_kana_closingbracket                         0x4a3
#define XK_kana_comma                                  0x4a4
#define XK_kana_conjunctive                            0x4a5
#define XK_kana_middledot                              0x4a5  /* deprecated */
#define XK_kana_WO                                     0x4a6
#define XK_kana_a                                      0x4a7
#define XK_kana_i                                      0x4a8
#define XK_kana_u                                      0x4a9
#define XK_kana_e                                      0x4aa
#define XK_kana_o                                      0x4ab
#define XK_kana_ya                                     0x4ac
#define XK_kana_yu                                     0x4ad
#define XK_kana_yo                                     0x4ae
#define XK_kana_tsu                                    0x4af
#define XK_kana_tu                                     0x4af  /* deprecated */
#define XK_prolongedsound                              0x4b0
#define XK_kana_A                                      0x4b1
#define XK_kana_I                                      0x4b2
#define XK_kana_U                                      0x4b3
#define XK_kana_E                                      0x4b4
#define XK_kana_O                                      0x4b5
#define XK_kana_KA                                     0x4b6
#define XK_kana_KI                                     0x4b7
#define XK_kana_KU                                     0x4b8
#define XK_kana_KE                                     0x4b9
#define XK_kana_KO                                     0x4ba
#define XK_kana_SA                                     0x4bb
#define XK_kana_SHI                                    0x4bc
#define XK_kana_SU                                     0x4bd
#define XK_kana_SE                                     0x4be
#define XK_kana_SO                                     0x4bf
#define XK_kana_TA                                     0x4c0
#define XK_kana_CHI                                    0x4c1
#define XK_kana_TI                                     0x4c1  /* deprecated */
#define XK_kana_TSU                                    0x4c2
#define XK_kana_TU                                     0x4c2  /* deprecated */
#define XK_kana_TE                                     0x4c3
#define XK_kana_TO                                     0x4c4
#define XK_kana_NA                                     0x4c5
#define XK_kana_NI                                     0x4c6
#define XK_kana_NU                                     0x4c7
#define XK_kana_NE                                     0x4c8
#define XK_kana_NO                                     0x4c9
#define XK_kana_HA                                     0x4ca
#define XK_kana_HI                                     0x4cb
#define XK_kana_FU                                     0x4cc
#define XK_kana_HU                                     0x4cc  /* deprecated */
#define XK_kana_HE                                     0x4cd
#define XK_kana_HO                                     0x4ce
#define XK_kana_MA                                     0x4cf
#define XK_kana_MI                                     0x4d0
#define XK_kana_MU                                     0x4d1
#define XK_kana_ME                                     0x4d2
#define XK_kana_MO                                     0x4d3
#define XK_kana_YA                                     0x4d4
#define XK_kana_YU                                     0x4d5
#define XK_kana_YO                                     0x4d6
#define XK_kana_RA                                     0x4d7
#define XK_kana_RI                                     0x4d8
#define XK_kana_RU                                     0x4d9
#define XK_kana_RE                                     0x4da
#define XK_kana_RO                                     0x4db
#define XK_kana_WA                                     0x4dc
#define XK_kana_N                                      0x4dd
#define XK_voicedsound                                 0x4de
#define XK_semivoicedsound                             0x4df
#define XK_kana_switch          0xFF7E  /* Alias for mode_switch */
#endif /* XK_KATAKANA */

/*
 *  Arabic
 *  Byte 3 = 5
 */

#ifdef XK_ARABIC
#define XK_Arabic_comma                                0x5ac
#define XK_Arabic_semicolon                            0x5bb
#define XK_Arabic_question_mark                        0x5bf
#define XK_Arabic_hamza                                0x5c1
#define XK_Arabic_maddaonalef                          0x5c2
#define XK_Arabic_hamzaonalef                          0x5c3
#define XK_Arabic_hamzaonwaw                           0x5c4
#define XK_Arabic_hamzaunderalef                       0x5c5
#define XK_Arabic_hamzaonyeh                           0x5c6
#define XK_Arabic_alef                                 0x5c7
#define XK_Arabic_beh                                  0x5c8
#define XK_Arabic_tehmarbuta                           0x5c9
#define XK_Arabic_teh                                  0x5ca
#define XK_Arabic_theh                                 0x5cb
#define XK_Arabic_jeem                                 0x5cc
#define XK_Arabic_hah                                  0x5cd
#define XK_Arabic_khah                                 0x5ce
#define XK_Arabic_dal                                  0x5cf
#define XK_Arabic_thal                                 0x5d0
#define XK_Arabic_ra                                   0x5d1
#define XK_Arabic_zain                                 0x5d2
#define XK_Arabic_seen                                 0x5d3
#define XK_Arabic_sheen                                0x5d4
#define XK_Arabic_sad                                  0x5d5
#define XK_Arabic_dad                                  0x5d6
#define XK_Arabic_tah                                  0x5d7
#define XK_Arabic_zah                                  0x5d8
#define XK_Arabic_ain                                  0x5d9
#define XK_Arabic_ghain                                0x5da
#define XK_Arabic_tatweel                              0x5e0
#define XK_Arabic_feh                                  0x5e1
#define XK_Arabic_qaf                                  0x5e2
#define XK_Arabic_kaf                                  0x5e3
#define XK_Arabic_lam                                  0x5e4
#define XK_Arabic_meem                                 0x5e5
#define XK_Arabic_noon                                 0x5e6
#define XK_Arabic_ha                                   0x5e7
#define XK_Arabic_heh                                  0x5e7  /* deprecated */
#define XK_Arabic_waw                                  0x5e8
#define XK_Arabic_alefmaksura                          0x5e9
#define XK_Arabic_yeh                                  0x5ea
#define XK_Arabic_fathatan                             0x5eb
#define XK_Arabic_dammatan                             0x5ec
#define XK_Arabic_kasratan                             0x5ed
#define XK_Arabic_fatha                                0x5ee
#define XK_Arabic_damma                                0x5ef
#define XK_Arabic_kasra                                0x5f0
#define XK_Arabic_shadda                               0x5f1
#define XK_Arabic_sukun                                0x5f2
#define XK_Arabic_switch        0xFF7E  /* Alias for mode_switch */
#endif /* XK_ARABIC */

/*
 * Cyrillic
 * Byte 3 = 6
 */
#ifdef XK_CYRILLIC
#define XK_Serbian_dje                                 0x6a1
#define XK_Macedonia_gje                               0x6a2
#define XK_Cyrillic_io                                 0x6a3
#define XK_Ukrainian_ie                                0x6a4
#define XK_Ukranian_je                                 0x6a4  /* deprecated */
#define XK_Macedonia_dse                               0x6a5
#define XK_Ukrainian_i                                 0x6a6
#define XK_Ukranian_i                                  0x6a6  /* deprecated */
#define XK_Ukrainian_yi                                0x6a7
#define XK_Ukranian_yi                                 0x6a7  /* deprecated */
#define XK_Cyrillic_je                                 0x6a8
#define XK_Serbian_je                                  0x6a8  /* deprecated */
#define XK_Cyrillic_lje                                0x6a9
#define XK_Serbian_lje                                 0x6a9  /* deprecated */
#define XK_Cyrillic_nje                                0x6aa
#define XK_Serbian_nje                                 0x6aa  /* deprecated */
#define XK_Serbian_tshe                                0x6ab
#define XK_Macedonia_kje                               0x6ac
#define XK_Byelorussian_shortu                         0x6ae
#define XK_Cyrillic_dzhe                               0x6af
#define XK_Serbian_dze                                 0x6af  /* deprecated */
#define XK_numerosign                                  0x6b0
#define XK_Serbian_DJE                                 0x6b1
#define XK_Macedonia_GJE                               0x6b2
#define XK_Cyrillic_IO                                 0x6b3
#define XK_Ukrainian_IE                                0x6b4
#define XK_Ukranian_JE                                 0x6b4  /* deprecated */
#define XK_Macedonia_DSE                               0x6b5
#define XK_Ukrainian_I                                 0x6b6
#define XK_Ukranian_I                                  0x6b6  /* deprecated */
#define XK_Ukrainian_YI                                0x6b7
#define XK_Ukranian_YI                                 0x6b7  /* deprecated */
#define XK_Cyrillic_JE                                 0x6b8
#define XK_Serbian_JE                                  0x6b8  /* deprecated */
#define XK_Cyrillic_LJE                                0x6b9
#define XK_Serbian_LJE                                 0x6b9  /* deprecated */
#define XK_Cyrillic_NJE                                0x6ba
#define XK_Serbian_NJE                                 0x6ba  /* deprecated */
#define XK_Serbian_TSHE                                0x6bb
#define XK_Macedonia_KJE                               0x6bc
#define XK_Byelorussian_SHORTU                         0x6be
#define XK_Cyrillic_DZHE                               0x6bf
#define XK_Serbian_DZE                                 0x6bf  /* deprecated */
#define XK_Cyrillic_yu                                 0x6c0
#define XK_Cyrillic_a                                  0x6c1
#define XK_Cyrillic_be                                 0x6c2
#define XK_Cyrillic_tse                                0x6c3
#define XK_Cyrillic_de                                 0x6c4
#define XK_Cyrillic_ie                                 0x6c5
#define XK_Cyrillic_ef                                 0x6c6
#define XK_Cyrillic_ghe                                0x6c7
#define XK_Cyrillic_ha                                 0x6c8
#define XK_Cyrillic_i                                  0x6c9
#define XK_Cyrillic_shorti                             0x6ca
#define XK_Cyrillic_ka                                 0x6cb
#define XK_Cyrillic_el                                 0x6cc
#define XK_Cyrillic_em                                 0x6cd
#define XK_Cyrillic_en                                 0x6ce
#define XK_Cyrillic_o                                  0x6cf
#define XK_Cyrillic_pe                                 0x6d0
#define XK_Cyrillic_ya                                 0x6d1
#define XK_Cyrillic_er                                 0x6d2
#define XK_Cyrillic_es                                 0x6d3
#define XK_Cyrillic_te                                 0x6d4
#define XK_Cyrillic_u                                  0x6d5
#define XK_Cyrillic_zhe                                0x6d6
#define XK_Cyrillic_ve                                 0x6d7
#define XK_Cyrillic_softsign                           0x6d8
#define XK_Cyrillic_yeru                               0x6d9
#define XK_Cyrillic_ze                                 0x6da
#define XK_Cyrillic_sha                                0x6db
#define XK_Cyrillic_e                                  0x6dc
#define XK_Cyrillic_shcha                              0x6dd
#define XK_Cyrillic_che                                0x6de
#define XK_Cyrillic_hardsign                           0x6df
#define XK_Cyrillic_YU                                 0x6e0
#define XK_Cyrillic_A                                  0x6e1
#define XK_Cyrillic_BE                                 0x6e2
#define XK_Cyrillic_TSE                                0x6e3
#define XK_Cyrillic_DE                                 0x6e4
#define XK_Cyrillic_IE                                 0x6e5
#define XK_Cyrillic_EF                                 0x6e6
#define XK_Cyrillic_GHE                                0x6e7
#define XK_Cyrillic_HA                                 0x6e8
#define XK_Cyrillic_I                                  0x6e9
#define XK_Cyrillic_SHORTI                             0x6ea
#define XK_Cyrillic_KA                                 0x6eb
#define XK_Cyrillic_EL                                 0x6ec
#define XK_Cyrillic_EM                                 0x6ed
#define XK_Cyrillic_EN                                 0x6ee
#define XK_Cyrillic_O                                  0x6ef
#define XK_Cyrillic_PE                                 0x6f0
#define XK_Cyrillic_YA                                 0x6f1
#define XK_Cyrillic_ER                                 0x6f2
#define XK_Cyrillic_ES                                 0x6f3
#define XK_Cyrillic_TE                                 0x6f4
#define XK_Cyrillic_U                                  0x6f5
#define XK_Cyrillic_ZHE                                0x6f6
#define XK_Cyrillic_VE                                 0x6f7
#define XK_Cyrillic_SOFTSIGN                           0x6f8
#define XK_Cyrillic_YERU                               0x6f9
#define XK_Cyrillic_ZE                                 0x6fa
#define XK_Cyrillic_SHA                                0x6fb
#define XK_Cyrillic_E                                  0x6fc
#define XK_Cyrillic_SHCHA                              0x6fd
#define XK_Cyrillic_CHE                                0x6fe
#define XK_Cyrillic_HARDSIGN                           0x6ff
#endif /* XK_CYRILLIC */

/*
 * Greek
 * Byte 3 = 7
 */

#ifdef XK_GREEK
#define XK_Greek_ALPHAaccent                           0x7a1
#define XK_Greek_EPSILONaccent                         0x7a2
#define XK_Greek_ETAaccent                             0x7a3
#define XK_Greek_IOTAaccent                            0x7a4
#define XK_Greek_IOTAdiaeresis                         0x7a5
#define XK_Greek_OMICRONaccent                         0x7a7
#define XK_Greek_UPSILONaccent                         0x7a8
#define XK_Greek_UPSILONdieresis                       0x7a9
#define XK_Greek_OMEGAaccent                           0x7ab
#define XK_Greek_accentdieresis                        0x7ae
#define XK_Greek_horizbar                              0x7af
#define XK_Greek_alphaaccent                           0x7b1
#define XK_Greek_epsilonaccent                         0x7b2
#define XK_Greek_etaaccent                             0x7b3
#define XK_Greek_iotaaccent                            0x7b4
#define XK_Greek_iotadieresis                          0x7b5
#define XK_Greek_iotaaccentdieresis                    0x7b6
#define XK_Greek_omicronaccent                         0x7b7
#define XK_Greek_upsilonaccent                         0x7b8
#define XK_Greek_upsilondieresis                       0x7b9
#define XK_Greek_upsilonaccentdieresis                 0x7ba
#define XK_Greek_omegaaccent                           0x7bb
#define XK_Greek_ALPHA                                 0x7c1
#define XK_Greek_BETA                                  0x7c2
#define XK_Greek_GAMMA                                 0x7c3
#define XK_Greek_DELTA                                 0x7c4
#define XK_Greek_EPSILON                               0x7c5
#define XK_Greek_ZETA                                  0x7c6
#define XK_Greek_ETA                                   0x7c7
#define XK_Greek_THETA                                 0x7c8
#define XK_Greek_IOTA                                  0x7c9
#define XK_Greek_KAPPA                                 0x7ca
#define XK_Greek_LAMDA                                 0x7cb
#define XK_Greek_LAMBDA                                0x7cb
#define XK_Greek_MU                                    0x7cc
#define XK_Greek_NU                                    0x7cd
#define XK_Greek_XI                                    0x7ce
#define XK_Greek_OMICRON                               0x7cf
#define XK_Greek_PI                                    0x7d0
#define XK_Greek_RHO                                   0x7d1
#define XK_Greek_SIGMA                                 0x7d2
#define XK_Greek_TAU                                   0x7d4
#define XK_Greek_UPSILON                               0x7d5
#define XK_Greek_PHI                                   0x7d6
#define XK_Greek_CHI                                   0x7d7
#define XK_Greek_PSI                                   0x7d8
#define XK_Greek_OMEGA                                 0x7d9
#define XK_Greek_alpha                                 0x7e1
#define XK_Greek_beta                                  0x7e2
#define XK_Greek_gamma                                 0x7e3
#define XK_Greek_delta                                 0x7e4
#define XK_Greek_epsilon                               0x7e5
#define XK_Greek_zeta                                  0x7e6
#define XK_Greek_eta                                   0x7e7
#define XK_Greek_theta                                 0x7e8
#define XK_Greek_iota                                  0x7e9
#define XK_Greek_kappa                                 0x7ea
#define XK_Greek_lamda                                 0x7eb
#define XK_Greek_lambda                                0x7eb
#define XK_Greek_mu                                    0x7ec
#define XK_Greek_nu                                    0x7ed
#define XK_Greek_xi                                    0x7ee
#define XK_Greek_omicron                               0x7ef
#define XK_Greek_pi                                    0x7f0
#define XK_Greek_rho                                   0x7f1
#define XK_Greek_sigma                                 0x7f2
#define XK_Greek_finalsmallsigma                       0x7f3
#define XK_Greek_tau                                   0x7f4
#define XK_Greek_upsilon                               0x7f5
#define XK_Greek_phi                                   0x7f6
#define XK_Greek_chi                                   0x7f7
#define XK_Greek_psi                                   0x7f8
#define XK_Greek_omega                                 0x7f9
#define XK_Greek_switch         0xFF7E  /* Alias for mode_switch */
#endif /* XK_GREEK */

/*
 * Technical
 * Byte 3 = 8
 */

#ifdef XK_TECHNICAL
#define XK_leftradical                                 0x8a1
#define XK_topleftradical                              0x8a2
#define XK_horizconnector                              0x8a3
#define XK_topintegral                                 0x8a4
#define XK_botintegral                                 0x8a5
#define XK_vertconnector                               0x8a6
#define XK_topleftsqbracket                            0x8a7
#define XK_botleftsqbracket                            0x8a8
#define XK_toprightsqbracket                           0x8a9
#define XK_botrightsqbracket                           0x8aa
#define XK_topleftparens                               0x8ab
#define XK_botleftparens                               0x8ac
#define XK_toprightparens                              0x8ad
#define XK_botrightparens                              0x8ae
#define XK_leftmiddlecurlybrace                        0x8af
#define XK_rightmiddlecurlybrace                       0x8b0
#define XK_topleftsummation                            0x8b1
#define XK_botleftsummation                            0x8b2
#define XK_topvertsummationconnector                   0x8b3
#define XK_botvertsummationconnector                   0x8b4
#define XK_toprightsummation                           0x8b5
#define XK_botrightsummation                           0x8b6
#define XK_rightmiddlesummation                        0x8b7
#define XK_lessthanequal                               0x8bc
#define XK_notequal                                    0x8bd
#define XK_greaterthanequal                            0x8be
#define XK_integral                                    0x8bf
#define XK_therefore                                   0x8c0
#define XK_variation                                   0x8c1
#define XK_infinity                                    0x8c2
#define XK_nabla                                       0x8c5
#define XK_approximate                                 0x8c8
#define XK_similarequal                                0x8c9
#define XK_ifonlyif                                    0x8cd
#define XK_implies                                     0x8ce
#define XK_identical                                   0x8cf
#define XK_radical                                     0x8d6
#define XK_includedin                                  0x8da
#define XK_includes                                    0x8db
#define XK_intersection                                0x8dc
#define XK_union                                       0x8dd
#define XK_logicaland                                  0x8de
#define XK_logicalor                                   0x8df
#define XK_partialderivative                           0x8ef
#define XK_function                                    0x8f6
#define XK_leftarrow                                   0x8fb
#define XK_uparrow                                     0x8fc
#define XK_rightarrow                                  0x8fd
#define XK_downarrow                                   0x8fe
#endif /* XK_TECHNICAL */

/*
 *  Special
 *  Byte 3 = 9
 */

#ifdef XK_SPECIAL
#define XK_blank                                       0x9df
#define XK_soliddiamond                                0x9e0
#define XK_checkerboard                                0x9e1
#define XK_ht                                          0x9e2
#define XK_ff                                          0x9e3
#define XK_cr                                          0x9e4
#define XK_lf                                          0x9e5
#define XK_nl                                          0x9e8
#define XK_vt                                          0x9e9
#define XK_lowrightcorner                              0x9ea
#define XK_uprightcorner                               0x9eb
#define XK_upleftcorner                                0x9ec
#define XK_lowleftcorner                               0x9ed
#define XK_crossinglines                               0x9ee
#define XK_horizlinescan1                              0x9ef
#define XK_horizlinescan3                              0x9f0
#define XK_horizlinescan5                              0x9f1
#define XK_horizlinescan7                              0x9f2
#define XK_horizlinescan9                              0x9f3
#define XK_leftt                                       0x9f4
#define XK_rightt                                      0x9f5
#define XK_bott                                        0x9f6
#define XK_topt                                        0x9f7
#define XK_vertbar                                     0x9f8
#endif /* XK_SPECIAL */

/*
 *  Publishing
 *  Byte 3 = a
 */

#ifdef XK_PUBLISHING
#define XK_emspace                                     0xaa1
#define XK_enspace                                     0xaa2
#define XK_em3space                                    0xaa3
#define XK_em4space                                    0xaa4
#define XK_digitspace                                  0xaa5
#define XK_punctspace                                  0xaa6
#define XK_thinspace                                   0xaa7
#define XK_hairspace                                   0xaa8
#define XK_emdash                                      0xaa9
#define XK_endash                                      0xaaa
#define XK_signifblank                                 0xaac
#define XK_ellipsis                                    0xaae
#define XK_doubbaselinedot                             0xaaf
#define XK_onethird                                    0xab0
#define XK_twothirds                                   0xab1
#define XK_onefifth                                    0xab2
#define XK_twofifths                                   0xab3
#define XK_threefifths                                 0xab4
#define XK_fourfifths                                  0xab5
#define XK_onesixth                                    0xab6
#define XK_fivesixths                                  0xab7
#define XK_careof                                      0xab8
#define XK_figdash                                     0xabb
#define XK_leftanglebracket                            0xabc
#define XK_decimalpoint                                0xabd
#define XK_rightanglebracket                           0xabe
#define XK_marker                                      0xabf
#define XK_oneeighth                                   0xac3
#define XK_threeeighths                                0xac4
#define XK_fiveeighths                                 0xac5
#define XK_seveneighths                                0xac6
#define XK_trademark                                   0xac9
#define XK_signaturemark                               0xaca
#define XK_trademarkincircle                           0xacb
#define XK_leftopentriangle                            0xacc
#define XK_rightopentriangle                           0xacd
#define XK_emopencircle                                0xace
#define XK_emopenrectangle                             0xacf
#define XK_leftsinglequotemark                         0xad0
#define XK_rightsinglequotemark                        0xad1
#define XK_leftdoublequotemark                         0xad2
#define XK_rightdoublequotemark                        0xad3
#define XK_prescription                                0xad4
#define XK_minutes                                     0xad6
#define XK_seconds                                     0xad7
#define XK_latincross                                  0xad9
#define XK_hexagram                                    0xada
#define XK_filledrectbullet                            0xadb
#define XK_filledlefttribullet                         0xadc
#define XK_filledrighttribullet                        0xadd
#define XK_emfilledcircle                              0xade
#define XK_emfilledrect                                0xadf
#define XK_enopencircbullet                            0xae0
#define XK_enopensquarebullet                          0xae1
#define XK_openrectbullet                              0xae2
#define XK_opentribulletup                             0xae3
#define XK_opentribulletdown                           0xae4
#define XK_openstar                                    0xae5
#define XK_enfilledcircbullet                          0xae6
#define XK_enfilledsqbullet                            0xae7
#define XK_filledtribulletup                           0xae8
#define XK_filledtribulletdown                         0xae9
#define XK_leftpointer                                 0xaea
#define XK_rightpointer                                0xaeb
#define XK_club                                        0xaec
#define XK_diamond                                     0xaed
#define XK_heart                                       0xaee
#define XK_maltesecross                                0xaf0
#define XK_dagger                                      0xaf1
#define XK_doubledagger                                0xaf2
#define XK_checkmark                                   0xaf3
#define XK_ballotcross                                 0xaf4
#define XK_musicalsharp                                0xaf5
#define XK_musicalflat                                 0xaf6
#define XK_malesymbol                                  0xaf7
#define XK_femalesymbol                                0xaf8
#define XK_telephone                                   0xaf9
#define XK_telephonerecorder                           0xafa
#define XK_phonographcopyright                         0xafb
#define XK_caret                                       0xafc
#define XK_singlelowquotemark                          0xafd
#define XK_doublelowquotemark                          0xafe
#define XK_cursor                                      0xaff
#endif /* XK_PUBLISHING */

/*
 *  APL
 *  Byte 3 = b
 */

#ifdef XK_APL
#define XK_leftcaret                                   0xba3
#define XK_rightcaret                                  0xba6
#define XK_downcaret                                   0xba8
#define XK_upcaret                                     0xba9
#define XK_overbar                                     0xbc0
#define XK_downtack                                    0xbc2
#define XK_upshoe                                      0xbc3
#define XK_downstile                                   0xbc4
#define XK_underbar                                    0xbc6
#define XK_jot                                         0xbca
#define XK_quad                                        0xbcc
#define XK_uptack                                      0xbce
#define XK_circle                                      0xbcf
#define XK_upstile                                     0xbd3
#define XK_downshoe                                    0xbd6
#define XK_rightshoe                                   0xbd8
#define XK_leftshoe                                    0xbda
#define XK_lefttack                                    0xbdc
#define XK_righttack                                   0xbfc
#endif /* XK_APL */

/*
 * Hebrew
 * Byte 3 = c
 */

#ifdef XK_HEBREW
#define XK_hebrew_doublelowline                        0xcdf
#define XK_hebrew_aleph                                0xce0
#define XK_hebrew_bet                                  0xce1
#define XK_hebrew_beth                                 0xce1  /* deprecated */
#define XK_hebrew_gimel                                0xce2
#define XK_hebrew_gimmel                               0xce2  /* deprecated */
#define XK_hebrew_dalet                                0xce3
#define XK_hebrew_daleth                               0xce3  /* deprecated */
#define XK_hebrew_he                                   0xce4
#define XK_hebrew_waw                                  0xce5
#define XK_hebrew_zain                                 0xce6
#define XK_hebrew_zayin                                0xce6  /* deprecated */
#define XK_hebrew_chet                                 0xce7
#define XK_hebrew_het                                  0xce7  /* deprecated */
#define XK_hebrew_tet                                  0xce8
#define XK_hebrew_teth                                 0xce8  /* deprecated */
#define XK_hebrew_yod                                  0xce9
#define XK_hebrew_finalkaph                            0xcea
#define XK_hebrew_kaph                                 0xceb
#define XK_hebrew_lamed                                0xcec
#define XK_hebrew_finalmem                             0xced
#define XK_hebrew_mem                                  0xcee
#define XK_hebrew_finalnun                             0xcef
#define XK_hebrew_nun                                  0xcf0
#define XK_hebrew_samech                               0xcf1
#define XK_hebrew_samekh                               0xcf1  /* deprecated */
#define XK_hebrew_ayin                                 0xcf2
#define XK_hebrew_finalpe                              0xcf3
#define XK_hebrew_pe                                   0xcf4
#define XK_hebrew_finalzade                            0xcf5
#define XK_hebrew_finalzadi                            0xcf5  /* deprecated */
#define XK_hebrew_zade                                 0xcf6
#define XK_hebrew_zadi                                 0xcf6  /* deprecated */
#define XK_hebrew_qoph                                 0xcf7
#define XK_hebrew_kuf                                  0xcf7  /* deprecated */
#define XK_hebrew_resh                                 0xcf8
#define XK_hebrew_shin                                 0xcf9
#define XK_hebrew_taw                                  0xcfa
#define XK_hebrew_taf                                  0xcfa  /* deprecated */
#define XK_Hebrew_switch        0xFF7E  /* Alias for mode_switch */
#endif /* XK_HEBREW */

                                                                                                                                                                                                                                                                                                                   xbytes.h                                                                                            0100644 0001750 0001750 00000004401 11056342513 032363  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/X11                                                                    /*
 * xbytes.h --
 *
 *	Declaration of table to reverse bit order of bytes.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _XBYTES
#define _XBYTES

/*
 * The bits in a byte can be reversed so the least significant becomes the
 * most significant by indexing xBitReverseTable with the byte to be reversed.
 */

static unsigned char xBitReverseTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

#endif /* _XBYTES */

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
                                                                                                                                                                                                                                                               tk-private/                                                                                         0040755 0001750 0001750 00000000000 12612224747 032424  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers                                                                        default.h                                                                                           0100644 0001750 0001750 00000001224 12566233006 034211  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * default.h --
 *
 *	This file defines the defaults for all options for all of
 *	the Tk widgets.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _DEFAULT
#define _DEFAULT

#if defined(__WIN32__) || defined(_WIN32) || \
    defined(__MINGW32__)
#   include "tkWinDefault.h"
#else
#   if defined(MAC_OSX_TK)
#	include "tkMacOSXDefault.h"
#   else
#	include "tkUnixDefault.h"
#   endif
#endif

#endif /* _DEFAULT */
                                                                                                                                                                                                                                                                                                                                                                            tkFont.h                                                                                            0100644 0001750 0001750 00000017462 12566233006 034045  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkFont.h --
 *
 *	Declarations for interfaces between the generic and platform-specific
 *	parts of the font package. This information is not visible outside of
 *	the font package.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKFONT
#define _TKFONT

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * The following structure keeps track of the attributes of a font. It can be
 * used to keep track of either the desired attributes or the actual
 * attributes gotten when the font was instantiated.
 */

struct TkFontAttributes {
    Tk_Uid family;		/* Font family, or NULL to represent plaform-
				 * specific default system font. */
    int size;			/* Pointsize of font, 0 for default size, or
				 * negative number meaning pixel size. */
    int weight;			/* Weight flag; see below for def'n. */
    int slant;			/* Slant flag; see below for def'n. */
    int underline;		/* Non-zero for underline font. */
    int overstrike;		/* Non-zero for overstrike font. */
};

/*
 * Possible values for the "weight" field in a TkFontAttributes structure.
 * Weight is a subjective term and depends on what the company that created
 * the font considers bold.
 */

#define TK_FW_NORMAL	0
#define TK_FW_BOLD	1

#define TK_FW_UNKNOWN	-1	/* Unknown weight. This value is used for
				 * error checking and is never actually stored
				 * in the weight field. */

/*
 * Possible values for the "slant" field in a TkFontAttributes structure.
 */

#define TK_FS_ROMAN	0
#define TK_FS_ITALIC	1
#define TK_FS_OBLIQUE	2	/* This value is only used when parsing X font
				 * names to determine the closest match. It is
				 * only stored in the XLFDAttributes
				 * structure, never in the slant field of the
				 * TkFontAttributes. */

#define TK_FS_UNKNOWN	-1	/* Unknown slant. This value is used for error
				 * checking and is never actually stored in
				 * the slant field. */

/*
 * The following structure keeps track of the metrics for an instantiated
 * font. The metrics are the physical properties of the font itself.
 */

typedef struct TkFontMetrics {
    int	ascent;			/* From baseline to top of font. */
    int	descent;		/* From baseline to bottom of font. */
    int maxWidth;		/* Width of widest character in font. */
    int fixed;			/* Non-zero if this is a fixed-width font,
				 * 0 otherwise. */
} TkFontMetrics;

/*
 * The following structure is used to keep track of the generic information
 * about a font. Each platform-specific font is represented by a structure
 * with the following structure at its beginning, plus any platform-specific
 * stuff after that.
 */

typedef struct TkFont {
    /*
     * Fields used and maintained exclusively by generic code.
     */

    int resourceRefCount;	/* Number of active uses of this font (each
				 * active use corresponds to a call to
				 * Tk_AllocFontFromTable or Tk_GetFont). If
				 * this count is 0, then this TkFont structure
				 * is no longer valid and it isn't present in
				 * a hash table: it is being kept around only
				 * because there are objects referring to it.
				 * The structure is freed when
				 * resourceRefCount and objRefCount are both
				 * 0. */
    int objRefCount;		/* The number of Tcl objects that reference
				 * this structure. */
    Tcl_HashEntry *cacheHashPtr;/* Entry in font cache for this structure,
				 * used when deleting it. */
    Tcl_HashEntry *namedHashPtr;/* Pointer to hash table entry that
				 * corresponds to the named font that the
				 * tkfont was based on, or NULL if the tkfont
				 * was not based on a named font. */
    Screen *screen;		/* The screen where this font is valid. */
    int tabWidth;		/* Width of tabs in this font (pixels). */
    int	underlinePos;		/* Offset from baseline to origin of underline
				 * bar (used for drawing underlines on a
				 * non-underlined font). */
    int underlineHeight;	/* Height of underline bar (used for drawing
				 * underlines on a non-underlined font). */

    /*
     * Fields used in the generic code that are filled in by
     * platform-specific code.
     */

    Font fid;			/* For backwards compatibility with XGCValues
				 * structures. Remove when TkGCValues is
				 * implemented. */
    TkFontAttributes fa;	/* Actual font attributes obtained when the
				 * the font was created, as opposed to the
				 * desired attributes passed in to
				 * TkpGetFontFromAttributes(). The desired
				 * metrics can be determined from the string
				 * that was used to create this font. */
    TkFontMetrics fm;		/* Font metrics determined when font was
				 * created. */
    struct TkFont *nextPtr;	/* Points to the next TkFont structure with
				 * the same name. All fonts with the same name
				 * (but different displays) are chained
				 * together off a single entry in a hash
				 * table. */
} TkFont;

/*
 * The following structure is used to return attributes when parsing an XLFD.
 * The extra information is of interest to the Unix-specific code when
 * attempting to find the closest matching font.
 */

typedef struct TkXLFDAttributes {
    Tk_Uid foundry;		/* The foundry of the font. */
    int slant;			/* The tristate value for the slant, which is
				 * significant under X. */
    int setwidth;		/* The proportionate width, see below for
				 * definition. */
    Tk_Uid charset;		/* The actual charset string. */
} TkXLFDAttributes;

/*
 * Possible values for the "setwidth" field in a TkXLFDAttributes structure.
 * The setwidth is whether characters are considered wider or narrower than
 * normal.
 */

#define TK_SW_NORMAL	0
#define TK_SW_CONDENSE	1
#define TK_SW_EXPAND	2
#define TK_SW_UNKNOWN	3	/* Unknown setwidth. This value may be stored
				 * in the setwidth field. */

/*
 * The following defines specify the meaning of the fields in a fully
 * qualified XLFD.
 */

#define XLFD_FOUNDRY	    0
#define XLFD_FAMILY	    1
#define XLFD_WEIGHT	    2
#define XLFD_SLANT	    3
#define XLFD_SETWIDTH	    4
#define XLFD_ADD_STYLE	    5
#define XLFD_PIXEL_SIZE	    6
#define XLFD_POINT_SIZE	    7
#define XLFD_RESOLUTION_X   8
#define XLFD_RESOLUTION_Y   9
#define XLFD_SPACING	    10
#define XLFD_AVERAGE_WIDTH  11
#define XLFD_CHARSET	    12
#define XLFD_NUMFIELDS	    13	/* Number of fields in XLFD. */

/*
 * Low-level API exported by generic code to platform-specific code.
 */

#define TkInitFontAttributes(fa)   memset((fa), 0, sizeof(TkFontAttributes));
#define TkInitXLFDAttributes(xa)   memset((xa), 0, sizeof(TkXLFDAttributes));

MODULE_SCOPE int	TkFontParseXLFD(CONST char *string,
			    TkFontAttributes *faPtr, TkXLFDAttributes *xaPtr);
MODULE_SCOPE char **	TkFontGetAliasList(CONST char *faceName);
MODULE_SCOPE char ***	TkFontGetFallbacks(void);
MODULE_SCOPE int	TkFontGetPixels(Tk_Window tkwin, int size);
MODULE_SCOPE int	TkFontGetPoints(Tk_Window tkwin, int size);
MODULE_SCOPE char **	TkFontGetGlobalClass(void);
MODULE_SCOPE char **	TkFontGetSymbolClass(void);
MODULE_SCOPE int	TkCreateNamedFont(Tcl_Interp *interp, Tk_Window tkwin,
			    CONST char *name, TkFontAttributes *faPtr);
MODULE_SCOPE int	TkDeleteNamedFont(Tcl_Interp *interp,
			    Tk_Window tkwin, CONST char *name);
MODULE_SCOPE int	TkFontGetFirstTextLayout(Tk_TextLayout layout,
			    Tk_Font *font, char *dst);

/*
 * Low-level API exported by platform-specific code to generic code.
 */

MODULE_SCOPE void	TkpDeleteFont(TkFont *tkFontPtr);
MODULE_SCOPE void	TkpFontPkgInit(TkMainInfo *mainPtr);
MODULE_SCOPE TkFont *	TkpGetFontFromAttributes(TkFont *tkFontPtr,
			    Tk_Window tkwin, CONST TkFontAttributes *faPtr);
MODULE_SCOPE void	TkpGetFontFamilies(Tcl_Interp *interp,
			    Tk_Window tkwin);
MODULE_SCOPE TkFont *	TkpGetNativeFont(Tk_Window tkwin, CONST char *name);

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif	/* _TKFONT */
                                                                                                                                                                                                              tkInt.h                                                                                             0100644 0001750 0001750 00000121450 11442001037 033647  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkInt.h --
 *
 *	Declarations for things used internally by the Tk functions but not
 *	exported outside the module.
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: $Id$
 */

#ifndef _TKINT
#define _TKINT

#ifndef _TK
#include "tk.h"
#endif
#ifndef _TCL
#include "tcl.h"
#endif
#ifndef _TKPORT
#include "tkPort.h"
#endif

/*
 * Ensure WORDS_BIGENDIAN is defined correcly:
 * Needs to happen here in addition to configure to work with fat compiles on
 * Darwin (where configure runs only once for multiple architectures).
 */

#ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#    include <sys/param.h>
#endif
#ifdef BYTE_ORDER
#    ifdef BIG_ENDIAN
#	 if BYTE_ORDER == BIG_ENDIAN
#	     undef WORDS_BIGENDIAN
#	     define WORDS_BIGENDIAN 1
#	 endif
#    endif
#    ifdef LITTLE_ENDIAN
#	 if BYTE_ORDER == LITTLE_ENDIAN
#	     undef WORDS_BIGENDIAN
#	 endif
#    endif
#endif

/*
 * Used to tag functions that are only to be visible within the module being
 * built and not outside it (where this is supported by the linker).
 */

#ifndef MODULE_SCOPE
#   ifdef __cplusplus
#	define MODULE_SCOPE extern "C"
#   else
#	define MODULE_SCOPE extern
#   endif
#endif

/*
 * Macros used to cast between pointers and integers (e.g. when storing an int
 * in ClientData), on 64-bit architectures they avoid gcc warning about "cast
 * to/from pointer from/to integer of different size".
 */

#if !defined(INT2PTR) && !defined(PTR2INT)
#   if defined(HAVE_INTPTR_T) || defined(intptr_t)
#	define INT2PTR(p) ((void*)(intptr_t)(p))
#	define PTR2INT(p) ((int)(intptr_t)(p))
#   else
#	define INT2PTR(p) ((void*)(p))
#	define PTR2INT(p) ((int)(p))
#   endif
#endif
#if !defined(UINT2PTR) && !defined(PTR2UINT)
#   if defined(HAVE_UINTPTR_T) || defined(uintptr_t)
#	define UINT2PTR(p) ((void*)(uintptr_t)(p))
#	define PTR2UINT(p) ((unsigned int)(uintptr_t)(p))
#   else
#	define UINT2PTR(p) ((void*)(p))
#	define PTR2UINT(p) ((unsigned int)(p))
#   endif
#endif

/*
 * Opaque type declarations:
 */

typedef struct TkColormap TkColormap;
typedef struct TkFontAttributes TkFontAttributes;
typedef struct TkGrabEvent TkGrabEvent;
typedef struct TkpCursor_ *TkpCursor;
typedef struct TkRegion_ *TkRegion;
typedef struct TkStressedCmap TkStressedCmap;
typedef struct TkBindInfo_ *TkBindInfo;

/*
 * Function types.
 */

typedef int (TkBindEvalProc)(ClientData clientData, Tcl_Interp *interp,
	XEvent *eventPtr, Tk_Window tkwin, KeySym keySym);
typedef void (TkBindFreeProc)(ClientData clientData);

/*
 * One of the following structures is maintained for each cursor in use in the
 * system. This structure is used by tkCursor.c and the various system
 * specific cursor files.
 */

typedef struct TkCursor {
    Tk_Cursor cursor;		/* System specific identifier for cursor. */
    Display *display;		/* Display containing cursor. Needed for
				 * disposal and retrieval of cursors. */
    int resourceRefCount;	/* Number of active uses of this cursor (each
				 * active use corresponds to a call to
				 * Tk_AllocPreserveFromObj or Tk_Preserve). If
				 * this count is 0, then this structure is no
				 * longer valid and it isn't present in a hash
				 * table: it is being kept around only because
				 * there are objects referring to it. The
				 * structure is freed when resourceRefCount
				 * and objRefCount are both 0. */
    int objRefCount;		/* Number of Tcl objects that reference this
				 * structure.. */
    Tcl_HashTable *otherTable;	/* Second table (other than idTable) used to
				 * index this entry. */
    Tcl_HashEntry *hashPtr;	/* Entry in otherTable for this structure
				 * (needed when deleting). */
    Tcl_HashEntry *idHashPtr;	/* Entry in idTable for this structure (needed
				 * when deleting). */
    struct TkCursor *nextPtr;	/* Points to the next TkCursor structure with
				 * the same name. Cursors with the same name
				 * but different displays are chained together
				 * off a single hash table entry. */
} TkCursor;

/*
 * The following structure is kept one-per-TkDisplay to maintain information
 * about the caret (cursor location) on this display. This is used to dictate
 * global focus location (Windows Accessibility guidelines) and to position
 * the IME or XIM over-the-spot window.
 */

typedef struct TkCaret {
    struct TkWindow *winPtr;	/* The window on which we requested caret
				 * placement. */
    int x;			/* Relative x coord of the caret. */
    int y;			/* Relative y coord of the caret. */
    int height;			/* Specified height of the window. */
} TkCaret;

/*
 * One of the following structures is maintained for each display containing a
 * window managed by Tk. In part, the structure is used to store thread-
 * specific data, since each thread will have its own TkDisplay structure.
 */

typedef struct TkDisplay {
    Display *display;		/* Xlib's info about display. */
    struct TkDisplay *nextPtr;	/* Next in list of all displays. */
    char *name;			/* Name of display (with any screen identifier
				 * removed). Malloc-ed. */
    Time lastEventTime;		/* Time of last event received for this
				 * display. */

    /*
     * Information used primarily by tk3d.c:
     */

    int borderInit;		/* 0 means borderTable needs initializing. */
    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
				 * structure. */

    /*
     * Information used by tkAtom.c only:
     */

    int atomInit;		/* 0 means stuff below hasn't been initialized
				 * yet. */
    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */

    /*
     * Information used primarily by tkBind.c:
     */

    int bindInfoStale;		/* Non-zero means the variables in this part
				 * of the structure are potentially incorrect
				 * and should be recomputed. */
    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
				 * corresponding to "mode shift". If no such
				 * modifier, than this is zero. */
    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
				 * corresponding to the "Meta" key. If no such
				 * modifier, then this is zero. */
    unsigned int altModMask;	/* Has one bit set to indicate the modifier
				 * corresponding to the "Meta" key. If no such
				 * modifier, then this is zero. */
    enum {LU_IGNORE, LU_CAPS, LU_SHIFT} lockUsage;
				/* Indicates how to interpret lock
				 * modifier. */
    int numModKeyCodes;		/* Number of entries in modKeyCodes array
				 * below. */
    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for all
				 * of the keys that have modifiers associated
				 * with them. Malloc'ed, but may be NULL. */

    /*
     * Information used by tkBitmap.c only:
     */

    int bitmapInit;		/* 0 means tables above need initializing. */
    int bitmapAutoNumber;	/* Used to number bitmaps. */
    Tcl_HashTable bitmapNameTable;
				/* Maps from name of bitmap to the first
				 * TkBitmap record for that name. */
    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
				 * structure for the bitmap. */
    Tcl_HashTable bitmapDataTable;
				/* Used by Tk_GetBitmapFromData to map from a
				 * collection of in-core data about a bitmap
				 * to a reference giving an automatically-
				 * generated name for the bitmap. */

    /*
     * Information used by tkCanvas.c only:
     */

    int numIdSearches;
    int numSlowSearches;

    /*
     * Used by tkColor.c only:
     */

    int colorInit;		/* 0 means color module needs initializing. */
    TkStressedCmap *stressPtr;	/* First in list of colormaps that have filled
				 * up, so we have to pick an approximate
				 * color. */
    Tcl_HashTable colorNameTable;
				/* Maps from color name to TkColor structure
				 * for that color. */
    Tcl_HashTable colorValueTable;
				/* Maps from integer RGB values to TkColor
				 * structures. */

    /*
     * Used by tkCursor.c only:
     */

    int cursorInit;		/* 0 means cursor module need initializing. */
    Tcl_HashTable cursorNameTable;
				/* Maps from a string name to a cursor to the
				 * TkCursor record for the cursor. */
    Tcl_HashTable cursorDataTable;
				/* Maps from a collection of in-core data
				 * about a cursor to a TkCursor structure. */
    Tcl_HashTable cursorIdTable;
				/* Maps from a cursor id to the TkCursor
				 * structure for the cursor. */
    char cursorString[20];	/* Used to store a cursor id string. */
    Font cursorFont;		/* Font to use for standard cursors. None
				 * means font not loaded yet. */

    /*
     * Information used by tkError.c only:
     */

    struct TkErrorHandler *errorPtr;
				/* First in list of error handlers for this
				 * display. NULL means no handlers exist at
				 * present. */
    int deleteCount;		/* Counts # of handlers deleted since last
				 * time inactive handlers were garbage-
				 * collected. When this number gets big,
				 * handlers get cleaned up. */

    /*
     * Used by tkEvent.c only:
     */

    struct TkWindowEvent *delayedMotionPtr;
				/* Points to a malloc-ed motion event whose
				 * processing has been delayed in the hopes
				 * that another motion event will come along
				 * right away and we can merge the two of them
				 * together. NULL means that there is no
				 * delayed motion event. */

    /*
     * Information used by tkFocus.c only:
     */

    int focusDebug;		/* 1 means collect focus debugging
				 * statistics. */
    struct TkWindow *implicitWinPtr;
				/* If the focus arrived at a toplevel window
				 * implicitly via an Enter event (rather than
				 * via a FocusIn event), this points to the
				 * toplevel window. Otherwise it is NULL. */
    struct TkWindow *focusPtr;	/* Points to the window on this display that
				 * should be receiving keyboard events. When
				 * multiple applications on the display have
				 * the focus, this will refer to the innermost
				 * window in the innermost application. This
				 * information isn't used on Windows, but it's
				 * needed on the Mac, and also on X11 when XIM
				 * processing is being done. */

    /*
     * Information used by tkGC.c only:
     */

    Tcl_HashTable gcValueTable; /* Maps from a GC's values to a TkGC structure
				 * describing a GC with those values. */
    Tcl_HashTable gcIdTable;    /* Maps from a GC to a TkGC. */
    int gcInit;			/* 0 means the tables below need
				 * initializing. */

    /*
     * Information used by tkGeometry.c only:
     */

    Tcl_HashTable maintainHashTable;
				/* Hash table that maps from a master's
				 * Tk_Window token to a list of slaves managed
				 * by that master. */
    int geomInit;

    /*
     * Information used by tkGet.c only:
     */

    Tcl_HashTable uidTable;	/* Stores all Tk_Uid used in a thread. */
    int uidInit;		/* 0 means uidTable needs initializing. */

    /*
     * Information used by tkGrab.c only:
     */

    struct TkWindow *grabWinPtr;/* Window in which the pointer is currently
				 * grabbed, or NULL if none. */
    struct TkWindow *eventualGrabWinPtr;
				/* Value that grabWinPtr will have once the
				 * grab event queue (below) has been
				 * completely emptied. */
    struct TkWindow *buttonWinPtr;
				/* Window in which first mouse button was
				 * pressed while grab was in effect, or NULL
				 * if no such press in effect. */
    struct TkWindow *serverWinPtr;
				/* If no application contains the pointer then
				 * this is NULL. Otherwise it contains the
				 * last window for which we've gotten an Enter
				 * or Leave event from the server (i.e. the
				 * last window known to have contained the
				 * pointer). Doesn't reflect events that were
				 * synthesized in tkGrab.c. */
    TkGrabEvent *firstGrabEventPtr;
				/* First in list of enter/leave events
				 * synthesized by grab code. These events must
				 * be processed in order before any other
				 * events are processed. NULL means no such
				 * events. */
    TkGrabEvent *lastGrabEventPtr;
				/* Last in list of synthesized events, or NULL
				 * if list is empty. */
    int grabFlags;		/* Miscellaneous flag values. See definitions
				 * in tkGrab.c. */

    /*
     * Information used by tkGrid.c only:
     */

    int gridInit;		/* 0 means table below needs initializing. */
    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to corresponding
				 * Grid structures. */

    /*
     * Information used by tkImage.c only:
     */

    int imageId;		/* Value used to number image ids. */

    /*
     * Information used by tkMacWinMenu.c only:
     */

    int postCommandGeneration;

    /*
     * Information used by tkOption.c only.
     */

    /*
     * Information used by tkPack.c only.
     */

    int packInit;		/* 0 means table below needs initializing. */
    Tcl_HashTable packerHashTable;
				/* Maps from Tk_Window tokens to corresponding
				 * Packer structures. */

    /*
     * Information used by tkPlace.c only.
     */

    int placeInit;		/* 0 means tables below need initializing. */
    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
				 * structure for the window, if it exists. */
    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
				 * structure for the window, if it exists. */

    /*
     * Information used by tkSelect.c and tkClipboard.c only:
     */

    struct TkSelectionInfo *selectionInfoPtr;
				/* First in list of selection information
				 * records. Each entry contains information
				 * about the current owner of a particular
				 * selection on this display. */
    Atom multipleAtom;		/* Atom for MULTIPLE. None means selection
				 * stuff isn't initialized. */
    Atom incrAtom;		/* Atom for INCR. */
    Atom targetsAtom;		/* Atom for TARGETS. */
    Atom timestampAtom;		/* Atom for TIMESTAMP. */
    Atom textAtom;		/* Atom for TEXT. */
    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
    Atom windowAtom;		/* Atom for TK_WINDOW. */
    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
    Atom utf8Atom;		/* Atom for UTF8_STRING. */

    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
				 * retrieve selections between processes. NULL
				 * means clipboard info hasn't been
				 * initialized. */
    int clipboardActive;	/* 1 means we currently own the clipboard
				 * selection, 0 means we don't. */
    struct TkMainInfo *clipboardAppPtr;
				/* Last application that owned clipboard. */
    struct TkClipboardTarget *clipTargetPtr;
				/* First in list of clipboard type information
				 * records. Each entry contains information
				 * about the buffers for a given selection
				 * target. */

    /*
     * Information used by tkSend.c only:
     */

    Tk_Window commTkwin;	/* Window used for communication between
				 * interpreters during "send" commands. NULL
				 * means send info hasn't been initialized
				 * yet. */
    Atom commProperty;		/* X's name for comm property. */
    Atom registryProperty;	/* X's name for property containing registry
				 * of interpreter names. */
    Atom appNameProperty;	/* X's name for property used to hold the
				 * application name on each comm window. */

    /*
     * Information used by tkXId.c only:
     */

    struct TkIdStack *idStackPtr;
				/* First in list of chunks of free resource
				 * identifiers, or NULL if there are no free
				 * resources. */
    XID (*defaultAllocProc) (Display *display);
				/* Default resource allocator for display. */
    struct TkIdStack *windowStackPtr;
				/* First in list of chunks of window ids that
				 * can't be reused right now. */
    Tcl_TimerToken idCleanupScheduled;
				/* If set, it means a call to WindowIdCleanup
				 * has already been scheduled, 0 means it
				 * hasn't. */

    /*
     * Information used by tkUnixWm.c and tkWinWm.c only:
     */

    struct TkWmInfo *firstWmPtr;/* Points to first top-level window. */
    struct TkWmInfo *foregroundWmPtr;
				/* Points to the foreground window. */

    /*
     * Information maintained by tkWindow.c for use later on by tkXId.c:
     */

    int destroyCount;		/* Number of Tk_DestroyWindow operations in
				 * progress. */
    unsigned long lastDestroyRequest;
				/* Id of most recent XDestroyWindow request;
				 * can re-use ids in windowStackPtr when
				 * server has seen this request and event
				 * queue is empty. */

    /*
     * Information used by tkVisual.c only:
     */

    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
				 * allocated for this display. */

    /*
     * Miscellaneous information:
     */

#ifdef TK_USE_INPUT_METHODS
    XIM inputMethod;		/* Input method for this display. */
    XIMStyle inputStyle;	/* Input style selected for this display. */
    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
#endif /* TK_USE_INPUT_METHODS */
    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */

    int refCount;		/* Reference count of how many Tk applications
				 * are using this display. Used to clean up
				 * the display when we no longer have any Tk
				 * applications using it. */

    /*
     * The following field were all added for Tk8.3
     */

    int mouseButtonState;	/* Current mouse button state for this
				 * display. */
    Window mouseButtonWindow;	/* Window the button state was set in, added
				 * in Tk 8.4. */
    Window warpWindow;
    int warpX;
    int warpY;

    /*
     * The following field(s) were all added for Tk8.4
     */

    unsigned int flags;		/* Various flag values: these are all defined
				 * in below. */
    TkCaret caret;		/* Information about the caret for this
				 * display. This is not a pointer. */

    int iconDataSize;		/* Size of default iconphoto image data. */
    unsigned char *iconDataPtr;	/* Default iconphoto image data, if set. */
} TkDisplay;

/*
 * Flag values for TkDisplay flags.
 *  TK_DISPLAY_COLLAPSE_MOTION_EVENTS:	(default on)
 *	Indicates that we should collapse motion events on this display
 *  TK_DISPLAY_USE_IM:			(default on, set via tk.tcl)
 *	Whether to use input methods for this display
 *  TK_DISPLAY_WM_TRACING:		(default off)
 *	Whether we should do wm tracing on this display.
 *  TK_DISPLAY_IN_WARP:			(default off)
 *	Indicates that we are in a pointer warp
 */

#define TK_DISPLAY_COLLAPSE_MOTION_EVENTS	(1 << 0)
#define TK_DISPLAY_USE_IM			(1 << 1)
#define TK_DISPLAY_WM_TRACING			(1 << 3)
#define TK_DISPLAY_IN_WARP			(1 << 4)

/*
 * One of the following structures exists for each error handler created by a
 * call to Tk_CreateErrorHandler. The structure is managed by tkError.c.
 */

typedef struct TkErrorHandler {
    TkDisplay *dispPtr;		/* Display to which handler applies. */
    unsigned long firstRequest;	/* Only errors with serial numbers >= to this
				 * are considered. */
    unsigned long lastRequest;	/* Only errors with serial numbers <= to this
				 * are considered. This field is filled in
				 * when XUnhandle is called. -1 means
				 * XUnhandle hasn't been called yet. */
    int error;			/* Consider only errors with this error_code
				 * (-1 means consider all errors). */
    int request;		/* Consider only errors with this major
				 * request code (-1 means consider all major
				 * codes). */
    int minorCode;		/* Consider only errors with this minor
				 * request code (-1 means consider all minor
				 * codes). */
    Tk_ErrorProc *errorProc;	/* Function to invoke when a matching error
				 * occurs. NULL means just ignore errors. */
    ClientData clientData;	/* Arbitrary value to pass to errorProc. */
    struct TkErrorHandler *nextPtr;
				/* Pointer to next older handler for this
				 * display, or NULL for end of list. */
} TkErrorHandler;

/*
 * One of the following structures exists for each event handler created by
 * calling Tk_CreateEventHandler. This information is used by tkEvent.c only.
 */

typedef struct TkEventHandler {
    unsigned long mask;		/* Events for which to invoke proc. */
    Tk_EventProc *proc;		/* Function to invoke when an event in mask
				 * occurs. */
    ClientData clientData;	/* Argument to pass to proc. */
    struct TkEventHandler *nextPtr;
				/* Next in list of handlers associated with
				 * window (NULL means end of list). */
} TkEventHandler;

/*
 * Tk keeps one of the following data structures for each main window (created
 * by a call to TkCreateMainWindow). It stores information that is shared by
 * all of the windows associated with a particular main window.
 */

typedef struct TkMainInfo {
    int refCount;		/* Number of windows whose "mainPtr" fields
				 * point here. When this becomes zero, can
				 * free up the structure (the reference count
				 * is zero because windows can get deleted in
				 * almost any order; the main window isn't
				 * necessarily the last one deleted). */
    struct TkWindow *winPtr;	/* Pointer to main window. */
    Tcl_Interp *interp;		/* Interpreter associated with application. */
    Tcl_HashTable nameTable;	/* Hash table mapping path names to TkWindow
				 * structs for all windows related to this
				 * main window. Managed by tkWindow.c. */
    long deletionEpoch;		/* Incremented by window deletions. */
    Tk_BindingTable bindingTable;
				/* Used in conjunction with "bind" command to
				 * bind events to Tcl commands. */
    TkBindInfo bindInfo;	/* Information used by tkBind.c on a per
				 * application basis. */
    struct TkFontInfo *fontInfoPtr;
				/* Information used by tkFont.c on a per
				 * application basis. */

    /*
     * Information used only by tkFocus.c and tk*Embed.c:
     */

    struct TkToplevelFocusInfo *tlFocusPtr;
				/* First in list of records containing focus
				 * information for each top-level in the
				 * application. Used only by tkFocus.c. */
    struct TkDisplayFocusInfo *displayFocusPtr;
				/* First in list of records containing focus
				 * information for each display that this
				 * application has ever used. Used only by
				 * tkFocus.c. */

    struct ElArray *optionRootPtr;
				/* Top level of option hierarchy for this main
				 * window. NULL means uninitialized. Managed
				 * by tkOption.c. */
    Tcl_HashTable imageTable;	/* Maps from image names to Tk_ImageMaster
				 * structures. Managed by tkImage.c. */
    int strictMotif;		/* This is linked to the tk_strictMotif global
				 * variable. */
    int alwaysShowSelection;	/* This is linked to the
				 * ::tk::AlwaysShowSelection variable. */
    struct TkMainInfo *nextPtr;	/* Next in list of all main windows managed by
				 * this process. */
} TkMainInfo;

/*
 * Tk keeps the following data structure for each of it's builtin bitmaps.
 * This structure is only used by tkBitmap.c and other platform specific
 * bitmap files.
 */

typedef struct {
    const char *source;		/* Bits for bitmap. */
    int width, height;		/* Dimensions of bitmap. */
    int native;			/* 0 means generic (X style) bitmap, 1 means
    				 * native style bitmap. */
} TkPredefBitmap;

/*
 * Tk keeps one of the following structures for each window. Some of the
 * information (like size and location) is a shadow of information managed by
 * the X server, and some is special information used here, such as event and
 * geometry management information. This information is (mostly) managed by
 * tkWindow.c. WARNING: the declaration below must be kept consistent with the
 * Tk_FakeWin structure in tk.h. If you change one, be sure to change the
 * other!
 */

typedef struct TkWindow {
    /*
     * Structural information:
     */

    Display *display;		/* Display containing window. */
    TkDisplay *dispPtr;		/* Tk's information about display for
				 * window. */
    int screenNum;		/* Index of screen for window, among all those
				 * for dispPtr. */
    Visual *visual;		/* Visual to use for window. If not default,
				 * MUST be set before X window is created. */
    int depth;			/* Number of bits/pixel. */
    Window window;		/* X's id for window. NULL means window hasn't
				 * actually been created yet, or it's been
				 * deleted. */
    struct TkWindow *childList;	/* First in list of child windows, or NULL if
				 * no children. List is in stacking order,
				 * lowest window first.*/
    struct TkWindow *lastChildPtr;
				/* Last in list of child windows (highest in
				 * stacking order), or NULL if no children. */
    struct TkWindow *parentPtr;	/* Pointer to parent window (logical parent,
				 * not necessarily X parent). NULL means
				 * either this is the main window, or the
				 * window's parent has already been deleted. */
    struct TkWindow *nextPtr;	/* Next higher sibling (in stacking order) in
				 * list of children with same parent. NULL
				 * means end of list. */
    TkMainInfo *mainPtr;	/* Information shared by all windows
				 * associated with a particular main window.
				 * NULL means this window is a rogue that is
				 * not associated with any application (at
				 * present, this only happens for the dummy
				 * windows used for "send" communication). */

    /*
     * Name and type information for the window:
     */

    char *pathName;		/* Path name of window (concatenation of all
				 * names between this window and its top-level
				 * ancestor). This is a pointer into an entry
				 * in mainPtr->nameTable. NULL means that the
				 * window hasn't been completely created
				 * yet. */
    Tk_Uid nameUid;		/* Name of the window within its parent
				 * (unique within the parent). */
    Tk_Uid classUid;		/* Class of the window. NULL means window
				 * hasn't been given a class yet. */

    /*
     * Geometry and other attributes of window. This information may not be
     * updated on the server immediately; stuff that hasn't been reflected in
     * the server yet is called "dirty". At present, information can be dirty
     * only if the window hasn't yet been created.
     */

    XWindowChanges changes;	/* Geometry and other info about window. */
    unsigned int dirtyChanges;	/* Bits indicate fields of "changes" that are
				 * dirty. */
    XSetWindowAttributes atts;	/* Current attributes of window. */
    unsigned long dirtyAtts;	/* Bits indicate fields of "atts" that are
				 * dirty. */

    unsigned int flags;		/* Various flag values: these are all defined
				 * in tk.h (confusing, but they're needed
				 * there for some query macros). */

    /*
     * Information kept by the event manager (tkEvent.c):
     */

    TkEventHandler *handlerList;/* First in list of event handlers declared
				 * for this window, or NULL if none. */
#ifdef TK_USE_INPUT_METHODS
    XIC inputContext;		/* XIM input context. */
#endif /* TK_USE_INPUT_METHODS */

    /*
     * Information used for event bindings (see "bind" and "bindtags" commands
     * in tkCmds.c):
     */

    ClientData *tagPtr;		/* Points to array of tags used for bindings
				 * on this window. Each tag is a Tk_Uid.
				 * Malloc'ed. NULL means no tags. */
    int numTags;		/* Number of tags at *tagPtr. */

    /*
     * Information used by tkOption.c to manage options for the window.
     */

    int optionLevel;		/* -1 means no option information is currently
				 * cached for this window. Otherwise this
				 * gives the level in the option stack at
				 * which info is cached. */
    /*
     * Information used by tkSelect.c to manage the selection.
     */

    struct TkSelHandler *selHandlerList;
				/* First in list of handlers for returning the
				 * selection in various forms. */

    /*
     * Information used by tkGeometry.c for geometry management.
     */

    const Tk_GeomMgr *geomMgrPtr; /* Information about geometry manager for this
				 * window. */
    ClientData geomData;	/* Argument for geometry manager functions. */
    int reqWidth, reqHeight;	/* Arguments from last call to
				 * Tk_GeometryRequest, or 0's if
				 * Tk_GeometryRequest hasn't been called. */
    int internalBorderLeft;	/* Width of internal border of window (0 means
				 * no internal border). Geometry managers
				 * should not normally place children on top
				 * of the border. Fields for the other three
				 * sides are found below. */

    /*
     * Information maintained by tkWm.c for window manager communication.
     */

    struct TkWmInfo *wmInfoPtr;	/* For top-level windows (and also for special
				 * Unix menubar and wrapper windows), points
				 * to structure with wm-related info (see
				 * tkWm.c). For other windows, this is NULL. */

    /*
     * Information used by widget classes.
     */

    Tk_ClassProcs *classProcsPtr;
    ClientData instanceData;

    /*
     * Platform specific information private to each port.
     */

    struct TkWindowPrivate *privatePtr;

    /*
     * More information used by tkGeometry.c for geometry management.
     */

    /* The remaining fields of internal border. */
    int internalBorderRight;
    int internalBorderTop;
    int internalBorderBottom;

    int minReqWidth;		/* Minimum requested width. */
    int minReqHeight;		/* Minimum requested height. */
} TkWindow;

/*
 * Real definition of some events. Note that these events come from outside
 * but have internally generated pieces added to them.
 */

typedef struct {
    XKeyEvent keyEvent;		/* The real event from X11. */
    char *charValuePtr;		/* A pointer to a string that holds the key's
				 * %A substitution text (before backslash
				 * adding), or NULL if that has not been
				 * computed yet. If non-NULL, this string was
				 * allocated with ckalloc(). */
    int charValueLen;		/* Length of string in charValuePtr when that
				 * is non-NULL. */
} TkKeyEvent;

/*
 * The following structure is used as a two way map between integers and
 * strings, usually to map between an internal C representation and the
 * strings used in Tcl.
 */

typedef struct TkStateMap {
    int numKey;			/* Integer representation of a value. */
    const char *strKey;		/* String representation of a value. */
} TkStateMap;

/*
 * This structure is used by the Mac and Window porting layers as the internal
 * representation of a clip_mask in a GC.
 */

typedef struct TkpClipMask {
    int type;			/* TKP_CLIP_PIXMAP or TKP_CLIP_REGION. */
    union {
	Pixmap pixmap;
	TkRegion region;
    } value;
} TkpClipMask;

#define TKP_CLIP_PIXMAP 0
#define TKP_CLIP_REGION 1

/*
 * Pointer to first entry in list of all displays currently known.
 */

extern TkDisplay *tkDisplayList;

/*
 * Return values from TkGrabState:
 */

#define TK_GRAB_NONE		0
#define TK_GRAB_IN_TREE		1
#define TK_GRAB_ANCESTOR	2
#define TK_GRAB_EXCLUDED	3

/*
 * Additional flag for TkpMeasureCharsInContext. Coordinate with other flags
 * for this routine, but don't make public until TkpMeasureCharsInContext is
 * made public, too.
 */

#define TK_ISOLATE_END		32

/*
 * The macro below is used to modify a "char" value (e.g. by casting it to an
 * unsigned character) so that it can be used safely with macros such as
 * isspace().
 */

#define UCHAR(c) ((unsigned char) (c))

/*
 * The following symbol is used in the mode field of FocusIn events generated
 * by an embedded application to request the input focus from its container.
 */

#define EMBEDDED_APP_WANTS_FOCUS (NotifyNormal + 20)

/*
 * The following special modifier mask bits are defined, to indicate logical
 * modifiers such as Meta and Alt that may float among the actual modifier
 * bits.
 */

#define META_MASK	(AnyModifier<<1)
#define ALT_MASK	(AnyModifier<<2)
#define EXTENDED_MASK	(AnyModifier<<3)

/*
 * Object types not declared in tkObj.c need to be mentioned here so they can
 * be properly registered with Tcl:
 */

MODULE_SCOPE Tcl_ObjType tkBorderObjType;
MODULE_SCOPE Tcl_ObjType tkBitmapObjType;
MODULE_SCOPE Tcl_ObjType tkColorObjType;
MODULE_SCOPE Tcl_ObjType tkCursorObjType;
MODULE_SCOPE Tcl_ObjType tkFontObjType;
MODULE_SCOPE Tcl_ObjType tkOptionObjType;
MODULE_SCOPE Tcl_ObjType tkStateKeyObjType;
MODULE_SCOPE Tcl_ObjType tkTextIndexType;

/*
 * Miscellaneous variables shared among Tk modules but not exported to the
 * outside world:
 */

MODULE_SCOPE Tk_SmoothMethod	tkBezierSmoothMethod;
MODULE_SCOPE Tk_ImageType	tkBitmapImageType;
MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtGIF;
MODULE_SCOPE void		(*tkHandleEventProc) (XEvent* eventPtr);
MODULE_SCOPE Tk_PhotoImageFormat tkImgFmtPPM;
MODULE_SCOPE TkMainInfo		*tkMainWindowList;
MODULE_SCOPE Tk_ImageType	tkPhotoImageType;
MODULE_SCOPE Tcl_HashTable	tkPredefBitmapTable;

#include "tkIntDecls.h"

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * Themed widget set init function:
 */

MODULE_SCOPE int	Ttk_Init(Tcl_Interp *interp);

/*
 * Internal functions shared among Tk modules but not exported to the outside
 * world:
 */

MODULE_SCOPE int	Tk_BellObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_BindObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_BindtagsObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ButtonObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_CanvasObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int argc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_CheckbuttonObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ClipboardObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ChooseColorObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ChooseDirectoryObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ChooseFontObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_DestroyObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_EntryObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_EventObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_FrameObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_FocusObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_FontObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_GetOpenFileObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_GetSaveFileObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_GrabObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_GridObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ImageObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_LabelObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_LabelframeObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ListboxObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_LowerObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_MenubuttonObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_MessageBoxObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_MessageObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_PanedWindowObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_OptionObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_PackObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_PlaceObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_RadiobuttonObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_RaiseObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ScaleObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ScrollbarCmd(ClientData clientData,
			    Tcl_Interp *interp, int argc, const char **argv);
MODULE_SCOPE int	Tk_SelectionObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_SendCmd(ClientData clientData,
			    Tcl_Interp *interp, int argc, const char **argv);
MODULE_SCOPE int	Tk_SendObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_SpinboxObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_TextObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_TkObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_TkwaitObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_ToplevelObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_UpdateObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_WinfoObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);
MODULE_SCOPE int	Tk_WmObjCmd(ClientData clientData, Tcl_Interp *interp,
			    int objc, Tcl_Obj *const objv[]);

MODULE_SCOPE int	Tk_GetDoublePixelsFromObj(Tcl_Interp *interp,
			    Tk_Window tkwin, Tcl_Obj *objPtr,
			    double *doublePtr);

MODULE_SCOPE void	TkEventInit(void);
MODULE_SCOPE void	TkRegisterObjTypes(void);
MODULE_SCOPE int	TkCreateMenuCmd(Tcl_Interp *interp);
MODULE_SCOPE int	TkDeadAppCmd(ClientData clientData,
			    Tcl_Interp *interp, int argc, const char **argv);
MODULE_SCOPE int	TkCanvasGetCoordObj(Tcl_Interp *interp,
			    Tk_Canvas canvas, Tcl_Obj *obj,
			    double *doublePtr);
MODULE_SCOPE int	TkGetDoublePixels(Tcl_Interp *interp, Tk_Window tkwin,
			    const char *string, double *doublePtr);
MODULE_SCOPE int	TkPostscriptImage(Tcl_Interp *interp, Tk_Window tkwin,
			    Tk_PostscriptInfo psInfo, XImage *ximage,
			    int x, int y, int width, int height);
MODULE_SCOPE void       TkMapTopFrame(Tk_Window tkwin);
MODULE_SCOPE XEvent *	TkpGetBindingXEvent(Tcl_Interp *interp);
MODULE_SCOPE void	TkCreateExitHandler(Tcl_ExitProc *proc,
			    ClientData clientData);
MODULE_SCOPE void	TkDeleteExitHandler(Tcl_ExitProc *proc,
			    ClientData clientData);
MODULE_SCOPE Tcl_ExitProc	TkFinalize;
MODULE_SCOPE Tcl_ExitProc	TkFinalizeThread;
MODULE_SCOPE void	TkpBuildRegionFromAlphaData(TkRegion region,
			    unsigned x, unsigned y, unsigned width,
			    unsigned height, unsigned char *dataPtr,
			    unsigned pixelStride, unsigned lineStride);
MODULE_SCOPE void	TkPrintPadAmount(Tcl_Interp *interp,
			    char *buffer, int pad1, int pad2);
MODULE_SCOPE int	TkParsePadAmount(Tcl_Interp *interp,
			    Tk_Window tkwin, Tcl_Obj *objPtr,
			    int *pad1Ptr, int *pad2Ptr);
MODULE_SCOPE void       TkFocusSplit(TkWindow *winPtr);
MODULE_SCOPE void       TkFocusJoin(TkWindow *winPtr);
MODULE_SCOPE int	TkpAlwaysShowSelection(Tk_Window tkwin);
MODULE_SCOPE void	TkpDrawCharsInContext(Display * display,
			    Drawable drawable, GC gc, Tk_Font tkfont,
			    const char *source, int numBytes, int rangeStart,
			    int rangeLength, int x, int y);
MODULE_SCOPE int	TkpMeasureCharsInContext(Tk_Font tkfont,
			    const char *source, int numBytes, int rangeStart,
			    int rangeLength, int maxLength, int flags,
			    int *lengthPtr);
MODULE_SCOPE void	TkUnderlineCharsInContext(Display *display,
			    Drawable drawable, GC gc, Tk_Font tkfont,
			    const char *string, int numBytes, int x, int y,
			    int firstByte, int lastByte);
MODULE_SCOPE void	TkpGetFontAttrsForChar(Tk_Window tkwin, Tk_Font tkfont,
			    Tcl_UniChar c, struct TkFontAttributes *faPtr);
MODULE_SCOPE int	TkBackgroundEvalObjv(Tcl_Interp *interp,
			    int objc, Tcl_Obj *const *objv, int flags);

/*
 * Unsupported commands.
 */

MODULE_SCOPE int	TkUnsupported1ObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *const objv[]);

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINT */

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
                                                                                                                                                                                                                        tkIntDecls.h                                                                                        0100644 0001750 0001750 00000205340 11442001432 034622  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkIntDecls.h --
 *
 *	This file contains the declarations for all unsupported
 *	functions that are exported by the Tk library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKINTDECLS
#define _TKINTDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tkInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifndef TkAllocWindow_TCL_DECLARED
#define TkAllocWindow_TCL_DECLARED
/* 0 */
EXTERN TkWindow *	TkAllocWindow(TkDisplay *dispPtr, int screenNum,
				TkWindow *parentPtr);
#endif
#ifndef TkBezierPoints_TCL_DECLARED
#define TkBezierPoints_TCL_DECLARED
/* 1 */
EXTERN void		TkBezierPoints(double control[], int numSteps,
				double *coordPtr);
#endif
#ifndef TkBezierScreenPoints_TCL_DECLARED
#define TkBezierScreenPoints_TCL_DECLARED
/* 2 */
EXTERN void		TkBezierScreenPoints(Tk_Canvas canvas,
				double control[], int numSteps,
				XPoint *xPointPtr);
#endif
#ifndef TkBindDeadWindow_TCL_DECLARED
#define TkBindDeadWindow_TCL_DECLARED
/* 3 */
EXTERN void		TkBindDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkBindEventProc_TCL_DECLARED
#define TkBindEventProc_TCL_DECLARED
/* 4 */
EXTERN void		TkBindEventProc(TkWindow *winPtr, XEvent *eventPtr);
#endif
#ifndef TkBindFree_TCL_DECLARED
#define TkBindFree_TCL_DECLARED
/* 5 */
EXTERN void		TkBindFree(TkMainInfo *mainPtr);
#endif
#ifndef TkBindInit_TCL_DECLARED
#define TkBindInit_TCL_DECLARED
/* 6 */
EXTERN void		TkBindInit(TkMainInfo *mainPtr);
#endif
#ifndef TkChangeEventWindow_TCL_DECLARED
#define TkChangeEventWindow_TCL_DECLARED
/* 7 */
EXTERN void		TkChangeEventWindow(XEvent *eventPtr,
				TkWindow *winPtr);
#endif
#ifndef TkClipInit_TCL_DECLARED
#define TkClipInit_TCL_DECLARED
/* 8 */
EXTERN int		TkClipInit(Tcl_Interp *interp, TkDisplay *dispPtr);
#endif
#ifndef TkComputeAnchor_TCL_DECLARED
#define TkComputeAnchor_TCL_DECLARED
/* 9 */
EXTERN void		TkComputeAnchor(Tk_Anchor anchor, Tk_Window tkwin,
				int padX, int padY, int innerWidth,
				int innerHeight, int *xPtr, int *yPtr);
#endif
#ifndef TkCopyAndGlobalEval_TCL_DECLARED
#define TkCopyAndGlobalEval_TCL_DECLARED
/* 10 */
EXTERN int		TkCopyAndGlobalEval(Tcl_Interp *interp, char *script);
#endif
#ifndef TkCreateBindingProcedure_TCL_DECLARED
#define TkCreateBindingProcedure_TCL_DECLARED
/* 11 */
EXTERN unsigned long	TkCreateBindingProcedure(Tcl_Interp *interp,
				Tk_BindingTable bindingTable,
				ClientData object, CONST char *eventString,
				TkBindEvalProc *evalProc,
				TkBindFreeProc *freeProc,
				ClientData clientData);
#endif
#ifndef TkCreateCursorFromData_TCL_DECLARED
#define TkCreateCursorFromData_TCL_DECLARED
/* 12 */
EXTERN TkCursor *	TkCreateCursorFromData(Tk_Window tkwin,
				CONST char *source, CONST char *mask,
				int width, int height, int xHot, int yHot,
				XColor fg, XColor bg);
#endif
#ifndef TkCreateFrame_TCL_DECLARED
#define TkCreateFrame_TCL_DECLARED
/* 13 */
EXTERN int		TkCreateFrame(ClientData clientData,
				Tcl_Interp *interp, int argc, char **argv,
				int toplevel, char *appName);
#endif
#ifndef TkCreateMainWindow_TCL_DECLARED
#define TkCreateMainWindow_TCL_DECLARED
/* 14 */
EXTERN Tk_Window	TkCreateMainWindow(Tcl_Interp *interp,
				CONST char *screenName, char *baseName);
#endif
#ifndef TkCurrentTime_TCL_DECLARED
#define TkCurrentTime_TCL_DECLARED
/* 15 */
EXTERN Time		TkCurrentTime(TkDisplay *dispPtr);
#endif
#ifndef TkDeleteAllImages_TCL_DECLARED
#define TkDeleteAllImages_TCL_DECLARED
/* 16 */
EXTERN void		TkDeleteAllImages(TkMainInfo *mainPtr);
#endif
#ifndef TkDoConfigureNotify_TCL_DECLARED
#define TkDoConfigureNotify_TCL_DECLARED
/* 17 */
EXTERN void		TkDoConfigureNotify(TkWindow *winPtr);
#endif
#ifndef TkDrawInsetFocusHighlight_TCL_DECLARED
#define TkDrawInsetFocusHighlight_TCL_DECLARED
/* 18 */
EXTERN void		TkDrawInsetFocusHighlight(Tk_Window tkwin, GC gc,
				int width, Drawable drawable, int padding);
#endif
#ifndef TkEventDeadWindow_TCL_DECLARED
#define TkEventDeadWindow_TCL_DECLARED
/* 19 */
EXTERN void		TkEventDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkFillPolygon_TCL_DECLARED
#define TkFillPolygon_TCL_DECLARED
/* 20 */
EXTERN void		TkFillPolygon(Tk_Canvas canvas, double *coordPtr,
				int numPoints, Display *display,
				Drawable drawable, GC gc, GC outlineGC);
#endif
#ifndef TkFindStateNum_TCL_DECLARED
#define TkFindStateNum_TCL_DECLARED
/* 21 */
EXTERN int		TkFindStateNum(Tcl_Interp *interp,
				CONST char *option, CONST TkStateMap *mapPtr,
				CONST char *strKey);
#endif
#ifndef TkFindStateString_TCL_DECLARED
#define TkFindStateString_TCL_DECLARED
/* 22 */
EXTERN char *		TkFindStateString(CONST TkStateMap *mapPtr,
				int numKey);
#endif
#ifndef TkFocusDeadWindow_TCL_DECLARED
#define TkFocusDeadWindow_TCL_DECLARED
/* 23 */
EXTERN void		TkFocusDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkFocusFilterEvent_TCL_DECLARED
#define TkFocusFilterEvent_TCL_DECLARED
/* 24 */
EXTERN int		TkFocusFilterEvent(TkWindow *winPtr,
				XEvent *eventPtr);
#endif
#ifndef TkFocusKeyEvent_TCL_DECLARED
#define TkFocusKeyEvent_TCL_DECLARED
/* 25 */
EXTERN TkWindow *	TkFocusKeyEvent(TkWindow *winPtr, XEvent *eventPtr);
#endif
#ifndef TkFontPkgInit_TCL_DECLARED
#define TkFontPkgInit_TCL_DECLARED
/* 26 */
EXTERN void		TkFontPkgInit(TkMainInfo *mainPtr);
#endif
#ifndef TkFontPkgFree_TCL_DECLARED
#define TkFontPkgFree_TCL_DECLARED
/* 27 */
EXTERN void		TkFontPkgFree(TkMainInfo *mainPtr);
#endif
#ifndef TkFreeBindingTags_TCL_DECLARED
#define TkFreeBindingTags_TCL_DECLARED
/* 28 */
EXTERN void		TkFreeBindingTags(TkWindow *winPtr);
#endif
#ifndef TkpFreeCursor_TCL_DECLARED
#define TkpFreeCursor_TCL_DECLARED
/* 29 */
EXTERN void		TkpFreeCursor(TkCursor *cursorPtr);
#endif
#ifndef TkGetBitmapData_TCL_DECLARED
#define TkGetBitmapData_TCL_DECLARED
/* 30 */
EXTERN char *		TkGetBitmapData(Tcl_Interp *interp, char *string,
				char *fileName, int *widthPtr,
				int *heightPtr, int *hotXPtr, int *hotYPtr);
#endif
#ifndef TkGetButtPoints_TCL_DECLARED
#define TkGetButtPoints_TCL_DECLARED
/* 31 */
EXTERN void		TkGetButtPoints(double p1[], double p2[],
				double width, int project, double m1[],
				double m2[]);
#endif
#ifndef TkGetCursorByName_TCL_DECLARED
#define TkGetCursorByName_TCL_DECLARED
/* 32 */
EXTERN TkCursor *	TkGetCursorByName(Tcl_Interp *interp,
				Tk_Window tkwin, Tk_Uid string);
#endif
#ifndef TkGetDefaultScreenName_TCL_DECLARED
#define TkGetDefaultScreenName_TCL_DECLARED
/* 33 */
EXTERN CONST84_RETURN char * TkGetDefaultScreenName(Tcl_Interp *interp,
				CONST char *screenName);
#endif
#ifndef TkGetDisplay_TCL_DECLARED
#define TkGetDisplay_TCL_DECLARED
/* 34 */
EXTERN TkDisplay *	TkGetDisplay(Display *display);
#endif
#ifndef TkGetDisplayOf_TCL_DECLARED
#define TkGetDisplayOf_TCL_DECLARED
/* 35 */
EXTERN int		TkGetDisplayOf(Tcl_Interp *interp, int objc,
				Tcl_Obj *CONST objv[], Tk_Window *tkwinPtr);
#endif
#ifndef TkGetFocusWin_TCL_DECLARED
#define TkGetFocusWin_TCL_DECLARED
/* 36 */
EXTERN TkWindow *	TkGetFocusWin(TkWindow *winPtr);
#endif
#ifndef TkGetInterpNames_TCL_DECLARED
#define TkGetInterpNames_TCL_DECLARED
/* 37 */
EXTERN int		TkGetInterpNames(Tcl_Interp *interp, Tk_Window tkwin);
#endif
#ifndef TkGetMiterPoints_TCL_DECLARED
#define TkGetMiterPoints_TCL_DECLARED
/* 38 */
EXTERN int		TkGetMiterPoints(double p1[], double p2[],
				double p3[], double width, double m1[],
				double m2[]);
#endif
#ifndef TkGetPointerCoords_TCL_DECLARED
#define TkGetPointerCoords_TCL_DECLARED
/* 39 */
EXTERN void		TkGetPointerCoords(Tk_Window tkwin, int *xPtr,
				int *yPtr);
#endif
#ifndef TkGetServerInfo_TCL_DECLARED
#define TkGetServerInfo_TCL_DECLARED
/* 40 */
EXTERN void		TkGetServerInfo(Tcl_Interp *interp, Tk_Window tkwin);
#endif
#ifndef TkGrabDeadWindow_TCL_DECLARED
#define TkGrabDeadWindow_TCL_DECLARED
/* 41 */
EXTERN void		TkGrabDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkGrabState_TCL_DECLARED
#define TkGrabState_TCL_DECLARED
/* 42 */
EXTERN int		TkGrabState(TkWindow *winPtr);
#endif
#ifndef TkIncludePoint_TCL_DECLARED
#define TkIncludePoint_TCL_DECLARED
/* 43 */
EXTERN void		TkIncludePoint(Tk_Item *itemPtr, double *pointPtr);
#endif
#ifndef TkInOutEvents_TCL_DECLARED
#define TkInOutEvents_TCL_DECLARED
/* 44 */
EXTERN void		TkInOutEvents(XEvent *eventPtr, TkWindow *sourcePtr,
				TkWindow *destPtr, int leaveType,
				int enterType, Tcl_QueuePosition position);
#endif
#ifndef TkInstallFrameMenu_TCL_DECLARED
#define TkInstallFrameMenu_TCL_DECLARED
/* 45 */
EXTERN void		TkInstallFrameMenu(Tk_Window tkwin);
#endif
#ifndef TkKeysymToString_TCL_DECLARED
#define TkKeysymToString_TCL_DECLARED
/* 46 */
EXTERN char *		TkKeysymToString(KeySym keysym);
#endif
#ifndef TkLineToArea_TCL_DECLARED
#define TkLineToArea_TCL_DECLARED
/* 47 */
EXTERN int		TkLineToArea(double end1Ptr[], double end2Ptr[],
				double rectPtr[]);
#endif
#ifndef TkLineToPoint_TCL_DECLARED
#define TkLineToPoint_TCL_DECLARED
/* 48 */
EXTERN double		TkLineToPoint(double end1Ptr[], double end2Ptr[],
				double pointPtr[]);
#endif
#ifndef TkMakeBezierCurve_TCL_DECLARED
#define TkMakeBezierCurve_TCL_DECLARED
/* 49 */
EXTERN int		TkMakeBezierCurve(Tk_Canvas canvas, double *pointPtr,
				int numPoints, int numSteps,
				XPoint xPoints[], double dblPoints[]);
#endif
#ifndef TkMakeBezierPostscript_TCL_DECLARED
#define TkMakeBezierPostscript_TCL_DECLARED
/* 50 */
EXTERN void		TkMakeBezierPostscript(Tcl_Interp *interp,
				Tk_Canvas canvas, double *pointPtr,
				int numPoints);
#endif
#ifndef TkOptionClassChanged_TCL_DECLARED
#define TkOptionClassChanged_TCL_DECLARED
/* 51 */
EXTERN void		TkOptionClassChanged(TkWindow *winPtr);
#endif
#ifndef TkOptionDeadWindow_TCL_DECLARED
#define TkOptionDeadWindow_TCL_DECLARED
/* 52 */
EXTERN void		TkOptionDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkOvalToArea_TCL_DECLARED
#define TkOvalToArea_TCL_DECLARED
/* 53 */
EXTERN int		TkOvalToArea(double *ovalPtr, double *rectPtr);
#endif
#ifndef TkOvalToPoint_TCL_DECLARED
#define TkOvalToPoint_TCL_DECLARED
/* 54 */
EXTERN double		TkOvalToPoint(double ovalPtr[], double width,
				int filled, double pointPtr[]);
#endif
#ifndef TkpChangeFocus_TCL_DECLARED
#define TkpChangeFocus_TCL_DECLARED
/* 55 */
EXTERN int		TkpChangeFocus(TkWindow *winPtr, int force);
#endif
#ifndef TkpCloseDisplay_TCL_DECLARED
#define TkpCloseDisplay_TCL_DECLARED
/* 56 */
EXTERN void		TkpCloseDisplay(TkDisplay *dispPtr);
#endif
#ifndef TkpClaimFocus_TCL_DECLARED
#define TkpClaimFocus_TCL_DECLARED
/* 57 */
EXTERN void		TkpClaimFocus(TkWindow *topLevelPtr, int force);
#endif
#ifndef TkpDisplayWarning_TCL_DECLARED
#define TkpDisplayWarning_TCL_DECLARED
/* 58 */
EXTERN void		TkpDisplayWarning(CONST char *msg, CONST char *title);
#endif
#ifndef TkpGetAppName_TCL_DECLARED
#define TkpGetAppName_TCL_DECLARED
/* 59 */
EXTERN void		TkpGetAppName(Tcl_Interp *interp, Tcl_DString *name);
#endif
#ifndef TkpGetOtherWindow_TCL_DECLARED
#define TkpGetOtherWindow_TCL_DECLARED
/* 60 */
EXTERN TkWindow *	TkpGetOtherWindow(TkWindow *winPtr);
#endif
#ifndef TkpGetWrapperWindow_TCL_DECLARED
#define TkpGetWrapperWindow_TCL_DECLARED
/* 61 */
EXTERN TkWindow *	TkpGetWrapperWindow(TkWindow *winPtr);
#endif
#ifndef TkpInit_TCL_DECLARED
#define TkpInit_TCL_DECLARED
/* 62 */
EXTERN int		TkpInit(Tcl_Interp *interp);
#endif
#ifndef TkpInitializeMenuBindings_TCL_DECLARED
#define TkpInitializeMenuBindings_TCL_DECLARED
/* 63 */
EXTERN void		TkpInitializeMenuBindings(Tcl_Interp *interp,
				Tk_BindingTable bindingTable);
#endif
#ifndef TkpMakeContainer_TCL_DECLARED
#define TkpMakeContainer_TCL_DECLARED
/* 64 */
EXTERN void		TkpMakeContainer(Tk_Window tkwin);
#endif
#ifndef TkpMakeMenuWindow_TCL_DECLARED
#define TkpMakeMenuWindow_TCL_DECLARED
/* 65 */
EXTERN void		TkpMakeMenuWindow(Tk_Window tkwin, int transient);
#endif
#ifndef TkpMakeWindow_TCL_DECLARED
#define TkpMakeWindow_TCL_DECLARED
/* 66 */
EXTERN Window		TkpMakeWindow(TkWindow *winPtr, Window parent);
#endif
#ifndef TkpMenuNotifyToplevelCreate_TCL_DECLARED
#define TkpMenuNotifyToplevelCreate_TCL_DECLARED
/* 67 */
EXTERN void		TkpMenuNotifyToplevelCreate(Tcl_Interp *interp1,
				char *menuName);
#endif
#ifndef TkpOpenDisplay_TCL_DECLARED
#define TkpOpenDisplay_TCL_DECLARED
/* 68 */
EXTERN TkDisplay *	TkpOpenDisplay(CONST char *display_name);
#endif
#ifndef TkPointerEvent_TCL_DECLARED
#define TkPointerEvent_TCL_DECLARED
/* 69 */
EXTERN int		TkPointerEvent(XEvent *eventPtr, TkWindow *winPtr);
#endif
#ifndef TkPolygonToArea_TCL_DECLARED
#define TkPolygonToArea_TCL_DECLARED
/* 70 */
EXTERN int		TkPolygonToArea(double *polyPtr, int numPoints,
				double *rectPtr);
#endif
#ifndef TkPolygonToPoint_TCL_DECLARED
#define TkPolygonToPoint_TCL_DECLARED
/* 71 */
EXTERN double		TkPolygonToPoint(double *polyPtr, int numPoints,
				double *pointPtr);
#endif
#ifndef TkPositionInTree_TCL_DECLARED
#define TkPositionInTree_TCL_DECLARED
/* 72 */
EXTERN int		TkPositionInTree(TkWindow *winPtr, TkWindow *treePtr);
#endif
#ifndef TkpRedirectKeyEvent_TCL_DECLARED
#define TkpRedirectKeyEvent_TCL_DECLARED
/* 73 */
EXTERN void		TkpRedirectKeyEvent(TkWindow *winPtr,
				XEvent *eventPtr);
#endif
#ifndef TkpSetMainMenubar_TCL_DECLARED
#define TkpSetMainMenubar_TCL_DECLARED
/* 74 */
EXTERN void		TkpSetMainMenubar(Tcl_Interp *interp,
				Tk_Window tkwin, char *menuName);
#endif
#ifndef TkpUseWindow_TCL_DECLARED
#define TkpUseWindow_TCL_DECLARED
/* 75 */
EXTERN int		TkpUseWindow(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *string);
#endif
#ifndef TkpWindowWasRecentlyDeleted_TCL_DECLARED
#define TkpWindowWasRecentlyDeleted_TCL_DECLARED
/* 76 */
EXTERN int		TkpWindowWasRecentlyDeleted(Window win,
				TkDisplay *dispPtr);
#endif
#ifndef TkQueueEventForAllChildren_TCL_DECLARED
#define TkQueueEventForAllChildren_TCL_DECLARED
/* 77 */
EXTERN void		TkQueueEventForAllChildren(TkWindow *winPtr,
				XEvent *eventPtr);
#endif
#ifndef TkReadBitmapFile_TCL_DECLARED
#define TkReadBitmapFile_TCL_DECLARED
/* 78 */
EXTERN int		TkReadBitmapFile(Display *display, Drawable d,
				CONST char *filename,
				unsigned int *width_return,
				unsigned int *height_return,
				Pixmap *bitmap_return, int *x_hot_return,
				int *y_hot_return);
#endif
#ifndef TkScrollWindow_TCL_DECLARED
#define TkScrollWindow_TCL_DECLARED
/* 79 */
EXTERN int		TkScrollWindow(Tk_Window tkwin, GC gc, int x, int y,
				int width, int height, int dx, int dy,
				TkRegion damageRgn);
#endif
#ifndef TkSelDeadWindow_TCL_DECLARED
#define TkSelDeadWindow_TCL_DECLARED
/* 80 */
EXTERN void		TkSelDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkSelEventProc_TCL_DECLARED
#define TkSelEventProc_TCL_DECLARED
/* 81 */
EXTERN void		TkSelEventProc(Tk_Window tkwin, XEvent *eventPtr);
#endif
#ifndef TkSelInit_TCL_DECLARED
#define TkSelInit_TCL_DECLARED
/* 82 */
EXTERN void		TkSelInit(Tk_Window tkwin);
#endif
#ifndef TkSelPropProc_TCL_DECLARED
#define TkSelPropProc_TCL_DECLARED
/* 83 */
EXTERN void		TkSelPropProc(XEvent *eventPtr);
#endif
/* Slot 84 is reserved */
#ifndef TkSetWindowMenuBar_TCL_DECLARED
#define TkSetWindowMenuBar_TCL_DECLARED
/* 85 */
EXTERN void		TkSetWindowMenuBar(Tcl_Interp *interp,
				Tk_Window tkwin, char *oldMenuName,
				char *menuName);
#endif
#ifndef TkStringToKeysym_TCL_DECLARED
#define TkStringToKeysym_TCL_DECLARED
/* 86 */
EXTERN KeySym		TkStringToKeysym(char *name);
#endif
#ifndef TkThickPolyLineToArea_TCL_DECLARED
#define TkThickPolyLineToArea_TCL_DECLARED
/* 87 */
EXTERN int		TkThickPolyLineToArea(double *coordPtr,
				int numPoints, double width, int capStyle,
				int joinStyle, double *rectPtr);
#endif
#ifndef TkWmAddToColormapWindows_TCL_DECLARED
#define TkWmAddToColormapWindows_TCL_DECLARED
/* 88 */
EXTERN void		TkWmAddToColormapWindows(TkWindow *winPtr);
#endif
#ifndef TkWmDeadWindow_TCL_DECLARED
#define TkWmDeadWindow_TCL_DECLARED
/* 89 */
EXTERN void		TkWmDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkWmFocusToplevel_TCL_DECLARED
#define TkWmFocusToplevel_TCL_DECLARED
/* 90 */
EXTERN TkWindow *	TkWmFocusToplevel(TkWindow *winPtr);
#endif
#ifndef TkWmMapWindow_TCL_DECLARED
#define TkWmMapWindow_TCL_DECLARED
/* 91 */
EXTERN void		TkWmMapWindow(TkWindow *winPtr);
#endif
#ifndef TkWmNewWindow_TCL_DECLARED
#define TkWmNewWindow_TCL_DECLARED
/* 92 */
EXTERN void		TkWmNewWindow(TkWindow *winPtr);
#endif
#ifndef TkWmProtocolEventProc_TCL_DECLARED
#define TkWmProtocolEventProc_TCL_DECLARED
/* 93 */
EXTERN void		TkWmProtocolEventProc(TkWindow *winPtr,
				XEvent *evenvPtr);
#endif
#ifndef TkWmRemoveFromColormapWindows_TCL_DECLARED
#define TkWmRemoveFromColormapWindows_TCL_DECLARED
/* 94 */
EXTERN void		TkWmRemoveFromColormapWindows(TkWindow *winPtr);
#endif
#ifndef TkWmRestackToplevel_TCL_DECLARED
#define TkWmRestackToplevel_TCL_DECLARED
/* 95 */
EXTERN void		TkWmRestackToplevel(TkWindow *winPtr, int aboveBelow,
				TkWindow *otherPtr);
#endif
#ifndef TkWmSetClass_TCL_DECLARED
#define TkWmSetClass_TCL_DECLARED
/* 96 */
EXTERN void		TkWmSetClass(TkWindow *winPtr);
#endif
#ifndef TkWmUnmapWindow_TCL_DECLARED
#define TkWmUnmapWindow_TCL_DECLARED
/* 97 */
EXTERN void		TkWmUnmapWindow(TkWindow *winPtr);
#endif
#ifndef TkDebugBitmap_TCL_DECLARED
#define TkDebugBitmap_TCL_DECLARED
/* 98 */
EXTERN Tcl_Obj *	TkDebugBitmap(Tk_Window tkwin, char *name);
#endif
#ifndef TkDebugBorder_TCL_DECLARED
#define TkDebugBorder_TCL_DECLARED
/* 99 */
EXTERN Tcl_Obj *	TkDebugBorder(Tk_Window tkwin, char *name);
#endif
#ifndef TkDebugCursor_TCL_DECLARED
#define TkDebugCursor_TCL_DECLARED
/* 100 */
EXTERN Tcl_Obj *	TkDebugCursor(Tk_Window tkwin, char *name);
#endif
#ifndef TkDebugColor_TCL_DECLARED
#define TkDebugColor_TCL_DECLARED
/* 101 */
EXTERN Tcl_Obj *	TkDebugColor(Tk_Window tkwin, char *name);
#endif
#ifndef TkDebugConfig_TCL_DECLARED
#define TkDebugConfig_TCL_DECLARED
/* 102 */
EXTERN Tcl_Obj *	TkDebugConfig(Tcl_Interp *interp,
				Tk_OptionTable table);
#endif
#ifndef TkDebugFont_TCL_DECLARED
#define TkDebugFont_TCL_DECLARED
/* 103 */
EXTERN Tcl_Obj *	TkDebugFont(Tk_Window tkwin, char *name);
#endif
#ifndef TkFindStateNumObj_TCL_DECLARED
#define TkFindStateNumObj_TCL_DECLARED
/* 104 */
EXTERN int		TkFindStateNumObj(Tcl_Interp *interp,
				Tcl_Obj *optionPtr, CONST TkStateMap *mapPtr,
				Tcl_Obj *keyPtr);
#endif
#ifndef TkGetBitmapPredefTable_TCL_DECLARED
#define TkGetBitmapPredefTable_TCL_DECLARED
/* 105 */
EXTERN Tcl_HashTable *	TkGetBitmapPredefTable(void);
#endif
#ifndef TkGetDisplayList_TCL_DECLARED
#define TkGetDisplayList_TCL_DECLARED
/* 106 */
EXTERN TkDisplay *	TkGetDisplayList(void);
#endif
#ifndef TkGetMainInfoList_TCL_DECLARED
#define TkGetMainInfoList_TCL_DECLARED
/* 107 */
EXTERN TkMainInfo *	TkGetMainInfoList(void);
#endif
#ifndef TkGetWindowFromObj_TCL_DECLARED
#define TkGetWindowFromObj_TCL_DECLARED
/* 108 */
EXTERN int		TkGetWindowFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr,
				Tk_Window *windowPtr);
#endif
#ifndef TkpGetString_TCL_DECLARED
#define TkpGetString_TCL_DECLARED
/* 109 */
EXTERN char *		TkpGetString(TkWindow *winPtr, XEvent *eventPtr,
				Tcl_DString *dsPtr);
#endif
#ifndef TkpGetSubFonts_TCL_DECLARED
#define TkpGetSubFonts_TCL_DECLARED
/* 110 */
EXTERN void		TkpGetSubFonts(Tcl_Interp *interp, Tk_Font tkfont);
#endif
#ifndef TkpGetSystemDefault_TCL_DECLARED
#define TkpGetSystemDefault_TCL_DECLARED
/* 111 */
EXTERN Tcl_Obj *	TkpGetSystemDefault(Tk_Window tkwin,
				CONST char *dbName, CONST char *className);
#endif
#ifndef TkpMenuThreadInit_TCL_DECLARED
#define TkpMenuThreadInit_TCL_DECLARED
/* 112 */
EXTERN void		TkpMenuThreadInit(void);
#endif
#ifdef __WIN32__ /* WIN */
#ifndef TkClipBox_TCL_DECLARED
#define TkClipBox_TCL_DECLARED
/* 113 */
EXTERN void		TkClipBox(TkRegion rgn, XRectangle *rect_return);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkClipBox_TCL_DECLARED
#define TkClipBox_TCL_DECLARED
/* 113 */
EXTERN void		TkClipBox(TkRegion rgn, XRectangle *rect_return);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkCreateRegion_TCL_DECLARED
#define TkCreateRegion_TCL_DECLARED
/* 114 */
EXTERN TkRegion		TkCreateRegion(void);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkCreateRegion_TCL_DECLARED
#define TkCreateRegion_TCL_DECLARED
/* 114 */
EXTERN TkRegion		TkCreateRegion(void);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkDestroyRegion_TCL_DECLARED
#define TkDestroyRegion_TCL_DECLARED
/* 115 */
EXTERN void		TkDestroyRegion(TkRegion rgn);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkDestroyRegion_TCL_DECLARED
#define TkDestroyRegion_TCL_DECLARED
/* 115 */
EXTERN void		TkDestroyRegion(TkRegion rgn);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkIntersectRegion_TCL_DECLARED
#define TkIntersectRegion_TCL_DECLARED
/* 116 */
EXTERN void		TkIntersectRegion(TkRegion sra, TkRegion srcb,
				TkRegion dr_return);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkIntersectRegion_TCL_DECLARED
#define TkIntersectRegion_TCL_DECLARED
/* 116 */
EXTERN void		TkIntersectRegion(TkRegion sra, TkRegion srcb,
				TkRegion dr_return);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkRectInRegion_TCL_DECLARED
#define TkRectInRegion_TCL_DECLARED
/* 117 */
EXTERN int		TkRectInRegion(TkRegion rgn, int x, int y,
				unsigned int width, unsigned int height);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkRectInRegion_TCL_DECLARED
#define TkRectInRegion_TCL_DECLARED
/* 117 */
EXTERN int		TkRectInRegion(TkRegion rgn, int x, int y,
				unsigned int width, unsigned int height);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkSetRegion_TCL_DECLARED
#define TkSetRegion_TCL_DECLARED
/* 118 */
EXTERN void		TkSetRegion(Display *display, GC gc, TkRegion rgn);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkSetRegion_TCL_DECLARED
#define TkSetRegion_TCL_DECLARED
/* 118 */
EXTERN void		TkSetRegion(Display *display, GC gc, TkRegion rgn);
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkUnionRectWithRegion_TCL_DECLARED
#define TkUnionRectWithRegion_TCL_DECLARED
/* 119 */
EXTERN void		TkUnionRectWithRegion(XRectangle *rect, TkRegion src,
				TkRegion dr_return);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkUnionRectWithRegion_TCL_DECLARED
#define TkUnionRectWithRegion_TCL_DECLARED
/* 119 */
EXTERN void		TkUnionRectWithRegion(XRectangle *rect, TkRegion src,
				TkRegion dr_return);
#endif
#endif /* AQUA */
/* Slot 120 is reserved */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpCreateNativeBitmap_TCL_DECLARED
#define TkpCreateNativeBitmap_TCL_DECLARED
/* 121 */
EXTERN Pixmap		TkpCreateNativeBitmap(Display *display,
				CONST char *source);
#endif
#endif /* AQUA */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpDefineNativeBitmaps_TCL_DECLARED
#define TkpDefineNativeBitmaps_TCL_DECLARED
/* 122 */
EXTERN void		TkpDefineNativeBitmaps(void);
#endif
#endif /* AQUA */
/* Slot 123 is reserved */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpGetNativeAppBitmap_TCL_DECLARED
#define TkpGetNativeAppBitmap_TCL_DECLARED
/* 124 */
EXTERN Pixmap		TkpGetNativeAppBitmap(Display *display,
				CONST char *name, int *width, int *height);
#endif
#endif /* AQUA */
/* Slot 125 is reserved */
/* Slot 126 is reserved */
/* Slot 127 is reserved */
/* Slot 128 is reserved */
/* Slot 129 is reserved */
/* Slot 130 is reserved */
/* Slot 131 is reserved */
/* Slot 132 is reserved */
/* Slot 133 is reserved */
/* Slot 134 is reserved */
#ifndef TkpDrawHighlightBorder_TCL_DECLARED
#define TkpDrawHighlightBorder_TCL_DECLARED
/* 135 */
EXTERN void		TkpDrawHighlightBorder(Tk_Window tkwin, GC fgGC,
				GC bgGC, int highlightWidth,
				Drawable drawable);
#endif
#ifndef TkSetFocusWin_TCL_DECLARED
#define TkSetFocusWin_TCL_DECLARED
/* 136 */
EXTERN void		TkSetFocusWin(TkWindow *winPtr, int force);
#endif
#ifndef TkpSetKeycodeAndState_TCL_DECLARED
#define TkpSetKeycodeAndState_TCL_DECLARED
/* 137 */
EXTERN void		TkpSetKeycodeAndState(Tk_Window tkwin, KeySym keySym,
				XEvent *eventPtr);
#endif
#ifndef TkpGetKeySym_TCL_DECLARED
#define TkpGetKeySym_TCL_DECLARED
/* 138 */
EXTERN KeySym		TkpGetKeySym(TkDisplay *dispPtr, XEvent *eventPtr);
#endif
#ifndef TkpInitKeymapInfo_TCL_DECLARED
#define TkpInitKeymapInfo_TCL_DECLARED
/* 139 */
EXTERN void		TkpInitKeymapInfo(TkDisplay *dispPtr);
#endif
#ifndef TkPhotoGetValidRegion_TCL_DECLARED
#define TkPhotoGetValidRegion_TCL_DECLARED
/* 140 */
EXTERN TkRegion		TkPhotoGetValidRegion(Tk_PhotoHandle handle);
#endif
#ifndef TkWmStackorderToplevel_TCL_DECLARED
#define TkWmStackorderToplevel_TCL_DECLARED
/* 141 */
EXTERN TkWindow **	TkWmStackorderToplevel(TkWindow *parentPtr);
#endif
#ifndef TkFocusFree_TCL_DECLARED
#define TkFocusFree_TCL_DECLARED
/* 142 */
EXTERN void		TkFocusFree(TkMainInfo *mainPtr);
#endif
#ifndef TkClipCleanup_TCL_DECLARED
#define TkClipCleanup_TCL_DECLARED
/* 143 */
EXTERN void		TkClipCleanup(TkDisplay *dispPtr);
#endif
#ifndef TkGCCleanup_TCL_DECLARED
#define TkGCCleanup_TCL_DECLARED
/* 144 */
EXTERN void		TkGCCleanup(TkDisplay *dispPtr);
#endif
#ifdef __WIN32__ /* WIN */
#ifndef TkSubtractRegion_TCL_DECLARED
#define TkSubtractRegion_TCL_DECLARED
/* 145 */
EXTERN void		TkSubtractRegion(TkRegion sra, TkRegion srcb,
				TkRegion dr_return);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkSubtractRegion_TCL_DECLARED
#define TkSubtractRegion_TCL_DECLARED
/* 145 */
EXTERN void		TkSubtractRegion(TkRegion sra, TkRegion srcb,
				TkRegion dr_return);
#endif
#endif /* AQUA */
#ifndef TkStylePkgInit_TCL_DECLARED
#define TkStylePkgInit_TCL_DECLARED
/* 146 */
EXTERN void		TkStylePkgInit(TkMainInfo *mainPtr);
#endif
#ifndef TkStylePkgFree_TCL_DECLARED
#define TkStylePkgFree_TCL_DECLARED
/* 147 */
EXTERN void		TkStylePkgFree(TkMainInfo *mainPtr);
#endif
#ifndef TkToplevelWindowForCommand_TCL_DECLARED
#define TkToplevelWindowForCommand_TCL_DECLARED
/* 148 */
EXTERN Tk_Window	TkToplevelWindowForCommand(Tcl_Interp *interp,
				CONST char *cmdName);
#endif
#ifndef TkGetOptionSpec_TCL_DECLARED
#define TkGetOptionSpec_TCL_DECLARED
/* 149 */
EXTERN CONST Tk_OptionSpec * TkGetOptionSpec(CONST char *name,
				Tk_OptionTable optionTable);
#endif
#ifndef TkMakeRawCurve_TCL_DECLARED
#define TkMakeRawCurve_TCL_DECLARED
/* 150 */
EXTERN int		TkMakeRawCurve(Tk_Canvas canvas, double *pointPtr,
				int numPoints, int numSteps,
				XPoint xPoints[], double dblPoints[]);
#endif
#ifndef TkMakeRawCurvePostscript_TCL_DECLARED
#define TkMakeRawCurvePostscript_TCL_DECLARED
/* 151 */
EXTERN void		TkMakeRawCurvePostscript(Tcl_Interp *interp,
				Tk_Canvas canvas, double *pointPtr,
				int numPoints);
#endif
#ifndef TkpDrawFrame_TCL_DECLARED
#define TkpDrawFrame_TCL_DECLARED
/* 152 */
EXTERN void		TkpDrawFrame(Tk_Window tkwin, Tk_3DBorder border,
				int highlightWidth, int borderWidth,
				int relief);
#endif
#ifndef TkCreateThreadExitHandler_TCL_DECLARED
#define TkCreateThreadExitHandler_TCL_DECLARED
/* 153 */
EXTERN void		TkCreateThreadExitHandler(Tcl_ExitProc *proc,
				ClientData clientData);
#endif
#ifndef TkDeleteThreadExitHandler_TCL_DECLARED
#define TkDeleteThreadExitHandler_TCL_DECLARED
/* 154 */
EXTERN void		TkDeleteThreadExitHandler(Tcl_ExitProc *proc,
				ClientData clientData);
#endif
/* Slot 155 is reserved */
#ifndef TkpTestembedCmd_TCL_DECLARED
#define TkpTestembedCmd_TCL_DECLARED
/* 156 */
EXTERN int		TkpTestembedCmd(ClientData clientData,
				Tcl_Interp *interp, int argc,
				CONST char **argv);
#endif
#ifndef TkpTesttextCmd_TCL_DECLARED
#define TkpTesttextCmd_TCL_DECLARED
/* 157 */
EXTERN int		TkpTesttextCmd(ClientData dummy, Tcl_Interp *interp,
				int argc, CONST char **argv);
#endif
/* Slot 158 is reserved */
/* Slot 159 is reserved */
/* Slot 160 is reserved */
/* Slot 161 is reserved */
/* Slot 162 is reserved */
/* Slot 163 is reserved */
/* Slot 164 is reserved */
/* Slot 165 is reserved */
/* Slot 166 is reserved */
/* Slot 167 is reserved */
/* Slot 168 is reserved */
#ifndef TkStateParseProc_TCL_DECLARED
#define TkStateParseProc_TCL_DECLARED
/* 169 */
EXTERN int		TkStateParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkStatePrintProc_TCL_DECLARED
#define TkStatePrintProc_TCL_DECLARED
/* 170 */
EXTERN char *		TkStatePrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef TkCanvasDashParseProc_TCL_DECLARED
#define TkCanvasDashParseProc_TCL_DECLARED
/* 171 */
EXTERN int		TkCanvasDashParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkCanvasDashPrintProc_TCL_DECLARED
#define TkCanvasDashPrintProc_TCL_DECLARED
/* 172 */
EXTERN char *		TkCanvasDashPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef TkOffsetParseProc_TCL_DECLARED
#define TkOffsetParseProc_TCL_DECLARED
/* 173 */
EXTERN int		TkOffsetParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkOffsetPrintProc_TCL_DECLARED
#define TkOffsetPrintProc_TCL_DECLARED
/* 174 */
EXTERN char *		TkOffsetPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef TkPixelParseProc_TCL_DECLARED
#define TkPixelParseProc_TCL_DECLARED
/* 175 */
EXTERN int		TkPixelParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkPixelPrintProc_TCL_DECLARED
#define TkPixelPrintProc_TCL_DECLARED
/* 176 */
EXTERN char *		TkPixelPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef TkOrientParseProc_TCL_DECLARED
#define TkOrientParseProc_TCL_DECLARED
/* 177 */
EXTERN int		TkOrientParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkOrientPrintProc_TCL_DECLARED
#define TkOrientPrintProc_TCL_DECLARED
/* 178 */
EXTERN char *		TkOrientPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef TkSmoothParseProc_TCL_DECLARED
#define TkSmoothParseProc_TCL_DECLARED
/* 179 */
EXTERN int		TkSmoothParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef TkSmoothPrintProc_TCL_DECLARED
#define TkSmoothPrintProc_TCL_DECLARED
/* 180 */
EXTERN char *		TkSmoothPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif

typedef struct TkIntStubs {
    int magic;
    struct TkIntStubHooks *hooks;

    TkWindow * (*tkAllocWindow) (TkDisplay *dispPtr, int screenNum, TkWindow *parentPtr); /* 0 */
    void (*tkBezierPoints) (double control[], int numSteps, double *coordPtr); /* 1 */
    void (*tkBezierScreenPoints) (Tk_Canvas canvas, double control[], int numSteps, XPoint *xPointPtr); /* 2 */
    void (*tkBindDeadWindow) (TkWindow *winPtr); /* 3 */
    void (*tkBindEventProc) (TkWindow *winPtr, XEvent *eventPtr); /* 4 */
    void (*tkBindFree) (TkMainInfo *mainPtr); /* 5 */
    void (*tkBindInit) (TkMainInfo *mainPtr); /* 6 */
    void (*tkChangeEventWindow) (XEvent *eventPtr, TkWindow *winPtr); /* 7 */
    int (*tkClipInit) (Tcl_Interp *interp, TkDisplay *dispPtr); /* 8 */
    void (*tkComputeAnchor) (Tk_Anchor anchor, Tk_Window tkwin, int padX, int padY, int innerWidth, int innerHeight, int *xPtr, int *yPtr); /* 9 */
    int (*tkCopyAndGlobalEval) (Tcl_Interp *interp, char *script); /* 10 */
    unsigned long (*tkCreateBindingProcedure) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventString, TkBindEvalProc *evalProc, TkBindFreeProc *freeProc, ClientData clientData); /* 11 */
    TkCursor * (*tkCreateCursorFromData) (Tk_Window tkwin, CONST char *source, CONST char *mask, int width, int height, int xHot, int yHot, XColor fg, XColor bg); /* 12 */
    int (*tkCreateFrame) (ClientData clientData, Tcl_Interp *interp, int argc, char **argv, int toplevel, char *appName); /* 13 */
    Tk_Window (*tkCreateMainWindow) (Tcl_Interp *interp, CONST char *screenName, char *baseName); /* 14 */
    Time (*tkCurrentTime) (TkDisplay *dispPtr); /* 15 */
    void (*tkDeleteAllImages) (TkMainInfo *mainPtr); /* 16 */
    void (*tkDoConfigureNotify) (TkWindow *winPtr); /* 17 */
    void (*tkDrawInsetFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable, int padding); /* 18 */
    void (*tkEventDeadWindow) (TkWindow *winPtr); /* 19 */
    void (*tkFillPolygon) (Tk_Canvas canvas, double *coordPtr, int numPoints, Display *display, Drawable drawable, GC gc, GC outlineGC); /* 20 */
    int (*tkFindStateNum) (Tcl_Interp *interp, CONST char *option, CONST TkStateMap *mapPtr, CONST char *strKey); /* 21 */
    char * (*tkFindStateString) (CONST TkStateMap *mapPtr, int numKey); /* 22 */
    void (*tkFocusDeadWindow) (TkWindow *winPtr); /* 23 */
    int (*tkFocusFilterEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 24 */
    TkWindow * (*tkFocusKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 25 */
    void (*tkFontPkgInit) (TkMainInfo *mainPtr); /* 26 */
    void (*tkFontPkgFree) (TkMainInfo *mainPtr); /* 27 */
    void (*tkFreeBindingTags) (TkWindow *winPtr); /* 28 */
    void (*tkpFreeCursor) (TkCursor *cursorPtr); /* 29 */
    char * (*tkGetBitmapData) (Tcl_Interp *interp, char *string, char *fileName, int *widthPtr, int *heightPtr, int *hotXPtr, int *hotYPtr); /* 30 */
    void (*tkGetButtPoints) (double p1[], double p2[], double width, int project, double m1[], double m2[]); /* 31 */
    TkCursor * (*tkGetCursorByName) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid string); /* 32 */
    CONST84_RETURN char * (*tkGetDefaultScreenName) (Tcl_Interp *interp, CONST char *screenName); /* 33 */
    TkDisplay * (*tkGetDisplay) (Display *display); /* 34 */
    int (*tkGetDisplayOf) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], Tk_Window *tkwinPtr); /* 35 */
    TkWindow * (*tkGetFocusWin) (TkWindow *winPtr); /* 36 */
    int (*tkGetInterpNames) (Tcl_Interp *interp, Tk_Window tkwin); /* 37 */
    int (*tkGetMiterPoints) (double p1[], double p2[], double p3[], double width, double m1[], double m2[]); /* 38 */
    void (*tkGetPointerCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 39 */
    void (*tkGetServerInfo) (Tcl_Interp *interp, Tk_Window tkwin); /* 40 */
    void (*tkGrabDeadWindow) (TkWindow *winPtr); /* 41 */
    int (*tkGrabState) (TkWindow *winPtr); /* 42 */
    void (*tkIncludePoint) (Tk_Item *itemPtr, double *pointPtr); /* 43 */
    void (*tkInOutEvents) (XEvent *eventPtr, TkWindow *sourcePtr, TkWindow *destPtr, int leaveType, int enterType, Tcl_QueuePosition position); /* 44 */
    void (*tkInstallFrameMenu) (Tk_Window tkwin); /* 45 */
    char * (*tkKeysymToString) (KeySym keysym); /* 46 */
    int (*tkLineToArea) (double end1Ptr[], double end2Ptr[], double rectPtr[]); /* 47 */
    double (*tkLineToPoint) (double end1Ptr[], double end2Ptr[], double pointPtr[]); /* 48 */
    int (*tkMakeBezierCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 49 */
    void (*tkMakeBezierPostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 50 */
    void (*tkOptionClassChanged) (TkWindow *winPtr); /* 51 */
    void (*tkOptionDeadWindow) (TkWindow *winPtr); /* 52 */
    int (*tkOvalToArea) (double *ovalPtr, double *rectPtr); /* 53 */
    double (*tkOvalToPoint) (double ovalPtr[], double width, int filled, double pointPtr[]); /* 54 */
    int (*tkpChangeFocus) (TkWindow *winPtr, int force); /* 55 */
    void (*tkpCloseDisplay) (TkDisplay *dispPtr); /* 56 */
    void (*tkpClaimFocus) (TkWindow *topLevelPtr, int force); /* 57 */
    void (*tkpDisplayWarning) (CONST char *msg, CONST char *title); /* 58 */
    void (*tkpGetAppName) (Tcl_Interp *interp, Tcl_DString *name); /* 59 */
    TkWindow * (*tkpGetOtherWindow) (TkWindow *winPtr); /* 60 */
    TkWindow * (*tkpGetWrapperWindow) (TkWindow *winPtr); /* 61 */
    int (*tkpInit) (Tcl_Interp *interp); /* 62 */
    void (*tkpInitializeMenuBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable); /* 63 */
    void (*tkpMakeContainer) (Tk_Window tkwin); /* 64 */
    void (*tkpMakeMenuWindow) (Tk_Window tkwin, int transient); /* 65 */
    Window (*tkpMakeWindow) (TkWindow *winPtr, Window parent); /* 66 */
    void (*tkpMenuNotifyToplevelCreate) (Tcl_Interp *interp1, char *menuName); /* 67 */
    TkDisplay * (*tkpOpenDisplay) (CONST char *display_name); /* 68 */
    int (*tkPointerEvent) (XEvent *eventPtr, TkWindow *winPtr); /* 69 */
    int (*tkPolygonToArea) (double *polyPtr, int numPoints, double *rectPtr); /* 70 */
    double (*tkPolygonToPoint) (double *polyPtr, int numPoints, double *pointPtr); /* 71 */
    int (*tkPositionInTree) (TkWindow *winPtr, TkWindow *treePtr); /* 72 */
    void (*tkpRedirectKeyEvent) (TkWindow *winPtr, XEvent *eventPtr); /* 73 */
    void (*tkpSetMainMenubar) (Tcl_Interp *interp, Tk_Window tkwin, char *menuName); /* 74 */
    int (*tkpUseWindow) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *string); /* 75 */
    int (*tkpWindowWasRecentlyDeleted) (Window win, TkDisplay *dispPtr); /* 76 */
    void (*tkQueueEventForAllChildren) (TkWindow *winPtr, XEvent *eventPtr); /* 77 */
    int (*tkReadBitmapFile) (Display *display, Drawable d, CONST char *filename, unsigned int *width_return, unsigned int *height_return, Pixmap *bitmap_return, int *x_hot_return, int *y_hot_return); /* 78 */
    int (*tkScrollWindow) (Tk_Window tkwin, GC gc, int x, int y, int width, int height, int dx, int dy, TkRegion damageRgn); /* 79 */
    void (*tkSelDeadWindow) (TkWindow *winPtr); /* 80 */
    void (*tkSelEventProc) (Tk_Window tkwin, XEvent *eventPtr); /* 81 */
    void (*tkSelInit) (Tk_Window tkwin); /* 82 */
    void (*tkSelPropProc) (XEvent *eventPtr); /* 83 */
    void *reserved84;
    void (*tkSetWindowMenuBar) (Tcl_Interp *interp, Tk_Window tkwin, char *oldMenuName, char *menuName); /* 85 */
    KeySym (*tkStringToKeysym) (char *name); /* 86 */
    int (*tkThickPolyLineToArea) (double *coordPtr, int numPoints, double width, int capStyle, int joinStyle, double *rectPtr); /* 87 */
    void (*tkWmAddToColormapWindows) (TkWindow *winPtr); /* 88 */
    void (*tkWmDeadWindow) (TkWindow *winPtr); /* 89 */
    TkWindow * (*tkWmFocusToplevel) (TkWindow *winPtr); /* 90 */
    void (*tkWmMapWindow) (TkWindow *winPtr); /* 91 */
    void (*tkWmNewWindow) (TkWindow *winPtr); /* 92 */
    void (*tkWmProtocolEventProc) (TkWindow *winPtr, XEvent *evenvPtr); /* 93 */
    void (*tkWmRemoveFromColormapWindows) (TkWindow *winPtr); /* 94 */
    void (*tkWmRestackToplevel) (TkWindow *winPtr, int aboveBelow, TkWindow *otherPtr); /* 95 */
    void (*tkWmSetClass) (TkWindow *winPtr); /* 96 */
    void (*tkWmUnmapWindow) (TkWindow *winPtr); /* 97 */
    Tcl_Obj * (*tkDebugBitmap) (Tk_Window tkwin, char *name); /* 98 */
    Tcl_Obj * (*tkDebugBorder) (Tk_Window tkwin, char *name); /* 99 */
    Tcl_Obj * (*tkDebugCursor) (Tk_Window tkwin, char *name); /* 100 */
    Tcl_Obj * (*tkDebugColor) (Tk_Window tkwin, char *name); /* 101 */
    Tcl_Obj * (*tkDebugConfig) (Tcl_Interp *interp, Tk_OptionTable table); /* 102 */
    Tcl_Obj * (*tkDebugFont) (Tk_Window tkwin, char *name); /* 103 */
    int (*tkFindStateNumObj) (Tcl_Interp *interp, Tcl_Obj *optionPtr, CONST TkStateMap *mapPtr, Tcl_Obj *keyPtr); /* 104 */
    Tcl_HashTable * (*tkGetBitmapPredefTable) (void); /* 105 */
    TkDisplay * (*tkGetDisplayList) (void); /* 106 */
    TkMainInfo * (*tkGetMainInfoList) (void); /* 107 */
    int (*tkGetWindowFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, Tk_Window *windowPtr); /* 108 */
    char * (*tkpGetString) (TkWindow *winPtr, XEvent *eventPtr, Tcl_DString *dsPtr); /* 109 */
    void (*tkpGetSubFonts) (Tcl_Interp *interp, Tk_Font tkfont); /* 110 */
    Tcl_Obj * (*tkpGetSystemDefault) (Tk_Window tkwin, CONST char *dbName, CONST char *className); /* 111 */
    void (*tkpMenuThreadInit) (void); /* 112 */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved113;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkClipBox) (TkRegion rgn, XRectangle *rect_return); /* 113 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved113; /* Dummy entry for stubs table backwards compatibility */
    void (*tkClipBox) (TkRegion rgn, XRectangle *rect_return); /* 113 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved114;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    TkRegion (*tkCreateRegion) (void); /* 114 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved114; /* Dummy entry for stubs table backwards compatibility */
    TkRegion (*tkCreateRegion) (void); /* 114 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved115;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved115; /* Dummy entry for stubs table backwards compatibility */
    void (*tkDestroyRegion) (TkRegion rgn); /* 115 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved116;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved116; /* Dummy entry for stubs table backwards compatibility */
    void (*tkIntersectRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 116 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved117;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved117; /* Dummy entry for stubs table backwards compatibility */
    int (*tkRectInRegion) (TkRegion rgn, int x, int y, unsigned int width, unsigned int height); /* 117 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved118;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkSetRegion) (Display *display, GC gc, TkRegion rgn); /* 118 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved118; /* Dummy entry for stubs table backwards compatibility */
    void (*tkSetRegion) (Display *display, GC gc, TkRegion rgn); /* 118 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved119;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkUnionRectWithRegion) (XRectangle *rect, TkRegion src, TkRegion dr_return); /* 119 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved119; /* Dummy entry for stubs table backwards compatibility */
    void (*tkUnionRectWithRegion) (XRectangle *rect, TkRegion src, TkRegion dr_return); /* 119 */
#endif /* AQUA */
    void *reserved120;
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved121;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void *reserved121;
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved121; /* Dummy entry for stubs table backwards compatibility */
    Pixmap (*tkpCreateNativeBitmap) (Display *display, CONST char *source); /* 121 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved122;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void *reserved122;
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved122; /* Dummy entry for stubs table backwards compatibility */
    void (*tkpDefineNativeBitmaps) (void); /* 122 */
#endif /* AQUA */
    void *reserved123;
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved124;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void *reserved124;
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved124; /* Dummy entry for stubs table backwards compatibility */
    Pixmap (*tkpGetNativeAppBitmap) (Display *display, CONST char *name, int *width, int *height); /* 124 */
#endif /* AQUA */
    void *reserved125;
    void *reserved126;
    void *reserved127;
    void *reserved128;
    void *reserved129;
    void *reserved130;
    void *reserved131;
    void *reserved132;
    void *reserved133;
    void *reserved134;
    void (*tkpDrawHighlightBorder) (Tk_Window tkwin, GC fgGC, GC bgGC, int highlightWidth, Drawable drawable); /* 135 */
    void (*tkSetFocusWin) (TkWindow *winPtr, int force); /* 136 */
    void (*tkpSetKeycodeAndState) (Tk_Window tkwin, KeySym keySym, XEvent *eventPtr); /* 137 */
    KeySym (*tkpGetKeySym) (TkDisplay *dispPtr, XEvent *eventPtr); /* 138 */
    void (*tkpInitKeymapInfo) (TkDisplay *dispPtr); /* 139 */
    TkRegion (*tkPhotoGetValidRegion) (Tk_PhotoHandle handle); /* 140 */
    TkWindow ** (*tkWmStackorderToplevel) (TkWindow *parentPtr); /* 141 */
    void (*tkFocusFree) (TkMainInfo *mainPtr); /* 142 */
    void (*tkClipCleanup) (TkDisplay *dispPtr); /* 143 */
    void (*tkGCCleanup) (TkDisplay *dispPtr); /* 144 */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void *reserved145;
#endif /* X11 */
#ifdef __WIN32__ /* WIN */
    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void *reserved145; /* Dummy entry for stubs table backwards compatibility */
    void (*tkSubtractRegion) (TkRegion sra, TkRegion srcb, TkRegion dr_return); /* 145 */
#endif /* AQUA */
    void (*tkStylePkgInit) (TkMainInfo *mainPtr); /* 146 */
    void (*tkStylePkgFree) (TkMainInfo *mainPtr); /* 147 */
    Tk_Window (*tkToplevelWindowForCommand) (Tcl_Interp *interp, CONST char *cmdName); /* 148 */
    CONST Tk_OptionSpec * (*tkGetOptionSpec) (CONST char *name, Tk_OptionTable optionTable); /* 149 */
    int (*tkMakeRawCurve) (Tk_Canvas canvas, double *pointPtr, int numPoints, int numSteps, XPoint xPoints[], double dblPoints[]); /* 150 */
    void (*tkMakeRawCurvePostscript) (Tcl_Interp *interp, Tk_Canvas canvas, double *pointPtr, int numPoints); /* 151 */
    void (*tkpDrawFrame) (Tk_Window tkwin, Tk_3DBorder border, int highlightWidth, int borderWidth, int relief); /* 152 */
    void (*tkCreateThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 153 */
    void (*tkDeleteThreadExitHandler) (Tcl_ExitProc *proc, ClientData clientData); /* 154 */
    void *reserved155;
    int (*tkpTestembedCmd) (ClientData clientData, Tcl_Interp *interp, int argc, CONST char **argv); /* 156 */
    int (*tkpTesttextCmd) (ClientData dummy, Tcl_Interp *interp, int argc, CONST char **argv); /* 157 */
    void *reserved158;
    void *reserved159;
    void *reserved160;
    void *reserved161;
    void *reserved162;
    void *reserved163;
    void *reserved164;
    void *reserved165;
    void *reserved166;
    void *reserved167;
    void *reserved168;
    int (*tkStateParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 169 */
    char * (*tkStatePrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 170 */
    int (*tkCanvasDashParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 171 */
    char * (*tkCanvasDashPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 172 */
    int (*tkOffsetParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 173 */
    char * (*tkOffsetPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 174 */
    int (*tkPixelParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 175 */
    char * (*tkPixelPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 176 */
    int (*tkOrientParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 177 */
    char * (*tkOrientPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 178 */
    int (*tkSmoothParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 179 */
    char * (*tkSmoothPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 180 */
} TkIntStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntStubs *tkIntStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifndef TkAllocWindow
#define TkAllocWindow \
	(tkIntStubsPtr->tkAllocWindow) /* 0 */
#endif
#ifndef TkBezierPoints
#define TkBezierPoints \
	(tkIntStubsPtr->tkBezierPoints) /* 1 */
#endif
#ifndef TkBezierScreenPoints
#define TkBezierScreenPoints \
	(tkIntStubsPtr->tkBezierScreenPoints) /* 2 */
#endif
#ifndef TkBindDeadWindow
#define TkBindDeadWindow \
	(tkIntStubsPtr->tkBindDeadWindow) /* 3 */
#endif
#ifndef TkBindEventProc
#define TkBindEventProc \
	(tkIntStubsPtr->tkBindEventProc) /* 4 */
#endif
#ifndef TkBindFree
#define TkBindFree \
	(tkIntStubsPtr->tkBindFree) /* 5 */
#endif
#ifndef TkBindInit
#define TkBindInit \
	(tkIntStubsPtr->tkBindInit) /* 6 */
#endif
#ifndef TkChangeEventWindow
#define TkChangeEventWindow \
	(tkIntStubsPtr->tkChangeEventWindow) /* 7 */
#endif
#ifndef TkClipInit
#define TkClipInit \
	(tkIntStubsPtr->tkClipInit) /* 8 */
#endif
#ifndef TkComputeAnchor
#define TkComputeAnchor \
	(tkIntStubsPtr->tkComputeAnchor) /* 9 */
#endif
#ifndef TkCopyAndGlobalEval
#define TkCopyAndGlobalEval \
	(tkIntStubsPtr->tkCopyAndGlobalEval) /* 10 */
#endif
#ifndef TkCreateBindingProcedure
#define TkCreateBindingProcedure \
	(tkIntStubsPtr->tkCreateBindingProcedure) /* 11 */
#endif
#ifndef TkCreateCursorFromData
#define TkCreateCursorFromData \
	(tkIntStubsPtr->tkCreateCursorFromData) /* 12 */
#endif
#ifndef TkCreateFrame
#define TkCreateFrame \
	(tkIntStubsPtr->tkCreateFrame) /* 13 */
#endif
#ifndef TkCreateMainWindow
#define TkCreateMainWindow \
	(tkIntStubsPtr->tkCreateMainWindow) /* 14 */
#endif
#ifndef TkCurrentTime
#define TkCurrentTime \
	(tkIntStubsPtr->tkCurrentTime) /* 15 */
#endif
#ifndef TkDeleteAllImages
#define TkDeleteAllImages \
	(tkIntStubsPtr->tkDeleteAllImages) /* 16 */
#endif
#ifndef TkDoConfigureNotify
#define TkDoConfigureNotify \
	(tkIntStubsPtr->tkDoConfigureNotify) /* 17 */
#endif
#ifndef TkDrawInsetFocusHighlight
#define TkDrawInsetFocusHighlight \
	(tkIntStubsPtr->tkDrawInsetFocusHighlight) /* 18 */
#endif
#ifndef TkEventDeadWindow
#define TkEventDeadWindow \
	(tkIntStubsPtr->tkEventDeadWindow) /* 19 */
#endif
#ifndef TkFillPolygon
#define TkFillPolygon \
	(tkIntStubsPtr->tkFillPolygon) /* 20 */
#endif
#ifndef TkFindStateNum
#define TkFindStateNum \
	(tkIntStubsPtr->tkFindStateNum) /* 21 */
#endif
#ifndef TkFindStateString
#define TkFindStateString \
	(tkIntStubsPtr->tkFindStateString) /* 22 */
#endif
#ifndef TkFocusDeadWindow
#define TkFocusDeadWindow \
	(tkIntStubsPtr->tkFocusDeadWindow) /* 23 */
#endif
#ifndef TkFocusFilterEvent
#define TkFocusFilterEvent \
	(tkIntStubsPtr->tkFocusFilterEvent) /* 24 */
#endif
#ifndef TkFocusKeyEvent
#define TkFocusKeyEvent \
	(tkIntStubsPtr->tkFocusKeyEvent) /* 25 */
#endif
#ifndef TkFontPkgInit
#define TkFontPkgInit \
	(tkIntStubsPtr->tkFontPkgInit) /* 26 */
#endif
#ifndef TkFontPkgFree
#define TkFontPkgFree \
	(tkIntStubsPtr->tkFontPkgFree) /* 27 */
#endif
#ifndef TkFreeBindingTags
#define TkFreeBindingTags \
	(tkIntStubsPtr->tkFreeBindingTags) /* 28 */
#endif
#ifndef TkpFreeCursor
#define TkpFreeCursor \
	(tkIntStubsPtr->tkpFreeCursor) /* 29 */
#endif
#ifndef TkGetBitmapData
#define TkGetBitmapData \
	(tkIntStubsPtr->tkGetBitmapData) /* 30 */
#endif
#ifndef TkGetButtPoints
#define TkGetButtPoints \
	(tkIntStubsPtr->tkGetButtPoints) /* 31 */
#endif
#ifndef TkGetCursorByName
#define TkGetCursorByName \
	(tkIntStubsPtr->tkGetCursorByName) /* 32 */
#endif
#ifndef TkGetDefaultScreenName
#define TkGetDefaultScreenName \
	(tkIntStubsPtr->tkGetDefaultScreenName) /* 33 */
#endif
#ifndef TkGetDisplay
#define TkGetDisplay \
	(tkIntStubsPtr->tkGetDisplay) /* 34 */
#endif
#ifndef TkGetDisplayOf
#define TkGetDisplayOf \
	(tkIntStubsPtr->tkGetDisplayOf) /* 35 */
#endif
#ifndef TkGetFocusWin
#define TkGetFocusWin \
	(tkIntStubsPtr->tkGetFocusWin) /* 36 */
#endif
#ifndef TkGetInterpNames
#define TkGetInterpNames \
	(tkIntStubsPtr->tkGetInterpNames) /* 37 */
#endif
#ifndef TkGetMiterPoints
#define TkGetMiterPoints \
	(tkIntStubsPtr->tkGetMiterPoints) /* 38 */
#endif
#ifndef TkGetPointerCoords
#define TkGetPointerCoords \
	(tkIntStubsPtr->tkGetPointerCoords) /* 39 */
#endif
#ifndef TkGetServerInfo
#define TkGetServerInfo \
	(tkIntStubsPtr->tkGetServerInfo) /* 40 */
#endif
#ifndef TkGrabDeadWindow
#define TkGrabDeadWindow \
	(tkIntStubsPtr->tkGrabDeadWindow) /* 41 */
#endif
#ifndef TkGrabState
#define TkGrabState \
	(tkIntStubsPtr->tkGrabState) /* 42 */
#endif
#ifndef TkIncludePoint
#define TkIncludePoint \
	(tkIntStubsPtr->tkIncludePoint) /* 43 */
#endif
#ifndef TkInOutEvents
#define TkInOutEvents \
	(tkIntStubsPtr->tkInOutEvents) /* 44 */
#endif
#ifndef TkInstallFrameMenu
#define TkInstallFrameMenu \
	(tkIntStubsPtr->tkInstallFrameMenu) /* 45 */
#endif
#ifndef TkKeysymToString
#define TkKeysymToString \
	(tkIntStubsPtr->tkKeysymToString) /* 46 */
#endif
#ifndef TkLineToArea
#define TkLineToArea \
	(tkIntStubsPtr->tkLineToArea) /* 47 */
#endif
#ifndef TkLineToPoint
#define TkLineToPoint \
	(tkIntStubsPtr->tkLineToPoint) /* 48 */
#endif
#ifndef TkMakeBezierCurve
#define TkMakeBezierCurve \
	(tkIntStubsPtr->tkMakeBezierCurve) /* 49 */
#endif
#ifndef TkMakeBezierPostscript
#define TkMakeBezierPostscript \
	(tkIntStubsPtr->tkMakeBezierPostscript) /* 50 */
#endif
#ifndef TkOptionClassChanged
#define TkOptionClassChanged \
	(tkIntStubsPtr->tkOptionClassChanged) /* 51 */
#endif
#ifndef TkOptionDeadWindow
#define TkOptionDeadWindow \
	(tkIntStubsPtr->tkOptionDeadWindow) /* 52 */
#endif
#ifndef TkOvalToArea
#define TkOvalToArea \
	(tkIntStubsPtr->tkOvalToArea) /* 53 */
#endif
#ifndef TkOvalToPoint
#define TkOvalToPoint \
	(tkIntStubsPtr->tkOvalToPoint) /* 54 */
#endif
#ifndef TkpChangeFocus
#define TkpChangeFocus \
	(tkIntStubsPtr->tkpChangeFocus) /* 55 */
#endif
#ifndef TkpCloseDisplay
#define TkpCloseDisplay \
	(tkIntStubsPtr->tkpCloseDisplay) /* 56 */
#endif
#ifndef TkpClaimFocus
#define TkpClaimFocus \
	(tkIntStubsPtr->tkpClaimFocus) /* 57 */
#endif
#ifndef TkpDisplayWarning
#define TkpDisplayWarning \
	(tkIntStubsPtr->tkpDisplayWarning) /* 58 */
#endif
#ifndef TkpGetAppName
#define TkpGetAppName \
	(tkIntStubsPtr->tkpGetAppName) /* 59 */
#endif
#ifndef TkpGetOtherWindow
#define TkpGetOtherWindow \
	(tkIntStubsPtr->tkpGetOtherWindow) /* 60 */
#endif
#ifndef TkpGetWrapperWindow
#define TkpGetWrapperWindow \
	(tkIntStubsPtr->tkpGetWrapperWindow) /* 61 */
#endif
#ifndef TkpInit
#define TkpInit \
	(tkIntStubsPtr->tkpInit) /* 62 */
#endif
#ifndef TkpInitializeMenuBindings
#define TkpInitializeMenuBindings \
	(tkIntStubsPtr->tkpInitializeMenuBindings) /* 63 */
#endif
#ifndef TkpMakeContainer
#define TkpMakeContainer \
	(tkIntStubsPtr->tkpMakeContainer) /* 64 */
#endif
#ifndef TkpMakeMenuWindow
#define TkpMakeMenuWindow \
	(tkIntStubsPtr->tkpMakeMenuWindow) /* 65 */
#endif
#ifndef TkpMakeWindow
#define TkpMakeWindow \
	(tkIntStubsPtr->tkpMakeWindow) /* 66 */
#endif
#ifndef TkpMenuNotifyToplevelCreate
#define TkpMenuNotifyToplevelCreate \
	(tkIntStubsPtr->tkpMenuNotifyToplevelCreate) /* 67 */
#endif
#ifndef TkpOpenDisplay
#define TkpOpenDisplay \
	(tkIntStubsPtr->tkpOpenDisplay) /* 68 */
#endif
#ifndef TkPointerEvent
#define TkPointerEvent \
	(tkIntStubsPtr->tkPointerEvent) /* 69 */
#endif
#ifndef TkPolygonToArea
#define TkPolygonToArea \
	(tkIntStubsPtr->tkPolygonToArea) /* 70 */
#endif
#ifndef TkPolygonToPoint
#define TkPolygonToPoint \
	(tkIntStubsPtr->tkPolygonToPoint) /* 71 */
#endif
#ifndef TkPositionInTree
#define TkPositionInTree \
	(tkIntStubsPtr->tkPositionInTree) /* 72 */
#endif
#ifndef TkpRedirectKeyEvent
#define TkpRedirectKeyEvent \
	(tkIntStubsPtr->tkpRedirectKeyEvent) /* 73 */
#endif
#ifndef TkpSetMainMenubar
#define TkpSetMainMenubar \
	(tkIntStubsPtr->tkpSetMainMenubar) /* 74 */
#endif
#ifndef TkpUseWindow
#define TkpUseWindow \
	(tkIntStubsPtr->tkpUseWindow) /* 75 */
#endif
#ifndef TkpWindowWasRecentlyDeleted
#define TkpWindowWasRecentlyDeleted \
	(tkIntStubsPtr->tkpWindowWasRecentlyDeleted) /* 76 */
#endif
#ifndef TkQueueEventForAllChildren
#define TkQueueEventForAllChildren \
	(tkIntStubsPtr->tkQueueEventForAllChildren) /* 77 */
#endif
#ifndef TkReadBitmapFile
#define TkReadBitmapFile \
	(tkIntStubsPtr->tkReadBitmapFile) /* 78 */
#endif
#ifndef TkScrollWindow
#define TkScrollWindow \
	(tkIntStubsPtr->tkScrollWindow) /* 79 */
#endif
#ifndef TkSelDeadWindow
#define TkSelDeadWindow \
	(tkIntStubsPtr->tkSelDeadWindow) /* 80 */
#endif
#ifndef TkSelEventProc
#define TkSelEventProc \
	(tkIntStubsPtr->tkSelEventProc) /* 81 */
#endif
#ifndef TkSelInit
#define TkSelInit \
	(tkIntStubsPtr->tkSelInit) /* 82 */
#endif
#ifndef TkSelPropProc
#define TkSelPropProc \
	(tkIntStubsPtr->tkSelPropProc) /* 83 */
#endif
/* Slot 84 is reserved */
#ifndef TkSetWindowMenuBar
#define TkSetWindowMenuBar \
	(tkIntStubsPtr->tkSetWindowMenuBar) /* 85 */
#endif
#ifndef TkStringToKeysym
#define TkStringToKeysym \
	(tkIntStubsPtr->tkStringToKeysym) /* 86 */
#endif
#ifndef TkThickPolyLineToArea
#define TkThickPolyLineToArea \
	(tkIntStubsPtr->tkThickPolyLineToArea) /* 87 */
#endif
#ifndef TkWmAddToColormapWindows
#define TkWmAddToColormapWindows \
	(tkIntStubsPtr->tkWmAddToColormapWindows) /* 88 */
#endif
#ifndef TkWmDeadWindow
#define TkWmDeadWindow \
	(tkIntStubsPtr->tkWmDeadWindow) /* 89 */
#endif
#ifndef TkWmFocusToplevel
#define TkWmFocusToplevel \
	(tkIntStubsPtr->tkWmFocusToplevel) /* 90 */
#endif
#ifndef TkWmMapWindow
#define TkWmMapWindow \
	(tkIntStubsPtr->tkWmMapWindow) /* 91 */
#endif
#ifndef TkWmNewWindow
#define TkWmNewWindow \
	(tkIntStubsPtr->tkWmNewWindow) /* 92 */
#endif
#ifndef TkWmProtocolEventProc
#define TkWmProtocolEventProc \
	(tkIntStubsPtr->tkWmProtocolEventProc) /* 93 */
#endif
#ifndef TkWmRemoveFromColormapWindows
#define TkWmRemoveFromColormapWindows \
	(tkIntStubsPtr->tkWmRemoveFromColormapWindows) /* 94 */
#endif
#ifndef TkWmRestackToplevel
#define TkWmRestackToplevel \
	(tkIntStubsPtr->tkWmRestackToplevel) /* 95 */
#endif
#ifndef TkWmSetClass
#define TkWmSetClass \
	(tkIntStubsPtr->tkWmSetClass) /* 96 */
#endif
#ifndef TkWmUnmapWindow
#define TkWmUnmapWindow \
	(tkIntStubsPtr->tkWmUnmapWindow) /* 97 */
#endif
#ifndef TkDebugBitmap
#define TkDebugBitmap \
	(tkIntStubsPtr->tkDebugBitmap) /* 98 */
#endif
#ifndef TkDebugBorder
#define TkDebugBorder \
	(tkIntStubsPtr->tkDebugBorder) /* 99 */
#endif
#ifndef TkDebugCursor
#define TkDebugCursor \
	(tkIntStubsPtr->tkDebugCursor) /* 100 */
#endif
#ifndef TkDebugColor
#define TkDebugColor \
	(tkIntStubsPtr->tkDebugColor) /* 101 */
#endif
#ifndef TkDebugConfig
#define TkDebugConfig \
	(tkIntStubsPtr->tkDebugConfig) /* 102 */
#endif
#ifndef TkDebugFont
#define TkDebugFont \
	(tkIntStubsPtr->tkDebugFont) /* 103 */
#endif
#ifndef TkFindStateNumObj
#define TkFindStateNumObj \
	(tkIntStubsPtr->tkFindStateNumObj) /* 104 */
#endif
#ifndef TkGetBitmapPredefTable
#define TkGetBitmapPredefTable \
	(tkIntStubsPtr->tkGetBitmapPredefTable) /* 105 */
#endif
#ifndef TkGetDisplayList
#define TkGetDisplayList \
	(tkIntStubsPtr->tkGetDisplayList) /* 106 */
#endif
#ifndef TkGetMainInfoList
#define TkGetMainInfoList \
	(tkIntStubsPtr->tkGetMainInfoList) /* 107 */
#endif
#ifndef TkGetWindowFromObj
#define TkGetWindowFromObj \
	(tkIntStubsPtr->tkGetWindowFromObj) /* 108 */
#endif
#ifndef TkpGetString
#define TkpGetString \
	(tkIntStubsPtr->tkpGetString) /* 109 */
#endif
#ifndef TkpGetSubFonts
#define TkpGetSubFonts \
	(tkIntStubsPtr->tkpGetSubFonts) /* 110 */
#endif
#ifndef TkpGetSystemDefault
#define TkpGetSystemDefault \
	(tkIntStubsPtr->tkpGetSystemDefault) /* 111 */
#endif
#ifndef TkpMenuThreadInit
#define TkpMenuThreadInit \
	(tkIntStubsPtr->tkpMenuThreadInit) /* 112 */
#endif
#ifdef __WIN32__ /* WIN */
#ifndef TkClipBox
#define TkClipBox \
	(tkIntStubsPtr->tkClipBox) /* 113 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkClipBox
#define TkClipBox \
	(tkIntStubsPtr->tkClipBox) /* 113 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkCreateRegion
#define TkCreateRegion \
	(tkIntStubsPtr->tkCreateRegion) /* 114 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkCreateRegion
#define TkCreateRegion \
	(tkIntStubsPtr->tkCreateRegion) /* 114 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkDestroyRegion
#define TkDestroyRegion \
	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkDestroyRegion
#define TkDestroyRegion \
	(tkIntStubsPtr->tkDestroyRegion) /* 115 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkIntersectRegion
#define TkIntersectRegion \
	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkIntersectRegion
#define TkIntersectRegion \
	(tkIntStubsPtr->tkIntersectRegion) /* 116 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkRectInRegion
#define TkRectInRegion \
	(tkIntStubsPtr->tkRectInRegion) /* 117 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkRectInRegion
#define TkRectInRegion \
	(tkIntStubsPtr->tkRectInRegion) /* 117 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkSetRegion
#define TkSetRegion \
	(tkIntStubsPtr->tkSetRegion) /* 118 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkSetRegion
#define TkSetRegion \
	(tkIntStubsPtr->tkSetRegion) /* 118 */
#endif
#endif /* AQUA */
#ifdef __WIN32__ /* WIN */
#ifndef TkUnionRectWithRegion
#define TkUnionRectWithRegion \
	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkUnionRectWithRegion
#define TkUnionRectWithRegion \
	(tkIntStubsPtr->tkUnionRectWithRegion) /* 119 */
#endif
#endif /* AQUA */
/* Slot 120 is reserved */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpCreateNativeBitmap
#define TkpCreateNativeBitmap \
	(tkIntStubsPtr->tkpCreateNativeBitmap) /* 121 */
#endif
#endif /* AQUA */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpDefineNativeBitmaps
#define TkpDefineNativeBitmaps \
	(tkIntStubsPtr->tkpDefineNativeBitmaps) /* 122 */
#endif
#endif /* AQUA */
/* Slot 123 is reserved */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkpGetNativeAppBitmap
#define TkpGetNativeAppBitmap \
	(tkIntStubsPtr->tkpGetNativeAppBitmap) /* 124 */
#endif
#endif /* AQUA */
/* Slot 125 is reserved */
/* Slot 126 is reserved */
/* Slot 127 is reserved */
/* Slot 128 is reserved */
/* Slot 129 is reserved */
/* Slot 130 is reserved */
/* Slot 131 is reserved */
/* Slot 132 is reserved */
/* Slot 133 is reserved */
/* Slot 134 is reserved */
#ifndef TkpDrawHighlightBorder
#define TkpDrawHighlightBorder \
	(tkIntStubsPtr->tkpDrawHighlightBorder) /* 135 */
#endif
#ifndef TkSetFocusWin
#define TkSetFocusWin \
	(tkIntStubsPtr->tkSetFocusWin) /* 136 */
#endif
#ifndef TkpSetKeycodeAndState
#define TkpSetKeycodeAndState \
	(tkIntStubsPtr->tkpSetKeycodeAndState) /* 137 */
#endif
#ifndef TkpGetKeySym
#define TkpGetKeySym \
	(tkIntStubsPtr->tkpGetKeySym) /* 138 */
#endif
#ifndef TkpInitKeymapInfo
#define TkpInitKeymapInfo \
	(tkIntStubsPtr->tkpInitKeymapInfo) /* 139 */
#endif
#ifndef TkPhotoGetValidRegion
#define TkPhotoGetValidRegion \
	(tkIntStubsPtr->tkPhotoGetValidRegion) /* 140 */
#endif
#ifndef TkWmStackorderToplevel
#define TkWmStackorderToplevel \
	(tkIntStubsPtr->tkWmStackorderToplevel) /* 141 */
#endif
#ifndef TkFocusFree
#define TkFocusFree \
	(tkIntStubsPtr->tkFocusFree) /* 142 */
#endif
#ifndef TkClipCleanup
#define TkClipCleanup \
	(tkIntStubsPtr->tkClipCleanup) /* 143 */
#endif
#ifndef TkGCCleanup
#define TkGCCleanup \
	(tkIntStubsPtr->tkGCCleanup) /* 144 */
#endif
#ifdef __WIN32__ /* WIN */
#ifndef TkSubtractRegion
#define TkSubtractRegion \
	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkSubtractRegion
#define TkSubtractRegion \
	(tkIntStubsPtr->tkSubtractRegion) /* 145 */
#endif
#endif /* AQUA */
#ifndef TkStylePkgInit
#define TkStylePkgInit \
	(tkIntStubsPtr->tkStylePkgInit) /* 146 */
#endif
#ifndef TkStylePkgFree
#define TkStylePkgFree \
	(tkIntStubsPtr->tkStylePkgFree) /* 147 */
#endif
#ifndef TkToplevelWindowForCommand
#define TkToplevelWindowForCommand \
	(tkIntStubsPtr->tkToplevelWindowForCommand) /* 148 */
#endif
#ifndef TkGetOptionSpec
#define TkGetOptionSpec \
	(tkIntStubsPtr->tkGetOptionSpec) /* 149 */
#endif
#ifndef TkMakeRawCurve
#define TkMakeRawCurve \
	(tkIntStubsPtr->tkMakeRawCurve) /* 150 */
#endif
#ifndef TkMakeRawCurvePostscript
#define TkMakeRawCurvePostscript \
	(tkIntStubsPtr->tkMakeRawCurvePostscript) /* 151 */
#endif
#ifndef TkpDrawFrame
#define TkpDrawFrame \
	(tkIntStubsPtr->tkpDrawFrame) /* 152 */
#endif
#ifndef TkCreateThreadExitHandler
#define TkCreateThreadExitHandler \
	(tkIntStubsPtr->tkCreateThreadExitHandler) /* 153 */
#endif
#ifndef TkDeleteThreadExitHandler
#define TkDeleteThreadExitHandler \
	(tkIntStubsPtr->tkDeleteThreadExitHandler) /* 154 */
#endif
/* Slot 155 is reserved */
#ifndef TkpTestembedCmd
#define TkpTestembedCmd \
	(tkIntStubsPtr->tkpTestembedCmd) /* 156 */
#endif
#ifndef TkpTesttextCmd
#define TkpTesttextCmd \
	(tkIntStubsPtr->tkpTesttextCmd) /* 157 */
#endif
/* Slot 158 is reserved */
/* Slot 159 is reserved */
/* Slot 160 is reserved */
/* Slot 161 is reserved */
/* Slot 162 is reserved */
/* Slot 163 is reserved */
/* Slot 164 is reserved */
/* Slot 165 is reserved */
/* Slot 166 is reserved */
/* Slot 167 is reserved */
/* Slot 168 is reserved */
#ifndef TkStateParseProc
#define TkStateParseProc \
	(tkIntStubsPtr->tkStateParseProc) /* 169 */
#endif
#ifndef TkStatePrintProc
#define TkStatePrintProc \
	(tkIntStubsPtr->tkStatePrintProc) /* 170 */
#endif
#ifndef TkCanvasDashParseProc
#define TkCanvasDashParseProc \
	(tkIntStubsPtr->tkCanvasDashParseProc) /* 171 */
#endif
#ifndef TkCanvasDashPrintProc
#define TkCanvasDashPrintProc \
	(tkIntStubsPtr->tkCanvasDashPrintProc) /* 172 */
#endif
#ifndef TkOffsetParseProc
#define TkOffsetParseProc \
	(tkIntStubsPtr->tkOffsetParseProc) /* 173 */
#endif
#ifndef TkOffsetPrintProc
#define TkOffsetPrintProc \
	(tkIntStubsPtr->tkOffsetPrintProc) /* 174 */
#endif
#ifndef TkPixelParseProc
#define TkPixelParseProc \
	(tkIntStubsPtr->tkPixelParseProc) /* 175 */
#endif
#ifndef TkPixelPrintProc
#define TkPixelPrintProc \
	(tkIntStubsPtr->tkPixelPrintProc) /* 176 */
#endif
#ifndef TkOrientParseProc
#define TkOrientParseProc \
	(tkIntStubsPtr->tkOrientParseProc) /* 177 */
#endif
#ifndef TkOrientPrintProc
#define TkOrientPrintProc \
	(tkIntStubsPtr->tkOrientPrintProc) /* 178 */
#endif
#ifndef TkSmoothParseProc
#define TkSmoothParseProc \
	(tkIntStubsPtr->tkSmoothParseProc) /* 179 */
#endif
#ifndef TkSmoothPrintProc
#define TkSmoothPrintProc \
	(tkIntStubsPtr->tkSmoothPrintProc) /* 180 */
#endif

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTDECLS */

                                                                                                                                                                                                                                                                                                tkIntPlatDecls.h                                                                                    0100644 0001750 0001750 00000104312 11442001432 035440  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkIntPlatDecls.h --
 *
 *	This file contains the declarations for all platform dependent
 *	unsupported functions that are exported by the Tk library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKINTPLATDECLS
#define _TKINTPLATDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tkInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef TkAlignImageData_TCL_DECLARED
#define TkAlignImageData_TCL_DECLARED
/* 0 */
EXTERN char *		TkAlignImageData(XImage *image, int alignment,
				int bitOrder);
#endif
/* Slot 1 is reserved */
#ifndef TkGenerateActivateEvents_TCL_DECLARED
#define TkGenerateActivateEvents_TCL_DECLARED
/* 2 */
EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
				int active);
#endif
#ifndef TkpGetMS_TCL_DECLARED
#define TkpGetMS_TCL_DECLARED
/* 3 */
EXTERN unsigned long	TkpGetMS(void);
#endif
#ifndef TkPointerDeadWindow_TCL_DECLARED
#define TkPointerDeadWindow_TCL_DECLARED
/* 4 */
EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkpPrintWindowId_TCL_DECLARED
#define TkpPrintWindowId_TCL_DECLARED
/* 5 */
EXTERN void		TkpPrintWindowId(char *buf, Window window);
#endif
#ifndef TkpScanWindowId_TCL_DECLARED
#define TkpScanWindowId_TCL_DECLARED
/* 6 */
EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
				CONST char *string, Window *idPtr);
#endif
#ifndef TkpSetCapture_TCL_DECLARED
#define TkpSetCapture_TCL_DECLARED
/* 7 */
EXTERN void		TkpSetCapture(TkWindow *winPtr);
#endif
#ifndef TkpSetCursor_TCL_DECLARED
#define TkpSetCursor_TCL_DECLARED
/* 8 */
EXTERN void		TkpSetCursor(TkpCursor cursor);
#endif
#ifndef TkpWmSetState_TCL_DECLARED
#define TkpWmSetState_TCL_DECLARED
/* 9 */
EXTERN void		TkpWmSetState(TkWindow *winPtr, int state);
#endif
#ifndef TkSetPixmapColormap_TCL_DECLARED
#define TkSetPixmapColormap_TCL_DECLARED
/* 10 */
EXTERN void		TkSetPixmapColormap(Pixmap pixmap, Colormap colormap);
#endif
#ifndef TkWinCancelMouseTimer_TCL_DECLARED
#define TkWinCancelMouseTimer_TCL_DECLARED
/* 11 */
EXTERN void		TkWinCancelMouseTimer(void);
#endif
#ifndef TkWinClipboardRender_TCL_DECLARED
#define TkWinClipboardRender_TCL_DECLARED
/* 12 */
EXTERN void		TkWinClipboardRender(TkDisplay *dispPtr, UINT format);
#endif
#ifndef TkWinEmbeddedEventProc_TCL_DECLARED
#define TkWinEmbeddedEventProc_TCL_DECLARED
/* 13 */
EXTERN LRESULT		TkWinEmbeddedEventProc(HWND hwnd, UINT message,
				WPARAM wParam, LPARAM lParam);
#endif
#ifndef TkWinFillRect_TCL_DECLARED
#define TkWinFillRect_TCL_DECLARED
/* 14 */
EXTERN void		TkWinFillRect(HDC dc, int x, int y, int width,
				int height, int pixel);
#endif
#ifndef TkWinGetBorderPixels_TCL_DECLARED
#define TkWinGetBorderPixels_TCL_DECLARED
/* 15 */
EXTERN COLORREF		TkWinGetBorderPixels(Tk_Window tkwin,
				Tk_3DBorder border, int which);
#endif
#ifndef TkWinGetDrawableDC_TCL_DECLARED
#define TkWinGetDrawableDC_TCL_DECLARED
/* 16 */
EXTERN HDC		TkWinGetDrawableDC(Display *display, Drawable d,
				TkWinDCState *state);
#endif
#ifndef TkWinGetModifierState_TCL_DECLARED
#define TkWinGetModifierState_TCL_DECLARED
/* 17 */
EXTERN int		TkWinGetModifierState(void);
#endif
#ifndef TkWinGetSystemPalette_TCL_DECLARED
#define TkWinGetSystemPalette_TCL_DECLARED
/* 18 */
EXTERN HPALETTE		TkWinGetSystemPalette(void);
#endif
#ifndef TkWinGetWrapperWindow_TCL_DECLARED
#define TkWinGetWrapperWindow_TCL_DECLARED
/* 19 */
EXTERN HWND		TkWinGetWrapperWindow(Tk_Window tkwin);
#endif
#ifndef TkWinHandleMenuEvent_TCL_DECLARED
#define TkWinHandleMenuEvent_TCL_DECLARED
/* 20 */
EXTERN int		TkWinHandleMenuEvent(HWND *phwnd, UINT *pMessage,
				WPARAM *pwParam, LPARAM *plParam,
				LRESULT *plResult);
#endif
#ifndef TkWinIndexOfColor_TCL_DECLARED
#define TkWinIndexOfColor_TCL_DECLARED
/* 21 */
EXTERN int		TkWinIndexOfColor(XColor *colorPtr);
#endif
#ifndef TkWinReleaseDrawableDC_TCL_DECLARED
#define TkWinReleaseDrawableDC_TCL_DECLARED
/* 22 */
EXTERN void		TkWinReleaseDrawableDC(Drawable d, HDC hdc,
				TkWinDCState *state);
#endif
#ifndef TkWinResendEvent_TCL_DECLARED
#define TkWinResendEvent_TCL_DECLARED
/* 23 */
EXTERN LRESULT		TkWinResendEvent(WNDPROC wndproc, HWND hwnd,
				XEvent *eventPtr);
#endif
#ifndef TkWinSelectPalette_TCL_DECLARED
#define TkWinSelectPalette_TCL_DECLARED
/* 24 */
EXTERN HPALETTE		TkWinSelectPalette(HDC dc, Colormap colormap);
#endif
#ifndef TkWinSetMenu_TCL_DECLARED
#define TkWinSetMenu_TCL_DECLARED
/* 25 */
EXTERN void		TkWinSetMenu(Tk_Window tkwin, HMENU hMenu);
#endif
#ifndef TkWinSetWindowPos_TCL_DECLARED
#define TkWinSetWindowPos_TCL_DECLARED
/* 26 */
EXTERN void		TkWinSetWindowPos(HWND hwnd, HWND siblingHwnd,
				int pos);
#endif
#ifndef TkWinWmCleanup_TCL_DECLARED
#define TkWinWmCleanup_TCL_DECLARED
/* 27 */
EXTERN void		TkWinWmCleanup(HINSTANCE hInstance);
#endif
#ifndef TkWinXCleanup_TCL_DECLARED
#define TkWinXCleanup_TCL_DECLARED
/* 28 */
EXTERN void		TkWinXCleanup(ClientData clientData);
#endif
#ifndef TkWinXInit_TCL_DECLARED
#define TkWinXInit_TCL_DECLARED
/* 29 */
EXTERN void		TkWinXInit(HINSTANCE hInstance);
#endif
#ifndef TkWinSetForegroundWindow_TCL_DECLARED
#define TkWinSetForegroundWindow_TCL_DECLARED
/* 30 */
EXTERN void		TkWinSetForegroundWindow(TkWindow *winPtr);
#endif
#ifndef TkWinDialogDebug_TCL_DECLARED
#define TkWinDialogDebug_TCL_DECLARED
/* 31 */
EXTERN void		TkWinDialogDebug(int debug);
#endif
#ifndef TkWinGetMenuSystemDefault_TCL_DECLARED
#define TkWinGetMenuSystemDefault_TCL_DECLARED
/* 32 */
EXTERN Tcl_Obj *	TkWinGetMenuSystemDefault(Tk_Window tkwin,
				CONST char *dbName, CONST char *className);
#endif
#ifndef TkWinGetPlatformId_TCL_DECLARED
#define TkWinGetPlatformId_TCL_DECLARED
/* 33 */
EXTERN int		TkWinGetPlatformId(void);
#endif
#ifndef TkWinSetHINSTANCE_TCL_DECLARED
#define TkWinSetHINSTANCE_TCL_DECLARED
/* 34 */
EXTERN void		TkWinSetHINSTANCE(HINSTANCE hInstance);
#endif
#ifndef TkWinGetPlatformTheme_TCL_DECLARED
#define TkWinGetPlatformTheme_TCL_DECLARED
/* 35 */
EXTERN int		TkWinGetPlatformTheme(void);
#endif
#ifndef TkWinChildProc_TCL_DECLARED
#define TkWinChildProc_TCL_DECLARED
/* 36 */
EXTERN LRESULT CALLBACK	 TkWinChildProc(HWND hwnd, UINT message,
				WPARAM wParam, LPARAM lParam);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkGenerateActivateEvents_TCL_DECLARED
#define TkGenerateActivateEvents_TCL_DECLARED
/* 0 */
EXTERN void		TkGenerateActivateEvents(TkWindow *winPtr,
				int active);
#endif
/* Slot 1 is reserved */
/* Slot 2 is reserved */
#ifndef TkPointerDeadWindow_TCL_DECLARED
#define TkPointerDeadWindow_TCL_DECLARED
/* 3 */
EXTERN void		TkPointerDeadWindow(TkWindow *winPtr);
#endif
#ifndef TkpSetCapture_TCL_DECLARED
#define TkpSetCapture_TCL_DECLARED
/* 4 */
EXTERN void		TkpSetCapture(TkWindow *winPtr);
#endif
#ifndef TkpSetCursor_TCL_DECLARED
#define TkpSetCursor_TCL_DECLARED
/* 5 */
EXTERN void		TkpSetCursor(TkpCursor cursor);
#endif
#ifndef TkpWmSetState_TCL_DECLARED
#define TkpWmSetState_TCL_DECLARED
/* 6 */
EXTERN void		TkpWmSetState(TkWindow *winPtr, int state);
#endif
#ifndef TkAboutDlg_TCL_DECLARED
#define TkAboutDlg_TCL_DECLARED
/* 7 */
EXTERN void		TkAboutDlg(void);
#endif
#ifndef TkMacOSXButtonKeyState_TCL_DECLARED
#define TkMacOSXButtonKeyState_TCL_DECLARED
/* 8 */
EXTERN unsigned int	TkMacOSXButtonKeyState(void);
#endif
#ifndef TkMacOSXClearMenubarActive_TCL_DECLARED
#define TkMacOSXClearMenubarActive_TCL_DECLARED
/* 9 */
EXTERN void		TkMacOSXClearMenubarActive(void);
#endif
#ifndef TkMacOSXDispatchMenuEvent_TCL_DECLARED
#define TkMacOSXDispatchMenuEvent_TCL_DECLARED
/* 10 */
EXTERN int		TkMacOSXDispatchMenuEvent(int menuID, int index);
#endif
#ifndef TkMacOSXInstallCursor_TCL_DECLARED
#define TkMacOSXInstallCursor_TCL_DECLARED
/* 11 */
EXTERN void		TkMacOSXInstallCursor(int resizeOverride);
#endif
#ifndef TkMacOSXHandleTearoffMenu_TCL_DECLARED
#define TkMacOSXHandleTearoffMenu_TCL_DECLARED
/* 12 */
EXTERN void		TkMacOSXHandleTearoffMenu(void);
#endif
/* Slot 13 is reserved */
#ifndef TkMacOSXDoHLEvent_TCL_DECLARED
#define TkMacOSXDoHLEvent_TCL_DECLARED
/* 14 */
EXTERN int		TkMacOSXDoHLEvent(void *theEvent);
#endif
/* Slot 15 is reserved */
#ifndef TkMacOSXGetXWindow_TCL_DECLARED
#define TkMacOSXGetXWindow_TCL_DECLARED
/* 16 */
EXTERN Window		TkMacOSXGetXWindow(void *macWinPtr);
#endif
#ifndef TkMacOSXGrowToplevel_TCL_DECLARED
#define TkMacOSXGrowToplevel_TCL_DECLARED
/* 17 */
EXTERN int		TkMacOSXGrowToplevel(void *whichWindow, XPoint start);
#endif
#ifndef TkMacOSXHandleMenuSelect_TCL_DECLARED
#define TkMacOSXHandleMenuSelect_TCL_DECLARED
/* 18 */
EXTERN void		TkMacOSXHandleMenuSelect(short theMenu,
				unsigned short theItem, int optionKeyPressed);
#endif
/* Slot 19 is reserved */
/* Slot 20 is reserved */
#ifndef TkMacOSXInvalidateWindow_TCL_DECLARED
#define TkMacOSXInvalidateWindow_TCL_DECLARED
/* 21 */
EXTERN void		TkMacOSXInvalidateWindow(MacDrawable *macWin,
				int flag);
#endif
#ifndef TkMacOSXIsCharacterMissing_TCL_DECLARED
#define TkMacOSXIsCharacterMissing_TCL_DECLARED
/* 22 */
EXTERN int		TkMacOSXIsCharacterMissing(Tk_Font tkfont,
				unsigned int searchChar);
#endif
#ifndef TkMacOSXMakeRealWindowExist_TCL_DECLARED
#define TkMacOSXMakeRealWindowExist_TCL_DECLARED
/* 23 */
EXTERN void		TkMacOSXMakeRealWindowExist(TkWindow *winPtr);
#endif
#ifndef TkMacOSXMakeStippleMap_TCL_DECLARED
#define TkMacOSXMakeStippleMap_TCL_DECLARED
/* 24 */
EXTERN void *		TkMacOSXMakeStippleMap(Drawable d1, Drawable d2);
#endif
#ifndef TkMacOSXMenuClick_TCL_DECLARED
#define TkMacOSXMenuClick_TCL_DECLARED
/* 25 */
EXTERN void		TkMacOSXMenuClick(void);
#endif
#ifndef TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
#define TkMacOSXRegisterOffScreenWindow_TCL_DECLARED
/* 26 */
EXTERN void		TkMacOSXRegisterOffScreenWindow(Window window,
				void *portPtr);
#endif
#ifndef TkMacOSXResizable_TCL_DECLARED
#define TkMacOSXResizable_TCL_DECLARED
/* 27 */
EXTERN int		TkMacOSXResizable(TkWindow *winPtr);
#endif
#ifndef TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
#define TkMacOSXSetHelpMenuItemCount_TCL_DECLARED
/* 28 */
EXTERN void		TkMacOSXSetHelpMenuItemCount(void);
#endif
#ifndef TkMacOSXSetScrollbarGrow_TCL_DECLARED
#define TkMacOSXSetScrollbarGrow_TCL_DECLARED
/* 29 */
EXTERN void		TkMacOSXSetScrollbarGrow(TkWindow *winPtr, int flag);
#endif
#ifndef TkMacOSXSetUpClippingRgn_TCL_DECLARED
#define TkMacOSXSetUpClippingRgn_TCL_DECLARED
/* 30 */
EXTERN void		TkMacOSXSetUpClippingRgn(Drawable drawable);
#endif
#ifndef TkMacOSXSetUpGraphicsPort_TCL_DECLARED
#define TkMacOSXSetUpGraphicsPort_TCL_DECLARED
/* 31 */
EXTERN void		TkMacOSXSetUpGraphicsPort(GC gc, void *destPort);
#endif
#ifndef TkMacOSXUpdateClipRgn_TCL_DECLARED
#define TkMacOSXUpdateClipRgn_TCL_DECLARED
/* 32 */
EXTERN void		TkMacOSXUpdateClipRgn(TkWindow *winPtr);
#endif
#ifndef TkMacOSXUnregisterMacWindow_TCL_DECLARED
#define TkMacOSXUnregisterMacWindow_TCL_DECLARED
/* 33 */
EXTERN void		TkMacOSXUnregisterMacWindow(void *portPtr);
#endif
#ifndef TkMacOSXUseMenuID_TCL_DECLARED
#define TkMacOSXUseMenuID_TCL_DECLARED
/* 34 */
EXTERN int		TkMacOSXUseMenuID(short macID);
#endif
#ifndef TkMacOSXVisableClipRgn_TCL_DECLARED
#define TkMacOSXVisableClipRgn_TCL_DECLARED
/* 35 */
EXTERN TkRegion		TkMacOSXVisableClipRgn(TkWindow *winPtr);
#endif
#ifndef TkMacOSXWinBounds_TCL_DECLARED
#define TkMacOSXWinBounds_TCL_DECLARED
/* 36 */
EXTERN void		TkMacOSXWinBounds(TkWindow *winPtr, void *geometry);
#endif
#ifndef TkMacOSXWindowOffset_TCL_DECLARED
#define TkMacOSXWindowOffset_TCL_DECLARED
/* 37 */
EXTERN void		TkMacOSXWindowOffset(void *wRef, int *xOffset,
				int *yOffset);
#endif
#ifndef TkSetMacColor_TCL_DECLARED
#define TkSetMacColor_TCL_DECLARED
/* 38 */
EXTERN int		TkSetMacColor(unsigned long pixel, void *macColor);
#endif
#ifndef TkSetWMName_TCL_DECLARED
#define TkSetWMName_TCL_DECLARED
/* 39 */
EXTERN void		TkSetWMName(TkWindow *winPtr, Tk_Uid titleUid);
#endif
#ifndef TkSuspendClipboard_TCL_DECLARED
#define TkSuspendClipboard_TCL_DECLARED
/* 40 */
EXTERN void		TkSuspendClipboard(void);
#endif
#ifndef TkMacOSXZoomToplevel_TCL_DECLARED
#define TkMacOSXZoomToplevel_TCL_DECLARED
/* 41 */
EXTERN int		TkMacOSXZoomToplevel(void *whichWindow,
				short zoomPart);
#endif
#ifndef Tk_TopCoordsToWindow_TCL_DECLARED
#define Tk_TopCoordsToWindow_TCL_DECLARED
/* 42 */
EXTERN Tk_Window	Tk_TopCoordsToWindow(Tk_Window tkwin, int rootX,
				int rootY, int *newX, int *newY);
#endif
#ifndef TkMacOSXContainerId_TCL_DECLARED
#define TkMacOSXContainerId_TCL_DECLARED
/* 43 */
EXTERN MacDrawable *	TkMacOSXContainerId(TkWindow *winPtr);
#endif
#ifndef TkMacOSXGetHostToplevel_TCL_DECLARED
#define TkMacOSXGetHostToplevel_TCL_DECLARED
/* 44 */
EXTERN MacDrawable *	TkMacOSXGetHostToplevel(TkWindow *winPtr);
#endif
#ifndef TkMacOSXPreprocessMenu_TCL_DECLARED
#define TkMacOSXPreprocessMenu_TCL_DECLARED
/* 45 */
EXTERN void		TkMacOSXPreprocessMenu(void);
#endif
#ifndef TkpIsWindowFloating_TCL_DECLARED
#define TkpIsWindowFloating_TCL_DECLARED
/* 46 */
EXTERN int		TkpIsWindowFloating(void *window);
#endif
#ifndef TkMacOSXGetCapture_TCL_DECLARED
#define TkMacOSXGetCapture_TCL_DECLARED
/* 47 */
EXTERN Tk_Window	TkMacOSXGetCapture(void);
#endif
/* Slot 48 is reserved */
#ifndef TkGetTransientMaster_TCL_DECLARED
#define TkGetTransientMaster_TCL_DECLARED
/* 49 */
EXTERN Window		TkGetTransientMaster(TkWindow *winPtr);
#endif
#ifndef TkGenerateButtonEvent_TCL_DECLARED
#define TkGenerateButtonEvent_TCL_DECLARED
/* 50 */
EXTERN int		TkGenerateButtonEvent(int x, int y, Window window,
				unsigned int state);
#endif
#ifndef TkGenWMDestroyEvent_TCL_DECLARED
#define TkGenWMDestroyEvent_TCL_DECLARED
/* 51 */
EXTERN void		TkGenWMDestroyEvent(Tk_Window tkwin);
#endif
/* Slot 52 is reserved */
#ifndef TkpGetMS_TCL_DECLARED
#define TkpGetMS_TCL_DECLARED
/* 53 */
EXTERN unsigned long	TkpGetMS(void);
#endif
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
#ifndef TkCreateXEventSource_TCL_DECLARED
#define TkCreateXEventSource_TCL_DECLARED
/* 0 */
EXTERN void		TkCreateXEventSource(void);
#endif
#ifndef TkFreeWindowId_TCL_DECLARED
#define TkFreeWindowId_TCL_DECLARED
/* 1 */
EXTERN void		TkFreeWindowId(TkDisplay *dispPtr, Window w);
#endif
#ifndef TkInitXId_TCL_DECLARED
#define TkInitXId_TCL_DECLARED
/* 2 */
EXTERN void		TkInitXId(TkDisplay *dispPtr);
#endif
#ifndef TkpCmapStressed_TCL_DECLARED
#define TkpCmapStressed_TCL_DECLARED
/* 3 */
EXTERN int		TkpCmapStressed(Tk_Window tkwin, Colormap colormap);
#endif
#ifndef TkpSync_TCL_DECLARED
#define TkpSync_TCL_DECLARED
/* 4 */
EXTERN void		TkpSync(Display *display);
#endif
#ifndef TkUnixContainerId_TCL_DECLARED
#define TkUnixContainerId_TCL_DECLARED
/* 5 */
EXTERN Window		TkUnixContainerId(TkWindow *winPtr);
#endif
#ifndef TkUnixDoOneXEvent_TCL_DECLARED
#define TkUnixDoOneXEvent_TCL_DECLARED
/* 6 */
EXTERN int		TkUnixDoOneXEvent(Tcl_Time *timePtr);
#endif
#ifndef TkUnixSetMenubar_TCL_DECLARED
#define TkUnixSetMenubar_TCL_DECLARED
/* 7 */
EXTERN void		TkUnixSetMenubar(Tk_Window tkwin, Tk_Window menubar);
#endif
#ifndef TkpScanWindowId_TCL_DECLARED
#define TkpScanWindowId_TCL_DECLARED
/* 8 */
EXTERN int		TkpScanWindowId(Tcl_Interp *interp,
				CONST char *string, Window *idPtr);
#endif
#ifndef TkWmCleanup_TCL_DECLARED
#define TkWmCleanup_TCL_DECLARED
/* 9 */
EXTERN void		TkWmCleanup(TkDisplay *dispPtr);
#endif
#ifndef TkSendCleanup_TCL_DECLARED
#define TkSendCleanup_TCL_DECLARED
/* 10 */
EXTERN void		TkSendCleanup(TkDisplay *dispPtr);
#endif
#ifndef TkFreeXId_TCL_DECLARED
#define TkFreeXId_TCL_DECLARED
/* 11 */
EXTERN void		TkFreeXId(TkDisplay *dispPtr);
#endif
#ifndef TkpWmSetState_TCL_DECLARED
#define TkpWmSetState_TCL_DECLARED
/* 12 */
EXTERN int		TkpWmSetState(TkWindow *winPtr, int state);
#endif
#ifndef TkpTestsendCmd_TCL_DECLARED
#define TkpTestsendCmd_TCL_DECLARED
/* 13 */
EXTERN int		TkpTestsendCmd(ClientData clientData,
				Tcl_Interp *interp, int argc,
				CONST char **argv);
#endif
#endif /* X11 */

typedef struct TkIntPlatStubs {
    int magic;
    struct TkIntPlatStubHooks *hooks;

#ifdef __WIN32__ /* WIN */
    char * (*tkAlignImageData) (XImage *image, int alignment, int bitOrder); /* 0 */
    void *reserved1;
    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 2 */
    unsigned long (*tkpGetMS) (void); /* 3 */
    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 4 */
    void (*tkpPrintWindowId) (char *buf, Window window); /* 5 */
    int (*tkpScanWindowId) (Tcl_Interp *interp, CONST char *string, Window *idPtr); /* 6 */
    void (*tkpSetCapture) (TkWindow *winPtr); /* 7 */
    void (*tkpSetCursor) (TkpCursor cursor); /* 8 */
    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 9 */
    void (*tkSetPixmapColormap) (Pixmap pixmap, Colormap colormap); /* 10 */
    void (*tkWinCancelMouseTimer) (void); /* 11 */
    void (*tkWinClipboardRender) (TkDisplay *dispPtr, UINT format); /* 12 */
    LRESULT (*tkWinEmbeddedEventProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 13 */
    void (*tkWinFillRect) (HDC dc, int x, int y, int width, int height, int pixel); /* 14 */
    COLORREF (*tkWinGetBorderPixels) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 15 */
    HDC (*tkWinGetDrawableDC) (Display *display, Drawable d, TkWinDCState *state); /* 16 */
    int (*tkWinGetModifierState) (void); /* 17 */
    HPALETTE (*tkWinGetSystemPalette) (void); /* 18 */
    HWND (*tkWinGetWrapperWindow) (Tk_Window tkwin); /* 19 */
    int (*tkWinHandleMenuEvent) (HWND *phwnd, UINT *pMessage, WPARAM *pwParam, LPARAM *plParam, LRESULT *plResult); /* 20 */
    int (*tkWinIndexOfColor) (XColor *colorPtr); /* 21 */
    void (*tkWinReleaseDrawableDC) (Drawable d, HDC hdc, TkWinDCState *state); /* 22 */
    LRESULT (*tkWinResendEvent) (WNDPROC wndproc, HWND hwnd, XEvent *eventPtr); /* 23 */
    HPALETTE (*tkWinSelectPalette) (HDC dc, Colormap colormap); /* 24 */
    void (*tkWinSetMenu) (Tk_Window tkwin, HMENU hMenu); /* 25 */
    void (*tkWinSetWindowPos) (HWND hwnd, HWND siblingHwnd, int pos); /* 26 */
    void (*tkWinWmCleanup) (HINSTANCE hInstance); /* 27 */
    void (*tkWinXCleanup) (ClientData clientData); /* 28 */
    void (*tkWinXInit) (HINSTANCE hInstance); /* 29 */
    void (*tkWinSetForegroundWindow) (TkWindow *winPtr); /* 30 */
    void (*tkWinDialogDebug) (int debug); /* 31 */
    Tcl_Obj * (*tkWinGetMenuSystemDefault) (Tk_Window tkwin, CONST char *dbName, CONST char *className); /* 32 */
    int (*tkWinGetPlatformId) (void); /* 33 */
    void (*tkWinSetHINSTANCE) (HINSTANCE hInstance); /* 34 */
    int (*tkWinGetPlatformTheme) (void); /* 35 */
    LRESULT (CALLBACK *tkWinChildProc) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); /* 36 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void (*tkGenerateActivateEvents) (TkWindow *winPtr, int active); /* 0 */
    void *reserved1;
    void *reserved2;
    void (*tkPointerDeadWindow) (TkWindow *winPtr); /* 3 */
    void (*tkpSetCapture) (TkWindow *winPtr); /* 4 */
    void (*tkpSetCursor) (TkpCursor cursor); /* 5 */
    void (*tkpWmSetState) (TkWindow *winPtr, int state); /* 6 */
    void (*tkAboutDlg) (void); /* 7 */
    unsigned int (*tkMacOSXButtonKeyState) (void); /* 8 */
    void (*tkMacOSXClearMenubarActive) (void); /* 9 */
    int (*tkMacOSXDispatchMenuEvent) (int menuID, int index); /* 10 */
    void (*tkMacOSXInstallCursor) (int resizeOverride); /* 11 */
    void (*tkMacOSXHandleTearoffMenu) (void); /* 12 */
    void *reserved13;
    int (*tkMacOSXDoHLEvent) (void *theEvent); /* 14 */
    void *reserved15;
    Window (*tkMacOSXGetXWindow) (void *macWinPtr); /* 16 */
    int (*tkMacOSXGrowToplevel) (void *whichWindow, XPoint start); /* 17 */
    void (*tkMacOSXHandleMenuSelect) (short theMenu, unsigned short theItem, int optionKeyPressed); /* 18 */
    void *reserved19;
    void *reserved20;
    void (*tkMacOSXInvalidateWindow) (MacDrawable *macWin, int flag); /* 21 */
    int (*tkMacOSXIsCharacterMissing) (Tk_Font tkfont, unsigned int searchChar); /* 22 */
    void (*tkMacOSXMakeRealWindowExist) (TkWindow *winPtr); /* 23 */
    void * (*tkMacOSXMakeStippleMap) (Drawable d1, Drawable d2); /* 24 */
    void (*tkMacOSXMenuClick) (void); /* 25 */
    void (*tkMacOSXRegisterOffScreenWindow) (Window window, void *portPtr); /* 26 */
    int (*tkMacOSXResizable) (TkWindow *winPtr); /* 27 */
    void (*tkMacOSXSetHelpMenuItemCount) (void); /* 28 */
    void (*tkMacOSXSetScrollbarGrow) (TkWindow *winPtr, int flag); /* 29 */
    void (*tkMacOSXSetUpClippingRgn) (Drawable drawable); /* 30 */
    void (*tkMacOSXSetUpGraphicsPort) (GC gc, void *destPort); /* 31 */
    void (*tkMacOSXUpdateClipRgn) (TkWindow *winPtr); /* 32 */
    void (*tkMacOSXUnregisterMacWindow) (void *portPtr); /* 33 */
    int (*tkMacOSXUseMenuID) (short macID); /* 34 */
    TkRegion (*tkMacOSXVisableClipRgn) (TkWindow *winPtr); /* 35 */
    void (*tkMacOSXWinBounds) (TkWindow *winPtr, void *geometry); /* 36 */
    void (*tkMacOSXWindowOffset) (void *wRef, int *xOffset, int *yOffset); /* 37 */
    int (*tkSetMacColor) (unsigned long pixel, void *macColor); /* 38 */
    void (*tkSetWMName) (TkWindow *winPtr, Tk_Uid titleUid); /* 39 */
    void (*tkSuspendClipboard) (void); /* 40 */
    int (*tkMacOSXZoomToplevel) (void *whichWindow, short zoomPart); /* 41 */
    Tk_Window (*tk_TopCoordsToWindow) (Tk_Window tkwin, int rootX, int rootY, int *newX, int *newY); /* 42 */
    MacDrawable * (*tkMacOSXContainerId) (TkWindow *winPtr); /* 43 */
    MacDrawable * (*tkMacOSXGetHostToplevel) (TkWindow *winPtr); /* 44 */
    void (*tkMacOSXPreprocessMenu) (void); /* 45 */
    int (*tkpIsWindowFloating) (void *window); /* 46 */
    Tk_Window (*tkMacOSXGetCapture) (void); /* 47 */
    void *reserved48;
    Window (*tkGetTransientMaster) (TkWindow *winPtr); /* 49 */
    int (*tkGenerateButtonEvent) (int x, int y, Window window, unsigned int state); /* 50 */
    void (*tkGenWMDestroyEvent) (Tk_Window tkwin); /* 51 */
    void *reserved52;
    unsigned long (*tkpGetMS) (void); /* 53 */
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
    void (*tkCreateXEventSource) (void); /* 0 */
    void (*tkFreeWindowId) (TkDisplay *dispPtr, Window w); /* 1 */
    void (*tkInitXId) (TkDisplay *dispPtr); /* 2 */
    int (*tkpCmapStressed) (Tk_Window tkwin, Colormap colormap); /* 3 */
    void (*tkpSync) (Display *display); /* 4 */
    Window (*tkUnixContainerId) (TkWindow *winPtr); /* 5 */
    int (*tkUnixDoOneXEvent) (Tcl_Time *timePtr); /* 6 */
    void (*tkUnixSetMenubar) (Tk_Window tkwin, Tk_Window menubar); /* 7 */
    int (*tkpScanWindowId) (Tcl_Interp *interp, CONST char *string, Window *idPtr); /* 8 */
    void (*tkWmCleanup) (TkDisplay *dispPtr); /* 9 */
    void (*tkSendCleanup) (TkDisplay *dispPtr); /* 10 */
    void (*tkFreeXId) (TkDisplay *dispPtr); /* 11 */
    int (*tkpWmSetState) (TkWindow *winPtr, int state); /* 12 */
    int (*tkpTestsendCmd) (ClientData clientData, Tcl_Interp *interp, int argc, CONST char **argv); /* 13 */
#endif /* X11 */
} TkIntPlatStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntPlatStubs *tkIntPlatStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef TkAlignImageData
#define TkAlignImageData \
	(tkIntPlatStubsPtr->tkAlignImageData) /* 0 */
#endif
/* Slot 1 is reserved */
#ifndef TkGenerateActivateEvents
#define TkGenerateActivateEvents \
	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 2 */
#endif
#ifndef TkpGetMS
#define TkpGetMS \
	(tkIntPlatStubsPtr->tkpGetMS) /* 3 */
#endif
#ifndef TkPointerDeadWindow
#define TkPointerDeadWindow \
	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 4 */
#endif
#ifndef TkpPrintWindowId
#define TkpPrintWindowId \
	(tkIntPlatStubsPtr->tkpPrintWindowId) /* 5 */
#endif
#ifndef TkpScanWindowId
#define TkpScanWindowId \
	(tkIntPlatStubsPtr->tkpScanWindowId) /* 6 */
#endif
#ifndef TkpSetCapture
#define TkpSetCapture \
	(tkIntPlatStubsPtr->tkpSetCapture) /* 7 */
#endif
#ifndef TkpSetCursor
#define TkpSetCursor \
	(tkIntPlatStubsPtr->tkpSetCursor) /* 8 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 9 */
#endif
#ifndef TkSetPixmapColormap
#define TkSetPixmapColormap \
	(tkIntPlatStubsPtr->tkSetPixmapColormap) /* 10 */
#endif
#ifndef TkWinCancelMouseTimer
#define TkWinCancelMouseTimer \
	(tkIntPlatStubsPtr->tkWinCancelMouseTimer) /* 11 */
#endif
#ifndef TkWinClipboardRender
#define TkWinClipboardRender \
	(tkIntPlatStubsPtr->tkWinClipboardRender) /* 12 */
#endif
#ifndef TkWinEmbeddedEventProc
#define TkWinEmbeddedEventProc \
	(tkIntPlatStubsPtr->tkWinEmbeddedEventProc) /* 13 */
#endif
#ifndef TkWinFillRect
#define TkWinFillRect \
	(tkIntPlatStubsPtr->tkWinFillRect) /* 14 */
#endif
#ifndef TkWinGetBorderPixels
#define TkWinGetBorderPixels \
	(tkIntPlatStubsPtr->tkWinGetBorderPixels) /* 15 */
#endif
#ifndef TkWinGetDrawableDC
#define TkWinGetDrawableDC \
	(tkIntPlatStubsPtr->tkWinGetDrawableDC) /* 16 */
#endif
#ifndef TkWinGetModifierState
#define TkWinGetModifierState \
	(tkIntPlatStubsPtr->tkWinGetModifierState) /* 17 */
#endif
#ifndef TkWinGetSystemPalette
#define TkWinGetSystemPalette \
	(tkIntPlatStubsPtr->tkWinGetSystemPalette) /* 18 */
#endif
#ifndef TkWinGetWrapperWindow
#define TkWinGetWrapperWindow \
	(tkIntPlatStubsPtr->tkWinGetWrapperWindow) /* 19 */
#endif
#ifndef TkWinHandleMenuEvent
#define TkWinHandleMenuEvent \
	(tkIntPlatStubsPtr->tkWinHandleMenuEvent) /* 20 */
#endif
#ifndef TkWinIndexOfColor
#define TkWinIndexOfColor \
	(tkIntPlatStubsPtr->tkWinIndexOfColor) /* 21 */
#endif
#ifndef TkWinReleaseDrawableDC
#define TkWinReleaseDrawableDC \
	(tkIntPlatStubsPtr->tkWinReleaseDrawableDC) /* 22 */
#endif
#ifndef TkWinResendEvent
#define TkWinResendEvent \
	(tkIntPlatStubsPtr->tkWinResendEvent) /* 23 */
#endif
#ifndef TkWinSelectPalette
#define TkWinSelectPalette \
	(tkIntPlatStubsPtr->tkWinSelectPalette) /* 24 */
#endif
#ifndef TkWinSetMenu
#define TkWinSetMenu \
	(tkIntPlatStubsPtr->tkWinSetMenu) /* 25 */
#endif
#ifndef TkWinSetWindowPos
#define TkWinSetWindowPos \
	(tkIntPlatStubsPtr->tkWinSetWindowPos) /* 26 */
#endif
#ifndef TkWinWmCleanup
#define TkWinWmCleanup \
	(tkIntPlatStubsPtr->tkWinWmCleanup) /* 27 */
#endif
#ifndef TkWinXCleanup
#define TkWinXCleanup \
	(tkIntPlatStubsPtr->tkWinXCleanup) /* 28 */
#endif
#ifndef TkWinXInit
#define TkWinXInit \
	(tkIntPlatStubsPtr->tkWinXInit) /* 29 */
#endif
#ifndef TkWinSetForegroundWindow
#define TkWinSetForegroundWindow \
	(tkIntPlatStubsPtr->tkWinSetForegroundWindow) /* 30 */
#endif
#ifndef TkWinDialogDebug
#define TkWinDialogDebug \
	(tkIntPlatStubsPtr->tkWinDialogDebug) /* 31 */
#endif
#ifndef TkWinGetMenuSystemDefault
#define TkWinGetMenuSystemDefault \
	(tkIntPlatStubsPtr->tkWinGetMenuSystemDefault) /* 32 */
#endif
#ifndef TkWinGetPlatformId
#define TkWinGetPlatformId \
	(tkIntPlatStubsPtr->tkWinGetPlatformId) /* 33 */
#endif
#ifndef TkWinSetHINSTANCE
#define TkWinSetHINSTANCE \
	(tkIntPlatStubsPtr->tkWinSetHINSTANCE) /* 34 */
#endif
#ifndef TkWinGetPlatformTheme
#define TkWinGetPlatformTheme \
	(tkIntPlatStubsPtr->tkWinGetPlatformTheme) /* 35 */
#endif
#ifndef TkWinChildProc
#define TkWinChildProc \
	(tkIntPlatStubsPtr->tkWinChildProc) /* 36 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef TkGenerateActivateEvents
#define TkGenerateActivateEvents \
	(tkIntPlatStubsPtr->tkGenerateActivateEvents) /* 0 */
#endif
/* Slot 1 is reserved */
/* Slot 2 is reserved */
#ifndef TkPointerDeadWindow
#define TkPointerDeadWindow \
	(tkIntPlatStubsPtr->tkPointerDeadWindow) /* 3 */
#endif
#ifndef TkpSetCapture
#define TkpSetCapture \
	(tkIntPlatStubsPtr->tkpSetCapture) /* 4 */
#endif
#ifndef TkpSetCursor
#define TkpSetCursor \
	(tkIntPlatStubsPtr->tkpSetCursor) /* 5 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 6 */
#endif
#ifndef TkAboutDlg
#define TkAboutDlg \
	(tkIntPlatStubsPtr->tkAboutDlg) /* 7 */
#endif
#ifndef TkMacOSXButtonKeyState
#define TkMacOSXButtonKeyState \
	(tkIntPlatStubsPtr->tkMacOSXButtonKeyState) /* 8 */
#endif
#ifndef TkMacOSXClearMenubarActive
#define TkMacOSXClearMenubarActive \
	(tkIntPlatStubsPtr->tkMacOSXClearMenubarActive) /* 9 */
#endif
#ifndef TkMacOSXDispatchMenuEvent
#define TkMacOSXDispatchMenuEvent \
	(tkIntPlatStubsPtr->tkMacOSXDispatchMenuEvent) /* 10 */
#endif
#ifndef TkMacOSXInstallCursor
#define TkMacOSXInstallCursor \
	(tkIntPlatStubsPtr->tkMacOSXInstallCursor) /* 11 */
#endif
#ifndef TkMacOSXHandleTearoffMenu
#define TkMacOSXHandleTearoffMenu \
	(tkIntPlatStubsPtr->tkMacOSXHandleTearoffMenu) /* 12 */
#endif
/* Slot 13 is reserved */
#ifndef TkMacOSXDoHLEvent
#define TkMacOSXDoHLEvent \
	(tkIntPlatStubsPtr->tkMacOSXDoHLEvent) /* 14 */
#endif
/* Slot 15 is reserved */
#ifndef TkMacOSXGetXWindow
#define TkMacOSXGetXWindow \
	(tkIntPlatStubsPtr->tkMacOSXGetXWindow) /* 16 */
#endif
#ifndef TkMacOSXGrowToplevel
#define TkMacOSXGrowToplevel \
	(tkIntPlatStubsPtr->tkMacOSXGrowToplevel) /* 17 */
#endif
#ifndef TkMacOSXHandleMenuSelect
#define TkMacOSXHandleMenuSelect \
	(tkIntPlatStubsPtr->tkMacOSXHandleMenuSelect) /* 18 */
#endif
/* Slot 19 is reserved */
/* Slot 20 is reserved */
#ifndef TkMacOSXInvalidateWindow
#define TkMacOSXInvalidateWindow \
	(tkIntPlatStubsPtr->tkMacOSXInvalidateWindow) /* 21 */
#endif
#ifndef TkMacOSXIsCharacterMissing
#define TkMacOSXIsCharacterMissing \
	(tkIntPlatStubsPtr->tkMacOSXIsCharacterMissing) /* 22 */
#endif
#ifndef TkMacOSXMakeRealWindowExist
#define TkMacOSXMakeRealWindowExist \
	(tkIntPlatStubsPtr->tkMacOSXMakeRealWindowExist) /* 23 */
#endif
#ifndef TkMacOSXMakeStippleMap
#define TkMacOSXMakeStippleMap \
	(tkIntPlatStubsPtr->tkMacOSXMakeStippleMap) /* 24 */
#endif
#ifndef TkMacOSXMenuClick
#define TkMacOSXMenuClick \
	(tkIntPlatStubsPtr->tkMacOSXMenuClick) /* 25 */
#endif
#ifndef TkMacOSXRegisterOffScreenWindow
#define TkMacOSXRegisterOffScreenWindow \
	(tkIntPlatStubsPtr->tkMacOSXRegisterOffScreenWindow) /* 26 */
#endif
#ifndef TkMacOSXResizable
#define TkMacOSXResizable \
	(tkIntPlatStubsPtr->tkMacOSXResizable) /* 27 */
#endif
#ifndef TkMacOSXSetHelpMenuItemCount
#define TkMacOSXSetHelpMenuItemCount \
	(tkIntPlatStubsPtr->tkMacOSXSetHelpMenuItemCount) /* 28 */
#endif
#ifndef TkMacOSXSetScrollbarGrow
#define TkMacOSXSetScrollbarGrow \
	(tkIntPlatStubsPtr->tkMacOSXSetScrollbarGrow) /* 29 */
#endif
#ifndef TkMacOSXSetUpClippingRgn
#define TkMacOSXSetUpClippingRgn \
	(tkIntPlatStubsPtr->tkMacOSXSetUpClippingRgn) /* 30 */
#endif
#ifndef TkMacOSXSetUpGraphicsPort
#define TkMacOSXSetUpGraphicsPort \
	(tkIntPlatStubsPtr->tkMacOSXSetUpGraphicsPort) /* 31 */
#endif
#ifndef TkMacOSXUpdateClipRgn
#define TkMacOSXUpdateClipRgn \
	(tkIntPlatStubsPtr->tkMacOSXUpdateClipRgn) /* 32 */
#endif
#ifndef TkMacOSXUnregisterMacWindow
#define TkMacOSXUnregisterMacWindow \
	(tkIntPlatStubsPtr->tkMacOSXUnregisterMacWindow) /* 33 */
#endif
#ifndef TkMacOSXUseMenuID
#define TkMacOSXUseMenuID \
	(tkIntPlatStubsPtr->tkMacOSXUseMenuID) /* 34 */
#endif
#ifndef TkMacOSXVisableClipRgn
#define TkMacOSXVisableClipRgn \
	(tkIntPlatStubsPtr->tkMacOSXVisableClipRgn) /* 35 */
#endif
#ifndef TkMacOSXWinBounds
#define TkMacOSXWinBounds \
	(tkIntPlatStubsPtr->tkMacOSXWinBounds) /* 36 */
#endif
#ifndef TkMacOSXWindowOffset
#define TkMacOSXWindowOffset \
	(tkIntPlatStubsPtr->tkMacOSXWindowOffset) /* 37 */
#endif
#ifndef TkSetMacColor
#define TkSetMacColor \
	(tkIntPlatStubsPtr->tkSetMacColor) /* 38 */
#endif
#ifndef TkSetWMName
#define TkSetWMName \
	(tkIntPlatStubsPtr->tkSetWMName) /* 39 */
#endif
#ifndef TkSuspendClipboard
#define TkSuspendClipboard \
	(tkIntPlatStubsPtr->tkSuspendClipboard) /* 40 */
#endif
#ifndef TkMacOSXZoomToplevel
#define TkMacOSXZoomToplevel \
	(tkIntPlatStubsPtr->tkMacOSXZoomToplevel) /* 41 */
#endif
#ifndef Tk_TopCoordsToWindow
#define Tk_TopCoordsToWindow \
	(tkIntPlatStubsPtr->tk_TopCoordsToWindow) /* 42 */
#endif
#ifndef TkMacOSXContainerId
#define TkMacOSXContainerId \
	(tkIntPlatStubsPtr->tkMacOSXContainerId) /* 43 */
#endif
#ifndef TkMacOSXGetHostToplevel
#define TkMacOSXGetHostToplevel \
	(tkIntPlatStubsPtr->tkMacOSXGetHostToplevel) /* 44 */
#endif
#ifndef TkMacOSXPreprocessMenu
#define TkMacOSXPreprocessMenu \
	(tkIntPlatStubsPtr->tkMacOSXPreprocessMenu) /* 45 */
#endif
#ifndef TkpIsWindowFloating
#define TkpIsWindowFloating \
	(tkIntPlatStubsPtr->tkpIsWindowFloating) /* 46 */
#endif
#ifndef TkMacOSXGetCapture
#define TkMacOSXGetCapture \
	(tkIntPlatStubsPtr->tkMacOSXGetCapture) /* 47 */
#endif
/* Slot 48 is reserved */
#ifndef TkGetTransientMaster
#define TkGetTransientMaster \
	(tkIntPlatStubsPtr->tkGetTransientMaster) /* 49 */
#endif
#ifndef TkGenerateButtonEvent
#define TkGenerateButtonEvent \
	(tkIntPlatStubsPtr->tkGenerateButtonEvent) /* 50 */
#endif
#ifndef TkGenWMDestroyEvent
#define TkGenWMDestroyEvent \
	(tkIntPlatStubsPtr->tkGenWMDestroyEvent) /* 51 */
#endif
/* Slot 52 is reserved */
#ifndef TkpGetMS
#define TkpGetMS \
	(tkIntPlatStubsPtr->tkpGetMS) /* 53 */
#endif
#endif /* AQUA */
#if !(defined(__WIN32__) || defined(MAC_OSX_TK)) /* X11 */
#ifndef TkCreateXEventSource
#define TkCreateXEventSource \
	(tkIntPlatStubsPtr->tkCreateXEventSource) /* 0 */
#endif
#ifndef TkFreeWindowId
#define TkFreeWindowId \
	(tkIntPlatStubsPtr->tkFreeWindowId) /* 1 */
#endif
#ifndef TkInitXId
#define TkInitXId \
	(tkIntPlatStubsPtr->tkInitXId) /* 2 */
#endif
#ifndef TkpCmapStressed
#define TkpCmapStressed \
	(tkIntPlatStubsPtr->tkpCmapStressed) /* 3 */
#endif
#ifndef TkpSync
#define TkpSync \
	(tkIntPlatStubsPtr->tkpSync) /* 4 */
#endif
#ifndef TkUnixContainerId
#define TkUnixContainerId \
	(tkIntPlatStubsPtr->tkUnixContainerId) /* 5 */
#endif
#ifndef TkUnixDoOneXEvent
#define TkUnixDoOneXEvent \
	(tkIntPlatStubsPtr->tkUnixDoOneXEvent) /* 6 */
#endif
#ifndef TkUnixSetMenubar
#define TkUnixSetMenubar \
	(tkIntPlatStubsPtr->tkUnixSetMenubar) /* 7 */
#endif
#ifndef TkpScanWindowId
#define TkpScanWindowId \
	(tkIntPlatStubsPtr->tkpScanWindowId) /* 8 */
#endif
#ifndef TkWmCleanup
#define TkWmCleanup \
	(tkIntPlatStubsPtr->tkWmCleanup) /* 9 */
#endif
#ifndef TkSendCleanup
#define TkSendCleanup \
	(tkIntPlatStubsPtr->tkSendCleanup) /* 10 */
#endif
#ifndef TkFreeXId
#define TkFreeXId \
	(tkIntPlatStubsPtr->tkFreeXId) /* 11 */
#endif
#ifndef TkpWmSetState
#define TkpWmSetState \
	(tkIntPlatStubsPtr->tkpWmSetState) /* 12 */
#endif
#ifndef TkpTestsendCmd
#define TkpTestsendCmd \
	(tkIntPlatStubsPtr->tkpTestsendCmd) /* 13 */
#endif
#endif /* X11 */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTPLATDECLS */
                                                                                                                                                                                                                                                                                                                      tkMacOSXDefault.h                                                                                   0100644 0001750 0001750 00000044233 12566233006 035532  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkMacOSXDefault.h --
 *
 *	This file defines the defaults for all options for all of
 *	the Tk widgets.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright 2001-2009, Apple Inc.
 * Copyright (c) 2006-2009 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKMACDEFAULT
#define _TKMACDEFAULT

#ifndef TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
#define TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS 1
#endif

/*
 * The definitions below provide symbolic names for the default colors.
 * NORMAL_BG -		Normal background color.
 * ACTIVE_BG -		Background color when widget is active.
 * SELECT_BG -		Background color for selected text.
 * SELECT_FG -		Foreground color for selected text.
 * TROUGH -		Background color for troughs in scales and scrollbars.
 * INDICATOR -		Color for indicator when button is selected.
 * DISABLED -		Foreground color when widget is disabled.
 */

#define BLACK			"Black"
#define WHITE			"White"
#define NORMAL_BG		"systemWindowBody"
#define ACTIVE_BG		"systemButtonFacePressed"
#define ACTIVE_FG		"systemPushButtonPressedText"
#define SELECT_BG		"systemHighlight"
#define SELECT_FG		None
#define INACTIVE_SELECT_BG	"systemHighlightSecondary"
#define TROUGH			"#c3c3c3"
#define INDICATOR		"#b03060"
#define DISABLED		"#a3a3a3"

/*
 * Defaults for labels, buttons, checkbuttons, and radiobuttons:
 */

#define DEF_BUTTON_ANCHOR		"center"
#define DEF_BUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_BUTTON_ACTIVE_BG_MONO	BLACK
#define DEF_BUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
#define DEF_CHKRAD_ACTIVE_FG_COLOR	DEF_BUTTON_ACTIVE_FG_COLOR
#define DEF_BUTTON_ACTIVE_FG_MONO	WHITE
/* #define DEF_BUTTON_BG_COLOR	"systemButtonFace"*/
#define DEF_BUTTON_BG_COLOR		WHITE
#define DEF_BUTTON_BG_MONO		WHITE
#define DEF_BUTTON_BITMAP		""
#define DEF_BUTTON_BORDER_WIDTH		"2"
#define DEF_BUTTON_CURSOR		""
#define DEF_BUTTON_COMMAND		""
#define DEF_BUTTON_COMPOUND		"none"
#define DEF_BUTTON_DEFAULT		"disabled"
#define DEF_BUTTON_DISABLED_FG_COLOR	DISABLED
#define DEF_BUTTON_DISABLED_FG_MONO	""
#define DEF_BUTTON_FG			"systemButtonText"
#define DEF_CHKRAD_FG			DEF_BUTTON_FG
#define DEF_BUTTON_FONT			"TkDefaultFont"
#define DEF_BUTTON_HEIGHT		"0"
#define DEF_BUTTON_HIGHLIGHT_BG_COLOR	DEF_BUTTON_BG_COLOR
#define DEF_BUTTON_HIGHLIGHT_BG_MONO	DEF_BUTTON_BG_MONO
#define DEF_BUTTON_HIGHLIGHT		"systemButtonFrame"
#define DEF_LABEL_HIGHLIGHT_WIDTH	"0"
#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
#define DEF_BUTTON_HIGHLIGHT_WIDTH	"4"
#define DEF_BUTTON_HIGHLIGHT_WIDTH_NOCM	"1"
#else
#define DEF_BUTTON_HIGHLIGHT_WIDTH	"1"
#endif
#define DEF_BUTTON_IMAGE		((char *) NULL)
#define DEF_BUTTON_INDICATOR		"1"
#define DEF_BUTTON_JUSTIFY		"center"
#define DEF_BUTTON_OFF_VALUE		"0"
#define DEF_BUTTON_ON_VALUE		"1"
#define DEF_BUTTON_TRISTATE_VALUE	""
#define DEF_BUTTON_OVER_RELIEF		""
#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
#define DEF_BUTTON_PADX			"12"
#define DEF_BUTTON_PADX_NOCM		"1"
#else
#define DEF_BUTTON_PADX			"1"
#endif
#define DEF_LABCHKRAD_PADX		"1"
#if TK_MAC_BUTTON_USE_COMPATIBILITY_METRICS
#define DEF_BUTTON_PADY			"3"
#define DEF_BUTTON_PADY_NOCM		"1"
#else
#define DEF_BUTTON_PADY			"1"
#endif
#define DEF_LABCHKRAD_PADY		"1"
#define DEF_BUTTON_RELIEF		"flat"
#define DEF_LABCHKRAD_RELIEF		"flat"
#define DEF_BUTTON_REPEAT_DELAY		"0"
#define DEF_BUTTON_REPEAT_INTERVAL	"0"
#define DEF_BUTTON_SELECT_COLOR		INDICATOR
#define DEF_BUTTON_SELECT_MONO		BLACK
#define DEF_BUTTON_SELECT_IMAGE		((char *) NULL)
#define DEF_BUTTON_STATE		"normal"
#define DEF_LABEL_TAKE_FOCUS		"0"
#define DEF_BUTTON_TAKE_FOCUS		((char *) NULL)
#define DEF_BUTTON_TEXT			""
#define DEF_BUTTON_TEXT_VARIABLE	""
#define DEF_BUTTON_UNDERLINE		"-1"
#define DEF_BUTTON_VALUE		""
#define DEF_BUTTON_WIDTH		"0"
#define DEF_BUTTON_WRAP_LENGTH		"0"
#define DEF_RADIOBUTTON_VARIABLE	"selectedButton"
#define DEF_CHECKBUTTON_VARIABLE	""

/*
 * Defaults for canvases:
 */

#define DEF_CANVAS_BG_COLOR		NORMAL_BG
#define DEF_CANVAS_BG_MONO		WHITE
#define DEF_CANVAS_BORDER_WIDTH		"0"
#define DEF_CANVAS_CLOSE_ENOUGH		"1"
#define DEF_CANVAS_CONFINE		"1"
#define DEF_CANVAS_CURSOR		""
#define DEF_CANVAS_HEIGHT		"7c"
#define DEF_CANVAS_HIGHLIGHT_BG		NORMAL_BG
#define DEF_CANVAS_HIGHLIGHT		BLACK
#define DEF_CANVAS_HIGHLIGHT_WIDTH	"3"
#define DEF_CANVAS_INSERT_BG		BLACK
#define DEF_CANVAS_INSERT_BD_COLOR	"0"
#define DEF_CANVAS_INSERT_BD_MONO	"0"
#define DEF_CANVAS_INSERT_OFF_TIME	"300"
#define DEF_CANVAS_INSERT_ON_TIME	"600"
#define DEF_CANVAS_INSERT_WIDTH		"2"
#define DEF_CANVAS_RELIEF		"flat"
#define DEF_CANVAS_SCROLL_REGION	""
#define DEF_CANVAS_SELECT_COLOR		SELECT_BG
#define DEF_CANVAS_SELECT_MONO		BLACK
#define DEF_CANVAS_SELECT_BD_COLOR	"1"
#define DEF_CANVAS_SELECT_BD_MONO	"0"
#define DEF_CANVAS_SELECT_FG_COLOR	SELECT_FG
#define DEF_CANVAS_SELECT_FG_MONO	WHITE
#define DEF_CANVAS_TAKE_FOCUS		((char *) NULL)
#define DEF_CANVAS_WIDTH		"10c"
#define DEF_CANVAS_X_SCROLL_CMD		""
#define DEF_CANVAS_X_SCROLL_INCREMENT	"0"
#define DEF_CANVAS_Y_SCROLL_CMD		""
#define DEF_CANVAS_Y_SCROLL_INCREMENT	"0"

/*
 * Defaults for entries:
 */

/*
 * I test the following two values in TkpDrawEntryBorderAndFocus
 * to determine whether to use the native entry widget. So if
 * you change the defaults to be different from these, then you
 * won't get the native widget by default.
 */

#define MAC_OSX_FOCUS_WIDTH		3
#define MAC_OSX_ENTRY_BORDER		2
#define MAC_OSX_ENTRY_RELIEF		TK_RELIEF_SUNKEN
#define MAC_OSX_ENTRY_SELECT_RELIEF	TK_RELIEF_FLAT

#define DEF_ENTRY_BG_COLOR		NORMAL_BG
#define DEF_ENTRY_BG_MONO		WHITE
#define DEF_ENTRY_BORDER_WIDTH		"2"
#define DEF_ENTRY_CURSOR		"xterm"
#define DEF_ENTRY_DISABLED_BG_COLOR	NORMAL_BG
#define DEF_ENTRY_DISABLED_BG_MONO	WHITE
#define DEF_ENTRY_DISABLED_FG		DISABLED
#define DEF_ENTRY_EXPORT_SELECTION	"1"
#define DEF_ENTRY_FONT			"TkTextFont"
#define DEF_ENTRY_FG			BLACK
#define DEF_ENTRY_HIGHLIGHT_BG		NORMAL_BG
#define DEF_ENTRY_HIGHLIGHT		BLACK
/* #define DEF_ENTRY_HIGHLIGHT_WIDTH	"3" */
#define DEF_ENTRY_HIGHLIGHT_WIDTH	"3"
#define DEF_ENTRY_INSERT_BG		BLACK
#define DEF_ENTRY_INSERT_BD_COLOR	"0"
#define DEF_ENTRY_INSERT_BD_MONO	"0"
#define DEF_ENTRY_INSERT_OFF_TIME	"300"
#define DEF_ENTRY_INSERT_ON_TIME	"600"
/* #define DEF_ENTRY_INSERT_WIDTH		"2" */
#define DEF_ENTRY_INSERT_WIDTH		"1"
#define DEF_ENTRY_JUSTIFY		"left"
#define DEF_ENTRY_READONLY_BG_COLOR	NORMAL_BG
#define DEF_ENTRY_READONLY_BG_MONO	WHITE
#define DEF_ENTRY_RELIEF		"sunken"
/* #define DEF_ENTRY_RELIEF		"solid" */
#define DEF_ENTRY_SCROLL_COMMAND	""
#define DEF_ENTRY_SELECT_COLOR		SELECT_BG
#define DEF_ENTRY_SELECT_MONO		BLACK
#define DEF_ENTRY_SELECT_BD_COLOR	"1"
#define DEF_ENTRY_SELECT_BD_MONO	"0"
#define DEF_ENTRY_SELECT_FG_COLOR	SELECT_FG
#define DEF_ENTRY_SELECT_FG_MONO	WHITE
#define DEF_ENTRY_SHOW			((char *) NULL)
#define DEF_ENTRY_STATE			"normal"
#define DEF_ENTRY_TAKE_FOCUS		((char *) NULL)
#define DEF_ENTRY_TEXT_VARIABLE		""
#define DEF_ENTRY_WIDTH			"20"

/*
 * Defaults for frames:
 */

#define DEF_FRAME_BG_COLOR		NORMAL_BG
#define DEF_FRAME_BG_MONO		WHITE
#define DEF_FRAME_BORDER_WIDTH		"0"
#define DEF_FRAME_CLASS			"Frame"
#define DEF_FRAME_COLORMAP		""
#define DEF_FRAME_CONTAINER		"0"
#define DEF_FRAME_CURSOR		""
#define DEF_FRAME_HEIGHT		"0"
#define DEF_FRAME_HIGHLIGHT_BG		NORMAL_BG
#define DEF_FRAME_HIGHLIGHT		BLACK
#define DEF_FRAME_HIGHLIGHT_WIDTH	"0"
#define DEF_FRAME_PADX			"0"
#define DEF_FRAME_PADY			"0"
#define DEF_FRAME_RELIEF		"flat"
#define DEF_FRAME_TAKE_FOCUS		"0"
#define DEF_FRAME_VISUAL		""
#define DEF_FRAME_WIDTH			"0"

/*
 * Defaults for labelframes:
 */

#define DEF_LABELFRAME_BORDER_WIDTH	"2"
#define DEF_LABELFRAME_CLASS		"Labelframe"
#define DEF_LABELFRAME_RELIEF		"groove"
#define DEF_LABELFRAME_FG		"systemButtonText"
#define DEF_LABELFRAME_FONT		"TkDefaultFont"
#define DEF_LABELFRAME_TEXT		""
#define DEF_LABELFRAME_LABELANCHOR	"nw"

/*
 * Defaults for listboxes:
 */

#define DEF_LISTBOX_ACTIVE_STYLE	"dotbox"
#define DEF_LISTBOX_BG_COLOR		WHITE
#define DEF_LISTBOX_BG_MONO		WHITE
#define DEF_LISTBOX_BORDER_WIDTH	"1"
#define DEF_LISTBOX_CURSOR		""
#define DEF_LISTBOX_DISABLED_FG		DISABLED
#define DEF_LISTBOX_EXPORT_SELECTION	"1"
#define DEF_LISTBOX_FONT		"TkTextFont"
#define DEF_LISTBOX_FG			BLACK
#define DEF_LISTBOX_HEIGHT		"10"
#define DEF_LISTBOX_HIGHLIGHT_BG	NORMAL_BG
#define DEF_LISTBOX_HIGHLIGHT		BLACK
#define DEF_LISTBOX_HIGHLIGHT_WIDTH	"0"
#define DEF_LISTBOX_RELIEF		"solid"
#define DEF_LISTBOX_SCROLL_COMMAND	""
#define DEF_LISTBOX_LIST_VARIABLE	""
#define DEF_LISTBOX_SELECT_COLOR	SELECT_BG
#define DEF_LISTBOX_SELECT_MONO		BLACK
#define DEF_LISTBOX_SELECT_BD		"0"
#define DEF_LISTBOX_SELECT_FG_COLOR	SELECT_FG
#define DEF_LISTBOX_SELECT_FG_MONO	WHITE
#define DEF_LISTBOX_SELECT_MODE		"browse"
#define DEF_LISTBOX_SET_GRID		"0"
#define DEF_LISTBOX_STATE		"normal"
#define DEF_LISTBOX_TAKE_FOCUS		((char *) NULL)
#define DEF_LISTBOX_WIDTH		"20"

/*
 * Defaults for individual entries of menus:
 */

#define DEF_MENU_ENTRY_ACTIVE_BG	((char *) NULL)
#define DEF_MENU_ENTRY_ACTIVE_FG	((char *) NULL)
#define DEF_MENU_ENTRY_ACCELERATOR	((char *) NULL)
#define DEF_MENU_ENTRY_BG		((char *) NULL)
#define DEF_MENU_ENTRY_BITMAP		None
#define DEF_MENU_ENTRY_COLUMN_BREAK	"0"
#define DEF_MENU_ENTRY_COMMAND		((char *) NULL)
#define DEF_MENU_ENTRY_COMPOUND		"none"
#define DEF_MENU_ENTRY_FG		((char *) NULL)
#define DEF_MENU_ENTRY_FONT		((char *) NULL)
#define DEF_MENU_ENTRY_HIDE_MARGIN	"0"
#define DEF_MENU_ENTRY_IMAGE		((char *) NULL)
#define DEF_MENU_ENTRY_INDICATOR	"1"
#define DEF_MENU_ENTRY_LABEL		((char *) NULL)
#define DEF_MENU_ENTRY_MENU		((char *) NULL)
#define DEF_MENU_ENTRY_OFF_VALUE	"0"
#define DEF_MENU_ENTRY_ON_VALUE		"1"
#define DEF_MENU_ENTRY_SELECT_IMAGE	((char *) NULL)
#define DEF_MENU_ENTRY_STATE		"normal"
#define DEF_MENU_ENTRY_VALUE		((char *) NULL)
#define DEF_MENU_ENTRY_CHECK_VARIABLE	((char *) NULL)
#define DEF_MENU_ENTRY_RADIO_VARIABLE	"selectedButton"
#define DEF_MENU_ENTRY_SELECT		((char *) NULL)
#define DEF_MENU_ENTRY_UNDERLINE	"-1"

/*
 * Defaults for menus overall:
 */

#define DEF_MENU_ACTIVE_BG_COLOR	"systemMenuActive"
#define DEF_MENU_ACTIVE_BG_MONO		BLACK
#define DEF_MENU_ACTIVE_BORDER_WIDTH	"0"
#define DEF_MENU_ACTIVE_FG_COLOR	"systemMenuActiveText"
#define DEF_MENU_ACTIVE_FG_MONO		WHITE
#define DEF_MENU_BG_COLOR		"systemMenu"
#define DEF_MENU_BG_MONO		WHITE
#define DEF_MENU_BORDER_WIDTH		"0"
#define DEF_MENU_CURSOR			"arrow"
#define DEF_MENU_DISABLED_FG_COLOR	"systemMenuDisabled"
#define DEF_MENU_DISABLED_FG_MONO	""
#define DEF_MENU_FONT			"menu" /* special: see tkMacOSXMenu.c */
#define DEF_MENU_FG			"systemMenuText"
#define DEF_MENU_POST_COMMAND		""
#define DEF_MENU_RELIEF			"flat"
#define DEF_MENU_SELECT_COLOR		"systemMenuActive"
#define DEF_MENU_SELECT_MONO		BLACK
#define DEF_MENU_TAKE_FOCUS		"0"

/*
 * FIXME: Turn the default back to 1 when we make tearoff menus work again.
 */

#define DEF_MENU_TEAROFF		"0"
#define DEF_MENU_TEAROFF_CMD		((char *) NULL)
#define DEF_MENU_TITLE			""
#define DEF_MENU_TYPE			"normal"

/*
 * Defaults for menubuttons:
 */

#define DEF_MENUBUTTON_ANCHOR		"center"
#define DEF_MENUBUTTON_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_MENUBUTTON_ACTIVE_BG_MONO	BLACK
#define DEF_MENUBUTTON_ACTIVE_FG_COLOR	ACTIVE_FG
#define DEF_MENUBUTTON_ACTIVE_FG_MONO	WHITE
#define DEF_MENUBUTTON_BG_COLOR		NORMAL_BG
#define DEF_MENUBUTTON_BG_MONO		WHITE
#define DEF_MENUBUTTON_BITMAP		""
#define DEF_MENUBUTTON_BORDER_WIDTH	"2"
#define DEF_MENUBUTTON_CURSOR		""
#define DEF_MENUBUTTON_DIRECTION	"below"
#define DEF_MENUBUTTON_DISABLED_FG_COLOR DISABLED
#define DEF_MENUBUTTON_DISABLED_FG_MONO	""
#define DEF_MENUBUTTON_FONT		"TkDefaultFont"
#define DEF_MENUBUTTON_FG		BLACK
#define DEF_MENUBUTTON_HEIGHT		"0"
#define DEF_MENUBUTTON_HIGHLIGHT_BG_COLOR DEF_MENUBUTTON_BG_COLOR
#define DEF_MENUBUTTON_HIGHLIGHT_BG_MONO  DEF_MENUBUTTON_BG_MONO
#define DEF_MENUBUTTON_HIGHLIGHT	BLACK
#define DEF_MENUBUTTON_HIGHLIGHT_WIDTH	"0"
#define DEF_MENUBUTTON_IMAGE		((char *) NULL)
#define DEF_MENUBUTTON_INDICATOR	"1"
#define DEF_MENUBUTTON_JUSTIFY		"left"
#define DEF_MENUBUTTON_MENU		""
#define DEF_MENUBUTTON_PADX		"4"
#define DEF_MENUBUTTON_PADY		"3"
#define DEF_MENUBUTTON_RELIEF		"flat"
#define DEF_MENUBUTTON_STATE		"normal"
#define DEF_MENUBUTTON_TAKE_FOCUS	"0"
#define DEF_MENUBUTTON_TEXT		""
#define DEF_MENUBUTTON_TEXT_VARIABLE	""
#define DEF_MENUBUTTON_UNDERLINE	"-1"
#define DEF_MENUBUTTON_WIDTH		"0"
#define DEF_MENUBUTTON_WRAP_LENGTH	"0"

/*
 * Defaults for messages:
 */

#define DEF_MESSAGE_ANCHOR		"center"
#define DEF_MESSAGE_ASPECT		"150"
#define DEF_MESSAGE_BG_COLOR		NORMAL_BG
#define DEF_MESSAGE_BG_MONO		WHITE
#define DEF_MESSAGE_BORDER_WIDTH	"1"
#define DEF_MESSAGE_CURSOR		""
#define DEF_MESSAGE_FG			BLACK
#define DEF_MESSAGE_FONT		"TkDefaultFont"
#define DEF_MESSAGE_HIGHLIGHT_BG	NORMAL_BG
#define DEF_MESSAGE_HIGHLIGHT		BLACK
#define DEF_MESSAGE_HIGHLIGHT_WIDTH	"0"
#define DEF_MESSAGE_JUSTIFY		"left"
#define DEF_MESSAGE_PADX		"-1"
#define DEF_MESSAGE_PADY		"-1"
#define DEF_MESSAGE_RELIEF		"flat"
#define DEF_MESSAGE_TAKE_FOCUS		"0"
#define DEF_MESSAGE_TEXT		""
#define DEF_MESSAGE_TEXT_VARIABLE	""
#define DEF_MESSAGE_WIDTH		"0"
/*
 * Defaults for panedwindows
 */

#define DEF_PANEDWINDOW_BG_COLOR	NORMAL_BG
#define DEF_PANEDWINDOW_BG_MONO		WHITE
#define DEF_PANEDWINDOW_BORDERWIDTH	"1"
#define DEF_PANEDWINDOW_CURSOR		""
#define DEF_PANEDWINDOW_HANDLEPAD	"8"
#define DEF_PANEDWINDOW_HANDLESIZE	"8"
#define DEF_PANEDWINDOW_HEIGHT		""
#define DEF_PANEDWINDOW_OPAQUERESIZE	"1"
#define DEF_PANEDWINDOW_ORIENT		"horizontal"
#define DEF_PANEDWINDOW_RELIEF		"flat"
#define DEF_PANEDWINDOW_SASHCURSOR	""
#define DEF_PANEDWINDOW_SASHPAD		"0"
#define DEF_PANEDWINDOW_SASHRELIEF	"flat"
#define DEF_PANEDWINDOW_SASHWIDTH	"3"
#define DEF_PANEDWINDOW_SHOWHANDLE	"0"
#define DEF_PANEDWINDOW_WIDTH		""

/*
 * Defaults for panedwindow panes
 */

#define DEF_PANEDWINDOW_PANE_AFTER	""
#define DEF_PANEDWINDOW_PANE_BEFORE	""
#define DEF_PANEDWINDOW_PANE_HEIGHT	""
#define DEF_PANEDWINDOW_PANE_MINSIZE	"0"
#define DEF_PANEDWINDOW_PANE_PADX	"0"
#define DEF_PANEDWINDOW_PANE_PADY	"0"
#define DEF_PANEDWINDOW_PANE_STICKY	"nsew"
#define DEF_PANEDWINDOW_PANE_WIDTH	""
#define DEF_PANEDWINDOW_PANE_HIDE	"0"
#define DEF_PANEDWINDOW_PANE_STRETCH	"last"

/*
 * Defaults for scales:
 */

#define DEF_SCALE_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_SCALE_ACTIVE_BG_MONO	BLACK
#define DEF_SCALE_BG_COLOR		NORMAL_BG
#define DEF_SCALE_BG_MONO		WHITE
#define DEF_SCALE_BIG_INCREMENT		"0"
#define DEF_SCALE_BORDER_WIDTH		"1"
#define DEF_SCALE_COMMAND		""
#define DEF_SCALE_CURSOR		""
#define DEF_SCALE_DIGITS		"0"
#define DEF_SCALE_FONT			"TkDefaultFont"
#define DEF_SCALE_FG_COLOR		BLACK
#define DEF_SCALE_FG_MONO		BLACK
#define DEF_SCALE_FROM			"0"
#define DEF_SCALE_HIGHLIGHT_BG_COLOR	DEF_SCALE_BG_COLOR
#define DEF_SCALE_HIGHLIGHT_BG_MONO	DEF_SCALE_BG_MONO
#define DEF_SCALE_HIGHLIGHT		BLACK
#define DEF_SCALE_HIGHLIGHT_WIDTH	"0"
#define DEF_SCALE_LABEL			""
#define DEF_SCALE_LENGTH		"100"
#define DEF_SCALE_ORIENT		"vertical"
#define DEF_SCALE_RELIEF		"flat"
#define DEF_SCALE_REPEAT_DELAY	"300"
#define DEF_SCALE_REPEAT_INTERVAL	"100"
#define DEF_SCALE_RESOLUTION		"1"
#define DEF_SCALE_TROUGH_COLOR		TROUGH
#define DEF_SCALE_TROUGH_MONO		WHITE
#define DEF_SCALE_SHOW_VALUE		"1"
#define DEF_SCALE_SLIDER_LENGTH		"30"
#define DEF_SCALE_SLIDER_RELIEF		"raised"
#define DEF_SCALE_STATE			"normal"
#define DEF_SCALE_TAKE_FOCUS		((char *) NULL)
#define DEF_SCALE_TICK_INTERVAL		"0"
#define DEF_SCALE_TO			"100"
#define DEF_SCALE_VARIABLE		""
#define DEF_SCALE_WIDTH			"15"

/*
 * Defaults for scrollbars:
 */

#define DEF_SCROLLBAR_ACTIVE_BG_COLOR	ACTIVE_BG
#define DEF_SCROLLBAR_ACTIVE_BG_MONO	BLACK
#define DEF_SCROLLBAR_ACTIVE_RELIEF	"raised"
#define DEF_SCROLLBAR_BG_COLOR		NORMAL_BG
#define DEF_SCROLLBAR_BG_MONO		WHITE
#define DEF_SCROLLBAR_BORDER_WIDTH	"0"
#define DEF_SCROLLBAR_COMMAND		""
#define DEF_SCROLLBAR_CURSOR		""
#define DEF_SCROLLBAR_EL_BORDER_WIDTH	"-1"
#define DEF_SCROLLBAR_HIGHLIGHT_BG	NORMAL_BG
#define DEF_SCROLLBAR_HIGHLIGHT		BLACK
#define DEF_SCROLLBAR_HIGHLIGHT_WIDTH	"0"
#define DEF_SCROLLBAR_JUMP		"0"
#define DEF_SCROLLBAR_ORIENT		"vertical"
#define DEF_SCROLLBAR_RELIEF		"flat"
#define DEF_SCROLLBAR_REPEAT_DELAY	"300"
#define DEF_SCROLLBAR_REPEAT_INTERVAL	"100"
#define DEF_SCROLLBAR_TAKE_FOCUS	((char *) NULL)
#define DEF_SCROLLBAR_TROUGH_COLOR	TROUGH
#define DEF_SCROLLBAR_TROUGH_MONO	WHITE
#define DEF_SCROLLBAR_WIDTH		"15"

/*
 * Defaults for texts:
 */

#define DEF_TEXT_AUTO_SEPARATORS	"1"
#define DEF_TEXT_BG_COLOR		NORMAL_BG
#define DEF_TEXT_BG_MONO		WHITE
#define DEF_TEXT_BLOCK_CURSOR		"0"
#define DEF_TEXT_BORDER_WIDTH		"0"
#define DEF_TEXT_CURSOR			"xterm"
#define DEF_TEXT_FG			BLACK
#define DEF_TEXT_EXPORT_SELECTION	"1"
#define DEF_TEXT_FONT			"TkFixedFont"
#define DEF_TEXT_HEIGHT			"24"
#define DEF_TEXT_HIGHLIGHT_BG		NORMAL_BG
#define DEF_TEXT_HIGHLIGHT		BLACK
#define DEF_TEXT_HIGHLIGHT_WIDTH	"3"
#define DEF_TEXT_INSERT_BG		BLACK
#define DEF_TEXT_INSERT_BD_COLOR	"0"
#define DEF_TEXT_INSERT_BD_MONO		"0"
#define DEF_TEXT_INSERT_OFF_TIME	"300"
#define DEF_TEXT_INSERT_ON_TIME		"600"
#define DEF_TEXT_INSERT_WIDTH		"1"
#define DEF_TEXT_MAX_UNDO		"0"
#define DEF_TEXT_PADX			"1"
#define DEF_TEXT_PADY			"1"
#define DEF_TEXT_RELIEF			"flat"
#define DEF_TEXT_INACTIVE_SELECT_COLOR	INACTIVE_SELECT_BG
#define DEF_TEXT_SELECT_COLOR		SELECT_BG
#define DEF_TEXT_SELECT_MONO		BLACK
#define DEF_TEXT_SELECT_BD_COLOR	"1"
#define DEF_TEXT_SELECT_BD_MONO		"0"
#define DEF_TEXT_SELECT_FG_COLOR	SELECT_FG
#define DEF_TEXT_SELECT_FG_MONO		WHITE
#define DEF_TEXT_SELECT_RELIEF		"flat"
#define DEF_TEXT_SET_GRID		"0"
#define DEF_TEXT_SPACING1		"0"
#define DEF_TEXT_SPACING2		"0"
#define DEF_TEXT_SPACING3		"0"
#define DEF_TEXT_STATE			"normal"
#define DEF_TEXT_TABS			""
#define DEF_TEXT_TABSTYLE		"tabular"
#define DEF_TEXT_TAKE_FOCUS		((char *) NULL)
#define DEF_TEXT_UNDO			"0"
#define DEF_TEXT_WIDTH			"80"
#define DEF_TEXT_WRAP			"char"
#define DEF_TEXT_XSCROLL_COMMAND	""
#define DEF_TEXT_YSCROLL_COMMAND	""

/*
 * Defaults for canvas text:
 */

#define DEF_CANVTEXT_FONT		"TkDefaultFont"

/*
 * Defaults for toplevels (most of the defaults for frames also apply
 * to toplevels):
 */

#define DEF_TOPLEVEL_CLASS		"Toplevel"
#define DEF_TOPLEVEL_MENU		""
#define DEF_TOPLEVEL_SCREEN		""
#define DEF_TOPLEVEL_USE		""

#endif /* _TKMACDEFAULT */
                                                                                                                                                                                                                                                                                                                                                                     tkMacOSXInt.h                                                                                       0100644 0001750 0001750 00000012204 11442001040 034650  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkMacOSXInt.h --
 *
 *	Declarations of Macintosh specific shared variables and procedures.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001-2009, Apple Inc.
 * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKMACINT
#define _TKMACINT

#ifndef _TKINT
#include "tkInt.h"
#endif

/*
 * Include platform specific public interfaces.
 */

#ifndef _TKMAC
#include "tkMacOSX.h"
#endif

/*
 * Define compatibility platform types used in the structures below so that
 * this header can be included without pulling in the platform headers.
 */

#ifndef _TKMACPRIV
#   ifndef CGGEOMETRY_H_
#	ifndef CGFLOAT_DEFINED
#	    if __LP64__
#		define CGFloat double
#	    else
#		define CGFloat float
#	    endif
#	endif
#	define CGSize struct {CGFloat width; CGFloat height;}
#   endif
#   ifndef CGCONTEXT_H_
#	define CGContextRef void *
#   endif
#   ifndef CGCOLOR_H_
#	define CGColorRef void *
#   endif
#   ifndef __HISHAPE__
#	define HIShapeRef void *
#   endif
#   ifndef _APPKITDEFINES_H
#	define NSView void *
#   endif
#endif

struct TkWindowPrivate {
    TkWindow *winPtr;		/* Ptr to tk window or NULL if Pixmap */
    NSView *view;
    CGContextRef context;
    int xOff;			/* X offset from toplevel window */
    int yOff;			/* Y offset from toplevel window */
    CGSize size;
    HIShapeRef visRgn;		/* Visible region of window */
    HIShapeRef aboveVisRgn;	/* Visible region of window & its children */
    HIShapeRef drawRgn;		/* Clipped drawing region */
    int referenceCount;		/* Don't delete toplevel until children are
				 * gone. */
    struct TkWindowPrivate *toplevel;
				/* Pointer to the toplevel datastruct. */
    int flags;			/* Various state see defines below. */
};
typedef struct TkWindowPrivate MacDrawable;

/*
 * Defines use for the flags field of the MacDrawable data structure.
 */

#define TK_SCROLLBAR_GROW	0x01
#define TK_CLIP_INVALID		0x02
#define TK_HOST_EXISTS		0x04
#define TK_DRAWN_UNDER_MENU	0x08
#define TK_FOCUSED_VIEW		0x10
#define TK_IS_PIXMAP		0x20
#define TK_IS_BW_PIXMAP		0x40

/*
 * I am reserving TK_EMBEDDED = 0x100 in the MacDrawable flags
 * This is defined in tk.h. We need to duplicate the TK_EMBEDDED flag in the
 * TkWindow structure for the window, but in the MacWin. This way we can
 * still tell what the correct port is after the TKWindow structure has been
 * freed. This actually happens when you bind destroy of a toplevel to
 * Destroy of a child.
 */

/*
 * This structure is for handling Netscape-type in process
 * embedding where Tk does not control the top-level. It contains
 * various functions that are needed by Mac specific routines, like
 * TkMacOSXGetDrawablePort. The definitions of the function types
 * are in tkMacOSX.h.
 */

typedef struct {
    Tk_MacOSXEmbedRegisterWinProc *registerWinProc;
    Tk_MacOSXEmbedGetGrafPortProc *getPortProc;
    Tk_MacOSXEmbedMakeContainerExistProc *containerExistProc;
    Tk_MacOSXEmbedGetClipProc *getClipProc;
    Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc;
} TkMacOSXEmbedHandler;

MODULE_SCOPE TkMacOSXEmbedHandler *tkMacOSXEmbedHandler;

/*
 * GC CGColorRef cache for tkMacOSXColor.c
 */

typedef struct {
    unsigned long cachedForeground;
    CGColorRef cachedForegroundColor;
    unsigned long cachedBackground;
    CGColorRef cachedBackgroundColor;
} TkpGCCache;

MODULE_SCOPE TkpGCCache *TkpGetGCCache(GC gc);
MODULE_SCOPE void TkpInitGCCache(GC gc);
MODULE_SCOPE void TkpFreeGCCache(GC gc);

/*
 * Undef compatibility platform types defined above.
 */

#ifndef _TKMACPRIV
#   ifndef CGGEOMETRY_H_
#	ifndef CGFLOAT_DEFINED
#	    undef CGFloat
#	endif
#	undef CGSize
#   endif
#   ifndef CGCONTEXT_H_
#	undef CGContextRef
#   endif
#   ifndef CGCOLOR_H_
#	undef CGColorRef
#   endif
#   ifndef __HISHAPE__
#	undef HIShapeRef
#   endif
#   ifndef _APPKITDEFINES_H
#	undef NSView
#   endif
#endif

/*
 * Defines used for TkMacOSXInvalidateWindow
 */

#define TK_WINDOW_ONLY 0
#define TK_PARENT_WINDOW 1

/*
 * Accessor for the privatePtr flags field for the TK_HOST_EXISTS field
 */

#define TkMacOSXHostToplevelExists(tkwin) \
    (((TkWindow *) (tkwin))->privatePtr->toplevel->flags & TK_HOST_EXISTS)

/*
 * Defines used for the flags argument to TkGenWMConfigureEvent.
 */

#define TK_LOCATION_CHANGED	1
#define TK_SIZE_CHANGED		2
#define TK_BOTH_CHANGED		3
#define TK_MACOSX_HANDLE_EVENT_IMMEDIATELY 1024

/*
 * Defines for tkTextDisp.c
 */

#define TK_LAYOUT_WITH_BASE_CHUNKS	1
#define TK_DRAW_IN_CONTEXT		1

/*
 * Prototypes of internal procs not in the stubs table.
 */

MODULE_SCOPE void TkMacOSXDefaultStartupScript(void);
#if 0
MODULE_SCOPE int XSetClipRectangles(Display *d, GC gc, int clip_x_origin,
	int clip_y_origin, XRectangle* rectangles, int n, int ordering);
#endif
MODULE_SCOPE void TkpClipDrawableToRect(Display *display, Drawable d, int x,
	int y, int width, int height);
MODULE_SCOPE void TkpRetainRegion(TkRegion r);
MODULE_SCOPE void TkpReleaseRegion(TkRegion r);

/*
 * Include the stubbed internal platform-specific API.
 */

#include "tkIntPlatDecls.h"

#endif /* _TKMACINT */
                                                                                                                                                                                                                                                                                                                                                                                            tkMacOSXPort.h                                                                                      0100644 0001750 0001750 00000011133 11442001040 035042  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkMacOSXPort.h --
 *
 *	This file is included by all of the Tk C files. It contains
 *	information that may be configuration-dependent, such as
 *	#includes for system include files and a few other things.
 *
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
 * Copyright 2001-2009, Apple Inc.
 * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKMACPORT
#define _TKMACPORT

/*
 * Macro to use instead of "void" for arguments that must have
 * type "void *" in ANSI C; maps them to type "char *" in
 * non-ANSI systems. This macro may be used in some of the include
 * files below, which is why it is defined here.
 */

#ifndef VOID
#   ifdef __STDC__
#	define VOID void
#   else
#	define VOID char
#   endif
#endif

#include <stdio.h>
#include <ctype.h>
#include <fcntl.h>
#include <limits.h>
#include <math.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/file.h>
#ifdef HAVE_SYS_SELECT_H
#   include <sys/select.h>
#endif
#include <sys/stat.h>
#ifndef _TCL
#   include <tcl.h>
#endif
#if TIME_WITH_SYS_TIME
#   include <sys/time.h>
#   include <time.h>
#else
#   if HAVE_SYS_TIME_H
#	include <sys/time.h>
#   else
#	include <time.h>
#   endif
#endif
#if HAVE_INTTYPES_H
#    include <inttypes.h>
#endif
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/cursorfont.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include <X11/Xfuncproto.h>
#include <X11/Xutil.h>
#include "tkIntXlibDecls.h"

/*
 * The following macro defines the type of the mask arguments to
 * select:
 */

#ifndef NO_FD_SET
#   define SELECT_MASK fd_set
#else
#   ifndef _AIX
	typedef long fd_mask;
#   endif
#   if defined(_IBMR2)
#	define SELECT_MASK void
#   else
#	define SELECT_MASK int
#   endif
#endif

/*
 * The following macro defines the number of fd_masks in an fd_set:
 */

#ifndef FD_SETSIZE
#   ifdef OPEN_MAX
#	define FD_SETSIZE OPEN_MAX
#   else
#	define FD_SETSIZE 256
#   endif
#endif
#if !defined(howmany)
#   define howmany(x, y) (((x)+((y)-1))/(y))
#endif
#ifndef NFDBITS
#   define NFDBITS NBBY*sizeof(fd_mask)
#endif
#define MASK_SIZE howmany(FD_SETSIZE, NFDBITS)

/*
 * Define "NBBY" (number of bits per byte) if it's not already defined.
 */

#ifndef NBBY
#   define NBBY 8
#endif

/*
 * The following define causes Tk to use its internal keysym hash table
 */

#define REDO_KEYSYM_LOOKUP

/*
 * Defines for X functions that are used by Tk but are treated as
 * no-op functions on the Macintosh.
 */

#define XFlush(display)
#define XFree(data) {if ((data) != NULL) ckfree((char *) (data));}
#define XGrabServer(display)
#define XNoOp(display) {display->request++;}
#define XUngrabServer(display)
#define XSynchronize(display, bool) {display->request++;}
#define XVisualIDFromVisual(visual) (visual->visualid)

/*
 * The following functions are not used on the Mac, so we stub them out.
 */

#define TkFreeWindowId(dispPtr,w)
#define TkInitXId(dispPtr)
#define TkpCmapStressed(tkwin,colormap) (0)
#define TkpFreeColor(tkColPtr)
#define TkSetPixmapColormap(p,c) {}
#define TkpSync(display)

/*
 * The following macro returns the pixel value that corresponds to the
 * RGB values in the given XColor structure.
 */

#define PIXEL_MAGIC ((unsigned char) 0x69)
#define TkpGetPixel(p) ((((((PIXEL_MAGIC << 8) \
	| (((p)->red >> 8) & 0xff)) << 8) \
	| (((p)->green >> 8) & 0xff)) << 8) \
	| (((p)->blue >> 8) & 0xff))

/*
 * This macro stores a representation of the window handle in a string.
 * This should perhaps use the real size of an XID.
 */

#define TkpPrintWindowId(buf,w) \
	sprintf((buf), "0x%x", (unsigned int) (w))

/*
 * TkpScanWindowId is just an alias for Tcl_GetInt on Unix.
 */

#define TkpScanWindowId(i,s,wp) \
	Tcl_GetInt((i),(s),(int *) (wp))

/*
 * Turn off Tk double-buffering as Aqua windows are already double-buffered.
 */

#define TK_NO_DOUBLE_BUFFERING 1

/*
 * Magic pixel code values for system colors.
 *
 * NOTE: values must be kept in sync with indices into the
 *	 systemColorMap array in tkMacOSXColor.c !
 */

#define TRANSPARENT_PIXEL		30
#define HIGHLIGHT_PIXEL			31
#define HIGHLIGHT_SECONDARY_PIXEL	32
#define HIGHLIGHT_TEXT_PIXEL		33
#define HIGHLIGHT_ALTERNATE_PIXEL	34
#define CONTROL_TEXT_PIXEL		35
#define CONTROL_BODY_PIXEL		37
#define CONTROL_FRAME_PIXEL		39
#define WINDOW_BODY_PIXEL		41
#define MENU_ACTIVE_PIXEL		43
#define MENU_ACTIVE_TEXT_PIXEL		45
#define MENU_BACKGROUND_PIXEL		47
#define MENU_DISABLED_PIXEL		49
#define MENU_TEXT_PIXEL			51
#define APPEARANCE_PIXEL		52

#endif /* _TKMACPORT */
                                                                                                                                                                                                                                                                                                                                                                                                                                     tkPort.h                                                                                            0100644 0001750 0001750 00000001260 11056342512 034044  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * tkPort.h --
 *
 *	This header file handles porting issues that occur because of
 *	differences between systems.  It reads in platform specific
 *	portability files.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKPORT
#define _TKPORT

#ifndef _TK
#include "tk.h"
#endif
#ifndef _TCL
#include "tcl.h"
#endif

#if defined(__WIN32__) || defined(_WIN32)
#   include "tkWinPort.h"
#else
#   if defined(MAC_OSX_TK)
#	include "tkMacOSXPort.h"
#   else
#	include "tkUnixPort.h"
#   endif
#endif

#endif /* _TKPORT */
                                                                                                                                                                                                                                                                                                                                                ttkDecls.h                                                                                          0100644 0001750 0001750 00000023173 11442001432 034335  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /*
 * $Id$
 *
 * This file is (mostly) automatically generated from ttk.decls.
 */

#ifndef _TTKDECLS
#define _TTKDECLS

#if defined(USE_TTK_STUBS)

extern const char *TtkInitializeStubs(
	Tcl_Interp *, const char *version, int epoch, int revision);
#define Ttk_InitStubs(interp) TtkInitializeStubs( \
	interp, TTK_VERSION, TTK_STUBS_EPOCH, TTK_STUBS_REVISION)
#else

#define Ttk_InitStubs(interp) Tcl_PkgRequire(interp, "Ttk", TTK_VERSION, 0)

#endif


/* !BEGIN!: Do not edit below this line. */

#define TTK_STUBS_EPOCH 0
#define TTK_STUBS_REVISION 31

/*
 * Exported function declarations:
 */

/* 0 */
TTKAPI Ttk_Theme	Ttk_GetTheme(Tcl_Interp *interp, const char *name);
/* 1 */
TTKAPI Ttk_Theme	Ttk_GetDefaultTheme(Tcl_Interp *interp);
/* 2 */
TTKAPI Ttk_Theme	Ttk_GetCurrentTheme(Tcl_Interp *interp);
/* 3 */
TTKAPI Ttk_Theme	Ttk_CreateTheme(Tcl_Interp *interp, const char *name,
				Ttk_Theme parent);
/* 4 */
TTKAPI void		Ttk_RegisterCleanup(Tcl_Interp *interp,
				void *deleteData,
				Ttk_CleanupProc *cleanupProc);
/* 5 */
TTKAPI int		Ttk_RegisterElementSpec(Ttk_Theme theme,
				const char *elementName,
				Ttk_ElementSpec *elementSpec,
				void *clientData);
/* 6 */
TTKAPI Ttk_ElementClass * Ttk_RegisterElement(Tcl_Interp *interp,
				Ttk_Theme theme, const char *elementName,
				Ttk_ElementSpec *elementSpec,
				void *clientData);
/* 7 */
TTKAPI int		Ttk_RegisterElementFactory(Tcl_Interp *interp,
				const char *name,
				Ttk_ElementFactory factoryProc,
				void *clientData);
/* 8 */
TTKAPI void		Ttk_RegisterLayout(Ttk_Theme theme,
				const char *className,
				Ttk_LayoutSpec layoutSpec);
/* Slot 9 is reserved */
/* 10 */
TTKAPI int		Ttk_GetStateSpecFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, Ttk_StateSpec *spec_rtn);
/* 11 */
TTKAPI Tcl_Obj *	Ttk_NewStateSpecObj(unsigned int onbits,
				unsigned int offbits);
/* 12 */
TTKAPI Ttk_StateMap	Ttk_GetStateMapFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr);
/* 13 */
TTKAPI Tcl_Obj *	Ttk_StateMapLookup(Tcl_Interp *interp,
				Ttk_StateMap map, Ttk_State state);
/* 14 */
TTKAPI int		Ttk_StateTableLookup(Ttk_StateTable map[],
				Ttk_State state);
/* Slot 15 is reserved */
/* Slot 16 is reserved */
/* Slot 17 is reserved */
/* Slot 18 is reserved */
/* Slot 19 is reserved */
/* 20 */
TTKAPI int		Ttk_GetPaddingFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr,
				Ttk_Padding *pad_rtn);
/* 21 */
TTKAPI int		Ttk_GetBorderFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, Ttk_Padding *pad_rtn);
/* 22 */
TTKAPI int		Ttk_GetStickyFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, Ttk_Sticky *sticky_rtn);
/* 23 */
TTKAPI Ttk_Padding	Ttk_MakePadding(short l, short t, short r, short b);
/* 24 */
TTKAPI Ttk_Padding	Ttk_UniformPadding(short borderWidth);
/* 25 */
TTKAPI Ttk_Padding	Ttk_AddPadding(Ttk_Padding pad1, Ttk_Padding pad2);
/* 26 */
TTKAPI Ttk_Padding	Ttk_RelievePadding(Ttk_Padding padding, int relief,
				int n);
/* 27 */
TTKAPI Ttk_Box		Ttk_MakeBox(int x, int y, int width, int height);
/* 28 */
TTKAPI int		Ttk_BoxContains(Ttk_Box box, int x, int y);
/* 29 */
TTKAPI Ttk_Box		Ttk_PackBox(Ttk_Box *cavity, int w, int h,
				Ttk_Side side);
/* 30 */
TTKAPI Ttk_Box		Ttk_StickBox(Ttk_Box parcel, int w, int h,
				Ttk_Sticky sticky);
/* 31 */
TTKAPI Ttk_Box		Ttk_AnchorBox(Ttk_Box parcel, int w, int h,
				Tk_Anchor anchor);
/* 32 */
TTKAPI Ttk_Box		Ttk_PadBox(Ttk_Box b, Ttk_Padding p);
/* 33 */
TTKAPI Ttk_Box		Ttk_ExpandBox(Ttk_Box b, Ttk_Padding p);
/* 34 */
TTKAPI Ttk_Box		Ttk_PlaceBox(Ttk_Box *cavity, int w, int h,
				Ttk_Side side, Ttk_Sticky sticky);
/* 35 */
TTKAPI Tcl_Obj *	Ttk_NewBoxObj(Ttk_Box box);
/* Slot 36 is reserved */
/* Slot 37 is reserved */
/* Slot 38 is reserved */
/* Slot 39 is reserved */
/* 40 */
TTKAPI int		Ttk_GetOrientFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, int *orient);

typedef struct TtkStubs {
    int magic;
    int epoch;
    int revision;
    const struct TtkStubHooks *hooks;

    Ttk_Theme (*ttk_GetTheme) (Tcl_Interp *interp, const char *name); /* 0 */
    Ttk_Theme (*ttk_GetDefaultTheme) (Tcl_Interp *interp); /* 1 */
    Ttk_Theme (*ttk_GetCurrentTheme) (Tcl_Interp *interp); /* 2 */
    Ttk_Theme (*ttk_CreateTheme) (Tcl_Interp *interp, const char *name, Ttk_Theme parent); /* 3 */
    void (*ttk_RegisterCleanup) (Tcl_Interp *interp, void *deleteData, Ttk_CleanupProc *cleanupProc); /* 4 */
    int (*ttk_RegisterElementSpec) (Ttk_Theme theme, const char *elementName, Ttk_ElementSpec *elementSpec, void *clientData); /* 5 */
    Ttk_ElementClass * (*ttk_RegisterElement) (Tcl_Interp *interp, Ttk_Theme theme, const char *elementName, Ttk_ElementSpec *elementSpec, void *clientData); /* 6 */
    int (*ttk_RegisterElementFactory) (Tcl_Interp *interp, const char *name, Ttk_ElementFactory factoryProc, void *clientData); /* 7 */
    void (*ttk_RegisterLayout) (Ttk_Theme theme, const char *className, Ttk_LayoutSpec layoutSpec); /* 8 */
    void (*reserved9)(void);
    int (*ttk_GetStateSpecFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Ttk_StateSpec *spec_rtn); /* 10 */
    Tcl_Obj * (*ttk_NewStateSpecObj) (unsigned int onbits, unsigned int offbits); /* 11 */
    Ttk_StateMap (*ttk_GetStateMapFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 12 */
    Tcl_Obj * (*ttk_StateMapLookup) (Tcl_Interp *interp, Ttk_StateMap map, Ttk_State state); /* 13 */
    int (*ttk_StateTableLookup) (Ttk_StateTable map[], Ttk_State state); /* 14 */
    void (*reserved15)(void);
    void (*reserved16)(void);
    void (*reserved17)(void);
    void (*reserved18)(void);
    void (*reserved19)(void);
    int (*ttk_GetPaddingFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, Ttk_Padding *pad_rtn); /* 20 */
    int (*ttk_GetBorderFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Ttk_Padding *pad_rtn); /* 21 */
    int (*ttk_GetStickyFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Ttk_Sticky *sticky_rtn); /* 22 */
    Ttk_Padding (*ttk_MakePadding) (short l, short t, short r, short b); /* 23 */
    Ttk_Padding (*ttk_UniformPadding) (short borderWidth); /* 24 */
    Ttk_Padding (*ttk_AddPadding) (Ttk_Padding pad1, Ttk_Padding pad2); /* 25 */
    Ttk_Padding (*ttk_RelievePadding) (Ttk_Padding padding, int relief, int n); /* 26 */
    Ttk_Box (*ttk_MakeBox) (int x, int y, int width, int height); /* 27 */
    int (*ttk_BoxContains) (Ttk_Box box, int x, int y); /* 28 */
    Ttk_Box (*ttk_PackBox) (Ttk_Box *cavity, int w, int h, Ttk_Side side); /* 29 */
    Ttk_Box (*ttk_StickBox) (Ttk_Box parcel, int w, int h, Ttk_Sticky sticky); /* 30 */
    Ttk_Box (*ttk_AnchorBox) (Ttk_Box parcel, int w, int h, Tk_Anchor anchor); /* 31 */
    Ttk_Box (*ttk_PadBox) (Ttk_Box b, Ttk_Padding p); /* 32 */
    Ttk_Box (*ttk_ExpandBox) (Ttk_Box b, Ttk_Padding p); /* 33 */
    Ttk_Box (*ttk_PlaceBox) (Ttk_Box *cavity, int w, int h, Ttk_Side side, Ttk_Sticky sticky); /* 34 */
    Tcl_Obj * (*ttk_NewBoxObj) (Ttk_Box box); /* 35 */
    void (*reserved36)(void);
    void (*reserved37)(void);
    void (*reserved38)(void);
    void (*reserved39)(void);
    int (*ttk_GetOrientFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *orient); /* 40 */
} TtkStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern const TtkStubs *ttkStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TTK_STUBS)

/*
 * Inline function declarations:
 */

#define Ttk_GetTheme \
	(ttkStubsPtr->ttk_GetTheme) /* 0 */
#define Ttk_GetDefaultTheme \
	(ttkStubsPtr->ttk_GetDefaultTheme) /* 1 */
#define Ttk_GetCurrentTheme \
	(ttkStubsPtr->ttk_GetCurrentTheme) /* 2 */
#define Ttk_CreateTheme \
	(ttkStubsPtr->ttk_CreateTheme) /* 3 */
#define Ttk_RegisterCleanup \
	(ttkStubsPtr->ttk_RegisterCleanup) /* 4 */
#define Ttk_RegisterElementSpec \
	(ttkStubsPtr->ttk_RegisterElementSpec) /* 5 */
#define Ttk_RegisterElement \
	(ttkStubsPtr->ttk_RegisterElement) /* 6 */
#define Ttk_RegisterElementFactory \
	(ttkStubsPtr->ttk_RegisterElementFactory) /* 7 */
#define Ttk_RegisterLayout \
	(ttkStubsPtr->ttk_RegisterLayout) /* 8 */
/* Slot 9 is reserved */
#define Ttk_GetStateSpecFromObj \
	(ttkStubsPtr->ttk_GetStateSpecFromObj) /* 10 */
#define Ttk_NewStateSpecObj \
	(ttkStubsPtr->ttk_NewStateSpecObj) /* 11 */
#define Ttk_GetStateMapFromObj \
	(ttkStubsPtr->ttk_GetStateMapFromObj) /* 12 */
#define Ttk_StateMapLookup \
	(ttkStubsPtr->ttk_StateMapLookup) /* 13 */
#define Ttk_StateTableLookup \
	(ttkStubsPtr->ttk_StateTableLookup) /* 14 */
/* Slot 15 is reserved */
/* Slot 16 is reserved */
/* Slot 17 is reserved */
/* Slot 18 is reserved */
/* Slot 19 is reserved */
#define Ttk_GetPaddingFromObj \
	(ttkStubsPtr->ttk_GetPaddingFromObj) /* 20 */
#define Ttk_GetBorderFromObj \
	(ttkStubsPtr->ttk_GetBorderFromObj) /* 21 */
#define Ttk_GetStickyFromObj \
	(ttkStubsPtr->ttk_GetStickyFromObj) /* 22 */
#define Ttk_MakePadding \
	(ttkStubsPtr->ttk_MakePadding) /* 23 */
#define Ttk_UniformPadding \
	(ttkStubsPtr->ttk_UniformPadding) /* 24 */
#define Ttk_AddPadding \
	(ttkStubsPtr->ttk_AddPadding) /* 25 */
#define Ttk_RelievePadding \
	(ttkStubsPtr->ttk_RelievePadding) /* 26 */
#define Ttk_MakeBox \
	(ttkStubsPtr->ttk_MakeBox) /* 27 */
#define Ttk_BoxContains \
	(ttkStubsPtr->ttk_BoxContains) /* 28 */
#define Ttk_PackBox \
	(ttkStubsPtr->ttk_PackBox) /* 29 */
#define Ttk_StickBox \
	(ttkStubsPtr->ttk_StickBox) /* 30 */
#define Ttk_AnchorBox \
	(ttkStubsPtr->ttk_AnchorBox) /* 31 */
#define Ttk_PadBox \
	(ttkStubsPtr->ttk_PadBox) /* 32 */
#define Ttk_ExpandBox \
	(ttkStubsPtr->ttk_ExpandBox) /* 33 */
#define Ttk_PlaceBox \
	(ttkStubsPtr->ttk_PlaceBox) /* 34 */
#define Ttk_NewBoxObj \
	(ttkStubsPtr->ttk_NewBoxObj) /* 35 */
/* Slot 36 is reserved */
/* Slot 37 is reserved */
/* Slot 38 is reserved */
/* Slot 39 is reserved */
#define Ttk_GetOrientFromObj \
	(ttkStubsPtr->ttk_GetOrientFromObj) /* 40 */

#endif /* defined(USE_TTK_STUBS) */

/* !END!: Do not edit above this line. */

#endif /* _TTKDECLS */
                                                                                                                                                                                                                                                                                                                                                                                                     ttkTheme.h                                                                                          0100644 0001750 0001750 00000035735 11435437120 034365  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk-private                                                             /* $Id$
 * Copyright (c) 2003 Joe English.  Freely redistributable.
 *
 * Declarations for Tk theme engine.
 */

#ifndef _TTKTHEME
#define _TTKTHEME

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MODULE_SCOPE
#   ifdef __cplusplus
#	define MODULE_SCOPE extern "C"
#   else
#	define MODULE_SCOPE extern
#   endif
#endif

#define TTKAPI MODULE_SCOPE

/* Ttk syncs to the Tk version & patchlevel */
#define TTK_VERSION    TK_VERSION
#define TTK_PATCH_LEVEL TK_PATCH_LEVEL

/*------------------------------------------------------------------------
 * +++ Defaults for element option specifications.
 */
#define DEFAULT_FONT 		"TkDefaultFont"
#define DEFAULT_BACKGROUND	"#d9d9d9"
#define DEFAULT_FOREGROUND	"black"

/*------------------------------------------------------------------------
 * +++ Widget states.
 * 	Keep in sync with stateNames[] in tkstate.c.
 */

typedef unsigned int Ttk_State;

#define TTK_STATE_ACTIVE	(1<<0)
#define TTK_STATE_DISABLED	(1<<1)
#define TTK_STATE_FOCUS		(1<<2)
#define TTK_STATE_PRESSED	(1<<3)
#define TTK_STATE_SELECTED	(1<<4)
#define TTK_STATE_BACKGROUND	(1<<5)
#define TTK_STATE_ALTERNATE	(1<<6)
#define TTK_STATE_INVALID	(1<<7)
#define TTK_STATE_READONLY 	(1<<8)
#define TTK_STATE_HOVER		(1<<9)
#define TTK_STATE_USER6		(1<<10)
#define TTK_STATE_USER5		(1<<11)
#define TTK_STATE_USER4		(1<<12)
#define TTK_STATE_USER3		(1<<13)
#define TTK_STATE_USER2		(1<<14)
#define TTK_STATE_USER1		(1<<15)

/* Maintenance note: if you get all the way to "USER1",
 * see tkstate.c
 */
typedef struct
{
    unsigned int onbits;	/* bits to turn on */
    unsigned int offbits;	/* bits to turn off */
} Ttk_StateSpec;

#define Ttk_StateMatches(state, spec) \
    (((state) & ((spec)->onbits|(spec)->offbits)) == (spec)->onbits)

#define Ttk_ModifyState(state, spec) \
    (((state) & ~(spec)->offbits) | (spec)->onbits)

TTKAPI int Ttk_GetStateSpecFromObj(Tcl_Interp *, Tcl_Obj *, Ttk_StateSpec *);
TTKAPI Tcl_Obj *Ttk_NewStateSpecObj(unsigned int onbits,unsigned int offbits);

/*------------------------------------------------------------------------
 * +++ State maps and state tables.
 */
typedef Tcl_Obj *Ttk_StateMap;

TTKAPI Ttk_StateMap Ttk_GetStateMapFromObj(Tcl_Interp *, Tcl_Obj *);
TTKAPI Tcl_Obj *Ttk_StateMapLookup(Tcl_Interp*, Ttk_StateMap, Ttk_State);

/*
 * Table for looking up an integer index based on widget state:
 */
typedef struct
{
    int index;			/* Value to return if this entry matches */
    unsigned int onBits;	/* Bits which must be set */
    unsigned int offBits;	/* Bits which must be cleared */
} Ttk_StateTable;

TTKAPI int Ttk_StateTableLookup(Ttk_StateTable map[], Ttk_State);

/*------------------------------------------------------------------------
 * +++ Padding.
 * 	Used to represent internal padding and borders.
 */
typedef struct
{
    short left;
    short top;
    short right;
    short bottom;
} Ttk_Padding;

TTKAPI int Ttk_GetPaddingFromObj(Tcl_Interp*,Tk_Window,Tcl_Obj*,Ttk_Padding*);
TTKAPI int Ttk_GetBorderFromObj(Tcl_Interp*,Tcl_Obj*,Ttk_Padding*);

TTKAPI Ttk_Padding Ttk_MakePadding(short l, short t, short r, short b);
TTKAPI Ttk_Padding Ttk_UniformPadding(short borderWidth);
TTKAPI Ttk_Padding Ttk_AddPadding(Ttk_Padding, Ttk_Padding);
TTKAPI Ttk_Padding Ttk_RelievePadding(Ttk_Padding, int relief, int n);

#define Ttk_PaddingWidth(p) ((p).left + (p).right)
#define Ttk_PaddingHeight(p) ((p).top + (p).bottom)

#define Ttk_SetMargins(tkwin, pad) \
    Tk_SetInternalBorderEx(tkwin, pad.left, pad.right, pad.top, pad.bottom)

/*------------------------------------------------------------------------
 * +++ Boxes.
 * 	Used to represent rectangular regions
 */
typedef struct 	/* Hey, this is an XRectangle! */
{
    int x;
    int y;
    int width;
    int height;
} Ttk_Box;

TTKAPI Ttk_Box Ttk_MakeBox(int x, int y, int width, int height);
TTKAPI int Ttk_BoxContains(Ttk_Box, int x, int y);

#define Ttk_WinBox(tkwin) Ttk_MakeBox(0,0,Tk_Width(tkwin),Tk_Height(tkwin))

/*------------------------------------------------------------------------
 * +++ Layout utilities.
 */
typedef enum {
    TTK_SIDE_LEFT, TTK_SIDE_TOP, TTK_SIDE_RIGHT, TTK_SIDE_BOTTOM
} Ttk_Side;

typedef unsigned int Ttk_Sticky;

/*
 * -sticky bits for Ttk_StickBox:
 */
#define TTK_STICK_W	(0x1)
#define TTK_STICK_E	(0x2)
#define TTK_STICK_N	(0x4)
#define TTK_STICK_S	(0x8)

/*
 * Aliases and useful combinations:
 */
#define TTK_FILL_X	(0x3)	/* -sticky ew */
#define TTK_FILL_Y	(0xC)	/* -sticky ns */
#define TTK_FILL_BOTH	(0xF)	/* -sticky nswe */

TTKAPI int Ttk_GetStickyFromObj(Tcl_Interp *, Tcl_Obj *, Ttk_Sticky *);
TTKAPI Tcl_Obj *Ttk_NewStickyObj(Ttk_Sticky);

/*
 * Extra bits for position specifications (combine -side and -sticky)
 */

typedef unsigned int Ttk_PositionSpec;	/* See below */

#define TTK_PACK_LEFT	(0x10)	/* pack at left of current parcel */
#define TTK_PACK_RIGHT	(0x20)	/* pack at right of current parcel */
#define TTK_PACK_TOP	(0x40)	/* pack at top of current parcel */
#define TTK_PACK_BOTTOM	(0x80)	/* pack at bottom of current parcel */
#define TTK_EXPAND	(0x100)	/* use entire parcel */
#define TTK_BORDER	(0x200)	/* draw this element after children */
#define TTK_UNIT	(0x400)	/* treat descendants as a part of element */

/*
 * Extra bits for layout specifications
 */
#define _TTK_CHILDREN	(0x1000)/* for LayoutSpecs -- children follow */
#define _TTK_LAYOUT_END	(0x2000)/* for LayoutSpecs -- end of child list */
#define _TTK_LAYOUT	(0x4000)/* for LayoutSpec tables -- define layout */

#define _TTK_MASK_STICK (0x0F)	/* See Ttk_UnparseLayout() */
#define _TTK_MASK_PACK	(0xF0)	/* See Ttk_UnparseLayout(), packStrings */

TTKAPI Ttk_Box Ttk_PackBox(Ttk_Box *cavity, int w, int h, Ttk_Side side);
TTKAPI Ttk_Box Ttk_StickBox(Ttk_Box parcel, int w, int h, Ttk_Sticky sticky);
TTKAPI Ttk_Box Ttk_AnchorBox(Ttk_Box parcel, int w, int h, Tk_Anchor anchor);
TTKAPI Ttk_Box Ttk_PadBox(Ttk_Box b, Ttk_Padding p);
TTKAPI Ttk_Box Ttk_ExpandBox(Ttk_Box b, Ttk_Padding p);
TTKAPI Ttk_Box Ttk_PlaceBox(Ttk_Box *cavity, int w,int h, Ttk_Side,Ttk_Sticky);
TTKAPI Ttk_Box Ttk_PositionBox(Ttk_Box *cavity, int w, int h, Ttk_PositionSpec);

/*------------------------------------------------------------------------
 * +++ Themes.
 */
MODULE_SCOPE void Ttk_StylePkgInit(Tcl_Interp *);

typedef struct Ttk_Theme_ *Ttk_Theme;
typedef struct Ttk_ElementClass_ Ttk_ElementClass;
typedef struct Ttk_Layout_ *Ttk_Layout;
typedef struct Ttk_LayoutNode_ *Ttk_Element;
typedef struct Ttk_Style_ *Ttk_Style;

TTKAPI Ttk_Theme Ttk_GetTheme(Tcl_Interp *interp, const char *name);
TTKAPI Ttk_Theme Ttk_GetDefaultTheme(Tcl_Interp *interp);
TTKAPI Ttk_Theme Ttk_GetCurrentTheme(Tcl_Interp *interp);

TTKAPI Ttk_Theme Ttk_CreateTheme(
    Tcl_Interp *interp, const char *name, Ttk_Theme parent);

typedef int (Ttk_ThemeEnabledProc)(Ttk_Theme theme, void *clientData);
MODULE_SCOPE void Ttk_SetThemeEnabledProc(Ttk_Theme, Ttk_ThemeEnabledProc, void *);

MODULE_SCOPE int Ttk_UseTheme(Tcl_Interp *, Ttk_Theme);

typedef void (Ttk_CleanupProc)(void *clientData);
TTKAPI void Ttk_RegisterCleanup(
    Tcl_Interp *interp, void *deleteData, Ttk_CleanupProc *cleanupProc);

/*------------------------------------------------------------------------
 * +++ Elements.
 */

enum TTKStyleVersion2 { TK_STYLE_VERSION_2 = 2 };

typedef void (Ttk_ElementSizeProc)(void *clientData, void *elementRecord,
        Tk_Window tkwin, int *widthPtr, int *heightPtr, Ttk_Padding*);
typedef void (Ttk_ElementDrawProc)(void *clientData, void *elementRecord,
        Tk_Window tkwin, Drawable d, Ttk_Box b, Ttk_State state);

typedef struct Ttk_ElementOptionSpec
{
    const char *optionName;		/* Command-line name of the widget option */
    Tk_OptionType type; 	/* Accepted option types */
    int offset;			/* Offset of Tcl_Obj* field in element record */
    const char *defaultValue;		/* Default value to used if resource missing */
} Ttk_ElementOptionSpec;

#define TK_OPTION_ANY TK_OPTION_STRING

typedef struct Ttk_ElementSpec {
    enum TTKStyleVersion2 version;	/* Version of the style support. */
    size_t elementSize;			/* Size of element record */
    Ttk_ElementOptionSpec *options;	/* List of options, NULL-terminated */
    Ttk_ElementSizeProc *size;		/* Compute min size and padding */
    Ttk_ElementDrawProc *draw;  	/* Draw the element */
} Ttk_ElementSpec;

TTKAPI Ttk_ElementClass *Ttk_RegisterElement(
	Tcl_Interp *interp, Ttk_Theme theme, const char *elementName,
	Ttk_ElementSpec *, void *clientData);

typedef int (*Ttk_ElementFactory)
	(Tcl_Interp *, void *clientData,
	 Ttk_Theme, const char *elementName, int objc, Tcl_Obj *const objv[]);

TTKAPI int Ttk_RegisterElementFactory(
	Tcl_Interp *, const char *name, Ttk_ElementFactory, void *clientData);

/*
 * Null element implementation:
 * has no geometry or layout; may be used as a stub or placeholder.
 */

typedef struct {
    Tcl_Obj	*unused;
} NullElement;

MODULE_SCOPE void TtkNullElementSize
	(void *, void *, Tk_Window, int *, int *, Ttk_Padding *);
MODULE_SCOPE void TtkNullElementDraw
	(void *, void *, Tk_Window, Drawable, Ttk_Box, Ttk_State);
MODULE_SCOPE Ttk_ElementOptionSpec TtkNullElementOptions[];
MODULE_SCOPE Ttk_ElementSpec ttkNullElementSpec;

/*------------------------------------------------------------------------
 * +++ Layout templates.
 */
typedef struct {
    const char *	elementName;
    unsigned		opcode;
} TTKLayoutInstruction, *Ttk_LayoutSpec;

#define TTK_BEGIN_LAYOUT_TABLE(name) \
				static TTKLayoutInstruction name[] = {
#define TTK_LAYOUT(name, content) \
				{ name, _TTK_CHILDREN|_TTK_LAYOUT }, \
				content \
				{ 0, _TTK_LAYOUT_END },
#define TTK_GROUP(name, flags, children) \
				{ name, flags | _TTK_CHILDREN }, \
				children \
				{ 0, _TTK_LAYOUT_END },
#define TTK_NODE(name, flags)	{ name, flags },
#define TTK_END_LAYOUT_TABLE	{ 0, _TTK_LAYOUT | _TTK_LAYOUT_END } };

#define TTK_BEGIN_LAYOUT(name)	static TTKLayoutInstruction name[] = {
#define TTK_END_LAYOUT 		{ 0, _TTK_LAYOUT_END } };

TTKAPI void Ttk_RegisterLayout(
    Ttk_Theme theme, const char *className, Ttk_LayoutSpec layoutSpec);

TTKAPI void Ttk_RegisterLayouts(
    Ttk_Theme theme, Ttk_LayoutSpec layoutTable);

/*------------------------------------------------------------------------
 * +++ Layout instances.
 */

MODULE_SCOPE Ttk_Layout Ttk_CreateLayout(
    Tcl_Interp *, Ttk_Theme, const char *name,
    void *recordPtr, Tk_OptionTable, Tk_Window tkwin);

MODULE_SCOPE Ttk_Layout Ttk_CreateSublayout(
    Tcl_Interp *, Ttk_Theme, Ttk_Layout, const char *name, Tk_OptionTable);

MODULE_SCOPE void Ttk_FreeLayout(Ttk_Layout);

MODULE_SCOPE void Ttk_LayoutSize(Ttk_Layout,Ttk_State,int *widthPtr,int *heightPtr);
MODULE_SCOPE void Ttk_PlaceLayout(Ttk_Layout, Ttk_State, Ttk_Box);
MODULE_SCOPE void Ttk_DrawLayout(Ttk_Layout, Ttk_State, Drawable);

MODULE_SCOPE void Ttk_RebindSublayout(Ttk_Layout, void *recordPtr);

MODULE_SCOPE Ttk_Element Ttk_IdentifyElement(Ttk_Layout, int x, int y);
MODULE_SCOPE Ttk_Element Ttk_FindElement(Ttk_Layout, const char *nodeName);

MODULE_SCOPE const char *Ttk_ElementName(Ttk_Element);
MODULE_SCOPE Ttk_Box Ttk_ElementParcel(Ttk_Element);

MODULE_SCOPE Ttk_Box Ttk_ClientRegion(Ttk_Layout, const char *elementName);

MODULE_SCOPE Ttk_Box Ttk_LayoutNodeInternalParcel(Ttk_Layout,Ttk_Element);
MODULE_SCOPE Ttk_Padding Ttk_LayoutNodeInternalPadding(Ttk_Layout,Ttk_Element);
MODULE_SCOPE void Ttk_LayoutNodeReqSize(Ttk_Layout, Ttk_Element, int *w, int *h);

MODULE_SCOPE void Ttk_PlaceElement(Ttk_Layout, Ttk_Element, Ttk_Box);
MODULE_SCOPE void Ttk_ChangeElementState(Ttk_Element,unsigned set,unsigned clr);

MODULE_SCOPE Tcl_Obj *Ttk_QueryOption(Ttk_Layout, const char *, Ttk_State);

TTKAPI Ttk_Style Ttk_LayoutStyle(Ttk_Layout);
TTKAPI Tcl_Obj *Ttk_StyleDefault(Ttk_Style, const char *optionName);
TTKAPI Tcl_Obj *Ttk_StyleMap(Ttk_Style, const char *optionName, Ttk_State);

/*------------------------------------------------------------------------
 * +++ Resource cache.
 * 	See resource.c for explanation.
 */

typedef struct Ttk_ResourceCache_ *Ttk_ResourceCache;
MODULE_SCOPE Ttk_ResourceCache Ttk_CreateResourceCache(Tcl_Interp *);
MODULE_SCOPE void Ttk_FreeResourceCache(Ttk_ResourceCache);

MODULE_SCOPE Ttk_ResourceCache Ttk_GetResourceCache(Tcl_Interp*);
MODULE_SCOPE Tcl_Obj *Ttk_UseFont(Ttk_ResourceCache, Tk_Window, Tcl_Obj *);
MODULE_SCOPE Tcl_Obj *Ttk_UseColor(Ttk_ResourceCache, Tk_Window, Tcl_Obj *);
MODULE_SCOPE Tcl_Obj *Ttk_UseBorder(Ttk_ResourceCache, Tk_Window, Tcl_Obj *);
MODULE_SCOPE Tk_Image Ttk_UseImage(Ttk_ResourceCache, Tk_Window, Tcl_Obj *);

MODULE_SCOPE void Ttk_RegisterNamedColor(Ttk_ResourceCache, const char *, XColor *);

/*------------------------------------------------------------------------
 * +++ Image specifications.
 */

typedef struct TtkImageSpec Ttk_ImageSpec;
TTKAPI Ttk_ImageSpec *TtkGetImageSpec(Tcl_Interp *, Tk_Window, Tcl_Obj *);
TTKAPI void TtkFreeImageSpec(Ttk_ImageSpec *);
TTKAPI Tk_Image TtkSelectImage(Ttk_ImageSpec *, Ttk_State);

/*------------------------------------------------------------------------
 * +++ Miscellaneous enumerations.
 * 	Other stuff that element implementations need to know about.
 */
typedef enum 			/* -default option values */
{
    TTK_BUTTON_DEFAULT_NORMAL,	/* widget defaultable */
    TTK_BUTTON_DEFAULT_ACTIVE,	/* currently the default widget */
    TTK_BUTTON_DEFAULT_DISABLED	/* not defaultable */
} Ttk_ButtonDefaultState;

TTKAPI int Ttk_GetButtonDefaultStateFromObj(Tcl_Interp *, Tcl_Obj *, int *);

typedef enum 			/* -compound option values */
{
    TTK_COMPOUND_NONE,  	/* image if specified, otherwise text */
    TTK_COMPOUND_TEXT,  	/* text only */
    TTK_COMPOUND_IMAGE,  	/* image only */
    TTK_COMPOUND_CENTER,	/* text overlays image */
    TTK_COMPOUND_TOP,   	/* image above text */
    TTK_COMPOUND_BOTTOM,	/* image below text */
    TTK_COMPOUND_LEFT,   	/* image to left of text */
    TTK_COMPOUND_RIGHT  	/* image to right of text */
} Ttk_Compound;

TTKAPI int Ttk_GetCompoundFromObj(Tcl_Interp *, Tcl_Obj *, int *);

typedef enum { 		/* -orient option values */
    TTK_ORIENT_HORIZONTAL,
    TTK_ORIENT_VERTICAL
} Ttk_Orient;

/*------------------------------------------------------------------------
 * +++ Utilities.
 */

typedef struct TtkEnsemble {
    const char *name;			/* subcommand name */
    Tcl_ObjCmdProc *command; 		/* subcommand implementation, OR: */
    const struct TtkEnsemble *ensemble;	/* subcommand ensemble */
} Ttk_Ensemble;

MODULE_SCOPE int Ttk_InvokeEnsemble(	/* Run an ensemble command */
    const Ttk_Ensemble *commands, int cmdIndex,
    void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]);

MODULE_SCOPE int TtkEnumerateHashTable(Tcl_Interp *, Tcl_HashTable *);

/*------------------------------------------------------------------------
 * +++ Stub table declarations.
 */

#include "ttkDecls.h"

/*
 * Drawing utilities for theme code:
 * (@@@ find a better home for this)
 */
typedef enum { ARROW_UP, ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT } ArrowDirection;
MODULE_SCOPE void TtkArrowSize(int h, ArrowDirection, int *widthPtr, int *heightPtr);
MODULE_SCOPE void TtkDrawArrow(Display *, Drawable, GC, Ttk_Box, ArrowDirection);
MODULE_SCOPE void TtkFillArrow(Display *, Drawable, GC, Ttk_Box, ArrowDirection);

#ifdef __cplusplus
}
#endif
#endif /* _TTKTHEME */
                                   osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers/tk.h0100644 0001750 0001750 00000160127 11430400547 031177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * tk.h --
 *
 *	Declarations for Tk-related things that are visible outside of the Tk
 *	module itself.
 *
 * Copyright (c) 1989-1994 The Regents of the University of California.
 * Copyright (c) 1994 The Australian National University.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 Ajuba Solutions.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TK
#define _TK

#include <tcl.h>
#if (TCL_MAJOR_VERSION != 8) || (TCL_MINOR_VERSION != 5)
#	error Tk 8.5 must be compiled with tcl.h from Tcl 8.5
#endif

/*
 * For C++ compilers, use extern "C"
 */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * When version numbers change here, you must also go into the following files
 * and update the version numbers:
 *
 * library/tk.tcl	(2 LOC patch)
 * unix/configure.in	(2 LOC Major, 2 LOC minor, 1 LOC patch)
 * win/configure.in	(as above)
 * README		(sections 0 and 1)
 * macosx/Wish.xcode/project.pbxproj (not patchlevel) 1 LOC
 * macosx/Wish-Common.xcconfig (not patchlevel) 1 LOC
 * win/README		(not patchlevel)
 * unix/README		(not patchlevel)
 * unix/tk.spec		(1 LOC patch)
 * win/tcl.m4		(not patchlevel)
 *
 * You may also need to update some of these files when the numbers change for
 * the version of Tcl that this release of Tk is compiled against.
 */

#define TK_MAJOR_VERSION	8
#define TK_MINOR_VERSION	5
#define TK_RELEASE_LEVEL	TCL_FINAL_RELEASE
#define TK_RELEASE_SERIAL	9

#define TK_VERSION		"8.5"
#define TK_PATCH_LEVEL		"8.5.9"

/*
 * A special definition used to allow this header file to be included from
 * windows or mac resource files so that they can obtain version information.
 * RC_INVOKED is defined by default by the windows RC tool and manually set
 * for macintosh.
 *
 * Resource compilers don't like all the C stuff, like typedefs and procedure
 * declarations, that occur below, so block them out.
 */

#ifndef RC_INVOKED

#ifndef _XLIB_H
#   if defined(MAC_OSX_TK)
#	include <X11/Xlib.h>
#	include <X11/X.h>
#   else
#	include <X11/Xlib.h>
#   endif
#endif
#ifdef __STDC__
#   include <stddef.h>
#endif

#ifdef BUILD_tk
# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * Decide whether or not to use input methods.
 */

#ifdef XNQueryInputStyle
#define TK_USE_INPUT_METHODS
#endif

/*
 * Dummy types that are used by clients:
 */

typedef struct Tk_BindingTable_ *Tk_BindingTable;
typedef struct Tk_Canvas_ *Tk_Canvas;
typedef struct Tk_Cursor_ *Tk_Cursor;
typedef struct Tk_ErrorHandler_ *Tk_ErrorHandler;
typedef struct Tk_Font_ *Tk_Font;
typedef struct Tk_Image__ *Tk_Image;
typedef struct Tk_ImageMaster_ *Tk_ImageMaster;
typedef struct Tk_OptionTable_ *Tk_OptionTable;
typedef struct Tk_PostscriptInfo_ *Tk_PostscriptInfo;
typedef struct Tk_TextLayout_ *Tk_TextLayout;
typedef struct Tk_Window_ *Tk_Window;
typedef struct Tk_3DBorder_ *Tk_3DBorder;
typedef struct Tk_Style_ *Tk_Style;
typedef struct Tk_StyleEngine_ *Tk_StyleEngine;
typedef struct Tk_StyledElement_ *Tk_StyledElement;

/*
 * Additional types exported to clients.
 */

typedef const char *Tk_Uid;

/*
 * The enum below defines the valid types for Tk configuration options as
 * implemented by Tk_InitOptions, Tk_SetOptions, etc.
 */

typedef enum {
    TK_OPTION_BOOLEAN,
    TK_OPTION_INT,
    TK_OPTION_DOUBLE,
    TK_OPTION_STRING,
    TK_OPTION_STRING_TABLE,
    TK_OPTION_COLOR,
    TK_OPTION_FONT,
    TK_OPTION_BITMAP,
    TK_OPTION_BORDER,
    TK_OPTION_RELIEF,
    TK_OPTION_CURSOR,
    TK_OPTION_JUSTIFY,
    TK_OPTION_ANCHOR,
    TK_OPTION_SYNONYM,
    TK_OPTION_PIXELS,
    TK_OPTION_WINDOW,
    TK_OPTION_END,
    TK_OPTION_CUSTOM,
    TK_OPTION_STYLE
} Tk_OptionType;

/*
 * Structures of the following type are used by widgets to specify their
 * configuration options. Typically each widget has a static array of these
 * structures, where each element of the array describes a single
 * configuration option. The array is passed to Tk_CreateOptionTable.
 */

typedef struct Tk_OptionSpec {
    Tk_OptionType type;		/* Type of option, such as TK_OPTION_COLOR;
				 * see definitions above. Last option in table
				 * must have type TK_OPTION_END. */
    const char *optionName;	/* Name used to specify option in Tcl
				 * commands. */
    const char *dbName;		/* Name for option in option database. */
    const char *dbClass;	/* Class for option in database. */
    const char *defValue;	/* Default value for option if not specified
				 * in command line, the option database, or
				 * the system. */
    int objOffset;		/* Where in record to store a Tcl_Obj * that
				 * holds the value of this option, specified
				 * as an offset in bytes from the start of the
				 * record. Use the Tk_Offset macro to generate
				 * values for this. -1 means don't store the
				 * Tcl_Obj in the record. */
    int internalOffset;		/* Where in record to store the internal
				 * representation of the value of this option,
				 * such as an int or XColor *. This field is
				 * specified as an offset in bytes from the
				 * start of the record. Use the Tk_Offset
				 * macro to generate values for it. -1 means
				 * don't store the internal representation in
				 * the record. */
    int flags;			/* Any combination of the values defined
				 * below. */
    ClientData clientData;	/* An alternate place to put option-specific
				 * data. Used for the monochrome default value
				 * for colors, etc. */
    int typeMask;		/* An arbitrary bit mask defined by the class
				 * manager; typically bits correspond to
				 * certain kinds of options such as all those
				 * that require a redisplay when they change.
				 * Tk_SetOptions returns the bit-wise OR of
				 * the typeMasks of all options that were
				 * changed. */
} Tk_OptionSpec;

/*
 * Flag values for Tk_OptionSpec structures. These flags are shared by
 * Tk_ConfigSpec structures, so be sure to coordinate any changes carefully.
 */

#define TK_OPTION_NULL_OK		(1 << 0)
#define TK_OPTION_DONT_SET_DEFAULT	(1 << 3)

/*
 * The following structure and function types are used by TK_OPTION_CUSTOM
 * options; the structure holds pointers to the functions needed by the Tk
 * option config code to handle a custom option.
 */

typedef int (Tk_CustomOptionSetProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj **value, char *widgRec,
	int offset, char *saveInternalPtr, int flags));
typedef Tcl_Obj *(Tk_CustomOptionGetProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *widgRec, int offset));
typedef void (Tk_CustomOptionRestoreProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *internalPtr, char *saveInternalPtr));
typedef void (Tk_CustomOptionFreeProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *internalPtr));

typedef struct Tk_ObjCustomOption {
    const char *name; /* Name of the custom option. */
    Tk_CustomOptionSetProc *setProc;
				/* Function to use to set a record's option
				 * value from a Tcl_Obj */
    Tk_CustomOptionGetProc *getProc;
				/* Function to use to get a Tcl_Obj
				 * representation from an internal
				 * representation of an option. */
    Tk_CustomOptionRestoreProc *restoreProc;
				/* Function to use to restore a saved value
				 * for the internal representation. */
    Tk_CustomOptionFreeProc *freeProc;
				/* Function to use to free the internal
				 * representation of an option. */
    ClientData clientData;	/* Arbitrary one-word value passed to the
				 * handling procs. */
} Tk_ObjCustomOption;

/*
 * Macro to use to fill in "offset" fields of the Tk_OptionSpec structure.
 * Computes number of bytes from beginning of structure to a given field.
 */

#ifdef offsetof
#define Tk_Offset(type, field) ((int) offsetof(type, field))
#else
#define Tk_Offset(type, field) ((int) ((char *) &((type *) 0)->field))
#endif

/*
 * The following two structures are used for error handling. When config
 * options are being modified, the old values are saved in a Tk_SavedOptions
 * structure. If an error occurs, then the contents of the structure can be
 * used to restore all of the old values. The contents of this structure are
 * for the private use Tk. No-one outside Tk should ever read or write any of
 * the fields of these structures.
 */

typedef struct Tk_SavedOption {
    struct TkOption *optionPtr;	/* Points to information that describes the
				 * option. */
    Tcl_Obj *valuePtr;		/* The old value of the option, in the form of
				 * a Tcl object; may be NULL if the value was
				 * not saved as an object. */
    double internalForm;	/* The old value of the option, in some
				 * internal representation such as an int or
				 * (XColor *). Valid only if the field
				 * optionPtr->specPtr->objOffset is < 0. The
				 * space must be large enough to accommodate a
				 * double, a long, or a pointer; right now it
				 * looks like a double (i.e., 8 bytes) is big
				 * enough. Also, using a double guarantees
				 * that the field is properly aligned for
				 * storing large values. */
} Tk_SavedOption;

#ifdef TCL_MEM_DEBUG
#   define TK_NUM_SAVED_OPTIONS 2
#else
#   define TK_NUM_SAVED_OPTIONS 20
#endif

typedef struct Tk_SavedOptions {
    char *recordPtr;		/* The data structure in which to restore
				 * configuration options. */
    Tk_Window tkwin;		/* Window associated with recordPtr; needed to
				 * restore certain options. */
    int numItems;		/* The number of valid items in items field. */
    Tk_SavedOption items[TK_NUM_SAVED_OPTIONS];
				/* Items used to hold old values. */
    struct Tk_SavedOptions *nextPtr;
				/* Points to next structure in list; needed if
				 * too many options changed to hold all the
				 * old values in a single structure. NULL
				 * means no more structures. */
} Tk_SavedOptions;

/*
 * Structure used to describe application-specific configuration options:
 * indicates procedures to call to parse an option and to return a text string
 * describing an option. THESE ARE DEPRECATED; PLEASE USE THE NEW STRUCTURES
 * LISTED ABOVE.
 */

/*
 * This is a temporary flag used while tkObjConfig and new widgets are in
 * development.
 */

#ifndef __NO_OLD_CONFIG

typedef int (Tk_OptionParseProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, CONST84 char *value, char *widgRec,
	int offset));
typedef char *(Tk_OptionPrintProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin, char *widgRec, int offset,
	Tcl_FreeProc **freeProcPtr));

typedef struct Tk_CustomOption {
    Tk_OptionParseProc *parseProc;
				/* Procedure to call to parse an option and
				 * store it in converted form. */
    Tk_OptionPrintProc *printProc;
				/* Procedure to return a printable string
				 * describing an existing option. */
    ClientData clientData;	/* Arbitrary one-word value used by option
				 * parser: passed to parseProc and
				 * printProc. */
} Tk_CustomOption;

/*
 * Structure used to specify information for Tk_ConfigureWidget. Each
 * structure gives complete information for one option, including how the
 * option is specified on the command line, where it appears in the option
 * database, etc.
 */

typedef struct Tk_ConfigSpec {
    int type;			/* Type of option, such as TK_CONFIG_COLOR;
				 * see definitions below. Last option in table
				 * must have type TK_CONFIG_END. */
    char *argvName;		/* Switch used to specify option in argv. NULL
				 * means this spec is part of a group. */
    Tk_Uid dbName;		/* Name for option in option database. */
    Tk_Uid dbClass;		/* Class for option in database. */
    Tk_Uid defValue;		/* Default value for option if not specified
				 * in command line or database. */
    int offset;			/* Where in widget record to store value; use
				 * Tk_Offset macro to generate values for
				 * this. */
    int specFlags;		/* Any combination of the values defined
				 * below; other bits are used internally by
				 * tkConfig.c. */
    Tk_CustomOption *customPtr;	/* If type is TK_CONFIG_CUSTOM then this is a
				 * pointer to info about how to parse and
				 * print the option. Otherwise it is
				 * irrelevant. */
} Tk_ConfigSpec;

/*
 * Type values for Tk_ConfigSpec structures. See the user documentation for
 * details.
 */

typedef enum {
    TK_CONFIG_BOOLEAN, TK_CONFIG_INT, TK_CONFIG_DOUBLE, TK_CONFIG_STRING,
    TK_CONFIG_UID, TK_CONFIG_COLOR, TK_CONFIG_FONT, TK_CONFIG_BITMAP,
    TK_CONFIG_BORDER, TK_CONFIG_RELIEF, TK_CONFIG_CURSOR,
    TK_CONFIG_ACTIVE_CURSOR, TK_CONFIG_JUSTIFY, TK_CONFIG_ANCHOR,
    TK_CONFIG_SYNONYM, TK_CONFIG_CAP_STYLE, TK_CONFIG_JOIN_STYLE,
    TK_CONFIG_PIXELS, TK_CONFIG_MM, TK_CONFIG_WINDOW, TK_CONFIG_CUSTOM,
    TK_CONFIG_END
} Tk_ConfigTypes;

/*
 * Possible values for flags argument to Tk_ConfigureWidget:
 */

#define TK_CONFIG_ARGV_ONLY	1
#define TK_CONFIG_OBJS		0x80

/*
 * Possible flag values for Tk_ConfigSpec structures. Any bits at or above
 * TK_CONFIG_USER_BIT may be used by clients for selecting certain entries.
 * Before changing any values here, coordinate with tkOldConfig.c
 * (internal-use-only flags are defined there).
 */

#define TK_CONFIG_NULL_OK		(1 << 0)
#define TK_CONFIG_COLOR_ONLY		(1 << 1)
#define TK_CONFIG_MONO_ONLY		(1 << 2)
#define TK_CONFIG_DONT_SET_DEFAULT	(1 << 3)
#define TK_CONFIG_OPTION_SPECIFIED      (1 << 4)
#define TK_CONFIG_USER_BIT		0x100
#endif /* __NO_OLD_CONFIG */

/*
 * Structure used to specify how to handle argv options.
 */

typedef struct {
    char *key;			/* The key string that flags the option in the
				 * argv array. */
    int type;			/* Indicates option type; see below. */
    char *src;			/* Value to be used in setting dst; usage
				 * depends on type. */
    char *dst;			/* Address of value to be modified; usage
				 * depends on type. */
    char *help;			/* Documentation message describing this
				 * option. */
} Tk_ArgvInfo;

/*
 * Legal values for the type field of a Tk_ArgvInfo: see the user
 * documentation for details.
 */

#define TK_ARGV_CONSTANT		15
#define TK_ARGV_INT			16
#define TK_ARGV_STRING			17
#define TK_ARGV_UID			18
#define TK_ARGV_REST			19
#define TK_ARGV_FLOAT			20
#define TK_ARGV_FUNC			21
#define TK_ARGV_GENFUNC			22
#define TK_ARGV_HELP			23
#define TK_ARGV_CONST_OPTION		24
#define TK_ARGV_OPTION_VALUE		25
#define TK_ARGV_OPTION_NAME_VALUE	26
#define TK_ARGV_END			27

/*
 * Flag bits for passing to Tk_ParseArgv:
 */

#define TK_ARGV_NO_DEFAULTS		0x1
#define TK_ARGV_NO_LEFTOVERS		0x2
#define TK_ARGV_NO_ABBREV		0x4
#define TK_ARGV_DONT_SKIP_FIRST_ARG	0x8

/*
 * Enumerated type for describing actions to be taken in response to a
 * restrictProc established by Tk_RestrictEvents.
 */

typedef enum {
    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT
} Tk_RestrictAction;

/*
 * Priority levels to pass to Tk_AddOption:
 */

#define TK_WIDGET_DEFAULT_PRIO	20
#define TK_STARTUP_FILE_PRIO	40
#define TK_USER_DEFAULT_PRIO	60
#define TK_INTERACTIVE_PRIO	80
#define TK_MAX_PRIO		100

/*
 * Relief values returned by Tk_GetRelief:
 */

#define TK_RELIEF_NULL		-1
#define TK_RELIEF_FLAT		0
#define TK_RELIEF_GROOVE	1
#define TK_RELIEF_RAISED	2
#define TK_RELIEF_RIDGE		3
#define TK_RELIEF_SOLID		4
#define TK_RELIEF_SUNKEN	5

/*
 * "Which" argument values for Tk_3DBorderGC:
 */

#define TK_3D_FLAT_GC		1
#define TK_3D_LIGHT_GC		2
#define TK_3D_DARK_GC		3

/*
 * Special EnterNotify/LeaveNotify "mode" for use in events generated by
 * tkShare.c. Pick a high enough value that it's unlikely to conflict with
 * existing values (like NotifyNormal) or any new values defined in the
 * future.
 */

#define TK_NOTIFY_SHARE		20

/*
 * Enumerated type for describing a point by which to anchor something:
 */

typedef enum {
    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,
    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,
    TK_ANCHOR_CENTER
} Tk_Anchor;

/*
 * Enumerated type for describing a style of justification:
 */

typedef enum {
    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER
} Tk_Justify;

/*
 * The following structure is used by Tk_GetFontMetrics() to return
 * information about the properties of a Tk_Font.
 */

typedef struct Tk_FontMetrics {
    int ascent;			/* The amount in pixels that the tallest
				 * letter sticks up above the baseline, plus
				 * any extra blank space added by the designer
				 * of the font. */
    int descent;		/* The largest amount in pixels that any
				 * letter sticks below the baseline, plus any
				 * extra blank space added by the designer of
				 * the font. */
    int linespace;		/* The sum of the ascent and descent. How far
				 * apart two lines of text in the same font
				 * should be placed so that none of the
				 * characters in one line overlap any of the
				 * characters in the other line. */
} Tk_FontMetrics;

/*
 * Flags passed to Tk_MeasureChars:
 */

#define TK_WHOLE_WORDS		1
#define TK_AT_LEAST_ONE		2
#define TK_PARTIAL_OK		4

/*
 * Flags passed to Tk_ComputeTextLayout:
 */

#define TK_IGNORE_TABS		8
#define TK_IGNORE_NEWLINES	16

/*
 * Widget class procedures used to implement platform specific widget
 * behavior.
 */

typedef Window (Tk_ClassCreateProc) _ANSI_ARGS_((Tk_Window tkwin,
	Window parent, ClientData instanceData));
typedef void (Tk_ClassWorldChangedProc) _ANSI_ARGS_((ClientData instanceData));
typedef void (Tk_ClassModalProc) _ANSI_ARGS_((Tk_Window tkwin,
	XEvent *eventPtr));

typedef struct Tk_ClassProcs {
    unsigned int size;
    Tk_ClassWorldChangedProc *worldChangedProc;
				/* Procedure to invoke when the widget needs
				 * to respond in some way to a change in the
				 * world (font changes, etc.) */
    Tk_ClassCreateProc *createProc;
				/* Procedure to invoke when the platform-
				 * dependent window needs to be created. */
    Tk_ClassModalProc *modalProc;
				/* Procedure to invoke after all bindings on a
				 * widget have been triggered in order to
				 * handle a modal loop. */
} Tk_ClassProcs;

/*
 * Simple accessor for Tk_ClassProcs structure. Checks that the structure is
 * not NULL, then checks the size field and returns either the requested
 * field, if present, or NULL if the structure is too small to have the field
 * (or NULL if the structure is NULL).
 *
 * A more general version of this function may be useful if other
 * size-versioned structure pop up in the future:
 *
 *	#define Tk_GetField(name, who, which) \
 *	    (((who) == NULL) ? NULL :
 *	    (((who)->size <= Tk_Offset(name, which)) ? NULL :(name)->which))
 */

#define Tk_GetClassProc(procs, which) \
    (((procs) == NULL) ? NULL : \
    (((procs)->size <= Tk_Offset(Tk_ClassProcs, which)) ? NULL:(procs)->which))

/*
 * Each geometry manager (the packer, the placer, etc.) is represented by a
 * structure of the following form, which indicates procedures to invoke in
 * the geometry manager to carry out certain functions.
 */

typedef void (Tk_GeomRequestProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin));
typedef void (Tk_GeomLostSlaveProc) _ANSI_ARGS_((ClientData clientData,
	Tk_Window tkwin));

typedef struct Tk_GeomMgr {
    const char *name;		/* Name of the geometry manager (command used
				 * to invoke it, or name of widget class that
				 * allows embedded widgets). */
    Tk_GeomRequestProc *requestProc;
				/* Procedure to invoke when a slave's
				 * requested geometry changes. */
    Tk_GeomLostSlaveProc *lostSlaveProc;
				/* Procedure to invoke when a slave is taken
				 * away from one geometry manager by another.
				 * NULL means geometry manager doesn't care
				 * when slaves are lost. */
} Tk_GeomMgr;

/*
 * Result values returned by Tk_GetScrollInfo:
 */

#define TK_SCROLL_MOVETO	1
#define TK_SCROLL_PAGES		2
#define TK_SCROLL_UNITS		3
#define TK_SCROLL_ERROR		4

/*
 *---------------------------------------------------------------------------
 *
 * Extensions to the X event set
 *
 *---------------------------------------------------------------------------
 */

#define VirtualEvent	    (MappingNotify + 1)
#define ActivateNotify	    (MappingNotify + 2)
#define DeactivateNotify    (MappingNotify + 3)
#define MouseWheelEvent     (MappingNotify + 4)
#define TK_LASTEVENT	    (MappingNotify + 5)

#define MouseWheelMask	    (1L << 28)
#define ActivateMask	    (1L << 29)
#define VirtualEventMask    (1L << 30)

/*
 * A virtual event shares most of its fields with the XKeyEvent and
 * XButtonEvent structures. 99% of the time a virtual event will be an
 * abstraction of a key or button event, so this structure provides the most
 * information to the user. The only difference is the changing of the detail
 * field for a virtual event so that it holds the name of the virtual event
 * being triggered.
 *
 * When using this structure, you should ensure that you zero out all the
 * fields first using memset() or bzero().
 */

typedef struct {
    int type;
    unsigned long serial;	/* # of last request processed by server. */
    Bool send_event;		/* True if this came from a SendEvent
				 * request. */
    Display *display;		/* Display the event was read from. */
    Window event;		/* Window on which event was requested. */
    Window root;		/* Root window that the event occured on. */
    Window subwindow;		/* Child window. */
    Time time;			/* Milliseconds. */
    int x, y;			/* Pointer x, y coordinates in event
				 * window. */
    int x_root, y_root;		/* Coordinates relative to root. */
    unsigned int state;		/* Key or button mask */
    Tk_Uid name;		/* Name of virtual event. */
    Bool same_screen;		/* Same screen flag. */
    Tcl_Obj *user_data;		/* Application-specific data reference; Tk
				 * will decrement the reference count *once*
				 * when it has finished processing the
				 * event. */
} XVirtualEvent;

typedef struct {
    int type;
    unsigned long serial;	/* # of last request processed by server. */
    Bool send_event;		/* True if this came from a SendEvent
				 * request. */
    Display *display;		/* Display the event was read from. */
    Window window;		/* Window in which event occurred. */
} XActivateDeactivateEvent;
typedef XActivateDeactivateEvent XActivateEvent;
typedef XActivateDeactivateEvent XDeactivateEvent;

/*
 *--------------------------------------------------------------
 *
 * Macros for querying Tk_Window structures. See the manual entries for
 * documentation.
 *
 *--------------------------------------------------------------
 */

#define Tk_Display(tkwin)	(((Tk_FakeWin *) (tkwin))->display)
#define Tk_ScreenNumber(tkwin)	(((Tk_FakeWin *) (tkwin))->screenNum)
#define Tk_Screen(tkwin) \
    (ScreenOfDisplay(Tk_Display(tkwin), Tk_ScreenNumber(tkwin)))
#define Tk_Depth(tkwin)		(((Tk_FakeWin *) (tkwin))->depth)
#define Tk_Visual(tkwin)	(((Tk_FakeWin *) (tkwin))->visual)
#define Tk_WindowId(tkwin)	(((Tk_FakeWin *) (tkwin))->window)
#define Tk_PathName(tkwin) 	(((Tk_FakeWin *) (tkwin))->pathName)
#define Tk_Name(tkwin)		(((Tk_FakeWin *) (tkwin))->nameUid)
#define Tk_Class(tkwin) 	(((Tk_FakeWin *) (tkwin))->classUid)
#define Tk_X(tkwin)		(((Tk_FakeWin *) (tkwin))->changes.x)
#define Tk_Y(tkwin)		(((Tk_FakeWin *) (tkwin))->changes.y)
#define Tk_Width(tkwin)		(((Tk_FakeWin *) (tkwin))->changes.width)
#define Tk_Height(tkwin) \
    (((Tk_FakeWin *) (tkwin))->changes.height)
#define Tk_Changes(tkwin)	(&((Tk_FakeWin *) (tkwin))->changes)
#define Tk_Attributes(tkwin)	(&((Tk_FakeWin *) (tkwin))->atts)
#define Tk_IsEmbedded(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_EMBEDDED)
#define Tk_IsContainer(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_CONTAINER)
#define Tk_IsMapped(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_MAPPED)
#define Tk_IsTopLevel(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_LEVEL)
#define Tk_HasWrapper(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_HAS_WRAPPER)
#define Tk_WinManaged(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_WIN_MANAGED)
#define Tk_TopWinHierarchy(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_TOP_HIERARCHY)
#define Tk_IsManageable(tkwin) \
    (((Tk_FakeWin *) (tkwin))->flags & TK_WM_MANAGEABLE)
#define Tk_ReqWidth(tkwin)	(((Tk_FakeWin *) (tkwin))->reqWidth)
#define Tk_ReqHeight(tkwin)	(((Tk_FakeWin *) (tkwin))->reqHeight)
/* Tk_InternalBorderWidth is deprecated */
#define Tk_InternalBorderWidth(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)
#define Tk_InternalBorderLeft(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderLeft)
#define Tk_InternalBorderRight(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderRight)
#define Tk_InternalBorderTop(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderTop)
#define Tk_InternalBorderBottom(tkwin) \
    (((Tk_FakeWin *) (tkwin))->internalBorderBottom)
#define Tk_MinReqWidth(tkwin)	(((Tk_FakeWin *) (tkwin))->minReqWidth)
#define Tk_MinReqHeight(tkwin)	(((Tk_FakeWin *) (tkwin))->minReqHeight)
#define Tk_Parent(tkwin)	(((Tk_FakeWin *) (tkwin))->parentPtr)
#define Tk_Colormap(tkwin)	(((Tk_FakeWin *) (tkwin))->atts.colormap)

/*
 * The structure below is needed by the macros above so that they can access
 * the fields of a Tk_Window. The fields not needed by the macros are declared
 * as "dummyX". The structure has its own type in order to prevent apps from
 * accessing Tk_Window fields except using official macros. WARNING!! The
 * structure definition must be kept consistent with the TkWindow structure in
 * tkInt.h. If you change one, then change the other. See the declaration in
 * tkInt.h for documentation on what the fields are used for internally.
 */

typedef struct Tk_FakeWin {
    Display *display;
    char *dummy1;		/* dispPtr */
    int screenNum;
    Visual *visual;
    int depth;
    Window window;
    char *dummy2;		/* childList */
    char *dummy3;		/* lastChildPtr */
    Tk_Window parentPtr;	/* parentPtr */
    char *dummy4;		/* nextPtr */
    char *dummy5;		/* mainPtr */
    char *pathName;
    Tk_Uid nameUid;
    Tk_Uid classUid;
    XWindowChanges changes;
    unsigned int dummy6;	/* dirtyChanges */
    XSetWindowAttributes atts;
    unsigned long dummy7;	/* dirtyAtts */
    unsigned int flags;
    char *dummy8;		/* handlerList */
#ifdef TK_USE_INPUT_METHODS
    XIC dummy9;			/* inputContext */
#endif /* TK_USE_INPUT_METHODS */
    ClientData *dummy10;	/* tagPtr */
    int dummy11;		/* numTags */
    int dummy12;		/* optionLevel */
    char *dummy13;		/* selHandlerList */
    char *dummy14;		/* geomMgrPtr */
    ClientData dummy15;		/* geomData */
    int reqWidth, reqHeight;
    int internalBorderLeft;
    char *dummy16;		/* wmInfoPtr */
    char *dummy17;		/* classProcPtr */
    ClientData dummy18;		/* instanceData */
    char *dummy19;		/* privatePtr */
    int internalBorderRight;
    int internalBorderTop;
    int internalBorderBottom;
    int minReqWidth;
    int minReqHeight;
} Tk_FakeWin;

/*
 * Flag values for TkWindow (and Tk_FakeWin) structures are:
 *
 * TK_MAPPED:			1 means window is currently mapped,
 *				0 means unmapped.
 * TK_TOP_LEVEL:		1 means this is a top-level widget.
 * TK_ALREADY_DEAD:		1 means the window is in the process of
 *				being destroyed already.
 * TK_NEED_CONFIG_NOTIFY:	1 means that the window has been reconfigured
 *				before it was made to exist. At the time of
 *				making it exist a ConfigureNotify event needs
 *				to be generated.
 * TK_GRAB_FLAG:		Used to manage grabs. See tkGrab.c for details
 * TK_CHECKED_IC:		1 means we've already tried to get an input
 *				context for this window; if the ic field is
 *				NULL it means that there isn't a context for
 *				the field.
 * TK_DONT_DESTROY_WINDOW:	1 means that Tk_DestroyWindow should not
 *				invoke XDestroyWindow to destroy this widget's
 *				X window. The flag is set when the window has
 *				already been destroyed elsewhere (e.g. by
 *				another application) or when it will be
 *				destroyed later (e.g. by destroying its parent)
 * TK_WM_COLORMAP_WINDOW:	1 means that this window has at some time
 *				appeared in the WM_COLORMAP_WINDOWS property
 *				for its toplevel, so we have to remove it from
 *				that property if the window is deleted and the
 *				toplevel isn't.
 * TK_EMBEDDED:			1 means that this window (which must be a
 *				toplevel) is not a free-standing window but
 *				rather is embedded in some other application.
 * TK_CONTAINER:		1 means that this window is a container, and
 *				that some other application (either in this
 *				process or elsewhere) may be embedding itself
 *				inside the window.
 * TK_BOTH_HALVES:		1 means that this window is used for
 *				application embedding (either as container or
 *				embedded application), and both the containing
 *				and embedded halves are associated with
 *				windows in this particular process.
 * TK_DEFER_MODAL:		1 means that this window has deferred a modal
 *				loop until all of the bindings for the current
 *				event have been invoked.
 * TK_WRAPPER:			1 means that this window is the extra wrapper
 *				window created around a toplevel to hold the
 *				menubar under Unix. See tkUnixWm.c for more
 *				information.
 * TK_REPARENTED:		1 means that this window has been reparented
 *				so that as far as the window system is
 *				concerned it isn't a child of its Tk parent.
 *				Initially this is used only for special Unix
 *				menubar windows.
 * TK_ANONYMOUS_WINDOW:		1 means that this window has no name, and is
 *				thus not accessible from Tk.
 * TK_HAS_WRAPPER		1 means that this window has a wrapper window
 * TK_WIN_MANAGED		1 means that this window is a child of the root
 *				window, and is managed by the window manager.
 * TK_TOP_HIERARCHY		1 means this window is at the top of a physical
 *				window hierarchy within this process, i.e. the
 *				window's parent either doesn't exist or is not
 *				owned by this Tk application.
 * TK_PROP_PROPCHANGE		1 means that PropertyNotify events in the
 *				window's children should propagate up to this
 *				window.
 * TK_WM_MANAGEABLE		1 marks a window as capable of being converted
 *				into a toplevel using [wm manage].
 */

#define TK_MAPPED		1
#define TK_TOP_LEVEL		2
#define TK_ALREADY_DEAD		4
#define TK_NEED_CONFIG_NOTIFY	8
#define TK_GRAB_FLAG		0x10
#define TK_CHECKED_IC		0x20
#define TK_DONT_DESTROY_WINDOW	0x40
#define TK_WM_COLORMAP_WINDOW	0x80
#define TK_EMBEDDED		0x100
#define TK_CONTAINER		0x200
#define TK_BOTH_HALVES		0x400
#define TK_DEFER_MODAL		0x800
#define TK_WRAPPER		0x1000
#define TK_REPARENTED		0x2000
#define TK_ANONYMOUS_WINDOW	0x4000
#define TK_HAS_WRAPPER		0x8000
#define TK_WIN_MANAGED		0x10000
#define TK_TOP_HIERARCHY	0x20000
#define TK_PROP_PROPCHANGE	0x40000
#define TK_WM_MANAGEABLE	0x80000

/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for defining new canvas items:
 *
 *--------------------------------------------------------------
 */

typedef enum {
    TK_STATE_NULL = -1, TK_STATE_ACTIVE, TK_STATE_DISABLED,
    TK_STATE_NORMAL, TK_STATE_HIDDEN
} Tk_State;

typedef struct Tk_SmoothMethod {
    char *name;
    int (*coordProc) _ANSI_ARGS_((Tk_Canvas canvas,
		double *pointPtr, int numPoints, int numSteps,
		XPoint xPoints[], double dblPoints[]));
    void (*postscriptProc) _ANSI_ARGS_((Tcl_Interp *interp,
		Tk_Canvas canvas, double *coordPtr,
		int numPoints, int numSteps));
} Tk_SmoothMethod;

/*
 * For each item in a canvas widget there exists one record with the following
 * structure. Each actual item is represented by a record with the following
 * stuff at its beginning, plus additional type-specific stuff after that.
 */

#define TK_TAG_SPACE 3

typedef struct Tk_Item {
    int id;			/* Unique identifier for this item (also
				 * serves as first tag for item). */
    struct Tk_Item *nextPtr;	/* Next in display list of all items in this
				 * canvas. Later items in list are drawn on
				 * top of earlier ones. */
    Tk_Uid staticTagSpace[TK_TAG_SPACE];
				/* Built-in space for limited # of tags. */
    Tk_Uid *tagPtr;		/* Pointer to array of tags. Usually points to
				 * staticTagSpace, but may point to malloc-ed
				 * space if there are lots of tags. */
    int tagSpace;		/* Total amount of tag space available at
				 * tagPtr. */
    int numTags;		/* Number of tag slots actually used at
				 * *tagPtr. */
    struct Tk_ItemType *typePtr;/* Table of procedures that implement this
				 * type of item. */
    int x1, y1, x2, y2;		/* Bounding box for item, in integer canvas
				 * units. Set by item-specific code and
				 * guaranteed to contain every pixel drawn in
				 * item. Item area includes x1 and y1 but not
				 * x2 and y2. */
    struct Tk_Item *prevPtr;	/* Previous in display list of all items in
				 * this canvas. Later items in list are drawn
				 * just below earlier ones. */
    Tk_State state;		/* State of item. */
    char *reserved1;		/* reserved for future use */
    int redraw_flags;		/* Some flags used in the canvas */

    /*
     *------------------------------------------------------------------
     * Starting here is additional type-specific stuff; see the declarations
     * for individual types to see what is part of each type. The actual space
     * below is determined by the "itemInfoSize" of the type's Tk_ItemType
     * record.
     *------------------------------------------------------------------
     */
} Tk_Item;

/*
 * Flag bits for canvases (redraw_flags):
 *
 * TK_ITEM_STATE_DEPENDANT -	1 means that object needs to be redrawn if the
 *				canvas state changes.
 * TK_ITEM_DONT_REDRAW - 	1 means that the object redraw is already been
 *				prepared, so the general canvas code doesn't
 *				need to do that any more.
 */

#define TK_ITEM_STATE_DEPENDANT		1
#define TK_ITEM_DONT_REDRAW		2

/*
 * Records of the following type are used to describe a type of item (e.g.
 * lines, circles, etc.) that can form part of a canvas widget.
 */

#ifdef USE_OLD_CANVAS
typedef int	Tk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv));
typedef int	Tk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv, int flags));
typedef int	Tk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    char **argv));
#else
typedef int	Tk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *const objv[]));
typedef int	Tk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *const objv[], int flags));
typedef int	Tk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
		    Tcl_Obj *const argv[]));
#endif
typedef void	Tk_ItemDeleteProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, Display *display));
typedef void	Tk_ItemDisplayProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, Display *display, Drawable dst,
		    int x, int y, int width, int height));
typedef double	Tk_ItemPointProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double *pointPtr));
typedef int	Tk_ItemAreaProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double *rectPtr));
typedef int	Tk_ItemPostscriptProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, int prepass));
typedef void	Tk_ItemScaleProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double originX, double originY,
		    double scaleX, double scaleY));
typedef void	Tk_ItemTranslateProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, double deltaX, double deltaY));
typedef int	Tk_ItemIndexProc _ANSI_ARGS_((Tcl_Interp *interp,
		    Tk_Canvas canvas, Tk_Item *itemPtr, char *indexString,
		    int *indexPtr));
typedef void	Tk_ItemCursorProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int index));
typedef int	Tk_ItemSelectionProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int offset, char *buffer,
		    int maxBytes));
typedef void	Tk_ItemInsertProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int beforeThis, char *string));
typedef void	Tk_ItemDCharsProc _ANSI_ARGS_((Tk_Canvas canvas,
		    Tk_Item *itemPtr, int first, int last));

#ifndef __NO_OLD_CONFIG

typedef struct Tk_ItemType {
    char *name;			/* The name of this type of item, such as
				 * "line". */
    int itemSize;		/* Total amount of space needed for item's
				 * record. */
    Tk_ItemCreateProc *createProc;
				/* Procedure to create a new item of this
				 * type. */
    Tk_ConfigSpec *configSpecs;	/* Pointer to array of configuration specs for
				 * this type. Used for returning configuration
				 * info. */
    Tk_ItemConfigureProc *configProc;
				/* Procedure to call to change configuration
				 * options. */
    Tk_ItemCoordProc *coordProc;/* Procedure to call to get and set the item's
				 * coordinates. */
    Tk_ItemDeleteProc *deleteProc;
				/* Procedure to delete existing item of this
				 * type. */
    Tk_ItemDisplayProc *displayProc;
				/* Procedure to display items of this type. */
    int alwaysRedraw;		/* Non-zero means displayProc should be called
				 * even when the item has been moved
				 * off-screen. */
    Tk_ItemPointProc *pointProc;/* Computes distance from item to a given
				 * point. */
    Tk_ItemAreaProc *areaProc;	/* Computes whether item is inside, outside,
				 * or overlapping an area. */
    Tk_ItemPostscriptProc *postscriptProc;
				/* Procedure to write a Postscript description
				 * for items of this type. */
    Tk_ItemScaleProc *scaleProc;/* Procedure to rescale items of this type. */
    Tk_ItemTranslateProc *translateProc;
				/* Procedure to translate items of this
				 * type. */
    Tk_ItemIndexProc *indexProc;/* Procedure to determine index of indicated
				 * character. NULL if item doesn't support
				 * indexing. */
    Tk_ItemCursorProc *icursorProc;
				/* Procedure to set insert cursor posn to just
				 * before a given position. */
    Tk_ItemSelectionProc *selectionProc;
				/* Procedure to return selection (in STRING
				 * format) when it is in this item. */
    Tk_ItemInsertProc *insertProc;
				/* Procedure to insert something into an
				 * item. */
    Tk_ItemDCharsProc *dCharsProc;
				/* Procedure to delete characters from an
				 * item. */
    struct Tk_ItemType *nextPtr;/* Used to link types together into a list. */
    char *reserved1;		/* Reserved for future extension. */
    int reserved2;		/* Carefully compatible with */
    char *reserved3;		/* Jan Nijtmans dash patch */
    char *reserved4;
} Tk_ItemType;

#endif

/*
 * The following structure provides information about the selection and the
 * insertion cursor. It is needed by only a few items, such as those that
 * display text. It is shared by the generic canvas code and the item-specific
 * code, but most of the fields should be written only by the canvas generic
 * code.
 */

typedef struct Tk_CanvasTextInfo {
    Tk_3DBorder selBorder;	/* Border and background for selected
				 * characters. Read-only to items.*/
    int selBorderWidth;		/* Width of border around selection. Read-only
				 * to items. */
    XColor *selFgColorPtr;	/* Foreground color for selected text.
				 * Read-only to items. */
    Tk_Item *selItemPtr;	/* Pointer to selected item. NULL means
				 * selection isn't in this canvas. Writable by
				 * items. */
    int selectFirst;		/* Character index of first selected
				 * character. Writable by items. */
    int selectLast;		/* Character index of last selected character.
				 * Writable by items. */
    Tk_Item *anchorItemPtr;	/* Item corresponding to "selectAnchor": not
				 * necessarily selItemPtr. Read-only to
				 * items. */
    int selectAnchor;		/* Character index of fixed end of selection
				 * (i.e. "select to" operation will use this
				 * as one end of the selection). Writable by
				 * items. */
    Tk_3DBorder insertBorder;	/* Used to draw vertical bar for insertion
				 * cursor. Read-only to items. */
    int insertWidth;		/* Total width of insertion cursor. Read-only
				 * to items. */
    int insertBorderWidth;	/* Width of 3-D border around insert cursor.
				 * Read-only to items. */
    Tk_Item *focusItemPtr;	/* Item that currently has the input focus, or
				 * NULL if no such item. Read-only to items. */
    int gotFocus;		/* Non-zero means that the canvas widget has
				 * the input focus. Read-only to items.*/
    int cursorOn;		/* Non-zero means that an insertion cursor
				 * should be displayed in focusItemPtr.
				 * Read-only to items.*/
} Tk_CanvasTextInfo;

/*
 * Structures used for Dashing and Outline.
 */

typedef struct Tk_Dash {
    int number;
    union {
	char *pt;
	char array[sizeof(char *)];
    } pattern;
} Tk_Dash;

typedef struct Tk_TSOffset {
    int flags;			/* Flags; see below for possible values */
    int xoffset;		/* x offset */
    int yoffset;		/* y offset */
} Tk_TSOffset;

/*
 * Bit fields in Tk_Offset->flags:
 */

#define TK_OFFSET_INDEX		1
#define TK_OFFSET_RELATIVE	2
#define TK_OFFSET_LEFT		4
#define TK_OFFSET_CENTER	8
#define TK_OFFSET_RIGHT		16
#define TK_OFFSET_TOP		32
#define TK_OFFSET_MIDDLE	64
#define TK_OFFSET_BOTTOM	128

typedef struct Tk_Outline {
    GC gc;			/* Graphics context. */
    double width;		/* Width of outline. */
    double activeWidth;		/* Width of outline. */
    double disabledWidth;	/* Width of outline. */
    int offset;			/* Dash offset. */
    Tk_Dash dash;		/* Dash pattern. */
    Tk_Dash activeDash;		/* Dash pattern if state is active. */
    Tk_Dash disabledDash;	/* Dash pattern if state is disabled. */
    VOID *reserved1;		/* Reserved for future expansion. */
    VOID *reserved2;
    VOID *reserved3;
    Tk_TSOffset tsoffset;	/* Stipple offset for outline. */
    XColor *color;		/* Outline color. */
    XColor *activeColor;	/* Outline color if state is active. */
    XColor *disabledColor;	/* Outline color if state is disabled. */
    Pixmap stipple;		/* Outline Stipple pattern. */
    Pixmap activeStipple;	/* Outline Stipple pattern if state is
				 * active. */
    Pixmap disabledStipple;	/* Outline Stipple pattern if state is
				 * disabled. */
} Tk_Outline;

/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for managing images:
 *
 *--------------------------------------------------------------
 */

typedef struct Tk_ImageType Tk_ImageType;
#ifdef USE_OLD_IMAGE
typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *name, int argc, char **argv, Tk_ImageType *typePtr,
	Tk_ImageMaster master, ClientData *masterDataPtr));
#else
typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *name, int objc, Tcl_Obj *const objv[], Tk_ImageType *typePtr,
	Tk_ImageMaster master, ClientData *masterDataPtr));
#endif
typedef ClientData (Tk_ImageGetProc) _ANSI_ARGS_((Tk_Window tkwin,
	ClientData masterData));
typedef void (Tk_ImageDisplayProc) _ANSI_ARGS_((ClientData instanceData,
	Display *display, Drawable drawable, int imageX, int imageY,
	int width, int height, int drawableX, int drawableY));
typedef void (Tk_ImageFreeProc) _ANSI_ARGS_((ClientData instanceData,
	Display *display));
typedef void (Tk_ImageDeleteProc) _ANSI_ARGS_((ClientData masterData));
typedef void (Tk_ImageChangedProc) _ANSI_ARGS_((ClientData clientData,
	int x, int y, int width, int height, int imageWidth,
	int imageHeight));
typedef int (Tk_ImagePostscriptProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo,
	int x, int y, int width, int height, int prepass));

/*
 * The following structure represents a particular type of image (bitmap, xpm
 * image, etc.). It provides information common to all images of that type,
 * such as the type name and a collection of procedures in the image manager
 * that respond to various events. Each image manager is represented by one of
 * these structures.
 */

struct Tk_ImageType {
    char *name;			/* Name of image type. */
    Tk_ImageCreateProc *createProc;
				/* Procedure to call to create a new image of
				 * this type. */
    Tk_ImageGetProc *getProc;	/* Procedure to call the first time
				 * Tk_GetImage is called in a new way (new
				 * visual or screen). */
    Tk_ImageDisplayProc *displayProc;
				/* Call to draw image, in response to
				 * Tk_RedrawImage calls. */
    Tk_ImageFreeProc *freeProc;	/* Procedure to call whenever Tk_FreeImage is
				 * called to release an instance of an
				 * image. */
    Tk_ImageDeleteProc *deleteProc;
				/* Procedure to call to delete image. It will
				 * not be called until after freeProc has been
				 * called for each instance of the image. */
    Tk_ImagePostscriptProc *postscriptProc;
				/* Procedure to call to produce postscript
				 * output for the image. */
    struct Tk_ImageType *nextPtr;
				/* Next in list of all image types currently
				 * known. Filled in by Tk, not by image
				 * manager. */
    char *reserved;		/* reserved for future expansion */
};

/*
 *--------------------------------------------------------------
 *
 * Additional definitions used to manage images of type "photo".
 *
 *--------------------------------------------------------------
 */

/*
 * The following type is used to identify a particular photo image to be
 * manipulated:
 */

typedef void *Tk_PhotoHandle;

/*
 * The following structure describes a block of pixels in memory:
 */

typedef struct Tk_PhotoImageBlock {
    unsigned char *pixelPtr;	/* Pointer to the first pixel. */
    int width;			/* Width of block, in pixels. */
    int height;			/* Height of block, in pixels. */
    int pitch;			/* Address difference between corresponding
				 * pixels in successive lines. */
    int pixelSize;		/* Address difference between successive
				 * pixels in the same line. */
    int offset[4];		/* Address differences between the red, green,
				 * blue and alpha components of the pixel and
				 * the pixel as a whole. */
} Tk_PhotoImageBlock;

/*
 * The following values control how blocks are combined into photo images when
 * the alpha component of a pixel is not 255, a.k.a. the compositing rule.
 */

#define TK_PHOTO_COMPOSITE_OVERLAY	0
#define TK_PHOTO_COMPOSITE_SET		1

/*
 * Procedure prototypes and structures used in reading and writing photo
 * images:
 */

typedef struct Tk_PhotoImageFormat Tk_PhotoImageFormat;
#ifdef USE_OLD_IMAGE
typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,
	char *fileName, char *formatString, int *widthPtr, int *heightPtr));
typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((char *string,
	char *formatString, int *widthPtr, int *heightPtr));
typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Channel chan, char *fileName, char *formatString,
	Tk_PhotoHandle imageHandle, int destX, int destY,
	int width, int height, int srcX, int srcY));
typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *string, char *formatString, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	char *fileName, char *formatString, Tk_PhotoImageBlock *blockPtr));
typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *dataPtr, char *formatString,
	Tk_PhotoImageBlock *blockPtr));
#else
typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,
	const char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr, Tcl_Interp *interp));
typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr,
	Tcl_Interp *interp));
typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Channel chan, const char *fileName, Tcl_Obj *format,
	Tk_PhotoHandle imageHandle, int destX, int destY,
	int width, int height, int srcX, int srcY));
typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Obj *dataObj, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	const char *fileName, Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
#endif

/*
 * The following structure represents a particular file format for storing
 * images (e.g., PPM, GIF, JPEG, etc.). It provides information to allow image
 * files of that format to be recognized and read into a photo image.
 */

struct Tk_PhotoImageFormat {
    char *name;			/* Name of image file format */
    Tk_ImageFileMatchProc *fileMatchProc;
				/* Procedure to call to determine whether an
				 * image file matches this format. */
    Tk_ImageStringMatchProc *stringMatchProc;
				/* Procedure to call to determine whether the
				 * data in a string matches this format. */
    Tk_ImageFileReadProc *fileReadProc;
				/* Procedure to call to read data from an
				 * image file into a photo image. */
    Tk_ImageStringReadProc *stringReadProc;
				/* Procedure to call to read data from a
				 * string into a photo image. */
    Tk_ImageFileWriteProc *fileWriteProc;
				/* Procedure to call to write data from a
				 * photo image to a file. */
    Tk_ImageStringWriteProc *stringWriteProc;
				/* Procedure to call to obtain a string
				 * representation of the data in a photo
				 * image.*/
    struct Tk_PhotoImageFormat *nextPtr;
				/* Next in list of all photo image formats
				 * currently known. Filled in by Tk, not by
				 * image format handler. */
};

#ifdef USE_OLD_IMAGE
#define Tk_CreateImageType Tk_CreateOldImageType
#define Tk_CreatePhotoImageFormat Tk_CreateOldPhotoImageFormat
#endif

/*
 *--------------------------------------------------------------
 *
 * Procedure prototypes and structures used for managing styles:
 *
 *--------------------------------------------------------------
 */

/*
 * Style support version tag.
 */

#define TK_STYLE_VERSION_1      0x1
#define TK_STYLE_VERSION        TK_STYLE_VERSION_1

/*
 * The following structures and prototypes are used as static templates to
 * declare widget elements.
 */

typedef void (Tk_GetElementSizeProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        int width, int height, int inner, int *widthPtr, int *heightPtr));
typedef void (Tk_GetElementBoxProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        int x, int y, int width, int height, int inner, int *xPtr, int *yPtr,
        int *widthPtr, int *heightPtr));
typedef int (Tk_GetElementBorderWidthProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin));
typedef void (Tk_DrawElementProc) _ANSI_ARGS_((ClientData clientData,
        char *recordPtr, const Tk_OptionSpec **optionsPtr, Tk_Window tkwin,
        Drawable d, int x, int y, int width, int height, int state));

typedef struct Tk_ElementOptionSpec {
    char *name;                 /* Name of the required option. */
    Tk_OptionType type;         /* Accepted option type. TK_OPTION_END means
                                 * any. */
} Tk_ElementOptionSpec;

typedef struct Tk_ElementSpec {
    int version;                /* Version of the style support. */
    char *name;                 /* Name of element. */
    Tk_ElementOptionSpec *options;
                                /* List of required options. Last one's name
                                 * must be NULL. */
    Tk_GetElementSizeProc *getSize;
                                /* Compute the external (resp. internal) size
                                 * of the element from its desired internal
                                 * (resp. external) size. */
    Tk_GetElementBoxProc *getBox;
                                /* Compute the inscribed or bounding boxes
                                 * within a given area. */
    Tk_GetElementBorderWidthProc *getBorderWidth;
                                /* Return the element's internal border width.
                                 * Mostly useful for widgets. */
    Tk_DrawElementProc *draw;	/* Draw the element in the given bounding
				 * box. */
} Tk_ElementSpec;

/*
 * Element state flags. Can be OR'ed.
 */

#define TK_ELEMENT_STATE_ACTIVE         1<<0
#define TK_ELEMENT_STATE_DISABLED       1<<1
#define TK_ELEMENT_STATE_FOCUS          1<<2
#define TK_ELEMENT_STATE_PRESSED        1<<3

/*
 *--------------------------------------------------------------
 *
 * The definitions below provide backward compatibility for functions and
 * types related to event handling that used to be in Tk but have moved to
 * Tcl.
 *
 *--------------------------------------------------------------
 */

#define TK_READABLE		TCL_READABLE
#define TK_WRITABLE		TCL_WRITABLE
#define TK_EXCEPTION		TCL_EXCEPTION

#define TK_DONT_WAIT		TCL_DONT_WAIT
#define TK_X_EVENTS		TCL_WINDOW_EVENTS
#define TK_WINDOW_EVENTS	TCL_WINDOW_EVENTS
#define TK_FILE_EVENTS		TCL_FILE_EVENTS
#define TK_TIMER_EVENTS		TCL_TIMER_EVENTS
#define TK_IDLE_EVENTS		TCL_IDLE_EVENTS
#define TK_ALL_EVENTS		TCL_ALL_EVENTS

#define Tk_IdleProc		Tcl_IdleProc
#define Tk_FileProc		Tcl_FileProc
#define Tk_TimerProc		Tcl_TimerProc
#define Tk_TimerToken		Tcl_TimerToken

#define Tk_BackgroundError	Tcl_BackgroundError
#define Tk_CancelIdleCall	Tcl_CancelIdleCall
#define Tk_CreateFileHandler	Tcl_CreateFileHandler
#define Tk_CreateTimerHandler	Tcl_CreateTimerHandler
#define Tk_DeleteFileHandler	Tcl_DeleteFileHandler
#define Tk_DeleteTimerHandler	Tcl_DeleteTimerHandler
#define Tk_DoOneEvent		Tcl_DoOneEvent
#define Tk_DoWhenIdle		Tcl_DoWhenIdle
#define Tk_Sleep		Tcl_Sleep

/* Additional stuff that has moved to Tcl: */

#define Tk_EventuallyFree	Tcl_EventuallyFree
#define Tk_FreeProc		Tcl_FreeProc
#define Tk_Preserve		Tcl_Preserve
#define Tk_Release		Tcl_Release

/* Removed Tk_Main, use macro instead */
#define Tk_Main(argc, argv, proc) \
    Tk_MainEx(argc, argv, proc, Tcl_CreateInterp())

const char *		Tk_InitStubs _ANSI_ARGS_((Tcl_Interp *interp,
			    const char *version, int exact));
EXTERN const char *	Tk_PkgInitStubsCheck _ANSI_ARGS_((Tcl_Interp *interp,
			    const char *version, int exact));

#ifndef USE_TK_STUBS

#define Tk_InitStubs(interp, version, exact) \
    Tk_PkgInitStubsCheck(interp, version, exact)

#endif

#define Tk_InitImageArgs(interp, argc, argv) /**/


/*
 *--------------------------------------------------------------
 *
 * Additional procedure types defined by Tk.
 *
 *--------------------------------------------------------------
 */

typedef int (Tk_ErrorProc) _ANSI_ARGS_((ClientData clientData,
	XErrorEvent *errEventPtr));
typedef void (Tk_EventProc) _ANSI_ARGS_((ClientData clientData,
	XEvent *eventPtr));
typedef int (Tk_GenericProc) _ANSI_ARGS_((ClientData clientData,
	XEvent *eventPtr));
typedef int (Tk_ClientMessageProc) _ANSI_ARGS_((Tk_Window tkwin,
	XEvent *eventPtr));
typedef int (Tk_GetSelProc) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, char *portion));
typedef void (Tk_LostSelProc) _ANSI_ARGS_((ClientData clientData));
typedef Tk_RestrictAction (Tk_RestrictProc) _ANSI_ARGS_((
	ClientData clientData, XEvent *eventPtr));
typedef int (Tk_SelectionProc) _ANSI_ARGS_((ClientData clientData,
	int offset, char *buffer, int maxBytes));

/*
 *--------------------------------------------------------------
 *
 * Platform independant exported procedures and variables.
 *
 *--------------------------------------------------------------
 */

#include "tkDecls.h"

/*
 * Allow users to say that they don't want to alter their source to add extra
 * arguments to Tk_PhotoPutBlock() et al; DO NOT DEFINE THIS WHEN BUILDING TK.
 *
 * This goes after the inclusion of the stubbed-decls so that the declarations
 * of what is actually there can be correct.
 */

#ifdef USE_COMPOSITELESS_PHOTO_PUT_BLOCK
#   ifdef Tk_PhotoPutBlock
#	undef Tk_PhotoPutBlock
#   endif
#   define Tk_PhotoPutBlock		Tk_PhotoPutBlock_NoComposite
#   ifdef Tk_PhotoPutZoomedBlock
#	undef Tk_PhotoPutZoomedBlock
#   endif
#   define Tk_PhotoPutZoomedBlock	Tk_PhotoPutZoomedBlock_NoComposite
#   define USE_PANIC_ON_PHOTO_ALLOC_FAILURE
#else /* !USE_COMPOSITELESS_PHOTO_PUT_BLOCK */
#   ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE
#	ifdef Tk_PhotoPutBlock
#	    undef Tk_PhotoPutBlock
#	endif
#	define Tk_PhotoPutBlock		Tk_PhotoPutBlock_Panic
#	ifdef Tk_PhotoPutZoomedBlock
#	    undef Tk_PhotoPutZoomedBlock
#	endif
#	define Tk_PhotoPutZoomedBlock	Tk_PhotoPutZoomedBlock_Panic
#   endif /* USE_PANIC_ON_PHOTO_ALLOC_FAILURE */
#endif /* USE_COMPOSITELESS_PHOTO_PUT_BLOCK */
#ifdef USE_PANIC_ON_PHOTO_ALLOC_FAILURE
#   ifdef Tk_PhotoExpand
#	undef Tk_PhotoExpand
#   endif
#   define Tk_PhotoExpand		Tk_PhotoExpand_Panic
#   ifdef Tk_PhotoSetSize
#	undef Tk_PhotoSetSize
#   endif
#   define Tk_PhotoSetSize		Tk_PhotoSetSize_Panic
#endif /* USE_PANIC_ON_PHOTO_ALLOC_FAILURE */

/*
 * Tcl commands exported by Tk:
 */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* RC_INVOKED */

/*
 * end block for C++
 */

#ifdef __cplusplus
}
#endif

#endif /* _TK */

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                         tkDecls.h                                                                                           0100644 0001750 0001750 00000322614 11442001432 032065  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers                                                                        /*
 * tkDecls.h --
 *
 *	Declarations of functions in the platform independent public Tcl API.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKDECLS
#define _TKDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tk.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifndef Tk_MainLoop_TCL_DECLARED
#define Tk_MainLoop_TCL_DECLARED
/* 0 */
EXTERN void		Tk_MainLoop(void);
#endif
#ifndef Tk_3DBorderColor_TCL_DECLARED
#define Tk_3DBorderColor_TCL_DECLARED
/* 1 */
EXTERN XColor *		Tk_3DBorderColor(Tk_3DBorder border);
#endif
#ifndef Tk_3DBorderGC_TCL_DECLARED
#define Tk_3DBorderGC_TCL_DECLARED
/* 2 */
EXTERN GC		Tk_3DBorderGC(Tk_Window tkwin, Tk_3DBorder border,
				int which);
#endif
#ifndef Tk_3DHorizontalBevel_TCL_DECLARED
#define Tk_3DHorizontalBevel_TCL_DECLARED
/* 3 */
EXTERN void		Tk_3DHorizontalBevel(Tk_Window tkwin,
				Drawable drawable, Tk_3DBorder border, int x,
				int y, int width, int height, int leftIn,
				int rightIn, int topBevel, int relief);
#endif
#ifndef Tk_3DVerticalBevel_TCL_DECLARED
#define Tk_3DVerticalBevel_TCL_DECLARED
/* 4 */
EXTERN void		Tk_3DVerticalBevel(Tk_Window tkwin,
				Drawable drawable, Tk_3DBorder border, int x,
				int y, int width, int height, int leftBevel,
				int relief);
#endif
#ifndef Tk_AddOption_TCL_DECLARED
#define Tk_AddOption_TCL_DECLARED
/* 5 */
EXTERN void		Tk_AddOption(Tk_Window tkwin, CONST char *name,
				CONST char *value, int priority);
#endif
#ifndef Tk_BindEvent_TCL_DECLARED
#define Tk_BindEvent_TCL_DECLARED
/* 6 */
EXTERN void		Tk_BindEvent(Tk_BindingTable bindingTable,
				XEvent *eventPtr, Tk_Window tkwin,
				int numObjects, ClientData *objectPtr);
#endif
#ifndef Tk_CanvasDrawableCoords_TCL_DECLARED
#define Tk_CanvasDrawableCoords_TCL_DECLARED
/* 7 */
EXTERN void		Tk_CanvasDrawableCoords(Tk_Canvas canvas, double x,
				double y, short *drawableXPtr,
				short *drawableYPtr);
#endif
#ifndef Tk_CanvasEventuallyRedraw_TCL_DECLARED
#define Tk_CanvasEventuallyRedraw_TCL_DECLARED
/* 8 */
EXTERN void		Tk_CanvasEventuallyRedraw(Tk_Canvas canvas, int x1,
				int y1, int x2, int y2);
#endif
#ifndef Tk_CanvasGetCoord_TCL_DECLARED
#define Tk_CanvasGetCoord_TCL_DECLARED
/* 9 */
EXTERN int		Tk_CanvasGetCoord(Tcl_Interp *interp,
				Tk_Canvas canvas, CONST char *str,
				double *doublePtr);
#endif
#ifndef Tk_CanvasGetTextInfo_TCL_DECLARED
#define Tk_CanvasGetTextInfo_TCL_DECLARED
/* 10 */
EXTERN Tk_CanvasTextInfo * Tk_CanvasGetTextInfo(Tk_Canvas canvas);
#endif
#ifndef Tk_CanvasPsBitmap_TCL_DECLARED
#define Tk_CanvasPsBitmap_TCL_DECLARED
/* 11 */
EXTERN int		Tk_CanvasPsBitmap(Tcl_Interp *interp,
				Tk_Canvas canvas, Pixmap bitmap, int x,
				int y, int width, int height);
#endif
#ifndef Tk_CanvasPsColor_TCL_DECLARED
#define Tk_CanvasPsColor_TCL_DECLARED
/* 12 */
EXTERN int		Tk_CanvasPsColor(Tcl_Interp *interp,
				Tk_Canvas canvas, XColor *colorPtr);
#endif
#ifndef Tk_CanvasPsFont_TCL_DECLARED
#define Tk_CanvasPsFont_TCL_DECLARED
/* 13 */
EXTERN int		Tk_CanvasPsFont(Tcl_Interp *interp, Tk_Canvas canvas,
				Tk_Font font);
#endif
#ifndef Tk_CanvasPsPath_TCL_DECLARED
#define Tk_CanvasPsPath_TCL_DECLARED
/* 14 */
EXTERN void		Tk_CanvasPsPath(Tcl_Interp *interp, Tk_Canvas canvas,
				double *coordPtr, int numPoints);
#endif
#ifndef Tk_CanvasPsStipple_TCL_DECLARED
#define Tk_CanvasPsStipple_TCL_DECLARED
/* 15 */
EXTERN int		Tk_CanvasPsStipple(Tcl_Interp *interp,
				Tk_Canvas canvas, Pixmap bitmap);
#endif
#ifndef Tk_CanvasPsY_TCL_DECLARED
#define Tk_CanvasPsY_TCL_DECLARED
/* 16 */
EXTERN double		Tk_CanvasPsY(Tk_Canvas canvas, double y);
#endif
#ifndef Tk_CanvasSetStippleOrigin_TCL_DECLARED
#define Tk_CanvasSetStippleOrigin_TCL_DECLARED
/* 17 */
EXTERN void		Tk_CanvasSetStippleOrigin(Tk_Canvas canvas, GC gc);
#endif
#ifndef Tk_CanvasTagsParseProc_TCL_DECLARED
#define Tk_CanvasTagsParseProc_TCL_DECLARED
/* 18 */
EXTERN int		Tk_CanvasTagsParseProc(ClientData clientData,
				Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *value, char *widgRec, int offset);
#endif
#ifndef Tk_CanvasTagsPrintProc_TCL_DECLARED
#define Tk_CanvasTagsPrintProc_TCL_DECLARED
/* 19 */
EXTERN char *		Tk_CanvasTagsPrintProc(ClientData clientData,
				Tk_Window tkwin, char *widgRec, int offset,
				Tcl_FreeProc **freeProcPtr);
#endif
#ifndef Tk_CanvasTkwin_TCL_DECLARED
#define Tk_CanvasTkwin_TCL_DECLARED
/* 20 */
EXTERN Tk_Window	Tk_CanvasTkwin(Tk_Canvas canvas);
#endif
#ifndef Tk_CanvasWindowCoords_TCL_DECLARED
#define Tk_CanvasWindowCoords_TCL_DECLARED
/* 21 */
EXTERN void		Tk_CanvasWindowCoords(Tk_Canvas canvas, double x,
				double y, short *screenXPtr,
				short *screenYPtr);
#endif
#ifndef Tk_ChangeWindowAttributes_TCL_DECLARED
#define Tk_ChangeWindowAttributes_TCL_DECLARED
/* 22 */
EXTERN void		Tk_ChangeWindowAttributes(Tk_Window tkwin,
				unsigned long valueMask,
				XSetWindowAttributes *attsPtr);
#endif
#ifndef Tk_CharBbox_TCL_DECLARED
#define Tk_CharBbox_TCL_DECLARED
/* 23 */
EXTERN int		Tk_CharBbox(Tk_TextLayout layout, int index,
				int *xPtr, int *yPtr, int *widthPtr,
				int *heightPtr);
#endif
#ifndef Tk_ClearSelection_TCL_DECLARED
#define Tk_ClearSelection_TCL_DECLARED
/* 24 */
EXTERN void		Tk_ClearSelection(Tk_Window tkwin, Atom selection);
#endif
#ifndef Tk_ClipboardAppend_TCL_DECLARED
#define Tk_ClipboardAppend_TCL_DECLARED
/* 25 */
EXTERN int		Tk_ClipboardAppend(Tcl_Interp *interp,
				Tk_Window tkwin, Atom target, Atom format,
				char *buffer);
#endif
#ifndef Tk_ClipboardClear_TCL_DECLARED
#define Tk_ClipboardClear_TCL_DECLARED
/* 26 */
EXTERN int		Tk_ClipboardClear(Tcl_Interp *interp,
				Tk_Window tkwin);
#endif
#ifndef Tk_ConfigureInfo_TCL_DECLARED
#define Tk_ConfigureInfo_TCL_DECLARED
/* 27 */
EXTERN int		Tk_ConfigureInfo(Tcl_Interp *interp, Tk_Window tkwin,
				Tk_ConfigSpec *specs, char *widgRec,
				CONST char *argvName, int flags);
#endif
#ifndef Tk_ConfigureValue_TCL_DECLARED
#define Tk_ConfigureValue_TCL_DECLARED
/* 28 */
EXTERN int		Tk_ConfigureValue(Tcl_Interp *interp,
				Tk_Window tkwin, Tk_ConfigSpec *specs,
				char *widgRec, CONST char *argvName,
				int flags);
#endif
#ifndef Tk_ConfigureWidget_TCL_DECLARED
#define Tk_ConfigureWidget_TCL_DECLARED
/* 29 */
EXTERN int		Tk_ConfigureWidget(Tcl_Interp *interp,
				Tk_Window tkwin, Tk_ConfigSpec *specs,
				int argc, CONST84 char **argv, char *widgRec,
				int flags);
#endif
#ifndef Tk_ConfigureWindow_TCL_DECLARED
#define Tk_ConfigureWindow_TCL_DECLARED
/* 30 */
EXTERN void		Tk_ConfigureWindow(Tk_Window tkwin,
				unsigned int valueMask,
				XWindowChanges *valuePtr);
#endif
#ifndef Tk_ComputeTextLayout_TCL_DECLARED
#define Tk_ComputeTextLayout_TCL_DECLARED
/* 31 */
EXTERN Tk_TextLayout	Tk_ComputeTextLayout(Tk_Font font, CONST char *str,
				int numChars, int wrapLength,
				Tk_Justify justify, int flags, int *widthPtr,
				int *heightPtr);
#endif
#ifndef Tk_CoordsToWindow_TCL_DECLARED
#define Tk_CoordsToWindow_TCL_DECLARED
/* 32 */
EXTERN Tk_Window	Tk_CoordsToWindow(int rootX, int rootY,
				Tk_Window tkwin);
#endif
#ifndef Tk_CreateBinding_TCL_DECLARED
#define Tk_CreateBinding_TCL_DECLARED
/* 33 */
EXTERN unsigned long	Tk_CreateBinding(Tcl_Interp *interp,
				Tk_BindingTable bindingTable,
				ClientData object, CONST char *eventStr,
				CONST char *command, int append);
#endif
#ifndef Tk_CreateBindingTable_TCL_DECLARED
#define Tk_CreateBindingTable_TCL_DECLARED
/* 34 */
EXTERN Tk_BindingTable	Tk_CreateBindingTable(Tcl_Interp *interp);
#endif
#ifndef Tk_CreateErrorHandler_TCL_DECLARED
#define Tk_CreateErrorHandler_TCL_DECLARED
/* 35 */
EXTERN Tk_ErrorHandler	Tk_CreateErrorHandler(Display *display, int errNum,
				int request, int minorCode,
				Tk_ErrorProc *errorProc,
				ClientData clientData);
#endif
#ifndef Tk_CreateEventHandler_TCL_DECLARED
#define Tk_CreateEventHandler_TCL_DECLARED
/* 36 */
EXTERN void		Tk_CreateEventHandler(Tk_Window token,
				unsigned long mask, Tk_EventProc *proc,
				ClientData clientData);
#endif
#ifndef Tk_CreateGenericHandler_TCL_DECLARED
#define Tk_CreateGenericHandler_TCL_DECLARED
/* 37 */
EXTERN void		Tk_CreateGenericHandler(Tk_GenericProc *proc,
				ClientData clientData);
#endif
#ifndef Tk_CreateImageType_TCL_DECLARED
#define Tk_CreateImageType_TCL_DECLARED
/* 38 */
EXTERN void		Tk_CreateImageType(Tk_ImageType *typePtr);
#endif
#ifndef Tk_CreateItemType_TCL_DECLARED
#define Tk_CreateItemType_TCL_DECLARED
/* 39 */
EXTERN void		Tk_CreateItemType(Tk_ItemType *typePtr);
#endif
#ifndef Tk_CreatePhotoImageFormat_TCL_DECLARED
#define Tk_CreatePhotoImageFormat_TCL_DECLARED
/* 40 */
EXTERN void		Tk_CreatePhotoImageFormat(
				Tk_PhotoImageFormat *formatPtr);
#endif
#ifndef Tk_CreateSelHandler_TCL_DECLARED
#define Tk_CreateSelHandler_TCL_DECLARED
/* 41 */
EXTERN void		Tk_CreateSelHandler(Tk_Window tkwin, Atom selection,
				Atom target, Tk_SelectionProc *proc,
				ClientData clientData, Atom format);
#endif
#ifndef Tk_CreateWindow_TCL_DECLARED
#define Tk_CreateWindow_TCL_DECLARED
/* 42 */
EXTERN Tk_Window	Tk_CreateWindow(Tcl_Interp *interp, Tk_Window parent,
				CONST char *name, CONST char *screenName);
#endif
#ifndef Tk_CreateWindowFromPath_TCL_DECLARED
#define Tk_CreateWindowFromPath_TCL_DECLARED
/* 43 */
EXTERN Tk_Window	Tk_CreateWindowFromPath(Tcl_Interp *interp,
				Tk_Window tkwin, CONST char *pathName,
				CONST char *screenName);
#endif
#ifndef Tk_DefineBitmap_TCL_DECLARED
#define Tk_DefineBitmap_TCL_DECLARED
/* 44 */
EXTERN int		Tk_DefineBitmap(Tcl_Interp *interp, CONST char *name,
				CONST char *source, int width, int height);
#endif
#ifndef Tk_DefineCursor_TCL_DECLARED
#define Tk_DefineCursor_TCL_DECLARED
/* 45 */
EXTERN void		Tk_DefineCursor(Tk_Window window, Tk_Cursor cursor);
#endif
#ifndef Tk_DeleteAllBindings_TCL_DECLARED
#define Tk_DeleteAllBindings_TCL_DECLARED
/* 46 */
EXTERN void		Tk_DeleteAllBindings(Tk_BindingTable bindingTable,
				ClientData object);
#endif
#ifndef Tk_DeleteBinding_TCL_DECLARED
#define Tk_DeleteBinding_TCL_DECLARED
/* 47 */
EXTERN int		Tk_DeleteBinding(Tcl_Interp *interp,
				Tk_BindingTable bindingTable,
				ClientData object, CONST char *eventStr);
#endif
#ifndef Tk_DeleteBindingTable_TCL_DECLARED
#define Tk_DeleteBindingTable_TCL_DECLARED
/* 48 */
EXTERN void		Tk_DeleteBindingTable(Tk_BindingTable bindingTable);
#endif
#ifndef Tk_DeleteErrorHandler_TCL_DECLARED
#define Tk_DeleteErrorHandler_TCL_DECLARED
/* 49 */
EXTERN void		Tk_DeleteErrorHandler(Tk_ErrorHandler handler);
#endif
#ifndef Tk_DeleteEventHandler_TCL_DECLARED
#define Tk_DeleteEventHandler_TCL_DECLARED
/* 50 */
EXTERN void		Tk_DeleteEventHandler(Tk_Window token,
				unsigned long mask, Tk_EventProc *proc,
				ClientData clientData);
#endif
#ifndef Tk_DeleteGenericHandler_TCL_DECLARED
#define Tk_DeleteGenericHandler_TCL_DECLARED
/* 51 */
EXTERN void		Tk_DeleteGenericHandler(Tk_GenericProc *proc,
				ClientData clientData);
#endif
#ifndef Tk_DeleteImage_TCL_DECLARED
#define Tk_DeleteImage_TCL_DECLARED
/* 52 */
EXTERN void		Tk_DeleteImage(Tcl_Interp *interp, CONST char *name);
#endif
#ifndef Tk_DeleteSelHandler_TCL_DECLARED
#define Tk_DeleteSelHandler_TCL_DECLARED
/* 53 */
EXTERN void		Tk_DeleteSelHandler(Tk_Window tkwin, Atom selection,
				Atom target);
#endif
#ifndef Tk_DestroyWindow_TCL_DECLARED
#define Tk_DestroyWindow_TCL_DECLARED
/* 54 */
EXTERN void		Tk_DestroyWindow(Tk_Window tkwin);
#endif
#ifndef Tk_DisplayName_TCL_DECLARED
#define Tk_DisplayName_TCL_DECLARED
/* 55 */
EXTERN CONST84_RETURN char * Tk_DisplayName(Tk_Window tkwin);
#endif
#ifndef Tk_DistanceToTextLayout_TCL_DECLARED
#define Tk_DistanceToTextLayout_TCL_DECLARED
/* 56 */
EXTERN int		Tk_DistanceToTextLayout(Tk_TextLayout layout, int x,
				int y);
#endif
#ifndef Tk_Draw3DPolygon_TCL_DECLARED
#define Tk_Draw3DPolygon_TCL_DECLARED
/* 57 */
EXTERN void		Tk_Draw3DPolygon(Tk_Window tkwin, Drawable drawable,
				Tk_3DBorder border, XPoint *pointPtr,
				int numPoints, int borderWidth,
				int leftRelief);
#endif
#ifndef Tk_Draw3DRectangle_TCL_DECLARED
#define Tk_Draw3DRectangle_TCL_DECLARED
/* 58 */
EXTERN void		Tk_Draw3DRectangle(Tk_Window tkwin,
				Drawable drawable, Tk_3DBorder border, int x,
				int y, int width, int height,
				int borderWidth, int relief);
#endif
#ifndef Tk_DrawChars_TCL_DECLARED
#define Tk_DrawChars_TCL_DECLARED
/* 59 */
EXTERN void		Tk_DrawChars(Display *display, Drawable drawable,
				GC gc, Tk_Font tkfont, CONST char *source,
				int numBytes, int x, int y);
#endif
#ifndef Tk_DrawFocusHighlight_TCL_DECLARED
#define Tk_DrawFocusHighlight_TCL_DECLARED
/* 60 */
EXTERN void		Tk_DrawFocusHighlight(Tk_Window tkwin, GC gc,
				int width, Drawable drawable);
#endif
#ifndef Tk_DrawTextLayout_TCL_DECLARED
#define Tk_DrawTextLayout_TCL_DECLARED
/* 61 */
EXTERN void		Tk_DrawTextLayout(Display *display,
				Drawable drawable, GC gc,
				Tk_TextLayout layout, int x, int y,
				int firstChar, int lastChar);
#endif
#ifndef Tk_Fill3DPolygon_TCL_DECLARED
#define Tk_Fill3DPolygon_TCL_DECLARED
/* 62 */
EXTERN void		Tk_Fill3DPolygon(Tk_Window tkwin, Drawable drawable,
				Tk_3DBorder border, XPoint *pointPtr,
				int numPoints, int borderWidth,
				int leftRelief);
#endif
#ifndef Tk_Fill3DRectangle_TCL_DECLARED
#define Tk_Fill3DRectangle_TCL_DECLARED
/* 63 */
EXTERN void		Tk_Fill3DRectangle(Tk_Window tkwin,
				Drawable drawable, Tk_3DBorder border, int x,
				int y, int width, int height,
				int borderWidth, int relief);
#endif
#ifndef Tk_FindPhoto_TCL_DECLARED
#define Tk_FindPhoto_TCL_DECLARED
/* 64 */
EXTERN Tk_PhotoHandle	Tk_FindPhoto(Tcl_Interp *interp,
				CONST char *imageName);
#endif
#ifndef Tk_FontId_TCL_DECLARED
#define Tk_FontId_TCL_DECLARED
/* 65 */
EXTERN Font		Tk_FontId(Tk_Font font);
#endif
#ifndef Tk_Free3DBorder_TCL_DECLARED
#define Tk_Free3DBorder_TCL_DECLARED
/* 66 */
EXTERN void		Tk_Free3DBorder(Tk_3DBorder border);
#endif
#ifndef Tk_FreeBitmap_TCL_DECLARED
#define Tk_FreeBitmap_TCL_DECLARED
/* 67 */
EXTERN void		Tk_FreeBitmap(Display *display, Pixmap bitmap);
#endif
#ifndef Tk_FreeColor_TCL_DECLARED
#define Tk_FreeColor_TCL_DECLARED
/* 68 */
EXTERN void		Tk_FreeColor(XColor *colorPtr);
#endif
#ifndef Tk_FreeColormap_TCL_DECLARED
#define Tk_FreeColormap_TCL_DECLARED
/* 69 */
EXTERN void		Tk_FreeColormap(Display *display, Colormap colormap);
#endif
#ifndef Tk_FreeCursor_TCL_DECLARED
#define Tk_FreeCursor_TCL_DECLARED
/* 70 */
EXTERN void		Tk_FreeCursor(Display *display, Tk_Cursor cursor);
#endif
#ifndef Tk_FreeFont_TCL_DECLARED
#define Tk_FreeFont_TCL_DECLARED
/* 71 */
EXTERN void		Tk_FreeFont(Tk_Font f);
#endif
#ifndef Tk_FreeGC_TCL_DECLARED
#define Tk_FreeGC_TCL_DECLARED
/* 72 */
EXTERN void		Tk_FreeGC(Display *display, GC gc);
#endif
#ifndef Tk_FreeImage_TCL_DECLARED
#define Tk_FreeImage_TCL_DECLARED
/* 73 */
EXTERN void		Tk_FreeImage(Tk_Image image);
#endif
#ifndef Tk_FreeOptions_TCL_DECLARED
#define Tk_FreeOptions_TCL_DECLARED
/* 74 */
EXTERN void		Tk_FreeOptions(Tk_ConfigSpec *specs, char *widgRec,
				Display *display, int needFlags);
#endif
#ifndef Tk_FreePixmap_TCL_DECLARED
#define Tk_FreePixmap_TCL_DECLARED
/* 75 */
EXTERN void		Tk_FreePixmap(Display *display, Pixmap pixmap);
#endif
#ifndef Tk_FreeTextLayout_TCL_DECLARED
#define Tk_FreeTextLayout_TCL_DECLARED
/* 76 */
EXTERN void		Tk_FreeTextLayout(Tk_TextLayout textLayout);
#endif
#ifndef Tk_FreeXId_TCL_DECLARED
#define Tk_FreeXId_TCL_DECLARED
/* 77 */
EXTERN void		Tk_FreeXId(Display *display, XID xid);
#endif
#ifndef Tk_GCForColor_TCL_DECLARED
#define Tk_GCForColor_TCL_DECLARED
/* 78 */
EXTERN GC		Tk_GCForColor(XColor *colorPtr, Drawable drawable);
#endif
#ifndef Tk_GeometryRequest_TCL_DECLARED
#define Tk_GeometryRequest_TCL_DECLARED
/* 79 */
EXTERN void		Tk_GeometryRequest(Tk_Window tkwin, int reqWidth,
				int reqHeight);
#endif
#ifndef Tk_Get3DBorder_TCL_DECLARED
#define Tk_Get3DBorder_TCL_DECLARED
/* 80 */
EXTERN Tk_3DBorder	Tk_Get3DBorder(Tcl_Interp *interp, Tk_Window tkwin,
				Tk_Uid colorName);
#endif
#ifndef Tk_GetAllBindings_TCL_DECLARED
#define Tk_GetAllBindings_TCL_DECLARED
/* 81 */
EXTERN void		Tk_GetAllBindings(Tcl_Interp *interp,
				Tk_BindingTable bindingTable,
				ClientData object);
#endif
#ifndef Tk_GetAnchor_TCL_DECLARED
#define Tk_GetAnchor_TCL_DECLARED
/* 82 */
EXTERN int		Tk_GetAnchor(Tcl_Interp *interp, CONST char *str,
				Tk_Anchor *anchorPtr);
#endif
#ifndef Tk_GetAtomName_TCL_DECLARED
#define Tk_GetAtomName_TCL_DECLARED
/* 83 */
EXTERN CONST84_RETURN char * Tk_GetAtomName(Tk_Window tkwin, Atom atom);
#endif
#ifndef Tk_GetBinding_TCL_DECLARED
#define Tk_GetBinding_TCL_DECLARED
/* 84 */
EXTERN CONST84_RETURN char * Tk_GetBinding(Tcl_Interp *interp,
				Tk_BindingTable bindingTable,
				ClientData object, CONST char *eventStr);
#endif
#ifndef Tk_GetBitmap_TCL_DECLARED
#define Tk_GetBitmap_TCL_DECLARED
/* 85 */
EXTERN Pixmap		Tk_GetBitmap(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str);
#endif
#ifndef Tk_GetBitmapFromData_TCL_DECLARED
#define Tk_GetBitmapFromData_TCL_DECLARED
/* 86 */
EXTERN Pixmap		Tk_GetBitmapFromData(Tcl_Interp *interp,
				Tk_Window tkwin, CONST char *source,
				int width, int height);
#endif
#ifndef Tk_GetCapStyle_TCL_DECLARED
#define Tk_GetCapStyle_TCL_DECLARED
/* 87 */
EXTERN int		Tk_GetCapStyle(Tcl_Interp *interp, CONST char *str,
				int *capPtr);
#endif
#ifndef Tk_GetColor_TCL_DECLARED
#define Tk_GetColor_TCL_DECLARED
/* 88 */
EXTERN XColor *		Tk_GetColor(Tcl_Interp *interp, Tk_Window tkwin,
				Tk_Uid name);
#endif
#ifndef Tk_GetColorByValue_TCL_DECLARED
#define Tk_GetColorByValue_TCL_DECLARED
/* 89 */
EXTERN XColor *		Tk_GetColorByValue(Tk_Window tkwin, XColor *colorPtr);
#endif
#ifndef Tk_GetColormap_TCL_DECLARED
#define Tk_GetColormap_TCL_DECLARED
/* 90 */
EXTERN Colormap		Tk_GetColormap(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str);
#endif
#ifndef Tk_GetCursor_TCL_DECLARED
#define Tk_GetCursor_TCL_DECLARED
/* 91 */
EXTERN Tk_Cursor	Tk_GetCursor(Tcl_Interp *interp, Tk_Window tkwin,
				Tk_Uid str);
#endif
#ifndef Tk_GetCursorFromData_TCL_DECLARED
#define Tk_GetCursorFromData_TCL_DECLARED
/* 92 */
EXTERN Tk_Cursor	Tk_GetCursorFromData(Tcl_Interp *interp,
				Tk_Window tkwin, CONST char *source,
				CONST char *mask, int width, int height,
				int xHot, int yHot, Tk_Uid fg, Tk_Uid bg);
#endif
#ifndef Tk_GetFont_TCL_DECLARED
#define Tk_GetFont_TCL_DECLARED
/* 93 */
EXTERN Tk_Font		Tk_GetFont(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str);
#endif
#ifndef Tk_GetFontFromObj_TCL_DECLARED
#define Tk_GetFontFromObj_TCL_DECLARED
/* 94 */
EXTERN Tk_Font		Tk_GetFontFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetFontMetrics_TCL_DECLARED
#define Tk_GetFontMetrics_TCL_DECLARED
/* 95 */
EXTERN void		Tk_GetFontMetrics(Tk_Font font,
				Tk_FontMetrics *fmPtr);
#endif
#ifndef Tk_GetGC_TCL_DECLARED
#define Tk_GetGC_TCL_DECLARED
/* 96 */
EXTERN GC		Tk_GetGC(Tk_Window tkwin, unsigned long valueMask,
				XGCValues *valuePtr);
#endif
#ifndef Tk_GetImage_TCL_DECLARED
#define Tk_GetImage_TCL_DECLARED
/* 97 */
EXTERN Tk_Image		Tk_GetImage(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *name,
				Tk_ImageChangedProc *changeProc,
				ClientData clientData);
#endif
#ifndef Tk_GetImageMasterData_TCL_DECLARED
#define Tk_GetImageMasterData_TCL_DECLARED
/* 98 */
EXTERN ClientData	Tk_GetImageMasterData(Tcl_Interp *interp,
				CONST char *name, Tk_ImageType **typePtrPtr);
#endif
#ifndef Tk_GetItemTypes_TCL_DECLARED
#define Tk_GetItemTypes_TCL_DECLARED
/* 99 */
EXTERN Tk_ItemType *	Tk_GetItemTypes(void);
#endif
#ifndef Tk_GetJoinStyle_TCL_DECLARED
#define Tk_GetJoinStyle_TCL_DECLARED
/* 100 */
EXTERN int		Tk_GetJoinStyle(Tcl_Interp *interp, CONST char *str,
				int *joinPtr);
#endif
#ifndef Tk_GetJustify_TCL_DECLARED
#define Tk_GetJustify_TCL_DECLARED
/* 101 */
EXTERN int		Tk_GetJustify(Tcl_Interp *interp, CONST char *str,
				Tk_Justify *justifyPtr);
#endif
#ifndef Tk_GetNumMainWindows_TCL_DECLARED
#define Tk_GetNumMainWindows_TCL_DECLARED
/* 102 */
EXTERN int		Tk_GetNumMainWindows(void);
#endif
#ifndef Tk_GetOption_TCL_DECLARED
#define Tk_GetOption_TCL_DECLARED
/* 103 */
EXTERN Tk_Uid		Tk_GetOption(Tk_Window tkwin, CONST char *name,
				CONST char *className);
#endif
#ifndef Tk_GetPixels_TCL_DECLARED
#define Tk_GetPixels_TCL_DECLARED
/* 104 */
EXTERN int		Tk_GetPixels(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str, int *intPtr);
#endif
#ifndef Tk_GetPixmap_TCL_DECLARED
#define Tk_GetPixmap_TCL_DECLARED
/* 105 */
EXTERN Pixmap		Tk_GetPixmap(Display *display, Drawable d, int width,
				int height, int depth);
#endif
#ifndef Tk_GetRelief_TCL_DECLARED
#define Tk_GetRelief_TCL_DECLARED
/* 106 */
EXTERN int		Tk_GetRelief(Tcl_Interp *interp, CONST char *name,
				int *reliefPtr);
#endif
#ifndef Tk_GetRootCoords_TCL_DECLARED
#define Tk_GetRootCoords_TCL_DECLARED
/* 107 */
EXTERN void		Tk_GetRootCoords(Tk_Window tkwin, int *xPtr,
				int *yPtr);
#endif
#ifndef Tk_GetScrollInfo_TCL_DECLARED
#define Tk_GetScrollInfo_TCL_DECLARED
/* 108 */
EXTERN int		Tk_GetScrollInfo(Tcl_Interp *interp, int argc,
				CONST84 char **argv, double *dblPtr,
				int *intPtr);
#endif
#ifndef Tk_GetScreenMM_TCL_DECLARED
#define Tk_GetScreenMM_TCL_DECLARED
/* 109 */
EXTERN int		Tk_GetScreenMM(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str, double *doublePtr);
#endif
#ifndef Tk_GetSelection_TCL_DECLARED
#define Tk_GetSelection_TCL_DECLARED
/* 110 */
EXTERN int		Tk_GetSelection(Tcl_Interp *interp, Tk_Window tkwin,
				Atom selection, Atom target,
				Tk_GetSelProc *proc, ClientData clientData);
#endif
#ifndef Tk_GetUid_TCL_DECLARED
#define Tk_GetUid_TCL_DECLARED
/* 111 */
EXTERN Tk_Uid		Tk_GetUid(CONST char *str);
#endif
#ifndef Tk_GetVisual_TCL_DECLARED
#define Tk_GetVisual_TCL_DECLARED
/* 112 */
EXTERN Visual *		Tk_GetVisual(Tcl_Interp *interp, Tk_Window tkwin,
				CONST char *str, int *depthPtr,
				Colormap *colormapPtr);
#endif
#ifndef Tk_GetVRootGeometry_TCL_DECLARED
#define Tk_GetVRootGeometry_TCL_DECLARED
/* 113 */
EXTERN void		Tk_GetVRootGeometry(Tk_Window tkwin, int *xPtr,
				int *yPtr, int *widthPtr, int *heightPtr);
#endif
#ifndef Tk_Grab_TCL_DECLARED
#define Tk_Grab_TCL_DECLARED
/* 114 */
EXTERN int		Tk_Grab(Tcl_Interp *interp, Tk_Window tkwin,
				int grabGlobal);
#endif
#ifndef Tk_HandleEvent_TCL_DECLARED
#define Tk_HandleEvent_TCL_DECLARED
/* 115 */
EXTERN void		Tk_HandleEvent(XEvent *eventPtr);
#endif
#ifndef Tk_IdToWindow_TCL_DECLARED
#define Tk_IdToWindow_TCL_DECLARED
/* 116 */
EXTERN Tk_Window	Tk_IdToWindow(Display *display, Window window);
#endif
#ifndef Tk_ImageChanged_TCL_DECLARED
#define Tk_ImageChanged_TCL_DECLARED
/* 117 */
EXTERN void		Tk_ImageChanged(Tk_ImageMaster master, int x, int y,
				int width, int height, int imageWidth,
				int imageHeight);
#endif
#ifndef Tk_Init_TCL_DECLARED
#define Tk_Init_TCL_DECLARED
/* 118 */
EXTERN int		Tk_Init(Tcl_Interp *interp);
#endif
#ifndef Tk_InternAtom_TCL_DECLARED
#define Tk_InternAtom_TCL_DECLARED
/* 119 */
EXTERN Atom		Tk_InternAtom(Tk_Window tkwin, CONST char *name);
#endif
#ifndef Tk_IntersectTextLayout_TCL_DECLARED
#define Tk_IntersectTextLayout_TCL_DECLARED
/* 120 */
EXTERN int		Tk_IntersectTextLayout(Tk_TextLayout layout, int x,
				int y, int width, int height);
#endif
#ifndef Tk_MaintainGeometry_TCL_DECLARED
#define Tk_MaintainGeometry_TCL_DECLARED
/* 121 */
EXTERN void		Tk_MaintainGeometry(Tk_Window slave,
				Tk_Window master, int x, int y, int width,
				int height);
#endif
#ifndef Tk_MainWindow_TCL_DECLARED
#define Tk_MainWindow_TCL_DECLARED
/* 122 */
EXTERN Tk_Window	Tk_MainWindow(Tcl_Interp *interp);
#endif
#ifndef Tk_MakeWindowExist_TCL_DECLARED
#define Tk_MakeWindowExist_TCL_DECLARED
/* 123 */
EXTERN void		Tk_MakeWindowExist(Tk_Window tkwin);
#endif
#ifndef Tk_ManageGeometry_TCL_DECLARED
#define Tk_ManageGeometry_TCL_DECLARED
/* 124 */
EXTERN void		Tk_ManageGeometry(Tk_Window tkwin,
				CONST Tk_GeomMgr *mgrPtr,
				ClientData clientData);
#endif
#ifndef Tk_MapWindow_TCL_DECLARED
#define Tk_MapWindow_TCL_DECLARED
/* 125 */
EXTERN void		Tk_MapWindow(Tk_Window tkwin);
#endif
#ifndef Tk_MeasureChars_TCL_DECLARED
#define Tk_MeasureChars_TCL_DECLARED
/* 126 */
EXTERN int		Tk_MeasureChars(Tk_Font tkfont, CONST char *source,
				int numBytes, int maxPixels, int flags,
				int *lengthPtr);
#endif
#ifndef Tk_MoveResizeWindow_TCL_DECLARED
#define Tk_MoveResizeWindow_TCL_DECLARED
/* 127 */
EXTERN void		Tk_MoveResizeWindow(Tk_Window tkwin, int x, int y,
				int width, int height);
#endif
#ifndef Tk_MoveWindow_TCL_DECLARED
#define Tk_MoveWindow_TCL_DECLARED
/* 128 */
EXTERN void		Tk_MoveWindow(Tk_Window tkwin, int x, int y);
#endif
#ifndef Tk_MoveToplevelWindow_TCL_DECLARED
#define Tk_MoveToplevelWindow_TCL_DECLARED
/* 129 */
EXTERN void		Tk_MoveToplevelWindow(Tk_Window tkwin, int x, int y);
#endif
#ifndef Tk_NameOf3DBorder_TCL_DECLARED
#define Tk_NameOf3DBorder_TCL_DECLARED
/* 130 */
EXTERN CONST84_RETURN char * Tk_NameOf3DBorder(Tk_3DBorder border);
#endif
#ifndef Tk_NameOfAnchor_TCL_DECLARED
#define Tk_NameOfAnchor_TCL_DECLARED
/* 131 */
EXTERN CONST84_RETURN char * Tk_NameOfAnchor(Tk_Anchor anchor);
#endif
#ifndef Tk_NameOfBitmap_TCL_DECLARED
#define Tk_NameOfBitmap_TCL_DECLARED
/* 132 */
EXTERN CONST84_RETURN char * Tk_NameOfBitmap(Display *display, Pixmap bitmap);
#endif
#ifndef Tk_NameOfCapStyle_TCL_DECLARED
#define Tk_NameOfCapStyle_TCL_DECLARED
/* 133 */
EXTERN CONST84_RETURN char * Tk_NameOfCapStyle(int cap);
#endif
#ifndef Tk_NameOfColor_TCL_DECLARED
#define Tk_NameOfColor_TCL_DECLARED
/* 134 */
EXTERN CONST84_RETURN char * Tk_NameOfColor(XColor *colorPtr);
#endif
#ifndef Tk_NameOfCursor_TCL_DECLARED
#define Tk_NameOfCursor_TCL_DECLARED
/* 135 */
EXTERN CONST84_RETURN char * Tk_NameOfCursor(Display *display,
				Tk_Cursor cursor);
#endif
#ifndef Tk_NameOfFont_TCL_DECLARED
#define Tk_NameOfFont_TCL_DECLARED
/* 136 */
EXTERN CONST84_RETURN char * Tk_NameOfFont(Tk_Font font);
#endif
#ifndef Tk_NameOfImage_TCL_DECLARED
#define Tk_NameOfImage_TCL_DECLARED
/* 137 */
EXTERN CONST84_RETURN char * Tk_NameOfImage(Tk_ImageMaster imageMaster);
#endif
#ifndef Tk_NameOfJoinStyle_TCL_DECLARED
#define Tk_NameOfJoinStyle_TCL_DECLARED
/* 138 */
EXTERN CONST84_RETURN char * Tk_NameOfJoinStyle(int join);
#endif
#ifndef Tk_NameOfJustify_TCL_DECLARED
#define Tk_NameOfJustify_TCL_DECLARED
/* 139 */
EXTERN CONST84_RETURN char * Tk_NameOfJustify(Tk_Justify justify);
#endif
#ifndef Tk_NameOfRelief_TCL_DECLARED
#define Tk_NameOfRelief_TCL_DECLARED
/* 140 */
EXTERN CONST84_RETURN char * Tk_NameOfRelief(int relief);
#endif
#ifndef Tk_NameToWindow_TCL_DECLARED
#define Tk_NameToWindow_TCL_DECLARED
/* 141 */
EXTERN Tk_Window	Tk_NameToWindow(Tcl_Interp *interp,
				CONST char *pathName, Tk_Window tkwin);
#endif
#ifndef Tk_OwnSelection_TCL_DECLARED
#define Tk_OwnSelection_TCL_DECLARED
/* 142 */
EXTERN void		Tk_OwnSelection(Tk_Window tkwin, Atom selection,
				Tk_LostSelProc *proc, ClientData clientData);
#endif
#ifndef Tk_ParseArgv_TCL_DECLARED
#define Tk_ParseArgv_TCL_DECLARED
/* 143 */
EXTERN int		Tk_ParseArgv(Tcl_Interp *interp, Tk_Window tkwin,
				int *argcPtr, CONST84 char **argv,
				Tk_ArgvInfo *argTable, int flags);
#endif
#ifndef Tk_PhotoPutBlock_NoComposite_TCL_DECLARED
#define Tk_PhotoPutBlock_NoComposite_TCL_DECLARED
/* 144 */
EXTERN void		Tk_PhotoPutBlock_NoComposite(Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height);
#endif
#ifndef Tk_PhotoPutZoomedBlock_NoComposite_TCL_DECLARED
#define Tk_PhotoPutZoomedBlock_NoComposite_TCL_DECLARED
/* 145 */
EXTERN void		Tk_PhotoPutZoomedBlock_NoComposite(
				Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height, int zoomX, int zoomY,
				int subsampleX, int subsampleY);
#endif
#ifndef Tk_PhotoGetImage_TCL_DECLARED
#define Tk_PhotoGetImage_TCL_DECLARED
/* 146 */
EXTERN int		Tk_PhotoGetImage(Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr);
#endif
#ifndef Tk_PhotoBlank_TCL_DECLARED
#define Tk_PhotoBlank_TCL_DECLARED
/* 147 */
EXTERN void		Tk_PhotoBlank(Tk_PhotoHandle handle);
#endif
#ifndef Tk_PhotoExpand_Panic_TCL_DECLARED
#define Tk_PhotoExpand_Panic_TCL_DECLARED
/* 148 */
EXTERN void		Tk_PhotoExpand_Panic(Tk_PhotoHandle handle,
				int width, int height);
#endif
#ifndef Tk_PhotoGetSize_TCL_DECLARED
#define Tk_PhotoGetSize_TCL_DECLARED
/* 149 */
EXTERN void		Tk_PhotoGetSize(Tk_PhotoHandle handle, int *widthPtr,
				int *heightPtr);
#endif
#ifndef Tk_PhotoSetSize_Panic_TCL_DECLARED
#define Tk_PhotoSetSize_Panic_TCL_DECLARED
/* 150 */
EXTERN void		Tk_PhotoSetSize_Panic(Tk_PhotoHandle handle,
				int width, int height);
#endif
#ifndef Tk_PointToChar_TCL_DECLARED
#define Tk_PointToChar_TCL_DECLARED
/* 151 */
EXTERN int		Tk_PointToChar(Tk_TextLayout layout, int x, int y);
#endif
#ifndef Tk_PostscriptFontName_TCL_DECLARED
#define Tk_PostscriptFontName_TCL_DECLARED
/* 152 */
EXTERN int		Tk_PostscriptFontName(Tk_Font tkfont,
				Tcl_DString *dsPtr);
#endif
#ifndef Tk_PreserveColormap_TCL_DECLARED
#define Tk_PreserveColormap_TCL_DECLARED
/* 153 */
EXTERN void		Tk_PreserveColormap(Display *display,
				Colormap colormap);
#endif
#ifndef Tk_QueueWindowEvent_TCL_DECLARED
#define Tk_QueueWindowEvent_TCL_DECLARED
/* 154 */
EXTERN void		Tk_QueueWindowEvent(XEvent *eventPtr,
				Tcl_QueuePosition position);
#endif
#ifndef Tk_RedrawImage_TCL_DECLARED
#define Tk_RedrawImage_TCL_DECLARED
/* 155 */
EXTERN void		Tk_RedrawImage(Tk_Image image, int imageX,
				int imageY, int width, int height,
				Drawable drawable, int drawableX,
				int drawableY);
#endif
#ifndef Tk_ResizeWindow_TCL_DECLARED
#define Tk_ResizeWindow_TCL_DECLARED
/* 156 */
EXTERN void		Tk_ResizeWindow(Tk_Window tkwin, int width,
				int height);
#endif
#ifndef Tk_RestackWindow_TCL_DECLARED
#define Tk_RestackWindow_TCL_DECLARED
/* 157 */
EXTERN int		Tk_RestackWindow(Tk_Window tkwin, int aboveBelow,
				Tk_Window other);
#endif
#ifndef Tk_RestrictEvents_TCL_DECLARED
#define Tk_RestrictEvents_TCL_DECLARED
/* 158 */
EXTERN Tk_RestrictProc * Tk_RestrictEvents(Tk_RestrictProc *proc,
				ClientData arg, ClientData *prevArgPtr);
#endif
#ifndef Tk_SafeInit_TCL_DECLARED
#define Tk_SafeInit_TCL_DECLARED
/* 159 */
EXTERN int		Tk_SafeInit(Tcl_Interp *interp);
#endif
#ifndef Tk_SetAppName_TCL_DECLARED
#define Tk_SetAppName_TCL_DECLARED
/* 160 */
EXTERN CONST char *	Tk_SetAppName(Tk_Window tkwin, CONST char *name);
#endif
#ifndef Tk_SetBackgroundFromBorder_TCL_DECLARED
#define Tk_SetBackgroundFromBorder_TCL_DECLARED
/* 161 */
EXTERN void		Tk_SetBackgroundFromBorder(Tk_Window tkwin,
				Tk_3DBorder border);
#endif
#ifndef Tk_SetClass_TCL_DECLARED
#define Tk_SetClass_TCL_DECLARED
/* 162 */
EXTERN void		Tk_SetClass(Tk_Window tkwin, CONST char *className);
#endif
#ifndef Tk_SetGrid_TCL_DECLARED
#define Tk_SetGrid_TCL_DECLARED
/* 163 */
EXTERN void		Tk_SetGrid(Tk_Window tkwin, int reqWidth,
				int reqHeight, int gridWidth, int gridHeight);
#endif
#ifndef Tk_SetInternalBorder_TCL_DECLARED
#define Tk_SetInternalBorder_TCL_DECLARED
/* 164 */
EXTERN void		Tk_SetInternalBorder(Tk_Window tkwin, int width);
#endif
#ifndef Tk_SetWindowBackground_TCL_DECLARED
#define Tk_SetWindowBackground_TCL_DECLARED
/* 165 */
EXTERN void		Tk_SetWindowBackground(Tk_Window tkwin,
				unsigned long pixel);
#endif
#ifndef Tk_SetWindowBackgroundPixmap_TCL_DECLARED
#define Tk_SetWindowBackgroundPixmap_TCL_DECLARED
/* 166 */
EXTERN void		Tk_SetWindowBackgroundPixmap(Tk_Window tkwin,
				Pixmap pixmap);
#endif
#ifndef Tk_SetWindowBorder_TCL_DECLARED
#define Tk_SetWindowBorder_TCL_DECLARED
/* 167 */
EXTERN void		Tk_SetWindowBorder(Tk_Window tkwin,
				unsigned long pixel);
#endif
#ifndef Tk_SetWindowBorderWidth_TCL_DECLARED
#define Tk_SetWindowBorderWidth_TCL_DECLARED
/* 168 */
EXTERN void		Tk_SetWindowBorderWidth(Tk_Window tkwin, int width);
#endif
#ifndef Tk_SetWindowBorderPixmap_TCL_DECLARED
#define Tk_SetWindowBorderPixmap_TCL_DECLARED
/* 169 */
EXTERN void		Tk_SetWindowBorderPixmap(Tk_Window tkwin,
				Pixmap pixmap);
#endif
#ifndef Tk_SetWindowColormap_TCL_DECLARED
#define Tk_SetWindowColormap_TCL_DECLARED
/* 170 */
EXTERN void		Tk_SetWindowColormap(Tk_Window tkwin,
				Colormap colormap);
#endif
#ifndef Tk_SetWindowVisual_TCL_DECLARED
#define Tk_SetWindowVisual_TCL_DECLARED
/* 171 */
EXTERN int		Tk_SetWindowVisual(Tk_Window tkwin, Visual *visual,
				int depth, Colormap colormap);
#endif
#ifndef Tk_SizeOfBitmap_TCL_DECLARED
#define Tk_SizeOfBitmap_TCL_DECLARED
/* 172 */
EXTERN void		Tk_SizeOfBitmap(Display *display, Pixmap bitmap,
				int *widthPtr, int *heightPtr);
#endif
#ifndef Tk_SizeOfImage_TCL_DECLARED
#define Tk_SizeOfImage_TCL_DECLARED
/* 173 */
EXTERN void		Tk_SizeOfImage(Tk_Image image, int *widthPtr,
				int *heightPtr);
#endif
#ifndef Tk_StrictMotif_TCL_DECLARED
#define Tk_StrictMotif_TCL_DECLARED
/* 174 */
EXTERN int		Tk_StrictMotif(Tk_Window tkwin);
#endif
#ifndef Tk_TextLayoutToPostscript_TCL_DECLARED
#define Tk_TextLayoutToPostscript_TCL_DECLARED
/* 175 */
EXTERN void		Tk_TextLayoutToPostscript(Tcl_Interp *interp,
				Tk_TextLayout layout);
#endif
#ifndef Tk_TextWidth_TCL_DECLARED
#define Tk_TextWidth_TCL_DECLARED
/* 176 */
EXTERN int		Tk_TextWidth(Tk_Font font, CONST char *str,
				int numBytes);
#endif
#ifndef Tk_UndefineCursor_TCL_DECLARED
#define Tk_UndefineCursor_TCL_DECLARED
/* 177 */
EXTERN void		Tk_UndefineCursor(Tk_Window window);
#endif
#ifndef Tk_UnderlineChars_TCL_DECLARED
#define Tk_UnderlineChars_TCL_DECLARED
/* 178 */
EXTERN void		Tk_UnderlineChars(Display *display,
				Drawable drawable, GC gc, Tk_Font tkfont,
				CONST char *source, int x, int y,
				int firstByte, int lastByte);
#endif
#ifndef Tk_UnderlineTextLayout_TCL_DECLARED
#define Tk_UnderlineTextLayout_TCL_DECLARED
/* 179 */
EXTERN void		Tk_UnderlineTextLayout(Display *display,
				Drawable drawable, GC gc,
				Tk_TextLayout layout, int x, int y,
				int underline);
#endif
#ifndef Tk_Ungrab_TCL_DECLARED
#define Tk_Ungrab_TCL_DECLARED
/* 180 */
EXTERN void		Tk_Ungrab(Tk_Window tkwin);
#endif
#ifndef Tk_UnmaintainGeometry_TCL_DECLARED
#define Tk_UnmaintainGeometry_TCL_DECLARED
/* 181 */
EXTERN void		Tk_UnmaintainGeometry(Tk_Window slave,
				Tk_Window master);
#endif
#ifndef Tk_UnmapWindow_TCL_DECLARED
#define Tk_UnmapWindow_TCL_DECLARED
/* 182 */
EXTERN void		Tk_UnmapWindow(Tk_Window tkwin);
#endif
#ifndef Tk_UnsetGrid_TCL_DECLARED
#define Tk_UnsetGrid_TCL_DECLARED
/* 183 */
EXTERN void		Tk_UnsetGrid(Tk_Window tkwin);
#endif
#ifndef Tk_UpdatePointer_TCL_DECLARED
#define Tk_UpdatePointer_TCL_DECLARED
/* 184 */
EXTERN void		Tk_UpdatePointer(Tk_Window tkwin, int x, int y,
				int state);
#endif
#ifndef Tk_AllocBitmapFromObj_TCL_DECLARED
#define Tk_AllocBitmapFromObj_TCL_DECLARED
/* 185 */
EXTERN Pixmap		Tk_AllocBitmapFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_Alloc3DBorderFromObj_TCL_DECLARED
#define Tk_Alloc3DBorderFromObj_TCL_DECLARED
/* 186 */
EXTERN Tk_3DBorder	Tk_Alloc3DBorderFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_AllocColorFromObj_TCL_DECLARED
#define Tk_AllocColorFromObj_TCL_DECLARED
/* 187 */
EXTERN XColor *		Tk_AllocColorFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_AllocCursorFromObj_TCL_DECLARED
#define Tk_AllocCursorFromObj_TCL_DECLARED
/* 188 */
EXTERN Tk_Cursor	Tk_AllocCursorFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_AllocFontFromObj_TCL_DECLARED
#define Tk_AllocFontFromObj_TCL_DECLARED
/* 189 */
EXTERN Tk_Font		Tk_AllocFontFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_CreateOptionTable_TCL_DECLARED
#define Tk_CreateOptionTable_TCL_DECLARED
/* 190 */
EXTERN Tk_OptionTable	Tk_CreateOptionTable(Tcl_Interp *interp,
				CONST Tk_OptionSpec *templatePtr);
#endif
#ifndef Tk_DeleteOptionTable_TCL_DECLARED
#define Tk_DeleteOptionTable_TCL_DECLARED
/* 191 */
EXTERN void		Tk_DeleteOptionTable(Tk_OptionTable optionTable);
#endif
#ifndef Tk_Free3DBorderFromObj_TCL_DECLARED
#define Tk_Free3DBorderFromObj_TCL_DECLARED
/* 192 */
EXTERN void		Tk_Free3DBorderFromObj(Tk_Window tkwin,
				Tcl_Obj *objPtr);
#endif
#ifndef Tk_FreeBitmapFromObj_TCL_DECLARED
#define Tk_FreeBitmapFromObj_TCL_DECLARED
/* 193 */
EXTERN void		Tk_FreeBitmapFromObj(Tk_Window tkwin,
				Tcl_Obj *objPtr);
#endif
#ifndef Tk_FreeColorFromObj_TCL_DECLARED
#define Tk_FreeColorFromObj_TCL_DECLARED
/* 194 */
EXTERN void		Tk_FreeColorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_FreeConfigOptions_TCL_DECLARED
#define Tk_FreeConfigOptions_TCL_DECLARED
/* 195 */
EXTERN void		Tk_FreeConfigOptions(char *recordPtr,
				Tk_OptionTable optionToken, Tk_Window tkwin);
#endif
#ifndef Tk_FreeSavedOptions_TCL_DECLARED
#define Tk_FreeSavedOptions_TCL_DECLARED
/* 196 */
EXTERN void		Tk_FreeSavedOptions(Tk_SavedOptions *savePtr);
#endif
#ifndef Tk_FreeCursorFromObj_TCL_DECLARED
#define Tk_FreeCursorFromObj_TCL_DECLARED
/* 197 */
EXTERN void		Tk_FreeCursorFromObj(Tk_Window tkwin,
				Tcl_Obj *objPtr);
#endif
#ifndef Tk_FreeFontFromObj_TCL_DECLARED
#define Tk_FreeFontFromObj_TCL_DECLARED
/* 198 */
EXTERN void		Tk_FreeFontFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_Get3DBorderFromObj_TCL_DECLARED
#define Tk_Get3DBorderFromObj_TCL_DECLARED
/* 199 */
EXTERN Tk_3DBorder	Tk_Get3DBorderFromObj(Tk_Window tkwin,
				Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetAnchorFromObj_TCL_DECLARED
#define Tk_GetAnchorFromObj_TCL_DECLARED
/* 200 */
EXTERN int		Tk_GetAnchorFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, Tk_Anchor *anchorPtr);
#endif
#ifndef Tk_GetBitmapFromObj_TCL_DECLARED
#define Tk_GetBitmapFromObj_TCL_DECLARED
/* 201 */
EXTERN Pixmap		Tk_GetBitmapFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetColorFromObj_TCL_DECLARED
#define Tk_GetColorFromObj_TCL_DECLARED
/* 202 */
EXTERN XColor *		Tk_GetColorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetCursorFromObj_TCL_DECLARED
#define Tk_GetCursorFromObj_TCL_DECLARED
/* 203 */
EXTERN Tk_Cursor	Tk_GetCursorFromObj(Tk_Window tkwin, Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetOptionInfo_TCL_DECLARED
#define Tk_GetOptionInfo_TCL_DECLARED
/* 204 */
EXTERN Tcl_Obj *	Tk_GetOptionInfo(Tcl_Interp *interp, char *recordPtr,
				Tk_OptionTable optionTable, Tcl_Obj *namePtr,
				Tk_Window tkwin);
#endif
#ifndef Tk_GetOptionValue_TCL_DECLARED
#define Tk_GetOptionValue_TCL_DECLARED
/* 205 */
EXTERN Tcl_Obj *	Tk_GetOptionValue(Tcl_Interp *interp,
				char *recordPtr, Tk_OptionTable optionTable,
				Tcl_Obj *namePtr, Tk_Window tkwin);
#endif
#ifndef Tk_GetJustifyFromObj_TCL_DECLARED
#define Tk_GetJustifyFromObj_TCL_DECLARED
/* 206 */
EXTERN int		Tk_GetJustifyFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, Tk_Justify *justifyPtr);
#endif
#ifndef Tk_GetMMFromObj_TCL_DECLARED
#define Tk_GetMMFromObj_TCL_DECLARED
/* 207 */
EXTERN int		Tk_GetMMFromObj(Tcl_Interp *interp, Tk_Window tkwin,
				Tcl_Obj *objPtr, double *doublePtr);
#endif
#ifndef Tk_GetPixelsFromObj_TCL_DECLARED
#define Tk_GetPixelsFromObj_TCL_DECLARED
/* 208 */
EXTERN int		Tk_GetPixelsFromObj(Tcl_Interp *interp,
				Tk_Window tkwin, Tcl_Obj *objPtr,
				int *intPtr);
#endif
#ifndef Tk_GetReliefFromObj_TCL_DECLARED
#define Tk_GetReliefFromObj_TCL_DECLARED
/* 209 */
EXTERN int		Tk_GetReliefFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr, int *resultPtr);
#endif
#ifndef Tk_GetScrollInfoObj_TCL_DECLARED
#define Tk_GetScrollInfoObj_TCL_DECLARED
/* 210 */
EXTERN int		Tk_GetScrollInfoObj(Tcl_Interp *interp, int objc,
				Tcl_Obj *CONST objv[], double *dblPtr,
				int *intPtr);
#endif
#ifndef Tk_InitOptions_TCL_DECLARED
#define Tk_InitOptions_TCL_DECLARED
/* 211 */
EXTERN int		Tk_InitOptions(Tcl_Interp *interp, char *recordPtr,
				Tk_OptionTable optionToken, Tk_Window tkwin);
#endif
#ifndef Tk_MainEx_TCL_DECLARED
#define Tk_MainEx_TCL_DECLARED
/* 212 */
EXTERN void		Tk_MainEx(int argc, char **argv,
				Tcl_AppInitProc *appInitProc,
				Tcl_Interp *interp);
#endif
#ifndef Tk_RestoreSavedOptions_TCL_DECLARED
#define Tk_RestoreSavedOptions_TCL_DECLARED
/* 213 */
EXTERN void		Tk_RestoreSavedOptions(Tk_SavedOptions *savePtr);
#endif
#ifndef Tk_SetOptions_TCL_DECLARED
#define Tk_SetOptions_TCL_DECLARED
/* 214 */
EXTERN int		Tk_SetOptions(Tcl_Interp *interp, char *recordPtr,
				Tk_OptionTable optionTable, int objc,
				Tcl_Obj *CONST objv[], Tk_Window tkwin,
				Tk_SavedOptions *savePtr, int *maskPtr);
#endif
#ifndef Tk_InitConsoleChannels_TCL_DECLARED
#define Tk_InitConsoleChannels_TCL_DECLARED
/* 215 */
EXTERN void		Tk_InitConsoleChannels(Tcl_Interp *interp);
#endif
#ifndef Tk_CreateConsoleWindow_TCL_DECLARED
#define Tk_CreateConsoleWindow_TCL_DECLARED
/* 216 */
EXTERN int		Tk_CreateConsoleWindow(Tcl_Interp *interp);
#endif
#ifndef Tk_CreateSmoothMethod_TCL_DECLARED
#define Tk_CreateSmoothMethod_TCL_DECLARED
/* 217 */
EXTERN void		Tk_CreateSmoothMethod(Tcl_Interp *interp,
				Tk_SmoothMethod *method);
#endif
/* Slot 218 is reserved */
/* Slot 219 is reserved */
#ifndef Tk_GetDash_TCL_DECLARED
#define Tk_GetDash_TCL_DECLARED
/* 220 */
EXTERN int		Tk_GetDash(Tcl_Interp *interp, CONST char *value,
				Tk_Dash *dash);
#endif
#ifndef Tk_CreateOutline_TCL_DECLARED
#define Tk_CreateOutline_TCL_DECLARED
/* 221 */
EXTERN void		Tk_CreateOutline(Tk_Outline *outline);
#endif
#ifndef Tk_DeleteOutline_TCL_DECLARED
#define Tk_DeleteOutline_TCL_DECLARED
/* 222 */
EXTERN void		Tk_DeleteOutline(Display *display,
				Tk_Outline *outline);
#endif
#ifndef Tk_ConfigOutlineGC_TCL_DECLARED
#define Tk_ConfigOutlineGC_TCL_DECLARED
/* 223 */
EXTERN int		Tk_ConfigOutlineGC(XGCValues *gcValues,
				Tk_Canvas canvas, Tk_Item *item,
				Tk_Outline *outline);
#endif
#ifndef Tk_ChangeOutlineGC_TCL_DECLARED
#define Tk_ChangeOutlineGC_TCL_DECLARED
/* 224 */
EXTERN int		Tk_ChangeOutlineGC(Tk_Canvas canvas, Tk_Item *item,
				Tk_Outline *outline);
#endif
#ifndef Tk_ResetOutlineGC_TCL_DECLARED
#define Tk_ResetOutlineGC_TCL_DECLARED
/* 225 */
EXTERN int		Tk_ResetOutlineGC(Tk_Canvas canvas, Tk_Item *item,
				Tk_Outline *outline);
#endif
#ifndef Tk_CanvasPsOutline_TCL_DECLARED
#define Tk_CanvasPsOutline_TCL_DECLARED
/* 226 */
EXTERN int		Tk_CanvasPsOutline(Tk_Canvas canvas, Tk_Item *item,
				Tk_Outline *outline);
#endif
#ifndef Tk_SetTSOrigin_TCL_DECLARED
#define Tk_SetTSOrigin_TCL_DECLARED
/* 227 */
EXTERN void		Tk_SetTSOrigin(Tk_Window tkwin, GC gc, int x, int y);
#endif
#ifndef Tk_CanvasGetCoordFromObj_TCL_DECLARED
#define Tk_CanvasGetCoordFromObj_TCL_DECLARED
/* 228 */
EXTERN int		Tk_CanvasGetCoordFromObj(Tcl_Interp *interp,
				Tk_Canvas canvas, Tcl_Obj *obj,
				double *doublePtr);
#endif
#ifndef Tk_CanvasSetOffset_TCL_DECLARED
#define Tk_CanvasSetOffset_TCL_DECLARED
/* 229 */
EXTERN void		Tk_CanvasSetOffset(Tk_Canvas canvas, GC gc,
				Tk_TSOffset *offset);
#endif
#ifndef Tk_DitherPhoto_TCL_DECLARED
#define Tk_DitherPhoto_TCL_DECLARED
/* 230 */
EXTERN void		Tk_DitherPhoto(Tk_PhotoHandle handle, int x, int y,
				int width, int height);
#endif
#ifndef Tk_PostscriptBitmap_TCL_DECLARED
#define Tk_PostscriptBitmap_TCL_DECLARED
/* 231 */
EXTERN int		Tk_PostscriptBitmap(Tcl_Interp *interp,
				Tk_Window tkwin, Tk_PostscriptInfo psInfo,
				Pixmap bitmap, int startX, int startY,
				int width, int height);
#endif
#ifndef Tk_PostscriptColor_TCL_DECLARED
#define Tk_PostscriptColor_TCL_DECLARED
/* 232 */
EXTERN int		Tk_PostscriptColor(Tcl_Interp *interp,
				Tk_PostscriptInfo psInfo, XColor *colorPtr);
#endif
#ifndef Tk_PostscriptFont_TCL_DECLARED
#define Tk_PostscriptFont_TCL_DECLARED
/* 233 */
EXTERN int		Tk_PostscriptFont(Tcl_Interp *interp,
				Tk_PostscriptInfo psInfo, Tk_Font font);
#endif
#ifndef Tk_PostscriptImage_TCL_DECLARED
#define Tk_PostscriptImage_TCL_DECLARED
/* 234 */
EXTERN int		Tk_PostscriptImage(Tk_Image image,
				Tcl_Interp *interp, Tk_Window tkwin,
				Tk_PostscriptInfo psinfo, int x, int y,
				int width, int height, int prepass);
#endif
#ifndef Tk_PostscriptPath_TCL_DECLARED
#define Tk_PostscriptPath_TCL_DECLARED
/* 235 */
EXTERN void		Tk_PostscriptPath(Tcl_Interp *interp,
				Tk_PostscriptInfo psInfo, double *coordPtr,
				int numPoints);
#endif
#ifndef Tk_PostscriptStipple_TCL_DECLARED
#define Tk_PostscriptStipple_TCL_DECLARED
/* 236 */
EXTERN int		Tk_PostscriptStipple(Tcl_Interp *interp,
				Tk_Window tkwin, Tk_PostscriptInfo psInfo,
				Pixmap bitmap);
#endif
#ifndef Tk_PostscriptY_TCL_DECLARED
#define Tk_PostscriptY_TCL_DECLARED
/* 237 */
EXTERN double		Tk_PostscriptY(double y, Tk_PostscriptInfo psInfo);
#endif
#ifndef Tk_PostscriptPhoto_TCL_DECLARED
#define Tk_PostscriptPhoto_TCL_DECLARED
/* 238 */
EXTERN int		Tk_PostscriptPhoto(Tcl_Interp *interp,
				Tk_PhotoImageBlock *blockPtr,
				Tk_PostscriptInfo psInfo, int width,
				int height);
#endif
#ifndef Tk_CreateClientMessageHandler_TCL_DECLARED
#define Tk_CreateClientMessageHandler_TCL_DECLARED
/* 239 */
EXTERN void		Tk_CreateClientMessageHandler(
				Tk_ClientMessageProc *proc);
#endif
#ifndef Tk_DeleteClientMessageHandler_TCL_DECLARED
#define Tk_DeleteClientMessageHandler_TCL_DECLARED
/* 240 */
EXTERN void		Tk_DeleteClientMessageHandler(
				Tk_ClientMessageProc *proc);
#endif
#ifndef Tk_CreateAnonymousWindow_TCL_DECLARED
#define Tk_CreateAnonymousWindow_TCL_DECLARED
/* 241 */
EXTERN Tk_Window	Tk_CreateAnonymousWindow(Tcl_Interp *interp,
				Tk_Window parent, CONST char *screenName);
#endif
#ifndef Tk_SetClassProcs_TCL_DECLARED
#define Tk_SetClassProcs_TCL_DECLARED
/* 242 */
EXTERN void		Tk_SetClassProcs(Tk_Window tkwin,
				Tk_ClassProcs *procs,
				ClientData instanceData);
#endif
#ifndef Tk_SetInternalBorderEx_TCL_DECLARED
#define Tk_SetInternalBorderEx_TCL_DECLARED
/* 243 */
EXTERN void		Tk_SetInternalBorderEx(Tk_Window tkwin, int left,
				int right, int top, int bottom);
#endif
#ifndef Tk_SetMinimumRequestSize_TCL_DECLARED
#define Tk_SetMinimumRequestSize_TCL_DECLARED
/* 244 */
EXTERN void		Tk_SetMinimumRequestSize(Tk_Window tkwin,
				int minWidth, int minHeight);
#endif
#ifndef Tk_SetCaretPos_TCL_DECLARED
#define Tk_SetCaretPos_TCL_DECLARED
/* 245 */
EXTERN void		Tk_SetCaretPos(Tk_Window tkwin, int x, int y,
				int height);
#endif
#ifndef Tk_PhotoPutBlock_Panic_TCL_DECLARED
#define Tk_PhotoPutBlock_Panic_TCL_DECLARED
/* 246 */
EXTERN void		Tk_PhotoPutBlock_Panic(Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height, int compRule);
#endif
#ifndef Tk_PhotoPutZoomedBlock_Panic_TCL_DECLARED
#define Tk_PhotoPutZoomedBlock_Panic_TCL_DECLARED
/* 247 */
EXTERN void		Tk_PhotoPutZoomedBlock_Panic(Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height, int zoomX, int zoomY,
				int subsampleX, int subsampleY, int compRule);
#endif
#ifndef Tk_CollapseMotionEvents_TCL_DECLARED
#define Tk_CollapseMotionEvents_TCL_DECLARED
/* 248 */
EXTERN int		Tk_CollapseMotionEvents(Display *display,
				int collapse);
#endif
#ifndef Tk_RegisterStyleEngine_TCL_DECLARED
#define Tk_RegisterStyleEngine_TCL_DECLARED
/* 249 */
EXTERN Tk_StyleEngine	Tk_RegisterStyleEngine(CONST char *name,
				Tk_StyleEngine parent);
#endif
#ifndef Tk_GetStyleEngine_TCL_DECLARED
#define Tk_GetStyleEngine_TCL_DECLARED
/* 250 */
EXTERN Tk_StyleEngine	Tk_GetStyleEngine(CONST char *name);
#endif
#ifndef Tk_RegisterStyledElement_TCL_DECLARED
#define Tk_RegisterStyledElement_TCL_DECLARED
/* 251 */
EXTERN int		Tk_RegisterStyledElement(Tk_StyleEngine engine,
				Tk_ElementSpec *templatePtr);
#endif
#ifndef Tk_GetElementId_TCL_DECLARED
#define Tk_GetElementId_TCL_DECLARED
/* 252 */
EXTERN int		Tk_GetElementId(CONST char *name);
#endif
#ifndef Tk_CreateStyle_TCL_DECLARED
#define Tk_CreateStyle_TCL_DECLARED
/* 253 */
EXTERN Tk_Style		Tk_CreateStyle(CONST char *name,
				Tk_StyleEngine engine, ClientData clientData);
#endif
#ifndef Tk_GetStyle_TCL_DECLARED
#define Tk_GetStyle_TCL_DECLARED
/* 254 */
EXTERN Tk_Style		Tk_GetStyle(Tcl_Interp *interp, CONST char *name);
#endif
#ifndef Tk_FreeStyle_TCL_DECLARED
#define Tk_FreeStyle_TCL_DECLARED
/* 255 */
EXTERN void		Tk_FreeStyle(Tk_Style style);
#endif
#ifndef Tk_NameOfStyle_TCL_DECLARED
#define Tk_NameOfStyle_TCL_DECLARED
/* 256 */
EXTERN CONST char *	Tk_NameOfStyle(Tk_Style style);
#endif
#ifndef Tk_AllocStyleFromObj_TCL_DECLARED
#define Tk_AllocStyleFromObj_TCL_DECLARED
/* 257 */
EXTERN Tk_Style		Tk_AllocStyleFromObj(Tcl_Interp *interp,
				Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetStyleFromObj_TCL_DECLARED
#define Tk_GetStyleFromObj_TCL_DECLARED
/* 258 */
EXTERN Tk_Style		Tk_GetStyleFromObj(Tcl_Obj *objPtr);
#endif
#ifndef Tk_FreeStyleFromObj_TCL_DECLARED
#define Tk_FreeStyleFromObj_TCL_DECLARED
/* 259 */
EXTERN void		Tk_FreeStyleFromObj(Tcl_Obj *objPtr);
#endif
#ifndef Tk_GetStyledElement_TCL_DECLARED
#define Tk_GetStyledElement_TCL_DECLARED
/* 260 */
EXTERN Tk_StyledElement	 Tk_GetStyledElement(Tk_Style style, int elementId,
				Tk_OptionTable optionTable);
#endif
#ifndef Tk_GetElementSize_TCL_DECLARED
#define Tk_GetElementSize_TCL_DECLARED
/* 261 */
EXTERN void		Tk_GetElementSize(Tk_Style style,
				Tk_StyledElement element, char *recordPtr,
				Tk_Window tkwin, int width, int height,
				int inner, int *widthPtr, int *heightPtr);
#endif
#ifndef Tk_GetElementBox_TCL_DECLARED
#define Tk_GetElementBox_TCL_DECLARED
/* 262 */
EXTERN void		Tk_GetElementBox(Tk_Style style,
				Tk_StyledElement element, char *recordPtr,
				Tk_Window tkwin, int x, int y, int width,
				int height, int inner, int *xPtr, int *yPtr,
				int *widthPtr, int *heightPtr);
#endif
#ifndef Tk_GetElementBorderWidth_TCL_DECLARED
#define Tk_GetElementBorderWidth_TCL_DECLARED
/* 263 */
EXTERN int		Tk_GetElementBorderWidth(Tk_Style style,
				Tk_StyledElement element, char *recordPtr,
				Tk_Window tkwin);
#endif
#ifndef Tk_DrawElement_TCL_DECLARED
#define Tk_DrawElement_TCL_DECLARED
/* 264 */
EXTERN void		Tk_DrawElement(Tk_Style style,
				Tk_StyledElement element, char *recordPtr,
				Tk_Window tkwin, Drawable d, int x, int y,
				int width, int height, int state);
#endif
#ifndef Tk_PhotoExpand_TCL_DECLARED
#define Tk_PhotoExpand_TCL_DECLARED
/* 265 */
EXTERN int		Tk_PhotoExpand(Tcl_Interp *interp,
				Tk_PhotoHandle handle, int width, int height);
#endif
#ifndef Tk_PhotoPutBlock_TCL_DECLARED
#define Tk_PhotoPutBlock_TCL_DECLARED
/* 266 */
EXTERN int		Tk_PhotoPutBlock(Tcl_Interp *interp,
				Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height, int compRule);
#endif
#ifndef Tk_PhotoPutZoomedBlock_TCL_DECLARED
#define Tk_PhotoPutZoomedBlock_TCL_DECLARED
/* 267 */
EXTERN int		Tk_PhotoPutZoomedBlock(Tcl_Interp *interp,
				Tk_PhotoHandle handle,
				Tk_PhotoImageBlock *blockPtr, int x, int y,
				int width, int height, int zoomX, int zoomY,
				int subsampleX, int subsampleY, int compRule);
#endif
#ifndef Tk_PhotoSetSize_TCL_DECLARED
#define Tk_PhotoSetSize_TCL_DECLARED
/* 268 */
EXTERN int		Tk_PhotoSetSize(Tcl_Interp *interp,
				Tk_PhotoHandle handle, int width, int height);
#endif
#ifndef Tk_GetUserInactiveTime_TCL_DECLARED
#define Tk_GetUserInactiveTime_TCL_DECLARED
/* 269 */
EXTERN long		Tk_GetUserInactiveTime(Display *dpy);
#endif
#ifndef Tk_ResetUserInactiveTime_TCL_DECLARED
#define Tk_ResetUserInactiveTime_TCL_DECLARED
/* 270 */
EXTERN void		Tk_ResetUserInactiveTime(Display *dpy);
#endif
#ifndef Tk_Interp_TCL_DECLARED
#define Tk_Interp_TCL_DECLARED
/* 271 */
EXTERN Tcl_Interp *	Tk_Interp(Tk_Window tkwin);
#endif
#ifndef Tk_CreateOldImageType_TCL_DECLARED
#define Tk_CreateOldImageType_TCL_DECLARED
/* 272 */
EXTERN void		Tk_CreateOldImageType(Tk_ImageType *typePtr);
#endif
#ifndef Tk_CreateOldPhotoImageFormat_TCL_DECLARED
#define Tk_CreateOldPhotoImageFormat_TCL_DECLARED
/* 273 */
EXTERN void		Tk_CreateOldPhotoImageFormat(
				Tk_PhotoImageFormat *formatPtr);
#endif

typedef struct TkStubHooks {
    struct TkPlatStubs *tkPlatStubs;
    struct TkIntStubs *tkIntStubs;
    struct TkIntPlatStubs *tkIntPlatStubs;
    struct TkIntXlibStubs *tkIntXlibStubs;
} TkStubHooks;

typedef struct TkStubs {
    int magic;
    struct TkStubHooks *hooks;

    void (*tk_MainLoop) (void); /* 0 */
    XColor * (*tk_3DBorderColor) (Tk_3DBorder border); /* 1 */
    GC (*tk_3DBorderGC) (Tk_Window tkwin, Tk_3DBorder border, int which); /* 2 */
    void (*tk_3DHorizontalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftIn, int rightIn, int topBevel, int relief); /* 3 */
    void (*tk_3DVerticalBevel) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int leftBevel, int relief); /* 4 */
    void (*tk_AddOption) (Tk_Window tkwin, CONST char *name, CONST char *value, int priority); /* 5 */
    void (*tk_BindEvent) (Tk_BindingTable bindingTable, XEvent *eventPtr, Tk_Window tkwin, int numObjects, ClientData *objectPtr); /* 6 */
    void (*tk_CanvasDrawableCoords) (Tk_Canvas canvas, double x, double y, short *drawableXPtr, short *drawableYPtr); /* 7 */
    void (*tk_CanvasEventuallyRedraw) (Tk_Canvas canvas, int x1, int y1, int x2, int y2); /* 8 */
    int (*tk_CanvasGetCoord) (Tcl_Interp *interp, Tk_Canvas canvas, CONST char *str, double *doublePtr); /* 9 */
    Tk_CanvasTextInfo * (*tk_CanvasGetTextInfo) (Tk_Canvas canvas); /* 10 */
    int (*tk_CanvasPsBitmap) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap, int x, int y, int width, int height); /* 11 */
    int (*tk_CanvasPsColor) (Tcl_Interp *interp, Tk_Canvas canvas, XColor *colorPtr); /* 12 */
    int (*tk_CanvasPsFont) (Tcl_Interp *interp, Tk_Canvas canvas, Tk_Font font); /* 13 */
    void (*tk_CanvasPsPath) (Tcl_Interp *interp, Tk_Canvas canvas, double *coordPtr, int numPoints); /* 14 */
    int (*tk_CanvasPsStipple) (Tcl_Interp *interp, Tk_Canvas canvas, Pixmap bitmap); /* 15 */
    double (*tk_CanvasPsY) (Tk_Canvas canvas, double y); /* 16 */
    void (*tk_CanvasSetStippleOrigin) (Tk_Canvas canvas, GC gc); /* 17 */
    int (*tk_CanvasTagsParseProc) (ClientData clientData, Tcl_Interp *interp, Tk_Window tkwin, CONST char *value, char *widgRec, int offset); /* 18 */
    char * (*tk_CanvasTagsPrintProc) (ClientData clientData, Tk_Window tkwin, char *widgRec, int offset, Tcl_FreeProc **freeProcPtr); /* 19 */
    Tk_Window (*tk_CanvasTkwin) (Tk_Canvas canvas); /* 20 */
    void (*tk_CanvasWindowCoords) (Tk_Canvas canvas, double x, double y, short *screenXPtr, short *screenYPtr); /* 21 */
    void (*tk_ChangeWindowAttributes) (Tk_Window tkwin, unsigned long valueMask, XSetWindowAttributes *attsPtr); /* 22 */
    int (*tk_CharBbox) (Tk_TextLayout layout, int index, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 23 */
    void (*tk_ClearSelection) (Tk_Window tkwin, Atom selection); /* 24 */
    int (*tk_ClipboardAppend) (Tcl_Interp *interp, Tk_Window tkwin, Atom target, Atom format, char *buffer); /* 25 */
    int (*tk_ClipboardClear) (Tcl_Interp *interp, Tk_Window tkwin); /* 26 */
    int (*tk_ConfigureInfo) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags); /* 27 */
    int (*tk_ConfigureValue) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, char *widgRec, CONST char *argvName, int flags); /* 28 */
    int (*tk_ConfigureWidget) (Tcl_Interp *interp, Tk_Window tkwin, Tk_ConfigSpec *specs, int argc, CONST84 char **argv, char *widgRec, int flags); /* 29 */
    void (*tk_ConfigureWindow) (Tk_Window tkwin, unsigned int valueMask, XWindowChanges *valuePtr); /* 30 */
    Tk_TextLayout (*tk_ComputeTextLayout) (Tk_Font font, CONST char *str, int numChars, int wrapLength, Tk_Justify justify, int flags, int *widthPtr, int *heightPtr); /* 31 */
    Tk_Window (*tk_CoordsToWindow) (int rootX, int rootY, Tk_Window tkwin); /* 32 */
    unsigned long (*tk_CreateBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr, CONST char *command, int append); /* 33 */
    Tk_BindingTable (*tk_CreateBindingTable) (Tcl_Interp *interp); /* 34 */
    Tk_ErrorHandler (*tk_CreateErrorHandler) (Display *display, int errNum, int request, int minorCode, Tk_ErrorProc *errorProc, ClientData clientData); /* 35 */
    void (*tk_CreateEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData); /* 36 */
    void (*tk_CreateGenericHandler) (Tk_GenericProc *proc, ClientData clientData); /* 37 */
    void (*tk_CreateImageType) (Tk_ImageType *typePtr); /* 38 */
    void (*tk_CreateItemType) (Tk_ItemType *typePtr); /* 39 */
    void (*tk_CreatePhotoImageFormat) (Tk_PhotoImageFormat *formatPtr); /* 40 */
    void (*tk_CreateSelHandler) (Tk_Window tkwin, Atom selection, Atom target, Tk_SelectionProc *proc, ClientData clientData, Atom format); /* 41 */
    Tk_Window (*tk_CreateWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *name, CONST char *screenName); /* 42 */
    Tk_Window (*tk_CreateWindowFromPath) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *pathName, CONST char *screenName); /* 43 */
    int (*tk_DefineBitmap) (Tcl_Interp *interp, CONST char *name, CONST char *source, int width, int height); /* 44 */
    void (*tk_DefineCursor) (Tk_Window window, Tk_Cursor cursor); /* 45 */
    void (*tk_DeleteAllBindings) (Tk_BindingTable bindingTable, ClientData object); /* 46 */
    int (*tk_DeleteBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr); /* 47 */
    void (*tk_DeleteBindingTable) (Tk_BindingTable bindingTable); /* 48 */
    void (*tk_DeleteErrorHandler) (Tk_ErrorHandler handler); /* 49 */
    void (*tk_DeleteEventHandler) (Tk_Window token, unsigned long mask, Tk_EventProc *proc, ClientData clientData); /* 50 */
    void (*tk_DeleteGenericHandler) (Tk_GenericProc *proc, ClientData clientData); /* 51 */
    void (*tk_DeleteImage) (Tcl_Interp *interp, CONST char *name); /* 52 */
    void (*tk_DeleteSelHandler) (Tk_Window tkwin, Atom selection, Atom target); /* 53 */
    void (*tk_DestroyWindow) (Tk_Window tkwin); /* 54 */
    CONST84_RETURN char * (*tk_DisplayName) (Tk_Window tkwin); /* 55 */
    int (*tk_DistanceToTextLayout) (Tk_TextLayout layout, int x, int y); /* 56 */
    void (*tk_Draw3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief); /* 57 */
    void (*tk_Draw3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief); /* 58 */
    void (*tk_DrawChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int numBytes, int x, int y); /* 59 */
    void (*tk_DrawFocusHighlight) (Tk_Window tkwin, GC gc, int width, Drawable drawable); /* 60 */
    void (*tk_DrawTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int firstChar, int lastChar); /* 61 */
    void (*tk_Fill3DPolygon) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, XPoint *pointPtr, int numPoints, int borderWidth, int leftRelief); /* 62 */
    void (*tk_Fill3DRectangle) (Tk_Window tkwin, Drawable drawable, Tk_3DBorder border, int x, int y, int width, int height, int borderWidth, int relief); /* 63 */
    Tk_PhotoHandle (*tk_FindPhoto) (Tcl_Interp *interp, CONST char *imageName); /* 64 */
    Font (*tk_FontId) (Tk_Font font); /* 65 */
    void (*tk_Free3DBorder) (Tk_3DBorder border); /* 66 */
    void (*tk_FreeBitmap) (Display *display, Pixmap bitmap); /* 67 */
    void (*tk_FreeColor) (XColor *colorPtr); /* 68 */
    void (*tk_FreeColormap) (Display *display, Colormap colormap); /* 69 */
    void (*tk_FreeCursor) (Display *display, Tk_Cursor cursor); /* 70 */
    void (*tk_FreeFont) (Tk_Font f); /* 71 */
    void (*tk_FreeGC) (Display *display, GC gc); /* 72 */
    void (*tk_FreeImage) (Tk_Image image); /* 73 */
    void (*tk_FreeOptions) (Tk_ConfigSpec *specs, char *widgRec, Display *display, int needFlags); /* 74 */
    void (*tk_FreePixmap) (Display *display, Pixmap pixmap); /* 75 */
    void (*tk_FreeTextLayout) (Tk_TextLayout textLayout); /* 76 */
    void (*tk_FreeXId) (Display *display, XID xid); /* 77 */
    GC (*tk_GCForColor) (XColor *colorPtr, Drawable drawable); /* 78 */
    void (*tk_GeometryRequest) (Tk_Window tkwin, int reqWidth, int reqHeight); /* 79 */
    Tk_3DBorder (*tk_Get3DBorder) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid colorName); /* 80 */
    void (*tk_GetAllBindings) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object); /* 81 */
    int (*tk_GetAnchor) (Tcl_Interp *interp, CONST char *str, Tk_Anchor *anchorPtr); /* 82 */
    CONST84_RETURN char * (*tk_GetAtomName) (Tk_Window tkwin, Atom atom); /* 83 */
    CONST84_RETURN char * (*tk_GetBinding) (Tcl_Interp *interp, Tk_BindingTable bindingTable, ClientData object, CONST char *eventStr); /* 84 */
    Pixmap (*tk_GetBitmap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 85 */
    Pixmap (*tk_GetBitmapFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, int width, int height); /* 86 */
    int (*tk_GetCapStyle) (Tcl_Interp *interp, CONST char *str, int *capPtr); /* 87 */
    XColor * (*tk_GetColor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid name); /* 88 */
    XColor * (*tk_GetColorByValue) (Tk_Window tkwin, XColor *colorPtr); /* 89 */
    Colormap (*tk_GetColormap) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 90 */
    Tk_Cursor (*tk_GetCursor) (Tcl_Interp *interp, Tk_Window tkwin, Tk_Uid str); /* 91 */
    Tk_Cursor (*tk_GetCursorFromData) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *source, CONST char *mask, int width, int height, int xHot, int yHot, Tk_Uid fg, Tk_Uid bg); /* 92 */
    Tk_Font (*tk_GetFont) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str); /* 93 */
    Tk_Font (*tk_GetFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 94 */
    void (*tk_GetFontMetrics) (Tk_Font font, Tk_FontMetrics *fmPtr); /* 95 */
    GC (*tk_GetGC) (Tk_Window tkwin, unsigned long valueMask, XGCValues *valuePtr); /* 96 */
    Tk_Image (*tk_GetImage) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *name, Tk_ImageChangedProc *changeProc, ClientData clientData); /* 97 */
    ClientData (*tk_GetImageMasterData) (Tcl_Interp *interp, CONST char *name, Tk_ImageType **typePtrPtr); /* 98 */
    Tk_ItemType * (*tk_GetItemTypes) (void); /* 99 */
    int (*tk_GetJoinStyle) (Tcl_Interp *interp, CONST char *str, int *joinPtr); /* 100 */
    int (*tk_GetJustify) (Tcl_Interp *interp, CONST char *str, Tk_Justify *justifyPtr); /* 101 */
    int (*tk_GetNumMainWindows) (void); /* 102 */
    Tk_Uid (*tk_GetOption) (Tk_Window tkwin, CONST char *name, CONST char *className); /* 103 */
    int (*tk_GetPixels) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *intPtr); /* 104 */
    Pixmap (*tk_GetPixmap) (Display *display, Drawable d, int width, int height, int depth); /* 105 */
    int (*tk_GetRelief) (Tcl_Interp *interp, CONST char *name, int *reliefPtr); /* 106 */
    void (*tk_GetRootCoords) (Tk_Window tkwin, int *xPtr, int *yPtr); /* 107 */
    int (*tk_GetScrollInfo) (Tcl_Interp *interp, int argc, CONST84 char **argv, double *dblPtr, int *intPtr); /* 108 */
    int (*tk_GetScreenMM) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, double *doublePtr); /* 109 */
    int (*tk_GetSelection) (Tcl_Interp *interp, Tk_Window tkwin, Atom selection, Atom target, Tk_GetSelProc *proc, ClientData clientData); /* 110 */
    Tk_Uid (*tk_GetUid) (CONST char *str); /* 111 */
    Visual * (*tk_GetVisual) (Tcl_Interp *interp, Tk_Window tkwin, CONST char *str, int *depthPtr, Colormap *colormapPtr); /* 112 */
    void (*tk_GetVRootGeometry) (Tk_Window tkwin, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 113 */
    int (*tk_Grab) (Tcl_Interp *interp, Tk_Window tkwin, int grabGlobal); /* 114 */
    void (*tk_HandleEvent) (XEvent *eventPtr); /* 115 */
    Tk_Window (*tk_IdToWindow) (Display *display, Window window); /* 116 */
    void (*tk_ImageChanged) (Tk_ImageMaster master, int x, int y, int width, int height, int imageWidth, int imageHeight); /* 117 */
    int (*tk_Init) (Tcl_Interp *interp); /* 118 */
    Atom (*tk_InternAtom) (Tk_Window tkwin, CONST char *name); /* 119 */
    int (*tk_IntersectTextLayout) (Tk_TextLayout layout, int x, int y, int width, int height); /* 120 */
    void (*tk_MaintainGeometry) (Tk_Window slave, Tk_Window master, int x, int y, int width, int height); /* 121 */
    Tk_Window (*tk_MainWindow) (Tcl_Interp *interp); /* 122 */
    void (*tk_MakeWindowExist) (Tk_Window tkwin); /* 123 */
    void (*tk_ManageGeometry) (Tk_Window tkwin, CONST Tk_GeomMgr *mgrPtr, ClientData clientData); /* 124 */
    void (*tk_MapWindow) (Tk_Window tkwin); /* 125 */
    int (*tk_MeasureChars) (Tk_Font tkfont, CONST char *source, int numBytes, int maxPixels, int flags, int *lengthPtr); /* 126 */
    void (*tk_MoveResizeWindow) (Tk_Window tkwin, int x, int y, int width, int height); /* 127 */
    void (*tk_MoveWindow) (Tk_Window tkwin, int x, int y); /* 128 */
    void (*tk_MoveToplevelWindow) (Tk_Window tkwin, int x, int y); /* 129 */
    CONST84_RETURN char * (*tk_NameOf3DBorder) (Tk_3DBorder border); /* 130 */
    CONST84_RETURN char * (*tk_NameOfAnchor) (Tk_Anchor anchor); /* 131 */
    CONST84_RETURN char * (*tk_NameOfBitmap) (Display *display, Pixmap bitmap); /* 132 */
    CONST84_RETURN char * (*tk_NameOfCapStyle) (int cap); /* 133 */
    CONST84_RETURN char * (*tk_NameOfColor) (XColor *colorPtr); /* 134 */
    CONST84_RETURN char * (*tk_NameOfCursor) (Display *display, Tk_Cursor cursor); /* 135 */
    CONST84_RETURN char * (*tk_NameOfFont) (Tk_Font font); /* 136 */
    CONST84_RETURN char * (*tk_NameOfImage) (Tk_ImageMaster imageMaster); /* 137 */
    CONST84_RETURN char * (*tk_NameOfJoinStyle) (int join); /* 138 */
    CONST84_RETURN char * (*tk_NameOfJustify) (Tk_Justify justify); /* 139 */
    CONST84_RETURN char * (*tk_NameOfRelief) (int relief); /* 140 */
    Tk_Window (*tk_NameToWindow) (Tcl_Interp *interp, CONST char *pathName, Tk_Window tkwin); /* 141 */
    void (*tk_OwnSelection) (Tk_Window tkwin, Atom selection, Tk_LostSelProc *proc, ClientData clientData); /* 142 */
    int (*tk_ParseArgv) (Tcl_Interp *interp, Tk_Window tkwin, int *argcPtr, CONST84 char **argv, Tk_ArgvInfo *argTable, int flags); /* 143 */
    void (*tk_PhotoPutBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height); /* 144 */
    void (*tk_PhotoPutZoomedBlock_NoComposite) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY); /* 145 */
    int (*tk_PhotoGetImage) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr); /* 146 */
    void (*tk_PhotoBlank) (Tk_PhotoHandle handle); /* 147 */
    void (*tk_PhotoExpand_Panic) (Tk_PhotoHandle handle, int width, int height); /* 148 */
    void (*tk_PhotoGetSize) (Tk_PhotoHandle handle, int *widthPtr, int *heightPtr); /* 149 */
    void (*tk_PhotoSetSize_Panic) (Tk_PhotoHandle handle, int width, int height); /* 150 */
    int (*tk_PointToChar) (Tk_TextLayout layout, int x, int y); /* 151 */
    int (*tk_PostscriptFontName) (Tk_Font tkfont, Tcl_DString *dsPtr); /* 152 */
    void (*tk_PreserveColormap) (Display *display, Colormap colormap); /* 153 */
    void (*tk_QueueWindowEvent) (XEvent *eventPtr, Tcl_QueuePosition position); /* 154 */
    void (*tk_RedrawImage) (Tk_Image image, int imageX, int imageY, int width, int height, Drawable drawable, int drawableX, int drawableY); /* 155 */
    void (*tk_ResizeWindow) (Tk_Window tkwin, int width, int height); /* 156 */
    int (*tk_RestackWindow) (Tk_Window tkwin, int aboveBelow, Tk_Window other); /* 157 */
    Tk_RestrictProc * (*tk_RestrictEvents) (Tk_RestrictProc *proc, ClientData arg, ClientData *prevArgPtr); /* 158 */
    int (*tk_SafeInit) (Tcl_Interp *interp); /* 159 */
    CONST char * (*tk_SetAppName) (Tk_Window tkwin, CONST char *name); /* 160 */
    void (*tk_SetBackgroundFromBorder) (Tk_Window tkwin, Tk_3DBorder border); /* 161 */
    void (*tk_SetClass) (Tk_Window tkwin, CONST char *className); /* 162 */
    void (*tk_SetGrid) (Tk_Window tkwin, int reqWidth, int reqHeight, int gridWidth, int gridHeight); /* 163 */
    void (*tk_SetInternalBorder) (Tk_Window tkwin, int width); /* 164 */
    void (*tk_SetWindowBackground) (Tk_Window tkwin, unsigned long pixel); /* 165 */
    void (*tk_SetWindowBackgroundPixmap) (Tk_Window tkwin, Pixmap pixmap); /* 166 */
    void (*tk_SetWindowBorder) (Tk_Window tkwin, unsigned long pixel); /* 167 */
    void (*tk_SetWindowBorderWidth) (Tk_Window tkwin, int width); /* 168 */
    void (*tk_SetWindowBorderPixmap) (Tk_Window tkwin, Pixmap pixmap); /* 169 */
    void (*tk_SetWindowColormap) (Tk_Window tkwin, Colormap colormap); /* 170 */
    int (*tk_SetWindowVisual) (Tk_Window tkwin, Visual *visual, int depth, Colormap colormap); /* 171 */
    void (*tk_SizeOfBitmap) (Display *display, Pixmap bitmap, int *widthPtr, int *heightPtr); /* 172 */
    void (*tk_SizeOfImage) (Tk_Image image, int *widthPtr, int *heightPtr); /* 173 */
    int (*tk_StrictMotif) (Tk_Window tkwin); /* 174 */
    void (*tk_TextLayoutToPostscript) (Tcl_Interp *interp, Tk_TextLayout layout); /* 175 */
    int (*tk_TextWidth) (Tk_Font font, CONST char *str, int numBytes); /* 176 */
    void (*tk_UndefineCursor) (Tk_Window window); /* 177 */
    void (*tk_UnderlineChars) (Display *display, Drawable drawable, GC gc, Tk_Font tkfont, CONST char *source, int x, int y, int firstByte, int lastByte); /* 178 */
    void (*tk_UnderlineTextLayout) (Display *display, Drawable drawable, GC gc, Tk_TextLayout layout, int x, int y, int underline); /* 179 */
    void (*tk_Ungrab) (Tk_Window tkwin); /* 180 */
    void (*tk_UnmaintainGeometry) (Tk_Window slave, Tk_Window master); /* 181 */
    void (*tk_UnmapWindow) (Tk_Window tkwin); /* 182 */
    void (*tk_UnsetGrid) (Tk_Window tkwin); /* 183 */
    void (*tk_UpdatePointer) (Tk_Window tkwin, int x, int y, int state); /* 184 */
    Pixmap (*tk_AllocBitmapFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 185 */
    Tk_3DBorder (*tk_Alloc3DBorderFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 186 */
    XColor * (*tk_AllocColorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 187 */
    Tk_Cursor (*tk_AllocCursorFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 188 */
    Tk_Font (*tk_AllocFontFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr); /* 189 */
    Tk_OptionTable (*tk_CreateOptionTable) (Tcl_Interp *interp, CONST Tk_OptionSpec *templatePtr); /* 190 */
    void (*tk_DeleteOptionTable) (Tk_OptionTable optionTable); /* 191 */
    void (*tk_Free3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 192 */
    void (*tk_FreeBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 193 */
    void (*tk_FreeColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 194 */
    void (*tk_FreeConfigOptions) (char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin); /* 195 */
    void (*tk_FreeSavedOptions) (Tk_SavedOptions *savePtr); /* 196 */
    void (*tk_FreeCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 197 */
    void (*tk_FreeFontFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 198 */
    Tk_3DBorder (*tk_Get3DBorderFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 199 */
    int (*tk_GetAnchorFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Anchor *anchorPtr); /* 200 */
    Pixmap (*tk_GetBitmapFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 201 */
    XColor * (*tk_GetColorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 202 */
    Tk_Cursor (*tk_GetCursorFromObj) (Tk_Window tkwin, Tcl_Obj *objPtr); /* 203 */
    Tcl_Obj * (*tk_GetOptionInfo) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin); /* 204 */
    Tcl_Obj * (*tk_GetOptionValue) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, Tcl_Obj *namePtr, Tk_Window tkwin); /* 205 */
    int (*tk_GetJustifyFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tk_Justify *justifyPtr); /* 206 */
    int (*tk_GetMMFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, double *doublePtr); /* 207 */
    int (*tk_GetPixelsFromObj) (Tcl_Interp *interp, Tk_Window tkwin, Tcl_Obj *objPtr, int *intPtr); /* 208 */
    int (*tk_GetReliefFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, int *resultPtr); /* 209 */
    int (*tk_GetScrollInfoObj) (Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], double *dblPtr, int *intPtr); /* 210 */
    int (*tk_InitOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionToken, Tk_Window tkwin); /* 211 */
    void (*tk_MainEx) (int argc, char **argv, Tcl_AppInitProc *appInitProc, Tcl_Interp *interp); /* 212 */
    void (*tk_RestoreSavedOptions) (Tk_SavedOptions *savePtr); /* 213 */
    int (*tk_SetOptions) (Tcl_Interp *interp, char *recordPtr, Tk_OptionTable optionTable, int objc, Tcl_Obj *CONST objv[], Tk_Window tkwin, Tk_SavedOptions *savePtr, int *maskPtr); /* 214 */
    void (*tk_InitConsoleChannels) (Tcl_Interp *interp); /* 215 */
    int (*tk_CreateConsoleWindow) (Tcl_Interp *interp); /* 216 */
    void (*tk_CreateSmoothMethod) (Tcl_Interp *interp, Tk_SmoothMethod *method); /* 217 */
    void *reserved218;
    void *reserved219;
    int (*tk_GetDash) (Tcl_Interp *interp, CONST char *value, Tk_Dash *dash); /* 220 */
    void (*tk_CreateOutline) (Tk_Outline *outline); /* 221 */
    void (*tk_DeleteOutline) (Display *display, Tk_Outline *outline); /* 222 */
    int (*tk_ConfigOutlineGC) (XGCValues *gcValues, Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 223 */
    int (*tk_ChangeOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 224 */
    int (*tk_ResetOutlineGC) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 225 */
    int (*tk_CanvasPsOutline) (Tk_Canvas canvas, Tk_Item *item, Tk_Outline *outline); /* 226 */
    void (*tk_SetTSOrigin) (Tk_Window tkwin, GC gc, int x, int y); /* 227 */
    int (*tk_CanvasGetCoordFromObj) (Tcl_Interp *interp, Tk_Canvas canvas, Tcl_Obj *obj, double *doublePtr); /* 228 */
    void (*tk_CanvasSetOffset) (Tk_Canvas canvas, GC gc, Tk_TSOffset *offset); /* 229 */
    void (*tk_DitherPhoto) (Tk_PhotoHandle handle, int x, int y, int width, int height); /* 230 */
    int (*tk_PostscriptBitmap) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap, int startX, int startY, int width, int height); /* 231 */
    int (*tk_PostscriptColor) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, XColor *colorPtr); /* 232 */
    int (*tk_PostscriptFont) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, Tk_Font font); /* 233 */
    int (*tk_PostscriptImage) (Tk_Image image, Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psinfo, int x, int y, int width, int height, int prepass); /* 234 */
    void (*tk_PostscriptPath) (Tcl_Interp *interp, Tk_PostscriptInfo psInfo, double *coordPtr, int numPoints); /* 235 */
    int (*tk_PostscriptStipple) (Tcl_Interp *interp, Tk_Window tkwin, Tk_PostscriptInfo psInfo, Pixmap bitmap); /* 236 */
    double (*tk_PostscriptY) (double y, Tk_PostscriptInfo psInfo); /* 237 */
    int (*tk_PostscriptPhoto) (Tcl_Interp *interp, Tk_PhotoImageBlock *blockPtr, Tk_PostscriptInfo psInfo, int width, int height); /* 238 */
    void (*tk_CreateClientMessageHandler) (Tk_ClientMessageProc *proc); /* 239 */
    void (*tk_DeleteClientMessageHandler) (Tk_ClientMessageProc *proc); /* 240 */
    Tk_Window (*tk_CreateAnonymousWindow) (Tcl_Interp *interp, Tk_Window parent, CONST char *screenName); /* 241 */
    void (*tk_SetClassProcs) (Tk_Window tkwin, Tk_ClassProcs *procs, ClientData instanceData); /* 242 */
    void (*tk_SetInternalBorderEx) (Tk_Window tkwin, int left, int right, int top, int bottom); /* 243 */
    void (*tk_SetMinimumRequestSize) (Tk_Window tkwin, int minWidth, int minHeight); /* 244 */
    void (*tk_SetCaretPos) (Tk_Window tkwin, int x, int y, int height); /* 245 */
    void (*tk_PhotoPutBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule); /* 246 */
    void (*tk_PhotoPutZoomedBlock_Panic) (Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule); /* 247 */
    int (*tk_CollapseMotionEvents) (Display *display, int collapse); /* 248 */
    Tk_StyleEngine (*tk_RegisterStyleEngine) (CONST char *name, Tk_StyleEngine parent); /* 249 */
    Tk_StyleEngine (*tk_GetStyleEngine) (CONST char *name); /* 250 */
    int (*tk_RegisterStyledElement) (Tk_StyleEngine engine, Tk_ElementSpec *templatePtr); /* 251 */
    int (*tk_GetElementId) (CONST char *name); /* 252 */
    Tk_Style (*tk_CreateStyle) (CONST char *name, Tk_StyleEngine engine, ClientData clientData); /* 253 */
    Tk_Style (*tk_GetStyle) (Tcl_Interp *interp, CONST char *name); /* 254 */
    void (*tk_FreeStyle) (Tk_Style style); /* 255 */
    CONST char * (*tk_NameOfStyle) (Tk_Style style); /* 256 */
    Tk_Style (*tk_AllocStyleFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr); /* 257 */
    Tk_Style (*tk_GetStyleFromObj) (Tcl_Obj *objPtr); /* 258 */
    void (*tk_FreeStyleFromObj) (Tcl_Obj *objPtr); /* 259 */
    Tk_StyledElement (*tk_GetStyledElement) (Tk_Style style, int elementId, Tk_OptionTable optionTable); /* 260 */
    void (*tk_GetElementSize) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int width, int height, int inner, int *widthPtr, int *heightPtr); /* 261 */
    void (*tk_GetElementBox) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, int x, int y, int width, int height, int inner, int *xPtr, int *yPtr, int *widthPtr, int *heightPtr); /* 262 */
    int (*tk_GetElementBorderWidth) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin); /* 263 */
    void (*tk_DrawElement) (Tk_Style style, Tk_StyledElement element, char *recordPtr, Tk_Window tkwin, Drawable d, int x, int y, int width, int height, int state); /* 264 */
    int (*tk_PhotoExpand) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height); /* 265 */
    int (*tk_PhotoPutBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int compRule); /* 266 */
    int (*tk_PhotoPutZoomedBlock) (Tcl_Interp *interp, Tk_PhotoHandle handle, Tk_PhotoImageBlock *blockPtr, int x, int y, int width, int height, int zoomX, int zoomY, int subsampleX, int subsampleY, int compRule); /* 267 */
    int (*tk_PhotoSetSize) (Tcl_Interp *interp, Tk_PhotoHandle handle, int width, int height); /* 268 */
    long (*tk_GetUserInactiveTime) (Display *dpy); /* 269 */
    void (*tk_ResetUserInactiveTime) (Display *dpy); /* 270 */
    Tcl_Interp * (*tk_Interp) (Tk_Window tkwin); /* 271 */
    void (*tk_CreateOldImageType) (Tk_ImageType *typePtr); /* 272 */
    void (*tk_CreateOldPhotoImageFormat) (Tk_PhotoImageFormat *formatPtr); /* 273 */
} TkStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkStubs *tkStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifndef Tk_MainLoop
#define Tk_MainLoop \
	(tkStubsPtr->tk_MainLoop) /* 0 */
#endif
#ifndef Tk_3DBorderColor
#define Tk_3DBorderColor \
	(tkStubsPtr->tk_3DBorderColor) /* 1 */
#endif
#ifndef Tk_3DBorderGC
#define Tk_3DBorderGC \
	(tkStubsPtr->tk_3DBorderGC) /* 2 */
#endif
#ifndef Tk_3DHorizontalBevel
#define Tk_3DHorizontalBevel \
	(tkStubsPtr->tk_3DHorizontalBevel) /* 3 */
#endif
#ifndef Tk_3DVerticalBevel
#define Tk_3DVerticalBevel \
	(tkStubsPtr->tk_3DVerticalBevel) /* 4 */
#endif
#ifndef Tk_AddOption
#define Tk_AddOption \
	(tkStubsPtr->tk_AddOption) /* 5 */
#endif
#ifndef Tk_BindEvent
#define Tk_BindEvent \
	(tkStubsPtr->tk_BindEvent) /* 6 */
#endif
#ifndef Tk_CanvasDrawableCoords
#define Tk_CanvasDrawableCoords \
	(tkStubsPtr->tk_CanvasDrawableCoords) /* 7 */
#endif
#ifndef Tk_CanvasEventuallyRedraw
#define Tk_CanvasEventuallyRedraw \
	(tkStubsPtr->tk_CanvasEventuallyRedraw) /* 8 */
#endif
#ifndef Tk_CanvasGetCoord
#define Tk_CanvasGetCoord \
	(tkStubsPtr->tk_CanvasGetCoord) /* 9 */
#endif
#ifndef Tk_CanvasGetTextInfo
#define Tk_CanvasGetTextInfo \
	(tkStubsPtr->tk_CanvasGetTextInfo) /* 10 */
#endif
#ifndef Tk_CanvasPsBitmap
#define Tk_CanvasPsBitmap \
	(tkStubsPtr->tk_CanvasPsBitmap) /* 11 */
#endif
#ifndef Tk_CanvasPsColor
#define Tk_CanvasPsColor \
	(tkStubsPtr->tk_CanvasPsColor) /* 12 */
#endif
#ifndef Tk_CanvasPsFont
#define Tk_CanvasPsFont \
	(tkStubsPtr->tk_CanvasPsFont) /* 13 */
#endif
#ifndef Tk_CanvasPsPath
#define Tk_CanvasPsPath \
	(tkStubsPtr->tk_CanvasPsPath) /* 14 */
#endif
#ifndef Tk_CanvasPsStipple
#define Tk_CanvasPsStipple \
	(tkStubsPtr->tk_CanvasPsStipple) /* 15 */
#endif
#ifndef Tk_CanvasPsY
#define Tk_CanvasPsY \
	(tkStubsPtr->tk_CanvasPsY) /* 16 */
#endif
#ifndef Tk_CanvasSetStippleOrigin
#define Tk_CanvasSetStippleOrigin \
	(tkStubsPtr->tk_CanvasSetStippleOrigin) /* 17 */
#endif
#ifndef Tk_CanvasTagsParseProc
#define Tk_CanvasTagsParseProc \
	(tkStubsPtr->tk_CanvasTagsParseProc) /* 18 */
#endif
#ifndef Tk_CanvasTagsPrintProc
#define Tk_CanvasTagsPrintProc \
	(tkStubsPtr->tk_CanvasTagsPrintProc) /* 19 */
#endif
#ifndef Tk_CanvasTkwin
#define Tk_CanvasTkwin \
	(tkStubsPtr->tk_CanvasTkwin) /* 20 */
#endif
#ifndef Tk_CanvasWindowCoords
#define Tk_CanvasWindowCoords \
	(tkStubsPtr->tk_CanvasWindowCoords) /* 21 */
#endif
#ifndef Tk_ChangeWindowAttributes
#define Tk_ChangeWindowAttributes \
	(tkStubsPtr->tk_ChangeWindowAttributes) /* 22 */
#endif
#ifndef Tk_CharBbox
#define Tk_CharBbox \
	(tkStubsPtr->tk_CharBbox) /* 23 */
#endif
#ifndef Tk_ClearSelection
#define Tk_ClearSelection \
	(tkStubsPtr->tk_ClearSelection) /* 24 */
#endif
#ifndef Tk_ClipboardAppend
#define Tk_ClipboardAppend \
	(tkStubsPtr->tk_ClipboardAppend) /* 25 */
#endif
#ifndef Tk_ClipboardClear
#define Tk_ClipboardClear \
	(tkStubsPtr->tk_ClipboardClear) /* 26 */
#endif
#ifndef Tk_ConfigureInfo
#define Tk_ConfigureInfo \
	(tkStubsPtr->tk_ConfigureInfo) /* 27 */
#endif
#ifndef Tk_ConfigureValue
#define Tk_ConfigureValue \
	(tkStubsPtr->tk_ConfigureValue) /* 28 */
#endif
#ifndef Tk_ConfigureWidget
#define Tk_ConfigureWidget \
	(tkStubsPtr->tk_ConfigureWidget) /* 29 */
#endif
#ifndef Tk_ConfigureWindow
#define Tk_ConfigureWindow \
	(tkStubsPtr->tk_ConfigureWindow) /* 30 */
#endif
#ifndef Tk_ComputeTextLayout
#define Tk_ComputeTextLayout \
	(tkStubsPtr->tk_ComputeTextLayout) /* 31 */
#endif
#ifndef Tk_CoordsToWindow
#define Tk_CoordsToWindow \
	(tkStubsPtr->tk_CoordsToWindow) /* 32 */
#endif
#ifndef Tk_CreateBinding
#define Tk_CreateBinding \
	(tkStubsPtr->tk_CreateBinding) /* 33 */
#endif
#ifndef Tk_CreateBindingTable
#define Tk_CreateBindingTable \
	(tkStubsPtr->tk_CreateBindingTable) /* 34 */
#endif
#ifndef Tk_CreateErrorHandler
#define Tk_CreateErrorHandler \
	(tkStubsPtr->tk_CreateErrorHandler) /* 35 */
#endif
#ifndef Tk_CreateEventHandler
#define Tk_CreateEventHandler \
	(tkStubsPtr->tk_CreateEventHandler) /* 36 */
#endif
#ifndef Tk_CreateGenericHandler
#define Tk_CreateGenericHandler \
	(tkStubsPtr->tk_CreateGenericHandler) /* 37 */
#endif
#ifndef Tk_CreateImageType
#define Tk_CreateImageType \
	(tkStubsPtr->tk_CreateImageType) /* 38 */
#endif
#ifndef Tk_CreateItemType
#define Tk_CreateItemType \
	(tkStubsPtr->tk_CreateItemType) /* 39 */
#endif
#ifndef Tk_CreatePhotoImageFormat
#define Tk_CreatePhotoImageFormat \
	(tkStubsPtr->tk_CreatePhotoImageFormat) /* 40 */
#endif
#ifndef Tk_CreateSelHandler
#define Tk_CreateSelHandler \
	(tkStubsPtr->tk_CreateSelHandler) /* 41 */
#endif
#ifndef Tk_CreateWindow
#define Tk_CreateWindow \
	(tkStubsPtr->tk_CreateWindow) /* 42 */
#endif
#ifndef Tk_CreateWindowFromPath
#define Tk_CreateWindowFromPath \
	(tkStubsPtr->tk_CreateWindowFromPath) /* 43 */
#endif
#ifndef Tk_DefineBitmap
#define Tk_DefineBitmap \
	(tkStubsPtr->tk_DefineBitmap) /* 44 */
#endif
#ifndef Tk_DefineCursor
#define Tk_DefineCursor \
	(tkStubsPtr->tk_DefineCursor) /* 45 */
#endif
#ifndef Tk_DeleteAllBindings
#define Tk_DeleteAllBindings \
	(tkStubsPtr->tk_DeleteAllBindings) /* 46 */
#endif
#ifndef Tk_DeleteBinding
#define Tk_DeleteBinding \
	(tkStubsPtr->tk_DeleteBinding) /* 47 */
#endif
#ifndef Tk_DeleteBindingTable
#define Tk_DeleteBindingTable \
	(tkStubsPtr->tk_DeleteBindingTable) /* 48 */
#endif
#ifndef Tk_DeleteErrorHandler
#define Tk_DeleteErrorHandler \
	(tkStubsPtr->tk_DeleteErrorHandler) /* 49 */
#endif
#ifndef Tk_DeleteEventHandler
#define Tk_DeleteEventHandler \
	(tkStubsPtr->tk_DeleteEventHandler) /* 50 */
#endif
#ifndef Tk_DeleteGenericHandler
#define Tk_DeleteGenericHandler \
	(tkStubsPtr->tk_DeleteGenericHandler) /* 51 */
#endif
#ifndef Tk_DeleteImage
#define Tk_DeleteImage \
	(tkStubsPtr->tk_DeleteImage) /* 52 */
#endif
#ifndef Tk_DeleteSelHandler
#define Tk_DeleteSelHandler \
	(tkStubsPtr->tk_DeleteSelHandler) /* 53 */
#endif
#ifndef Tk_DestroyWindow
#define Tk_DestroyWindow \
	(tkStubsPtr->tk_DestroyWindow) /* 54 */
#endif
#ifndef Tk_DisplayName
#define Tk_DisplayName \
	(tkStubsPtr->tk_DisplayName) /* 55 */
#endif
#ifndef Tk_DistanceToTextLayout
#define Tk_DistanceToTextLayout \
	(tkStubsPtr->tk_DistanceToTextLayout) /* 56 */
#endif
#ifndef Tk_Draw3DPolygon
#define Tk_Draw3DPolygon \
	(tkStubsPtr->tk_Draw3DPolygon) /* 57 */
#endif
#ifndef Tk_Draw3DRectangle
#define Tk_Draw3DRectangle \
	(tkStubsPtr->tk_Draw3DRectangle) /* 58 */
#endif
#ifndef Tk_DrawChars
#define Tk_DrawChars \
	(tkStubsPtr->tk_DrawChars) /* 59 */
#endif
#ifndef Tk_DrawFocusHighlight
#define Tk_DrawFocusHighlight \
	(tkStubsPtr->tk_DrawFocusHighlight) /* 60 */
#endif
#ifndef Tk_DrawTextLayout
#define Tk_DrawTextLayout \
	(tkStubsPtr->tk_DrawTextLayout) /* 61 */
#endif
#ifndef Tk_Fill3DPolygon
#define Tk_Fill3DPolygon \
	(tkStubsPtr->tk_Fill3DPolygon) /* 62 */
#endif
#ifndef Tk_Fill3DRectangle
#define Tk_Fill3DRectangle \
	(tkStubsPtr->tk_Fill3DRectangle) /* 63 */
#endif
#ifndef Tk_FindPhoto
#define Tk_FindPhoto \
	(tkStubsPtr->tk_FindPhoto) /* 64 */
#endif
#ifndef Tk_FontId
#define Tk_FontId \
	(tkStubsPtr->tk_FontId) /* 65 */
#endif
#ifndef Tk_Free3DBorder
#define Tk_Free3DBorder \
	(tkStubsPtr->tk_Free3DBorder) /* 66 */
#endif
#ifndef Tk_FreeBitmap
#define Tk_FreeBitmap \
	(tkStubsPtr->tk_FreeBitmap) /* 67 */
#endif
#ifndef Tk_FreeColor
#define Tk_FreeColor \
	(tkStubsPtr->tk_FreeColor) /* 68 */
#endif
#ifndef Tk_FreeColormap
#define Tk_FreeColormap \
	(tkStubsPtr->tk_FreeColormap) /* 69 */
#endif
#ifndef Tk_FreeCursor
#define Tk_FreeCursor \
	(tkStubsPtr->tk_FreeCursor) /* 70 */
#endif
#ifndef Tk_FreeFont
#define Tk_FreeFont \
	(tkStubsPtr->tk_FreeFont) /* 71 */
#endif
#ifndef Tk_FreeGC
#define Tk_FreeGC \
	(tkStubsPtr->tk_FreeGC) /* 72 */
#endif
#ifndef Tk_FreeImage
#define Tk_FreeImage \
	(tkStubsPtr->tk_FreeImage) /* 73 */
#endif
#ifndef Tk_FreeOptions
#define Tk_FreeOptions \
	(tkStubsPtr->tk_FreeOptions) /* 74 */
#endif
#ifndef Tk_FreePixmap
#define Tk_FreePixmap \
	(tkStubsPtr->tk_FreePixmap) /* 75 */
#endif
#ifndef Tk_FreeTextLayout
#define Tk_FreeTextLayout \
	(tkStubsPtr->tk_FreeTextLayout) /* 76 */
#endif
#ifndef Tk_FreeXId
#define Tk_FreeXId \
	(tkStubsPtr->tk_FreeXId) /* 77 */
#endif
#ifndef Tk_GCForColor
#define Tk_GCForColor \
	(tkStubsPtr->tk_GCForColor) /* 78 */
#endif
#ifndef Tk_GeometryRequest
#define Tk_GeometryRequest \
	(tkStubsPtr->tk_GeometryRequest) /* 79 */
#endif
#ifndef Tk_Get3DBorder
#define Tk_Get3DBorder \
	(tkStubsPtr->tk_Get3DBorder) /* 80 */
#endif
#ifndef Tk_GetAllBindings
#define Tk_GetAllBindings \
	(tkStubsPtr->tk_GetAllBindings) /* 81 */
#endif
#ifndef Tk_GetAnchor
#define Tk_GetAnchor \
	(tkStubsPtr->tk_GetAnchor) /* 82 */
#endif
#ifndef Tk_GetAtomName
#define Tk_GetAtomName \
	(tkStubsPtr->tk_GetAtomName) /* 83 */
#endif
#ifndef Tk_GetBinding
#define Tk_GetBinding \
	(tkStubsPtr->tk_GetBinding) /* 84 */
#endif
#ifndef Tk_GetBitmap
#define Tk_GetBitmap \
	(tkStubsPtr->tk_GetBitmap) /* 85 */
#endif
#ifndef Tk_GetBitmapFromData
#define Tk_GetBitmapFromData \
	(tkStubsPtr->tk_GetBitmapFromData) /* 86 */
#endif
#ifndef Tk_GetCapStyle
#define Tk_GetCapStyle \
	(tkStubsPtr->tk_GetCapStyle) /* 87 */
#endif
#ifndef Tk_GetColor
#define Tk_GetColor \
	(tkStubsPtr->tk_GetColor) /* 88 */
#endif
#ifndef Tk_GetColorByValue
#define Tk_GetColorByValue \
	(tkStubsPtr->tk_GetColorByValue) /* 89 */
#endif
#ifndef Tk_GetColormap
#define Tk_GetColormap \
	(tkStubsPtr->tk_GetColormap) /* 90 */
#endif
#ifndef Tk_GetCursor
#define Tk_GetCursor \
	(tkStubsPtr->tk_GetCursor) /* 91 */
#endif
#ifndef Tk_GetCursorFromData
#define Tk_GetCursorFromData \
	(tkStubsPtr->tk_GetCursorFromData) /* 92 */
#endif
#ifndef Tk_GetFont
#define Tk_GetFont \
	(tkStubsPtr->tk_GetFont) /* 93 */
#endif
#ifndef Tk_GetFontFromObj
#define Tk_GetFontFromObj \
	(tkStubsPtr->tk_GetFontFromObj) /* 94 */
#endif
#ifndef Tk_GetFontMetrics
#define Tk_GetFontMetrics \
	(tkStubsPtr->tk_GetFontMetrics) /* 95 */
#endif
#ifndef Tk_GetGC
#define Tk_GetGC \
	(tkStubsPtr->tk_GetGC) /* 96 */
#endif
#ifndef Tk_GetImage
#define Tk_GetImage \
	(tkStubsPtr->tk_GetImage) /* 97 */
#endif
#ifndef Tk_GetImageMasterData
#define Tk_GetImageMasterData \
	(tkStubsPtr->tk_GetImageMasterData) /* 98 */
#endif
#ifndef Tk_GetItemTypes
#define Tk_GetItemTypes \
	(tkStubsPtr->tk_GetItemTypes) /* 99 */
#endif
#ifndef Tk_GetJoinStyle
#define Tk_GetJoinStyle \
	(tkStubsPtr->tk_GetJoinStyle) /* 100 */
#endif
#ifndef Tk_GetJustify
#define Tk_GetJustify \
	(tkStubsPtr->tk_GetJustify) /* 101 */
#endif
#ifndef Tk_GetNumMainWindows
#define Tk_GetNumMainWindows \
	(tkStubsPtr->tk_GetNumMainWindows) /* 102 */
#endif
#ifndef Tk_GetOption
#define Tk_GetOption \
	(tkStubsPtr->tk_GetOption) /* 103 */
#endif
#ifndef Tk_GetPixels
#define Tk_GetPixels \
	(tkStubsPtr->tk_GetPixels) /* 104 */
#endif
#ifndef Tk_GetPixmap
#define Tk_GetPixmap \
	(tkStubsPtr->tk_GetPixmap) /* 105 */
#endif
#ifndef Tk_GetRelief
#define Tk_GetRelief \
	(tkStubsPtr->tk_GetRelief) /* 106 */
#endif
#ifndef Tk_GetRootCoords
#define Tk_GetRootCoords \
	(tkStubsPtr->tk_GetRootCoords) /* 107 */
#endif
#ifndef Tk_GetScrollInfo
#define Tk_GetScrollInfo \
	(tkStubsPtr->tk_GetScrollInfo) /* 108 */
#endif
#ifndef Tk_GetScreenMM
#define Tk_GetScreenMM \
	(tkStubsPtr->tk_GetScreenMM) /* 109 */
#endif
#ifndef Tk_GetSelection
#define Tk_GetSelection \
	(tkStubsPtr->tk_GetSelection) /* 110 */
#endif
#ifndef Tk_GetUid
#define Tk_GetUid \
	(tkStubsPtr->tk_GetUid) /* 111 */
#endif
#ifndef Tk_GetVisual
#define Tk_GetVisual \
	(tkStubsPtr->tk_GetVisual) /* 112 */
#endif
#ifndef Tk_GetVRootGeometry
#define Tk_GetVRootGeometry \
	(tkStubsPtr->tk_GetVRootGeometry) /* 113 */
#endif
#ifndef Tk_Grab
#define Tk_Grab \
	(tkStubsPtr->tk_Grab) /* 114 */
#endif
#ifndef Tk_HandleEvent
#define Tk_HandleEvent \
	(tkStubsPtr->tk_HandleEvent) /* 115 */
#endif
#ifndef Tk_IdToWindow
#define Tk_IdToWindow \
	(tkStubsPtr->tk_IdToWindow) /* 116 */
#endif
#ifndef Tk_ImageChanged
#define Tk_ImageChanged \
	(tkStubsPtr->tk_ImageChanged) /* 117 */
#endif
#ifndef Tk_Init
#define Tk_Init \
	(tkStubsPtr->tk_Init) /* 118 */
#endif
#ifndef Tk_InternAtom
#define Tk_InternAtom \
	(tkStubsPtr->tk_InternAtom) /* 119 */
#endif
#ifndef Tk_IntersectTextLayout
#define Tk_IntersectTextLayout \
	(tkStubsPtr->tk_IntersectTextLayout) /* 120 */
#endif
#ifndef Tk_MaintainGeometry
#define Tk_MaintainGeometry \
	(tkStubsPtr->tk_MaintainGeometry) /* 121 */
#endif
#ifndef Tk_MainWindow
#define Tk_MainWindow \
	(tkStubsPtr->tk_MainWindow) /* 122 */
#endif
#ifndef Tk_MakeWindowExist
#define Tk_MakeWindowExist \
	(tkStubsPtr->tk_MakeWindowExist) /* 123 */
#endif
#ifndef Tk_ManageGeometry
#define Tk_ManageGeometry \
	(tkStubsPtr->tk_ManageGeometry) /* 124 */
#endif
#ifndef Tk_MapWindow
#define Tk_MapWindow \
	(tkStubsPtr->tk_MapWindow) /* 125 */
#endif
#ifndef Tk_MeasureChars
#define Tk_MeasureChars \
	(tkStubsPtr->tk_MeasureChars) /* 126 */
#endif
#ifndef Tk_MoveResizeWindow
#define Tk_MoveResizeWindow \
	(tkStubsPtr->tk_MoveResizeWindow) /* 127 */
#endif
#ifndef Tk_MoveWindow
#define Tk_MoveWindow \
	(tkStubsPtr->tk_MoveWindow) /* 128 */
#endif
#ifndef Tk_MoveToplevelWindow
#define Tk_MoveToplevelWindow \
	(tkStubsPtr->tk_MoveToplevelWindow) /* 129 */
#endif
#ifndef Tk_NameOf3DBorder
#define Tk_NameOf3DBorder \
	(tkStubsPtr->tk_NameOf3DBorder) /* 130 */
#endif
#ifndef Tk_NameOfAnchor
#define Tk_NameOfAnchor \
	(tkStubsPtr->tk_NameOfAnchor) /* 131 */
#endif
#ifndef Tk_NameOfBitmap
#define Tk_NameOfBitmap \
	(tkStubsPtr->tk_NameOfBitmap) /* 132 */
#endif
#ifndef Tk_NameOfCapStyle
#define Tk_NameOfCapStyle \
	(tkStubsPtr->tk_NameOfCapStyle) /* 133 */
#endif
#ifndef Tk_NameOfColor
#define Tk_NameOfColor \
	(tkStubsPtr->tk_NameOfColor) /* 134 */
#endif
#ifndef Tk_NameOfCursor
#define Tk_NameOfCursor \
	(tkStubsPtr->tk_NameOfCursor) /* 135 */
#endif
#ifndef Tk_NameOfFont
#define Tk_NameOfFont \
	(tkStubsPtr->tk_NameOfFont) /* 136 */
#endif
#ifndef Tk_NameOfImage
#define Tk_NameOfImage \
	(tkStubsPtr->tk_NameOfImage) /* 137 */
#endif
#ifndef Tk_NameOfJoinStyle
#define Tk_NameOfJoinStyle \
	(tkStubsPtr->tk_NameOfJoinStyle) /* 138 */
#endif
#ifndef Tk_NameOfJustify
#define Tk_NameOfJustify \
	(tkStubsPtr->tk_NameOfJustify) /* 139 */
#endif
#ifndef Tk_NameOfRelief
#define Tk_NameOfRelief \
	(tkStubsPtr->tk_NameOfRelief) /* 140 */
#endif
#ifndef Tk_NameToWindow
#define Tk_NameToWindow \
	(tkStubsPtr->tk_NameToWindow) /* 141 */
#endif
#ifndef Tk_OwnSelection
#define Tk_OwnSelection \
	(tkStubsPtr->tk_OwnSelection) /* 142 */
#endif
#ifndef Tk_ParseArgv
#define Tk_ParseArgv \
	(tkStubsPtr->tk_ParseArgv) /* 143 */
#endif
#ifndef Tk_PhotoPutBlock_NoComposite
#define Tk_PhotoPutBlock_NoComposite \
	(tkStubsPtr->tk_PhotoPutBlock_NoComposite) /* 144 */
#endif
#ifndef Tk_PhotoPutZoomedBlock_NoComposite
#define Tk_PhotoPutZoomedBlock_NoComposite \
	(tkStubsPtr->tk_PhotoPutZoomedBlock_NoComposite) /* 145 */
#endif
#ifndef Tk_PhotoGetImage
#define Tk_PhotoGetImage \
	(tkStubsPtr->tk_PhotoGetImage) /* 146 */
#endif
#ifndef Tk_PhotoBlank
#define Tk_PhotoBlank \
	(tkStubsPtr->tk_PhotoBlank) /* 147 */
#endif
#ifndef Tk_PhotoExpand_Panic
#define Tk_PhotoExpand_Panic \
	(tkStubsPtr->tk_PhotoExpand_Panic) /* 148 */
#endif
#ifndef Tk_PhotoGetSize
#define Tk_PhotoGetSize \
	(tkStubsPtr->tk_PhotoGetSize) /* 149 */
#endif
#ifndef Tk_PhotoSetSize_Panic
#define Tk_PhotoSetSize_Panic \
	(tkStubsPtr->tk_PhotoSetSize_Panic) /* 150 */
#endif
#ifndef Tk_PointToChar
#define Tk_PointToChar \
	(tkStubsPtr->tk_PointToChar) /* 151 */
#endif
#ifndef Tk_PostscriptFontName
#define Tk_PostscriptFontName \
	(tkStubsPtr->tk_PostscriptFontName) /* 152 */
#endif
#ifndef Tk_PreserveColormap
#define Tk_PreserveColormap \
	(tkStubsPtr->tk_PreserveColormap) /* 153 */
#endif
#ifndef Tk_QueueWindowEvent
#define Tk_QueueWindowEvent \
	(tkStubsPtr->tk_QueueWindowEvent) /* 154 */
#endif
#ifndef Tk_RedrawImage
#define Tk_RedrawImage \
	(tkStubsPtr->tk_RedrawImage) /* 155 */
#endif
#ifndef Tk_ResizeWindow
#define Tk_ResizeWindow \
	(tkStubsPtr->tk_ResizeWindow) /* 156 */
#endif
#ifndef Tk_RestackWindow
#define Tk_RestackWindow \
	(tkStubsPtr->tk_RestackWindow) /* 157 */
#endif
#ifndef Tk_RestrictEvents
#define Tk_RestrictEvents \
	(tkStubsPtr->tk_RestrictEvents) /* 158 */
#endif
#ifndef Tk_SafeInit
#define Tk_SafeInit \
	(tkStubsPtr->tk_SafeInit) /* 159 */
#endif
#ifndef Tk_SetAppName
#define Tk_SetAppName \
	(tkStubsPtr->tk_SetAppName) /* 160 */
#endif
#ifndef Tk_SetBackgroundFromBorder
#define Tk_SetBackgroundFromBorder \
	(tkStubsPtr->tk_SetBackgroundFromBorder) /* 161 */
#endif
#ifndef Tk_SetClass
#define Tk_SetClass \
	(tkStubsPtr->tk_SetClass) /* 162 */
#endif
#ifndef Tk_SetGrid
#define Tk_SetGrid \
	(tkStubsPtr->tk_SetGrid) /* 163 */
#endif
#ifndef Tk_SetInternalBorder
#define Tk_SetInternalBorder \
	(tkStubsPtr->tk_SetInternalBorder) /* 164 */
#endif
#ifndef Tk_SetWindowBackground
#define Tk_SetWindowBackground \
	(tkStubsPtr->tk_SetWindowBackground) /* 165 */
#endif
#ifndef Tk_SetWindowBackgroundPixmap
#define Tk_SetWindowBackgroundPixmap \
	(tkStubsPtr->tk_SetWindowBackgroundPixmap) /* 166 */
#endif
#ifndef Tk_SetWindowBorder
#define Tk_SetWindowBorder \
	(tkStubsPtr->tk_SetWindowBorder) /* 167 */
#endif
#ifndef Tk_SetWindowBorderWidth
#define Tk_SetWindowBorderWidth \
	(tkStubsPtr->tk_SetWindowBorderWidth) /* 168 */
#endif
#ifndef Tk_SetWindowBorderPixmap
#define Tk_SetWindowBorderPixmap \
	(tkStubsPtr->tk_SetWindowBorderPixmap) /* 169 */
#endif
#ifndef Tk_SetWindowColormap
#define Tk_SetWindowColormap \
	(tkStubsPtr->tk_SetWindowColormap) /* 170 */
#endif
#ifndef Tk_SetWindowVisual
#define Tk_SetWindowVisual \
	(tkStubsPtr->tk_SetWindowVisual) /* 171 */
#endif
#ifndef Tk_SizeOfBitmap
#define Tk_SizeOfBitmap \
	(tkStubsPtr->tk_SizeOfBitmap) /* 172 */
#endif
#ifndef Tk_SizeOfImage
#define Tk_SizeOfImage \
	(tkStubsPtr->tk_SizeOfImage) /* 173 */
#endif
#ifndef Tk_StrictMotif
#define Tk_StrictMotif \
	(tkStubsPtr->tk_StrictMotif) /* 174 */
#endif
#ifndef Tk_TextLayoutToPostscript
#define Tk_TextLayoutToPostscript \
	(tkStubsPtr->tk_TextLayoutToPostscript) /* 175 */
#endif
#ifndef Tk_TextWidth
#define Tk_TextWidth \
	(tkStubsPtr->tk_TextWidth) /* 176 */
#endif
#ifndef Tk_UndefineCursor
#define Tk_UndefineCursor \
	(tkStubsPtr->tk_UndefineCursor) /* 177 */
#endif
#ifndef Tk_UnderlineChars
#define Tk_UnderlineChars \
	(tkStubsPtr->tk_UnderlineChars) /* 178 */
#endif
#ifndef Tk_UnderlineTextLayout
#define Tk_UnderlineTextLayout \
	(tkStubsPtr->tk_UnderlineTextLayout) /* 179 */
#endif
#ifndef Tk_Ungrab
#define Tk_Ungrab \
	(tkStubsPtr->tk_Ungrab) /* 180 */
#endif
#ifndef Tk_UnmaintainGeometry
#define Tk_UnmaintainGeometry \
	(tkStubsPtr->tk_UnmaintainGeometry) /* 181 */
#endif
#ifndef Tk_UnmapWindow
#define Tk_UnmapWindow \
	(tkStubsPtr->tk_UnmapWindow) /* 182 */
#endif
#ifndef Tk_UnsetGrid
#define Tk_UnsetGrid \
	(tkStubsPtr->tk_UnsetGrid) /* 183 */
#endif
#ifndef Tk_UpdatePointer
#define Tk_UpdatePointer \
	(tkStubsPtr->tk_UpdatePointer) /* 184 */
#endif
#ifndef Tk_AllocBitmapFromObj
#define Tk_AllocBitmapFromObj \
	(tkStubsPtr->tk_AllocBitmapFromObj) /* 185 */
#endif
#ifndef Tk_Alloc3DBorderFromObj
#define Tk_Alloc3DBorderFromObj \
	(tkStubsPtr->tk_Alloc3DBorderFromObj) /* 186 */
#endif
#ifndef Tk_AllocColorFromObj
#define Tk_AllocColorFromObj \
	(tkStubsPtr->tk_AllocColorFromObj) /* 187 */
#endif
#ifndef Tk_AllocCursorFromObj
#define Tk_AllocCursorFromObj \
	(tkStubsPtr->tk_AllocCursorFromObj) /* 188 */
#endif
#ifndef Tk_AllocFontFromObj
#define Tk_AllocFontFromObj \
	(tkStubsPtr->tk_AllocFontFromObj) /* 189 */
#endif
#ifndef Tk_CreateOptionTable
#define Tk_CreateOptionTable \
	(tkStubsPtr->tk_CreateOptionTable) /* 190 */
#endif
#ifndef Tk_DeleteOptionTable
#define Tk_DeleteOptionTable \
	(tkStubsPtr->tk_DeleteOptionTable) /* 191 */
#endif
#ifndef Tk_Free3DBorderFromObj
#define Tk_Free3DBorderFromObj \
	(tkStubsPtr->tk_Free3DBorderFromObj) /* 192 */
#endif
#ifndef Tk_FreeBitmapFromObj
#define Tk_FreeBitmapFromObj \
	(tkStubsPtr->tk_FreeBitmapFromObj) /* 193 */
#endif
#ifndef Tk_FreeColorFromObj
#define Tk_FreeColorFromObj \
	(tkStubsPtr->tk_FreeColorFromObj) /* 194 */
#endif
#ifndef Tk_FreeConfigOptions
#define Tk_FreeConfigOptions \
	(tkStubsPtr->tk_FreeConfigOptions) /* 195 */
#endif
#ifndef Tk_FreeSavedOptions
#define Tk_FreeSavedOptions \
	(tkStubsPtr->tk_FreeSavedOptions) /* 196 */
#endif
#ifndef Tk_FreeCursorFromObj
#define Tk_FreeCursorFromObj \
	(tkStubsPtr->tk_FreeCursorFromObj) /* 197 */
#endif
#ifndef Tk_FreeFontFromObj
#define Tk_FreeFontFromObj \
	(tkStubsPtr->tk_FreeFontFromObj) /* 198 */
#endif
#ifndef Tk_Get3DBorderFromObj
#define Tk_Get3DBorderFromObj \
	(tkStubsPtr->tk_Get3DBorderFromObj) /* 199 */
#endif
#ifndef Tk_GetAnchorFromObj
#define Tk_GetAnchorFromObj \
	(tkStubsPtr->tk_GetAnchorFromObj) /* 200 */
#endif
#ifndef Tk_GetBitmapFromObj
#define Tk_GetBitmapFromObj \
	(tkStubsPtr->tk_GetBitmapFromObj) /* 201 */
#endif
#ifndef Tk_GetColorFromObj
#define Tk_GetColorFromObj \
	(tkStubsPtr->tk_GetColorFromObj) /* 202 */
#endif
#ifndef Tk_GetCursorFromObj
#define Tk_GetCursorFromObj \
	(tkStubsPtr->tk_GetCursorFromObj) /* 203 */
#endif
#ifndef Tk_GetOptionInfo
#define Tk_GetOptionInfo \
	(tkStubsPtr->tk_GetOptionInfo) /* 204 */
#endif
#ifndef Tk_GetOptionValue
#define Tk_GetOptionValue \
	(tkStubsPtr->tk_GetOptionValue) /* 205 */
#endif
#ifndef Tk_GetJustifyFromObj
#define Tk_GetJustifyFromObj \
	(tkStubsPtr->tk_GetJustifyFromObj) /* 206 */
#endif
#ifndef Tk_GetMMFromObj
#define Tk_GetMMFromObj \
	(tkStubsPtr->tk_GetMMFromObj) /* 207 */
#endif
#ifndef Tk_GetPixelsFromObj
#define Tk_GetPixelsFromObj \
	(tkStubsPtr->tk_GetPixelsFromObj) /* 208 */
#endif
#ifndef Tk_GetReliefFromObj
#define Tk_GetReliefFromObj \
	(tkStubsPtr->tk_GetReliefFromObj) /* 209 */
#endif
#ifndef Tk_GetScrollInfoObj
#define Tk_GetScrollInfoObj \
	(tkStubsPtr->tk_GetScrollInfoObj) /* 210 */
#endif
#ifndef Tk_InitOptions
#define Tk_InitOptions \
	(tkStubsPtr->tk_InitOptions) /* 211 */
#endif
#ifndef Tk_MainEx
#define Tk_MainEx \
	(tkStubsPtr->tk_MainEx) /* 212 */
#endif
#ifndef Tk_RestoreSavedOptions
#define Tk_RestoreSavedOptions \
	(tkStubsPtr->tk_RestoreSavedOptions) /* 213 */
#endif
#ifndef Tk_SetOptions
#define Tk_SetOptions \
	(tkStubsPtr->tk_SetOptions) /* 214 */
#endif
#ifndef Tk_InitConsoleChannels
#define Tk_InitConsoleChannels \
	(tkStubsPtr->tk_InitConsoleChannels) /* 215 */
#endif
#ifndef Tk_CreateConsoleWindow
#define Tk_CreateConsoleWindow \
	(tkStubsPtr->tk_CreateConsoleWindow) /* 216 */
#endif
#ifndef Tk_CreateSmoothMethod
#define Tk_CreateSmoothMethod \
	(tkStubsPtr->tk_CreateSmoothMethod) /* 217 */
#endif
/* Slot 218 is reserved */
/* Slot 219 is reserved */
#ifndef Tk_GetDash
#define Tk_GetDash \
	(tkStubsPtr->tk_GetDash) /* 220 */
#endif
#ifndef Tk_CreateOutline
#define Tk_CreateOutline \
	(tkStubsPtr->tk_CreateOutline) /* 221 */
#endif
#ifndef Tk_DeleteOutline
#define Tk_DeleteOutline \
	(tkStubsPtr->tk_DeleteOutline) /* 222 */
#endif
#ifndef Tk_ConfigOutlineGC
#define Tk_ConfigOutlineGC \
	(tkStubsPtr->tk_ConfigOutlineGC) /* 223 */
#endif
#ifndef Tk_ChangeOutlineGC
#define Tk_ChangeOutlineGC \
	(tkStubsPtr->tk_ChangeOutlineGC) /* 224 */
#endif
#ifndef Tk_ResetOutlineGC
#define Tk_ResetOutlineGC \
	(tkStubsPtr->tk_ResetOutlineGC) /* 225 */
#endif
#ifndef Tk_CanvasPsOutline
#define Tk_CanvasPsOutline \
	(tkStubsPtr->tk_CanvasPsOutline) /* 226 */
#endif
#ifndef Tk_SetTSOrigin
#define Tk_SetTSOrigin \
	(tkStubsPtr->tk_SetTSOrigin) /* 227 */
#endif
#ifndef Tk_CanvasGetCoordFromObj
#define Tk_CanvasGetCoordFromObj \
	(tkStubsPtr->tk_CanvasGetCoordFromObj) /* 228 */
#endif
#ifndef Tk_CanvasSetOffset
#define Tk_CanvasSetOffset \
	(tkStubsPtr->tk_CanvasSetOffset) /* 229 */
#endif
#ifndef Tk_DitherPhoto
#define Tk_DitherPhoto \
	(tkStubsPtr->tk_DitherPhoto) /* 230 */
#endif
#ifndef Tk_PostscriptBitmap
#define Tk_PostscriptBitmap \
	(tkStubsPtr->tk_PostscriptBitmap) /* 231 */
#endif
#ifndef Tk_PostscriptColor
#define Tk_PostscriptColor \
	(tkStubsPtr->tk_PostscriptColor) /* 232 */
#endif
#ifndef Tk_PostscriptFont
#define Tk_PostscriptFont \
	(tkStubsPtr->tk_PostscriptFont) /* 233 */
#endif
#ifndef Tk_PostscriptImage
#define Tk_PostscriptImage \
	(tkStubsPtr->tk_PostscriptImage) /* 234 */
#endif
#ifndef Tk_PostscriptPath
#define Tk_PostscriptPath \
	(tkStubsPtr->tk_PostscriptPath) /* 235 */
#endif
#ifndef Tk_PostscriptStipple
#define Tk_PostscriptStipple \
	(tkStubsPtr->tk_PostscriptStipple) /* 236 */
#endif
#ifndef Tk_PostscriptY
#define Tk_PostscriptY \
	(tkStubsPtr->tk_PostscriptY) /* 237 */
#endif
#ifndef Tk_PostscriptPhoto
#define Tk_PostscriptPhoto \
	(tkStubsPtr->tk_PostscriptPhoto) /* 238 */
#endif
#ifndef Tk_CreateClientMessageHandler
#define Tk_CreateClientMessageHandler \
	(tkStubsPtr->tk_CreateClientMessageHandler) /* 239 */
#endif
#ifndef Tk_DeleteClientMessageHandler
#define Tk_DeleteClientMessageHandler \
	(tkStubsPtr->tk_DeleteClientMessageHandler) /* 240 */
#endif
#ifndef Tk_CreateAnonymousWindow
#define Tk_CreateAnonymousWindow \
	(tkStubsPtr->tk_CreateAnonymousWindow) /* 241 */
#endif
#ifndef Tk_SetClassProcs
#define Tk_SetClassProcs \
	(tkStubsPtr->tk_SetClassProcs) /* 242 */
#endif
#ifndef Tk_SetInternalBorderEx
#define Tk_SetInternalBorderEx \
	(tkStubsPtr->tk_SetInternalBorderEx) /* 243 */
#endif
#ifndef Tk_SetMinimumRequestSize
#define Tk_SetMinimumRequestSize \
	(tkStubsPtr->tk_SetMinimumRequestSize) /* 244 */
#endif
#ifndef Tk_SetCaretPos
#define Tk_SetCaretPos \
	(tkStubsPtr->tk_SetCaretPos) /* 245 */
#endif
#ifndef Tk_PhotoPutBlock_Panic
#define Tk_PhotoPutBlock_Panic \
	(tkStubsPtr->tk_PhotoPutBlock_Panic) /* 246 */
#endif
#ifndef Tk_PhotoPutZoomedBlock_Panic
#define Tk_PhotoPutZoomedBlock_Panic \
	(tkStubsPtr->tk_PhotoPutZoomedBlock_Panic) /* 247 */
#endif
#ifndef Tk_CollapseMotionEvents
#define Tk_CollapseMotionEvents \
	(tkStubsPtr->tk_CollapseMotionEvents) /* 248 */
#endif
#ifndef Tk_RegisterStyleEngine
#define Tk_RegisterStyleEngine \
	(tkStubsPtr->tk_RegisterStyleEngine) /* 249 */
#endif
#ifndef Tk_GetStyleEngine
#define Tk_GetStyleEngine \
	(tkStubsPtr->tk_GetStyleEngine) /* 250 */
#endif
#ifndef Tk_RegisterStyledElement
#define Tk_RegisterStyledElement \
	(tkStubsPtr->tk_RegisterStyledElement) /* 251 */
#endif
#ifndef Tk_GetElementId
#define Tk_GetElementId \
	(tkStubsPtr->tk_GetElementId) /* 252 */
#endif
#ifndef Tk_CreateStyle
#define Tk_CreateStyle \
	(tkStubsPtr->tk_CreateStyle) /* 253 */
#endif
#ifndef Tk_GetStyle
#define Tk_GetStyle \
	(tkStubsPtr->tk_GetStyle) /* 254 */
#endif
#ifndef Tk_FreeStyle
#define Tk_FreeStyle \
	(tkStubsPtr->tk_FreeStyle) /* 255 */
#endif
#ifndef Tk_NameOfStyle
#define Tk_NameOfStyle \
	(tkStubsPtr->tk_NameOfStyle) /* 256 */
#endif
#ifndef Tk_AllocStyleFromObj
#define Tk_AllocStyleFromObj \
	(tkStubsPtr->tk_AllocStyleFromObj) /* 257 */
#endif
#ifndef Tk_GetStyleFromObj
#define Tk_GetStyleFromObj \
	(tkStubsPtr->tk_GetStyleFromObj) /* 258 */
#endif
#ifndef Tk_FreeStyleFromObj
#define Tk_FreeStyleFromObj \
	(tkStubsPtr->tk_FreeStyleFromObj) /* 259 */
#endif
#ifndef Tk_GetStyledElement
#define Tk_GetStyledElement \
	(tkStubsPtr->tk_GetStyledElement) /* 260 */
#endif
#ifndef Tk_GetElementSize
#define Tk_GetElementSize \
	(tkStubsPtr->tk_GetElementSize) /* 261 */
#endif
#ifndef Tk_GetElementBox
#define Tk_GetElementBox \
	(tkStubsPtr->tk_GetElementBox) /* 262 */
#endif
#ifndef Tk_GetElementBorderWidth
#define Tk_GetElementBorderWidth \
	(tkStubsPtr->tk_GetElementBorderWidth) /* 263 */
#endif
#ifndef Tk_DrawElement
#define Tk_DrawElement \
	(tkStubsPtr->tk_DrawElement) /* 264 */
#endif
#ifndef Tk_PhotoExpand
#define Tk_PhotoExpand \
	(tkStubsPtr->tk_PhotoExpand) /* 265 */
#endif
#ifndef Tk_PhotoPutBlock
#define Tk_PhotoPutBlock \
	(tkStubsPtr->tk_PhotoPutBlock) /* 266 */
#endif
#ifndef Tk_PhotoPutZoomedBlock
#define Tk_PhotoPutZoomedBlock \
	(tkStubsPtr->tk_PhotoPutZoomedBlock) /* 267 */
#endif
#ifndef Tk_PhotoSetSize
#define Tk_PhotoSetSize \
	(tkStubsPtr->tk_PhotoSetSize) /* 268 */
#endif
#ifndef Tk_GetUserInactiveTime
#define Tk_GetUserInactiveTime \
	(tkStubsPtr->tk_GetUserInactiveTime) /* 269 */
#endif
#ifndef Tk_ResetUserInactiveTime
#define Tk_ResetUserInactiveTime \
	(tkStubsPtr->tk_ResetUserInactiveTime) /* 270 */
#endif
#ifndef Tk_Interp
#define Tk_Interp \
	(tkStubsPtr->tk_Interp) /* 271 */
#endif
#ifndef Tk_CreateOldImageType
#define Tk_CreateOldImageType \
	(tkStubsPtr->tk_CreateOldImageType) /* 272 */
#endif
#ifndef Tk_CreateOldPhotoImageFormat
#define Tk_CreateOldPhotoImageFormat \
	(tkStubsPtr->tk_CreateOldPhotoImageFormat) /* 273 */
#endif

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKDECLS */

                                                                                                                    tkIntXlibDecls.h                                                                                    0100644 0001750 0001750 00000217774 11442001432 033371  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers                                                                        /*
 * tkIntXlibDecls.h --
 *
 *	This file contains the declarations for all platform dependent
 *	unsupported functions that are exported by the Tk library.  These
 *	interfaces are not guaranteed to remain the same between
 *	versions.  Use at your own risk.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKINTXLIBDECLS
#define _TKINTXLIBDECLS

#include "X11/Xutil.h"

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tkInt.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef XSetDashes_TCL_DECLARED
#define XSetDashes_TCL_DECLARED
/* 0 */
EXTERN void		XSetDashes(Display *display, GC gc, int dash_offset,
				_Xconst char *dash_list, int n);
#endif
#ifndef XGetModifierMapping_TCL_DECLARED
#define XGetModifierMapping_TCL_DECLARED
/* 1 */
EXTERN XModifierKeymap * XGetModifierMapping(Display *d);
#endif
#ifndef XCreateImage_TCL_DECLARED
#define XCreateImage_TCL_DECLARED
/* 2 */
EXTERN XImage *		XCreateImage(Display *d, Visual *v, unsigned int ui1,
				int i1, int i2, char *cp, unsigned int ui2,
				unsigned int ui3, int i3, int i4);
#endif
#ifndef XGetImage_TCL_DECLARED
#define XGetImage_TCL_DECLARED
/* 3 */
EXTERN XImage *		XGetImage(Display *d, Drawable dr, int i1, int i2,
				unsigned int ui1, unsigned int ui2,
				unsigned long ul, int i3);
#endif
#ifndef XGetAtomName_TCL_DECLARED
#define XGetAtomName_TCL_DECLARED
/* 4 */
EXTERN char *		XGetAtomName(Display *d, Atom a);
#endif
#ifndef XKeysymToString_TCL_DECLARED
#define XKeysymToString_TCL_DECLARED
/* 5 */
EXTERN char *		XKeysymToString(KeySym k);
#endif
#ifndef XCreateColormap_TCL_DECLARED
#define XCreateColormap_TCL_DECLARED
/* 6 */
EXTERN Colormap		XCreateColormap(Display *d, Window w, Visual *v,
				int i);
#endif
#ifndef XCreatePixmapCursor_TCL_DECLARED
#define XCreatePixmapCursor_TCL_DECLARED
/* 7 */
EXTERN Cursor		XCreatePixmapCursor(Display *d, Pixmap p1, Pixmap p2,
				XColor *x1, XColor *x2, unsigned int ui1,
				unsigned int ui2);
#endif
#ifndef XCreateGlyphCursor_TCL_DECLARED
#define XCreateGlyphCursor_TCL_DECLARED
/* 8 */
EXTERN Cursor		XCreateGlyphCursor(Display *d, Font f1, Font f2,
				unsigned int ui1, unsigned int ui2,
				XColor *x1, XColor *x2);
#endif
#ifndef XGContextFromGC_TCL_DECLARED
#define XGContextFromGC_TCL_DECLARED
/* 9 */
EXTERN GContext		XGContextFromGC(GC g);
#endif
#ifndef XListHosts_TCL_DECLARED
#define XListHosts_TCL_DECLARED
/* 10 */
EXTERN XHostAddress *	XListHosts(Display *d, int *i, Bool *b);
#endif
#ifndef XKeycodeToKeysym_TCL_DECLARED
#define XKeycodeToKeysym_TCL_DECLARED
/* 11 */
EXTERN KeySym		XKeycodeToKeysym(Display *d, unsigned int k, int i);
#endif
#ifndef XStringToKeysym_TCL_DECLARED
#define XStringToKeysym_TCL_DECLARED
/* 12 */
EXTERN KeySym		XStringToKeysym(_Xconst char *c);
#endif
#ifndef XRootWindow_TCL_DECLARED
#define XRootWindow_TCL_DECLARED
/* 13 */
EXTERN Window		XRootWindow(Display *d, int i);
#endif
#ifndef XSetErrorHandler_TCL_DECLARED
#define XSetErrorHandler_TCL_DECLARED
/* 14 */
EXTERN XErrorHandler	XSetErrorHandler(XErrorHandler x);
#endif
#ifndef XIconifyWindow_TCL_DECLARED
#define XIconifyWindow_TCL_DECLARED
/* 15 */
EXTERN Status		XIconifyWindow(Display *d, Window w, int i);
#endif
#ifndef XWithdrawWindow_TCL_DECLARED
#define XWithdrawWindow_TCL_DECLARED
/* 16 */
EXTERN Status		XWithdrawWindow(Display *d, Window w, int i);
#endif
#ifndef XGetWMColormapWindows_TCL_DECLARED
#define XGetWMColormapWindows_TCL_DECLARED
/* 17 */
EXTERN Status		XGetWMColormapWindows(Display *d, Window w,
				Window **wpp, int *ip);
#endif
#ifndef XAllocColor_TCL_DECLARED
#define XAllocColor_TCL_DECLARED
/* 18 */
EXTERN Status		XAllocColor(Display *d, Colormap c, XColor *xp);
#endif
#ifndef XBell_TCL_DECLARED
#define XBell_TCL_DECLARED
/* 19 */
EXTERN void		XBell(Display *d, int i);
#endif
#ifndef XChangeProperty_TCL_DECLARED
#define XChangeProperty_TCL_DECLARED
/* 20 */
EXTERN void		XChangeProperty(Display *d, Window w, Atom a1,
				Atom a2, int i1, int i2,
				_Xconst unsigned char *c, int i3);
#endif
#ifndef XChangeWindowAttributes_TCL_DECLARED
#define XChangeWindowAttributes_TCL_DECLARED
/* 21 */
EXTERN void		XChangeWindowAttributes(Display *d, Window w,
				unsigned long ul, XSetWindowAttributes *x);
#endif
#ifndef XClearWindow_TCL_DECLARED
#define XClearWindow_TCL_DECLARED
/* 22 */
EXTERN void		XClearWindow(Display *d, Window w);
#endif
#ifndef XConfigureWindow_TCL_DECLARED
#define XConfigureWindow_TCL_DECLARED
/* 23 */
EXTERN void		XConfigureWindow(Display *d, Window w,
				unsigned int i, XWindowChanges *x);
#endif
#ifndef XCopyArea_TCL_DECLARED
#define XCopyArea_TCL_DECLARED
/* 24 */
EXTERN void		XCopyArea(Display *d, Drawable dr1, Drawable dr2,
				GC g, int i1, int i2, unsigned int ui1,
				unsigned int ui2, int i3, int i4);
#endif
#ifndef XCopyPlane_TCL_DECLARED
#define XCopyPlane_TCL_DECLARED
/* 25 */
EXTERN void		XCopyPlane(Display *d, Drawable dr1, Drawable dr2,
				GC g, int i1, int i2, unsigned int ui1,
				unsigned int ui2, int i3, int i4,
				unsigned long ul);
#endif
#ifndef XCreateBitmapFromData_TCL_DECLARED
#define XCreateBitmapFromData_TCL_DECLARED
/* 26 */
EXTERN Pixmap		XCreateBitmapFromData(Display *display, Drawable d,
				_Xconst char *data, unsigned int width,
				unsigned int height);
#endif
#ifndef XDefineCursor_TCL_DECLARED
#define XDefineCursor_TCL_DECLARED
/* 27 */
EXTERN void		XDefineCursor(Display *d, Window w, Cursor c);
#endif
#ifndef XDeleteProperty_TCL_DECLARED
#define XDeleteProperty_TCL_DECLARED
/* 28 */
EXTERN void		XDeleteProperty(Display *d, Window w, Atom a);
#endif
#ifndef XDestroyWindow_TCL_DECLARED
#define XDestroyWindow_TCL_DECLARED
/* 29 */
EXTERN void		XDestroyWindow(Display *d, Window w);
#endif
#ifndef XDrawArc_TCL_DECLARED
#define XDrawArc_TCL_DECLARED
/* 30 */
EXTERN void		XDrawArc(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2,
				int i3, int i4);
#endif
#ifndef XDrawLines_TCL_DECLARED
#define XDrawLines_TCL_DECLARED
/* 31 */
EXTERN void		XDrawLines(Display *d, Drawable dr, GC g, XPoint *x,
				int i1, int i2);
#endif
#ifndef XDrawRectangle_TCL_DECLARED
#define XDrawRectangle_TCL_DECLARED
/* 32 */
EXTERN void		XDrawRectangle(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2);
#endif
#ifndef XFillArc_TCL_DECLARED
#define XFillArc_TCL_DECLARED
/* 33 */
EXTERN void		XFillArc(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2,
				int i3, int i4);
#endif
#ifndef XFillPolygon_TCL_DECLARED
#define XFillPolygon_TCL_DECLARED
/* 34 */
EXTERN void		XFillPolygon(Display *d, Drawable dr, GC g,
				XPoint *x, int i1, int i2, int i3);
#endif
#ifndef XFillRectangles_TCL_DECLARED
#define XFillRectangles_TCL_DECLARED
/* 35 */
EXTERN void		XFillRectangles(Display *d, Drawable dr, GC g,
				XRectangle *x, int i);
#endif
#ifndef XForceScreenSaver_TCL_DECLARED
#define XForceScreenSaver_TCL_DECLARED
/* 36 */
EXTERN void		XForceScreenSaver(Display *d, int i);
#endif
#ifndef XFreeColormap_TCL_DECLARED
#define XFreeColormap_TCL_DECLARED
/* 37 */
EXTERN void		XFreeColormap(Display *d, Colormap c);
#endif
#ifndef XFreeColors_TCL_DECLARED
#define XFreeColors_TCL_DECLARED
/* 38 */
EXTERN void		XFreeColors(Display *d, Colormap c,
				unsigned long *ulp, int i, unsigned long ul);
#endif
#ifndef XFreeCursor_TCL_DECLARED
#define XFreeCursor_TCL_DECLARED
/* 39 */
EXTERN void		XFreeCursor(Display *d, Cursor c);
#endif
#ifndef XFreeModifiermap_TCL_DECLARED
#define XFreeModifiermap_TCL_DECLARED
/* 40 */
EXTERN void		XFreeModifiermap(XModifierKeymap *x);
#endif
#ifndef XGetGeometry_TCL_DECLARED
#define XGetGeometry_TCL_DECLARED
/* 41 */
EXTERN Status		XGetGeometry(Display *d, Drawable dr, Window *w,
				int *i1, int *i2, unsigned int *ui1,
				unsigned int *ui2, unsigned int *ui3,
				unsigned int *ui4);
#endif
#ifndef XGetInputFocus_TCL_DECLARED
#define XGetInputFocus_TCL_DECLARED
/* 42 */
EXTERN void		XGetInputFocus(Display *d, Window *w, int *i);
#endif
#ifndef XGetWindowProperty_TCL_DECLARED
#define XGetWindowProperty_TCL_DECLARED
/* 43 */
EXTERN int		XGetWindowProperty(Display *d, Window w, Atom a1,
				long l1, long l2, Bool b, Atom a2, Atom *ap,
				int *ip, unsigned long *ulp1,
				unsigned long *ulp2, unsigned char **cpp);
#endif
#ifndef XGetWindowAttributes_TCL_DECLARED
#define XGetWindowAttributes_TCL_DECLARED
/* 44 */
EXTERN Status		XGetWindowAttributes(Display *d, Window w,
				XWindowAttributes *x);
#endif
#ifndef XGrabKeyboard_TCL_DECLARED
#define XGrabKeyboard_TCL_DECLARED
/* 45 */
EXTERN int		XGrabKeyboard(Display *d, Window w, Bool b, int i1,
				int i2, Time t);
#endif
#ifndef XGrabPointer_TCL_DECLARED
#define XGrabPointer_TCL_DECLARED
/* 46 */
EXTERN int		XGrabPointer(Display *d, Window w1, Bool b,
				unsigned int ui, int i1, int i2, Window w2,
				Cursor c, Time t);
#endif
#ifndef XKeysymToKeycode_TCL_DECLARED
#define XKeysymToKeycode_TCL_DECLARED
/* 47 */
EXTERN KeyCode		XKeysymToKeycode(Display *d, KeySym k);
#endif
#ifndef XLookupColor_TCL_DECLARED
#define XLookupColor_TCL_DECLARED
/* 48 */
EXTERN Status		XLookupColor(Display *d, Colormap c1,
				_Xconst char *c2, XColor *x1, XColor *x2);
#endif
#ifndef XMapWindow_TCL_DECLARED
#define XMapWindow_TCL_DECLARED
/* 49 */
EXTERN void		XMapWindow(Display *d, Window w);
#endif
#ifndef XMoveResizeWindow_TCL_DECLARED
#define XMoveResizeWindow_TCL_DECLARED
/* 50 */
EXTERN void		XMoveResizeWindow(Display *d, Window w, int i1,
				int i2, unsigned int ui1, unsigned int ui2);
#endif
#ifndef XMoveWindow_TCL_DECLARED
#define XMoveWindow_TCL_DECLARED
/* 51 */
EXTERN void		XMoveWindow(Display *d, Window w, int i1, int i2);
#endif
#ifndef XNextEvent_TCL_DECLARED
#define XNextEvent_TCL_DECLARED
/* 52 */
EXTERN void		XNextEvent(Display *d, XEvent *x);
#endif
#ifndef XPutBackEvent_TCL_DECLARED
#define XPutBackEvent_TCL_DECLARED
/* 53 */
EXTERN void		XPutBackEvent(Display *d, XEvent *x);
#endif
#ifndef XQueryColors_TCL_DECLARED
#define XQueryColors_TCL_DECLARED
/* 54 */
EXTERN void		XQueryColors(Display *d, Colormap c, XColor *x,
				int i);
#endif
#ifndef XQueryPointer_TCL_DECLARED
#define XQueryPointer_TCL_DECLARED
/* 55 */
EXTERN Bool		XQueryPointer(Display *d, Window w1, Window *w2,
				Window *w3, int *i1, int *i2, int *i3,
				int *i4, unsigned int *ui);
#endif
#ifndef XQueryTree_TCL_DECLARED
#define XQueryTree_TCL_DECLARED
/* 56 */
EXTERN Status		XQueryTree(Display *d, Window w1, Window *w2,
				Window *w3, Window **w4, unsigned int *ui);
#endif
#ifndef XRaiseWindow_TCL_DECLARED
#define XRaiseWindow_TCL_DECLARED
/* 57 */
EXTERN void		XRaiseWindow(Display *d, Window w);
#endif
#ifndef XRefreshKeyboardMapping_TCL_DECLARED
#define XRefreshKeyboardMapping_TCL_DECLARED
/* 58 */
EXTERN void		XRefreshKeyboardMapping(XMappingEvent *x);
#endif
#ifndef XResizeWindow_TCL_DECLARED
#define XResizeWindow_TCL_DECLARED
/* 59 */
EXTERN void		XResizeWindow(Display *d, Window w, unsigned int ui1,
				unsigned int ui2);
#endif
#ifndef XSelectInput_TCL_DECLARED
#define XSelectInput_TCL_DECLARED
/* 60 */
EXTERN void		XSelectInput(Display *d, Window w, long l);
#endif
#ifndef XSendEvent_TCL_DECLARED
#define XSendEvent_TCL_DECLARED
/* 61 */
EXTERN Status		XSendEvent(Display *d, Window w, Bool b, long l,
				XEvent *x);
#endif
#ifndef XSetCommand_TCL_DECLARED
#define XSetCommand_TCL_DECLARED
/* 62 */
EXTERN void		XSetCommand(Display *d, Window w, CONST char **c,
				int i);
#endif
#ifndef XSetIconName_TCL_DECLARED
#define XSetIconName_TCL_DECLARED
/* 63 */
EXTERN void		XSetIconName(Display *d, Window w, _Xconst char *c);
#endif
#ifndef XSetInputFocus_TCL_DECLARED
#define XSetInputFocus_TCL_DECLARED
/* 64 */
EXTERN void		XSetInputFocus(Display *d, Window w, int i, Time t);
#endif
#ifndef XSetSelectionOwner_TCL_DECLARED
#define XSetSelectionOwner_TCL_DECLARED
/* 65 */
EXTERN void		XSetSelectionOwner(Display *d, Atom a, Window w,
				Time t);
#endif
#ifndef XSetWindowBackground_TCL_DECLARED
#define XSetWindowBackground_TCL_DECLARED
/* 66 */
EXTERN void		XSetWindowBackground(Display *d, Window w,
				unsigned long ul);
#endif
#ifndef XSetWindowBackgroundPixmap_TCL_DECLARED
#define XSetWindowBackgroundPixmap_TCL_DECLARED
/* 67 */
EXTERN void		XSetWindowBackgroundPixmap(Display *d, Window w,
				Pixmap p);
#endif
#ifndef XSetWindowBorder_TCL_DECLARED
#define XSetWindowBorder_TCL_DECLARED
/* 68 */
EXTERN void		XSetWindowBorder(Display *d, Window w,
				unsigned long ul);
#endif
#ifndef XSetWindowBorderPixmap_TCL_DECLARED
#define XSetWindowBorderPixmap_TCL_DECLARED
/* 69 */
EXTERN void		XSetWindowBorderPixmap(Display *d, Window w,
				Pixmap p);
#endif
#ifndef XSetWindowBorderWidth_TCL_DECLARED
#define XSetWindowBorderWidth_TCL_DECLARED
/* 70 */
EXTERN void		XSetWindowBorderWidth(Display *d, Window w,
				unsigned int ui);
#endif
#ifndef XSetWindowColormap_TCL_DECLARED
#define XSetWindowColormap_TCL_DECLARED
/* 71 */
EXTERN void		XSetWindowColormap(Display *d, Window w, Colormap c);
#endif
#ifndef XTranslateCoordinates_TCL_DECLARED
#define XTranslateCoordinates_TCL_DECLARED
/* 72 */
EXTERN Bool		XTranslateCoordinates(Display *d, Window w1,
				Window w2, int i1, int i2, int *i3, int *i4,
				Window *w3);
#endif
#ifndef XUngrabKeyboard_TCL_DECLARED
#define XUngrabKeyboard_TCL_DECLARED
/* 73 */
EXTERN void		XUngrabKeyboard(Display *d, Time t);
#endif
#ifndef XUngrabPointer_TCL_DECLARED
#define XUngrabPointer_TCL_DECLARED
/* 74 */
EXTERN void		XUngrabPointer(Display *d, Time t);
#endif
#ifndef XUnmapWindow_TCL_DECLARED
#define XUnmapWindow_TCL_DECLARED
/* 75 */
EXTERN void		XUnmapWindow(Display *d, Window w);
#endif
#ifndef XWindowEvent_TCL_DECLARED
#define XWindowEvent_TCL_DECLARED
/* 76 */
EXTERN void		XWindowEvent(Display *d, Window w, long l, XEvent *x);
#endif
#ifndef XDestroyIC_TCL_DECLARED
#define XDestroyIC_TCL_DECLARED
/* 77 */
EXTERN void		XDestroyIC(XIC x);
#endif
#ifndef XFilterEvent_TCL_DECLARED
#define XFilterEvent_TCL_DECLARED
/* 78 */
EXTERN Bool		XFilterEvent(XEvent *x, Window w);
#endif
#ifndef XmbLookupString_TCL_DECLARED
#define XmbLookupString_TCL_DECLARED
/* 79 */
EXTERN int		XmbLookupString(XIC xi, XKeyPressedEvent *xk,
				char *c, int i, KeySym *k, Status *s);
#endif
#ifndef TkPutImage_TCL_DECLARED
#define TkPutImage_TCL_DECLARED
/* 80 */
EXTERN void		TkPutImage(unsigned long *colors, int ncolors,
				Display *display, Drawable d, GC gc,
				XImage *image, int src_x, int src_y,
				int dest_x, int dest_y, unsigned int width,
				unsigned int height);
#endif
/* Slot 81 is reserved */
#ifndef XParseColor_TCL_DECLARED
#define XParseColor_TCL_DECLARED
/* 82 */
EXTERN Status		XParseColor(Display *display, Colormap map,
				_Xconst char *spec, XColor *colorPtr);
#endif
#ifndef XCreateGC_TCL_DECLARED
#define XCreateGC_TCL_DECLARED
/* 83 */
EXTERN GC		XCreateGC(Display *display, Drawable d,
				unsigned long valuemask, XGCValues *values);
#endif
#ifndef XFreeGC_TCL_DECLARED
#define XFreeGC_TCL_DECLARED
/* 84 */
EXTERN void		XFreeGC(Display *display, GC gc);
#endif
#ifndef XInternAtom_TCL_DECLARED
#define XInternAtom_TCL_DECLARED
/* 85 */
EXTERN Atom		XInternAtom(Display *display,
				_Xconst char *atom_name, Bool only_if_exists);
#endif
#ifndef XSetBackground_TCL_DECLARED
#define XSetBackground_TCL_DECLARED
/* 86 */
EXTERN void		XSetBackground(Display *display, GC gc,
				unsigned long foreground);
#endif
#ifndef XSetForeground_TCL_DECLARED
#define XSetForeground_TCL_DECLARED
/* 87 */
EXTERN void		XSetForeground(Display *display, GC gc,
				unsigned long foreground);
#endif
#ifndef XSetClipMask_TCL_DECLARED
#define XSetClipMask_TCL_DECLARED
/* 88 */
EXTERN void		XSetClipMask(Display *display, GC gc, Pixmap pixmap);
#endif
#ifndef XSetClipOrigin_TCL_DECLARED
#define XSetClipOrigin_TCL_DECLARED
/* 89 */
EXTERN void		XSetClipOrigin(Display *display, GC gc,
				int clip_x_origin, int clip_y_origin);
#endif
#ifndef XSetTSOrigin_TCL_DECLARED
#define XSetTSOrigin_TCL_DECLARED
/* 90 */
EXTERN void		XSetTSOrigin(Display *display, GC gc,
				int ts_x_origin, int ts_y_origin);
#endif
#ifndef XChangeGC_TCL_DECLARED
#define XChangeGC_TCL_DECLARED
/* 91 */
EXTERN void		XChangeGC(Display *d, GC gc, unsigned long mask,
				XGCValues *values);
#endif
#ifndef XSetFont_TCL_DECLARED
#define XSetFont_TCL_DECLARED
/* 92 */
EXTERN void		XSetFont(Display *display, GC gc, Font font);
#endif
#ifndef XSetArcMode_TCL_DECLARED
#define XSetArcMode_TCL_DECLARED
/* 93 */
EXTERN void		XSetArcMode(Display *display, GC gc, int arc_mode);
#endif
#ifndef XSetStipple_TCL_DECLARED
#define XSetStipple_TCL_DECLARED
/* 94 */
EXTERN void		XSetStipple(Display *display, GC gc, Pixmap stipple);
#endif
#ifndef XSetFillRule_TCL_DECLARED
#define XSetFillRule_TCL_DECLARED
/* 95 */
EXTERN void		XSetFillRule(Display *display, GC gc, int fill_rule);
#endif
#ifndef XSetFillStyle_TCL_DECLARED
#define XSetFillStyle_TCL_DECLARED
/* 96 */
EXTERN void		XSetFillStyle(Display *display, GC gc,
				int fill_style);
#endif
#ifndef XSetFunction_TCL_DECLARED
#define XSetFunction_TCL_DECLARED
/* 97 */
EXTERN void		XSetFunction(Display *display, GC gc, int function);
#endif
#ifndef XSetLineAttributes_TCL_DECLARED
#define XSetLineAttributes_TCL_DECLARED
/* 98 */
EXTERN void		XSetLineAttributes(Display *display, GC gc,
				unsigned int line_width, int line_style,
				int cap_style, int join_style);
#endif
#ifndef _XInitImageFuncPtrs_TCL_DECLARED
#define _XInitImageFuncPtrs_TCL_DECLARED
/* 99 */
EXTERN int		_XInitImageFuncPtrs(XImage *image);
#endif
#ifndef XCreateIC_TCL_DECLARED
#define XCreateIC_TCL_DECLARED
/* 100 */
EXTERN XIC		XCreateIC(void);
#endif
#ifndef XGetVisualInfo_TCL_DECLARED
#define XGetVisualInfo_TCL_DECLARED
/* 101 */
EXTERN XVisualInfo *	XGetVisualInfo(Display *display, long vinfo_mask,
				XVisualInfo *vinfo_template,
				int *nitems_return);
#endif
#ifndef XSetWMClientMachine_TCL_DECLARED
#define XSetWMClientMachine_TCL_DECLARED
/* 102 */
EXTERN void		XSetWMClientMachine(Display *display, Window w,
				XTextProperty *text_prop);
#endif
#ifndef XStringListToTextProperty_TCL_DECLARED
#define XStringListToTextProperty_TCL_DECLARED
/* 103 */
EXTERN Status		XStringListToTextProperty(char **list, int count,
				XTextProperty *text_prop_return);
#endif
#ifndef XDrawLine_TCL_DECLARED
#define XDrawLine_TCL_DECLARED
/* 104 */
EXTERN void		XDrawLine(Display *d, Drawable dr, GC g, int x1,
				int y1, int x2, int y2);
#endif
#ifndef XWarpPointer_TCL_DECLARED
#define XWarpPointer_TCL_DECLARED
/* 105 */
EXTERN void		XWarpPointer(Display *d, Window s, Window dw, int sx,
				int sy, unsigned int sw, unsigned int sh,
				int dx, int dy);
#endif
#ifndef XFillRectangle_TCL_DECLARED
#define XFillRectangle_TCL_DECLARED
/* 106 */
EXTERN void		XFillRectangle(Display *display, Drawable d, GC gc,
				int x, int y, unsigned int width,
				unsigned int height);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef XSetDashes_TCL_DECLARED
#define XSetDashes_TCL_DECLARED
/* 0 */
EXTERN void		XSetDashes(Display *display, GC gc, int dash_offset,
				_Xconst char *dash_list, int n);
#endif
#ifndef XGetModifierMapping_TCL_DECLARED
#define XGetModifierMapping_TCL_DECLARED
/* 1 */
EXTERN XModifierKeymap * XGetModifierMapping(Display *d);
#endif
#ifndef XCreateImage_TCL_DECLARED
#define XCreateImage_TCL_DECLARED
/* 2 */
EXTERN XImage *		XCreateImage(Display *d, Visual *v, unsigned int ui1,
				int i1, int i2, char *cp, unsigned int ui2,
				unsigned int ui3, int i3, int i4);
#endif
#ifndef XGetImage_TCL_DECLARED
#define XGetImage_TCL_DECLARED
/* 3 */
EXTERN XImage *		XGetImage(Display *d, Drawable dr, int i1, int i2,
				unsigned int ui1, unsigned int ui2,
				unsigned long ul, int i3);
#endif
#ifndef XGetAtomName_TCL_DECLARED
#define XGetAtomName_TCL_DECLARED
/* 4 */
EXTERN char *		XGetAtomName(Display *d, Atom a);
#endif
#ifndef XKeysymToString_TCL_DECLARED
#define XKeysymToString_TCL_DECLARED
/* 5 */
EXTERN char *		XKeysymToString(KeySym k);
#endif
#ifndef XCreateColormap_TCL_DECLARED
#define XCreateColormap_TCL_DECLARED
/* 6 */
EXTERN Colormap		XCreateColormap(Display *d, Window w, Visual *v,
				int i);
#endif
#ifndef XGContextFromGC_TCL_DECLARED
#define XGContextFromGC_TCL_DECLARED
/* 7 */
EXTERN GContext		XGContextFromGC(GC g);
#endif
#ifndef XKeycodeToKeysym_TCL_DECLARED
#define XKeycodeToKeysym_TCL_DECLARED
/* 8 */
EXTERN KeySym		XKeycodeToKeysym(Display *d, KeyCode k, int i);
#endif
#ifndef XStringToKeysym_TCL_DECLARED
#define XStringToKeysym_TCL_DECLARED
/* 9 */
EXTERN KeySym		XStringToKeysym(_Xconst char *c);
#endif
#ifndef XRootWindow_TCL_DECLARED
#define XRootWindow_TCL_DECLARED
/* 10 */
EXTERN Window		XRootWindow(Display *d, int i);
#endif
#ifndef XSetErrorHandler_TCL_DECLARED
#define XSetErrorHandler_TCL_DECLARED
/* 11 */
EXTERN XErrorHandler	XSetErrorHandler(XErrorHandler x);
#endif
#ifndef XAllocColor_TCL_DECLARED
#define XAllocColor_TCL_DECLARED
/* 12 */
EXTERN Status		XAllocColor(Display *d, Colormap c, XColor *xp);
#endif
#ifndef XBell_TCL_DECLARED
#define XBell_TCL_DECLARED
/* 13 */
EXTERN void		XBell(Display *d, int i);
#endif
#ifndef XChangeProperty_TCL_DECLARED
#define XChangeProperty_TCL_DECLARED
/* 14 */
EXTERN void		XChangeProperty(Display *d, Window w, Atom a1,
				Atom a2, int i1, int i2,
				_Xconst unsigned char *c, int i3);
#endif
#ifndef XChangeWindowAttributes_TCL_DECLARED
#define XChangeWindowAttributes_TCL_DECLARED
/* 15 */
EXTERN void		XChangeWindowAttributes(Display *d, Window w,
				unsigned long ul, XSetWindowAttributes *x);
#endif
#ifndef XConfigureWindow_TCL_DECLARED
#define XConfigureWindow_TCL_DECLARED
/* 16 */
EXTERN void		XConfigureWindow(Display *d, Window w,
				unsigned int i, XWindowChanges *x);
#endif
#ifndef XCopyArea_TCL_DECLARED
#define XCopyArea_TCL_DECLARED
/* 17 */
EXTERN void		XCopyArea(Display *d, Drawable dr1, Drawable dr2,
				GC g, int i1, int i2, unsigned int ui1,
				unsigned int ui2, int i3, int i4);
#endif
#ifndef XCopyPlane_TCL_DECLARED
#define XCopyPlane_TCL_DECLARED
/* 18 */
EXTERN void		XCopyPlane(Display *d, Drawable dr1, Drawable dr2,
				GC g, int i1, int i2, unsigned int ui1,
				unsigned int ui2, int i3, int i4,
				unsigned long ul);
#endif
#ifndef XCreateBitmapFromData_TCL_DECLARED
#define XCreateBitmapFromData_TCL_DECLARED
/* 19 */
EXTERN Pixmap		XCreateBitmapFromData(Display *display, Drawable d,
				_Xconst char *data, unsigned int width,
				unsigned int height);
#endif
#ifndef XDefineCursor_TCL_DECLARED
#define XDefineCursor_TCL_DECLARED
/* 20 */
EXTERN void		XDefineCursor(Display *d, Window w, Cursor c);
#endif
#ifndef XDestroyWindow_TCL_DECLARED
#define XDestroyWindow_TCL_DECLARED
/* 21 */
EXTERN void		XDestroyWindow(Display *d, Window w);
#endif
#ifndef XDrawArc_TCL_DECLARED
#define XDrawArc_TCL_DECLARED
/* 22 */
EXTERN void		XDrawArc(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2,
				int i3, int i4);
#endif
#ifndef XDrawLines_TCL_DECLARED
#define XDrawLines_TCL_DECLARED
/* 23 */
EXTERN void		XDrawLines(Display *d, Drawable dr, GC g, XPoint *x,
				int i1, int i2);
#endif
#ifndef XDrawRectangle_TCL_DECLARED
#define XDrawRectangle_TCL_DECLARED
/* 24 */
EXTERN void		XDrawRectangle(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2);
#endif
#ifndef XFillArc_TCL_DECLARED
#define XFillArc_TCL_DECLARED
/* 25 */
EXTERN void		XFillArc(Display *d, Drawable dr, GC g, int i1,
				int i2, unsigned int ui1, unsigned int ui2,
				int i3, int i4);
#endif
#ifndef XFillPolygon_TCL_DECLARED
#define XFillPolygon_TCL_DECLARED
/* 26 */
EXTERN void		XFillPolygon(Display *d, Drawable dr, GC g,
				XPoint *x, int i1, int i2, int i3);
#endif
#ifndef XFillRectangles_TCL_DECLARED
#define XFillRectangles_TCL_DECLARED
/* 27 */
EXTERN void		XFillRectangles(Display *d, Drawable dr, GC g,
				XRectangle *x, int i);
#endif
#ifndef XFreeColormap_TCL_DECLARED
#define XFreeColormap_TCL_DECLARED
/* 28 */
EXTERN void		XFreeColormap(Display *d, Colormap c);
#endif
#ifndef XFreeColors_TCL_DECLARED
#define XFreeColors_TCL_DECLARED
/* 29 */
EXTERN void		XFreeColors(Display *d, Colormap c,
				unsigned long *ulp, int i, unsigned long ul);
#endif
#ifndef XFreeModifiermap_TCL_DECLARED
#define XFreeModifiermap_TCL_DECLARED
/* 30 */
EXTERN void		XFreeModifiermap(XModifierKeymap *x);
#endif
#ifndef XGetGeometry_TCL_DECLARED
#define XGetGeometry_TCL_DECLARED
/* 31 */
EXTERN Status		XGetGeometry(Display *d, Drawable dr, Window *w,
				int *i1, int *i2, unsigned int *ui1,
				unsigned int *ui2, unsigned int *ui3,
				unsigned int *ui4);
#endif
#ifndef XGetWindowProperty_TCL_DECLARED
#define XGetWindowProperty_TCL_DECLARED
/* 32 */
EXTERN int		XGetWindowProperty(Display *d, Window w, Atom a1,
				long l1, long l2, Bool b, Atom a2, Atom *ap,
				int *ip, unsigned long *ulp1,
				unsigned long *ulp2, unsigned char **cpp);
#endif
#ifndef XGrabKeyboard_TCL_DECLARED
#define XGrabKeyboard_TCL_DECLARED
/* 33 */
EXTERN int		XGrabKeyboard(Display *d, Window w, Bool b, int i1,
				int i2, Time t);
#endif
#ifndef XGrabPointer_TCL_DECLARED
#define XGrabPointer_TCL_DECLARED
/* 34 */
EXTERN int		XGrabPointer(Display *d, Window w1, Bool b,
				unsigned int ui, int i1, int i2, Window w2,
				Cursor c, Time t);
#endif
#ifndef XKeysymToKeycode_TCL_DECLARED
#define XKeysymToKeycode_TCL_DECLARED
/* 35 */
EXTERN KeyCode		XKeysymToKeycode(Display *d, KeySym k);
#endif
#ifndef XMapWindow_TCL_DECLARED
#define XMapWindow_TCL_DECLARED
/* 36 */
EXTERN void		XMapWindow(Display *d, Window w);
#endif
#ifndef XMoveResizeWindow_TCL_DECLARED
#define XMoveResizeWindow_TCL_DECLARED
/* 37 */
EXTERN void		XMoveResizeWindow(Display *d, Window w, int i1,
				int i2, unsigned int ui1, unsigned int ui2);
#endif
#ifndef XMoveWindow_TCL_DECLARED
#define XMoveWindow_TCL_DECLARED
/* 38 */
EXTERN void		XMoveWindow(Display *d, Window w, int i1, int i2);
#endif
#ifndef XQueryPointer_TCL_DECLARED
#define XQueryPointer_TCL_DECLARED
/* 39 */
EXTERN Bool		XQueryPointer(Display *d, Window w1, Window *w2,
				Window *w3, int *i1, int *i2, int *i3,
				int *i4, unsigned int *ui);
#endif
#ifndef XRaiseWindow_TCL_DECLARED
#define XRaiseWindow_TCL_DECLARED
/* 40 */
EXTERN void		XRaiseWindow(Display *d, Window w);
#endif
#ifndef XRefreshKeyboardMapping_TCL_DECLARED
#define XRefreshKeyboardMapping_TCL_DECLARED
/* 41 */
EXTERN void		XRefreshKeyboardMapping(XMappingEvent *x);
#endif
#ifndef XResizeWindow_TCL_DECLARED
#define XResizeWindow_TCL_DECLARED
/* 42 */
EXTERN void		XResizeWindow(Display *d, Window w, unsigned int ui1,
				unsigned int ui2);
#endif
#ifndef XSelectInput_TCL_DECLARED
#define XSelectInput_TCL_DECLARED
/* 43 */
EXTERN void		XSelectInput(Display *d, Window w, long l);
#endif
#ifndef XSendEvent_TCL_DECLARED
#define XSendEvent_TCL_DECLARED
/* 44 */
EXTERN Status		XSendEvent(Display *d, Window w, Bool b, long l,
				XEvent *x);
#endif
#ifndef XSetIconName_TCL_DECLARED
#define XSetIconName_TCL_DECLARED
/* 45 */
EXTERN void		XSetIconName(Display *d, Window w, _Xconst char *c);
#endif
#ifndef XSetInputFocus_TCL_DECLARED
#define XSetInputFocus_TCL_DECLARED
/* 46 */
EXTERN void		XSetInputFocus(Display *d, Window w, int i, Time t);
#endif
#ifndef XSetSelectionOwner_TCL_DECLARED
#define XSetSelectionOwner_TCL_DECLARED
/* 47 */
EXTERN void		XSetSelectionOwner(Display *d, Atom a, Window w,
				Time t);
#endif
#ifndef XSetWindowBackground_TCL_DECLARED
#define XSetWindowBackground_TCL_DECLARED
/* 48 */
EXTERN void		XSetWindowBackground(Display *d, Window w,
				unsigned long ul);
#endif
#ifndef XSetWindowBackgroundPixmap_TCL_DECLARED
#define XSetWindowBackgroundPixmap_TCL_DECLARED
/* 49 */
EXTERN void		XSetWindowBackgroundPixmap(Display *d, Window w,
				Pixmap p);
#endif
#ifndef XSetWindowBorder_TCL_DECLARED
#define XSetWindowBorder_TCL_DECLARED
/* 50 */
EXTERN void		XSetWindowBorder(Display *d, Window w,
				unsigned long ul);
#endif
#ifndef XSetWindowBorderPixmap_TCL_DECLARED
#define XSetWindowBorderPixmap_TCL_DECLARED
/* 51 */
EXTERN void		XSetWindowBorderPixmap(Display *d, Window w,
				Pixmap p);
#endif
#ifndef XSetWindowBorderWidth_TCL_DECLARED
#define XSetWindowBorderWidth_TCL_DECLARED
/* 52 */
EXTERN void		XSetWindowBorderWidth(Display *d, Window w,
				unsigned int ui);
#endif
#ifndef XSetWindowColormap_TCL_DECLARED
#define XSetWindowColormap_TCL_DECLARED
/* 53 */
EXTERN void		XSetWindowColormap(Display *d, Window w, Colormap c);
#endif
#ifndef XUngrabKeyboard_TCL_DECLARED
#define XUngrabKeyboard_TCL_DECLARED
/* 54 */
EXTERN void		XUngrabKeyboard(Display *d, Time t);
#endif
#ifndef XUngrabPointer_TCL_DECLARED
#define XUngrabPointer_TCL_DECLARED
/* 55 */
EXTERN void		XUngrabPointer(Display *d, Time t);
#endif
#ifndef XUnmapWindow_TCL_DECLARED
#define XUnmapWindow_TCL_DECLARED
/* 56 */
EXTERN void		XUnmapWindow(Display *d, Window w);
#endif
#ifndef TkPutImage_TCL_DECLARED
#define TkPutImage_TCL_DECLARED
/* 57 */
EXTERN void		TkPutImage(unsigned long *colors, int ncolors,
				Display *display, Drawable d, GC gc,
				XImage *image, int src_x, int src_y,
				int dest_x, int dest_y, unsigned int width,
				unsigned int height);
#endif
#ifndef XParseColor_TCL_DECLARED
#define XParseColor_TCL_DECLARED
/* 58 */
EXTERN Status		XParseColor(Display *display, Colormap map,
				_Xconst char *spec, XColor *colorPtr);
#endif
#ifndef XCreateGC_TCL_DECLARED
#define XCreateGC_TCL_DECLARED
/* 59 */
EXTERN GC		XCreateGC(Display *display, Drawable d,
				unsigned long valuemask, XGCValues *values);
#endif
#ifndef XFreeGC_TCL_DECLARED
#define XFreeGC_TCL_DECLARED
/* 60 */
EXTERN void		XFreeGC(Display *display, GC gc);
#endif
#ifndef XInternAtom_TCL_DECLARED
#define XInternAtom_TCL_DECLARED
/* 61 */
EXTERN Atom		XInternAtom(Display *display,
				_Xconst char *atom_name, Bool only_if_exists);
#endif
#ifndef XSetBackground_TCL_DECLARED
#define XSetBackground_TCL_DECLARED
/* 62 */
EXTERN void		XSetBackground(Display *display, GC gc,
				unsigned long foreground);
#endif
#ifndef XSetForeground_TCL_DECLARED
#define XSetForeground_TCL_DECLARED
/* 63 */
EXTERN void		XSetForeground(Display *display, GC gc,
				unsigned long foreground);
#endif
#ifndef XSetClipMask_TCL_DECLARED
#define XSetClipMask_TCL_DECLARED
/* 64 */
EXTERN void		XSetClipMask(Display *display, GC gc, Pixmap pixmap);
#endif
#ifndef XSetClipOrigin_TCL_DECLARED
#define XSetClipOrigin_TCL_DECLARED
/* 65 */
EXTERN void		XSetClipOrigin(Display *display, GC gc,
				int clip_x_origin, int clip_y_origin);
#endif
#ifndef XSetTSOrigin_TCL_DECLARED
#define XSetTSOrigin_TCL_DECLARED
/* 66 */
EXTERN void		XSetTSOrigin(Display *display, GC gc,
				int ts_x_origin, int ts_y_origin);
#endif
#ifndef XChangeGC_TCL_DECLARED
#define XChangeGC_TCL_DECLARED
/* 67 */
EXTERN void		XChangeGC(Display *d, GC gc, unsigned long mask,
				XGCValues *values);
#endif
#ifndef XSetFont_TCL_DECLARED
#define XSetFont_TCL_DECLARED
/* 68 */
EXTERN void		XSetFont(Display *display, GC gc, Font font);
#endif
#ifndef XSetArcMode_TCL_DECLARED
#define XSetArcMode_TCL_DECLARED
/* 69 */
EXTERN void		XSetArcMode(Display *display, GC gc, int arc_mode);
#endif
#ifndef XSetStipple_TCL_DECLARED
#define XSetStipple_TCL_DECLARED
/* 70 */
EXTERN void		XSetStipple(Display *display, GC gc, Pixmap stipple);
#endif
#ifndef XSetFillRule_TCL_DECLARED
#define XSetFillRule_TCL_DECLARED
/* 71 */
EXTERN void		XSetFillRule(Display *display, GC gc, int fill_rule);
#endif
#ifndef XSetFillStyle_TCL_DECLARED
#define XSetFillStyle_TCL_DECLARED
/* 72 */
EXTERN void		XSetFillStyle(Display *display, GC gc,
				int fill_style);
#endif
#ifndef XSetFunction_TCL_DECLARED
#define XSetFunction_TCL_DECLARED
/* 73 */
EXTERN void		XSetFunction(Display *display, GC gc, int function);
#endif
#ifndef XSetLineAttributes_TCL_DECLARED
#define XSetLineAttributes_TCL_DECLARED
/* 74 */
EXTERN void		XSetLineAttributes(Display *display, GC gc,
				unsigned int line_width, int line_style,
				int cap_style, int join_style);
#endif
#ifndef _XInitImageFuncPtrs_TCL_DECLARED
#define _XInitImageFuncPtrs_TCL_DECLARED
/* 75 */
EXTERN int		_XInitImageFuncPtrs(XImage *image);
#endif
#ifndef XCreateIC_TCL_DECLARED
#define XCreateIC_TCL_DECLARED
/* 76 */
EXTERN XIC		XCreateIC(void);
#endif
#ifndef XGetVisualInfo_TCL_DECLARED
#define XGetVisualInfo_TCL_DECLARED
/* 77 */
EXTERN XVisualInfo *	XGetVisualInfo(Display *display, long vinfo_mask,
				XVisualInfo *vinfo_template,
				int *nitems_return);
#endif
#ifndef XSetWMClientMachine_TCL_DECLARED
#define XSetWMClientMachine_TCL_DECLARED
/* 78 */
EXTERN void		XSetWMClientMachine(Display *display, Window w,
				XTextProperty *text_prop);
#endif
#ifndef XStringListToTextProperty_TCL_DECLARED
#define XStringListToTextProperty_TCL_DECLARED
/* 79 */
EXTERN Status		XStringListToTextProperty(char **list, int count,
				XTextProperty *text_prop_return);
#endif
#ifndef XDrawSegments_TCL_DECLARED
#define XDrawSegments_TCL_DECLARED
/* 80 */
EXTERN void		XDrawSegments(Display *display, Drawable d, GC gc,
				XSegment *segments, int nsegments);
#endif
#ifndef XForceScreenSaver_TCL_DECLARED
#define XForceScreenSaver_TCL_DECLARED
/* 81 */
EXTERN void		XForceScreenSaver(Display *display, int mode);
#endif
#ifndef XDrawLine_TCL_DECLARED
#define XDrawLine_TCL_DECLARED
/* 82 */
EXTERN void		XDrawLine(Display *d, Drawable dr, GC g, int x1,
				int y1, int x2, int y2);
#endif
#ifndef XFillRectangle_TCL_DECLARED
#define XFillRectangle_TCL_DECLARED
/* 83 */
EXTERN void		XFillRectangle(Display *display, Drawable d, GC gc,
				int x, int y, unsigned int width,
				unsigned int height);
#endif
#ifndef XClearWindow_TCL_DECLARED
#define XClearWindow_TCL_DECLARED
/* 84 */
EXTERN void		XClearWindow(Display *d, Window w);
#endif
#ifndef XDrawPoint_TCL_DECLARED
#define XDrawPoint_TCL_DECLARED
/* 85 */
EXTERN void		XDrawPoint(Display *display, Drawable d, GC gc,
				int x, int y);
#endif
#ifndef XDrawPoints_TCL_DECLARED
#define XDrawPoints_TCL_DECLARED
/* 86 */
EXTERN void		XDrawPoints(Display *display, Drawable d, GC gc,
				XPoint *points, int npoints, int mode);
#endif
#ifndef XWarpPointer_TCL_DECLARED
#define XWarpPointer_TCL_DECLARED
/* 87 */
EXTERN void		XWarpPointer(Display *display, Window src_w,
				Window dest_w, int src_x, int src_y,
				unsigned int src_width,
				unsigned int src_height, int dest_x,
				int dest_y);
#endif
#ifndef XQueryColor_TCL_DECLARED
#define XQueryColor_TCL_DECLARED
/* 88 */
EXTERN void		XQueryColor(Display *display, Colormap colormap,
				XColor *def_in_out);
#endif
#ifndef XQueryColors_TCL_DECLARED
#define XQueryColors_TCL_DECLARED
/* 89 */
EXTERN void		XQueryColors(Display *display, Colormap colormap,
				XColor *defs_in_out, int ncolors);
#endif
#ifndef XQueryTree_TCL_DECLARED
#define XQueryTree_TCL_DECLARED
/* 90 */
EXTERN Status		XQueryTree(Display *d, Window w1, Window *w2,
				Window *w3, Window **w4, unsigned int *ui);
#endif
#ifndef XSync_TCL_DECLARED
#define XSync_TCL_DECLARED
/* 91 */
EXTERN int		XSync(Display *display, Bool flag);
#endif
#endif /* AQUA */

typedef struct TkIntXlibStubs {
    int magic;
    struct TkIntXlibStubHooks *hooks;

#ifdef __WIN32__ /* WIN */
    void (*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n); /* 0 */
    XModifierKeymap * (*xGetModifierMapping) (Display *d); /* 1 */
    XImage * (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4); /* 2 */
    XImage * (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3); /* 3 */
    char * (*xGetAtomName) (Display *d, Atom a); /* 4 */
    char * (*xKeysymToString) (KeySym k); /* 5 */
    Colormap (*xCreateColormap) (Display *d, Window w, Visual *v, int i); /* 6 */
    Cursor (*xCreatePixmapCursor) (Display *d, Pixmap p1, Pixmap p2, XColor *x1, XColor *x2, unsigned int ui1, unsigned int ui2); /* 7 */
    Cursor (*xCreateGlyphCursor) (Display *d, Font f1, Font f2, unsigned int ui1, unsigned int ui2, XColor *x1, XColor *x2); /* 8 */
    GContext (*xGContextFromGC) (GC g); /* 9 */
    XHostAddress * (*xListHosts) (Display *d, int *i, Bool *b); /* 10 */
    KeySym (*xKeycodeToKeysym) (Display *d, unsigned int k, int i); /* 11 */
    KeySym (*xStringToKeysym) (_Xconst char *c); /* 12 */
    Window (*xRootWindow) (Display *d, int i); /* 13 */
    XErrorHandler (*xSetErrorHandler) (XErrorHandler x); /* 14 */
    Status (*xIconifyWindow) (Display *d, Window w, int i); /* 15 */
    Status (*xWithdrawWindow) (Display *d, Window w, int i); /* 16 */
    Status (*xGetWMColormapWindows) (Display *d, Window w, Window **wpp, int *ip); /* 17 */
    Status (*xAllocColor) (Display *d, Colormap c, XColor *xp); /* 18 */
    void (*xBell) (Display *d, int i); /* 19 */
    void (*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3); /* 20 */
    void (*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x); /* 21 */
    void (*xClearWindow) (Display *d, Window w); /* 22 */
    void (*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x); /* 23 */
    void (*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 24 */
    void (*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul); /* 25 */
    Pixmap (*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height); /* 26 */
    void (*xDefineCursor) (Display *d, Window w, Cursor c); /* 27 */
    void (*xDeleteProperty) (Display *d, Window w, Atom a); /* 28 */
    void (*xDestroyWindow) (Display *d, Window w); /* 29 */
    void (*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 30 */
    void (*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2); /* 31 */
    void (*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 32 */
    void (*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 33 */
    void (*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3); /* 34 */
    void (*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i); /* 35 */
    void (*xForceScreenSaver) (Display *d, int i); /* 36 */
    void (*xFreeColormap) (Display *d, Colormap c); /* 37 */
    void (*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul); /* 38 */
    void (*xFreeCursor) (Display *d, Cursor c); /* 39 */
    void (*xFreeModifiermap) (XModifierKeymap *x); /* 40 */
    Status (*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4); /* 41 */
    void (*xGetInputFocus) (Display *d, Window *w, int *i); /* 42 */
    int (*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp); /* 43 */
    Status (*xGetWindowAttributes) (Display *d, Window w, XWindowAttributes *x); /* 44 */
    int (*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t); /* 45 */
    int (*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t); /* 46 */
    KeyCode (*xKeysymToKeycode) (Display *d, KeySym k); /* 47 */
    Status (*xLookupColor) (Display *d, Colormap c1, _Xconst char *c2, XColor *x1, XColor *x2); /* 48 */
    void (*xMapWindow) (Display *d, Window w); /* 49 */
    void (*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 50 */
    void (*xMoveWindow) (Display *d, Window w, int i1, int i2); /* 51 */
    void (*xNextEvent) (Display *d, XEvent *x); /* 52 */
    void (*xPutBackEvent) (Display *d, XEvent *x); /* 53 */
    void (*xQueryColors) (Display *d, Colormap c, XColor *x, int i); /* 54 */
    Bool (*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui); /* 55 */
    Status (*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui); /* 56 */
    void (*xRaiseWindow) (Display *d, Window w); /* 57 */
    void (*xRefreshKeyboardMapping) (XMappingEvent *x); /* 58 */
    void (*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2); /* 59 */
    void (*xSelectInput) (Display *d, Window w, long l); /* 60 */
    Status (*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x); /* 61 */
    void (*xSetCommand) (Display *d, Window w, CONST char **c, int i); /* 62 */
    void (*xSetIconName) (Display *d, Window w, _Xconst char *c); /* 63 */
    void (*xSetInputFocus) (Display *d, Window w, int i, Time t); /* 64 */
    void (*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t); /* 65 */
    void (*xSetWindowBackground) (Display *d, Window w, unsigned long ul); /* 66 */
    void (*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p); /* 67 */
    void (*xSetWindowBorder) (Display *d, Window w, unsigned long ul); /* 68 */
    void (*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p); /* 69 */
    void (*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui); /* 70 */
    void (*xSetWindowColormap) (Display *d, Window w, Colormap c); /* 71 */
    Bool (*xTranslateCoordinates) (Display *d, Window w1, Window w2, int i1, int i2, int *i3, int *i4, Window *w3); /* 72 */
    void (*xUngrabKeyboard) (Display *d, Time t); /* 73 */
    void (*xUngrabPointer) (Display *d, Time t); /* 74 */
    void (*xUnmapWindow) (Display *d, Window w); /* 75 */
    void (*xWindowEvent) (Display *d, Window w, long l, XEvent *x); /* 76 */
    void (*xDestroyIC) (XIC x); /* 77 */
    Bool (*xFilterEvent) (XEvent *x, Window w); /* 78 */
    int (*xmbLookupString) (XIC xi, XKeyPressedEvent *xk, char *c, int i, KeySym *k, Status *s); /* 79 */
    void (*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height); /* 80 */
    void *reserved81;
    Status (*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr); /* 82 */
    GC (*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values); /* 83 */
    void (*xFreeGC) (Display *display, GC gc); /* 84 */
    Atom (*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists); /* 85 */
    void (*xSetBackground) (Display *display, GC gc, unsigned long foreground); /* 86 */
    void (*xSetForeground) (Display *display, GC gc, unsigned long foreground); /* 87 */
    void (*xSetClipMask) (Display *display, GC gc, Pixmap pixmap); /* 88 */
    void (*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin); /* 89 */
    void (*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin); /* 90 */
    void (*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values); /* 91 */
    void (*xSetFont) (Display *display, GC gc, Font font); /* 92 */
    void (*xSetArcMode) (Display *display, GC gc, int arc_mode); /* 93 */
    void (*xSetStipple) (Display *display, GC gc, Pixmap stipple); /* 94 */
    void (*xSetFillRule) (Display *display, GC gc, int fill_rule); /* 95 */
    void (*xSetFillStyle) (Display *display, GC gc, int fill_style); /* 96 */
    void (*xSetFunction) (Display *display, GC gc, int function); /* 97 */
    void (*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style); /* 98 */
    int (*_XInitImageFuncPtrs) (XImage *image); /* 99 */
    XIC (*xCreateIC) (void); /* 100 */
    XVisualInfo * (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return); /* 101 */
    void (*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop); /* 102 */
    Status (*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return); /* 103 */
    void (*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2); /* 104 */
    void (*xWarpPointer) (Display *d, Window s, Window dw, int sx, int sy, unsigned int sw, unsigned int sh, int dx, int dy); /* 105 */
    void (*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height); /* 106 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void (*xSetDashes) (Display *display, GC gc, int dash_offset, _Xconst char *dash_list, int n); /* 0 */
    XModifierKeymap * (*xGetModifierMapping) (Display *d); /* 1 */
    XImage * (*xCreateImage) (Display *d, Visual *v, unsigned int ui1, int i1, int i2, char *cp, unsigned int ui2, unsigned int ui3, int i3, int i4); /* 2 */
    XImage * (*xGetImage) (Display *d, Drawable dr, int i1, int i2, unsigned int ui1, unsigned int ui2, unsigned long ul, int i3); /* 3 */
    char * (*xGetAtomName) (Display *d, Atom a); /* 4 */
    char * (*xKeysymToString) (KeySym k); /* 5 */
    Colormap (*xCreateColormap) (Display *d, Window w, Visual *v, int i); /* 6 */
    GContext (*xGContextFromGC) (GC g); /* 7 */
    KeySym (*xKeycodeToKeysym) (Display *d, KeyCode k, int i); /* 8 */
    KeySym (*xStringToKeysym) (_Xconst char *c); /* 9 */
    Window (*xRootWindow) (Display *d, int i); /* 10 */
    XErrorHandler (*xSetErrorHandler) (XErrorHandler x); /* 11 */
    Status (*xAllocColor) (Display *d, Colormap c, XColor *xp); /* 12 */
    void (*xBell) (Display *d, int i); /* 13 */
    void (*xChangeProperty) (Display *d, Window w, Atom a1, Atom a2, int i1, int i2, _Xconst unsigned char *c, int i3); /* 14 */
    void (*xChangeWindowAttributes) (Display *d, Window w, unsigned long ul, XSetWindowAttributes *x); /* 15 */
    void (*xConfigureWindow) (Display *d, Window w, unsigned int i, XWindowChanges *x); /* 16 */
    void (*xCopyArea) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 17 */
    void (*xCopyPlane) (Display *d, Drawable dr1, Drawable dr2, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4, unsigned long ul); /* 18 */
    Pixmap (*xCreateBitmapFromData) (Display *display, Drawable d, _Xconst char *data, unsigned int width, unsigned int height); /* 19 */
    void (*xDefineCursor) (Display *d, Window w, Cursor c); /* 20 */
    void (*xDestroyWindow) (Display *d, Window w); /* 21 */
    void (*xDrawArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 22 */
    void (*xDrawLines) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2); /* 23 */
    void (*xDrawRectangle) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 24 */
    void (*xFillArc) (Display *d, Drawable dr, GC g, int i1, int i2, unsigned int ui1, unsigned int ui2, int i3, int i4); /* 25 */
    void (*xFillPolygon) (Display *d, Drawable dr, GC g, XPoint *x, int i1, int i2, int i3); /* 26 */
    void (*xFillRectangles) (Display *d, Drawable dr, GC g, XRectangle *x, int i); /* 27 */
    void (*xFreeColormap) (Display *d, Colormap c); /* 28 */
    void (*xFreeColors) (Display *d, Colormap c, unsigned long *ulp, int i, unsigned long ul); /* 29 */
    void (*xFreeModifiermap) (XModifierKeymap *x); /* 30 */
    Status (*xGetGeometry) (Display *d, Drawable dr, Window *w, int *i1, int *i2, unsigned int *ui1, unsigned int *ui2, unsigned int *ui3, unsigned int *ui4); /* 31 */
    int (*xGetWindowProperty) (Display *d, Window w, Atom a1, long l1, long l2, Bool b, Atom a2, Atom *ap, int *ip, unsigned long *ulp1, unsigned long *ulp2, unsigned char **cpp); /* 32 */
    int (*xGrabKeyboard) (Display *d, Window w, Bool b, int i1, int i2, Time t); /* 33 */
    int (*xGrabPointer) (Display *d, Window w1, Bool b, unsigned int ui, int i1, int i2, Window w2, Cursor c, Time t); /* 34 */
    KeyCode (*xKeysymToKeycode) (Display *d, KeySym k); /* 35 */
    void (*xMapWindow) (Display *d, Window w); /* 36 */
    void (*xMoveResizeWindow) (Display *d, Window w, int i1, int i2, unsigned int ui1, unsigned int ui2); /* 37 */
    void (*xMoveWindow) (Display *d, Window w, int i1, int i2); /* 38 */
    Bool (*xQueryPointer) (Display *d, Window w1, Window *w2, Window *w3, int *i1, int *i2, int *i3, int *i4, unsigned int *ui); /* 39 */
    void (*xRaiseWindow) (Display *d, Window w); /* 40 */
    void (*xRefreshKeyboardMapping) (XMappingEvent *x); /* 41 */
    void (*xResizeWindow) (Display *d, Window w, unsigned int ui1, unsigned int ui2); /* 42 */
    void (*xSelectInput) (Display *d, Window w, long l); /* 43 */
    Status (*xSendEvent) (Display *d, Window w, Bool b, long l, XEvent *x); /* 44 */
    void (*xSetIconName) (Display *d, Window w, _Xconst char *c); /* 45 */
    void (*xSetInputFocus) (Display *d, Window w, int i, Time t); /* 46 */
    void (*xSetSelectionOwner) (Display *d, Atom a, Window w, Time t); /* 47 */
    void (*xSetWindowBackground) (Display *d, Window w, unsigned long ul); /* 48 */
    void (*xSetWindowBackgroundPixmap) (Display *d, Window w, Pixmap p); /* 49 */
    void (*xSetWindowBorder) (Display *d, Window w, unsigned long ul); /* 50 */
    void (*xSetWindowBorderPixmap) (Display *d, Window w, Pixmap p); /* 51 */
    void (*xSetWindowBorderWidth) (Display *d, Window w, unsigned int ui); /* 52 */
    void (*xSetWindowColormap) (Display *d, Window w, Colormap c); /* 53 */
    void (*xUngrabKeyboard) (Display *d, Time t); /* 54 */
    void (*xUngrabPointer) (Display *d, Time t); /* 55 */
    void (*xUnmapWindow) (Display *d, Window w); /* 56 */
    void (*tkPutImage) (unsigned long *colors, int ncolors, Display *display, Drawable d, GC gc, XImage *image, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height); /* 57 */
    Status (*xParseColor) (Display *display, Colormap map, _Xconst char *spec, XColor *colorPtr); /* 58 */
    GC (*xCreateGC) (Display *display, Drawable d, unsigned long valuemask, XGCValues *values); /* 59 */
    void (*xFreeGC) (Display *display, GC gc); /* 60 */
    Atom (*xInternAtom) (Display *display, _Xconst char *atom_name, Bool only_if_exists); /* 61 */
    void (*xSetBackground) (Display *display, GC gc, unsigned long foreground); /* 62 */
    void (*xSetForeground) (Display *display, GC gc, unsigned long foreground); /* 63 */
    void (*xSetClipMask) (Display *display, GC gc, Pixmap pixmap); /* 64 */
    void (*xSetClipOrigin) (Display *display, GC gc, int clip_x_origin, int clip_y_origin); /* 65 */
    void (*xSetTSOrigin) (Display *display, GC gc, int ts_x_origin, int ts_y_origin); /* 66 */
    void (*xChangeGC) (Display *d, GC gc, unsigned long mask, XGCValues *values); /* 67 */
    void (*xSetFont) (Display *display, GC gc, Font font); /* 68 */
    void (*xSetArcMode) (Display *display, GC gc, int arc_mode); /* 69 */
    void (*xSetStipple) (Display *display, GC gc, Pixmap stipple); /* 70 */
    void (*xSetFillRule) (Display *display, GC gc, int fill_rule); /* 71 */
    void (*xSetFillStyle) (Display *display, GC gc, int fill_style); /* 72 */
    void (*xSetFunction) (Display *display, GC gc, int function); /* 73 */
    void (*xSetLineAttributes) (Display *display, GC gc, unsigned int line_width, int line_style, int cap_style, int join_style); /* 74 */
    int (*_XInitImageFuncPtrs) (XImage *image); /* 75 */
    XIC (*xCreateIC) (void); /* 76 */
    XVisualInfo * (*xGetVisualInfo) (Display *display, long vinfo_mask, XVisualInfo *vinfo_template, int *nitems_return); /* 77 */
    void (*xSetWMClientMachine) (Display *display, Window w, XTextProperty *text_prop); /* 78 */
    Status (*xStringListToTextProperty) (char **list, int count, XTextProperty *text_prop_return); /* 79 */
    void (*xDrawSegments) (Display *display, Drawable d, GC gc, XSegment *segments, int nsegments); /* 80 */
    void (*xForceScreenSaver) (Display *display, int mode); /* 81 */
    void (*xDrawLine) (Display *d, Drawable dr, GC g, int x1, int y1, int x2, int y2); /* 82 */
    void (*xFillRectangle) (Display *display, Drawable d, GC gc, int x, int y, unsigned int width, unsigned int height); /* 83 */
    void (*xClearWindow) (Display *d, Window w); /* 84 */
    void (*xDrawPoint) (Display *display, Drawable d, GC gc, int x, int y); /* 85 */
    void (*xDrawPoints) (Display *display, Drawable d, GC gc, XPoint *points, int npoints, int mode); /* 86 */
    void (*xWarpPointer) (Display *display, Window src_w, Window dest_w, int src_x, int src_y, unsigned int src_width, unsigned int src_height, int dest_x, int dest_y); /* 87 */
    void (*xQueryColor) (Display *display, Colormap colormap, XColor *def_in_out); /* 88 */
    void (*xQueryColors) (Display *display, Colormap colormap, XColor *defs_in_out, int ncolors); /* 89 */
    Status (*xQueryTree) (Display *d, Window w1, Window *w2, Window *w3, Window **w4, unsigned int *ui); /* 90 */
    int (*xSync) (Display *display, Bool flag); /* 91 */
#endif /* AQUA */
} TkIntXlibStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkIntXlibStubs *tkIntXlibStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef XSetDashes
#define XSetDashes \
	(tkIntXlibStubsPtr->xSetDashes) /* 0 */
#endif
#ifndef XGetModifierMapping
#define XGetModifierMapping \
	(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */
#endif
#ifndef XCreateImage
#define XCreateImage \
	(tkIntXlibStubsPtr->xCreateImage) /* 2 */
#endif
#ifndef XGetImage
#define XGetImage \
	(tkIntXlibStubsPtr->xGetImage) /* 3 */
#endif
#ifndef XGetAtomName
#define XGetAtomName \
	(tkIntXlibStubsPtr->xGetAtomName) /* 4 */
#endif
#ifndef XKeysymToString
#define XKeysymToString \
	(tkIntXlibStubsPtr->xKeysymToString) /* 5 */
#endif
#ifndef XCreateColormap
#define XCreateColormap \
	(tkIntXlibStubsPtr->xCreateColormap) /* 6 */
#endif
#ifndef XCreatePixmapCursor
#define XCreatePixmapCursor \
	(tkIntXlibStubsPtr->xCreatePixmapCursor) /* 7 */
#endif
#ifndef XCreateGlyphCursor
#define XCreateGlyphCursor \
	(tkIntXlibStubsPtr->xCreateGlyphCursor) /* 8 */
#endif
#ifndef XGContextFromGC
#define XGContextFromGC \
	(tkIntXlibStubsPtr->xGContextFromGC) /* 9 */
#endif
#ifndef XListHosts
#define XListHosts \
	(tkIntXlibStubsPtr->xListHosts) /* 10 */
#endif
#ifndef XKeycodeToKeysym
#define XKeycodeToKeysym \
	(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 11 */
#endif
#ifndef XStringToKeysym
#define XStringToKeysym \
	(tkIntXlibStubsPtr->xStringToKeysym) /* 12 */
#endif
#ifndef XRootWindow
#define XRootWindow \
	(tkIntXlibStubsPtr->xRootWindow) /* 13 */
#endif
#ifndef XSetErrorHandler
#define XSetErrorHandler \
	(tkIntXlibStubsPtr->xSetErrorHandler) /* 14 */
#endif
#ifndef XIconifyWindow
#define XIconifyWindow \
	(tkIntXlibStubsPtr->xIconifyWindow) /* 15 */
#endif
#ifndef XWithdrawWindow
#define XWithdrawWindow \
	(tkIntXlibStubsPtr->xWithdrawWindow) /* 16 */
#endif
#ifndef XGetWMColormapWindows
#define XGetWMColormapWindows \
	(tkIntXlibStubsPtr->xGetWMColormapWindows) /* 17 */
#endif
#ifndef XAllocColor
#define XAllocColor \
	(tkIntXlibStubsPtr->xAllocColor) /* 18 */
#endif
#ifndef XBell
#define XBell \
	(tkIntXlibStubsPtr->xBell) /* 19 */
#endif
#ifndef XChangeProperty
#define XChangeProperty \
	(tkIntXlibStubsPtr->xChangeProperty) /* 20 */
#endif
#ifndef XChangeWindowAttributes
#define XChangeWindowAttributes \
	(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 21 */
#endif
#ifndef XClearWindow
#define XClearWindow \
	(tkIntXlibStubsPtr->xClearWindow) /* 22 */
#endif
#ifndef XConfigureWindow
#define XConfigureWindow \
	(tkIntXlibStubsPtr->xConfigureWindow) /* 23 */
#endif
#ifndef XCopyArea
#define XCopyArea \
	(tkIntXlibStubsPtr->xCopyArea) /* 24 */
#endif
#ifndef XCopyPlane
#define XCopyPlane \
	(tkIntXlibStubsPtr->xCopyPlane) /* 25 */
#endif
#ifndef XCreateBitmapFromData
#define XCreateBitmapFromData \
	(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 26 */
#endif
#ifndef XDefineCursor
#define XDefineCursor \
	(tkIntXlibStubsPtr->xDefineCursor) /* 27 */
#endif
#ifndef XDeleteProperty
#define XDeleteProperty \
	(tkIntXlibStubsPtr->xDeleteProperty) /* 28 */
#endif
#ifndef XDestroyWindow
#define XDestroyWindow \
	(tkIntXlibStubsPtr->xDestroyWindow) /* 29 */
#endif
#ifndef XDrawArc
#define XDrawArc \
	(tkIntXlibStubsPtr->xDrawArc) /* 30 */
#endif
#ifndef XDrawLines
#define XDrawLines \
	(tkIntXlibStubsPtr->xDrawLines) /* 31 */
#endif
#ifndef XDrawRectangle
#define XDrawRectangle \
	(tkIntXlibStubsPtr->xDrawRectangle) /* 32 */
#endif
#ifndef XFillArc
#define XFillArc \
	(tkIntXlibStubsPtr->xFillArc) /* 33 */
#endif
#ifndef XFillPolygon
#define XFillPolygon \
	(tkIntXlibStubsPtr->xFillPolygon) /* 34 */
#endif
#ifndef XFillRectangles
#define XFillRectangles \
	(tkIntXlibStubsPtr->xFillRectangles) /* 35 */
#endif
#ifndef XForceScreenSaver
#define XForceScreenSaver \
	(tkIntXlibStubsPtr->xForceScreenSaver) /* 36 */
#endif
#ifndef XFreeColormap
#define XFreeColormap \
	(tkIntXlibStubsPtr->xFreeColormap) /* 37 */
#endif
#ifndef XFreeColors
#define XFreeColors \
	(tkIntXlibStubsPtr->xFreeColors) /* 38 */
#endif
#ifndef XFreeCursor
#define XFreeCursor \
	(tkIntXlibStubsPtr->xFreeCursor) /* 39 */
#endif
#ifndef XFreeModifiermap
#define XFreeModifiermap \
	(tkIntXlibStubsPtr->xFreeModifiermap) /* 40 */
#endif
#ifndef XGetGeometry
#define XGetGeometry \
	(tkIntXlibStubsPtr->xGetGeometry) /* 41 */
#endif
#ifndef XGetInputFocus
#define XGetInputFocus \
	(tkIntXlibStubsPtr->xGetInputFocus) /* 42 */
#endif
#ifndef XGetWindowProperty
#define XGetWindowProperty \
	(tkIntXlibStubsPtr->xGetWindowProperty) /* 43 */
#endif
#ifndef XGetWindowAttributes
#define XGetWindowAttributes \
	(tkIntXlibStubsPtr->xGetWindowAttributes) /* 44 */
#endif
#ifndef XGrabKeyboard
#define XGrabKeyboard \
	(tkIntXlibStubsPtr->xGrabKeyboard) /* 45 */
#endif
#ifndef XGrabPointer
#define XGrabPointer \
	(tkIntXlibStubsPtr->xGrabPointer) /* 46 */
#endif
#ifndef XKeysymToKeycode
#define XKeysymToKeycode \
	(tkIntXlibStubsPtr->xKeysymToKeycode) /* 47 */
#endif
#ifndef XLookupColor
#define XLookupColor \
	(tkIntXlibStubsPtr->xLookupColor) /* 48 */
#endif
#ifndef XMapWindow
#define XMapWindow \
	(tkIntXlibStubsPtr->xMapWindow) /* 49 */
#endif
#ifndef XMoveResizeWindow
#define XMoveResizeWindow \
	(tkIntXlibStubsPtr->xMoveResizeWindow) /* 50 */
#endif
#ifndef XMoveWindow
#define XMoveWindow \
	(tkIntXlibStubsPtr->xMoveWindow) /* 51 */
#endif
#ifndef XNextEvent
#define XNextEvent \
	(tkIntXlibStubsPtr->xNextEvent) /* 52 */
#endif
#ifndef XPutBackEvent
#define XPutBackEvent \
	(tkIntXlibStubsPtr->xPutBackEvent) /* 53 */
#endif
#ifndef XQueryColors
#define XQueryColors \
	(tkIntXlibStubsPtr->xQueryColors) /* 54 */
#endif
#ifndef XQueryPointer
#define XQueryPointer \
	(tkIntXlibStubsPtr->xQueryPointer) /* 55 */
#endif
#ifndef XQueryTree
#define XQueryTree \
	(tkIntXlibStubsPtr->xQueryTree) /* 56 */
#endif
#ifndef XRaiseWindow
#define XRaiseWindow \
	(tkIntXlibStubsPtr->xRaiseWindow) /* 57 */
#endif
#ifndef XRefreshKeyboardMapping
#define XRefreshKeyboardMapping \
	(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 58 */
#endif
#ifndef XResizeWindow
#define XResizeWindow \
	(tkIntXlibStubsPtr->xResizeWindow) /* 59 */
#endif
#ifndef XSelectInput
#define XSelectInput \
	(tkIntXlibStubsPtr->xSelectInput) /* 60 */
#endif
#ifndef XSendEvent
#define XSendEvent \
	(tkIntXlibStubsPtr->xSendEvent) /* 61 */
#endif
#ifndef XSetCommand
#define XSetCommand \
	(tkIntXlibStubsPtr->xSetCommand) /* 62 */
#endif
#ifndef XSetIconName
#define XSetIconName \
	(tkIntXlibStubsPtr->xSetIconName) /* 63 */
#endif
#ifndef XSetInputFocus
#define XSetInputFocus \
	(tkIntXlibStubsPtr->xSetInputFocus) /* 64 */
#endif
#ifndef XSetSelectionOwner
#define XSetSelectionOwner \
	(tkIntXlibStubsPtr->xSetSelectionOwner) /* 65 */
#endif
#ifndef XSetWindowBackground
#define XSetWindowBackground \
	(tkIntXlibStubsPtr->xSetWindowBackground) /* 66 */
#endif
#ifndef XSetWindowBackgroundPixmap
#define XSetWindowBackgroundPixmap \
	(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 67 */
#endif
#ifndef XSetWindowBorder
#define XSetWindowBorder \
	(tkIntXlibStubsPtr->xSetWindowBorder) /* 68 */
#endif
#ifndef XSetWindowBorderPixmap
#define XSetWindowBorderPixmap \
	(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 69 */
#endif
#ifndef XSetWindowBorderWidth
#define XSetWindowBorderWidth \
	(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 70 */
#endif
#ifndef XSetWindowColormap
#define XSetWindowColormap \
	(tkIntXlibStubsPtr->xSetWindowColormap) /* 71 */
#endif
#ifndef XTranslateCoordinates
#define XTranslateCoordinates \
	(tkIntXlibStubsPtr->xTranslateCoordinates) /* 72 */
#endif
#ifndef XUngrabKeyboard
#define XUngrabKeyboard \
	(tkIntXlibStubsPtr->xUngrabKeyboard) /* 73 */
#endif
#ifndef XUngrabPointer
#define XUngrabPointer \
	(tkIntXlibStubsPtr->xUngrabPointer) /* 74 */
#endif
#ifndef XUnmapWindow
#define XUnmapWindow \
	(tkIntXlibStubsPtr->xUnmapWindow) /* 75 */
#endif
#ifndef XWindowEvent
#define XWindowEvent \
	(tkIntXlibStubsPtr->xWindowEvent) /* 76 */
#endif
#ifndef XDestroyIC
#define XDestroyIC \
	(tkIntXlibStubsPtr->xDestroyIC) /* 77 */
#endif
#ifndef XFilterEvent
#define XFilterEvent \
	(tkIntXlibStubsPtr->xFilterEvent) /* 78 */
#endif
#ifndef XmbLookupString
#define XmbLookupString \
	(tkIntXlibStubsPtr->xmbLookupString) /* 79 */
#endif
#ifndef TkPutImage
#define TkPutImage \
	(tkIntXlibStubsPtr->tkPutImage) /* 80 */
#endif
/* Slot 81 is reserved */
#ifndef XParseColor
#define XParseColor \
	(tkIntXlibStubsPtr->xParseColor) /* 82 */
#endif
#ifndef XCreateGC
#define XCreateGC \
	(tkIntXlibStubsPtr->xCreateGC) /* 83 */
#endif
#ifndef XFreeGC
#define XFreeGC \
	(tkIntXlibStubsPtr->xFreeGC) /* 84 */
#endif
#ifndef XInternAtom
#define XInternAtom \
	(tkIntXlibStubsPtr->xInternAtom) /* 85 */
#endif
#ifndef XSetBackground
#define XSetBackground \
	(tkIntXlibStubsPtr->xSetBackground) /* 86 */
#endif
#ifndef XSetForeground
#define XSetForeground \
	(tkIntXlibStubsPtr->xSetForeground) /* 87 */
#endif
#ifndef XSetClipMask
#define XSetClipMask \
	(tkIntXlibStubsPtr->xSetClipMask) /* 88 */
#endif
#ifndef XSetClipOrigin
#define XSetClipOrigin \
	(tkIntXlibStubsPtr->xSetClipOrigin) /* 89 */
#endif
#ifndef XSetTSOrigin
#define XSetTSOrigin \
	(tkIntXlibStubsPtr->xSetTSOrigin) /* 90 */
#endif
#ifndef XChangeGC
#define XChangeGC \
	(tkIntXlibStubsPtr->xChangeGC) /* 91 */
#endif
#ifndef XSetFont
#define XSetFont \
	(tkIntXlibStubsPtr->xSetFont) /* 92 */
#endif
#ifndef XSetArcMode
#define XSetArcMode \
	(tkIntXlibStubsPtr->xSetArcMode) /* 93 */
#endif
#ifndef XSetStipple
#define XSetStipple \
	(tkIntXlibStubsPtr->xSetStipple) /* 94 */
#endif
#ifndef XSetFillRule
#define XSetFillRule \
	(tkIntXlibStubsPtr->xSetFillRule) /* 95 */
#endif
#ifndef XSetFillStyle
#define XSetFillStyle \
	(tkIntXlibStubsPtr->xSetFillStyle) /* 96 */
#endif
#ifndef XSetFunction
#define XSetFunction \
	(tkIntXlibStubsPtr->xSetFunction) /* 97 */
#endif
#ifndef XSetLineAttributes
#define XSetLineAttributes \
	(tkIntXlibStubsPtr->xSetLineAttributes) /* 98 */
#endif
#ifndef _XInitImageFuncPtrs
#define _XInitImageFuncPtrs \
	(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 99 */
#endif
#ifndef XCreateIC
#define XCreateIC \
	(tkIntXlibStubsPtr->xCreateIC) /* 100 */
#endif
#ifndef XGetVisualInfo
#define XGetVisualInfo \
	(tkIntXlibStubsPtr->xGetVisualInfo) /* 101 */
#endif
#ifndef XSetWMClientMachine
#define XSetWMClientMachine \
	(tkIntXlibStubsPtr->xSetWMClientMachine) /* 102 */
#endif
#ifndef XStringListToTextProperty
#define XStringListToTextProperty \
	(tkIntXlibStubsPtr->xStringListToTextProperty) /* 103 */
#endif
#ifndef XDrawLine
#define XDrawLine \
	(tkIntXlibStubsPtr->xDrawLine) /* 104 */
#endif
#ifndef XWarpPointer
#define XWarpPointer \
	(tkIntXlibStubsPtr->xWarpPointer) /* 105 */
#endif
#ifndef XFillRectangle
#define XFillRectangle \
	(tkIntXlibStubsPtr->xFillRectangle) /* 106 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef XSetDashes
#define XSetDashes \
	(tkIntXlibStubsPtr->xSetDashes) /* 0 */
#endif
#ifndef XGetModifierMapping
#define XGetModifierMapping \
	(tkIntXlibStubsPtr->xGetModifierMapping) /* 1 */
#endif
#ifndef XCreateImage
#define XCreateImage \
	(tkIntXlibStubsPtr->xCreateImage) /* 2 */
#endif
#ifndef XGetImage
#define XGetImage \
	(tkIntXlibStubsPtr->xGetImage) /* 3 */
#endif
#ifndef XGetAtomName
#define XGetAtomName \
	(tkIntXlibStubsPtr->xGetAtomName) /* 4 */
#endif
#ifndef XKeysymToString
#define XKeysymToString \
	(tkIntXlibStubsPtr->xKeysymToString) /* 5 */
#endif
#ifndef XCreateColormap
#define XCreateColormap \
	(tkIntXlibStubsPtr->xCreateColormap) /* 6 */
#endif
#ifndef XGContextFromGC
#define XGContextFromGC \
	(tkIntXlibStubsPtr->xGContextFromGC) /* 7 */
#endif
#ifndef XKeycodeToKeysym
#define XKeycodeToKeysym \
	(tkIntXlibStubsPtr->xKeycodeToKeysym) /* 8 */
#endif
#ifndef XStringToKeysym
#define XStringToKeysym \
	(tkIntXlibStubsPtr->xStringToKeysym) /* 9 */
#endif
#ifndef XRootWindow
#define XRootWindow \
	(tkIntXlibStubsPtr->xRootWindow) /* 10 */
#endif
#ifndef XSetErrorHandler
#define XSetErrorHandler \
	(tkIntXlibStubsPtr->xSetErrorHandler) /* 11 */
#endif
#ifndef XAllocColor
#define XAllocColor \
	(tkIntXlibStubsPtr->xAllocColor) /* 12 */
#endif
#ifndef XBell
#define XBell \
	(tkIntXlibStubsPtr->xBell) /* 13 */
#endif
#ifndef XChangeProperty
#define XChangeProperty \
	(tkIntXlibStubsPtr->xChangeProperty) /* 14 */
#endif
#ifndef XChangeWindowAttributes
#define XChangeWindowAttributes \
	(tkIntXlibStubsPtr->xChangeWindowAttributes) /* 15 */
#endif
#ifndef XConfigureWindow
#define XConfigureWindow \
	(tkIntXlibStubsPtr->xConfigureWindow) /* 16 */
#endif
#ifndef XCopyArea
#define XCopyArea \
	(tkIntXlibStubsPtr->xCopyArea) /* 17 */
#endif
#ifndef XCopyPlane
#define XCopyPlane \
	(tkIntXlibStubsPtr->xCopyPlane) /* 18 */
#endif
#ifndef XCreateBitmapFromData
#define XCreateBitmapFromData \
	(tkIntXlibStubsPtr->xCreateBitmapFromData) /* 19 */
#endif
#ifndef XDefineCursor
#define XDefineCursor \
	(tkIntXlibStubsPtr->xDefineCursor) /* 20 */
#endif
#ifndef XDestroyWindow
#define XDestroyWindow \
	(tkIntXlibStubsPtr->xDestroyWindow) /* 21 */
#endif
#ifndef XDrawArc
#define XDrawArc \
	(tkIntXlibStubsPtr->xDrawArc) /* 22 */
#endif
#ifndef XDrawLines
#define XDrawLines \
	(tkIntXlibStubsPtr->xDrawLines) /* 23 */
#endif
#ifndef XDrawRectangle
#define XDrawRectangle \
	(tkIntXlibStubsPtr->xDrawRectangle) /* 24 */
#endif
#ifndef XFillArc
#define XFillArc \
	(tkIntXlibStubsPtr->xFillArc) /* 25 */
#endif
#ifndef XFillPolygon
#define XFillPolygon \
	(tkIntXlibStubsPtr->xFillPolygon) /* 26 */
#endif
#ifndef XFillRectangles
#define XFillRectangles \
	(tkIntXlibStubsPtr->xFillRectangles) /* 27 */
#endif
#ifndef XFreeColormap
#define XFreeColormap \
	(tkIntXlibStubsPtr->xFreeColormap) /* 28 */
#endif
#ifndef XFreeColors
#define XFreeColors \
	(tkIntXlibStubsPtr->xFreeColors) /* 29 */
#endif
#ifndef XFreeModifiermap
#define XFreeModifiermap \
	(tkIntXlibStubsPtr->xFreeModifiermap) /* 30 */
#endif
#ifndef XGetGeometry
#define XGetGeometry \
	(tkIntXlibStubsPtr->xGetGeometry) /* 31 */
#endif
#ifndef XGetWindowProperty
#define XGetWindowProperty \
	(tkIntXlibStubsPtr->xGetWindowProperty) /* 32 */
#endif
#ifndef XGrabKeyboard
#define XGrabKeyboard \
	(tkIntXlibStubsPtr->xGrabKeyboard) /* 33 */
#endif
#ifndef XGrabPointer
#define XGrabPointer \
	(tkIntXlibStubsPtr->xGrabPointer) /* 34 */
#endif
#ifndef XKeysymToKeycode
#define XKeysymToKeycode \
	(tkIntXlibStubsPtr->xKeysymToKeycode) /* 35 */
#endif
#ifndef XMapWindow
#define XMapWindow \
	(tkIntXlibStubsPtr->xMapWindow) /* 36 */
#endif
#ifndef XMoveResizeWindow
#define XMoveResizeWindow \
	(tkIntXlibStubsPtr->xMoveResizeWindow) /* 37 */
#endif
#ifndef XMoveWindow
#define XMoveWindow \
	(tkIntXlibStubsPtr->xMoveWindow) /* 38 */
#endif
#ifndef XQueryPointer
#define XQueryPointer \
	(tkIntXlibStubsPtr->xQueryPointer) /* 39 */
#endif
#ifndef XRaiseWindow
#define XRaiseWindow \
	(tkIntXlibStubsPtr->xRaiseWindow) /* 40 */
#endif
#ifndef XRefreshKeyboardMapping
#define XRefreshKeyboardMapping \
	(tkIntXlibStubsPtr->xRefreshKeyboardMapping) /* 41 */
#endif
#ifndef XResizeWindow
#define XResizeWindow \
	(tkIntXlibStubsPtr->xResizeWindow) /* 42 */
#endif
#ifndef XSelectInput
#define XSelectInput \
	(tkIntXlibStubsPtr->xSelectInput) /* 43 */
#endif
#ifndef XSendEvent
#define XSendEvent \
	(tkIntXlibStubsPtr->xSendEvent) /* 44 */
#endif
#ifndef XSetIconName
#define XSetIconName \
	(tkIntXlibStubsPtr->xSetIconName) /* 45 */
#endif
#ifndef XSetInputFocus
#define XSetInputFocus \
	(tkIntXlibStubsPtr->xSetInputFocus) /* 46 */
#endif
#ifndef XSetSelectionOwner
#define XSetSelectionOwner \
	(tkIntXlibStubsPtr->xSetSelectionOwner) /* 47 */
#endif
#ifndef XSetWindowBackground
#define XSetWindowBackground \
	(tkIntXlibStubsPtr->xSetWindowBackground) /* 48 */
#endif
#ifndef XSetWindowBackgroundPixmap
#define XSetWindowBackgroundPixmap \
	(tkIntXlibStubsPtr->xSetWindowBackgroundPixmap) /* 49 */
#endif
#ifndef XSetWindowBorder
#define XSetWindowBorder \
	(tkIntXlibStubsPtr->xSetWindowBorder) /* 50 */
#endif
#ifndef XSetWindowBorderPixmap
#define XSetWindowBorderPixmap \
	(tkIntXlibStubsPtr->xSetWindowBorderPixmap) /* 51 */
#endif
#ifndef XSetWindowBorderWidth
#define XSetWindowBorderWidth \
	(tkIntXlibStubsPtr->xSetWindowBorderWidth) /* 52 */
#endif
#ifndef XSetWindowColormap
#define XSetWindowColormap \
	(tkIntXlibStubsPtr->xSetWindowColormap) /* 53 */
#endif
#ifndef XUngrabKeyboard
#define XUngrabKeyboard \
	(tkIntXlibStubsPtr->xUngrabKeyboard) /* 54 */
#endif
#ifndef XUngrabPointer
#define XUngrabPointer \
	(tkIntXlibStubsPtr->xUngrabPointer) /* 55 */
#endif
#ifndef XUnmapWindow
#define XUnmapWindow \
	(tkIntXlibStubsPtr->xUnmapWindow) /* 56 */
#endif
#ifndef TkPutImage
#define TkPutImage \
	(tkIntXlibStubsPtr->tkPutImage) /* 57 */
#endif
#ifndef XParseColor
#define XParseColor \
	(tkIntXlibStubsPtr->xParseColor) /* 58 */
#endif
#ifndef XCreateGC
#define XCreateGC \
	(tkIntXlibStubsPtr->xCreateGC) /* 59 */
#endif
#ifndef XFreeGC
#define XFreeGC \
	(tkIntXlibStubsPtr->xFreeGC) /* 60 */
#endif
#ifndef XInternAtom
#define XInternAtom \
	(tkIntXlibStubsPtr->xInternAtom) /* 61 */
#endif
#ifndef XSetBackground
#define XSetBackground \
	(tkIntXlibStubsPtr->xSetBackground) /* 62 */
#endif
#ifndef XSetForeground
#define XSetForeground \
	(tkIntXlibStubsPtr->xSetForeground) /* 63 */
#endif
#ifndef XSetClipMask
#define XSetClipMask \
	(tkIntXlibStubsPtr->xSetClipMask) /* 64 */
#endif
#ifndef XSetClipOrigin
#define XSetClipOrigin \
	(tkIntXlibStubsPtr->xSetClipOrigin) /* 65 */
#endif
#ifndef XSetTSOrigin
#define XSetTSOrigin \
	(tkIntXlibStubsPtr->xSetTSOrigin) /* 66 */
#endif
#ifndef XChangeGC
#define XChangeGC \
	(tkIntXlibStubsPtr->xChangeGC) /* 67 */
#endif
#ifndef XSetFont
#define XSetFont \
	(tkIntXlibStubsPtr->xSetFont) /* 68 */
#endif
#ifndef XSetArcMode
#define XSetArcMode \
	(tkIntXlibStubsPtr->xSetArcMode) /* 69 */
#endif
#ifndef XSetStipple
#define XSetStipple \
	(tkIntXlibStubsPtr->xSetStipple) /* 70 */
#endif
#ifndef XSetFillRule
#define XSetFillRule \
	(tkIntXlibStubsPtr->xSetFillRule) /* 71 */
#endif
#ifndef XSetFillStyle
#define XSetFillStyle \
	(tkIntXlibStubsPtr->xSetFillStyle) /* 72 */
#endif
#ifndef XSetFunction
#define XSetFunction \
	(tkIntXlibStubsPtr->xSetFunction) /* 73 */
#endif
#ifndef XSetLineAttributes
#define XSetLineAttributes \
	(tkIntXlibStubsPtr->xSetLineAttributes) /* 74 */
#endif
#ifndef _XInitImageFuncPtrs
#define _XInitImageFuncPtrs \
	(tkIntXlibStubsPtr->_XInitImageFuncPtrs) /* 75 */
#endif
#ifndef XCreateIC
#define XCreateIC \
	(tkIntXlibStubsPtr->xCreateIC) /* 76 */
#endif
#ifndef XGetVisualInfo
#define XGetVisualInfo \
	(tkIntXlibStubsPtr->xGetVisualInfo) /* 77 */
#endif
#ifndef XSetWMClientMachine
#define XSetWMClientMachine \
	(tkIntXlibStubsPtr->xSetWMClientMachine) /* 78 */
#endif
#ifndef XStringListToTextProperty
#define XStringListToTextProperty \
	(tkIntXlibStubsPtr->xStringListToTextProperty) /* 79 */
#endif
#ifndef XDrawSegments
#define XDrawSegments \
	(tkIntXlibStubsPtr->xDrawSegments) /* 80 */
#endif
#ifndef XForceScreenSaver
#define XForceScreenSaver \
	(tkIntXlibStubsPtr->xForceScreenSaver) /* 81 */
#endif
#ifndef XDrawLine
#define XDrawLine \
	(tkIntXlibStubsPtr->xDrawLine) /* 82 */
#endif
#ifndef XFillRectangle
#define XFillRectangle \
	(tkIntXlibStubsPtr->xFillRectangle) /* 83 */
#endif
#ifndef XClearWindow
#define XClearWindow \
	(tkIntXlibStubsPtr->xClearWindow) /* 84 */
#endif
#ifndef XDrawPoint
#define XDrawPoint \
	(tkIntXlibStubsPtr->xDrawPoint) /* 85 */
#endif
#ifndef XDrawPoints
#define XDrawPoints \
	(tkIntXlibStubsPtr->xDrawPoints) /* 86 */
#endif
#ifndef XWarpPointer
#define XWarpPointer \
	(tkIntXlibStubsPtr->xWarpPointer) /* 87 */
#endif
#ifndef XQueryColor
#define XQueryColor \
	(tkIntXlibStubsPtr->xQueryColor) /* 88 */
#endif
#ifndef XQueryColors
#define XQueryColors \
	(tkIntXlibStubsPtr->xQueryColors) /* 89 */
#endif
#ifndef XQueryTree
#define XQueryTree \
	(tkIntXlibStubsPtr->xQueryTree) /* 90 */
#endif
#ifndef XSync
#define XSync \
	(tkIntXlibStubsPtr->xSync) /* 91 */
#endif
#endif /* AQUA */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKINTXLIBDECLS */
    tkMacOSX.h                                                                                          0100644 0001750 0001750 00000002020 11442001040 032102  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers                                                                        /*
 * tkMacOSX.h --
 *
 *	Declarations of Macintosh specific exported variables and procedures.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001-2009, Apple Inc.
 * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKMAC
#define _TKMAC

#ifndef _TK
#include "tk.h"
#endif

/*
 * Structures and function types for handling Netscape-type in process
 * embedding where Tk does not control the top-level
 */

typedef int (Tk_MacOSXEmbedRegisterWinProc) (long winID, Tk_Window window);
typedef void* (Tk_MacOSXEmbedGetGrafPortProc) (Tk_Window window);
typedef int (Tk_MacOSXEmbedMakeContainerExistProc) (Tk_Window window);
typedef void (Tk_MacOSXEmbedGetClipProc) (Tk_Window window, TkRegion rgn);
typedef void (Tk_MacOSXEmbedGetOffsetInParentProc) (Tk_Window window, void *ulCorner);

#include "tkPlatDecls.h"

#endif /* _TKMAC */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                tkPlatDecls.h                                                                                       0100644 0001750 0001750 00000016714 11442001432 032707  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Headers                                                                        /*
 * tkPlatDecls.h --
 *
 *	Declarations of functions in the platform-specific public Tcl API.
 *
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#ifndef _TKPLATDECLS
#define _TKPLATDECLS

#ifdef BUILD_tk
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * WARNING: This file is automatically generated by the tools/genStubs.tcl
 * script.  Any modifications to the function declarations below should be made
 * in the generic/tk.decls script.
 */

/* !BEGIN!: Do not edit below this line. */

/*
 * Exported function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef Tk_AttachHWND_TCL_DECLARED
#define Tk_AttachHWND_TCL_DECLARED
/* 0 */
EXTERN Window		Tk_AttachHWND(Tk_Window tkwin, HWND hwnd);
#endif
#ifndef Tk_GetHINSTANCE_TCL_DECLARED
#define Tk_GetHINSTANCE_TCL_DECLARED
/* 1 */
EXTERN HINSTANCE	Tk_GetHINSTANCE(void);
#endif
#ifndef Tk_GetHWND_TCL_DECLARED
#define Tk_GetHWND_TCL_DECLARED
/* 2 */
EXTERN HWND		Tk_GetHWND(Window window);
#endif
#ifndef Tk_HWNDToWindow_TCL_DECLARED
#define Tk_HWNDToWindow_TCL_DECLARED
/* 3 */
EXTERN Tk_Window	Tk_HWNDToWindow(HWND hwnd);
#endif
#ifndef Tk_PointerEvent_TCL_DECLARED
#define Tk_PointerEvent_TCL_DECLARED
/* 4 */
EXTERN void		Tk_PointerEvent(HWND hwnd, int x, int y);
#endif
#ifndef Tk_TranslateWinEvent_TCL_DECLARED
#define Tk_TranslateWinEvent_TCL_DECLARED
/* 5 */
EXTERN int		Tk_TranslateWinEvent(HWND hwnd, UINT message,
				WPARAM wParam, LPARAM lParam,
				LRESULT *result);
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef Tk_MacOSXSetEmbedHandler_TCL_DECLARED
#define Tk_MacOSXSetEmbedHandler_TCL_DECLARED
/* 0 */
EXTERN void		Tk_MacOSXSetEmbedHandler(
				Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr,
				Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr,
				Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr,
				Tk_MacOSXEmbedGetClipProc *getClipProc,
				Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc);
#endif
#ifndef Tk_MacOSXTurnOffMenus_TCL_DECLARED
#define Tk_MacOSXTurnOffMenus_TCL_DECLARED
/* 1 */
EXTERN void		Tk_MacOSXTurnOffMenus(void);
#endif
#ifndef Tk_MacOSXTkOwnsCursor_TCL_DECLARED
#define Tk_MacOSXTkOwnsCursor_TCL_DECLARED
/* 2 */
EXTERN void		Tk_MacOSXTkOwnsCursor(int tkOwnsIt);
#endif
#ifndef TkMacOSXInitMenus_TCL_DECLARED
#define TkMacOSXInitMenus_TCL_DECLARED
/* 3 */
EXTERN void		TkMacOSXInitMenus(Tcl_Interp *interp);
#endif
#ifndef TkMacOSXInitAppleEvents_TCL_DECLARED
#define TkMacOSXInitAppleEvents_TCL_DECLARED
/* 4 */
EXTERN void		TkMacOSXInitAppleEvents(Tcl_Interp *interp);
#endif
#ifndef TkGenWMConfigureEvent_TCL_DECLARED
#define TkGenWMConfigureEvent_TCL_DECLARED
/* 5 */
EXTERN void		TkGenWMConfigureEvent(Tk_Window tkwin, int x, int y,
				int width, int height, int flags);
#endif
#ifndef TkMacOSXInvalClipRgns_TCL_DECLARED
#define TkMacOSXInvalClipRgns_TCL_DECLARED
/* 6 */
EXTERN void		TkMacOSXInvalClipRgns(Tk_Window tkwin);
#endif
#ifndef TkMacOSXGetDrawablePort_TCL_DECLARED
#define TkMacOSXGetDrawablePort_TCL_DECLARED
/* 7 */
EXTERN void *		TkMacOSXGetDrawablePort(Drawable drawable);
#endif
#ifndef TkMacOSXGetRootControl_TCL_DECLARED
#define TkMacOSXGetRootControl_TCL_DECLARED
/* 8 */
EXTERN void *		TkMacOSXGetRootControl(Drawable drawable);
#endif
#ifndef Tk_MacOSXSetupTkNotifier_TCL_DECLARED
#define Tk_MacOSXSetupTkNotifier_TCL_DECLARED
/* 9 */
EXTERN void		Tk_MacOSXSetupTkNotifier(void);
#endif
#ifndef Tk_MacOSXIsAppInFront_TCL_DECLARED
#define Tk_MacOSXIsAppInFront_TCL_DECLARED
/* 10 */
EXTERN int		Tk_MacOSXIsAppInFront(void);
#endif
#endif /* AQUA */

typedef struct TkPlatStubs {
    int magic;
    struct TkPlatStubHooks *hooks;

#ifdef __WIN32__ /* WIN */
    Window (*tk_AttachHWND) (Tk_Window tkwin, HWND hwnd); /* 0 */
    HINSTANCE (*tk_GetHINSTANCE) (void); /* 1 */
    HWND (*tk_GetHWND) (Window window); /* 2 */
    Tk_Window (*tk_HWNDToWindow) (HWND hwnd); /* 3 */
    void (*tk_PointerEvent) (HWND hwnd, int x, int y); /* 4 */
    int (*tk_TranslateWinEvent) (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *result); /* 5 */
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
    void (*tk_MacOSXSetEmbedHandler) (Tk_MacOSXEmbedRegisterWinProc *registerWinProcPtr, Tk_MacOSXEmbedGetGrafPortProc *getPortProcPtr, Tk_MacOSXEmbedMakeContainerExistProc *containerExistProcPtr, Tk_MacOSXEmbedGetClipProc *getClipProc, Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc); /* 0 */
    void (*tk_MacOSXTurnOffMenus) (void); /* 1 */
    void (*tk_MacOSXTkOwnsCursor) (int tkOwnsIt); /* 2 */
    void (*tkMacOSXInitMenus) (Tcl_Interp *interp); /* 3 */
    void (*tkMacOSXInitAppleEvents) (Tcl_Interp *interp); /* 4 */
    void (*tkGenWMConfigureEvent) (Tk_Window tkwin, int x, int y, int width, int height, int flags); /* 5 */
    void (*tkMacOSXInvalClipRgns) (Tk_Window tkwin); /* 6 */
    void * (*tkMacOSXGetDrawablePort) (Drawable drawable); /* 7 */
    void * (*tkMacOSXGetRootControl) (Drawable drawable); /* 8 */
    void (*tk_MacOSXSetupTkNotifier) (void); /* 9 */
    int (*tk_MacOSXIsAppInFront) (void); /* 10 */
#endif /* AQUA */
} TkPlatStubs;

#ifdef __cplusplus
extern "C" {
#endif
extern TkPlatStubs *tkPlatStubsPtr;
#ifdef __cplusplus
}
#endif

#if defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS)

/*
 * Inline function declarations:
 */

#ifdef __WIN32__ /* WIN */
#ifndef Tk_AttachHWND
#define Tk_AttachHWND \
	(tkPlatStubsPtr->tk_AttachHWND) /* 0 */
#endif
#ifndef Tk_GetHINSTANCE
#define Tk_GetHINSTANCE \
	(tkPlatStubsPtr->tk_GetHINSTANCE) /* 1 */
#endif
#ifndef Tk_GetHWND
#define Tk_GetHWND \
	(tkPlatStubsPtr->tk_GetHWND) /* 2 */
#endif
#ifndef Tk_HWNDToWindow
#define Tk_HWNDToWindow \
	(tkPlatStubsPtr->tk_HWNDToWindow) /* 3 */
#endif
#ifndef Tk_PointerEvent
#define Tk_PointerEvent \
	(tkPlatStubsPtr->tk_PointerEvent) /* 4 */
#endif
#ifndef Tk_TranslateWinEvent
#define Tk_TranslateWinEvent \
	(tkPlatStubsPtr->tk_TranslateWinEvent) /* 5 */
#endif
#endif /* WIN */
#ifdef MAC_OSX_TK /* AQUA */
#ifndef Tk_MacOSXSetEmbedHandler
#define Tk_MacOSXSetEmbedHandler \
	(tkPlatStubsPtr->tk_MacOSXSetEmbedHandler) /* 0 */
#endif
#ifndef Tk_MacOSXTurnOffMenus
#define Tk_MacOSXTurnOffMenus \
	(tkPlatStubsPtr->tk_MacOSXTurnOffMenus) /* 1 */
#endif
#ifndef Tk_MacOSXTkOwnsCursor
#define Tk_MacOSXTkOwnsCursor \
	(tkPlatStubsPtr->tk_MacOSXTkOwnsCursor) /* 2 */
#endif
#ifndef TkMacOSXInitMenus
#define TkMacOSXInitMenus \
	(tkPlatStubsPtr->tkMacOSXInitMenus) /* 3 */
#endif
#ifndef TkMacOSXInitAppleEvents
#define TkMacOSXInitAppleEvents \
	(tkPlatStubsPtr->tkMacOSXInitAppleEvents) /* 4 */
#endif
#ifndef TkGenWMConfigureEvent
#define TkGenWMConfigureEvent \
	(tkPlatStubsPtr->tkGenWMConfigureEvent) /* 5 */
#endif
#ifndef TkMacOSXInvalClipRgns
#define TkMacOSXInvalClipRgns \
	(tkPlatStubsPtr->tkMacOSXInvalClipRgns) /* 6 */
#endif
#ifndef TkMacOSXGetDrawablePort
#define TkMacOSXGetDrawablePort \
	(tkPlatStubsPtr->tkMacOSXGetDrawablePort) /* 7 */
#endif
#ifndef TkMacOSXGetRootControl
#define TkMacOSXGetRootControl \
	(tkPlatStubsPtr->tkMacOSXGetRootControl) /* 8 */
#endif
#ifndef Tk_MacOSXSetupTkNotifier
#define Tk_MacOSXSetupTkNotifier \
	(tkPlatStubsPtr->tk_MacOSXSetupTkNotifier) /* 9 */
#endif
#ifndef Tk_MacOSXIsAppInFront
#define Tk_MacOSXIsAppInFront \
	(tkPlatStubsPtr->tk_MacOSXIsAppInFront) /* 10 */
#endif
#endif /* AQUA */

#endif /* defined(USE_TK_STUBS) && !defined(USE_TK_STUB_PROCS) */

/* !END!: Do not edit above this line. */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKPLATDECLS */
                                                    osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5/Tk.tbd      0100644 0001750 0001750 00000040347 12571375071 030121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/Tk.framework/Versions/8.5/Tk
current-version: 8.5.9
compatibility-version: 8.5
exports:         
  - archs:           [ i386 ]
    objc-classes:    [ _TKApplication, _TKContentView, _TKMenu, _TKWindow ]
  - archs:           [ i386, x86_64 ]
    symbols:         [ _TkAboutDlg, _TkAllocWindow, _TkBezierPoints, _TkBezierScreenPoints, 
                       _TkBindDeadWindow, _TkBindEventProc, _TkBindFree, 
                       _TkBindInit, _TkCanvasDashParseProc, _TkCanvasDashPrintProc, 
                       _TkChangeEventWindow, _TkClipBox, _TkClipCleanup, 
                       _TkClipInit, _TkComputeAnchor, _TkCopyAndGlobalEval, 
                       _TkCreateBindingProcedure, _TkCreateCursorFromData, 
                       _TkCreateFrame, _TkCreateMainWindow, _TkCreateRegion, 
                       _TkCreateThreadExitHandler, _TkCurrentTime, _TkDebugBitmap, 
                       _TkDebugBorder, _TkDebugColor, _TkDebugConfig, _TkDebugCursor, 
                       _TkDebugFont, _TkDeleteAllImages, _TkDeleteThreadExitHandler, 
                       _TkDestroyRegion, _TkDoConfigureNotify, _TkDrawInsetFocusHighlight, 
                       _TkEventDeadWindow, _TkFillPolygon, _TkFindStateNum, 
                       _TkFindStateNumObj, _TkFindStateString, _TkFocusDeadWindow, 
                       _TkFocusFilterEvent, _TkFocusFree, _TkFocusKeyEvent, 
                       _TkFontPkgFree, _TkFontPkgInit, _TkFreeBindingTags, 
                       _TkGCCleanup, _TkGenWMConfigureEvent, _TkGenWMDestroyEvent, 
                       _TkGenerateActivateEvents, _TkGenerateButtonEvent, 
                       _TkGetBitmapData, _TkGetBitmapPredefTable, _TkGetButtPoints, 
                       _TkGetCursorByName, _TkGetDefaultScreenName, _TkGetDisplay, 
                       _TkGetDisplayList, _TkGetDisplayOf, _TkGetFocusWin, 
                       _TkGetInterpNames, _TkGetMainInfoList, _TkGetMiterPoints, 
                       _TkGetOptionSpec, _TkGetPointerCoords, _TkGetServerInfo, 
                       _TkGetTransientMaster, _TkGetWindowFromObj, _TkGrabDeadWindow, 
                       _TkGrabState, _TkInOutEvents, _TkIncludePoint, _TkInstallFrameMenu, 
                       _TkIntersectRegion, _TkKeysymToString, _TkLineToArea, 
                       _TkLineToPoint, _TkMacOSXButtonKeyState, _TkMacOSXClearMenubarActive, 
                       _TkMacOSXContainerId, _TkMacOSXDispatchMenuEvent, 
                       _TkMacOSXDoHLEvent, _TkMacOSXGetCapture, _TkMacOSXGetDrawablePort, 
                       _TkMacOSXGetHostToplevel, _TkMacOSXGetRootControl, 
                       _TkMacOSXGetXWindow, _TkMacOSXGrowToplevel, _TkMacOSXHandleMenuSelect, 
                       _TkMacOSXHandleTearoffMenu, _TkMacOSXInitAppleEvents, 
                       _TkMacOSXInitMenus, _TkMacOSXInstallCursor, _TkMacOSXInvalClipRgns, 
                       _TkMacOSXInvalidateWindow, _TkMacOSXIsCharacterMissing, 
                       _TkMacOSXMakeRealWindowExist, _TkMacOSXMakeStippleMap, 
                       _TkMacOSXMenuClick, _TkMacOSXPreprocessMenu, _TkMacOSXRegisterOffScreenWindow, 
                       _TkMacOSXResizable, _TkMacOSXSetHelpMenuItemCount, 
                       _TkMacOSXSetScrollbarGrow, _TkMacOSXSetUpClippingRgn, 
                       _TkMacOSXSetUpGraphicsPort, _TkMacOSXUnregisterMacWindow, 
                       _TkMacOSXUpdateClipRgn, _TkMacOSXUseMenuID, _TkMacOSXVisableClipRgn, 
                       _TkMacOSXWinBounds, _TkMacOSXWindowOffset, _TkMacOSXZoomToplevel, 
                       _TkMakeBezierCurve, _TkMakeBezierPostscript, _TkMakeRawCurve, 
                       _TkMakeRawCurvePostscript, _TkOffsetParseProc, _TkOffsetPrintProc, 
                       _TkOptionClassChanged, _TkOptionDeadWindow, _TkOrientParseProc, 
                       _TkOrientPrintProc, _TkOvalToArea, _TkOvalToPoint, 
                       _TkPhotoGetValidRegion, _TkPixelParseProc, _TkPixelPrintProc, 
                       _TkPointerDeadWindow, _TkPointerEvent, _TkPolygonToArea, 
                       _TkPolygonToPoint, _TkPositionInTree, _TkPutImage, 
                       _TkQueueEventForAllChildren, _TkReadBitmapFile, 
                       _TkRectInRegion, _TkScrollWindow, _TkSelDeadWindow, 
                       _TkSelEventProc, _TkSelInit, _TkSelPropProc, _TkSetFocusWin, 
                       _TkSetMacColor, _TkSetRegion, _TkSetWMName, _TkSetWindowMenuBar, 
                       _TkSmoothParseProc, _TkSmoothPrintProc, _TkStateParseProc, 
                       _TkStatePrintProc, _TkStringToKeysym, _TkStylePkgFree, 
                       _TkStylePkgInit, _TkSubtractRegion, _TkSuspendClipboard, 
                       _TkThickPolyLineToArea, _TkToplevelWindowForCommand, 
                       _TkUnionRectWithRegion, _TkWmAddToColormapWindows, 
                       _TkWmDeadWindow, _TkWmFocusToplevel, _TkWmMapWindow, 
                       _TkWmNewWindow, _TkWmProtocolEventProc, _TkWmRemoveFromColormapWindows, 
                       _TkWmRestackToplevel, _TkWmSetClass, _TkWmStackorderToplevel, 
                       _TkWmUnmapWindow, _Tk_3DBorderColor, _Tk_3DBorderGC, 
                       _Tk_3DHorizontalBevel, _Tk_3DVerticalBevel, _Tk_AddOption, 
                       _Tk_Alloc3DBorderFromObj, _Tk_AllocBitmapFromObj, 
                       _Tk_AllocColorFromObj, _Tk_AllocCursorFromObj, _Tk_AllocFontFromObj, 
                       _Tk_AllocStyleFromObj, _Tk_BindEvent, _Tk_CanvasDrawableCoords, 
                       _Tk_CanvasEventuallyRedraw, _Tk_CanvasGetCoord, 
                       _Tk_CanvasGetCoordFromObj, _Tk_CanvasGetTextInfo, 
                       _Tk_CanvasPsBitmap, _Tk_CanvasPsColor, _Tk_CanvasPsFont, 
                       _Tk_CanvasPsOutline, _Tk_CanvasPsPath, _Tk_CanvasPsStipple, 
                       _Tk_CanvasPsY, _Tk_CanvasSetOffset, _Tk_CanvasSetStippleOrigin, 
                       _Tk_CanvasTagsParseProc, _Tk_CanvasTagsPrintProc, 
                       _Tk_CanvasTkwin, _Tk_CanvasWindowCoords, _Tk_ChangeOutlineGC, 
                       _Tk_ChangeWindowAttributes, _Tk_CharBbox, _Tk_ClearSelection, 
                       _Tk_ClipboardAppend, _Tk_ClipboardClear, _Tk_CollapseMotionEvents, 
                       _Tk_ComputeTextLayout, _Tk_ConfigOutlineGC, _Tk_ConfigureInfo, 
                       _Tk_ConfigureValue, _Tk_ConfigureWidget, _Tk_ConfigureWindow, 
                       _Tk_CoordsToWindow, _Tk_CreateAnonymousWindow, _Tk_CreateBinding, 
                       _Tk_CreateBindingTable, _Tk_CreateClientMessageHandler, 
                       _Tk_CreateConsoleWindow, _Tk_CreateErrorHandler, 
                       _Tk_CreateEventHandler, _Tk_CreateGenericHandler, 
                       _Tk_CreateImageType, _Tk_CreateItemType, _Tk_CreateOldImageType, 
                       _Tk_CreateOldPhotoImageFormat, _Tk_CreateOptionTable, 
                       _Tk_CreateOutline, _Tk_CreatePhotoImageFormat, _Tk_CreateSelHandler, 
                       _Tk_CreateSmoothMethod, _Tk_CreateStyle, _Tk_CreateWindow, 
                       _Tk_CreateWindowFromPath, _Tk_DefineBitmap, _Tk_DefineCursor, 
                       _Tk_DeleteAllBindings, _Tk_DeleteBinding, _Tk_DeleteBindingTable, 
                       _Tk_DeleteClientMessageHandler, _Tk_DeleteErrorHandler, 
                       _Tk_DeleteEventHandler, _Tk_DeleteGenericHandler, 
                       _Tk_DeleteImage, _Tk_DeleteOptionTable, _Tk_DeleteOutline, 
                       _Tk_DeleteSelHandler, _Tk_DestroyWindow, _Tk_DisplayName, 
                       _Tk_DistanceToTextLayout, _Tk_DitherPhoto, _Tk_Draw3DPolygon, 
                       _Tk_Draw3DRectangle, _Tk_DrawChars, _Tk_DrawElement, 
                       _Tk_DrawFocusHighlight, _Tk_DrawTextLayout, _Tk_Fill3DPolygon, 
                       _Tk_Fill3DRectangle, _Tk_FindPhoto, _Tk_FontId, 
                       _Tk_Free3DBorder, _Tk_Free3DBorderFromObj, _Tk_FreeBitmap, 
                       _Tk_FreeBitmapFromObj, _Tk_FreeColor, _Tk_FreeColorFromObj, 
                       _Tk_FreeColormap, _Tk_FreeConfigOptions, _Tk_FreeCursor, 
                       _Tk_FreeCursorFromObj, _Tk_FreeFont, _Tk_FreeFontFromObj, 
                       _Tk_FreeGC, _Tk_FreeImage, _Tk_FreeOptions, _Tk_FreePixmap, 
                       _Tk_FreeSavedOptions, _Tk_FreeStyle, _Tk_FreeStyleFromObj, 
                       _Tk_FreeTextLayout, _Tk_FreeXId, _Tk_GCForColor, 
                       _Tk_GeometryRequest, _Tk_Get3DBorder, _Tk_Get3DBorderFromObj, 
                       _Tk_GetAllBindings, _Tk_GetAnchor, _Tk_GetAnchorFromObj, 
                       _Tk_GetAtomName, _Tk_GetBinding, _Tk_GetBitmap, 
                       _Tk_GetBitmapFromData, _Tk_GetBitmapFromObj, _Tk_GetCapStyle, 
                       _Tk_GetColor, _Tk_GetColorByValue, _Tk_GetColorFromObj, 
                       _Tk_GetColormap, _Tk_GetCursor, _Tk_GetCursorFromData, 
                       _Tk_GetCursorFromObj, _Tk_GetDash, _Tk_GetElementBorderWidth, 
                       _Tk_GetElementBox, _Tk_GetElementId, _Tk_GetElementSize, 
                       _Tk_GetFont, _Tk_GetFontFromObj, _Tk_GetFontMetrics, 
                       _Tk_GetGC, _Tk_GetImage, _Tk_GetImageMasterData, 
                       _Tk_GetItemTypes, _Tk_GetJoinStyle, _Tk_GetJustify, 
                       _Tk_GetJustifyFromObj, _Tk_GetMMFromObj, _Tk_GetNumMainWindows, 
                       _Tk_GetOption, _Tk_GetOptionInfo, _Tk_GetOptionValue, 
                       _Tk_GetPixels, _Tk_GetPixelsFromObj, _Tk_GetPixmap, 
                       _Tk_GetRelief, _Tk_GetReliefFromObj, _Tk_GetRootCoords, 
                       _Tk_GetScreenMM, _Tk_GetScrollInfo, _Tk_GetScrollInfoObj, 
                       _Tk_GetSelection, _Tk_GetStyle, _Tk_GetStyleEngine, 
                       _Tk_GetStyleFromObj, _Tk_GetStyledElement, _Tk_GetUid, 
                       _Tk_GetUserInactiveTime, _Tk_GetVRootGeometry, _Tk_GetVisual, 
                       _Tk_Grab, _Tk_HandleEvent, _Tk_IdToWindow, _Tk_ImageChanged, 
                       _Tk_Init, _Tk_InitConsoleChannels, _Tk_InitOptions, 
                       _Tk_InitStubs, _Tk_InternAtom, _Tk_Interp, _Tk_IntersectTextLayout, 
                       _Tk_MacOSXIsAppInFront, _Tk_MacOSXSetEmbedHandler, 
                       _Tk_MacOSXSetupTkNotifier, _Tk_MacOSXTkOwnsCursor, 
                       _Tk_MacOSXTurnOffMenus, _Tk_MainEx, _Tk_MainLoop, 
                       _Tk_MainWindow, _Tk_MaintainGeometry, _Tk_MakeWindowExist, 
                       _Tk_ManageGeometry, _Tk_MapWindow, _Tk_MeasureChars, 
                       _Tk_MoveResizeWindow, _Tk_MoveToplevelWindow, _Tk_MoveWindow, 
                       _Tk_NameOf3DBorder, _Tk_NameOfAnchor, _Tk_NameOfBitmap, 
                       _Tk_NameOfCapStyle, _Tk_NameOfColor, _Tk_NameOfCursor, 
                       _Tk_NameOfFont, _Tk_NameOfImage, _Tk_NameOfJoinStyle, 
                       _Tk_NameOfJustify, _Tk_NameOfRelief, _Tk_NameOfStyle, 
                       _Tk_NameToWindow, _Tk_OwnSelection, _Tk_ParseArgv, 
                       _Tk_PhotoBlank, _Tk_PhotoExpand, _Tk_PhotoExpand_Panic, 
                       _Tk_PhotoGetImage, _Tk_PhotoGetSize, _Tk_PhotoPutBlock, 
                       _Tk_PhotoPutBlock_NoComposite, _Tk_PhotoPutBlock_Panic, 
                       _Tk_PhotoPutZoomedBlock, _Tk_PhotoPutZoomedBlock_NoComposite, 
                       _Tk_PhotoPutZoomedBlock_Panic, _Tk_PhotoSetSize, 
                       _Tk_PhotoSetSize_Panic, _Tk_PkgInitStubsCheck, _Tk_PointToChar, 
                       _Tk_PostscriptBitmap, _Tk_PostscriptColor, _Tk_PostscriptFont, 
                       _Tk_PostscriptFontName, _Tk_PostscriptImage, _Tk_PostscriptPath, 
                       _Tk_PostscriptPhoto, _Tk_PostscriptStipple, _Tk_PostscriptY, 
                       _Tk_PreserveColormap, _Tk_QueueWindowEvent, _Tk_RedrawImage, 
                       _Tk_RegisterStyleEngine, _Tk_RegisterStyledElement, 
                       _Tk_ResetOutlineGC, _Tk_ResetUserInactiveTime, _Tk_ResizeWindow, 
                       _Tk_RestackWindow, _Tk_RestoreSavedOptions, _Tk_RestrictEvents, 
                       _Tk_SafeInit, _Tk_SetAppName, _Tk_SetBackgroundFromBorder, 
                       _Tk_SetCaretPos, _Tk_SetClass, _Tk_SetClassProcs, 
                       _Tk_SetGrid, _Tk_SetInternalBorder, _Tk_SetInternalBorderEx, 
                       _Tk_SetMinimumRequestSize, _Tk_SetOptions, _Tk_SetTSOrigin, 
                       _Tk_SetWindowBackground, _Tk_SetWindowBackgroundPixmap, 
                       _Tk_SetWindowBorder, _Tk_SetWindowBorderPixmap, 
                       _Tk_SetWindowBorderWidth, _Tk_SetWindowColormap, 
                       _Tk_SetWindowVisual, _Tk_SizeOfBitmap, _Tk_SizeOfImage, 
                       _Tk_StrictMotif, _Tk_TextLayoutToPostscript, _Tk_TextWidth, 
                       _Tk_TopCoordsToWindow, _Tk_UndefineCursor, _Tk_UnderlineChars, 
                       _Tk_UnderlineTextLayout, _Tk_Ungrab, _Tk_UnmaintainGeometry, 
                       _Tk_UnmapWindow, _Tk_UnsetGrid, _Tk_UpdatePointer, 
                       _TkpChangeFocus, _TkpClaimFocus, _TkpCloseDisplay, 
                       _TkpCreateNativeBitmap, _TkpDefineNativeBitmaps, 
                       _TkpDisplayWarning, _TkpDrawFrame, _TkpDrawHighlightBorder, 
                       _TkpFreeCursor, _TkpGetAppName, _TkpGetKeySym, _TkpGetMS, 
                       _TkpGetNativeAppBitmap, _TkpGetOtherWindow, _TkpGetString, 
                       _TkpGetSubFonts, _TkpGetSystemDefault, _TkpGetWrapperWindow, 
                       _TkpInit, _TkpInitKeymapInfo, _TkpInitializeMenuBindings, 
                       _TkpIsWindowFloating, _TkpMakeContainer, _TkpMakeMenuWindow, 
                       _TkpMakeWindow, _TkpMenuNotifyToplevelCreate, _TkpMenuThreadInit, 
                       _TkpOpenDisplay, _TkpRedirectKeyEvent, _TkpSetCapture, 
                       _TkpSetCursor, _TkpSetKeycodeAndState, _TkpSetMainMenubar, 
                       _TkpTestembedCmd, _TkpTesttextCmd, _TkpUseWindow, 
                       _TkpWindowWasRecentlyDeleted, _TkpWmSetState, _XAllocColor, 
                       _XBell, _XChangeGC, _XChangeProperty, _XChangeWindowAttributes, 
                       _XClearWindow, _XConfigureWindow, _XCopyArea, _XCopyPlane, 
                       _XCreateBitmapFromData, _XCreateColormap, _XCreateGC, 
                       _XCreateIC, _XCreateImage, _XDefineCursor, _XDestroyWindow, 
                       _XDrawArc, _XDrawLine, _XDrawLines, _XDrawPoint, 
                       _XDrawPoints, _XDrawRectangle, _XDrawSegments, _XFillArc, 
                       _XFillPolygon, _XFillRectangle, _XFillRectangles, 
                       _XForceScreenSaver, _XFreeColormap, _XFreeColors, 
                       _XFreeGC, _XFreeModifiermap, _XGContextFromGC, _XGetAtomName, 
                       _XGetGeometry, _XGetImage, _XGetModifierMapping, 
                       _XGetVisualInfo, _XGetWindowProperty, _XGrabKeyboard, 
                       _XGrabPointer, _XInternAtom, _XKeycodeToKeysym, 
                       _XKeysymToKeycode, _XKeysymToString, _XMapWindow, 
                       _XMoveResizeWindow, _XMoveWindow, _XParseColor, 
                       _XQueryColor, _XQueryColors, _XQueryPointer, _XQueryTree, 
                       _XRaiseWindow, _XRefreshKeyboardMapping, _XResizeWindow, 
                       _XRootWindow, _XSelectInput, _XSendEvent, _XSetArcMode, 
                       _XSetBackground, _XSetClipMask, _XSetClipOrigin, 
                       _XSetDashes, _XSetErrorHandler, _XSetFillRule, _XSetFillStyle, 
                       _XSetFont, _XSetForeground, _XSetFunction, _XSetIconName, 
                       _XSetInputFocus, _XSetLineAttributes, _XSetSelectionOwner, 
                       _XSetStipple, _XSetTSOrigin, _XSetWMClientMachine, 
                       _XSetWindowBackground, _XSetWindowBackgroundPixmap, 
                       _XSetWindowBorder, _XSetWindowBorderPixmap, _XSetWindowBorderWidth, 
                       _XSetWindowColormap, _XStringListToTextProperty, 
                       _XStringToKeysym, _XSync, _XUngrabKeyboard, _XUngrabPointer, 
                       _XUnmapWindow, _XWarpPointer, __XInitImageFuncPtrs, 
                       _tkIntPlatStubsPtr, _tkIntStubsPtr, _tkIntXlibStubsPtr, 
                       _tkPlatStubsPtr, _tkStubsPtr ]
...
                                                                                                                                                                                                                                                                                         libtkstub8.5.a                                                                                      0100644 0001750 0001750 00000016060 12566232730 031362  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Tk.framework/Versions/8.5                                                                                